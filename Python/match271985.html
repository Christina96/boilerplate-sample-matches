<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for gen.py &amp; version.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for gen.py &amp; version.py
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>gen.py (0.9456265%)<th>version.py (0.7707129%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(986-991)<td><a href="#" name="0">(319-324)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>gen.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 import collections
3 import functools
4 import itertools
5 import os
6 import sys
7 import textwrap
8 import types
9 import weakref
10 import salt.ext.tornado as tornado
11 from salt.ext.tornado.concurrent import Future, TracebackFuture, is_future, chain_future
12 from salt.ext.tornado.ioloop import IOLoop
13 from salt.ext.tornado.log import app_log
14 from salt.ext.tornado import stack_context
15 from salt.ext.tornado.util import PY3, raise_exc_info
16 try:
17     try:
18         from functools import singledispatch  # type: ignore
19     except ImportError:
20         from singledispatch import singledispatch  # backport
21 except ImportError:
22     if 'APPENGINE_RUNTIME' not in os.environ:
23         raise
24     singledispatch = None
25 try:
26     try:
27         from collections.abc import Generator as GeneratorType  # type: ignore
28     except ImportError:
29         from salt.ext.backports_abc import Generator as GeneratorType  # type: ignore
30     try:
31         from inspect import isawaitable  # type: ignore
32     except ImportError:
33         from salt.ext.backports_abc import isawaitable
34 except ImportError:
35     if 'APPENGINE_RUNTIME' not in os.environ:
36         raise
37     from types import GeneratorType
38     def isawaitable(x):  # type: ignore
39         return False
40 if PY3:
41     import builtins
42 else:
43     import __builtin__ as builtins
44 class KeyReuseError(Exception):
45     pass
46 class UnknownKeyError(Exception):
47     pass
48 class LeakedCallbackError(Exception):
49     pass
50 class BadYieldError(Exception):
51     pass
52 class ReturnValueIgnoredError(Exception):
53     pass
54 class TimeoutError(Exception):
55 def _value_from_stopiteration(e):
56     try:
57         return e.value
58     except AttributeError:
59         pass
60     try:
61         return e.args[0]
62     except (AttributeError, IndexError):
63         return None
64 def engine(func):
65     func = _make_coroutine_wrapper(func, replace_callback=False)
66     @functools.wraps(func)
67     def wrapper(*args, **kwargs):
68         future = func(*args, **kwargs)
69         def final_callback(future):
70             if future.result() is not None:
71                 raise ReturnValueIgnoredError(
72                     "@gen.engine functions cannot return values: %r" %
73                     (future.result(),))
74         future.add_done_callback(stack_context.wrap(final_callback))
75     return wrapper
76 def coroutine(func, replace_callback=True):
77     return _make_coroutine_wrapper(func, replace_callback=True)
78 _futures_to_runners = weakref.WeakKeyDictionary()
79 def _make_coroutine_wrapper(func, replace_callback):
80     wrapped = func
81     if hasattr(types, 'coroutine'):
82         func = types.coroutine(func)
83     @functools.wraps(wrapped)
84     def wrapper(*args, **kwargs):
85         future = TracebackFuture()
86         if replace_callback and 'callback' in kwargs:
87             callback = kwargs.pop('callback')
88             IOLoop.current().add_future(
89                 future, lambda future: callback(future.result()))
90         try:
91             result = func(*args, **kwargs)
92         except (Return, StopIteration) as e:
93             result = _value_from_stopiteration(e)
94         except Exception:
95             future.set_exc_info(sys.exc_info())
96             return future
97         else:
98             if isinstance(result, GeneratorType):
99                 try:
100                     orig_stack_contexts = stack_context._state.contexts
101                     yielded = next(result)
102                     if stack_context._state.contexts is not orig_stack_contexts:
103                         yielded = TracebackFuture()
104                         yielded.set_exception(
105                             stack_context.StackContextInconsistentError(
106                                 'stack_context inconsistency (probably caused '
107                                 'by yield within a "with StackContext" block)'))
108                 except (StopIteration, Return) as e:
109                     future.set_result(_value_from_stopiteration(e))
110                 except Exception:
111                     future.set_exc_info(sys.exc_info())
112                 else:
113                     _futures_to_runners[future] = Runner(result, future, yielded)
114                 yielded = None
115                 try:
116                     return future
117                 finally:
118                     future = None
119         future.set_result(result)
120         return future
121     wrapper.__wrapped__ = wrapped
122     wrapper.__tornado_coroutine__ = True
123     return wrapper
124 def is_coroutine_function(func):
125     return getattr(func, '__tornado_coroutine__', False)
126 class Return(Exception):
127     def __init__(self, value=None):
128         super(Return, self).__init__()
129         self.value = value
130         self.args = (value,)
131 class WaitIterator(object):
132     def __init__(self, *args, **kwargs):
133         if args and kwargs:
134             raise ValueError(
135                 "You must provide args or kwargs, not both")
136         if kwargs:
137             self._unfinished = dict((f, k) for (k, f) in kwargs.items())
138             futures = list(kwargs.values())
139         else:
140             self._unfinished = dict((f, i) for (i, f) in enumerate(args))
141             futures = args
142         self._finished = collections.deque()
143         self.current_index = self.current_future = None
144         self._running_future = None
145         for future in futures:
146             future.add_done_callback(self._done_callback)
147     def done(self):
148         if self._finished or self._unfinished:
149             return False
150         self.current_index = self.current_future = None
151         return True
152     def next(self):
153         self._running_future = TracebackFuture()
154         if self._finished:
155             self._return_result(self._finished.popleft())
156         return self._running_future
157     def _done_callback(self, done):
158         if self._running_future and not self._running_future.done():
159             self._return_result(done)
160         else:
161             self._finished.append(done)
162     def _return_result(self, done):
163         chain_future(done, self._running_future)
164         self.current_future = done
165         self.current_index = self._unfinished.pop(done)
166     def __aiter__(self):
167         raise self
168     def __anext__(self):
169         if self.done():
170             raise getattr(builtins, 'StopAsyncIteration')()
171         return self.next()
172 class YieldPoint(object):
173     def start(self, runner):
174         raise NotImplementedError()
175     def is_ready(self):
176         raise NotImplementedError()
177     def get_result(self):
178         raise NotImplementedError()
179 class Callback(YieldPoint):
180     def __init__(self, key):
181         self.key = key
182     def start(self, runner):
183         self.runner = runner
184         runner.register_callback(self.key)
185     def is_ready(self):
186         return True
187     def get_result(self):
188         return self.runner.result_callback(self.key)
189 class Wait(YieldPoint):
190     def __init__(self, key):
191         self.key = key
192     def start(self, runner):
193         self.runner = runner
194     def is_ready(self):
195         return self.runner.is_ready(self.key)
196     def get_result(self):
197         return self.runner.pop_result(self.key)
198 class WaitAll(YieldPoint):
199     def __init__(self, keys):
200         self.keys = keys
201     def start(self, runner):
202         self.runner = runner
203     def is_ready(self):
204         return all(self.runner.is_ready(key) for key in self.keys)
205     def get_result(self):
206         return [self.runner.pop_result(key) for key in self.keys]
207 def Task(func, *args, **kwargs):
208     future = Future()
209     def handle_exception(typ, value, tb):
210         if future.done():
211             return False
212         future.set_exc_info((typ, value, tb))
213         return True
214     def set_result(result):
215         if future.done():
216             return
217         future.set_result(result)
218     with stack_context.ExceptionStackContext(handle_exception):
219         func(*args, callback=_argument_adapter(set_result), **kwargs)
220     return future
221 class YieldFuture(YieldPoint):
222     def __init__(self, future, io_loop=None):
223         self.future = future
224         self.io_loop = io_loop or IOLoop.current()
225     def start(self, runner):
226         if not self.future.done():
227             self.runner = runner
228             self.key = object()
229             runner.register_callback(self.key)
230             self.io_loop.add_future(self.future, runner.result_callback(self.key))
231         else:
232             self.runner = None
233             self.result_fn = self.future.result
234     def is_ready(self):
235         if self.runner is not None:
236             return self.runner.is_ready(self.key)
237         else:
238             return True
239     def get_result(self):
240         if self.runner is not None:
241             return self.runner.pop_result(self.key).result()
242         else:
243             return self.result_fn()
244 def _contains_yieldpoint(children):
245     if isinstance(children, dict):
246         return any(isinstance(i, YieldPoint) for i in children.values())
247     if isinstance(children, list):
248         return any(isinstance(i, YieldPoint) for i in children)
249     return False
250 def multi(children, quiet_exceptions=()):
251     if _contains_yieldpoint(children):
252         return MultiYieldPoint(children, quiet_exceptions=quiet_exceptions)
253     else:
254         return multi_future(children, quiet_exceptions=quiet_exceptions)
255 Multi = multi
256 class MultiYieldPoint(YieldPoint):
257     def __init__(self, children, quiet_exceptions=()):
258         self.keys = None
259         if isinstance(children, dict):
260             self.keys = list(children.keys())
261             children = children.values()
262         self.children = []
263         for i in children:
264             if not isinstance(i, YieldPoint):
265                 i = convert_yielded(i)
266             if is_future(i):
267                 i = YieldFuture(i)
268             self.children.append(i)
269         assert all(isinstance(i, YieldPoint) for i in self.children)
270         self.unfinished_children = set(self.children)
271         self.quiet_exceptions = quiet_exceptions
272     def start(self, runner):
273         for i in self.children:
274             i.start(runner)
275     def is_ready(self):
276         finished = list(itertools.takewhile(
277             lambda i: i.is_ready(), self.unfinished_children))
278         self.unfinished_children.difference_update(finished)
279         return not self.unfinished_children
280     def get_result(self):
281         result_list = []
282         exc_info = None
283         for f in self.children:
284             try:
285                 result_list.append(f.get_result())
286             except Exception as e:
287                 if exc_info is None:
288                     exc_info = sys.exc_info()
289                 else:
290                     if not isinstance(e, self.quiet_exceptions):
291                         app_log.error("Multiple exceptions in yield list",
292                                       exc_info=True)
293         if exc_info is not None:
294             raise_exc_info(exc_info)
295         if self.keys is not None:
296             return dict(zip(self.keys, result_list))
297         else:
298             return list(result_list)
299 def multi_future(children, quiet_exceptions=()):
300     if isinstance(children, dict):
301         keys = list(children.keys())
302         children = children.values()
303     else:
304         keys = None
305     children = list(map(convert_yielded, children))
306     assert all(is_future(i) for i in children)
307     unfinished_children = set(children)
308     future = Future()
309     if not children:
310         future.set_result({} if keys is not None else [])
311     def callback(f):
312         unfinished_children.remove(f)
313         if not unfinished_children:
314             result_list = []
315             for f in children:
316                 try:
317                     result_list.append(f.result())
318                 except Exception as e:
319                     if future.done():
320                         if not isinstance(e, quiet_exceptions):
321                             app_log.error("Multiple exceptions in yield list",
322                                           exc_info=True)
323                     else:
324                         future.set_exc_info(sys.exc_info())
325             if not future.done():
326                 if keys is not None:
327                     future.set_result(dict(zip(keys, result_list)))
328                 else:
329                     future.set_result(result_list)
330     listening = set()
331     for f in children:
332         if f not in listening:
333             listening.add(f)
334             f.add_done_callback(callback)
335     return future
336 def maybe_future(x):
337     if is_future(x):
338         return x
339     else:
340         fut = Future()
341         fut.set_result(x)
342         return fut
343 def with_timeout(timeout, future, io_loop=None, quiet_exceptions=()):
344     future = convert_yielded(future)
345     result = Future()
346     chain_future(future, result)
347     if io_loop is None:
348         io_loop = IOLoop.current()
349     def error_callback(future):
350         try:
351             future.result()
352         except Exception as e:
353             if not isinstance(e, quiet_exceptions):
354                 app_log.error("Exception in Future %r after timeout",
355                               future, exc_info=True)
356     def timeout_callback():
357         result.set_exception(TimeoutError("Timeout"))
358         future.add_done_callback(error_callback)
359     timeout_handle = io_loop.add_timeout(
360         timeout, timeout_callback)
361     if isinstance(future, Future):
362         future.add_done_callback(
363             lambda future: io_loop.remove_timeout(timeout_handle))
364     else:
365         io_loop.add_future(
366             future, lambda future: io_loop.remove_timeout(timeout_handle))
367     return result
368 def sleep(duration):
369     f = Future()
370     IOLoop.current().call_later(duration, lambda: f.set_result(None))
371     return f
372 _null_future = Future()
373 _null_future.set_result(None)
374 moment = Future()
375 moment.__doc__ = \
376 moment.set_result(None)
377 class Runner(object):
378     def __init__(self, gen, result_future, first_yielded):
379         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.gen = gen
380         self.result_future = result_future
381         self.future = _null_future
382         self.yield_point = None
383         self.pending_callbacks = None
384         self.results =</b></font> None
385         self.running = False
386         self.finished = False
387         self.had_exception = False
388         self.io_loop = IOLoop.current()
389         self.stack_context_deactivate = None
390         if self.handle_yield(first_yielded):
391             gen = result_future = first_yielded = None
392             self.run()
393     def register_callback(self, key):
394         if self.pending_callbacks is None:
395             self.pending_callbacks = set()
396             self.results = {}
397         if key in self.pending_callbacks:
398             raise KeyReuseError("key %r is already pending" % (key,))
399         self.pending_callbacks.add(key)
400     def is_ready(self, key):
401         if self.pending_callbacks is None or key not in self.pending_callbacks:
402             raise UnknownKeyError("key %r is not pending" % (key,))
403         return key in self.results
404     def set_result(self, key, result):
405         self.results[key] = result
406         if self.yield_point is not None and self.yield_point.is_ready():
407             try:
408                 self.future.set_result(self.yield_point.get_result())
409             except:
410                 self.future.set_exc_info(sys.exc_info())
411             self.yield_point = None
412             self.run()
413     def pop_result(self, key):
414         self.pending_callbacks.remove(key)
415         return self.results.pop(key)
416     def run(self):
417         if self.running or self.finished:
418             return
419         try:
420             self.running = True
421             while True:
422                 future = self.future
423                 if not future.done():
424                     return
425                 self.future = None
426                 try:
427                     orig_stack_contexts = stack_context._state.contexts
428                     exc_info = None
429                     try:
430                         value = future.result()
431                     except Exception:
432                         self.had_exception = True
433                         exc_info = sys.exc_info()
434                     future = None
435                     if exc_info is not None:
436                         try:
437                             yielded = self.gen.throw(*exc_info)
438                         finally:
439                             exc_info = None
440                     else:
441                         yielded = self.gen.send(value)
442                     if stack_context._state.contexts is not orig_stack_contexts:
443                         self.gen.throw(
444                             stack_context.StackContextInconsistentError(
445                                 'stack_context inconsistency (probably caused '
446                                 'by yield within a "with StackContext" block)'))
447                 except (StopIteration, Return) as e:
448                     self.finished = True
449                     self.future = _null_future
450                     if self.pending_callbacks and not self.had_exception:
451                         raise LeakedCallbackError(
452                             "finished without waiting for callbacks %r" %
453                             self.pending_callbacks)
454                     self.result_future.set_result(_value_from_stopiteration(e))
455                     self.result_future = None
456                     self._deactivate_stack_context()
457                     return
458                 except Exception:
459                     self.finished = True
460                     self.future = _null_future
461                     self.result_future.set_exc_info(sys.exc_info())
462                     self.result_future = None
463                     self._deactivate_stack_context()
464                     return
465                 if not self.handle_yield(yielded):
466                     return
467                 yielded = None
468         finally:
469             self.running = False
470     def handle_yield(self, yielded):
471         if _contains_yieldpoint(yielded):
472             yielded = multi(yielded)
473         if isinstance(yielded, YieldPoint):
474             self.future = TracebackFuture()
475             def start_yield_point():
476                 try:
477                     yielded.start(self)
478                     if yielded.is_ready():
479                         self.future.set_result(
480                             yielded.get_result())
481                     else:
482                         self.yield_point = yielded
483                 except Exception:
484                     self.future = TracebackFuture()
485                     self.future.set_exc_info(sys.exc_info())
486             if self.stack_context_deactivate is None:
487                 with stack_context.ExceptionStackContext(
488                         self.handle_exception) as deactivate:
489                     self.stack_context_deactivate = deactivate
490                     def cb():
491                         start_yield_point()
492                         self.run()
493                     self.io_loop.add_callback(cb)
494                     return False
495             else:
496                 start_yield_point()
497         else:
498             try:
499                 self.future = convert_yielded(yielded)
500             except BadYieldError:
501                 self.future = TracebackFuture()
502                 self.future.set_exc_info(sys.exc_info())
503         if not self.future.done() or self.future is moment:
504             def inner(f):
505                 f = None # noqa
506                 self.run()
507             self.io_loop.add_future(
508                 self.future, inner)
509             return False
510         return True
511     def result_callback(self, key):
512         return stack_context.wrap(_argument_adapter(
513             functools.partial(self.set_result, key)))
514     def handle_exception(self, typ, value, tb):
515         if not self.running and not self.finished:
516             self.future = TracebackFuture()
517             self.future.set_exc_info((typ, value, tb))
518             self.run()
519             return True
520         else:
521             return False
522     def _deactivate_stack_context(self):
523         if self.stack_context_deactivate is not None:
524             self.stack_context_deactivate()
525             self.stack_context_deactivate = None
526 Arguments = collections.namedtuple('Arguments', ['args', 'kwargs'])
527 def _argument_adapter(callback):
528     def wrapper(*args, **kwargs):
529         if kwargs or len(args) &gt; 1:
530             callback(Arguments(args, kwargs))
531         elif args:
532             callback(args[0])
533         else:
534             callback(None)
535     return wrapper
536 if sys.version_info &gt;= (3, 3):
537     exec(textwrap.dedent("""
538     @coroutine
539     def _wrap_awaitable(x):
540         if hasattr(x, '__await__'):
541             x = x.__await__()
542         return (yield from x)
543     The default implementation accepts lists, dictionaries, and Futures.
544     If the `~functools.singledispatch` library is available, this function
545     may be extended to support additional types. For example::
546         @convert_yielded.register(asyncio.Future)
547         def _(asyncio_future):
548             return tornado.platform.asyncio.to_tornado_future(asyncio_future)
549     .. versionadded:: 4.1
550 Set up the version of Salt
551     Handle SaltStack versions class.
552     Knows how to parse ``git describe`` output, knows about release candidates
553     and also supports version comparison.
554         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.major = major
555         self.minor = minor
556         self.bugfix = bugfix
557         self.mbugfix = mbugfix
558         self.pre_type = pre_type
559         self.pre_num =</b></font> pre_num
560         if self.new_version(major):
561             vnames_key = (major,)
562         else:
563             vnames_key = (major, minor)
564         self.name = self.VNAMES.get(vnames_key)
565         self.noc = noc
566         self.sha = sha
567     def new_version(self, major):
568         return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)
569     @classmethod
570     def parse(cls, version_string):
571         if version_string.lower() in cls.LNAMES:
572             return cls.from_name(version_string)
573         vstr = (
574             version_string.decode()
575             if isinstance(version_string, bytes)
576             else version_string
577         )
578         match = cls.git_describe_regex.match(vstr)
579         if not match:
580             raise ValueError(
581                 "Unable to parse version string: '{}'".format(version_string)
582             )
583         return cls(*match.groups())
584     @classmethod
585     def from_name(cls, name):
586         if name.lower() not in cls.LNAMES:
587             raise ValueError("Named version '{}' is not known".format(name))
588         return cls(*cls.LNAMES[name.lower()])
589     @classmethod
590     def from_last_named_version(cls):
591         import salt.utils.versions
592         salt.utils.versions.warn_until(
593             SaltVersionsInfo.SULFUR,
594             "The use of SaltStackVersion.from_last_named_version() is "
595             "deprecated and set to be removed in {version}. Please use "
596             "SaltStackVersion.current_release() instead.",
597         )
598         return cls.current_release()
599     @classmethod
600     def current_release(cls):
601         return cls(*SaltVersionsInfo.current_release().info)
602     @classmethod
603     def next_release(cls):
604         return cls(*SaltVersionsInfo.next_release().info)
605     @property
606     def sse(self):
607         return 0 &lt; self.major &lt; 2014
608     def min_info(self):
609         info = [self.major]
610         if self.new_version(self.major):
611             if self.minor:
612                 info.append(self.minor)
613         else:
614             info.extend([self.minor, self.bugfix, self.mbugfix])
615         return info
616     @property
617     def info(self):
618         return tuple(self.min_info())
619     @property
620     def pre_info(self):
621         info = self.min_info()
622         info.extend([self.pre_type, self.pre_num])
623         return tuple(info)
624     @property
625     def noc_info(self):
626         info = self.min_info()
627         info.extend([self.pre_type, self.pre_num, self.noc])
628         return tuple(info)
629     @property
630     def full_info(self):
631         info = self.min_info()
632         info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
633         return tuple(info)
634     @property
635     def full_info_all_versions(self):
636         info = [
637             self.major,
638             self.minor,
639             self.bugfix,
640             self.mbugfix,
641             self.pre_type,
642             self.pre_num,
643             self.noc,
644             self.sha,
645         ]
646         return tuple(info)
647     @property
648     def string(self):
649         if self.new_version(self.major):
650             version_string = "{}".format(self.major)
651             if self.minor:
652                 version_string = "{}.{}".format(self.major, self.minor)
653         else:
654             version_string = "{}.{}.{}".format(self.major, self.minor, self.bugfix)
655         if self.mbugfix:
656             version_string += ".{}".format(self.mbugfix)
657         if self.pre_type:
658             version_string += "{}{}".format(self.pre_type, self.pre_num)
659         if self.noc and self.sha:
660             noc = self.noc
661             if noc &lt; 0:
662                 noc = "0na"
663             version_string += "+{}.{}".format(noc, self.sha)
664         return version_string
665     @property
666     def formatted_version(self):
667         if self.name and self.major &gt; 10000:
668             version_string = self.name
669             if self.sse:
670                 version_string += " Enterprise"
671             version_string += " (Unreleased)"
672             return version_string
673         version_string = self.string
674         if self.sse:
675             version_string += " Enterprise"
676         if (self.major, self.minor) in self.RMATCH:
677             version_string += " ({})".format(self.RMATCH[(self.major, self.minor)])
678         return version_string
679     @property
680     def pre_index(self):
681         if self.new_version(self.major):
682             pre_type = 2
683             if not isinstance(self.minor, int):
684                 pre_type = 1
685         else:
686             pre_type = 4
687         return pre_type
688     def __str__(self):
689         return self.string
690     def __compare__(self, other, method):
691         if not isinstance(other, SaltStackVersion):
692             if isinstance(other, str):
693                 other = SaltStackVersion.parse(other)
694             elif isinstance(other, (list, tuple)):
695                 other = SaltStackVersion(*other)
696             else:
697                 raise ValueError(
698                     "Cannot instantiate Version from type '{}'".format(type(other))
699                 )
700         pre_type = self.pre_index
701         other_pre_type = other.pre_index
702         other_noc_info = list(other.noc_info)
703         noc_info = list(self.noc_info)
704         if self.new_version(self.major):
705             if self.minor and not other.minor:
706                 if self.minor &gt; 0:
707                     other_noc_info[1] = 0
708             if not self.minor and other.minor:
709                 if other.minor &gt; 0:
710                     noc_info[1] = 0
711         if self.pre_type and not other.pre_type:
712             other_noc_info[other_pre_type] = "zzzzz"
713         if not self.pre_type and other.pre_type:
714             noc_info[pre_type] = "zzzzz"
715         return method(tuple(noc_info), tuple(other_noc_info))
716     def __lt__(self, other):
717         return self.__compare__(other, lambda _self, _other: _self &lt; _other)
718     def __le__(self, other):
719         return self.__compare__(other, lambda _self, _other: _self &lt;= _other)
720     def __eq__(self, other):
721         return self.__compare__(other, lambda _self, _other: _self == _other)
722     def __ne__(self, other):
723         return self.__compare__(other, lambda _self, _other: _self != _other)
724     def __ge__(self, other):
725         return self.__compare__(other, lambda _self, _other: _self &gt;= _other)
726     def __gt__(self, other):
727         return self.__compare__(other, lambda _self, _other: _self &gt; _other)
728     def __repr__(self):
729         parts = []
730         if self.name:
731             parts.append("name='{}'".format(self.name))
732         parts.extend(["major={}".format(self.major), "minor={}".format(self.minor)])
733         if self.new_version(self.major):
734             if not self.minor:
735                 parts.remove("".join([x for x in parts if re.search("^minor*", x)]))
736         else:
737             parts.extend(["bugfix={}".format(self.bugfix)])
738         if self.mbugfix:
739             parts.append("minor-bugfix={}".format(self.mbugfix))
740         if self.pre_type:
741             parts.append("{}={}".format(self.pre_type, self.pre_num))
742         noc = self.noc
743         if noc == -1:
744             noc = "0na"
745         if noc and self.sha:
746             parts.extend(["noc={}".format(noc), "sha={}".format(self.sha)])
747         return "&lt;{} {}&gt;".format(self.__class__.__name__, " ".join(parts))
748 __saltstack_version__ = SaltStackVersion.current_release()
749 def __discover_version(saltstack_version):
750     import os
751     import subprocess
752     if "SETUP_DIRNAME" in globals():
753         cwd = SETUP_DIRNAME  # pylint: disable=E0602
754         if not os.path.exists(os.path.join(cwd, ".git")):
755             return saltstack_version
756     else:
757         cwd = os.path.abspath(os.path.dirname(__file__))
758         if not os.path.exists(os.path.join(os.path.dirname(cwd), ".git")):
759             return saltstack_version
760     try:
761         kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
762         if not sys.platform.startswith("win"):
763             kwargs["close_fds"] = True
764         process = subprocess.Popen(
765             [
766                 "git",
767                 "describe",
768                 "--tags",
769                 "--long",
770                 "--match",
771                 "v[0-9]*",
772                 "--always",
773             ],
774             **kwargs
775         )
776         out, err = process.communicate()
777         out = out.decode().strip()
778         err = err.decode().strip()
779         if not out or err:
780             return saltstack_version
781         if SaltStackVersion.git_sha_regex.match(out):
782             saltstack_version.sha = out.strip()
783             saltstack_version.noc = -1
784             return saltstack_version
785         return SaltStackVersion.parse(out)
786     except OSError as os_err:
787         if os_err.errno != 2:
788             raise
789     return saltstack_version
790 def __get_version(saltstack_version):
791     try:
792         from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401
793         return __saltstack_version__
794     except ImportError:
795         return __discover_version(saltstack_version)
796 __saltstack_version__ = __get_version(__saltstack_version__)
797 if __saltstack_version__.name:
798     SaltVersionsInfo._current_release = getattr(
799         SaltVersionsInfo, __saltstack_version__.name.upper()
800     )
801 del __get_version
802 __version_info__ = __saltstack_version__.info
803 __version__ = __saltstack_version__.string
804 def salt_information():
805     yield "Salt", __version__
806 def dependency_information(include_salt_cloud=False):
807     libs = [
808         ("Python", None, sys.version.rsplit("\n")[0].strip()),
809         ("Jinja2", "jinja2", "__version__"),
810         ("M2Crypto", "M2Crypto", "version"),
811         ("msgpack", "msgpack", "version"),
812         ("msgpack-pure", "msgpack_pure", "version"),
813         ("pycrypto", "Crypto", "__version__"),
814         ("pycryptodome", "Cryptodome", "version_info"),
815         ("PyYAML", "yaml", "__version__"),
816         ("PyZMQ", "zmq", "__version__"),
817         ("ZMQ", "zmq", "zmq_version"),
818         ("Mako", "mako", "__version__"),
819         ("Tornado", "tornado", "version"),
820         ("timelib", "timelib", "version"),
821         ("dateutil", "dateutil", "__version__"),
822         ("pygit2", "pygit2", "__version__"),
823         ("libgit2", "pygit2", "LIBGIT2_VERSION"),
824         ("smmap", "smmap", "__version__"),
825         ("cffi", "cffi", "__version__"),
826         ("pycparser", "pycparser", "__version__"),
827         ("gitdb", "gitdb", "__version__"),
828         ("gitpython", "git", "__version__"),
829         ("python-gnupg", "gnupg", "__version__"),
830         ("mysql-python", "MySQLdb", "__version__"),
831         ("cherrypy", "cherrypy", "__version__"),
832         ("docker-py", "docker", "__version__"),
833     ]
834     if include_salt_cloud:
835         libs.append(
836             ("Apache Libcloud", "libcloud", "__version__"),
837         )
838     for name, imp, attr in libs:
839         if imp is None:
840             yield name, attr
841             continue
842         try:
843             imp = __import__(imp)
844             version = getattr(imp, attr)
845             if callable(version):
846                 version = version()
847             if isinstance(version, (tuple, list)):
848                 version = ".".join(map(str, version))
849             yield name, version
850         except Exception:  # pylint: disable=broad-except
851             yield name, None
852 def system_information():
853     from distro import linux_distribution
854     def system_version():
855         lin_ver = linux_distribution()
856         mac_ver = platform.mac_ver()
857         win_ver = platform.win32_ver()
858         if mac_ver[0]:
859             if isinstance(mac_ver[1], (tuple, list)) and "".join(mac_ver[1]):
860                 return " ".join([mac_ver[0], ".".join(mac_ver[1]), mac_ver[2]])
861             else:
862                 return " ".join([mac_ver[0], mac_ver[2]])
863         elif win_ver[0]:
864             return " ".join(win_ver)
865         elif lin_ver[0]:
866             return " ".join(lin_ver)
867         else:
868             return ""
869     if platform.win32_ver()[0]:
870         import win32api  # pylint: disable=3rd-party-module-not-gated
871         import win32con  # pylint: disable=3rd-party-module-not-gated
872         hkey = win32con.HKEY_LOCAL_MACHINE
873         key = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
874         value_name = "ProductName"
875         reg_handle = win32api.RegOpenKey(hkey, key)
876         product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)
877         version = "Unknown"
878         release = ""
879         if "Server" in product_name:
880             for item in product_name.split(" "):
881                 if re.match(r"\d+", item):
882                     version = item
883                 if re.match(r"^R\d+$", item):
884                     release = item
885             release = "{}Server{}".format(version, release)
886         else:
887             for item in product_name.split(" "):
888                 if re.match(r"^(\d+(\.\d+)?)|Thin|Vista$", item):
889                     version = item
890             release = version
891         _, ver, service_pack, extra = platform.win32_ver()
892         version = " ".join([release, ver, service_pack, extra])
893     else:
894         version = system_version()
895         release = platform.release()
896     system = [
897         ("system", platform.system()),
898         ("dist", " ".join(linux_distribution(full_distribution_name=False))),
899         ("release", release),
900         ("machine", platform.machine()),
901         ("version", version),
902         ("locale", __salt_system_encoding__),
903     ]
904     for name, attr in system:
905         yield name, attr
906         continue
907 def extensions_information():
908     import salt.utils.entrypoints
909     extensions = {}
910     for entry_point in salt.utils.entrypoints.iter_entry_points("salt.loader"):
911         dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
912         if not dist_nv:
913             continue
914         if dist_nv.name in extensions:
915             continue
916         extensions[dist_nv.name] = dist_nv.version
917     return extensions
918 def versions_information(include_salt_cloud=False, include_extensions=True):
919     salt_info = list(salt_information())
920     lib_info = list(dependency_information(include_salt_cloud))
921     sys_info = list(system_information())
922     info = {
923         "Salt Version": dict(salt_info),
924         "Dependency Versions": dict(lib_info),
925         "System Versions": dict(sys_info),
926     }
927     if include_extensions:
928         extensions_info = extensions_information()
929         if extensions_info:
930             info["Salt Extensions"] = extensions_info
931     return info
932 def versions_report(include_salt_cloud=False, include_extensions=True):
933     ver_info = versions_information(
934         include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
935     )
936     not_installed = "Not Installed"
937     ns_pad = len(not_installed)
938     lib_pad = max(len(name) for name in ver_info["Dependency Versions"])
939     sys_pad = max(len(name) for name in ver_info["System Versions"])
940     if include_extensions and "Salt Extensions" in ver_info:
941         ext_pad = max(len(name) for name in ver_info["Salt Extensions"])
942     else:
943         ext_pad = 1
944     padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1
945     fmt = "{0:&gt;{pad}}: {1}"
946     info = []
947     for ver_type in (
948         "Salt Version",
949         "Dependency Versions",
950         "Salt Extensions",
951         "System Versions",
952     ):
953         if ver_type == "Salt Extensions" and ver_type not in ver_info:
954             continue
955         info.append("{}:".format(ver_type))
956         for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
957             ver = fmt.format(
958                 name, ver_info[ver_type][name] or not_installed, pad=padding
959             )
960             info.append(ver)
961         info.append(" ")
962     yield from info
963 if __name__ == "__main__":
964     print(__version__)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
