<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for gen.py & version.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for gen.py & version.py
      </h3>
      <h1 align="center">
        0.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>gen.py (0.9456265%)<TH>version.py (0.7707129%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match271985-0.html#0',2,'match271985-1.html#0',3)" NAME="0">(986-991)<TD><A HREF="javascript:ZweiFrames('match271985-0.html#0',2,'match271985-1.html#0',3)" NAME="0">(319-324)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>gen.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;``tornado.gen`` is a generator-based interface to make it easier to
work in an asynchronous environment.  Code using the ``gen`` module
is technically asynchronous, but it is written as a single generator
instead of a collection of separate functions.

For example, the following asynchronous handler:

.. testcode::

    class AsyncHandler(RequestHandler):
        @asynchronous
        def get(self):
            http_client = AsyncHTTPClient()
            http_client.fetch(&quot;http://example.com&quot;,
                              callback=self.on_fetch)

        def on_fetch(self, response):
            do_something_with_response(response)
            self.render(&quot;template.html&quot;)

.. testoutput::
   :hide:

could be written with ``gen`` as:

.. testcode::

    class GenAsyncHandler(RequestHandler):
        @gen.coroutine
        def get(self):
            http_client = AsyncHTTPClient()
            response = yield http_client.fetch(&quot;http://example.com&quot;)
            do_something_with_response(response)
            self.render(&quot;template.html&quot;)

.. testoutput::
   :hide:

Most asynchronous functions in Tornado return a `.Future`;
yielding this object returns its `~.Future.result`.

You can also yield a list or dict of ``Futures``, which will be
started at the same time and run in parallel; a list or dict of results will
be returned when they are all finished:

.. testcode::

    @gen.coroutine
    def get(self):
        http_client = AsyncHTTPClient()
        response1, response2 = yield [http_client.fetch(url1),
                                      http_client.fetch(url2)]
        response_dict = yield dict(response3=http_client.fetch(url3),
                                   response4=http_client.fetch(url4))
        response3 = response_dict['response3']
        response4 = response_dict['response4']

.. testoutput::
   :hide:

If the `~functools.singledispatch` library is available (standard in
Python 3.4, available via the `singledispatch
&lt;https://pypi.python.org/pypi/singledispatch&gt;`_ package on older
versions), additional types of objects may be yielded. Tornado includes
support for ``asyncio.Future`` and Twisted's ``Deferred`` class when
``tornado.platform.asyncio`` and ``tornado.platform.twisted`` are imported.
See the `convert_yielded` function to extend this mechanism.

.. versionchanged:: 3.2
   Dict support added.

.. versionchanged:: 4.1
   Support added for yielding ``asyncio`` Futures and Twisted Deferreds
   via ``singledispatch``.

&quot;&quot;&quot;
# pylint: skip-file
from __future__ import absolute_import, division, print_function

import collections
import functools
import itertools
import os
import sys
import textwrap
import types
import weakref

import salt.ext.tornado as tornado
from salt.ext.tornado.concurrent import Future, TracebackFuture, is_future, chain_future
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.log import app_log
from salt.ext.tornado import stack_context
from salt.ext.tornado.util import PY3, raise_exc_info

try:
    try:
        # py34+
        from functools import singledispatch  # type: ignore
    except ImportError:
        from singledispatch import singledispatch  # backport
except ImportError:
    # In most cases, singledispatch is required (to avoid
    # difficult-to-diagnose problems in which the functionality
    # available differs depending on which invisble packages are
    # installed). However, in Google App Engine third-party
    # dependencies are more trouble so we allow this module to be
    # imported without it.
    if 'APPENGINE_RUNTIME' not in os.environ:
        raise
    singledispatch = None

try:
    try:
        # py35+
        from collections.abc import Generator as GeneratorType  # type: ignore
    except ImportError:
        from salt.ext.backports_abc import Generator as GeneratorType  # type: ignore

    try:
        # py35+
        from inspect import isawaitable  # type: ignore
    except ImportError:
        from salt.ext.backports_abc import isawaitable
except ImportError:
    if 'APPENGINE_RUNTIME' not in os.environ:
        raise
    from types import GeneratorType

    def isawaitable(x):  # type: ignore
        return False

if PY3:
    import builtins
else:
    import __builtin__ as builtins


class KeyReuseError(Exception):
    pass


class UnknownKeyError(Exception):
    pass


class LeakedCallbackError(Exception):
    pass


class BadYieldError(Exception):
    pass


class ReturnValueIgnoredError(Exception):
    pass


class TimeoutError(Exception):
    &quot;&quot;&quot;Exception raised by ``with_timeout``.&quot;&quot;&quot;


def _value_from_stopiteration(e):
    try:
        # StopIteration has a value attribute beginning in py33.
        # So does our Return class.
        return e.value
    except AttributeError:
        pass
    try:
        # Cython backports coroutine functionality by putting the value in
        # e.args[0].
        return e.args[0]
    except (AttributeError, IndexError):
        return None


def engine(func):
    &quot;&quot;&quot;Callback-oriented decorator for asynchronous generators.

    This is an older interface; for new code that does not need to be
    compatible with versions of Tornado older than 3.0 the
    `coroutine` decorator is recommended instead.

    This decorator is similar to `coroutine`, except it does not
    return a `.Future` and the ``callback`` argument is not treated
    specially.

    In most cases, functions decorated with `engine` should take
    a ``callback`` argument and invoke it with their result when
    they are finished.  One notable exception is the
    `~tornado.web.RequestHandler` :ref:`HTTP verb methods &lt;verbs&gt;`,
    which use ``self.finish()`` in place of a callback argument.
    &quot;&quot;&quot;
    func = _make_coroutine_wrapper(func, replace_callback=False)

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        future = func(*args, **kwargs)

        def final_callback(future):
            if future.result() is not None:
                raise ReturnValueIgnoredError(
                    &quot;@gen.engine functions cannot return values: %r&quot; %
                    (future.result(),))
        # The engine interface doesn't give us any way to return
        # errors but to raise them into the stack context.
        # Save the stack context here to use when the Future has resolved.
        future.add_done_callback(stack_context.wrap(final_callback))
    return wrapper


def coroutine(func, replace_callback=True):
    &quot;&quot;&quot;Decorator for asynchronous generators.

    Any generator that yields objects from this module must be wrapped
    in either this decorator or `engine`.

    Coroutines may &quot;return&quot; by raising the special exception
    `Return(value) &lt;Return&gt;`.  In Python 3.3+, it is also possible for
    the function to simply use the ``return value`` statement (prior to
    Python 3.3 generators were not allowed to also return values).
    In all versions of Python a coroutine that simply wishes to exit
    early may use the ``return`` statement without a value.

    Functions with this decorator return a `.Future`.  Additionally,
    they may be called with a ``callback`` keyword argument, which
    will be invoked with the future's result when it resolves.  If the
    coroutine fails, the callback will not be run and an exception
    will be raised into the surrounding `.StackContext`.  The
    ``callback`` argument is not visible inside the decorated
    function; it is handled by the decorator itself.

    From the caller's perspective, ``@gen.coroutine`` is similar to
    the combination of ``@return_future`` and ``@gen.engine``.

    .. warning::

       When exceptions occur inside a coroutine, the exception
       information will be stored in the `.Future` object. You must
       examine the result of the `.Future` object, or the exception
       may go unnoticed by your code. This means yielding the function
       if called from another coroutine, using something like
       `.IOLoop.run_sync` for top-level calls, or passing the `.Future`
       to `.IOLoop.add_future`.

    &quot;&quot;&quot;
    return _make_coroutine_wrapper(func, replace_callback=True)


# Ties lifetime of runners to their result futures. Github Issue #1769
# Generators, like any object in Python, must be strong referenced
# in order to not be cleaned up by the garbage collector. When using
# coroutines, the Runner object is what strong-refs the inner
# generator. However, the only item that strong-reffed the Runner
# was the last Future that the inner generator yielded (via the
# Future's internal done_callback list). Usually this is enough, but
# it is also possible for this Future to not have any strong references
# other than other objects referenced by the Runner object (usually
# when using other callback patterns and/or weakrefs). In this
# situation, if a garbage collection ran, a cycle would be detected and
# Runner objects could be destroyed along with their inner generators
# and everything in their local scope.
# This map provides strong references to Runner objects as long as
# their result future objects also have strong references (typically
# from the parent coroutine's Runner). This keeps the coroutine's
# Runner alive.
_futures_to_runners = weakref.WeakKeyDictionary()


def _make_coroutine_wrapper(func, replace_callback):
    &quot;&quot;&quot;The inner workings of ``@gen.coroutine`` and ``@gen.engine``.

    The two decorators differ in their treatment of the ``callback``
    argument, so we cannot simply implement ``@engine`` in terms of
    ``@coroutine``.
    &quot;&quot;&quot;
    # On Python 3.5, set the coroutine flag on our generator, to allow it
    # to be used with 'await'.
    wrapped = func
    if hasattr(types, 'coroutine'):
        func = types.coroutine(func)

    @functools.wraps(wrapped)
    def wrapper(*args, **kwargs):
        future = TracebackFuture()

        if replace_callback and 'callback' in kwargs:
            callback = kwargs.pop('callback')
            IOLoop.current().add_future(
                future, lambda future: callback(future.result()))

        try:
            result = func(*args, **kwargs)
        except (Return, StopIteration) as e:
            result = _value_from_stopiteration(e)
        except Exception:
            future.set_exc_info(sys.exc_info())
            return future
        else:
            if isinstance(result, GeneratorType):
                # Inline the first iteration of Runner.run.  This lets us
                # avoid the cost of creating a Runner when the coroutine
                # never actually yields, which in turn allows us to
                # use &quot;optional&quot; coroutines in critical path code without
                # performance penalty for the synchronous case.
                try:
                    orig_stack_contexts = stack_context._state.contexts
                    yielded = next(result)
                    if stack_context._state.contexts is not orig_stack_contexts:
                        yielded = TracebackFuture()
                        yielded.set_exception(
                            stack_context.StackContextInconsistentError(
                                'stack_context inconsistency (probably caused '
                                'by yield within a &quot;with StackContext&quot; block)'))
                except (StopIteration, Return) as e:
                    future.set_result(_value_from_stopiteration(e))
                except Exception:
                    future.set_exc_info(sys.exc_info())
                else:
                    _futures_to_runners[future] = Runner(result, future, yielded)
                yielded = None
                try:
                    return future
                finally:
                    # Subtle memory optimization: if next() raised an exception,
                    # the future's exc_info contains a traceback which
                    # includes this stack frame.  This creates a cycle,
                    # which will be collected at the next full GC but has
                    # been shown to greatly increase memory usage of
                    # benchmarks (relative to the refcount-based scheme
                    # used in the absence of cycles).  We can avoid the
                    # cycle by clearing the local variable after we return it.
                    future = None
        future.set_result(result)
        return future

    wrapper.__wrapped__ = wrapped
    wrapper.__tornado_coroutine__ = True
    return wrapper


def is_coroutine_function(func):
    &quot;&quot;&quot;Return whether *func* is a coroutine function, i.e. a function
    wrapped with `~.gen.coroutine`.

    .. versionadded:: 4.5
    &quot;&quot;&quot;
    return getattr(func, '__tornado_coroutine__', False)


class Return(Exception):
    &quot;&quot;&quot;Special exception to return a value from a `coroutine`.

    If this exception is raised, its value argument is used as the
    result of the coroutine::

        @gen.coroutine
        def fetch_json(url):
            response = yield AsyncHTTPClient().fetch(url)
            raise gen.Return(json_decode(response.body))

    In Python 3.3, this exception is no longer necessary: the ``return``
    statement can be used directly to return a value (previously
    ``yield`` and ``return`` with a value could not be combined in the
    same function).

    By analogy with the return statement, the value argument is optional,
    but it is never necessary to ``raise gen.Return()``.  The ``return``
    statement can be used with no arguments instead.
    &quot;&quot;&quot;
    def __init__(self, value=None):
        super(Return, self).__init__()
        self.value = value
        # Cython recognizes subclasses of StopIteration with a .args tuple.
        self.args = (value,)


class WaitIterator(object):
    &quot;&quot;&quot;Provides an iterator to yield the results of futures as they finish.

    Yielding a set of futures like this:

    ``results = yield [future1, future2]``

    pauses the coroutine until both ``future1`` and ``future2``
    return, and then restarts the coroutine with the results of both
    futures. If either future is an exception, the expression will
    raise that exception and all the results will be lost.

    If you need to get the result of each future as soon as possible,
    or if you need the result of some futures even if others produce
    errors, you can use ``WaitIterator``::

      wait_iterator = gen.WaitIterator(future1, future2)
      while not wait_iterator.done():
          try:
              result = yield wait_iterator.next()
          except Exception as e:
              print(&quot;Error {} from {}&quot;.format(e, wait_iterator.current_future))
          else:
              print(&quot;Result {} received from {} at {}&quot;.format(
                  result, wait_iterator.current_future,
                  wait_iterator.current_index))

    Because results are returned as soon as they are available the
    output from the iterator *will not be in the same order as the
    input arguments*. If you need to know which future produced the
    current result, you can use the attributes
    ``WaitIterator.current_future``, or ``WaitIterator.current_index``
    to get the index of the future from the input list. (if keyword
    arguments were used in the construction of the `WaitIterator`,
    ``current_index`` will use the corresponding keyword).

    On Python 3.5, `WaitIterator` implements the async iterator
    protocol, so it can be used with the ``async for`` statement (note
    that in this version the entire iteration is aborted if any value
    raises an exception, while the previous example can continue past
    individual errors)::

      async for result in gen.WaitIterator(future1, future2):
          print(&quot;Result {} received from {} at {}&quot;.format(
              result, wait_iterator.current_future,
              wait_iterator.current_index))

    .. versionadded:: 4.1

    .. versionchanged:: 4.3
       Added ``async for`` support in Python 3.5.

    &quot;&quot;&quot;
    def __init__(self, *args, **kwargs):
        if args and kwargs:
            raise ValueError(
                &quot;You must provide args or kwargs, not both&quot;)

        if kwargs:
            self._unfinished = dict((f, k) for (k, f) in kwargs.items())
            futures = list(kwargs.values())
        else:
            self._unfinished = dict((f, i) for (i, f) in enumerate(args))
            futures = args

        self._finished = collections.deque()
        self.current_index = self.current_future = None
        self._running_future = None

        for future in futures:
            future.add_done_callback(self._done_callback)

    def done(self):
        &quot;&quot;&quot;Returns True if this iterator has no more results.&quot;&quot;&quot;
        if self._finished or self._unfinished:
            return False
        # Clear the 'current' values when iteration is done.
        self.current_index = self.current_future = None
        return True

    def next(self):
        &quot;&quot;&quot;Returns a `.Future` that will yield the next available result.

        Note that this `.Future` will not be the same object as any of
        the inputs.
        &quot;&quot;&quot;
        self._running_future = TracebackFuture()

        if self._finished:
            self._return_result(self._finished.popleft())

        return self._running_future

    def _done_callback(self, done):
        if self._running_future and not self._running_future.done():
            self._return_result(done)
        else:
            self._finished.append(done)

    def _return_result(self, done):
        &quot;&quot;&quot;Called set the returned future's state that of the future
        we yielded, and set the current future for the iterator.
        &quot;&quot;&quot;
        chain_future(done, self._running_future)

        self.current_future = done
        self.current_index = self._unfinished.pop(done)

    def __aiter__(self):
        raise self

    def __anext__(self):
        if self.done():
            # Lookup by name to silence pyflakes on older versions.
            raise getattr(builtins, 'StopAsyncIteration')()
        return self.next()


class YieldPoint(object):
    &quot;&quot;&quot;Base class for objects that may be yielded from the generator.

    .. deprecated:: 4.0
       Use `Futures &lt;.Future&gt;` instead.
    &quot;&quot;&quot;
    def start(self, runner):
        &quot;&quot;&quot;Called by the runner after the generator has yielded.

        No other methods will be called on this object before ``start``.
        &quot;&quot;&quot;
        raise NotImplementedError()

    def is_ready(self):
        &quot;&quot;&quot;Called by the runner to determine whether to resume the generator.

        Returns a boolean; may be called more than once.
        &quot;&quot;&quot;
        raise NotImplementedError()

    def get_result(self):
        &quot;&quot;&quot;Returns the value to use as the result of the yield expression.

        This method will only be called once, and only after `is_ready`
        has returned true.
        &quot;&quot;&quot;
        raise NotImplementedError()


class Callback(YieldPoint):
    &quot;&quot;&quot;Returns a callable object that will allow a matching `Wait` to proceed.

    The key may be any value suitable for use as a dictionary key, and is
    used to match ``Callbacks`` to their corresponding ``Waits``.  The key
    must be unique among outstanding callbacks within a single run of the
    generator function, but may be reused across different runs of the same
    function (so constants generally work fine).

    The callback may be called with zero or one arguments; if an argument
    is given it will be returned by `Wait`.

    .. deprecated:: 4.0
       Use `Futures &lt;.Future&gt;` instead.
    &quot;&quot;&quot;
    def __init__(self, key):
        self.key = key

    def start(self, runner):
        self.runner = runner
        runner.register_callback(self.key)

    def is_ready(self):
        return True

    def get_result(self):
        return self.runner.result_callback(self.key)


class Wait(YieldPoint):
    &quot;&quot;&quot;Returns the argument passed to the result of a previous `Callback`.

    .. deprecated:: 4.0
       Use `Futures &lt;.Future&gt;` instead.
    &quot;&quot;&quot;
    def __init__(self, key):
        self.key = key

    def start(self, runner):
        self.runner = runner

    def is_ready(self):
        return self.runner.is_ready(self.key)

    def get_result(self):
        return self.runner.pop_result(self.key)


class WaitAll(YieldPoint):
    &quot;&quot;&quot;Returns the results of multiple previous `Callbacks &lt;Callback&gt;`.

    The argument is a sequence of `Callback` keys, and the result is
    a list of results in the same order.

    `WaitAll` is equivalent to yielding a list of `Wait` objects.

    .. deprecated:: 4.0
       Use `Futures &lt;.Future&gt;` instead.
    &quot;&quot;&quot;
    def __init__(self, keys):
        self.keys = keys

    def start(self, runner):
        self.runner = runner

    def is_ready(self):
        return all(self.runner.is_ready(key) for key in self.keys)

    def get_result(self):
        return [self.runner.pop_result(key) for key in self.keys]


def Task(func, *args, **kwargs):
    &quot;&quot;&quot;Adapts a callback-based asynchronous function for use in coroutines.

    Takes a function (and optional additional arguments) and runs it with
    those arguments plus a ``callback`` keyword argument.  The argument passed
    to the callback is returned as the result of the yield expression.

    .. versionchanged:: 4.0
       ``gen.Task`` is now a function that returns a `.Future`, instead of
       a subclass of `YieldPoint`.  It still behaves the same way when
       yielded.
    &quot;&quot;&quot;
    future = Future()

    def handle_exception(typ, value, tb):
        if future.done():
            return False
        future.set_exc_info((typ, value, tb))
        return True

    def set_result(result):
        if future.done():
            return
        future.set_result(result)
    with stack_context.ExceptionStackContext(handle_exception):
        func(*args, callback=_argument_adapter(set_result), **kwargs)
    return future


class YieldFuture(YieldPoint):
    def __init__(self, future, io_loop=None):
        &quot;&quot;&quot;Adapts a `.Future` to the `YieldPoint` interface.

        .. versionchanged:: 4.1
           The ``io_loop`` argument is deprecated.
        &quot;&quot;&quot;
        self.future = future
        self.io_loop = io_loop or IOLoop.current()

    def start(self, runner):
        if not self.future.done():
            self.runner = runner
            self.key = object()
            runner.register_callback(self.key)
            self.io_loop.add_future(self.future, runner.result_callback(self.key))
        else:
            self.runner = None
            self.result_fn = self.future.result

    def is_ready(self):
        if self.runner is not None:
            return self.runner.is_ready(self.key)
        else:
            return True

    def get_result(self):
        if self.runner is not None:
            return self.runner.pop_result(self.key).result()
        else:
            return self.result_fn()


def _contains_yieldpoint(children):
    &quot;&quot;&quot;Returns True if ``children`` contains any YieldPoints.

    ``children`` may be a dict or a list, as used by `MultiYieldPoint`
    and `multi_future`.
    &quot;&quot;&quot;
    if isinstance(children, dict):
        return any(isinstance(i, YieldPoint) for i in children.values())
    if isinstance(children, list):
        return any(isinstance(i, YieldPoint) for i in children)
    return False


def multi(children, quiet_exceptions=()):
    &quot;&quot;&quot;Runs multiple asynchronous operations in parallel.

    ``children`` may either be a list or a dict whose values are
    yieldable objects. ``multi()`` returns a new yieldable
    object that resolves to a parallel structure containing their
    results. If ``children`` is a list, the result is a list of
    results in the same order; if it is a dict, the result is a dict
    with the same keys.

    That is, ``results = yield multi(list_of_futures)`` is equivalent
    to::

        results = []
        for future in list_of_futures:
            results.append(yield future)

    If any children raise exceptions, ``multi()`` will raise the first
    one. All others will be logged, unless they are of types
    contained in the ``quiet_exceptions`` argument.

    If any of the inputs are `YieldPoints &lt;YieldPoint&gt;`, the returned
    yieldable object is a `YieldPoint`. Otherwise, returns a `.Future`.
    This means that the result of `multi` can be used in a native
    coroutine if and only if all of its children can be.

    In a ``yield``-based coroutine, it is not normally necessary to
    call this function directly, since the coroutine runner will
    do it automatically when a list or dict is yielded. However,
    it is necessary in ``await``-based coroutines, or to pass
    the ``quiet_exceptions`` argument.

    This function is available under the names ``multi()`` and ``Multi()``
    for historical reasons.

    .. versionchanged:: 4.2
       If multiple yieldables fail, any exceptions after the first
       (which is raised) will be logged. Added the ``quiet_exceptions``
       argument to suppress this logging for selected exception types.

    .. versionchanged:: 4.3
       Replaced the class ``Multi`` and the function ``multi_future``
       with a unified function ``multi``. Added support for yieldables
       other than `YieldPoint` and `.Future`.

    &quot;&quot;&quot;
    if _contains_yieldpoint(children):
        return MultiYieldPoint(children, quiet_exceptions=quiet_exceptions)
    else:
        return multi_future(children, quiet_exceptions=quiet_exceptions)


Multi = multi


class MultiYieldPoint(YieldPoint):
    &quot;&quot;&quot;Runs multiple asynchronous operations in parallel.

    This class is similar to `multi`, but it always creates a stack
    context even when no children require it. It is not compatible with
    native coroutines.

    .. versionchanged:: 4.2
       If multiple ``YieldPoints`` fail, any exceptions after the first
       (which is raised) will be logged. Added the ``quiet_exceptions``
       argument to suppress this logging for selected exception types.

    .. versionchanged:: 4.3
       Renamed from ``Multi`` to ``MultiYieldPoint``. The name ``Multi``
       remains as an alias for the equivalent `multi` function.

    .. deprecated:: 4.3
       Use `multi` instead.
    &quot;&quot;&quot;
    def __init__(self, children, quiet_exceptions=()):
        self.keys = None
        if isinstance(children, dict):
            self.keys = list(children.keys())
            children = children.values()
        self.children = []
        for i in children:
            if not isinstance(i, YieldPoint):
                i = convert_yielded(i)
            if is_future(i):
                i = YieldFuture(i)
            self.children.append(i)
        assert all(isinstance(i, YieldPoint) for i in self.children)
        self.unfinished_children = set(self.children)
        self.quiet_exceptions = quiet_exceptions

    def start(self, runner):
        for i in self.children:
            i.start(runner)

    def is_ready(self):
        finished = list(itertools.takewhile(
            lambda i: i.is_ready(), self.unfinished_children))
        self.unfinished_children.difference_update(finished)
        return not self.unfinished_children

    def get_result(self):
        result_list = []
        exc_info = None
        for f in self.children:
            try:
                result_list.append(f.get_result())
            except Exception as e:
                if exc_info is None:
                    exc_info = sys.exc_info()
                else:
                    if not isinstance(e, self.quiet_exceptions):
                        app_log.error(&quot;Multiple exceptions in yield list&quot;,
                                      exc_info=True)
        if exc_info is not None:
            raise_exc_info(exc_info)
        if self.keys is not None:
            return dict(zip(self.keys, result_list))
        else:
            return list(result_list)


def multi_future(children, quiet_exceptions=()):
    &quot;&quot;&quot;Wait for multiple asynchronous futures in parallel.

    This function is similar to `multi`, but does not support
    `YieldPoints &lt;YieldPoint&gt;`.

    .. versionadded:: 4.0

    .. versionchanged:: 4.2
       If multiple ``Futures`` fail, any exceptions after the first (which is
       raised) will be logged. Added the ``quiet_exceptions``
       argument to suppress this logging for selected exception types.

    .. deprecated:: 4.3
       Use `multi` instead.
    &quot;&quot;&quot;
    if isinstance(children, dict):
        keys = list(children.keys())
        children = children.values()
    else:
        keys = None
    children = list(map(convert_yielded, children))
    assert all(is_future(i) for i in children)
    unfinished_children = set(children)

    future = Future()
    if not children:
        future.set_result({} if keys is not None else [])

    def callback(f):
        unfinished_children.remove(f)
        if not unfinished_children:
            result_list = []
            for f in children:
                try:
                    result_list.append(f.result())
                except Exception as e:
                    if future.done():
                        if not isinstance(e, quiet_exceptions):
                            app_log.error(&quot;Multiple exceptions in yield list&quot;,
                                          exc_info=True)
                    else:
                        future.set_exc_info(sys.exc_info())
            if not future.done():
                if keys is not None:
                    future.set_result(dict(zip(keys, result_list)))
                else:
                    future.set_result(result_list)

    listening = set()
    for f in children:
        if f not in listening:
            listening.add(f)
            f.add_done_callback(callback)
    return future


def maybe_future(x):
    &quot;&quot;&quot;Converts ``x`` into a `.Future`.

    If ``x`` is already a `.Future`, it is simply returned; otherwise
    it is wrapped in a new `.Future`.  This is suitable for use as
    ``result = yield gen.maybe_future(f())`` when you don't know whether
    ``f()`` returns a `.Future` or not.

    .. deprecated:: 4.3
       This function only handles ``Futures``, not other yieldable objects.
       Instead of `maybe_future`, check for the non-future result types
       you expect (often just ``None``), and ``yield`` anything unknown.
    &quot;&quot;&quot;
    if is_future(x):
        return x
    else:
        fut = Future()
        fut.set_result(x)
        return fut


def with_timeout(timeout, future, io_loop=None, quiet_exceptions=()):
    &quot;&quot;&quot;Wraps a `.Future` (or other yieldable object) in a timeout.

    Raises `TimeoutError` if the input future does not complete before
    ``timeout``, which may be specified in any form allowed by
    `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or an absolute time
    relative to `.IOLoop.time`)

    If the wrapped `.Future` fails after it has timed out, the exception
    will be logged unless it is of a type contained in ``quiet_exceptions``
    (which may be an exception type or a sequence of types).

    Does not support `YieldPoint` subclasses.

    .. versionadded:: 4.0

    .. versionchanged:: 4.1
       Added the ``quiet_exceptions`` argument and the logging of unhandled
       exceptions.

    .. versionchanged:: 4.4
       Added support for yieldable objects other than `.Future`.
    &quot;&quot;&quot;
    # TODO: allow YieldPoints in addition to other yieldables?
    # Tricky to do with stack_context semantics.
    #
    # It's tempting to optimize this by cancelling the input future on timeout
    # instead of creating a new one, but A) we can't know if we are the only
    # one waiting on the input future, so cancelling it might disrupt other
    # callers and B) concurrent futures can only be cancelled while they are
    # in the queue, so cancellation cannot reliably bound our waiting time.
    future = convert_yielded(future)
    result = Future()
    chain_future(future, result)
    if io_loop is None:
        io_loop = IOLoop.current()

    def error_callback(future):
        try:
            future.result()
        except Exception as e:
            if not isinstance(e, quiet_exceptions):
                app_log.error(&quot;Exception in Future %r after timeout&quot;,
                              future, exc_info=True)

    def timeout_callback():
        result.set_exception(TimeoutError(&quot;Timeout&quot;))
        # In case the wrapped future goes on to fail, log it.
        future.add_done_callback(error_callback)
    timeout_handle = io_loop.add_timeout(
        timeout, timeout_callback)
    if isinstance(future, Future):
        # We know this future will resolve on the IOLoop, so we don't
        # need the extra thread-safety of IOLoop.add_future (and we also
        # don't care about StackContext here.
        future.add_done_callback(
            lambda future: io_loop.remove_timeout(timeout_handle))
    else:
        # concurrent.futures.Futures may resolve on any thread, so we
        # need to route them back to the IOLoop.
        io_loop.add_future(
            future, lambda future: io_loop.remove_timeout(timeout_handle))
    return result


def sleep(duration):
    &quot;&quot;&quot;Return a `.Future` that resolves after the given number of seconds.

    When used with ``yield`` in a coroutine, this is a non-blocking
    analogue to `time.sleep` (which should not be used in coroutines
    because it is blocking)::

        yield gen.sleep(0.5)

    Note that calling this function on its own does nothing; you must
    wait on the `.Future` it returns (usually by yielding it).

    .. versionadded:: 4.1
    &quot;&quot;&quot;
    f = Future()
    IOLoop.current().call_later(duration, lambda: f.set_result(None))
    return f


_null_future = Future()
_null_future.set_result(None)

moment = Future()
moment.__doc__ = \
    &quot;&quot;&quot;A special object which may be yielded to allow the IOLoop to run for
one iteration.

This is not needed in normal use but it can be helpful in long-running
coroutines that are likely to yield Futures that are ready instantly.

Usage: ``yield gen.moment``

.. versionadded:: 4.0

.. deprecated:: 4.5
   ``yield None`` is now equivalent to ``yield gen.moment``.
&quot;&quot;&quot;
moment.set_result(None)


class Runner(object):
    &quot;&quot;&quot;Internal implementation of `tornado.gen.engine`.

    Maintains information about pending callbacks and their results.

    The results of the generator are stored in ``result_future`` (a
<A NAME="0"></A>    `.TracebackFuture`)
    &quot;&quot;&quot;
    def __init__(self, gen, result_future, first_yielded):
        self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match271985-1.html#0',3,'match271985-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.gen = gen
        self.result_future = result_future
        self.future = _null_future
        self.yield_point = None
        self.pending_callbacks = None
        self.results =</B></FONT> None
        self.running = False
        self.finished = False
        self.had_exception = False
        self.io_loop = IOLoop.current()
        # For efficiency, we do not create a stack context until we
        # reach a YieldPoint (stack contexts are required for the historical
        # semantics of YieldPoints, but not for Futures).  When we have
        # done so, this field will be set and must be called at the end
        # of the coroutine.
        self.stack_context_deactivate = None
        if self.handle_yield(first_yielded):
            gen = result_future = first_yielded = None
            self.run()

    def register_callback(self, key):
        &quot;&quot;&quot;Adds ``key`` to the list of callbacks.&quot;&quot;&quot;
        if self.pending_callbacks is None:
            # Lazily initialize the old-style YieldPoint data structures.
            self.pending_callbacks = set()
            self.results = {}
        if key in self.pending_callbacks:
            raise KeyReuseError(&quot;key %r is already pending&quot; % (key,))
        self.pending_callbacks.add(key)

    def is_ready(self, key):
        &quot;&quot;&quot;Returns true if a result is available for ``key``.&quot;&quot;&quot;
        if self.pending_callbacks is None or key not in self.pending_callbacks:
            raise UnknownKeyError(&quot;key %r is not pending&quot; % (key,))
        return key in self.results

    def set_result(self, key, result):
        &quot;&quot;&quot;Sets the result for ``key`` and attempts to resume the generator.&quot;&quot;&quot;
        self.results[key] = result
        if self.yield_point is not None and self.yield_point.is_ready():
            try:
                self.future.set_result(self.yield_point.get_result())
            except:
                self.future.set_exc_info(sys.exc_info())
            self.yield_point = None
            self.run()

    def pop_result(self, key):
        &quot;&quot;&quot;Returns the result for ``key`` and unregisters it.&quot;&quot;&quot;
        self.pending_callbacks.remove(key)
        return self.results.pop(key)

    def run(self):
        &quot;&quot;&quot;Starts or resumes the generator, running until it reaches a
        yield point that is not ready.
        &quot;&quot;&quot;
        if self.running or self.finished:
            return
        try:
            self.running = True
            while True:
                future = self.future
                if not future.done():
                    return
                self.future = None
                try:
                    orig_stack_contexts = stack_context._state.contexts
                    exc_info = None

                    try:
                        value = future.result()
                    except Exception:
                        self.had_exception = True
                        exc_info = sys.exc_info()
                    future = None

                    if exc_info is not None:
                        try:
                            yielded = self.gen.throw(*exc_info)
                        finally:
                            # Break up a reference to itself
                            # for faster GC on CPython.
                            exc_info = None
                    else:
                        yielded = self.gen.send(value)

                    if stack_context._state.contexts is not orig_stack_contexts:
                        self.gen.throw(
                            stack_context.StackContextInconsistentError(
                                'stack_context inconsistency (probably caused '
                                'by yield within a &quot;with StackContext&quot; block)'))
                except (StopIteration, Return) as e:
                    self.finished = True
                    self.future = _null_future
                    if self.pending_callbacks and not self.had_exception:
                        # If we ran cleanly without waiting on all callbacks
                        # raise an error (really more of a warning).  If we
                        # had an exception then some callbacks may have been
                        # orphaned, so skip the check in that case.
                        raise LeakedCallbackError(
                            &quot;finished without waiting for callbacks %r&quot; %
                            self.pending_callbacks)
                    self.result_future.set_result(_value_from_stopiteration(e))
                    self.result_future = None
                    self._deactivate_stack_context()
                    return
                except Exception:
                    self.finished = True
                    self.future = _null_future
                    self.result_future.set_exc_info(sys.exc_info())
                    self.result_future = None
                    self._deactivate_stack_context()
                    return
                if not self.handle_yield(yielded):
                    return
                yielded = None
        finally:
            self.running = False

    def handle_yield(self, yielded):
        # Lists containing YieldPoints require stack contexts;
        # other lists are handled in convert_yielded.
        if _contains_yieldpoint(yielded):
            yielded = multi(yielded)

        if isinstance(yielded, YieldPoint):
            # YieldPoints are too closely coupled to the Runner to go
            # through the generic convert_yielded mechanism.
            self.future = TracebackFuture()

            def start_yield_point():
                try:
                    yielded.start(self)
                    if yielded.is_ready():
                        self.future.set_result(
                            yielded.get_result())
                    else:
                        self.yield_point = yielded
                except Exception:
                    self.future = TracebackFuture()
                    self.future.set_exc_info(sys.exc_info())

            if self.stack_context_deactivate is None:
                # Start a stack context if this is the first
                # YieldPoint we've seen.
                with stack_context.ExceptionStackContext(
                        self.handle_exception) as deactivate:
                    self.stack_context_deactivate = deactivate

                    def cb():
                        start_yield_point()
                        self.run()
                    self.io_loop.add_callback(cb)
                    return False
            else:
                start_yield_point()
        else:
            try:
                self.future = convert_yielded(yielded)
            except BadYieldError:
                self.future = TracebackFuture()
                self.future.set_exc_info(sys.exc_info())

        if not self.future.done() or self.future is moment:
            def inner(f):
                # Break a reference cycle to speed GC.
                f = None # noqa
                self.run()
            self.io_loop.add_future(
                self.future, inner)
            return False
        return True

    def result_callback(self, key):
        return stack_context.wrap(_argument_adapter(
            functools.partial(self.set_result, key)))

    def handle_exception(self, typ, value, tb):
        if not self.running and not self.finished:
            self.future = TracebackFuture()
            self.future.set_exc_info((typ, value, tb))
            self.run()
            return True
        else:
            return False

    def _deactivate_stack_context(self):
        if self.stack_context_deactivate is not None:
            self.stack_context_deactivate()
            self.stack_context_deactivate = None


Arguments = collections.namedtuple('Arguments', ['args', 'kwargs'])


def _argument_adapter(callback):
    &quot;&quot;&quot;Returns a function that when invoked runs ``callback`` with one arg.

    If the function returned by this function is called with exactly
    one argument, that argument is passed to ``callback``.  Otherwise
    the args tuple and kwargs dict are wrapped in an `Arguments` object.
    &quot;&quot;&quot;
    def wrapper(*args, **kwargs):
        if kwargs or len(args) &gt; 1:
            callback(Arguments(args, kwargs))
        elif args:
            callback(args[0])
        else:
            callback(None)
    return wrapper


# Convert Awaitables into Futures. It is unfortunately possible
# to have infinite recursion here if those Awaitables assume that
# we're using a different coroutine runner and yield objects
# we don't understand. If that happens, the solution is to
# register that runner's yieldable objects with convert_yielded.
if sys.version_info &gt;= (3, 3):
    exec(textwrap.dedent(&quot;&quot;&quot;
    @coroutine
    def _wrap_awaitable(x):
        if hasattr(x, '__await__'):
            x = x.__await__()
        return (yield from x)
    &quot;&quot;&quot;))
else:
    # Py2-compatible version for use with Cython.
    # Copied from PEP 380.
    @coroutine
    def _wrap_awaitable(x):
        if hasattr(x, '__await__'):
            _i = x.__await__()
        else:
            _i = iter(x)
        try:
            _y = next(_i)
        except StopIteration as _e:
            _r = _value_from_stopiteration(_e)
        else:
            while 1:
                try:
                    _s = yield _y
                except GeneratorExit as _e:
                    try:
                        _m = _i.close
                    except AttributeError:
                        pass
                    else:
                        _m()
                    raise _e
                except BaseException as _e:
                    _x = sys.exc_info()
                    try:
                        _m = _i.throw
                    except AttributeError:
                        raise _e
                    else:
                        try:
                            _y = _m(*_x)
                        except StopIteration as _e:
                            _r = _value_from_stopiteration(_e)
                            break
                else:
                    try:
                        if _s is None:
                            _y = next(_i)
                        else:
                            _y = _i.send(_s)
                    except StopIteration as _e:
                        _r = _value_from_stopiteration(_e)
                        break
        raise Return(_r)


def convert_yielded(yielded):
    &quot;&quot;&quot;Convert a yielded object into a `.Future`.

    The default implementation accepts lists, dictionaries, and Futures.

    If the `~functools.singledispatch` library is available, this function
    may be extended to support additional types. For example::

        @convert_yielded.register(asyncio.Future)
        def _(asyncio_future):
            return tornado.platform.asyncio.to_tornado_future(asyncio_future)

    .. versionadded:: 4.1
    &quot;&quot;&quot;
    # Lists and dicts containing YieldPoints were handled earlier.
    if yielded is None:
        return moment
    elif isinstance(yielded, (list, dict)):
        return multi(yielded)
    elif is_future(yielded):
        return yielded
    elif isawaitable(yielded):
        return _wrap_awaitable(yielded)
    else:
        raise BadYieldError(&quot;yielded unknown object %r&quot; % (yielded,))


if singledispatch is not None:
    convert_yielded = singledispatch(convert_yielded)

    try:
        # If we can import t.p.asyncio, do it for its side effect
        # (registering asyncio.Future with convert_yielded).
        # It's ugly to do this here, but it prevents a cryptic
        # infinite recursion in _wrap_awaitable.
        # Note that even with this, asyncio integration is unlikely
        # to work unless the application also configures AsyncIOLoop,
        # but at least the error messages in that case are more
        # comprehensible than a stack overflow.
        import salt.ext.tornado.platform.asyncio
    except ImportError:
        pass
    else:
        # Reference the imported module to make pyflakes happy.
        tornado
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>version.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Set up the version of Salt
&quot;&quot;&quot;

import operator
import platform
import re
import sys
from collections import namedtuple
from functools import total_ordering

MAX_SIZE = sys.maxsize
VERSION_LIMIT = MAX_SIZE - 200

# ----- ATTENTION ---------------------------------------------------------------------------------------------------&gt;
#
# ALL major version bumps, new release codenames, MUST be defined in the SaltStackVersion.NAMES dictionary, i.e.:
#
#    class SaltStackVersion:
#
#        NAMES = {
#            'Hydrogen': (2014, 1),   # &lt;- This is the tuple to bump versions
#            ( ... )
#        }
#
#
# ONLY UPDATE CODENAMES AFTER BRANCHING
#
# As an example, The Helium codename must only be properly defined with &quot;(2014, 7)&quot; after Hydrogen, &quot;(2014, 1)&quot;, has
# been branched out into its own branch.
#
# ALL OTHER VERSION INFORMATION IS EXTRACTED FROM THE GIT TAGS
#
# &lt;---- ATTENTION ----------------------------------------------------------------------------------------------------


@total_ordering
class SaltVersion(namedtuple(&quot;SaltVersion&quot;, &quot;name, info, released&quot;)):
    __slots__ = ()

    def __new__(cls, name, info, released=False):
        if isinstance(info, int):
            info = (info,)
        return super().__new__(cls, name, info, released)

    def __eq__(self, other):
        return self.info == other.info

    def __gt__(self, other):
        return self.info &gt; other.info


class SaltVersionsInfo(type):

    _sorted_versions = ()
    _current_release = None
    _previous_release = None
    _next_release = None

    # pylint: disable=bad-whitespace,multiple-spaces-before-operator
    # ----- Please refrain from fixing whitespace ----------------------------------&gt;
    # The idea is to keep this readable.
    # -------------------------------------------------------------------------------
    # fmt: off
    HYDROGEN      = SaltVersion(&quot;Hydrogen&quot;     , info=(2014, 1),  released=True)
    HELIUM        = SaltVersion(&quot;Helium&quot;       , info=(2014, 7),  released=True)
    LITHIUM       = SaltVersion(&quot;Lithium&quot;      , info=(2015, 5),  released=True)
    BERYLLIUM     = SaltVersion(&quot;Beryllium&quot;    , info=(2015, 8),  released=True)
    BORON         = SaltVersion(&quot;Boron&quot;        , info=(2016, 3),  released=True)
    CARBON        = SaltVersion(&quot;Carbon&quot;       , info=(2016, 11), released=True)
    NITROGEN      = SaltVersion(&quot;Nitrogen&quot;     , info=(2017, 7),  released=True)
    OXYGEN        = SaltVersion(&quot;Oxygen&quot;       , info=(2018, 3),  released=True)
    FLUORINE      = SaltVersion(&quot;Fluorine&quot;     , info=(2019, 2),  released=True)
    NEON          = SaltVersion(&quot;Neon&quot;         , info=3000,       released=True)
    SODIUM        = SaltVersion(&quot;Sodium&quot;       , info=3001,       released=True)
    MAGNESIUM     = SaltVersion(&quot;Magnesium&quot;    , info=3002,       released=True)
    ALUMINIUM     = SaltVersion(&quot;Aluminium&quot;    , info=3003,       released=True)
    SILICON       = SaltVersion(&quot;Silicon&quot;      , info=3004,       released=True)
    PHOSPHORUS    = SaltVersion(&quot;Phosphorus&quot;   , info=3005)
    SULFUR        = SaltVersion(&quot;Sulfur&quot;       , info=3006)
    CHLORINE      = SaltVersion(&quot;Chlorine&quot;     , info=3007)
    ARGON         = SaltVersion(&quot;Argon&quot;        , info=3008)
    POTASSIUM     = SaltVersion(&quot;Potassium&quot;    , info=3009)
    CALCIUM       = SaltVersion(&quot;Calcium&quot;      , info=3010)
    SCANDIUM      = SaltVersion(&quot;Scandium&quot;     , info=3011)
    TITANIUM      = SaltVersion(&quot;Titanium&quot;     , info=3012)
    VANADIUM      = SaltVersion(&quot;Vanadium&quot;     , info=3013)
    CHROMIUM      = SaltVersion(&quot;Chromium&quot;     , info=3014)
    MANGANESE     = SaltVersion(&quot;Manganese&quot;    , info=3015)
    IRON          = SaltVersion(&quot;Iron&quot;         , info=3016)
    COBALT        = SaltVersion(&quot;Cobalt&quot;       , info=3017)
    NICKEL        = SaltVersion(&quot;Nickel&quot;       , info=3018)
    COPPER        = SaltVersion(&quot;Copper&quot;       , info=3019)
    ZINC          = SaltVersion(&quot;Zinc&quot;         , info=3020)
    GALLIUM       = SaltVersion(&quot;Gallium&quot;      , info=3021)
    GERMANIUM     = SaltVersion(&quot;Germanium&quot;    , info=3022)
    ARSENIC       = SaltVersion(&quot;Arsenic&quot;      , info=3023)
    SELENIUM      = SaltVersion(&quot;Selenium&quot;     , info=3024)
    BROMINE       = SaltVersion(&quot;Bromine&quot;      , info=3025)
    KRYPTON       = SaltVersion(&quot;Krypton&quot;      , info=3026)
    RUBIDIUM      = SaltVersion(&quot;Rubidium&quot;     , info=3027)
    STRONTIUM     = SaltVersion(&quot;Strontium&quot;    , info=3028)
    YTTRIUM       = SaltVersion(&quot;Yttrium&quot;      , info=3029)
    ZIRCONIUM     = SaltVersion(&quot;Zirconium&quot;    , info=3030)
    NIOBIUM       = SaltVersion(&quot;Niobium&quot;      , info=3031)
    MOLYBDENUM    = SaltVersion(&quot;Molybdenum&quot;   , info=3032)
    TECHNETIUM    = SaltVersion(&quot;Technetium&quot;   , info=3033)
    RUTHENIUM     = SaltVersion(&quot;Ruthenium&quot;    , info=3034)
    RHODIUM       = SaltVersion(&quot;Rhodium&quot;      , info=3035)
    PALLADIUM     = SaltVersion(&quot;Palladium&quot;    , info=3036)
    SILVER        = SaltVersion(&quot;Silver&quot;       , info=3037)
    CADMIUM       = SaltVersion(&quot;Cadmium&quot;      , info=3038)
    INDIUM        = SaltVersion(&quot;Indium&quot;       , info=3039)
    TIN           = SaltVersion(&quot;Tin&quot;          , info=3040)
    ANTIMONY      = SaltVersion(&quot;Antimony&quot;     , info=3041)
    TELLURIUM     = SaltVersion(&quot;Tellurium&quot;    , info=3042)
    IODINE        = SaltVersion(&quot;Iodine&quot;       , info=3043)
    XENON         = SaltVersion(&quot;Xenon&quot;        , info=3044)
    CESIUM        = SaltVersion(&quot;Cesium&quot;       , info=3045)
    BARIUM        = SaltVersion(&quot;Barium&quot;       , info=3046)
    LANTHANUM     = SaltVersion(&quot;Lanthanum&quot;    , info=3047)
    CERIUM        = SaltVersion(&quot;Cerium&quot;       , info=3048)
    PRASEODYMIUM  = SaltVersion(&quot;Praseodymium&quot; , info=3049)
    NEODYMIUM     = SaltVersion(&quot;Neodymium&quot;    , info=3050)
    PROMETHIUM    = SaltVersion(&quot;Promethium&quot;   , info=3051)
    SAMARIUM      = SaltVersion(&quot;Samarium&quot;     , info=3052)
    EUROPIUM      = SaltVersion(&quot;Europium&quot;     , info=3053)
    GADOLINIUM    = SaltVersion(&quot;Gadolinium&quot;   , info=3054)
    TERBIUM       = SaltVersion(&quot;Terbium&quot;      , info=3055)
    DYSPROSIUM    = SaltVersion(&quot;Dysprosium&quot;   , info=3056)
    HOLMIUM       = SaltVersion(&quot;Holmium&quot;      , info=3057)
    ERBIUM        = SaltVersion(&quot;Erbium&quot;       , info=3058)
    THULIUM       = SaltVersion(&quot;Thulium&quot;      , info=3059)
    YTTERBIUM     = SaltVersion(&quot;Ytterbium&quot;    , info=3060)
    LUTETIUM      = SaltVersion(&quot;Lutetium&quot;     , info=3061)
    HAFNIUM       = SaltVersion(&quot;Hafnium&quot;      , info=3062)
    TANTALUM      = SaltVersion(&quot;Tantalum&quot;     , info=3063)
    TUNGSTEN      = SaltVersion(&quot;Tungsten&quot;     , info=3064)
    RHENIUM       = SaltVersion(&quot;Rhenium&quot;      , info=3065)
    OSMIUM        = SaltVersion(&quot;Osmium&quot;       , info=3066)
    IRIDIUM       = SaltVersion(&quot;Iridium&quot;      , info=3067)
    PLATINUM      = SaltVersion(&quot;Platinum&quot;     , info=3068)
    GOLD          = SaltVersion(&quot;Gold&quot;         , info=3069)
    MERCURY       = SaltVersion(&quot;Mercury&quot;      , info=3070)
    THALLIUM      = SaltVersion(&quot;Thallium&quot;     , info=3071)
    LEAD          = SaltVersion(&quot;Lead&quot;         , info=3072)
    BISMUTH       = SaltVersion(&quot;Bismuth&quot;      , info=3073)
    POLONIUM      = SaltVersion(&quot;Polonium&quot;     , info=3074)
    ASTATINE      = SaltVersion(&quot;Astatine&quot;     , info=3075)
    RADON         = SaltVersion(&quot;Radon&quot;        , info=3076)
    FRANCIUM      = SaltVersion(&quot;Francium&quot;     , info=3077)
    RADIUM        = SaltVersion(&quot;Radium&quot;       , info=3078)
    ACTINIUM      = SaltVersion(&quot;Actinium&quot;     , info=3079)
    THORIUM       = SaltVersion(&quot;Thorium&quot;      , info=3080)
    PROTACTINIUM  = SaltVersion(&quot;Protactinium&quot; , info=3081)
    URANIUM       = SaltVersion(&quot;Uranium&quot;      , info=3082)
    NEPTUNIUM     = SaltVersion(&quot;Neptunium&quot;    , info=3083)
    PLUTONIUM     = SaltVersion(&quot;Plutonium&quot;    , info=3084)
    AMERICIUM     = SaltVersion(&quot;Americium&quot;    , info=3085)
    CURIUM        = SaltVersion(&quot;Curium&quot;       , info=3086)
    BERKELIUM     = SaltVersion(&quot;Berkelium&quot;    , info=3087)
    CALIFORNIUM   = SaltVersion(&quot;Californium&quot;  , info=3088)
    EINSTEINIUM   = SaltVersion(&quot;Einsteinium&quot;  , info=3089)
    FERMIUM       = SaltVersion(&quot;Fermium&quot;      , info=3090)
    MENDELEVIUM   = SaltVersion(&quot;Mendelevium&quot;  , info=3091)
    NOBELIUM      = SaltVersion(&quot;Nobelium&quot;     , info=3092)
    LAWRENCIUM    = SaltVersion(&quot;Lawrencium&quot;   , info=3093)
    RUTHERFORDIUM = SaltVersion(&quot;Rutherfordium&quot;, info=3094)
    DUBNIUM       = SaltVersion(&quot;Dubnium&quot;      , info=3095)
    SEABORGIUM    = SaltVersion(&quot;Seaborgium&quot;   , info=3096)
    BOHRIUM       = SaltVersion(&quot;Bohrium&quot;      , info=3097)
    HASSIUM       = SaltVersion(&quot;Hassium&quot;      , info=3098)
    MEITNERIUM    = SaltVersion(&quot;Meitnerium&quot;   , info=3099)
    DARMSTADTIUM  = SaltVersion(&quot;Darmstadtium&quot; , info=3100)
    ROENTGENIUM   = SaltVersion(&quot;Roentgenium&quot;  , info=3101)
    COPERNICIUM   = SaltVersion(&quot;Copernicium&quot;  , info=3102)
    NIHONIUM      = SaltVersion(&quot;Nihonium&quot;     , info=3103)
    FLEROVIUM     = SaltVersion(&quot;Flerovium&quot;    , info=3104)
    MOSCOVIUM     = SaltVersion(&quot;Moscovium&quot;    , info=3105)
    LIVERMORIUM   = SaltVersion(&quot;Livermorium&quot;  , info=3106)
    TENNESSINE    = SaltVersion(&quot;Tennessine&quot;   , info=3107)
    OGANESSON     = SaltVersion(&quot;Oganesson&quot;    , info=3108)
    # &lt;---- Please refrain from fixing whitespace -----------------------------------
    # The idea is to keep this readable.
    # -------------------------------------------------------------------------------
    # pylint: enable=bad-whitespace,multiple-spaces-before-operator
    # fmt: on

    @classmethod
    def versions(cls):
        if not cls._sorted_versions:
            cls._sorted_versions = sorted(
                (getattr(cls, name) for name in dir(cls) if name.isupper()),
                key=operator.attrgetter(&quot;info&quot;),
            )
        return cls._sorted_versions

    @classmethod
    def current_release(cls):
        if cls._current_release is None:
            for version in cls.versions():
                if version.released is False:
                    cls._current_release = version
                    break
        return cls._current_release

    @classmethod
    def next_release(cls):
        if cls._next_release is None:
            next_release_ahead = False
            for version in cls.versions():
                if next_release_ahead:
                    cls._next_release = version
                    break
                if version == cls.current_release():
                    next_release_ahead = True
        return cls._next_release

    @classmethod
    def previous_release(cls):
        if cls._previous_release is None:
            previous = None
            for version in cls.versions():
                if version == cls.current_release():
                    break
                previous = version
            cls._previous_release = previous
        return cls._previous_release


class SaltStackVersion:
    &quot;&quot;&quot;
    Handle SaltStack versions class.

    Knows how to parse ``git describe`` output, knows about release candidates
    and also supports version comparison.
    &quot;&quot;&quot;

    __slots__ = (
        &quot;name&quot;,
        &quot;major&quot;,
        &quot;minor&quot;,
        &quot;bugfix&quot;,
        &quot;mbugfix&quot;,
        &quot;pre_type&quot;,
        &quot;pre_num&quot;,
        &quot;noc&quot;,
        &quot;sha&quot;,
    )

    git_sha_regex = r&quot;(?P&lt;sha&gt;g?[a-f0-9]{7,40})&quot;

    git_describe_regex = re.compile(
        r&quot;(?:[^\d]+)?(?P&lt;major&gt;[\d]{1,4})&quot;
        r&quot;(?:\.(?P&lt;minor&gt;[\d]{1,2}))?&quot;
        r&quot;(?:\.(?P&lt;bugfix&gt;[\d]{0,2}))?&quot;
        r&quot;(?:\.(?P&lt;mbugfix&gt;[\d]{0,2}))?&quot;
        r&quot;(?:(?P&lt;pre_type&gt;rc|a|b|alpha|beta|nb)(?P&lt;pre_num&gt;[\d]+))?&quot;
        r&quot;(?:(?:.*)(?:\+|-)(?P&lt;noc&gt;(?:0na|[\d]+|n/a))(?:-|\.)&quot; + git_sha_regex + r&quot;)?&quot;
    )
    git_sha_regex = r&quot;^&quot; + git_sha_regex

    git_sha_regex = re.compile(git_sha_regex)

    NAMES = {v.name: v.info for v in SaltVersionsInfo.versions()}
    LNAMES = {k.lower(): v for (k, v) in iter(NAMES.items())}
    VNAMES = {v: k for (k, v) in iter(NAMES.items())}
    RMATCH = {v[:2]: k for (k, v) in iter(NAMES.items())}

    def __init__(
        self,  # pylint: disable=C0103
        major,
        minor=None,
        bugfix=None,
        mbugfix=0,
        pre_type=None,
        pre_num=None,
        noc=0,
        sha=None,
    ):

        if isinstance(major, str):
            major = int(major)

        if isinstance(minor, str):
            if not minor:
                # Empty string
                minor = None
            else:
                minor = int(minor)

        if bugfix is None and not self.new_version(major=major):
            bugfix = 0
        elif isinstance(bugfix, str):
            if not bugfix:
                bugfix = None
            else:
                bugfix = int(bugfix)

        if mbugfix is None:
            mbugfix = 0
        elif isinstance(mbugfix, str):
            mbugfix = int(mbugfix)

        if pre_type is None:
            pre_type = &quot;&quot;
        if pre_num is None:
            pre_num = 0
        elif isinstance(pre_num, str):
            pre_num = int(pre_num)

        if noc is None:
            noc = 0
        elif isinstance(noc, str) and noc in (&quot;0na&quot;, &quot;n/a&quot;):
            noc = -1
<A NAME="0"></A>        elif isinstance(noc, str):
            noc = int(noc)

        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match271985-0.html#0',2,'match271985-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.major = major
        self.minor = minor
        self.bugfix = bugfix
        self.mbugfix = mbugfix
        self.pre_type = pre_type
        self.pre_num =</B></FONT> pre_num
        if self.new_version(major):
            vnames_key = (major,)
        else:
            vnames_key = (major, minor)
        self.name = self.VNAMES.get(vnames_key)
        self.noc = noc
        self.sha = sha

    def new_version(self, major):
        &quot;&quot;&quot;
        determine if using new versioning scheme
        &quot;&quot;&quot;
        return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)

    @classmethod
    def parse(cls, version_string):
        if version_string.lower() in cls.LNAMES:
            return cls.from_name(version_string)
        vstr = (
            version_string.decode()
            if isinstance(version_string, bytes)
            else version_string
        )
        match = cls.git_describe_regex.match(vstr)
        if not match:
            raise ValueError(
                &quot;Unable to parse version string: '{}'&quot;.format(version_string)
            )
        return cls(*match.groups())

    @classmethod
    def from_name(cls, name):
        if name.lower() not in cls.LNAMES:
            raise ValueError(&quot;Named version '{}' is not known&quot;.format(name))
        return cls(*cls.LNAMES[name.lower()])

    @classmethod
    def from_last_named_version(cls):
        import salt.utils.versions

        salt.utils.versions.warn_until(
            SaltVersionsInfo.SULFUR,
            &quot;The use of SaltStackVersion.from_last_named_version() is &quot;
            &quot;deprecated and set to be removed in {version}. Please use &quot;
            &quot;SaltStackVersion.current_release() instead.&quot;,
        )
        return cls.current_release()

    @classmethod
    def current_release(cls):
        return cls(*SaltVersionsInfo.current_release().info)

    @classmethod
    def next_release(cls):
        return cls(*SaltVersionsInfo.next_release().info)

    @property
    def sse(self):
        # Higher than 0.17, lower than first date based
        return 0 &lt; self.major &lt; 2014

    def min_info(self):
        info = [self.major]
        if self.new_version(self.major):
            if self.minor:
                info.append(self.minor)
        else:
            info.extend([self.minor, self.bugfix, self.mbugfix])
        return info

    @property
    def info(self):
        return tuple(self.min_info())

    @property
    def pre_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num])
        return tuple(info)

    @property
    def noc_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num, self.noc])
        return tuple(info)

    @property
    def full_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
        return tuple(info)

    @property
    def full_info_all_versions(self):
        &quot;&quot;&quot;
        Return the full info regardless
        of which versioning scheme we
        are using.
        &quot;&quot;&quot;
        info = [
            self.major,
            self.minor,
            self.bugfix,
            self.mbugfix,
            self.pre_type,
            self.pre_num,
            self.noc,
            self.sha,
        ]
        return tuple(info)

    @property
    def string(self):
        if self.new_version(self.major):
            version_string = &quot;{}&quot;.format(self.major)
            if self.minor:
                version_string = &quot;{}.{}&quot;.format(self.major, self.minor)
        else:
            version_string = &quot;{}.{}.{}&quot;.format(self.major, self.minor, self.bugfix)
        if self.mbugfix:
            version_string += &quot;.{}&quot;.format(self.mbugfix)
        if self.pre_type:
            version_string += &quot;{}{}&quot;.format(self.pre_type, self.pre_num)
        if self.noc and self.sha:
            noc = self.noc
            if noc &lt; 0:
                noc = &quot;0na&quot;
            version_string += &quot;+{}.{}&quot;.format(noc, self.sha)
        return version_string

    @property
    def formatted_version(self):
        if self.name and self.major &gt; 10000:
            version_string = self.name
            if self.sse:
                version_string += &quot; Enterprise&quot;
            version_string += &quot; (Unreleased)&quot;
            return version_string
        version_string = self.string
        if self.sse:
            version_string += &quot; Enterprise&quot;
        if (self.major, self.minor) in self.RMATCH:
            version_string += &quot; ({})&quot;.format(self.RMATCH[(self.major, self.minor)])
        return version_string

    @property
    def pre_index(self):
        if self.new_version(self.major):
            pre_type = 2
            if not isinstance(self.minor, int):
                pre_type = 1
        else:
            pre_type = 4
        return pre_type

    def __str__(self):
        return self.string

    def __compare__(self, other, method):
        if not isinstance(other, SaltStackVersion):
            if isinstance(other, str):
                other = SaltStackVersion.parse(other)
            elif isinstance(other, (list, tuple)):
                other = SaltStackVersion(*other)
            else:
                raise ValueError(
                    &quot;Cannot instantiate Version from type '{}'&quot;.format(type(other))
                )

        pre_type = self.pre_index
        other_pre_type = other.pre_index
        other_noc_info = list(other.noc_info)
        noc_info = list(self.noc_info)

        if self.new_version(self.major):
            if self.minor and not other.minor:
                # We have minor information, the other side does not
                if self.minor &gt; 0:
                    other_noc_info[1] = 0

            if not self.minor and other.minor:
                # The other side has minor information, we don't
                if other.minor &gt; 0:
                    noc_info[1] = 0

        if self.pre_type and not other.pre_type:
            # We have pre-release information, the other side doesn't
            other_noc_info[other_pre_type] = &quot;zzzzz&quot;

        if not self.pre_type and other.pre_type:
            # The other side has pre-release information, we don't
            noc_info[pre_type] = &quot;zzzzz&quot;

        return method(tuple(noc_info), tuple(other_noc_info))

    def __lt__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &lt; _other)

    def __le__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &lt;= _other)

    def __eq__(self, other):
        return self.__compare__(other, lambda _self, _other: _self == _other)

    def __ne__(self, other):
        return self.__compare__(other, lambda _self, _other: _self != _other)

    def __ge__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &gt;= _other)

    def __gt__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &gt; _other)

    def __repr__(self):
        parts = []
        if self.name:
            parts.append(&quot;name='{}'&quot;.format(self.name))
        parts.extend([&quot;major={}&quot;.format(self.major), &quot;minor={}&quot;.format(self.minor)])

        if self.new_version(self.major):
            if not self.minor:
                parts.remove(&quot;&quot;.join([x for x in parts if re.search(&quot;^minor*&quot;, x)]))
        else:
            parts.extend([&quot;bugfix={}&quot;.format(self.bugfix)])

        if self.mbugfix:
            parts.append(&quot;minor-bugfix={}&quot;.format(self.mbugfix))
        if self.pre_type:
            parts.append(&quot;{}={}&quot;.format(self.pre_type, self.pre_num))
        noc = self.noc
        if noc == -1:
            noc = &quot;0na&quot;
        if noc and self.sha:
            parts.extend([&quot;noc={}&quot;.format(noc), &quot;sha={}&quot;.format(self.sha)])
        return &quot;&lt;{} {}&gt;&quot;.format(self.__class__.__name__, &quot; &quot;.join(parts))


# ----- Hardcoded Salt Codename Version Information -----------------------------------------------------------------&gt;
#
#   There's no need to do anything here. The last released codename will be picked up
# --------------------------------------------------------------------------------------------------------------------
__saltstack_version__ = SaltStackVersion.current_release()
# &lt;---- Hardcoded Salt Version Information ---------------------------------------------------------------------------


# ----- Dynamic/Runtime Salt Version Information --------------------------------------------------------------------&gt;
def __discover_version(saltstack_version):
    # This might be a 'python setup.py develop' installation type. Let's
    # discover the version information at runtime.
    import os
    import subprocess

    if &quot;SETUP_DIRNAME&quot; in globals():
        # This is from the exec() call in Salt's setup.py
        cwd = SETUP_DIRNAME  # pylint: disable=E0602
        if not os.path.exists(os.path.join(cwd, &quot;.git&quot;)):
            # This is not a Salt git checkout!!! Don't even try to parse...
            return saltstack_version
    else:
        cwd = os.path.abspath(os.path.dirname(__file__))
        if not os.path.exists(os.path.join(os.path.dirname(cwd), &quot;.git&quot;)):
            # This is not a Salt git checkout!!! Don't even try to parse...
            return saltstack_version

    try:
        kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)

        if not sys.platform.startswith(&quot;win&quot;):
            # Let's not import `salt.utils` for the above check
            kwargs[&quot;close_fds&quot;] = True

        process = subprocess.Popen(
            [
                &quot;git&quot;,
                &quot;describe&quot;,
                &quot;--tags&quot;,
                &quot;--long&quot;,
                &quot;--match&quot;,
                &quot;v[0-9]*&quot;,
                &quot;--always&quot;,
            ],
            **kwargs
        )

        out, err = process.communicate()

        out = out.decode().strip()
        err = err.decode().strip()

        if not out or err:
            return saltstack_version

        if SaltStackVersion.git_sha_regex.match(out):
            # We only define the parsed SHA and set NOC as ??? (unknown)
            saltstack_version.sha = out.strip()
            saltstack_version.noc = -1
            return saltstack_version

        return SaltStackVersion.parse(out)

    except OSError as os_err:
        if os_err.errno != 2:
            # If the errno is not 2(The system cannot find the file
            # specified), raise the exception so it can be catch by the
            # developers
            raise
    return saltstack_version


def __get_version(saltstack_version):
    &quot;&quot;&quot;
    If we can get a version provided at installation time or from Git, use
    that instead, otherwise we carry on.
    &quot;&quot;&quot;
    try:
        # Try to import the version information provided at install time
        from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401

        return __saltstack_version__
    except ImportError:
        return __discover_version(saltstack_version)


# Get additional version information if available
__saltstack_version__ = __get_version(__saltstack_version__)
if __saltstack_version__.name:
    # Set SaltVersionsInfo._current_release to avoid lookups when finding previous and next releases
    SaltVersionsInfo._current_release = getattr(
        SaltVersionsInfo, __saltstack_version__.name.upper()
    )

# This function has executed once, we're done with it. Delete it!
del __get_version
# &lt;---- Dynamic/Runtime Salt Version Information ---------------------------------------------------------------------


# ----- Common version related attributes - NO NEED TO CHANGE -------------------------------------------------------&gt;
__version_info__ = __saltstack_version__.info
__version__ = __saltstack_version__.string
# &lt;---- Common version related attributes - NO NEED TO CHANGE --------------------------------------------------------


def salt_information():
    &quot;&quot;&quot;
    Report version of salt.
    &quot;&quot;&quot;
    yield &quot;Salt&quot;, __version__


def dependency_information(include_salt_cloud=False):
    &quot;&quot;&quot;
    Report versions of library dependencies.
    &quot;&quot;&quot;
    libs = [
        (&quot;Python&quot;, None, sys.version.rsplit(&quot;\n&quot;)[0].strip()),
        (&quot;Jinja2&quot;, &quot;jinja2&quot;, &quot;__version__&quot;),
        (&quot;M2Crypto&quot;, &quot;M2Crypto&quot;, &quot;version&quot;),
        (&quot;msgpack&quot;, &quot;msgpack&quot;, &quot;version&quot;),
        (&quot;msgpack-pure&quot;, &quot;msgpack_pure&quot;, &quot;version&quot;),
        (&quot;pycrypto&quot;, &quot;Crypto&quot;, &quot;__version__&quot;),
        (&quot;pycryptodome&quot;, &quot;Cryptodome&quot;, &quot;version_info&quot;),
        (&quot;PyYAML&quot;, &quot;yaml&quot;, &quot;__version__&quot;),
        (&quot;PyZMQ&quot;, &quot;zmq&quot;, &quot;__version__&quot;),
        (&quot;ZMQ&quot;, &quot;zmq&quot;, &quot;zmq_version&quot;),
        (&quot;Mako&quot;, &quot;mako&quot;, &quot;__version__&quot;),
        (&quot;Tornado&quot;, &quot;tornado&quot;, &quot;version&quot;),
        (&quot;timelib&quot;, &quot;timelib&quot;, &quot;version&quot;),
        (&quot;dateutil&quot;, &quot;dateutil&quot;, &quot;__version__&quot;),
        (&quot;pygit2&quot;, &quot;pygit2&quot;, &quot;__version__&quot;),
        (&quot;libgit2&quot;, &quot;pygit2&quot;, &quot;LIBGIT2_VERSION&quot;),
        (&quot;smmap&quot;, &quot;smmap&quot;, &quot;__version__&quot;),
        (&quot;cffi&quot;, &quot;cffi&quot;, &quot;__version__&quot;),
        (&quot;pycparser&quot;, &quot;pycparser&quot;, &quot;__version__&quot;),
        (&quot;gitdb&quot;, &quot;gitdb&quot;, &quot;__version__&quot;),
        (&quot;gitpython&quot;, &quot;git&quot;, &quot;__version__&quot;),
        (&quot;python-gnupg&quot;, &quot;gnupg&quot;, &quot;__version__&quot;),
        (&quot;mysql-python&quot;, &quot;MySQLdb&quot;, &quot;__version__&quot;),
        (&quot;cherrypy&quot;, &quot;cherrypy&quot;, &quot;__version__&quot;),
        (&quot;docker-py&quot;, &quot;docker&quot;, &quot;__version__&quot;),
    ]

    if include_salt_cloud:
        libs.append(
            (&quot;Apache Libcloud&quot;, &quot;libcloud&quot;, &quot;__version__&quot;),
        )

    for name, imp, attr in libs:
        if imp is None:
            yield name, attr
            continue
        try:
            imp = __import__(imp)
            version = getattr(imp, attr)
            if callable(version):
                version = version()
            if isinstance(version, (tuple, list)):
                version = &quot;.&quot;.join(map(str, version))
            yield name, version
        except Exception:  # pylint: disable=broad-except
            yield name, None


def system_information():
    &quot;&quot;&quot;
    Report system versions.
    &quot;&quot;&quot;
    # Late import so that when getting called from setup.py does not break
    from distro import linux_distribution

    def system_version():
        &quot;&quot;&quot;
        Return host system version.
        &quot;&quot;&quot;

        lin_ver = linux_distribution()
        mac_ver = platform.mac_ver()
        win_ver = platform.win32_ver()

        # linux_distribution() will return a
        # distribution on OS X and Windows.
        # Check mac_ver and win_ver first,
        # then lin_ver.
        if mac_ver[0]:
            if isinstance(mac_ver[1], (tuple, list)) and &quot;&quot;.join(mac_ver[1]):
                return &quot; &quot;.join([mac_ver[0], &quot;.&quot;.join(mac_ver[1]), mac_ver[2]])
            else:
                return &quot; &quot;.join([mac_ver[0], mac_ver[2]])
        elif win_ver[0]:
            return &quot; &quot;.join(win_ver)
        elif lin_ver[0]:
            return &quot; &quot;.join(lin_ver)
        else:
            return &quot;&quot;

    if platform.win32_ver()[0]:
        # Get the version and release info based on the Windows Operating
        # System Product Name. As long as Microsoft maintains a similar format
        # this should be future proof
        import win32api  # pylint: disable=3rd-party-module-not-gated
        import win32con  # pylint: disable=3rd-party-module-not-gated

        # Get the product name from the registry
        hkey = win32con.HKEY_LOCAL_MACHINE
        key = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot;
        value_name = &quot;ProductName&quot;
        reg_handle = win32api.RegOpenKey(hkey, key)

        # Returns a tuple of (product_name, value_type)
        product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)

        version = &quot;Unknown&quot;
        release = &quot;&quot;
        if &quot;Server&quot; in product_name:
            for item in product_name.split(&quot; &quot;):
                # If it's all digits, then it's version
                if re.match(r&quot;\d+&quot;, item):
                    version = item
                # If it starts with R and then numbers, it's the release
                # ie: R2
                if re.match(r&quot;^R\d+$&quot;, item):
                    release = item
            release = &quot;{}Server{}&quot;.format(version, release)
        else:
            for item in product_name.split(&quot; &quot;):
                # If it's a number, decimal number, Thin or Vista, then it's the
                # version
                if re.match(r&quot;^(\d+(\.\d+)?)|Thin|Vista$&quot;, item):
                    version = item
            release = version

        _, ver, service_pack, extra = platform.win32_ver()
        version = &quot; &quot;.join([release, ver, service_pack, extra])
    else:
        version = system_version()
        release = platform.release()

    system = [
        (&quot;system&quot;, platform.system()),
        (&quot;dist&quot;, &quot; &quot;.join(linux_distribution(full_distribution_name=False))),
        (&quot;release&quot;, release),
        (&quot;machine&quot;, platform.machine()),
        (&quot;version&quot;, version),
        (&quot;locale&quot;, __salt_system_encoding__),
    ]

    for name, attr in system:
        yield name, attr
        continue


def extensions_information():
    &quot;&quot;&quot;
    Gather infomation about any installed salt extensions
    &quot;&quot;&quot;
    # Late import
    import salt.utils.entrypoints

    extensions = {}
    for entry_point in salt.utils.entrypoints.iter_entry_points(&quot;salt.loader&quot;):
        dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
        if not dist_nv:
            continue
        if dist_nv.name in extensions:
            continue
        extensions[dist_nv.name] = dist_nv.version
    return extensions


def versions_information(include_salt_cloud=False, include_extensions=True):
    &quot;&quot;&quot;
    Report the versions of dependent software.
    &quot;&quot;&quot;
    salt_info = list(salt_information())
    lib_info = list(dependency_information(include_salt_cloud))
    sys_info = list(system_information())

    info = {
        &quot;Salt Version&quot;: dict(salt_info),
        &quot;Dependency Versions&quot;: dict(lib_info),
        &quot;System Versions&quot;: dict(sys_info),
    }
    if include_extensions:
        extensions_info = extensions_information()
        if extensions_info:
            info[&quot;Salt Extensions&quot;] = extensions_info
    return info


def versions_report(include_salt_cloud=False, include_extensions=True):
    &quot;&quot;&quot;
    Yield each version properly formatted for console output.
    &quot;&quot;&quot;
    ver_info = versions_information(
        include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
    )
    not_installed = &quot;Not Installed&quot;
    ns_pad = len(not_installed)
    lib_pad = max(len(name) for name in ver_info[&quot;Dependency Versions&quot;])
    sys_pad = max(len(name) for name in ver_info[&quot;System Versions&quot;])
    if include_extensions and &quot;Salt Extensions&quot; in ver_info:
        ext_pad = max(len(name) for name in ver_info[&quot;Salt Extensions&quot;])
    else:
        ext_pad = 1
    padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1

    fmt = &quot;{0:&gt;{pad}}: {1}&quot;
    info = []
    for ver_type in (
        &quot;Salt Version&quot;,
        &quot;Dependency Versions&quot;,
        &quot;Salt Extensions&quot;,
        &quot;System Versions&quot;,
    ):
        if ver_type == &quot;Salt Extensions&quot; and ver_type not in ver_info:
            # No salt Extensions to report
            continue
        info.append(&quot;{}:&quot;.format(ver_type))
        # List dependencies in alphabetical, case insensitive order
        for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
            ver = fmt.format(
                name, ver_info[ver_type][name] or not_installed, pad=padding
            )
            info.append(ver)
        info.append(&quot; &quot;)

    yield from info


if __name__ == &quot;__main__&quot;:
    print(__version__)
</PRE>
</div>
  </div>
</body>
</html>
