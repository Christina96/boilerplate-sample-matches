<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for datadog_api.py &amp; test_boto_cognitoidentity.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datadog_api.py &amp; test_boto_cognitoidentity.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datadog_api.py (5.581395%)<th>test_boto_cognitoidentity.py (1.4492754%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(172-214)<td><a href="#" name="0">(49-60)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datadog_api.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import requests
2 from salt.exceptions import SaltInvocationError
3 HAS_DATADOG = True
4 try:
5     import datadog
6 except ImportError:
7     HAS_DATADOG = False
8 __virtualname__ = "datadog"
9 def __virtual__():
10     if HAS_DATADOG:
11         return "datadog"
12     else:
13         message = "Unable to import the python datadog module. Is it installed?"
14         return False, message
15 def _initialize_connection(api_key, app_key):
16     if api_key is None:
17         raise SaltInvocationError("api_key must be specified")
18     if app_key is None:
19         raise SaltInvocationError("app_key must be specified")
20     options = {"api_key": api_key, "app_key": app_key}
21     datadog.initialize(**options)
22 def schedule_downtime(
23     scope,
24     api_key=None,
25     app_key=None,
26     monitor_id=None,
27     start=None,
28     end=None,
29     message=None,
30     recurrence=None,
31     timezone=None,
32     test=False,
33 ):
34     ret = {"result": False, "response": None, "comment": ""}
35     if api_key is None:
36         raise SaltInvocationError("api_key must be specified")
37     if app_key is None:
38         raise SaltInvocationError("app_key must be specified")
39     if test is True:
40         ret["result"] = True
41         ret["comment"] = "A schedule downtime API call would have been made."
42         return ret
43     _initialize_connection(api_key, app_key)
44     try:
45         response = datadog.api.Downtime.create(
46             scope=scope,
47             monitor_id=monitor_id,
48             start=start,
49             end=end,
50             message=message,
51             recurrence=recurrence,
52             timezone=timezone,
53         )
54     except ValueError:
55         comment = (
56             "Unexpected exception in Datadog Schedule Downtime API "
57             "call. Are your keys correct?"
58         )
59         ret["comment"] = comment
60         return ret
61     ret["response"] = response
62     if "active" in response.keys():
63         ret["result"] = True
64         ret["comment"] = "Successfully scheduled downtime"
65     return ret
66 def cancel_downtime(api_key=None, app_key=None, scope=None, id=None):
67     if api_key is None:
68         raise SaltInvocationError("api_key must be specified")
69     if app_key is None:
70         raise SaltInvocationError("app_key must be specified")
71     _initialize_connection(api_key, app_key)
72     ret = {"result": False, "response": None, "comment": ""}
73     if id:
74         response = datadog.api.Downtime.delete(id)
75         ret["response"] = response
76         if not response:  # Then call has succeeded
77             ret["result"] = True
78             ret["comment"] = "Successfully cancelled downtime"
79         return ret
80     elif scope:
81         params = {"api_key": api_key, "application_key": app_key, "scope": scope}
82         response = requests.post(
83             "https://app.datadoghq.com/api/v1/downtime/cancel/by_scope", params=params
84         )
85         if response.status_code == 200:
86             ret["result"] = True
87             ret["response"] = response.json()
88             ret["comment"] = "Successfully cancelled downtime"
89         else:
90             ret["response"] = response.text
91             ret["comment"] = "Status Code: {}".format(response.status_code)
92         return ret
93     else:
94         raise SaltInvocationError("One of id or scope must be specified")
95     return ret
96 def post_event(
97     api_key<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
98     app_key=None,
99     title=None,
100     text=None,
101     date_happened=None,
102     priority=None,
103     host=None,
104     tags=None,
105     alert_type=None,
106     aggregation_key=None,
107     source_type_name=None,
108 ):
109     _initialize_connection(</b></font>api_key, app_key)
110     if title is None:
111         raise SaltInvocationError("title must be specified")
112     if text is None:
113         raise SaltInvocationError("text must be specified")
114     if alert_type not in [None, "error", "warning", "info", "success"]:
115         message = 'alert_type must be one of "error", "warning", "info", or "success"'
116         raise SaltInvocationError(message)
117     ret = {"result": False, "response": None, "comment": ""}
118     try:
119         response = datadog.api.Event.create(
120             title=title,
121             text=text,
122             date_happened=date_happened,
123             priority=priority,
124             host=host,
125             tags=tags,
126             alert_type=alert_type,
127             aggregation_key=aggregation_key,
128             source_type_name=source_type_name,
129         )
130     except ValueError:
131         comment = (
132             "Unexpected exception in Datadog Post Event API "
133             "call. Are your keys correct?"
134         )
135         ret["comment"] = comment
136         return ret
137     ret["response"] = response
138     if "status" in response.keys():
139         ret["result"] = True
140         ret["comment"] = "Successfully sent event"
141     else:
142         ret["comment"] = "Error in posting event."
143     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_cognitoidentity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import random
3 import string
4 import pytest
5 import salt.config
6 import salt.loader
7 import salt.states.boto_cognitoidentity as boto_cognitoidentity
8 from salt.utils.versions import LooseVersion
9 from tests.support.mixins import LoaderModuleMockMixin
10 from tests.support.mock import MagicMock, patch
11 from tests.support.unit import TestCase, skipIf
12 from tests.unit.modules.test_boto_cognitoidentity import (
13     BotoCognitoIdentityTestCaseMixin,
14 )
15 try:
16     import boto3
17     from botocore.exceptions import ClientError
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 required_boto3_version = "1.2.1"
22 region = "us-east-1"
23 access_key = "GKTADJGHEIQSXMKKRBJ08H"
24 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
25 conn_parameters = {
26     "region": region,
27     "key": access_key,
28     "keyid": secret_key,
29     "profile": {},
30 }
31 error_message = (
32     "An error occurred (101) when calling the {0} operation: Test-defined error"
33 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
34 first_pool_id <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "first_pool_id"
35 first_pool_name = "first_pool"
36 second_pool_id = "second_pool_id"
37 second_pool_name = "second_pool"
38 second_pool_name_updated = "second_pool_updated"
39 third_pool_id = "third_pool_id"
40 third_pool_name = first_pool_name
41 default_pool_name = "default_pool_name"
42 default_pool_id = "default_pool_id"
43 default_dev_provider = "test_provider_default"
44 identity_pools_ret = dict(</b></font>
45     IdentityPools=[
46         dict(IdentityPoolId=first_pool_id, IdentityPoolName=first_pool_name),
47         dict(IdentityPoolId=second_pool_id, IdentityPoolName=second_pool_name),
48         dict(IdentityPoolId=third_pool_id, IdentityPoolName=third_pool_name),
49     ]
50 )
51 first_pool_ret = dict(
52     IdentityPoolId=first_pool_id,
53     IdentityPoolName=first_pool_name,
54     AllowUnauthenticatedIdentities=False,
55     SupportedLoginProviders={
56         "accounts.google.com": "testing123",
57         "api.twitter.com": "testing123",
58         "graph.facebook.com": "testing123",
59         "www.amazon.com": "testing123",
60     },
61     DeveloperProviderName="test_provider",
62     OpenIdConnectProviderARNs=["some_provider_arn", "another_provider_arn"],
63 )
64 first_pool_role_ret = dict(
65     IdentityPoolId=first_pool_id,
66     Roles=dict(
67         authenticated="first_pool_auth_role", unauthenticated="first_pool_unauth_role"
68     ),
69 )
70 second_pool_ret = dict(
71     IdentityPoolId=second_pool_id,
72     IdentityPoolName=second_pool_name,
73     AllowUnauthenticatedIdentities=False,
74 )
75 second_pool_role_ret = dict(
76     IdentityPoolId=second_pool_id, Roles=dict(authenticated="second_pool_auth_role")
77 )
78 second_pool_update_ret = dict(
79     IdentityPoolId=second_pool_id,
80     IdentityPoolName=second_pool_name,
81     AllowUnauthenticatedIdentities=True,
82 )
83 third_pool_ret = dict(
84     IdentityPoolId=third_pool_id,
85     IdentityPoolName=third_pool_name,
86     AllowUnauthenticatedIdentities=False,
87     DeveloperProviderName="test_provider2",
88 )
89 third_pool_role_ret = dict(IdentityPoolId=third_pool_id)
90 default_pool_ret = dict(
91     IdentityPoolId=default_pool_id,
92     IdentityPoolName=default_pool_name,
93     AllowUnauthenticatedIdentities=False,
94     DeveloperProviderName=default_dev_provider,
95 )
96 default_pool_role_ret = dict(IdentityPoolId=default_pool_id)
97 log = logging.getLogger(__name__)
98 def _has_required_boto():
99     if not HAS_BOTO:
100         return False
101     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
102         return False
103     else:
104         return True
105 class BotoCognitoIdentityStateTestCaseBase(TestCase, LoaderModuleMockMixin):
106     conn = None
107     def setup_loader_modules(self):
108         ctx = {}
109         utils = salt.loader.utils(
110             self.opts,
111             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
112             context=ctx,
113         )
114         serializers = salt.loader.serializers(self.opts)
115         self.funcs = funcs = salt.loader.minion_mods(
116             self.opts, context=ctx, utils=utils, whitelist=["boto_cognitoidentity"]
117         )
118         self.salt_states = salt.loader.states(
119             opts=self.opts,
120             functions=funcs,
121             utils=utils,
122             whitelist=["boto_cognitoidentity"],
123             serializers=serializers,
124         )
125         return {
126             boto_cognitoidentity: {
127                 "__opts__": self.opts,
128                 "__salt__": funcs,
129                 "__utils__": utils,
130                 "__states__": self.salt_states,
131                 "__serializers__": serializers,
132             }
133         }
134     @classmethod
135     def setUpClass(cls):
136         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
137         cls.opts["grains"] = salt.loader.grains(cls.opts)
138     @classmethod
139     def tearDownClass(cls):
140         del cls.opts
141     def setUp(self):
142         self.addCleanup(delattr, self, "funcs")
143         self.addCleanup(delattr, self, "salt_states")
144         conn_parameters["key"] = "".join(
145             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
146         )
147         self.patcher = patch("boto3.session.Session")
148         self.addCleanup(self.patcher.stop)
149         self.addCleanup(delattr, self, "patcher")
150         mock_session = self.patcher.start()
151         session_instance = mock_session.return_value
152         self.conn = MagicMock()
153         self.addCleanup(delattr, self, "conn")
154         session_instance.client.return_value = self.conn
155 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
156 @skipIf(
157     _has_required_boto() is False,
158     "The boto3 module must be greater than or equal to version {}".format(
159         required_boto3_version
160     ),
161 )
162 class BotoCognitoIdentityTestCase(
163     BotoCognitoIdentityStateTestCaseBase, BotoCognitoIdentityTestCaseMixin
164 ):
165     def _describe_identity_pool_side_effect(self, *args, **kwargs):
166         if kwargs.get("IdentityPoolId") == first_pool_id:
167             return first_pool_ret
168         elif kwargs.get("IdentityPoolId") == second_pool_id:
169             return second_pool_ret
170         elif kwargs.get("IdentityPoolId") == third_pool_id:
171             return third_pool_ret
172         else:
173             return default_pool_ret
174     def test_present_when_failing_to_describe_identity_pools(self):
175         self.conn.list_identity_pools.return_value = identity_pools_ret
176         self.conn.describe_identity_pool.side_effect = ClientError(
177             error_content, "error on describe identity pool"
178         )
179         result = self.salt_states["boto_cognitoidentity.pool_present"](
180             name="test pool present",
181             IdentityPoolName=first_pool_name,
182             AuthenticatedRole="my_auth_role",
183             **conn_parameters
184         )
185         self.assertEqual(result.get("result"), False)
186         self.assertTrue("error on describe identity pool" in result.get("comment", {}))
187     def test_present_when_multiple_pools_with_same_name_exist(self):
188         self.conn.list_identity_pools.return_value = identity_pools_ret
189         self.conn.describe_identity_pool.side_effect = (
190             self._describe_identity_pool_side_effect
191         )
192         result = self.salt_states["boto_cognitoidentity.pool_present"](
193             name="test pool present",
194             IdentityPoolName=first_pool_name,
195             AuthenticatedRole="my_auth_role",
196             **conn_parameters
197         )
198         self.assertEqual(result.get("result"), False)
199         self.assertIn(
200             "{}".format([first_pool_ret, third_pool_ret]), result.get("comment", "")
201         )
202     def test_present_when_failing_to_create_a_new_identity_pool(self):
203         self.conn.list_identity_pools.return_value = identity_pools_ret
204         self.conn.describe_identity_pool.side_effect = (
205             self._describe_identity_pool_side_effect
206         )
207         self.conn.create_identity_pool.side_effect = ClientError(
208             error_content, "error on create_identity_pool"
209         )
210         result = self.salt_states["boto_cognitoidentity.pool_present"](
211             name="test pool present",
212             IdentityPoolName=default_pool_name,
213             AuthenticatedRole="my_auth_role",
214             **conn_parameters
215         )
216         self.assertEqual(result.get("result"), False)
217         self.assertTrue("error on create_identity_pool" in result.get("comment", ""))
218         self.assertTrue(self.conn.update_identity_pool.call_count == 0)
219     def test_present_when_failing_to_update_an_existing_identity_pool(self):
220         self.conn.list_identity_pools.return_value = identity_pools_ret
221         self.conn.describe_identity_pool.side_effect = (
222             self._describe_identity_pool_side_effect
223         )
224         self.conn.update_identity_pool.side_effect = ClientError(
225             error_content, "error on update_identity_pool"
226         )
227         result = self.salt_states["boto_cognitoidentity.pool_present"](
228             name="test pool present",
229             IdentityPoolName=second_pool_name,
230             AuthenticatedRole="my_auth_role",
231             AllowUnauthenticatedIdentities=True,
232             **conn_parameters
233         )
234         self.assertEqual(result.get("result"), False)
235         self.assertTrue("error on update_identity_pool" in result.get("comment", ""))
236         self.assertTrue(self.conn.create_identity_pool.call_count == 0)
237     def _get_identity_pool_roles_side_effect(self, *args, **kwargs):
238         if kwargs.get("IdentityPoolId") == first_pool_id:
239             return first_pool_role_ret
240         elif kwargs.get("IdentityPoolId") == second_pool_id:
241             return second_pool_role_ret
242         elif kwargs.get("IdentityPoolId") == third_pool_id:
243             return third_pool_role_ret
244         else:
245             return default_pool_role_ret
246     def test_present_when_failing_to_get_identity_pool_roles(self):
247         self.conn.list_identity_pools.return_value = identity_pools_ret
248         self.conn.describe_identity_pool.side_effect = (
249             self._describe_identity_pool_side_effect
250         )
251         self.conn.update_identity_pool.return_value = second_pool_update_ret
252         self.conn.get_identity_pool_roles.side_effect = ClientError(
253             error_content, "error on get_identity_pool_roles"
254         )
255         result = self.salt_states["boto_cognitoidentity.pool_present"](
256             name="test pool present",
257             IdentityPoolName=second_pool_name,
258             AuthenticatedRole="my_auth_role",
259             AllowUnauthenticatedIdentities=True,
260             **conn_parameters
261         )
262         self.assertEqual(result.get("result"), False)
263         self.assertTrue("error on get_identity_pool_roles" in result.get("comment", ""))
264         self.assertTrue(self.conn.create_identity_pool.call_count == 0)
265         self.assertTrue(self.conn.set_identity_pool_roles.call_count == 0)
266     @pytest.mark.slow_test
267     def test_present_when_failing_to_set_identity_pool_roles(self):
268         self.conn.list_identity_pools.return_value = identity_pools_ret
269         self.conn.describe_identity_pool.side_effect = (
270             self._describe_identity_pool_side_effect
271         )
272         self.conn.update_identity_pool.return_value = second_pool_update_ret
273         self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
274         self.conn.set_identity_pool_roles.side_effect = ClientError(
275             error_content, "error on set_identity_pool_roles"
276         )
277         with patch.dict(
278             self.funcs,
279             {
280                 "boto_iam.describe_role": MagicMock(
281                     return_value={"arn": "my_auth_role_arn"}
282                 )
283             },
284         ):
285             result = self.salt_states["boto_cognitoidentity.pool_present"](
286                 name="test pool present",
287                 IdentityPoolName=second_pool_name,
288                 AuthenticatedRole="my_auth_role",
289                 AllowUnauthenticatedIdentities=True,
290                 **conn_parameters
291             )
292             self.assertEqual(result.get("result"), False)
293             self.assertTrue(
294                 "error on set_identity_pool_roles" in result.get("comment", "")
295             )
296             expected_call_args = (
297                 dict(
298                     IdentityPoolId=second_pool_id,
299                     Roles={"authenticated": "my_auth_role_arn"},
300                 ),
301             )
302             self.assertTrue(
303                 self.conn.set_identity_pool_roles.call_args == expected_call_args
304             )
305     @pytest.mark.slow_test
306     def test_present_when_pool_name_does_not_exist(self):
307         self.conn.list_identity_pools.return_value = identity_pools_ret
308         self.conn.create_identity_pool.side_effect = (
309             self._describe_identity_pool_side_effect
310         )
311         self.conn.get_identity_pool_roles.return_value = default_pool_role_ret
312         self.conn.set_identity_pool_roles.return_value = None
313         with patch.dict(
314             self.funcs,
315             {
316                 "boto_iam.describe_role": MagicMock(
317                     return_value={"arn": "my_auth_role_arn"}
318                 )
319             },
320         ):
321             result = self.salt_states["boto_cognitoidentity.pool_present"](
322                 name="test pool present",
323                 IdentityPoolName=default_pool_name,
324                 AuthenticatedRole="my_auth_role",
325                 AllowUnauthenticatedIdentities=True,
326                 DeveloperProviderName=default_dev_provider,
327                 **conn_parameters
328             )
329             self.assertEqual(result.get("result"), True)
330             expected_call_args = (
331                 dict(
332                     AllowUnauthenticatedIdentities=True,
333                     IdentityPoolName=default_pool_name,
334                     DeveloperProviderName=default_dev_provider,
335                     SupportedLoginProviders={},
336                     OpenIdConnectProviderARNs=[],
337                 ),
338             )
339             self.assertTrue(
340                 self.conn.create_identity_pool.call_args == expected_call_args
341             )
342             expected_call_args = (
343                 dict(
344                     IdentityPoolId=default_pool_id,
345                     Roles={"authenticated": "my_auth_role_arn"},
346                 ),
347             )
348             self.assertTrue(
349                 self.conn.set_identity_pool_roles.call_args == expected_call_args
350             )
351             self.assertTrue(self.conn.update_identity_pool.call_count == 0)
352     @pytest.mark.slow_test
353     def test_present_when_pool_name_exists(self):
354         self.conn.list_identity_pools.return_value = identity_pools_ret
355         self.conn.describe_identity_pool.side_effect = (
356             self._describe_identity_pool_side_effect
357         )
358         self.conn.update_identity_pool.return_value = second_pool_update_ret
359         self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
360         self.conn.set_identity_pool_roles.return_value = None
361         with patch.dict(
362             self.funcs,
363             {
364                 "boto_iam.describe_role": MagicMock(
365                     return_value={"arn": "my_auth_role_arn"}
366                 )
367             },
368         ):
369             result = self.salt_states["boto_cognitoidentity.pool_present"](
370                 name="test pool present",
371                 IdentityPoolName=second_pool_name,
372                 AuthenticatedRole="my_auth_role",
373                 AllowUnauthenticatedIdentities=True,
374                 **conn_parameters
375             )
376             self.assertEqual(result.get("result"), True)
377             expected_call_args = (
378                 dict(
379                     AllowUnauthenticatedIdentities=True,
380                     IdentityPoolId=second_pool_id,
381                     IdentityPoolName=second_pool_name,
382                 ),
383             )
384             self.assertTrue(
385                 self.conn.update_identity_pool.call_args == expected_call_args
386             )
387             expected_call_args = (
388                 dict(
389                     IdentityPoolId=second_pool_id,
390                     Roles={"authenticated": "my_auth_role_arn"},
391                 ),
392             )
393             self.assertTrue(
394                 self.conn.set_identity_pool_roles.call_args == expected_call_args
395             )
396             self.assertTrue(self.conn.create_identity_pool.call_count == 0)
397     def test_absent_when_pool_does_not_exist(self):
398         self.conn.list_identity_pools.return_value = identity_pools_ret
399         result = self.salt_states["boto_cognitoidentity.pool_absent"](
400             name="test pool absent",
401             IdentityPoolName="no_such_pool_name",
402             RemoveAllMatched=False,
403             **conn_parameters
404         )
405         self.assertEqual(result.get("result"), True)
406         self.assertEqual(result["changes"], {})
407     def test_absent_when_removeallmatched_is_false_and_multiple_pools_matched(self):
408         self.conn.list_identity_pools.return_value = identity_pools_ret
409         self.conn.describe_identity_pool.side_effect = (
410             self._describe_identity_pool_side_effect
411         )
412         result = self.salt_states["boto_cognitoidentity.pool_absent"](
413             name="test pool absent",
414             IdentityPoolName=first_pool_name,
415             RemoveAllMatched=False,
416             **conn_parameters
417         )
418         self.assertEqual(result.get("result"), False)
419         self.assertEqual(result["changes"], {})
420         self.assertTrue(
421             "{}".format([first_pool_ret, third_pool_ret]) in result.get("comment", "")
422         )
423     def test_absent_when_failing_to_describe_identity_pools(self):
424         self.conn.list_identity_pools.return_value = identity_pools_ret
425         self.conn.describe_identity_pool.side_effect = ClientError(
426             error_content, "error on describe identity pool"
427         )
428         result = self.salt_states["boto_cognitoidentity.pool_absent"](
429             name="test pool absent",
430             IdentityPoolName=first_pool_name,
431             RemoveAllMatched=False,
432             **conn_parameters
433         )
434         self.assertEqual(result.get("result"), False)
435         self.assertTrue("error on describe identity pool" in result.get("comment", {}))
436     def test_absent_when_erroring_on_delete_identity_pool(self):
437         self.conn.list_identity_pools.return_value = identity_pools_ret
438         self.conn.describe_identity_pool.side_effect = (
439             self._describe_identity_pool_side_effect
440         )
441         self.conn.delete_identity_pool.side_effect = ClientError(
442             error_content, "error on delete identity pool"
443         )
444         result = self.salt_states["boto_cognitoidentity.pool_absent"](
445             name="test pool absent",
446             IdentityPoolName=first_pool_name,
447             RemoveAllMatched=True,
448             **conn_parameters
449         )
450         self.assertEqual(result.get("result"), False)
451         self.assertEqual(result["changes"], {})
452         self.assertTrue("error on delete identity pool" in result.get("comment", ""))
453     def test_absent_when_a_single_pool_exists(self):
454         self.conn.list_identity_pools.return_value = identity_pools_ret
455         self.conn.describe_identity_pool.return_value = second_pool_ret
456         self.conn.delete_identity_pool.return_value = None
457         result = self.salt_states["boto_cognitoidentity.pool_absent"](
458             name="test pool absent",
459             IdentityPoolName=second_pool_name,
460             RemoveAllMatched=False,
461             **conn_parameters
462         )
463         self.assertEqual(result.get("result"), True)
464         expected_changes = {
465             "new": {"Identity Pool Id {}".format(second_pool_id): None},
466             "old": {"Identity Pool Id {}".format(second_pool_id): second_pool_name},
467         }
468         self.assertEqual(result["changes"], expected_changes)
469     def test_absent_when_multiple_pool_exists_and_removeallmatched_flag_is_true(self):
470         self.conn.list_identity_pools.return_value = identity_pools_ret
471         self.conn.describe_identity_pool.side_effect = (
472             self._describe_identity_pool_side_effect
473         )
474         self.conn.delete_identity_pool.return_value = None
475         result = self.salt_states["boto_cognitoidentity.pool_absent"](
476             name="test pool absent",
477             IdentityPoolName=first_pool_name,
478             RemoveAllMatched=True,
479             **conn_parameters
480         )
481         self.assertEqual(result.get("result"), True)
482         expected_changes = {
483             "new": {
484                 "Identity Pool Id {}".format(first_pool_id): None,
485                 "Identity Pool Id {}".format(third_pool_id): None,
486             },
487             "old": {
488                 "Identity Pool Id {}".format(first_pool_id): first_pool_name,
489                 "Identity Pool Id {}".format(third_pool_id): third_pool_name,
490             },
491         }
492         self.assertEqual(result["changes"], expected_changes)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
