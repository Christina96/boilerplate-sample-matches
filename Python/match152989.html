<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for datadog_api.py & test_boto_cognitoidentity.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for datadog_api.py & test_boto_cognitoidentity.py
      </h3>
      <h1 align="center">
        2.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>datadog_api.py (5.581395%)<TH>test_boto_cognitoidentity.py (1.4492754%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match152989-0.html#0',2,'match152989-1.html#0',3)" NAME="0">(172-214)<TD><A HREF="javascript:ZweiFrames('match152989-0.html#0',2,'match152989-1.html#0',3)" NAME="0">(49-60)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datadog_api.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
An execution module that interacts with the Datadog API

The following parameters are required for all functions.

api_key
    The datadog API key

app_key
    The datadog application key

Full argument reference is available on the Datadog API reference page
https://docs.datadoghq.com/api/
&quot;&quot;&quot;


import requests
from salt.exceptions import SaltInvocationError

HAS_DATADOG = True
try:
    import datadog
except ImportError:
    HAS_DATADOG = False

# Define the module's virtual name
__virtualname__ = &quot;datadog&quot;


def __virtual__():
    if HAS_DATADOG:
        return &quot;datadog&quot;
    else:
        message = &quot;Unable to import the python datadog module. Is it installed?&quot;
        return False, message


def _initialize_connection(api_key, app_key):
    &quot;&quot;&quot;
    Initialize Datadog connection
    &quot;&quot;&quot;
    if api_key is None:
        raise SaltInvocationError(&quot;api_key must be specified&quot;)
    if app_key is None:
        raise SaltInvocationError(&quot;app_key must be specified&quot;)
    options = {&quot;api_key&quot;: api_key, &quot;app_key&quot;: app_key}
    datadog.initialize(**options)


def schedule_downtime(
    scope,
    api_key=None,
    app_key=None,
    monitor_id=None,
    start=None,
    end=None,
    message=None,
    recurrence=None,
    timezone=None,
    test=False,
):
    &quot;&quot;&quot;
    Schedule downtime for a scope of monitors.

    CLI Example:

    .. code-block:: bash

        salt-call datadog.schedule_downtime 'host:app2' \\
                                            stop=$(date --date='30 minutes' +%s) \\
                                            app_key='0123456789' \\
                                            api_key='9876543210'

    Optional arguments

    :param monitor_id:      The ID of the monitor
    :param start:           Start time in seconds since the epoch
    :param end:             End time in seconds since the epoch
    :param message:         A message to send in a notification for this downtime
    :param recurrence:      Repeat this downtime periodically
    :param timezone:        Specify the timezone
    &quot;&quot;&quot;
    ret = {&quot;result&quot;: False, &quot;response&quot;: None, &quot;comment&quot;: &quot;&quot;}

    if api_key is None:
        raise SaltInvocationError(&quot;api_key must be specified&quot;)
    if app_key is None:
        raise SaltInvocationError(&quot;app_key must be specified&quot;)
    if test is True:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A schedule downtime API call would have been made.&quot;
        return ret
    _initialize_connection(api_key, app_key)

    # Schedule downtime
    try:
        response = datadog.api.Downtime.create(
            scope=scope,
            monitor_id=monitor_id,
            start=start,
            end=end,
            message=message,
            recurrence=recurrence,
            timezone=timezone,
        )
    except ValueError:
        comment = (
            &quot;Unexpected exception in Datadog Schedule Downtime API &quot;
            &quot;call. Are your keys correct?&quot;
        )
        ret[&quot;comment&quot;] = comment
        return ret

    ret[&quot;response&quot;] = response
    if &quot;active&quot; in response.keys():
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Successfully scheduled downtime&quot;
    return ret


def cancel_downtime(api_key=None, app_key=None, scope=None, id=None):
    &quot;&quot;&quot;
    Cancel a downtime by id or by scope.

    CLI Example:

    .. code-block:: bash

        salt-call datadog.cancel_downtime scope='host:app01' \\
                                          api_key='0123456789' \\
                                          app_key='9876543210'`

    Arguments - Either scope or id is required.

    :param id:      The downtime ID
    :param scope:   The downtime scope
    &quot;&quot;&quot;
    if api_key is None:
        raise SaltInvocationError(&quot;api_key must be specified&quot;)
    if app_key is None:
        raise SaltInvocationError(&quot;app_key must be specified&quot;)
    _initialize_connection(api_key, app_key)

    ret = {&quot;result&quot;: False, &quot;response&quot;: None, &quot;comment&quot;: &quot;&quot;}
    if id:
        response = datadog.api.Downtime.delete(id)
        ret[&quot;response&quot;] = response
        if not response:  # Then call has succeeded
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Successfully cancelled downtime&quot;
        return ret
    elif scope:
        params = {&quot;api_key&quot;: api_key, &quot;application_key&quot;: app_key, &quot;scope&quot;: scope}
        response = requests.post(
            &quot;https://app.datadoghq.com/api/v1/downtime/cancel/by_scope&quot;, params=params
        )
        if response.status_code == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;response&quot;] = response.json()
            ret[&quot;comment&quot;] = &quot;Successfully cancelled downtime&quot;
        else:
            ret[&quot;response&quot;] = response.text
            ret[&quot;comment&quot;] = &quot;Status Code: {}&quot;.format(response.status_code)
        return ret
    else:
        raise SaltInvocationError(&quot;One of id or scope must be specified&quot;)

    return ret
<A NAME="0"></A>

def post_event(
    api_key<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match152989-1.html#0',3,'match152989-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=None,
    app_key=None,
    title=None,
    text=None,
    date_happened=None,
    priority=None,
    host=None,
    tags=None,
    alert_type=None,
    aggregation_key=None,
    source_type_name=None,
):
    &quot;&quot;&quot;
    Post an event to the Datadog stream.

    CLI Example

    .. code-block:: bash

        salt-call datadog.post_event api_key='0123456789' \\
                                     app_key='9876543210' \\
                                     title='Salt Highstate' \\
                                     text=&quot;Salt highstate was run on $(salt-call grains.get id)&quot; \\
                                     tags='[&quot;service:salt&quot;, &quot;event:highstate&quot;]'

    Required arguments

    :param title:   The event title. Limited to 100 characters.
    :param text:    The body of the event. Limited to 4000 characters. The text
                    supports markdown.

    Optional arguments

    :param date_happened:       POSIX timestamp of the event.
    :param priority:            The priority of the event ('normal' or 'low').
    :param host:                Host name to associate with the event.
    :param tags:                A list of tags to apply to the event.
    :param alert_type:          &quot;error&quot;, &quot;warning&quot;, &quot;info&quot; or &quot;success&quot;.
    :param aggregation_key:     An arbitrary string to use for aggregation,
                                max length of 100 characters.
    :param source_type_name:    The type of event being posted.
    &quot;&quot;&quot;
    _initialize_connection(</B></FONT>api_key, app_key)
    if title is None:
        raise SaltInvocationError(&quot;title must be specified&quot;)
    if text is None:
        raise SaltInvocationError(&quot;text must be specified&quot;)
    if alert_type not in [None, &quot;error&quot;, &quot;warning&quot;, &quot;info&quot;, &quot;success&quot;]:
        # Datadog only supports these alert types but the API doesn't return an
        # error for an incorrect alert_type, so we can do it here for now.
        # https://github.com/DataDog/datadogpy/issues/215
        message = 'alert_type must be one of &quot;error&quot;, &quot;warning&quot;, &quot;info&quot;, or &quot;success&quot;'
        raise SaltInvocationError(message)

    ret = {&quot;result&quot;: False, &quot;response&quot;: None, &quot;comment&quot;: &quot;&quot;}

    try:
        response = datadog.api.Event.create(
            title=title,
            text=text,
            date_happened=date_happened,
            priority=priority,
            host=host,
            tags=tags,
            alert_type=alert_type,
            aggregation_key=aggregation_key,
            source_type_name=source_type_name,
        )
    except ValueError:
        comment = (
            &quot;Unexpected exception in Datadog Post Event API &quot;
            &quot;call. Are your keys correct?&quot;
        )
        ret[&quot;comment&quot;] = comment
        return ret

    ret[&quot;response&quot;] = response
    if &quot;status&quot; in response.keys():
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Successfully sent event&quot;
    else:
        ret[&quot;comment&quot;] = &quot;Error in posting event.&quot;
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_cognitoidentity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging
import random
import string

import pytest
import salt.config
import salt.loader
import salt.states.boto_cognitoidentity as boto_cognitoidentity
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

# pylint: disable=import-error,no-name-in-module
from tests.unit.modules.test_boto_cognitoidentity import (
    BotoCognitoIdentityTestCaseMixin,
)

try:
    import boto3
    from botocore.exceptions import ClientError

    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False


# pylint: enable=import-error,no-name-in-module

# the boto_cognitoidentity module relies on the connect_to_region() method
# which was added in boto 2.8.0
# https://github.com/boto/boto/commit/33ac26b416fbb48a60602542b4ce15dcc7029f12
required_boto3_version = &quot;1.2.1&quot;

region = &quot;us-east-1&quot;
access_key = &quot;GKTADJGHEIQSXMKKRBJ08H&quot;
secret_key = &quot;askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs&quot;
conn_parameters = {
    &quot;region&quot;: region,
    &quot;key&quot;: access_key,
    &quot;keyid&quot;: secret_key,
    &quot;profile&quot;: {},
}
error_message = (
    &quot;An error occurred (101) when calling the {0} operation: Test-defined error&quot;
<A NAME="0"></A>)
error_content = {&quot;Error&quot;: {&quot;Code&quot;: 101, &quot;Message&quot;: &quot;Test-defined error&quot;}}

first_pool_id <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match152989-0.html#0',2,'match152989-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;first_pool_id&quot;
first_pool_name = &quot;first_pool&quot;
second_pool_id = &quot;second_pool_id&quot;
second_pool_name = &quot;second_pool&quot;
second_pool_name_updated = &quot;second_pool_updated&quot;
third_pool_id = &quot;third_pool_id&quot;
third_pool_name = first_pool_name
default_pool_name = &quot;default_pool_name&quot;
default_pool_id = &quot;default_pool_id&quot;
default_dev_provider = &quot;test_provider_default&quot;

identity_pools_ret = dict(</B></FONT>
    IdentityPools=[
        dict(IdentityPoolId=first_pool_id, IdentityPoolName=first_pool_name),
        dict(IdentityPoolId=second_pool_id, IdentityPoolName=second_pool_name),
        dict(IdentityPoolId=third_pool_id, IdentityPoolName=third_pool_name),
    ]
)

first_pool_ret = dict(
    IdentityPoolId=first_pool_id,
    IdentityPoolName=first_pool_name,
    AllowUnauthenticatedIdentities=False,
    SupportedLoginProviders={
        &quot;accounts.google.com&quot;: &quot;testing123&quot;,
        &quot;api.twitter.com&quot;: &quot;testing123&quot;,
        &quot;graph.facebook.com&quot;: &quot;testing123&quot;,
        &quot;www.amazon.com&quot;: &quot;testing123&quot;,
    },
    DeveloperProviderName=&quot;test_provider&quot;,
    OpenIdConnectProviderARNs=[&quot;some_provider_arn&quot;, &quot;another_provider_arn&quot;],
)

first_pool_role_ret = dict(
    IdentityPoolId=first_pool_id,
    Roles=dict(
        authenticated=&quot;first_pool_auth_role&quot;, unauthenticated=&quot;first_pool_unauth_role&quot;
    ),
)

second_pool_ret = dict(
    IdentityPoolId=second_pool_id,
    IdentityPoolName=second_pool_name,
    AllowUnauthenticatedIdentities=False,
)

second_pool_role_ret = dict(
    IdentityPoolId=second_pool_id, Roles=dict(authenticated=&quot;second_pool_auth_role&quot;)
)

second_pool_update_ret = dict(
    IdentityPoolId=second_pool_id,
    IdentityPoolName=second_pool_name,
    AllowUnauthenticatedIdentities=True,
)

third_pool_ret = dict(
    IdentityPoolId=third_pool_id,
    IdentityPoolName=third_pool_name,
    AllowUnauthenticatedIdentities=False,
    DeveloperProviderName=&quot;test_provider2&quot;,
)

third_pool_role_ret = dict(IdentityPoolId=third_pool_id)

default_pool_ret = dict(
    IdentityPoolId=default_pool_id,
    IdentityPoolName=default_pool_name,
    AllowUnauthenticatedIdentities=False,
    DeveloperProviderName=default_dev_provider,
)

default_pool_role_ret = dict(IdentityPoolId=default_pool_id)


log = logging.getLogger(__name__)


def _has_required_boto():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    &quot;&quot;&quot;
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    else:
        return True


class BotoCognitoIdentityStateTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None

    def setup_loader_modules(self):
        ctx = {}
        utils = salt.loader.utils(
            self.opts,
            whitelist=[&quot;boto&quot;, &quot;boto3&quot;, &quot;args&quot;, &quot;systemd&quot;, &quot;path&quot;, &quot;platform&quot;, &quot;reg&quot;],
            context=ctx,
        )
        serializers = salt.loader.serializers(self.opts)
        self.funcs = funcs = salt.loader.minion_mods(
            self.opts, context=ctx, utils=utils, whitelist=[&quot;boto_cognitoidentity&quot;]
        )
        self.salt_states = salt.loader.states(
            opts=self.opts,
            functions=funcs,
            utils=utils,
            whitelist=[&quot;boto_cognitoidentity&quot;],
            serializers=serializers,
        )
        return {
            boto_cognitoidentity: {
                &quot;__opts__&quot;: self.opts,
                &quot;__salt__&quot;: funcs,
                &quot;__utils__&quot;: utils,
                &quot;__states__&quot;: self.salt_states,
                &quot;__serializers__&quot;: serializers,
            }
        }

    @classmethod
    def setUpClass(cls):
        cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        cls.opts[&quot;grains&quot;] = salt.loader.grains(cls.opts)

    @classmethod
    def tearDownClass(cls):
        del cls.opts

    def setUp(self):
        self.addCleanup(delattr, self, &quot;funcs&quot;)
        self.addCleanup(delattr, self, &quot;salt_states&quot;)
        # Set up MagicMock to replace the boto3 session
        # connections keep getting cached from prior tests, can't find the
        # correct context object to clear it. So randomize the cache key, to prevent any
        # cache hits
        conn_parameters[&quot;key&quot;] = &quot;&quot;.join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )

        self.patcher = patch(&quot;boto3.session.Session&quot;)
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, &quot;patcher&quot;)
        mock_session = self.patcher.start()

        session_instance = mock_session.return_value
        self.conn = MagicMock()
        self.addCleanup(delattr, self, &quot;conn&quot;)
        session_instance.client.return_value = self.conn


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto3 module must be greater than or equal to version {}&quot;.format(
        required_boto3_version
    ),
)
class BotoCognitoIdentityTestCase(
    BotoCognitoIdentityStateTestCaseBase, BotoCognitoIdentityTestCaseMixin
):
    &quot;&quot;&quot;
    TestCase for salt.states.boto_cognitoidentity state.module
    &quot;&quot;&quot;

    def _describe_identity_pool_side_effect(self, *args, **kwargs):
        if kwargs.get(&quot;IdentityPoolId&quot;) == first_pool_id:
            return first_pool_ret
        elif kwargs.get(&quot;IdentityPoolId&quot;) == second_pool_id:
            return second_pool_ret
        elif kwargs.get(&quot;IdentityPoolId&quot;) == third_pool_id:
            return third_pool_ret
        else:
            return default_pool_ret

    def test_present_when_failing_to_describe_identity_pools(self):
        &quot;&quot;&quot;
        Tests exceptions when describing identity pools
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = ClientError(
            error_content, &quot;error on describe identity pool&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
            name=&quot;test pool present&quot;,
            IdentityPoolName=first_pool_name,
            AuthenticatedRole=&quot;my_auth_role&quot;,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertTrue(&quot;error on describe identity pool&quot; in result.get(&quot;comment&quot;, {}))

    def test_present_when_multiple_pools_with_same_name_exist(self):
        &quot;&quot;&quot;
        Tests present on an identity pool name where it matched
        multiple pools.  The result should fail.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
            name=&quot;test pool present&quot;,
            IdentityPoolName=first_pool_name,
            AuthenticatedRole=&quot;my_auth_role&quot;,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertIn(
            &quot;{}&quot;.format([first_pool_ret, third_pool_ret]), result.get(&quot;comment&quot;, &quot;&quot;)
        )

    def test_present_when_failing_to_create_a_new_identity_pool(self):
        &quot;&quot;&quot;
        Tests present on an identity pool name that doesn't exist and
        an error is thrown on creation.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.create_identity_pool.side_effect = ClientError(
            error_content, &quot;error on create_identity_pool&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
            name=&quot;test pool present&quot;,
            IdentityPoolName=default_pool_name,
            AuthenticatedRole=&quot;my_auth_role&quot;,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertTrue(&quot;error on create_identity_pool&quot; in result.get(&quot;comment&quot;, &quot;&quot;))
        self.assertTrue(self.conn.update_identity_pool.call_count == 0)

    def test_present_when_failing_to_update_an_existing_identity_pool(self):
        &quot;&quot;&quot;
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, and an error is thrown on updating the pool properties.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.side_effect = ClientError(
            error_content, &quot;error on update_identity_pool&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
            name=&quot;test pool present&quot;,
            IdentityPoolName=second_pool_name,
            AuthenticatedRole=&quot;my_auth_role&quot;,
            AllowUnauthenticatedIdentities=True,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertTrue(&quot;error on update_identity_pool&quot; in result.get(&quot;comment&quot;, &quot;&quot;))
        self.assertTrue(self.conn.create_identity_pool.call_count == 0)

    def _get_identity_pool_roles_side_effect(self, *args, **kwargs):
        if kwargs.get(&quot;IdentityPoolId&quot;) == first_pool_id:
            return first_pool_role_ret
        elif kwargs.get(&quot;IdentityPoolId&quot;) == second_pool_id:
            return second_pool_role_ret
        elif kwargs.get(&quot;IdentityPoolId&quot;) == third_pool_id:
            return third_pool_role_ret
        else:
            return default_pool_role_ret

    def test_present_when_failing_to_get_identity_pool_roles(self):
        &quot;&quot;&quot;
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, where update_identity_pool succeeded, but an error
        is thrown on getting the identity pool role prior to setting the roles.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.side_effect = ClientError(
            error_content, &quot;error on get_identity_pool_roles&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
            name=&quot;test pool present&quot;,
            IdentityPoolName=second_pool_name,
            AuthenticatedRole=&quot;my_auth_role&quot;,
            AllowUnauthenticatedIdentities=True,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertTrue(&quot;error on get_identity_pool_roles&quot; in result.get(&quot;comment&quot;, &quot;&quot;))
        self.assertTrue(self.conn.create_identity_pool.call_count == 0)
        self.assertTrue(self.conn.set_identity_pool_roles.call_count == 0)

    @pytest.mark.slow_test
    def test_present_when_failing_to_set_identity_pool_roles(self):
        &quot;&quot;&quot;
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, where update_identity_pool succeeded, but an error
        is thrown on setting the identity pool role.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
        self.conn.set_identity_pool_roles.side_effect = ClientError(
            error_content, &quot;error on set_identity_pool_roles&quot;
        )
        with patch.dict(
            self.funcs,
            {
                &quot;boto_iam.describe_role&quot;: MagicMock(
                    return_value={&quot;arn&quot;: &quot;my_auth_role_arn&quot;}
                )
            },
        ):
            result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
                name=&quot;test pool present&quot;,
                IdentityPoolName=second_pool_name,
                AuthenticatedRole=&quot;my_auth_role&quot;,
                AllowUnauthenticatedIdentities=True,
                **conn_parameters
            )
            self.assertEqual(result.get(&quot;result&quot;), False)
            self.assertTrue(
                &quot;error on set_identity_pool_roles&quot; in result.get(&quot;comment&quot;, &quot;&quot;)
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=second_pool_id,
                    Roles={&quot;authenticated&quot;: &quot;my_auth_role_arn&quot;},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )

    @pytest.mark.slow_test
    def test_present_when_pool_name_does_not_exist(self):
        &quot;&quot;&quot;
        Tests the successful case of creating a new instance, and updating its
        roles
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.create_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.get_identity_pool_roles.return_value = default_pool_role_ret
        self.conn.set_identity_pool_roles.return_value = None
        with patch.dict(
            self.funcs,
            {
                &quot;boto_iam.describe_role&quot;: MagicMock(
                    return_value={&quot;arn&quot;: &quot;my_auth_role_arn&quot;}
                )
            },
        ):
            result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
                name=&quot;test pool present&quot;,
                IdentityPoolName=default_pool_name,
                AuthenticatedRole=&quot;my_auth_role&quot;,
                AllowUnauthenticatedIdentities=True,
                DeveloperProviderName=default_dev_provider,
                **conn_parameters
            )
            self.assertEqual(result.get(&quot;result&quot;), True)
            expected_call_args = (
                dict(
                    AllowUnauthenticatedIdentities=True,
                    IdentityPoolName=default_pool_name,
                    DeveloperProviderName=default_dev_provider,
                    SupportedLoginProviders={},
                    OpenIdConnectProviderARNs=[],
                ),
            )
            self.assertTrue(
                self.conn.create_identity_pool.call_args == expected_call_args
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=default_pool_id,
                    Roles={&quot;authenticated&quot;: &quot;my_auth_role_arn&quot;},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )
            self.assertTrue(self.conn.update_identity_pool.call_count == 0)

    @pytest.mark.slow_test
    def test_present_when_pool_name_exists(self):
        &quot;&quot;&quot;
        Tests the successful case of updating a single instance with matching
        IdentityPoolName and its roles.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
        self.conn.set_identity_pool_roles.return_value = None
        with patch.dict(
            self.funcs,
            {
                &quot;boto_iam.describe_role&quot;: MagicMock(
                    return_value={&quot;arn&quot;: &quot;my_auth_role_arn&quot;}
                )
            },
        ):
            result = self.salt_states[&quot;boto_cognitoidentity.pool_present&quot;](
                name=&quot;test pool present&quot;,
                IdentityPoolName=second_pool_name,
                AuthenticatedRole=&quot;my_auth_role&quot;,
                AllowUnauthenticatedIdentities=True,
                **conn_parameters
            )
            self.assertEqual(result.get(&quot;result&quot;), True)
            expected_call_args = (
                dict(
                    AllowUnauthenticatedIdentities=True,
                    IdentityPoolId=second_pool_id,
                    IdentityPoolName=second_pool_name,
                ),
            )
            self.assertTrue(
                self.conn.update_identity_pool.call_args == expected_call_args
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=second_pool_id,
                    Roles={&quot;authenticated&quot;: &quot;my_auth_role_arn&quot;},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )
            self.assertTrue(self.conn.create_identity_pool.call_count == 0)

    def test_absent_when_pool_does_not_exist(self):
        &quot;&quot;&quot;
        Tests absent on an identity pool that does not exist.
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=&quot;no_such_pool_name&quot;,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), True)
        self.assertEqual(result[&quot;changes&quot;], {})

    def test_absent_when_removeallmatched_is_false_and_multiple_pools_matched(self):
        &quot;&quot;&quot;
        Tests absent on when RemoveAllMatched flag is false and there are multiple matches
        for the given pool name
        first_pool_name is matched to first and third pool with different id's
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertEqual(result[&quot;changes&quot;], {})
        self.assertTrue(
            &quot;{}&quot;.format([first_pool_ret, third_pool_ret]) in result.get(&quot;comment&quot;, &quot;&quot;)
        )

    def test_absent_when_failing_to_describe_identity_pools(self):
        &quot;&quot;&quot;
        Tests exceptions when describing identity pools
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = ClientError(
            error_content, &quot;error on describe identity pool&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertTrue(&quot;error on describe identity pool&quot; in result.get(&quot;comment&quot;, {}))

    def test_absent_when_erroring_on_delete_identity_pool(self):
        &quot;&quot;&quot;
        Tests error due to delete_identity_pools
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.delete_identity_pool.side_effect = ClientError(
            error_content, &quot;error on delete identity pool&quot;
        )
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=True,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), False)
        self.assertEqual(result[&quot;changes&quot;], {})
        self.assertTrue(&quot;error on delete identity pool&quot; in result.get(&quot;comment&quot;, &quot;&quot;))

    def test_absent_when_a_single_pool_exists(self):
        &quot;&quot;&quot;
        Tests absent succeeds on delete when a single pool matched and
        RemoveAllMatched is False
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.return_value = second_pool_ret
        self.conn.delete_identity_pool.return_value = None
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=second_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), True)
        expected_changes = {
            &quot;new&quot;: {&quot;Identity Pool Id {}&quot;.format(second_pool_id): None},
            &quot;old&quot;: {&quot;Identity Pool Id {}&quot;.format(second_pool_id): second_pool_name},
        }
        self.assertEqual(result[&quot;changes&quot;], expected_changes)

    def test_absent_when_multiple_pool_exists_and_removeallmatched_flag_is_true(self):
        &quot;&quot;&quot;
        Tests absent succeeds on delete when a multiple pools matched and
        RemoveAllMatched is True

        first_pool_name should match to first_pool_id and third_pool_id
        &quot;&quot;&quot;
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.delete_identity_pool.return_value = None
        result = self.salt_states[&quot;boto_cognitoidentity.pool_absent&quot;](
            name=&quot;test pool absent&quot;,
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=True,
            **conn_parameters
        )
        self.assertEqual(result.get(&quot;result&quot;), True)
        expected_changes = {
            &quot;new&quot;: {
                &quot;Identity Pool Id {}&quot;.format(first_pool_id): None,
                &quot;Identity Pool Id {}&quot;.format(third_pool_id): None,
            },
            &quot;old&quot;: {
                &quot;Identity Pool Id {}&quot;.format(first_pool_id): first_pool_name,
                &quot;Identity Pool Id {}&quot;.format(third_pool_id): third_pool_name,
            },
        }
        self.assertEqual(result[&quot;changes&quot;], expected_changes)
</PRE>
</div>
  </div>
</body>
</html>
