<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for datadog_api.py &amp; test_boto_cognitoidentity.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datadog_api.py &amp; test_boto_cognitoidentity.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datadog_api.py (5.581395%)<th>test_boto_cognitoidentity.py (1.4492754%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(172-214)<td><a href="#" name="0">(49-60)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datadog_api.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import requests
2 from salt.exceptions import SaltInvocationError
3 HAS_DATADOG = True
4 try:
5     import datadog
6 except ImportError:
7     HAS_DATADOG = False
8 __virtualname__ = "datadog"
9 def __virtual__():
10     if HAS_DATADOG:
11         return "datadog"
12     else:
13         message = "Unable to import the python datadog module. Is it installed?"
14         return False, message
15 def _initialize_connection(api_key, app_key):
16     if api_key is None:
17         raise SaltInvocationError("api_key must be specified")
18     if app_key is None:
19         raise SaltInvocationError("app_key must be specified")
20     options = {"api_key": api_key, "app_key": app_key}
21     datadog.initialize(**options)
22 def schedule_downtime(
23     scope,
24     api_key=None,
25     app_key=None,
26     monitor_id=None,
27     start=None,
28     end=None,
29     message=None,
30     recurrence=None,
31     timezone=None,
32     test=False,
33 ):
34     ret = {"result": False, "response": None, "comment": ""}
35     if api_key is None:
36         raise SaltInvocationError("api_key must be specified")
37     if app_key is None:
38         raise SaltInvocationError("app_key must be specified")
39     if test is True:
40         ret["result"] = True
41         ret["comment"] = "A schedule downtime API call would have been made."
42         return ret
43     _initialize_connection(api_key, app_key)
44     try:
45         response = datadog.api.Downtime.create(
46             scope=scope,
47             monitor_id=monitor_id,
48             start=start,
49             end=end,
50             message=message,
51             recurrence=recurrence,
52             timezone=timezone,
53         )
54     except ValueError:
55         comment = (
56             "Unexpected exception in Datadog Schedule Downtime API "
57             "call. Are your keys correct?"
58         )
59         ret["comment"] = comment
60         return ret
61     ret["response"] = response
62     if "active" in response.keys():
63         ret["result"] = True
64         ret["comment"] = "Successfully scheduled downtime"
65     return ret
66 def cancel_downtime(api_key=None, app_key=None, scope=None, id=None):
67     if api_key is None:
68         raise SaltInvocationError("api_key must be specified")
69     if app_key is None:
70         raise SaltInvocationError("app_key must be specified")
71     _initialize_connection(api_key, app_key)
72     ret = {"result": False, "response": None, "comment": ""}
73     if id:
74         response = datadog.api.Downtime.delete(id)
75         ret["response"] = response
76         if not response:  # Then call has succeeded
77             ret["result"] = True
78             ret["comment"] = "Successfully cancelled downtime"
79         return ret
80     elif scope:
81         params = {"api_key": api_key, "application_key": app_key, "scope": scope}
82         response = requests.post(
83             "https://app.datadoghq.com/api/v1/downtime/cancel/by_scope", params=params
84         )
85         if response.status_code == 200:
86             ret["result"] = True
87             ret["response"] = response.json()
88             ret["comment"] = "Successfully cancelled downtime"
89         else:
90             ret["response"] = response.text
91             ret["comment"] = "Status Code: {}".format(response.status_code)
92         return ret
93     else:
94         raise SaltInvocationError("One of id or scope must be specified")
95     return ret
96 <a name="0"></a>
97 def post_event(
98     api_key<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
99     app_key=None,
100     title=None,
101     text=None,
102     date_happened=None,
103     priority=None,
104     host=None,
105     tags=None,
106     alert_type=None,
107     aggregation_key=None,
108     source_type_name=None,
109 ):
110     _initialize_connection(</b></font>api_key, app_key)
111     if title is None:
112         raise SaltInvocationError("title must be specified")
113     if text is None:
114         raise SaltInvocationError("text must be specified")
115     if alert_type not in [None, "error", "warning", "info", "success"]:
116         message = 'alert_type must be one of "error", "warning", "info", or "success"'
117         raise SaltInvocationError(message)
118     ret = {"result": False, "response": None, "comment": ""}
119     try:
120         response = datadog.api.Event.create(
121             title=title,
122             text=text,
123             date_happened=date_happened,
124             priority=priority,
125             host=host,
126             tags=tags,
127             alert_type=alert_type,
128             aggregation_key=aggregation_key,
129             source_type_name=source_type_name,
130         )
131     except ValueError:
132         comment = (
133             "Unexpected exception in Datadog Post Event API "
134             "call. Are your keys correct?"
135         )
136         ret["comment"] = comment
137         return ret
138     ret["response"] = response
139     if "status" in response.keys():
140         ret["result"] = True
141         ret["comment"] = "Successfully sent event"
142     else:
143         ret["comment"] = "Error in posting event."
144     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_cognitoidentity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import random
3 import string
4 import pytest
5 import salt.config
6 import salt.loader
7 import salt.states.boto_cognitoidentity as boto_cognitoidentity
8 from salt.utils.versions import LooseVersion
9 from tests.support.mixins import LoaderModuleMockMixin
10 from tests.support.mock import MagicMock, patch
11 from tests.support.unit import TestCase, skipIf
12 from tests.unit.modules.test_boto_cognitoidentity import (
13     BotoCognitoIdentityTestCaseMixin,
14 )
15 try:
16     import boto3
17     from botocore.exceptions import ClientError
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 required_boto3_version = "1.2.1"
22 region = "us-east-1"
23 access_key = "GKTADJGHEIQSXMKKRBJ08H"
24 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
25 conn_parameters = {
26     "region": region,
27     "key": access_key,
28     "keyid": secret_key,
29     "profile": {},
30 }
31 error_message = (
32     "An error occurred (101) when calling the {0} operation: Test-defined error"
33 <a name="0"></a>)
34 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
35 first_pool_id <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "first_pool_id"
36 first_pool_name = "first_pool"
37 second_pool_id = "second_pool_id"
38 second_pool_name = "second_pool"
39 second_pool_name_updated = "second_pool_updated"
40 third_pool_id = "third_pool_id"
41 third_pool_name = first_pool_name
42 default_pool_name = "default_pool_name"
43 default_pool_id = "default_pool_id"
44 default_dev_provider = "test_provider_default"
45 identity_pools_ret = dict(</b></font>
46     IdentityPools=[
47         dict(IdentityPoolId=first_pool_id, IdentityPoolName=first_pool_name),
48         dict(IdentityPoolId=second_pool_id, IdentityPoolName=second_pool_name),
49         dict(IdentityPoolId=third_pool_id, IdentityPoolName=third_pool_name),
50     ]
51 )
52 first_pool_ret = dict(
53     IdentityPoolId=first_pool_id,
54     IdentityPoolName=first_pool_name,
55     AllowUnauthenticatedIdentities=False,
56     SupportedLoginProviders={
57         "accounts.google.com": "testing123",
58         "api.twitter.com": "testing123",
59         "graph.facebook.com": "testing123",
60         "www.amazon.com": "testing123",
61     },
62     DeveloperProviderName="test_provider",
63     OpenIdConnectProviderARNs=["some_provider_arn", "another_provider_arn"],
64 )
65 first_pool_role_ret = dict(
66     IdentityPoolId=first_pool_id,
67     Roles=dict(
68         authenticated="first_pool_auth_role", unauthenticated="first_pool_unauth_role"
69     ),
70 )
71 second_pool_ret = dict(
72     IdentityPoolId=second_pool_id,
73     IdentityPoolName=second_pool_name,
74     AllowUnauthenticatedIdentities=False,
75 )
76 second_pool_role_ret = dict(
77     IdentityPoolId=second_pool_id, Roles=dict(authenticated="second_pool_auth_role")
78 )
79 second_pool_update_ret = dict(
80     IdentityPoolId=second_pool_id,
81     IdentityPoolName=second_pool_name,
82     AllowUnauthenticatedIdentities=True,
83 )
84 third_pool_ret = dict(
85     IdentityPoolId=third_pool_id,
86     IdentityPoolName=third_pool_name,
87     AllowUnauthenticatedIdentities=False,
88     DeveloperProviderName="test_provider2",
89 )
90 third_pool_role_ret = dict(IdentityPoolId=third_pool_id)
91 default_pool_ret = dict(
92     IdentityPoolId=default_pool_id,
93     IdentityPoolName=default_pool_name,
94     AllowUnauthenticatedIdentities=False,
95     DeveloperProviderName=default_dev_provider,
96 )
97 default_pool_role_ret = dict(IdentityPoolId=default_pool_id)
98 log = logging.getLogger(__name__)
99 def _has_required_boto():
100     if not HAS_BOTO:
101         return False
102     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
103         return False
104     else:
105         return True
106 class BotoCognitoIdentityStateTestCaseBase(TestCase, LoaderModuleMockMixin):
107     conn = None
108     def setup_loader_modules(self):
109         ctx = {}
110         utils = salt.loader.utils(
111             self.opts,
112             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
113             context=ctx,
114         )
115         serializers = salt.loader.serializers(self.opts)
116         self.funcs = funcs = salt.loader.minion_mods(
117             self.opts, context=ctx, utils=utils, whitelist=["boto_cognitoidentity"]
118         )
119         self.salt_states = salt.loader.states(
120             opts=self.opts,
121             functions=funcs,
122             utils=utils,
123             whitelist=["boto_cognitoidentity"],
124             serializers=serializers,
125         )
126         return {
127             boto_cognitoidentity: {
128                 "__opts__": self.opts,
129                 "__salt__": funcs,
130                 "__utils__": utils,
131                 "__states__": self.salt_states,
132                 "__serializers__": serializers,
133             }
134         }
135     @classmethod
136     def setUpClass(cls):
137         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
138         cls.opts["grains"] = salt.loader.grains(cls.opts)
139     @classmethod
140     def tearDownClass(cls):
141         del cls.opts
142     def setUp(self):
143         self.addCleanup(delattr, self, "funcs")
144         self.addCleanup(delattr, self, "salt_states")
145         conn_parameters["key"] = "".join(
146             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
147         )
148         self.patcher = patch("boto3.session.Session")
149         self.addCleanup(self.patcher.stop)
150         self.addCleanup(delattr, self, "patcher")
151         mock_session = self.patcher.start()
152         session_instance = mock_session.return_value
153         self.conn = MagicMock()
154         self.addCleanup(delattr, self, "conn")
155         session_instance.client.return_value = self.conn
156 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
157 @skipIf(
158     _has_required_boto() is False,
159     "The boto3 module must be greater than or equal to version {}".format(
160         required_boto3_version
161     ),
162 )
163 class BotoCognitoIdentityTestCase(
164     BotoCognitoIdentityStateTestCaseBase, BotoCognitoIdentityTestCaseMixin
165 ):
166     def _describe_identity_pool_side_effect(self, *args, **kwargs):
167         if kwargs.get("IdentityPoolId") == first_pool_id:
168             return first_pool_ret
169         elif kwargs.get("IdentityPoolId") == second_pool_id:
170             return second_pool_ret
171         elif kwargs.get("IdentityPoolId") == third_pool_id:
172             return third_pool_ret
173         else:
174             return default_pool_ret
175     def test_present_when_failing_to_describe_identity_pools(self):
176         self.conn.list_identity_pools.return_value = identity_pools_ret
177         self.conn.describe_identity_pool.side_effect = ClientError(
178             error_content, "error on describe identity pool"
179         )
180         result = self.salt_states["boto_cognitoidentity.pool_present"](
181             name="test pool present",
182             IdentityPoolName=first_pool_name,
183             AuthenticatedRole="my_auth_role",
184             **conn_parameters
185         )
186         self.assertEqual(result.get("result"), False)
187         self.assertTrue("error on describe identity pool" in result.get("comment", {}))
188     def test_present_when_multiple_pools_with_same_name_exist(self):
189         self.conn.list_identity_pools.return_value = identity_pools_ret
190         self.conn.describe_identity_pool.side_effect = (
191             self._describe_identity_pool_side_effect
192         )
193         result = self.salt_states["boto_cognitoidentity.pool_present"](
194             name="test pool present",
195             IdentityPoolName=first_pool_name,
196             AuthenticatedRole="my_auth_role",
197             **conn_parameters
198         )
199         self.assertEqual(result.get("result"), False)
200         self.assertIn(
201             "{}".format([first_pool_ret, third_pool_ret]), result.get("comment", "")
202         )
203     def test_present_when_failing_to_create_a_new_identity_pool(self):
204         self.conn.list_identity_pools.return_value = identity_pools_ret
205         self.conn.describe_identity_pool.side_effect = (
206             self._describe_identity_pool_side_effect
207         )
208         self.conn.create_identity_pool.side_effect = ClientError(
209             error_content, "error on create_identity_pool"
210         )
211         result = self.salt_states["boto_cognitoidentity.pool_present"](
212             name="test pool present",
213             IdentityPoolName=default_pool_name,
214             AuthenticatedRole="my_auth_role",
215             **conn_parameters
216         )
217         self.assertEqual(result.get("result"), False)
218         self.assertTrue("error on create_identity_pool" in result.get("comment", ""))
219         self.assertTrue(self.conn.update_identity_pool.call_count == 0)
220     def test_present_when_failing_to_update_an_existing_identity_pool(self):
221         self.conn.list_identity_pools.return_value = identity_pools_ret
222         self.conn.describe_identity_pool.side_effect = (
223             self._describe_identity_pool_side_effect
224         )
225         self.conn.update_identity_pool.side_effect = ClientError(
226             error_content, "error on update_identity_pool"
227         )
228         result = self.salt_states["boto_cognitoidentity.pool_present"](
229             name="test pool present",
230             IdentityPoolName=second_pool_name,
231             AuthenticatedRole="my_auth_role",
232             AllowUnauthenticatedIdentities=True,
233             **conn_parameters
234         )
235         self.assertEqual(result.get("result"), False)
236         self.assertTrue("error on update_identity_pool" in result.get("comment", ""))
237         self.assertTrue(self.conn.create_identity_pool.call_count == 0)
238     def _get_identity_pool_roles_side_effect(self, *args, **kwargs):
239         if kwargs.get("IdentityPoolId") == first_pool_id:
240             return first_pool_role_ret
241         elif kwargs.get("IdentityPoolId") == second_pool_id:
242             return second_pool_role_ret
243         elif kwargs.get("IdentityPoolId") == third_pool_id:
244             return third_pool_role_ret
245         else:
246             return default_pool_role_ret
247     def test_present_when_failing_to_get_identity_pool_roles(self):
248         self.conn.list_identity_pools.return_value = identity_pools_ret
249         self.conn.describe_identity_pool.side_effect = (
250             self._describe_identity_pool_side_effect
251         )
252         self.conn.update_identity_pool.return_value = second_pool_update_ret
253         self.conn.get_identity_pool_roles.side_effect = ClientError(
254             error_content, "error on get_identity_pool_roles"
255         )
256         result = self.salt_states["boto_cognitoidentity.pool_present"](
257             name="test pool present",
258             IdentityPoolName=second_pool_name,
259             AuthenticatedRole="my_auth_role",
260             AllowUnauthenticatedIdentities=True,
261             **conn_parameters
262         )
263         self.assertEqual(result.get("result"), False)
264         self.assertTrue("error on get_identity_pool_roles" in result.get("comment", ""))
265         self.assertTrue(self.conn.create_identity_pool.call_count == 0)
266         self.assertTrue(self.conn.set_identity_pool_roles.call_count == 0)
267     @pytest.mark.slow_test
268     def test_present_when_failing_to_set_identity_pool_roles(self):
269         self.conn.list_identity_pools.return_value = identity_pools_ret
270         self.conn.describe_identity_pool.side_effect = (
271             self._describe_identity_pool_side_effect
272         )
273         self.conn.update_identity_pool.return_value = second_pool_update_ret
274         self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
275         self.conn.set_identity_pool_roles.side_effect = ClientError(
276             error_content, "error on set_identity_pool_roles"
277         )
278         with patch.dict(
279             self.funcs,
280             {
281                 "boto_iam.describe_role": MagicMock(
282                     return_value={"arn": "my_auth_role_arn"}
283                 )
284             },
285         ):
286             result = self.salt_states["boto_cognitoidentity.pool_present"](
287                 name="test pool present",
288                 IdentityPoolName=second_pool_name,
289                 AuthenticatedRole="my_auth_role",
290                 AllowUnauthenticatedIdentities=True,
291                 **conn_parameters
292             )
293             self.assertEqual(result.get("result"), False)
294             self.assertTrue(
295                 "error on set_identity_pool_roles" in result.get("comment", "")
296             )
297             expected_call_args = (
298                 dict(
299                     IdentityPoolId=second_pool_id,
300                     Roles={"authenticated": "my_auth_role_arn"},
301                 ),
302             )
303             self.assertTrue(
304                 self.conn.set_identity_pool_roles.call_args == expected_call_args
305             )
306     @pytest.mark.slow_test
307     def test_present_when_pool_name_does_not_exist(self):
308         self.conn.list_identity_pools.return_value = identity_pools_ret
309         self.conn.create_identity_pool.side_effect = (
310             self._describe_identity_pool_side_effect
311         )
312         self.conn.get_identity_pool_roles.return_value = default_pool_role_ret
313         self.conn.set_identity_pool_roles.return_value = None
314         with patch.dict(
315             self.funcs,
316             {
317                 "boto_iam.describe_role": MagicMock(
318                     return_value={"arn": "my_auth_role_arn"}
319                 )
320             },
321         ):
322             result = self.salt_states["boto_cognitoidentity.pool_present"](
323                 name="test pool present",
324                 IdentityPoolName=default_pool_name,
325                 AuthenticatedRole="my_auth_role",
326                 AllowUnauthenticatedIdentities=True,
327                 DeveloperProviderName=default_dev_provider,
328                 **conn_parameters
329             )
330             self.assertEqual(result.get("result"), True)
331             expected_call_args = (
332                 dict(
333                     AllowUnauthenticatedIdentities=True,
334                     IdentityPoolName=default_pool_name,
335                     DeveloperProviderName=default_dev_provider,
336                     SupportedLoginProviders={},
337                     OpenIdConnectProviderARNs=[],
338                 ),
339             )
340             self.assertTrue(
341                 self.conn.create_identity_pool.call_args == expected_call_args
342             )
343             expected_call_args = (
344                 dict(
345                     IdentityPoolId=default_pool_id,
346                     Roles={"authenticated": "my_auth_role_arn"},
347                 ),
348             )
349             self.assertTrue(
350                 self.conn.set_identity_pool_roles.call_args == expected_call_args
351             )
352             self.assertTrue(self.conn.update_identity_pool.call_count == 0)
353     @pytest.mark.slow_test
354     def test_present_when_pool_name_exists(self):
355         self.conn.list_identity_pools.return_value = identity_pools_ret
356         self.conn.describe_identity_pool.side_effect = (
357             self._describe_identity_pool_side_effect
358         )
359         self.conn.update_identity_pool.return_value = second_pool_update_ret
360         self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
361         self.conn.set_identity_pool_roles.return_value = None
362         with patch.dict(
363             self.funcs,
364             {
365                 "boto_iam.describe_role": MagicMock(
366                     return_value={"arn": "my_auth_role_arn"}
367                 )
368             },
369         ):
370             result = self.salt_states["boto_cognitoidentity.pool_present"](
371                 name="test pool present",
372                 IdentityPoolName=second_pool_name,
373                 AuthenticatedRole="my_auth_role",
374                 AllowUnauthenticatedIdentities=True,
375                 **conn_parameters
376             )
377             self.assertEqual(result.get("result"), True)
378             expected_call_args = (
379                 dict(
380                     AllowUnauthenticatedIdentities=True,
381                     IdentityPoolId=second_pool_id,
382                     IdentityPoolName=second_pool_name,
383                 ),
384             )
385             self.assertTrue(
386                 self.conn.update_identity_pool.call_args == expected_call_args
387             )
388             expected_call_args = (
389                 dict(
390                     IdentityPoolId=second_pool_id,
391                     Roles={"authenticated": "my_auth_role_arn"},
392                 ),
393             )
394             self.assertTrue(
395                 self.conn.set_identity_pool_roles.call_args == expected_call_args
396             )
397             self.assertTrue(self.conn.create_identity_pool.call_count == 0)
398     def test_absent_when_pool_does_not_exist(self):
399         self.conn.list_identity_pools.return_value = identity_pools_ret
400         result = self.salt_states["boto_cognitoidentity.pool_absent"](
401             name="test pool absent",
402             IdentityPoolName="no_such_pool_name",
403             RemoveAllMatched=False,
404             **conn_parameters
405         )
406         self.assertEqual(result.get("result"), True)
407         self.assertEqual(result["changes"], {})
408     def test_absent_when_removeallmatched_is_false_and_multiple_pools_matched(self):
409         self.conn.list_identity_pools.return_value = identity_pools_ret
410         self.conn.describe_identity_pool.side_effect = (
411             self._describe_identity_pool_side_effect
412         )
413         result = self.salt_states["boto_cognitoidentity.pool_absent"](
414             name="test pool absent",
415             IdentityPoolName=first_pool_name,
416             RemoveAllMatched=False,
417             **conn_parameters
418         )
419         self.assertEqual(result.get("result"), False)
420         self.assertEqual(result["changes"], {})
421         self.assertTrue(
422             "{}".format([first_pool_ret, third_pool_ret]) in result.get("comment", "")
423         )
424     def test_absent_when_failing_to_describe_identity_pools(self):
425         self.conn.list_identity_pools.return_value = identity_pools_ret
426         self.conn.describe_identity_pool.side_effect = ClientError(
427             error_content, "error on describe identity pool"
428         )
429         result = self.salt_states["boto_cognitoidentity.pool_absent"](
430             name="test pool absent",
431             IdentityPoolName=first_pool_name,
432             RemoveAllMatched=False,
433             **conn_parameters
434         )
435         self.assertEqual(result.get("result"), False)
436         self.assertTrue("error on describe identity pool" in result.get("comment", {}))
437     def test_absent_when_erroring_on_delete_identity_pool(self):
438         self.conn.list_identity_pools.return_value = identity_pools_ret
439         self.conn.describe_identity_pool.side_effect = (
440             self._describe_identity_pool_side_effect
441         )
442         self.conn.delete_identity_pool.side_effect = ClientError(
443             error_content, "error on delete identity pool"
444         )
445         result = self.salt_states["boto_cognitoidentity.pool_absent"](
446             name="test pool absent",
447             IdentityPoolName=first_pool_name,
448             RemoveAllMatched=True,
449             **conn_parameters
450         )
451         self.assertEqual(result.get("result"), False)
452         self.assertEqual(result["changes"], {})
453         self.assertTrue("error on delete identity pool" in result.get("comment", ""))
454     def test_absent_when_a_single_pool_exists(self):
455         self.conn.list_identity_pools.return_value = identity_pools_ret
456         self.conn.describe_identity_pool.return_value = second_pool_ret
457         self.conn.delete_identity_pool.return_value = None
458         result = self.salt_states["boto_cognitoidentity.pool_absent"](
459             name="test pool absent",
460             IdentityPoolName=second_pool_name,
461             RemoveAllMatched=False,
462             **conn_parameters
463         )
464         self.assertEqual(result.get("result"), True)
465         expected_changes = {
466             "new": {"Identity Pool Id {}".format(second_pool_id): None},
467             "old": {"Identity Pool Id {}".format(second_pool_id): second_pool_name},
468         }
469         self.assertEqual(result["changes"], expected_changes)
470     def test_absent_when_multiple_pool_exists_and_removeallmatched_flag_is_true(self):
471         self.conn.list_identity_pools.return_value = identity_pools_ret
472         self.conn.describe_identity_pool.side_effect = (
473             self._describe_identity_pool_side_effect
474         )
475         self.conn.delete_identity_pool.return_value = None
476         result = self.salt_states["boto_cognitoidentity.pool_absent"](
477             name="test pool absent",
478             IdentityPoolName=first_pool_name,
479             RemoveAllMatched=True,
480             **conn_parameters
481         )
482         self.assertEqual(result.get("result"), True)
483         expected_changes = {
484             "new": {
485                 "Identity Pool Id {}".format(first_pool_id): None,
486                 "Identity Pool Id {}".format(third_pool_id): None,
487             },
488             "old": {
489                 "Identity Pool Id {}".format(first_pool_id): first_pool_name,
490                 "Identity Pool Id {}".format(third_pool_id): third_pool_name,
491             },
492         }
493         self.assertEqual(result["changes"], expected_changes)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
