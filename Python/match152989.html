<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for datadog_api.py &amp; test_boto_cognitoidentity.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for datadog_api.py &amp; test_boto_cognitoidentity.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>datadog_api.py (5.581395%)<th>test_boto_cognitoidentity.py (1.4492754%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(172-214)<td><a href="#" name="0">(49-60)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>datadog_api.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
An execution module that interacts with the Datadog API

The following parameters are required for all functions.

api_key
    The datadog API key

app_key
    The datadog application key

Full argument reference is available on the Datadog API reference page
https://docs.datadoghq.com/api/
"""


import requests
from salt.exceptions import SaltInvocationError

HAS_DATADOG = True
try:
    import datadog
except ImportError:
    HAS_DATADOG = False

# Define the module's virtual name
__virtualname__ = "datadog"


def __virtual__():
    if HAS_DATADOG:
        return "datadog"
    else:
        message = "Unable to import the python datadog module. Is it installed?"
        return False, message


def _initialize_connection(api_key, app_key):
    """
    Initialize Datadog connection
    """
    if api_key is None:
        raise SaltInvocationError("api_key must be specified")
    if app_key is None:
        raise SaltInvocationError("app_key must be specified")
    options = {"api_key": api_key, "app_key": app_key}
    datadog.initialize(**options)


def schedule_downtime(
    scope,
    api_key=None,
    app_key=None,
    monitor_id=None,
    start=None,
    end=None,
    message=None,
    recurrence=None,
    timezone=None,
    test=False,
):
    """
    Schedule downtime for a scope of monitors.

    CLI Example:

    .. code-block:: bash

        salt-call datadog.schedule_downtime 'host:app2' \\
                                            stop=$(date --date='30 minutes' +%s) \\
                                            app_key='0123456789' \\
                                            api_key='9876543210'

    Optional arguments

    :param monitor_id:      The ID of the monitor
    :param start:           Start time in seconds since the epoch
    :param end:             End time in seconds since the epoch
    :param message:         A message to send in a notification for this downtime
    :param recurrence:      Repeat this downtime periodically
    :param timezone:        Specify the timezone
    """
    ret = {"result": False, "response": None, "comment": ""}

    if api_key is None:
        raise SaltInvocationError("api_key must be specified")
    if app_key is None:
        raise SaltInvocationError("app_key must be specified")
    if test is True:
        ret["result"] = True
        ret["comment"] = "A schedule downtime API call would have been made."
        return ret
    _initialize_connection(api_key, app_key)

    # Schedule downtime
    try:
        response = datadog.api.Downtime.create(
            scope=scope,
            monitor_id=monitor_id,
            start=start,
            end=end,
            message=message,
            recurrence=recurrence,
            timezone=timezone,
        )
    except ValueError:
        comment = (
            "Unexpected exception in Datadog Schedule Downtime API "
            "call. Are your keys correct?"
        )
        ret["comment"] = comment
        return ret

    ret["response"] = response
    if "active" in response.keys():
        ret["result"] = True
        ret["comment"] = "Successfully scheduled downtime"
    return ret


def cancel_downtime(api_key=None, app_key=None, scope=None, id=None):
    """
    Cancel a downtime by id or by scope.

    CLI Example:

    .. code-block:: bash

        salt-call datadog.cancel_downtime scope='host:app01' \\
                                          api_key='0123456789' \\
                                          app_key='9876543210'`

    Arguments - Either scope or id is required.

    :param id:      The downtime ID
    :param scope:   The downtime scope
    """
    if api_key is None:
        raise SaltInvocationError("api_key must be specified")
    if app_key is None:
        raise SaltInvocationError("app_key must be specified")
    _initialize_connection(api_key, app_key)

    ret = {"result": False, "response": None, "comment": ""}
    if id:
        response = datadog.api.Downtime.delete(id)
        ret["response"] = response
        if not response:  # Then call has succeeded
            ret["result"] = True
            ret["comment"] = "Successfully cancelled downtime"
        return ret
    elif scope:
        params = {"api_key": api_key, "application_key": app_key, "scope": scope}
        response = requests.post(
            "https://app.datadoghq.com/api/v1/downtime/cancel/by_scope", params=params
        )
        if response.status_code == 200:
            ret["result"] = True
            ret["response"] = response.json()
            ret["comment"] = "Successfully cancelled downtime"
        else:
            ret["response"] = response.text
            ret["comment"] = "Status Code: {}".format(response.status_code)
        return ret
    else:
        raise SaltInvocationError("One of id or scope must be specified")

    return ret
<a name="0"></a>

def post_event(
    api_key<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
    app_key=None,
    title=None,
    text=None,
    date_happened=None,
    priority=None,
    host=None,
    tags=None,
    alert_type=None,
    aggregation_key=None,
    source_type_name=None,
):
    """
    Post an event to the Datadog stream.

    CLI Example

    .. code-block:: bash

        salt-call datadog.post_event api_key='0123456789' \\
                                     app_key='9876543210' \\
                                     title='Salt Highstate' \\
                                     text="Salt highstate was run on $(salt-call grains.get id)" \\
                                     tags='["service:salt", "event:highstate"]'

    Required arguments

    :param title:   The event title. Limited to 100 characters.
    :param text:    The body of the event. Limited to 4000 characters. The text
                    supports markdown.

    Optional arguments

    :param date_happened:       POSIX timestamp of the event.
    :param priority:            The priority of the event ('normal' or 'low').
    :param host:                Host name to associate with the event.
    :param tags:                A list of tags to apply to the event.
    :param alert_type:          "error", "warning", "info" or "success".
    :param aggregation_key:     An arbitrary string to use for aggregation,
                                max length of 100 characters.
    :param source_type_name:    The type of event being posted.
    """
    _initialize_connection(</b></font>api_key, app_key)
    if title is None:
        raise SaltInvocationError("title must be specified")
    if text is None:
        raise SaltInvocationError("text must be specified")
    if alert_type not in [None, "error", "warning", "info", "success"]:
        # Datadog only supports these alert types but the API doesn't return an
        # error for an incorrect alert_type, so we can do it here for now.
        # https://github.com/DataDog/datadogpy/issues/215
        message = 'alert_type must be one of "error", "warning", "info", or "success"'
        raise SaltInvocationError(message)

    ret = {"result": False, "response": None, "comment": ""}

    try:
        response = datadog.api.Event.create(
            title=title,
            text=text,
            date_happened=date_happened,
            priority=priority,
            host=host,
            tags=tags,
            alert_type=alert_type,
            aggregation_key=aggregation_key,
            source_type_name=source_type_name,
        )
    except ValueError:
        comment = (
            "Unexpected exception in Datadog Post Event API "
            "call. Are your keys correct?"
        )
        ret["comment"] = comment
        return ret

    ret["response"] = response
    if "status" in response.keys():
        ret["result"] = True
        ret["comment"] = "Successfully sent event"
    else:
        ret["comment"] = "Error in posting event."
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_cognitoidentity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import random
import string

import pytest
import salt.config
import salt.loader
import salt.states.boto_cognitoidentity as boto_cognitoidentity
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

# pylint: disable=import-error,no-name-in-module
from tests.unit.modules.test_boto_cognitoidentity import (
    BotoCognitoIdentityTestCaseMixin,
)

try:
    import boto3
    from botocore.exceptions import ClientError

    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False


# pylint: enable=import-error,no-name-in-module

# the boto_cognitoidentity module relies on the connect_to_region() method
# which was added in boto 2.8.0
# https://github.com/boto/boto/commit/33ac26b416fbb48a60602542b4ce15dcc7029f12
required_boto3_version = "1.2.1"

region = "us-east-1"
access_key = "GKTADJGHEIQSXMKKRBJ08H"
secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
conn_parameters = {
    "region": region,
    "key": access_key,
    "keyid": secret_key,
    "profile": {},
}
error_message = (
    "An error occurred (101) when calling the {0} operation: Test-defined error"
<a name="0"></a>)
error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}

first_pool_id <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "first_pool_id"
first_pool_name = "first_pool"
second_pool_id = "second_pool_id"
second_pool_name = "second_pool"
second_pool_name_updated = "second_pool_updated"
third_pool_id = "third_pool_id"
third_pool_name = first_pool_name
default_pool_name = "default_pool_name"
default_pool_id = "default_pool_id"
default_dev_provider = "test_provider_default"

identity_pools_ret = dict(</b></font>
    IdentityPools=[
        dict(IdentityPoolId=first_pool_id, IdentityPoolName=first_pool_name),
        dict(IdentityPoolId=second_pool_id, IdentityPoolName=second_pool_name),
        dict(IdentityPoolId=third_pool_id, IdentityPoolName=third_pool_name),
    ]
)

first_pool_ret = dict(
    IdentityPoolId=first_pool_id,
    IdentityPoolName=first_pool_name,
    AllowUnauthenticatedIdentities=False,
    SupportedLoginProviders={
        "accounts.google.com": "testing123",
        "api.twitter.com": "testing123",
        "graph.facebook.com": "testing123",
        "www.amazon.com": "testing123",
    },
    DeveloperProviderName="test_provider",
    OpenIdConnectProviderARNs=["some_provider_arn", "another_provider_arn"],
)

first_pool_role_ret = dict(
    IdentityPoolId=first_pool_id,
    Roles=dict(
        authenticated="first_pool_auth_role", unauthenticated="first_pool_unauth_role"
    ),
)

second_pool_ret = dict(
    IdentityPoolId=second_pool_id,
    IdentityPoolName=second_pool_name,
    AllowUnauthenticatedIdentities=False,
)

second_pool_role_ret = dict(
    IdentityPoolId=second_pool_id, Roles=dict(authenticated="second_pool_auth_role")
)

second_pool_update_ret = dict(
    IdentityPoolId=second_pool_id,
    IdentityPoolName=second_pool_name,
    AllowUnauthenticatedIdentities=True,
)

third_pool_ret = dict(
    IdentityPoolId=third_pool_id,
    IdentityPoolName=third_pool_name,
    AllowUnauthenticatedIdentities=False,
    DeveloperProviderName="test_provider2",
)

third_pool_role_ret = dict(IdentityPoolId=third_pool_id)

default_pool_ret = dict(
    IdentityPoolId=default_pool_id,
    IdentityPoolName=default_pool_name,
    AllowUnauthenticatedIdentities=False,
    DeveloperProviderName=default_dev_provider,
)

default_pool_role_ret = dict(IdentityPoolId=default_pool_id)


log = logging.getLogger(__name__)


def _has_required_boto():
    """
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    """
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    else:
        return True


class BotoCognitoIdentityStateTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None

    def setup_loader_modules(self):
        ctx = {}
        utils = salt.loader.utils(
            self.opts,
            whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
            context=ctx,
        )
        serializers = salt.loader.serializers(self.opts)
        self.funcs = funcs = salt.loader.minion_mods(
            self.opts, context=ctx, utils=utils, whitelist=["boto_cognitoidentity"]
        )
        self.salt_states = salt.loader.states(
            opts=self.opts,
            functions=funcs,
            utils=utils,
            whitelist=["boto_cognitoidentity"],
            serializers=serializers,
        )
        return {
            boto_cognitoidentity: {
                "__opts__": self.opts,
                "__salt__": funcs,
                "__utils__": utils,
                "__states__": self.salt_states,
                "__serializers__": serializers,
            }
        }

    @classmethod
    def setUpClass(cls):
        cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        cls.opts["grains"] = salt.loader.grains(cls.opts)

    @classmethod
    def tearDownClass(cls):
        del cls.opts

    def setUp(self):
        self.addCleanup(delattr, self, "funcs")
        self.addCleanup(delattr, self, "salt_states")
        # Set up MagicMock to replace the boto3 session
        # connections keep getting cached from prior tests, can't find the
        # correct context object to clear it. So randomize the cache key, to prevent any
        # cache hits
        conn_parameters["key"] = "".join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )

        self.patcher = patch("boto3.session.Session")
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, "patcher")
        mock_session = self.patcher.start()

        session_instance = mock_session.return_value
        self.conn = MagicMock()
        self.addCleanup(delattr, self, "conn")
        session_instance.client.return_value = self.conn


@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
class BotoCognitoIdentityTestCase(
    BotoCognitoIdentityStateTestCaseBase, BotoCognitoIdentityTestCaseMixin
):
    """
    TestCase for salt.states.boto_cognitoidentity state.module
    """

    def _describe_identity_pool_side_effect(self, *args, **kwargs):
        if kwargs.get("IdentityPoolId") == first_pool_id:
            return first_pool_ret
        elif kwargs.get("IdentityPoolId") == second_pool_id:
            return second_pool_ret
        elif kwargs.get("IdentityPoolId") == third_pool_id:
            return third_pool_ret
        else:
            return default_pool_ret

    def test_present_when_failing_to_describe_identity_pools(self):
        """
        Tests exceptions when describing identity pools
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = ClientError(
            error_content, "error on describe identity pool"
        )
        result = self.salt_states["boto_cognitoidentity.pool_present"](
            name="test pool present",
            IdentityPoolName=first_pool_name,
            AuthenticatedRole="my_auth_role",
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertTrue("error on describe identity pool" in result.get("comment", {}))

    def test_present_when_multiple_pools_with_same_name_exist(self):
        """
        Tests present on an identity pool name where it matched
        multiple pools.  The result should fail.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        result = self.salt_states["boto_cognitoidentity.pool_present"](
            name="test pool present",
            IdentityPoolName=first_pool_name,
            AuthenticatedRole="my_auth_role",
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertIn(
            "{}".format([first_pool_ret, third_pool_ret]), result.get("comment", "")
        )

    def test_present_when_failing_to_create_a_new_identity_pool(self):
        """
        Tests present on an identity pool name that doesn't exist and
        an error is thrown on creation.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.create_identity_pool.side_effect = ClientError(
            error_content, "error on create_identity_pool"
        )
        result = self.salt_states["boto_cognitoidentity.pool_present"](
            name="test pool present",
            IdentityPoolName=default_pool_name,
            AuthenticatedRole="my_auth_role",
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertTrue("error on create_identity_pool" in result.get("comment", ""))
        self.assertTrue(self.conn.update_identity_pool.call_count == 0)

    def test_present_when_failing_to_update_an_existing_identity_pool(self):
        """
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, and an error is thrown on updating the pool properties.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.side_effect = ClientError(
            error_content, "error on update_identity_pool"
        )
        result = self.salt_states["boto_cognitoidentity.pool_present"](
            name="test pool present",
            IdentityPoolName=second_pool_name,
            AuthenticatedRole="my_auth_role",
            AllowUnauthenticatedIdentities=True,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertTrue("error on update_identity_pool" in result.get("comment", ""))
        self.assertTrue(self.conn.create_identity_pool.call_count == 0)

    def _get_identity_pool_roles_side_effect(self, *args, **kwargs):
        if kwargs.get("IdentityPoolId") == first_pool_id:
            return first_pool_role_ret
        elif kwargs.get("IdentityPoolId") == second_pool_id:
            return second_pool_role_ret
        elif kwargs.get("IdentityPoolId") == third_pool_id:
            return third_pool_role_ret
        else:
            return default_pool_role_ret

    def test_present_when_failing_to_get_identity_pool_roles(self):
        """
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, where update_identity_pool succeeded, but an error
        is thrown on getting the identity pool role prior to setting the roles.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.side_effect = ClientError(
            error_content, "error on get_identity_pool_roles"
        )
        result = self.salt_states["boto_cognitoidentity.pool_present"](
            name="test pool present",
            IdentityPoolName=second_pool_name,
            AuthenticatedRole="my_auth_role",
            AllowUnauthenticatedIdentities=True,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertTrue("error on get_identity_pool_roles" in result.get("comment", ""))
        self.assertTrue(self.conn.create_identity_pool.call_count == 0)
        self.assertTrue(self.conn.set_identity_pool_roles.call_count == 0)

    @pytest.mark.slow_test
    def test_present_when_failing_to_set_identity_pool_roles(self):
        """
        Tests present on a unique instance of identity pool having the matching
        IdentityPoolName, where update_identity_pool succeeded, but an error
        is thrown on setting the identity pool role.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
        self.conn.set_identity_pool_roles.side_effect = ClientError(
            error_content, "error on set_identity_pool_roles"
        )
        with patch.dict(
            self.funcs,
            {
                "boto_iam.describe_role": MagicMock(
                    return_value={"arn": "my_auth_role_arn"}
                )
            },
        ):
            result = self.salt_states["boto_cognitoidentity.pool_present"](
                name="test pool present",
                IdentityPoolName=second_pool_name,
                AuthenticatedRole="my_auth_role",
                AllowUnauthenticatedIdentities=True,
                **conn_parameters
            )
            self.assertEqual(result.get("result"), False)
            self.assertTrue(
                "error on set_identity_pool_roles" in result.get("comment", "")
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=second_pool_id,
                    Roles={"authenticated": "my_auth_role_arn"},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )

    @pytest.mark.slow_test
    def test_present_when_pool_name_does_not_exist(self):
        """
        Tests the successful case of creating a new instance, and updating its
        roles
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.create_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.get_identity_pool_roles.return_value = default_pool_role_ret
        self.conn.set_identity_pool_roles.return_value = None
        with patch.dict(
            self.funcs,
            {
                "boto_iam.describe_role": MagicMock(
                    return_value={"arn": "my_auth_role_arn"}
                )
            },
        ):
            result = self.salt_states["boto_cognitoidentity.pool_present"](
                name="test pool present",
                IdentityPoolName=default_pool_name,
                AuthenticatedRole="my_auth_role",
                AllowUnauthenticatedIdentities=True,
                DeveloperProviderName=default_dev_provider,
                **conn_parameters
            )
            self.assertEqual(result.get("result"), True)
            expected_call_args = (
                dict(
                    AllowUnauthenticatedIdentities=True,
                    IdentityPoolName=default_pool_name,
                    DeveloperProviderName=default_dev_provider,
                    SupportedLoginProviders={},
                    OpenIdConnectProviderARNs=[],
                ),
            )
            self.assertTrue(
                self.conn.create_identity_pool.call_args == expected_call_args
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=default_pool_id,
                    Roles={"authenticated": "my_auth_role_arn"},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )
            self.assertTrue(self.conn.update_identity_pool.call_count == 0)

    @pytest.mark.slow_test
    def test_present_when_pool_name_exists(self):
        """
        Tests the successful case of updating a single instance with matching
        IdentityPoolName and its roles.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.update_identity_pool.return_value = second_pool_update_ret
        self.conn.get_identity_pool_roles.return_value = second_pool_role_ret
        self.conn.set_identity_pool_roles.return_value = None
        with patch.dict(
            self.funcs,
            {
                "boto_iam.describe_role": MagicMock(
                    return_value={"arn": "my_auth_role_arn"}
                )
            },
        ):
            result = self.salt_states["boto_cognitoidentity.pool_present"](
                name="test pool present",
                IdentityPoolName=second_pool_name,
                AuthenticatedRole="my_auth_role",
                AllowUnauthenticatedIdentities=True,
                **conn_parameters
            )
            self.assertEqual(result.get("result"), True)
            expected_call_args = (
                dict(
                    AllowUnauthenticatedIdentities=True,
                    IdentityPoolId=second_pool_id,
                    IdentityPoolName=second_pool_name,
                ),
            )
            self.assertTrue(
                self.conn.update_identity_pool.call_args == expected_call_args
            )
            expected_call_args = (
                dict(
                    IdentityPoolId=second_pool_id,
                    Roles={"authenticated": "my_auth_role_arn"},
                ),
            )
            self.assertTrue(
                self.conn.set_identity_pool_roles.call_args == expected_call_args
            )
            self.assertTrue(self.conn.create_identity_pool.call_count == 0)

    def test_absent_when_pool_does_not_exist(self):
        """
        Tests absent on an identity pool that does not exist.
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName="no_such_pool_name",
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), True)
        self.assertEqual(result["changes"], {})

    def test_absent_when_removeallmatched_is_false_and_multiple_pools_matched(self):
        """
        Tests absent on when RemoveAllMatched flag is false and there are multiple matches
        for the given pool name
        first_pool_name is matched to first and third pool with different id's
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertEqual(result["changes"], {})
        self.assertTrue(
            "{}".format([first_pool_ret, third_pool_ret]) in result.get("comment", "")
        )

    def test_absent_when_failing_to_describe_identity_pools(self):
        """
        Tests exceptions when describing identity pools
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = ClientError(
            error_content, "error on describe identity pool"
        )
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertTrue("error on describe identity pool" in result.get("comment", {}))

    def test_absent_when_erroring_on_delete_identity_pool(self):
        """
        Tests error due to delete_identity_pools
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.delete_identity_pool.side_effect = ClientError(
            error_content, "error on delete identity pool"
        )
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=True,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), False)
        self.assertEqual(result["changes"], {})
        self.assertTrue("error on delete identity pool" in result.get("comment", ""))

    def test_absent_when_a_single_pool_exists(self):
        """
        Tests absent succeeds on delete when a single pool matched and
        RemoveAllMatched is False
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.return_value = second_pool_ret
        self.conn.delete_identity_pool.return_value = None
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName=second_pool_name,
            RemoveAllMatched=False,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), True)
        expected_changes = {
            "new": {"Identity Pool Id {}".format(second_pool_id): None},
            "old": {"Identity Pool Id {}".format(second_pool_id): second_pool_name},
        }
        self.assertEqual(result["changes"], expected_changes)

    def test_absent_when_multiple_pool_exists_and_removeallmatched_flag_is_true(self):
        """
        Tests absent succeeds on delete when a multiple pools matched and
        RemoveAllMatched is True

        first_pool_name should match to first_pool_id and third_pool_id
        """
        self.conn.list_identity_pools.return_value = identity_pools_ret
        self.conn.describe_identity_pool.side_effect = (
            self._describe_identity_pool_side_effect
        )
        self.conn.delete_identity_pool.return_value = None
        result = self.salt_states["boto_cognitoidentity.pool_absent"](
            name="test pool absent",
            IdentityPoolName=first_pool_name,
            RemoveAllMatched=True,
            **conn_parameters
        )
        self.assertEqual(result.get("result"), True)
        expected_changes = {
            "new": {
                "Identity Pool Id {}".format(first_pool_id): None,
                "Identity Pool Id {}".format(third_pool_id): None,
            },
            "old": {
                "Identity Pool Id {}".format(first_pool_id): first_pool_name,
                "Identity Pool Id {}".format(third_pool_id): third_pool_name,
            },
        }
        self.assertEqual(result["changes"], expected_changes)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
