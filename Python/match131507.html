<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for web_test.py &amp; kiwiproc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for web_test.py &amp; kiwiproc.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>web_test.py (1.4430285%)<th>kiwiproc.py (18.509615%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(781-786)<td><a href="#" name="0">(248-254)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(481-488)<td><a href="#" name="1">(125-130)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2707-2711)<td><a href="#" name="2">(177-181)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1647-1650)<td><a href="#" name="3">(205-209)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(111-115)<td><a href="#" name="4">(78-81)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from __future__ import absolute_import, division, print_function
from salt.ext.tornado.concurrent import Future
from salt.ext.tornado import gen
from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
from salt.ext.tornado.httputil import format_timestamp
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.iostream import IOStream
from salt.ext.tornado import locale
from salt.ext.tornado.log import app_log, gen_log
from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
from salt.ext.tornado.template import DictLoader
from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding
import binascii
import contextlib
import copy
import datetime
import email.utils
import gzip
from io import BytesIO
import itertools
import logging
import os
import re
import socket
if PY3:
    import urllib.parse as urllib_parse  # py3
else:
    import urllib as urllib_parse  # py2
wsgi_safe_tests = []
def relpath(*a):
    return os.path.join(os.path.dirname(__file__), *a)
def wsgi_safe(cls):
    wsgi_safe_tests.append(cls)
    return cls
class WebTestCase(AsyncHTTPTestCase):
    def get_app(self):
        self.app = Application(self.get_handlers(), **self.get_app_kwargs())
        return self.app
    def get_handlers(self):
        raise NotImplementedError()
    def get_app_kwargs(self):
        return {}
class SimpleHandlerTestCase(WebTestCase):
    def get_handlers(self):
        return [('/', self.Handler)]
class HelloHandler(RequestHandler):
    def get(self):
        self.write('hello')
class CookieTestRequestHandler(RequestHandler):
    def __init__(self, cookie_secret='0123456789', key_version=None):
        self._cookies = {}
        if key_version is None:
            self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
        else:
            self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
                                                        key_version=key_version))
    def get_cookie(self, name):
        return self._cookies.get(name)
    def set_cookie(self, name, value, expires_days=None):
        self._cookies[name] = value
class SecureCookieV1Test(unittest.TestCase):
    def test_round_trip(self):
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'bar', version=1)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
                         b'bar')
    def test_cookie_tampering_future_timestamp(self):
        handler = CookieTestRequestHandler()
<a name="4"></a>        handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),
                                  version=1)
        cookie = handler._cookies['foo']
        match = re<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
        self.assertTrue(match)
        timestamp = match.group(1)
        sig = match.group(2)
        self.assertEqual(</b></font>
            _create_signature_v1(handler.application.settings["cookie_secret"],
                                 'foo', '12345678', timestamp),
            sig)
        self.assertEqual(
            _create_signature_v1(handler.application.settings["cookie_secret"],
                                 'foo', '1234', b'5678' + timestamp),
            sig)
        handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
            to_basestring(timestamp), to_basestring(sig)))
        with ExpectLog(gen_log, "Cookie timestamp in future"):
            self.assertTrue(
                handler.get_secure_cookie('foo', min_version=1) is None)
    def test_arbitrary_bytes(self):
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'\xe9', version=1)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')
class SecureCookieV2Test(unittest.TestCase):
    KEY_VERSIONS = {
        0: 'ajklasdf0ojaisdf',
        1: 'aslkjasaolwkjsdf'
    }
    def test_round_trip(self):
        handler = CookieTestRequestHandler()
        handler.set_secure_cookie('foo', b'bar', version=2)
        self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')
    def test_key_version_roundtrip(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
    def test_key_version_roundtrip_differing_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=1)
        handler.set_secure_cookie('foo', b'bar')
        self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
    def test_key_version_increment_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                               key_version=1)
        new_handler._cookies = handler._cookies
        self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')
    def test_key_version_invalidate_version(self):
        handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
                                           key_version=0)
        handler.set_secure_cookie('foo', b'bar')
        new_key_versions = self.KEY_VERSIONS.copy()
        new_key_versions.pop(0)
        new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
                                               key_version=1)
        new_handler._cookies = handler._cookies
        self.assertEqual(new_handler.get_secure_cookie('foo'), None)
class CookieTest(WebTestCase):
    def get_handlers(self):
        class SetCookieHandler(RequestHandler):
            def get(self):
                self.set_cookie("str", "asdf")
                self.set_cookie("unicode", u"qwer")
                self.set_cookie("bytes", b"zxcv")
        class GetCookieHandler(RequestHandler):
            def get(self):
                self.write(self.get_cookie("foo", "default"))
        class SetCookieDomainHandler(RequestHandler):
            def get(self):
                self.set_cookie("unicode_args", "blah", domain=u"foo.com",
                                path=u"/foo")
        class SetCookieSpecialCharHandler(RequestHandler):
            def get(self):
                self.set_cookie("equals", "a=b")
                self.set_cookie("semicolon", "a;b")
                self.set_cookie("quote", 'a"b')
        class SetCookieOverwriteHandler(RequestHandler):
            def get(self):
                self.set_cookie("a", "b", domain="example.com")
                self.set_cookie("c", "d", domain="example.com")
                self.set_cookie("a", "e")
        class SetCookieMaxAgeHandler(RequestHandler):
            def get(self):
                self.set_cookie("foo", "bar", max_age=10)
        class SetCookieExpiresDaysHandler(RequestHandler):
            def get(self):
                self.set_cookie("foo", "bar", expires_days=10)
        class SetCookieFalsyFlags(RequestHandler):
            def get(self):
                self.set_cookie("a", "1", secure=True)
                self.set_cookie("b", "1", secure=False)
                self.set_cookie("c", "1", httponly=True)
                self.set_cookie("d", "1", httponly=False)
        return [("/set", SetCookieHandler),
                ("/get", GetCookieHandler),
                ("/set_domain", SetCookieDomainHandler),
                ("/special_char", SetCookieSpecialCharHandler),
                ("/set_overwrite", SetCookieOverwriteHandler),
                ("/set_max_age", SetCookieMaxAgeHandler),
                ("/set_expires_days", SetCookieExpiresDaysHandler),
                ("/set_falsy_flags", SetCookieFalsyFlags)
                ]
    def test_set_cookie(self):
        response = self.fetch("/set")
        self.assertEqual(sorted(response.headers.get_list("Set-Cookie")),
                         ["bytes=zxcv; Path=/",
                          "str=asdf; Path=/",
                          "unicode=qwer; Path=/",
                          ])
    def test_get_cookie(self):
        response = self.fetch("/get", headers={"Cookie": "foo=bar"})
        self.assertEqual(response.body, b"bar")
        response = self.fetch("/get", headers={"Cookie": 'foo="bar"'})
        self.assertEqual(response.body, b"bar")
        response = self.fetch("/get", headers={"Cookie": "/=exception;"})
        self.assertEqual(response.body, b"default")
    def test_set_cookie_domain(self):
        response = self.fetch("/set_domain")
        self.assertEqual(response.headers.get_list("Set-Cookie"),
                         ["unicode_args=blah; Domain=foo.com; Path=/foo"])
    def test_cookie_special_char(self):
        response = self.fetch("/special_char")
        headers = sorted(response.headers.get_list("Set-Cookie"))
        self.assertEqual(len(headers), 3)
        self.assertEqual(headers[0], 'equals="a=b"; Path=/')
        self.assertEqual(headers[1], 'quote="a\\"b"; Path=/')
        self.assertTrue(headers[2] in ('semicolon="a;b"; Path=/',
                                       'semicolon="a\\073b"; Path=/'),
                        headers[2])
        data = [('foo=a=b', 'a=b'),
                ('foo="a=b"', 'a=b'),
                ('foo="a;b"', '"a'),  # even quoted, ";" is a delimiter
                ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
                ('foo="a\\073b"', 'a;b'),
                ('foo="a\\"b"', 'a"b'),
                ]
        for header, expected in data:
            logging.debug("trying %r", header)
            response = self.fetch("/get", headers={"Cookie": header})
            self.assertEqual(response.body, utf8(expected))
    def test_set_cookie_overwrite(self):
        response = self.fetch("/set_overwrite")
        headers = response.headers.get_list("Set-Cookie")
        self.assertEqual(sorted(headers),
                         ["a=e; Path=/", "c=d; Domain=example.com; Path=/"])
    def test_set_cookie_max_age(self):
        response = self.fetch("/set_max_age")
        headers = response.headers.get_list("Set-Cookie")
        self.assertEqual(sorted(headers),
                         ["foo=bar; Max-Age=10; Path=/"])
    def test_set_cookie_expires_days(self):
        response = self.fetch("/set_expires_days")
        header = response.headers.get("Set-Cookie")
        match = re.match("foo=bar; expires=(?P&lt;expires&gt;.+); Path=/", header)
        self.assertIsNotNone(match)
        expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
        header_expires = datetime.datetime(
            *email.utils.parsedate(match.groupdict()["expires"])[:6])
        self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)
    def test_set_cookie_false_flags(self):
        response = self.fetch("/set_falsy_flags")
        headers = sorted(response.headers.get_list("Set-Cookie"))
        self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
        self.assertEqual(headers[1].lower(), 'b=1; path=/')
        self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
        self.assertEqual(headers[3].lower(), 'd=1; path=/')
class AuthRedirectRequestHandler(RequestHandler):
    def initialize(self, login_url):
        self.login_url = login_url
    def get_login_url(self):
        return self.login_url
    @authenticated
    def get(self):
        self.send_error(500)
class AuthRedirectTest(WebTestCase):
    def get_handlers(self):
        return [('/relative', AuthRedirectRequestHandler,
                 dict(login_url='/login')),
                ('/absolute', AuthRedirectRequestHandler,
                 dict(login_url='http://example.com/login'))]
    def test_relative_auth_redirect(self):
        self.http_client.fetch(self.get_url('/relative'), self.stop,
                               follow_redirects=False)
        response = self.wait()
        self.assertEqual(response.code, 302)
        self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')
    def test_absolute_auth_redirect(self):
        self.http_client.fetch(self.get_url('/absolute'), self.stop,
                               follow_redirects=False)
        response = self.wait()
        self.assertEqual(response.code, 302)
        self.assertTrue(re.match(
            'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
            response.headers['Location']), response.headers['Location'])
class ConnectionCloseHandler(RequestHandler):
    def initialize(self, test):
        self.test = test
    @asynchronous
    def get(self):
        self.test.on_handler_waiting()
    def on_connection_close(self):
        self.test.on_connection_close()
class ConnectionCloseTest(WebTestCase):
    def get_handlers(self):
        return [('/', ConnectionCloseHandler, dict(test=self))]
    def test_connection_close(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s.connect(("127.0.0.1", self.get_http_port()))
        self.stream = IOStream(s, io_loop=self.io_loop)
        self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
        self.wait()
    def on_handler_waiting(self):
        logging.debug('handler waiting')
        self.stream.close()
    def on_connection_close(self):
        logging.debug('connection closed')
        self.stop()
class EchoHandler(RequestHandler):
    def get(self, *path_args):
        for key in self.request.arguments:
            if type(key) != str:
                raise Exception("incorrect type for key: %r" % type(key))
            for value in self.request.arguments[key]:
                if type(value) != bytes:
                    raise Exception("incorrect type for value: %r" %
                                    type(value))
            for value in self.get_arguments(key):
                if type(value) != unicode_type:
                    raise Exception("incorrect type for value: %r" %
                                    type(value))
        for arg in path_args:
            if type(arg) != unicode_type:
                raise Exception("incorrect type for path arg: %r" % type(arg))
        self.write(dict(path=self.request.path,
                        path_args=path_args,
                        args=recursive_unicode(self.request.arguments)))
class RequestEncodingTest(WebTestCase):
    def get_handlers(self):
        return [("/group/(.*)", EchoHandler),
                ("/slashes/([^/]*)/([^/]*)", EchoHandler),
                ]
    def fetch_json(self, path):
        return json_decode(self.fetch(path).body)
    def test_group_question_mark(self):
        self.assertEqual(self.fetch_json('/group/%3F'),
                         dict(path='/group/%3F', path_args=['?'], args={}))
        self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
                         dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))
    def test_group_encoding(self):
        self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
                         {u"path": u"/group/%C3%A9",
                          u"path_args": [u"\u00e9"],
                          u"args": {u"arg": [u"\u00e9"]}})
    def test_slashes(self):
        self.assertEqual(self.fetch_json('/slashes/foo/bar'),
                         dict(path="/slashes/foo/bar",
                              path_args=["foo", "bar"],
                              args={}))
        self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
                         dict(path="/slashes/a%2Fb/c%2Fd",
                              path_args=["a/b", "c/d"],
                              args={}))
    def test_error(self):
        with ExpectLog(gen_log, ".*Invalid unicode"):
            self.fetch("/group/?arg=%25%e9")
class TypeCheckHandler(RequestHandler):
    def prepare(self):
        self.errors = {}
        self.check_type('status', self.get_status(), int)
        self.check_type('argument', self.get_argument('foo'), unicode_type)
        self.check_type('cookie_key', list(self.cookies.keys())[0], str)
        self.check_type('cookie_value', list(self.cookies.values())[0].value, str)
        if list(self.cookies.keys()) != ['asdf']:
<a name="1"></a>            raise Exception("unexpected values for cookie keys: %r" %
                            self.cookies.keys())
        self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
        self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.check_type('get_cookie', self.get_cookie('asdf'), str)
        self.check_type('xsrf_token', self.xsrf_token, bytes)
        self.check_type('xsrf_form_html', self.xsrf_form_html(), str)
        self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)
        self.check_type(</b></font>'request_summary', self._request_summary(), str)
    def get(self, path_component):
        self.check_type('path_component', path_component, unicode_type)
        self.write(self.errors)
    def post(self, path_component):
        self.check_type('path_component', path_component, unicode_type)
        self.write(self.errors)
    def check_type(self, name, obj, expected_type):
        actual_type = type(obj)
        if expected_type != actual_type:
            self.errors[name] = "expected %s, got %s" % (expected_type,
                                                         actual_type)
class DecodeArgHandler(RequestHandler):
    def decode_argument(self, value, name=None):
        if type(value) != bytes:
            raise Exception("unexpected type for value: %r" % type(value))
        if 'encoding' in self.request.arguments:
            return value.decode(to_unicode(self.request.arguments['encoding'][0]))
        else:
            return value
    def get(self, arg):
        def describe(s):
            if type(s) == bytes:
                return ["bytes", native_str(binascii.b2a_hex(s))]
            elif type(s) == unicode_type:
                return ["unicode", s]
            raise Exception("unknown type")
        self.write({'path': describe(arg),
                    'query': describe(self.get_argument("foo")),
                    })
class LinkifyHandler(RequestHandler):
    def get(self):
        self.render("linkify.html", message="http://example.com")
class UIModuleResourceHandler(RequestHandler):
    def get(self):
        self.render("page.html", entries=[1, 2])
class OptionalPathHandler(RequestHandler):
    def get(self, path):
        self.write({"path": path})
class FlowControlHandler(RequestHandler):
    @asynchronous
    def get(self):
        self.write("1")
        self.flush(callback=self.step2)
    def step2(self):
        self.write("2")
        self.flush(callback=self.step3)
    def step3(self):
        self.write("3")
        self.finish()
class MultiHeaderHandler(RequestHandler):
    def get(self):
        self.set_header("x-overwrite", "1")
        self.set_header("X-Overwrite", 2)
        self.add_header("x-multi", 3)
        self.add_header("X-Multi", "4")
class RedirectHandler(RequestHandler):
    def get(self):
        if self.get_argument('permanent', None) is not None:
            self.redirect('/', permanent=int(self.get_argument('permanent')))
        elif self.get_argument('status', None) is not None:
            self.redirect('/', status=int(self.get_argument('status')))
        else:
            raise Exception("didn't get permanent or status arguments")
class EmptyFlushCallbackHandler(RequestHandler):
    @asynchronous
    @gen.engine
    def get(self):
        yield gen.Task(self.flush)  # "empty" flush, but writes headers
        yield gen.Task(self.flush)  # empty flush
        self.write("o")
        yield self.flush()  # flushes the "o"
        yield self.flush()  # empty flush
        self.finish("k")
class HeaderInjectionHandler(RequestHandler):
    def get(self):
        try:
            self.set_header("X-Foo", "foo\r\nX-Bar: baz")
            raise Exception("Didn't get expected exception")
        except ValueError as e:
            if "Unsafe header value" in str(e):
                self.finish(b"ok")
            else:
                raise
class GetArgumentHandler(RequestHandler):
    def prepare(self):
        if self.get_argument('source', None) == 'query':
            method = self.get_query_argument
        elif self.get_argument('source', None) == 'body':
            method = self.get_body_argument
        else:
            method = self.get_argument
        self.finish(method("foo", "default"))
class GetArgumentsHandler(RequestHandler):
    def prepare(self):
        self.finish(dict(default=self.get_arguments("foo"),
                         query=self.get_query_arguments("foo"),
                         body=self.get_body_arguments("foo")))
@wsgi_safe
class WSGISafeWebTest(WebTestCase):
    COOKIE_SECRET = "WebTest.COOKIE_SECRET"
    def get_app_kwargs(self):
        loader = DictLoader({
            "linkify.html": "{% module linkify(message) %}",
            "page.html": """\
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
{% for e in entries %}
{% module Template("entry.html", entry=e) %}
{% end %}
&lt;/body&gt;&lt;/html&gt;""",
            "entry.html": """\
{{ set_resources(embedded_css=".entry { margin-bottom: 1em; }", embedded_javascript="js_embed()", css_files=["/base.css", "/foo.css"], javascript_files="/common.js", html_head="&lt;meta&gt;", html_body='&lt;script src="/analytics.js"/&gt;') }}
&lt;div class="entry"&gt;...&lt;/div&gt;""",
        })
        return dict(template_loader=loader,
                    autoescape="xhtml_escape",
                    cookie_secret=self.COOKIE_SECRET)
    def tearDown(self):
        super(WSGISafeWebTest, self).tearDown()
        RequestHandler._template_loaders.clear()
    def get_handlers(self):
        urls = [
            url("/typecheck/(.*)", TypeCheckHandler, name='typecheck'),
            url("/decode_arg/(.*)", DecodeArgHandler, name='decode_arg'),
            url("/decode_arg_kw/(?P&lt;arg&gt;.*)", DecodeArgHandler),
            url("/linkify", LinkifyHandler),
            url("/uimodule_resources", UIModuleResourceHandler),
            url("/optional_path/(.+)?", OptionalPathHandler),
            url("/multi_header", MultiHeaderHandler),
            url("/redirect", RedirectHandler),
            url("/web_redirect_permanent", WebRedirectHandler, {"url": "/web_redirect_newpath"}),
            url("/web_redirect", WebRedirectHandler, {"url": "/web_redirect_newpath", "permanent": False}),
            url("//web_redirect_double_slash", WebRedirectHandler, {"url": '/web_redirect_newpath'}),
            url("/header_injection", HeaderInjectionHandler),
            url("/get_argument", GetArgumentHandler),
            url("/get_arguments", GetArgumentsHandler),
        ]
        return urls
    def fetch_json(self, *args, **kwargs):
        response = self.fetch(*args, **kwargs)
        response.rethrow()
        return json_decode(response.body)
    def test_types(self):
        cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
                                                      "asdf", "qwer"))
        response = self.fetch("/typecheck/asdf?foo=bar",
                              headers={"Cookie": "asdf=" + cookie_value})
        data = json_decode(response.body)
        self.assertEqual(data, {})
        response = self.fetch("/typecheck/asdf?foo=bar", method="POST",
                              headers={"Cookie": "asdf=" + cookie_value},
                              body="foo=bar")
    def test_decode_argument(self):
        urls = ["/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8",
                "/decode_arg/%E9?foo=%E9&amp;encoding=latin1",
                "/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1",
                ]
        for req_url in urls:
            response = self.fetch(req_url)
            response.rethrow()
            data = json_decode(response.body)
            self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
                                    u'query': [u'unicode', u'\u00e9'],
                                    })
        response = self.fetch("/decode_arg/%C3%A9?foo=%C3%A9")
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
                                u'query': [u'bytes', u'c3a9'],
                                })
    def test_decode_argument_invalid_unicode(self):
        with ExpectLog(gen_log, ".*Invalid unicode.*"):
            response = self.fetch("/typecheck/invalid%FF")
            self.assertEqual(response.code, 400)
            response = self.fetch("/typecheck/invalid?foo=%FF")
            self.assertEqual(response.code, 400)
    def test_decode_argument_plus(self):
        urls = ["/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8",
                "/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8"]
        for req_url in urls:
            response = self.fetch(req_url)
            response.rethrow()
            data = json_decode(response.body)
            self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
                                    u'query': [u'unicode', u'1 + 1'],
                                    })
    def test_reverse_url(self):
        self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
                         '/decode_arg/foo')
        self.assertEqual(self.app.reverse_url('decode_arg', 42),
                         '/decode_arg/42')
        self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
                         '/decode_arg/%E9')
        self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
                         '/decode_arg/%C3%A9')
        self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
                         '/decode_arg/1%20%2B%201')
    def test_uimodule_unescaped(self):
        response = self.fetch("/linkify")
        self.assertEqual(response.body,
                         b"&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;")
    def test_uimodule_resources(self):
        response = self.fetch("/uimodule_resources")
        self.assertEqual(response.body, b"""\
&lt;html&gt;&lt;head&gt;&lt;link href="/base.css" type="text/css" rel="stylesheet"/&gt;&lt;link href="/foo.css" type="text/css" rel="stylesheet"/&gt;
&lt;style type="text/css"&gt;
.entry { margin-bottom: 1em; }
&lt;/style&gt;
&lt;meta&gt;
&lt;/head&gt;&lt;body&gt;
&lt;div class="entry"&gt;...&lt;/div&gt;
&lt;div class="entry"&gt;...&lt;/div&gt;
&lt;script src="/common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
//&lt;![CDATA[
js_embed()
//]]&gt;
&lt;/script&gt;
&lt;script src="/analytics.js"/&gt;
&lt;/body&gt;&lt;/html&gt;""")
    def test_optional_path(self):
        self.assertEqual(self.fetch_json("/optional_path/foo"),
                         {u"path": u"foo"})
        self.assertEqual(self.fetch_json("/optional_path/"),
                         {u"path": None})
    def test_multi_header(self):
        response = self.fetch("/multi_header")
        self.assertEqual(response.headers["x-overwrite"], "2")
<a name="0"></a>        self.assertEqual(response.headers.get_list("x-multi"), ["3", "4"])
    def test_redirect(self):
        response <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch("/redirect?permanent=1", follow_redirects=False)
        self.assertEqual(response.code, 301)
        response = self.fetch("/redirect?permanent=0", follow_redirects=False)
        self.assertEqual(response.code, 302)
        response = self.fetch("/redirect?status=307", follow_redirects=False)
        self.assertEqual(response.</b></font>code, 307)
    def test_web_redirect(self):
        response = self.fetch("/web_redirect_permanent", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
        response = self.fetch("/web_redirect", follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
    def test_web_redirect_double_slash(self):
        response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
    def test_header_injection(self):
        response = self.fetch("/header_injection")
        self.assertEqual(response.body, b"ok")
    def test_get_argument(self):
        response = self.fetch("/get_argument?foo=bar")
        self.assertEqual(response.body, b"bar")
        response = self.fetch("/get_argument?foo=")
        self.assertEqual(response.body, b"")
        response = self.fetch("/get_argument")
        self.assertEqual(response.body, b"default")
        body = urllib_parse.urlencode(dict(foo="hello"))
        response = self.fetch("/get_argument?foo=bar", method="POST", body=body)
        self.assertEqual(response.body, b"hello")
        response = self.fetch("/get_arguments?foo=bar",
                              method="POST", body=body)
        self.assertEqual(json_decode(response.body),
                         dict(default=['bar', 'hello'],
                              query=['bar'],
                              body=['hello']))
    def test_get_query_arguments(self):
        body = urllib_parse.urlencode(dict(foo="hello"))
        response = self.fetch("/get_argument?source=query&amp;foo=bar",
                              method="POST", body=body)
        self.assertEqual(response.body, b"bar")
        response = self.fetch("/get_argument?source=query&amp;foo=",
                              method="POST", body=body)
        self.assertEqual(response.body, b"")
        response = self.fetch("/get_argument?source=query",
                              method="POST", body=body)
        self.assertEqual(response.body, b"default")
    def test_get_body_arguments(self):
        body = urllib_parse.urlencode(dict(foo="bar"))
        response = self.fetch("/get_argument?source=body&amp;foo=hello",
                              method="POST", body=body)
        self.assertEqual(response.body, b"bar")
        body = urllib_parse.urlencode(dict(foo=""))
        response = self.fetch("/get_argument?source=body&amp;foo=hello",
                              method="POST", body=body)
        self.assertEqual(response.body, b"")
        body = urllib_parse.urlencode(dict())
        response = self.fetch("/get_argument?source=body&amp;foo=hello",
                              method="POST", body=body)
        self.assertEqual(response.body, b"default")
    def test_no_gzip(self):
        response = self.fetch('/get_argument')
        self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
        self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))
class NonWSGIWebTests(WebTestCase):
    def get_handlers(self):
        return [("/flow_control", FlowControlHandler),
                ("/empty_flush", EmptyFlushCallbackHandler),
                ]
    def test_flow_control(self):
        self.assertEqual(self.fetch("/flow_control").body, b"123")
    def test_empty_flush(self):
        response = self.fetch("/empty_flush")
        self.assertEqual(response.body, b"ok")
@wsgi_safe
class ErrorResponseTest(WebTestCase):
    def get_handlers(self):
        class DefaultHandler(RequestHandler):
            def get(self):
                if self.get_argument("status", None):
                    raise HTTPError(int(self.get_argument("status")))
                1 / 0
        class WriteErrorHandler(RequestHandler):
            def get(self):
                if self.get_argument("status", None):
                    self.send_error(int(self.get_argument("status")))
                else:
                    1 / 0
            def write_error(self, status_code, **kwargs):
                self.set_header("Content-Type", "text/plain")
                if "exc_info" in kwargs:
                    self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
                else:
                    self.write("Status: %d" % status_code)
        class FailedWriteErrorHandler(RequestHandler):
            def get(self):
                1 / 0
            def write_error(self, status_code, **kwargs):
                raise Exception("exception in write_error")
        return [url("/default", DefaultHandler),
                url("/write_error", WriteErrorHandler),
                url("/failed_write_error", FailedWriteErrorHandler),
                ]
    def test_default(self):
        with ExpectLog(app_log, "Uncaught exception"):
            response = self.fetch("/default")
            self.assertEqual(response.code, 500)
            self.assertTrue(b"500: Internal Server Error" in response.body)
            response = self.fetch("/default?status=503")
            self.assertEqual(response.code, 503)
            self.assertTrue(b"503: Service Unavailable" in response.body)
    def test_write_error(self):
        with ExpectLog(app_log, "Uncaught exception"):
            response = self.fetch("/write_error")
            self.assertEqual(response.code, 500)
            self.assertEqual(b"Exception: ZeroDivisionError", response.body)
            response = self.fetch("/write_error?status=503")
            self.assertEqual(response.code, 503)
            self.assertEqual(b"Status: 503", response.body)
    def test_failed_write_error(self):
        with ExpectLog(app_log, "Uncaught exception"):
            response = self.fetch("/failed_write_error")
            self.assertEqual(response.code, 500)
            self.assertEqual(b"", response.body)
@wsgi_safe
class StaticFileTest(WebTestCase):
    robots_txt_hash = b"f71d20196d4caf35b6a670db8c70b03d"
    static_dir = os.path.join(os.path.dirname(__file__), 'static')
    def get_handlers(self):
        class StaticUrlHandler(RequestHandler):
            def get(self, path):
                with_v = int(self.get_argument('include_version', 1))
                self.write(self.static_url(path, include_version=with_v))
        class AbsoluteStaticUrlHandler(StaticUrlHandler):
            include_host = True
        class OverrideStaticUrlHandler(RequestHandler):
            def get(self, path):
                do_include = bool(self.get_argument("include_host"))
                self.include_host = not do_include
                regular_url = self.static_url(path)
                override_url = self.static_url(path, include_host=do_include)
                if override_url == regular_url:
                    return self.write(str(False))
                protocol = self.request.protocol + "://"
                protocol_length = len(protocol)
                check_regular = regular_url.find(protocol, 0, protocol_length)
                check_override = override_url.find(protocol, 0, protocol_length)
                if do_include:
                    result = (check_override == 0 and check_regular == -1)
                else:
                    result = (check_override == -1 and check_regular == 0)
                self.write(str(result))
        return [('/static_url/(.*)', StaticUrlHandler),
                ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
                ('/override_static_url/(.*)', OverrideStaticUrlHandler),
                ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]
    def get_app_kwargs(self):
        return dict(static_path=relpath('static'))
    def test_static_files(self):
        response = self.fetch('/robots.txt')
        self.assertTrue(b"Disallow: /" in response.body)
        response = self.fetch('/static/robots.txt')
        self.assertTrue(b"Disallow: /" in response.body)
        self.assertEqual(response.headers.get("Content-Type"), "text/plain")
    def test_static_compressed_files(self):
        response = self.fetch("/static/sample.xml.gz")
        self.assertEqual(response.headers.get("Content-Type"),
                         "application/gzip")
        response = self.fetch("/static/sample.xml.bz2")
        self.assertEqual(response.headers.get("Content-Type"),
                         "application/octet-stream")
        response = self.fetch("/static/sample.xml")
        self.assertTrue(response.headers.get("Content-Type")
                        in set(("text/xml", "application/xml")))
    def test_static_url(self):
        response = self.fetch("/static_url/robots.txt")
        self.assertEqual(response.body,
                         b"/static/robots.txt?v=" + self.robots_txt_hash)
    def test_absolute_static_url(self):
        response = self.fetch("/abs_static_url/robots.txt")
        self.assertEqual(response.body, (
            utf8(self.get_url("/")) +
            b"static/robots.txt?v=" +
            self.robots_txt_hash
        ))
    def test_relative_version_exclusion(self):
        response = self.fetch("/static_url/robots.txt?include_version=0")
        self.assertEqual(response.body, b"/static/robots.txt")
    def test_absolute_version_exclusion(self):
        response = self.fetch("/abs_static_url/robots.txt?include_version=0")
        self.assertEqual(response.body,
                         utf8(self.get_url("/") + "static/robots.txt"))
    def test_include_host_override(self):
        self._trigger_include_host_check(False)
        self._trigger_include_host_check(True)
    def _trigger_include_host_check(self, include_host):
        path = "/override_static_url/robots.txt?include_host=%s"
        response = self.fetch(path % int(include_host))
        self.assertEqual(response.body, utf8(str(True)))
    def get_and_head(self, *args, **kwargs):
        head_response = self.fetch(*args, method="HEAD", **kwargs)
        get_response = self.fetch(*args, method="GET", **kwargs)
        content_headers = set()
        for h in itertools.chain(head_response.headers, get_response.headers):
            if h.startswith('Content-'):
                content_headers.add(h)
        for h in content_headers:
            self.assertEqual(head_response.headers.get(h),
                             get_response.headers.get(h),
                             "%s differs between GET (%s) and HEAD (%s)" %
                             (h, head_response.headers.get(h),
                              get_response.headers.get(h)))
        return get_response
    def test_static_304_if_modified_since(self):
        response1 = self.get_and_head("/static/robots.txt")
        response2 = self.get_and_head("/static/robots.txt", headers={
            'If-Modified-Since': response1.headers['Last-Modified']})
        self.assertEqual(response2.code, 304)
        self.assertTrue('Content-Length' not in response2.headers)
        self.assertTrue('Last-Modified' not in response2.headers)
    def test_static_304_if_none_match(self):
        response1 = self.get_and_head("/static/robots.txt")
        response2 = self.get_and_head("/static/robots.txt", headers={
            'If-None-Match': response1.headers['Etag']})
        self.assertEqual(response2.code, 304)
    def test_static_if_modified_since_pre_epoch(self):
        response = self.get_and_head("/static/robots.txt", headers={
            'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
        self.assertEqual(response.code, 200)
    def test_static_if_modified_since_time_zone(self):
        stat = os.stat(relpath('static/robots.txt'))
        response = self.get_and_head('/static/robots.txt', headers={
            'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})
        self.assertEqual(response.code, 200)
        response = self.get_and_head('/static/robots.txt', headers={
            'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})
        self.assertEqual(response.code, 304)
    def test_static_etag(self):
        response = self.get_and_head('/static/robots.txt')
        self.assertEqual(utf8(response.headers.get("Etag")),
                         b'"' + self.robots_txt_hash + b'"')
    def test_static_with_range(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-9'})
        self.assertEqual(response.code, 206)
        self.assertEqual(response.body, b"User-agent")
        self.assertEqual(utf8(response.headers.get("Etag")),
                         b'"' + self.robots_txt_hash + b'"')
        self.assertEqual(response.headers.get("Content-Length"), "10")
        self.assertEqual(response.headers.get("Content-Range"),
                         "bytes 0-9/26")
    def test_static_with_range_full_file(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-'})
        self.assertEqual(response.code, 200)
        robots_file_path = os.path.join(self.static_dir, "robots.txt")
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()))
        self.assertEqual(response.headers.get("Content-Length"), "26")
        self.assertEqual(response.headers.get("Content-Range"), None)
    def test_static_with_range_full_past_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=0-10000000'})
        self.assertEqual(response.code, 200)
        robots_file_path = os.path.join(self.static_dir, "robots.txt")
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()))
        self.assertEqual(response.headers.get("Content-Length"), "26")
        self.assertEqual(response.headers.get("Content-Range"), None)
    def test_static_with_range_partial_past_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=1-10000000'})
        self.assertEqual(response.code, 206)
        robots_file_path = os.path.join(self.static_dir, "robots.txt")
        with open(robots_file_path) as f:
            self.assertEqual(response.body, utf8(f.read()[1:]))
        self.assertEqual(response.headers.get("Content-Length"), "25")
        self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
    def test_static_with_range_end_edge(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=22-'})
        self.assertEqual(response.body, b": /\n")
        self.assertEqual(response.headers.get("Content-Length"), "4")
        self.assertEqual(response.headers.get("Content-Range"),
                         "bytes 22-25/26")
    def test_static_with_range_neg_end(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=-4'})
        self.assertEqual(response.body, b": /\n")
        self.assertEqual(response.headers.get("Content-Length"), "4")
        self.assertEqual(response.headers.get("Content-Range"),
                         "bytes 22-25/26")
    def test_static_invalid_range(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'asdf'})
        self.assertEqual(response.code, 200)
    def test_static_unsatisfiable_range_zero_suffix(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=-0'})
        self.assertEqual(response.headers.get("Content-Range"),
                         "bytes */26")
        self.assertEqual(response.code, 416)
    def test_static_unsatisfiable_range_invalid_start(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=26'})
        self.assertEqual(response.code, 416)
        self.assertEqual(response.headers.get("Content-Range"),
                         "bytes */26")
    def test_static_head(self):
        response = self.fetch('/static/robots.txt', method='HEAD')
        self.assertEqual(response.code, 200)
        self.assertEqual(response.body, b'')
        self.assertEqual(response.headers['Content-Length'], '26')
        self.assertEqual(utf8(response.headers['Etag']),
                         b'"' + self.robots_txt_hash + b'"')
    def test_static_head_range(self):
        response = self.fetch('/static/robots.txt', method='HEAD',
                              headers={'Range': 'bytes=1-4'})
        self.assertEqual(response.code, 206)
        self.assertEqual(response.body, b'')
        self.assertEqual(response.headers['Content-Length'], '4')
        self.assertEqual(utf8(response.headers['Etag']),
                         b'"' + self.robots_txt_hash + b'"')
    def test_static_range_if_none_match(self):
        response = self.get_and_head('/static/robots.txt', headers={
            'Range': 'bytes=1-4',
            'If-None-Match': b'"' + self.robots_txt_hash + b'"'})
        self.assertEqual(response.code, 304)
        self.assertEqual(response.body, b'')
        self.assertTrue('Content-Length' not in response.headers)
        self.assertEqual(utf8(response.headers['Etag']),
                         b'"' + self.robots_txt_hash + b'"')
    def test_static_404(self):
        response = self.get_and_head('/static/blarg')
        self.assertEqual(response.code, 404)
    def test_path_traversal_protection(self):
        self.http_client.close()
        self.http_client = SimpleAsyncHTTPClient()
        with ExpectLog(gen_log, ".*not in root static directory"):
            response = self.get_and_head('/static/../static_foo.txt')
        self.assertEqual(response.code, 403)
    @unittest.skipIf(os.name != 'posix', 'non-posix OS')
    def test_root_static_path(self):
        path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                            'static/robots.txt')
        response = self.get_and_head('/root_static' + urllib_parse.quote(path))
        self.assertEqual(response.code, 200)
@wsgi_safe
class StaticDefaultFilenameTest(WebTestCase):
    def get_app_kwargs(self):
        return dict(static_path=relpath('static'),
                    static_handler_args=dict(default_filename='index.html'))
    def get_handlers(self):
        return []
    def test_static_default_filename(self):
        response = self.fetch('/static/dir/', follow_redirects=False)
        self.assertEqual(response.code, 200)
        self.assertEqual(b'this is the index\n', response.body)
    def test_static_default_redirect(self):
        response = self.fetch('/static/dir', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertTrue(response.headers['Location'].endswith('/static/dir/'))
@wsgi_safe
class StaticFileWithPathTest(WebTestCase):
    def get_app_kwargs(self):
        return dict(static_path=relpath('static'),
                    static_handler_args=dict(default_filename='index.html'))
    def get_handlers(self):
        return [("/foo/(.*)", StaticFileHandler, {
            "path": relpath("templates/"),
        })]
    def test_serve(self):
        response = self.fetch("/foo/utf8.html")
        self.assertEqual(response.body, b"H\xc3\xa9llo\n")
@wsgi_safe
class CustomStaticFileTest(WebTestCase):
    def get_handlers(self):
        class MyStaticFileHandler(StaticFileHandler):
            @classmethod
            def make_static_url(cls, settings, path):
                version_hash = cls.get_version(settings, path)
                extension_index = path.rindex('.')
                before_version = path[:extension_index]
                after_version = path[(extension_index + 1):]
                return '/static/%s.%s.%s' % (before_version, version_hash,
                                             after_version)
            def parse_url_path(self, url_path):
                extension_index = url_path.rindex('.')
                version_index = url_path.rindex('.', 0, extension_index)
                return '%s%s' % (url_path[:version_index],
                                 url_path[extension_index:])
            @classmethod
            def get_absolute_path(cls, settings, path):
                return 'CustomStaticFileTest:' + path
            def validate_absolute_path(self, root, absolute_path):
                return absolute_path
            @classmethod
            def get_content(self, path, start=None, end=None):
                assert start is None and end is None
                if path == 'CustomStaticFileTest:foo.txt':
                    return b'bar'
                raise Exception("unexpected path %r" % path)
            def get_content_size(self):
                if self.absolute_path == 'CustomStaticFileTest:foo.txt':
                    return 3
                raise Exception("unexpected path %r" % self.absolute_path)
            def get_modified_time(self):
                return None
            @classmethod
            def get_version(cls, settings, path):
                return "42"
        class StaticUrlHandler(RequestHandler):
            def get(self, path):
                self.write(self.static_url(path))
        self.static_handler_class = MyStaticFileHandler
        return [("/static_url/(.*)", StaticUrlHandler)]
    def get_app_kwargs(self):
        return dict(static_path="dummy",
                    static_handler_class=self.static_handler_class)
    def test_serve(self):
        response = self.fetch("/static/foo.42.txt")
        self.assertEqual(response.body, b"bar")
    def test_static_url(self):
        with ExpectLog(gen_log, "Could not open static file", required=False):
            response = self.fetch("/static_url/foo.txt")
            self.assertEqual(response.body, b"/static/foo.42.txt")
@wsgi_safe
class HostMatchingTest(WebTestCase):
    class Handler(RequestHandler):
        def initialize(self, reply):
            self.reply = reply
        def get(self):
            self.write(self.reply)
    def get_handlers(self):
        return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
    def test_host_matching(self):
        self.app.add_handlers("www.example.com",
                              [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
        self.app.add_handlers(r"www\.example\.com",
                              [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
        self.app.add_handlers("www.example.com",
                              [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
        self.app.add_handlers("www.e.*e.com",
                              [("/baz", HostMatchingTest.Handler, {"reply": "[3]"})])
        response = self.fetch("/foo")
        self.assertEqual(response.body, b"wildcard")
        response = self.fetch("/bar")
        self.assertEqual(response.code, 404)
        response = self.fetch("/baz")
        self.assertEqual(response.code, 404)
        response = self.fetch("/foo", headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b"[0]")
        response = self.fetch("/bar", headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b"[1]")
        response = self.fetch("/baz", headers={'Host': 'www.example.com'})
        self.assertEqual(response.body, b"[2]")
        response = self.fetch("/baz", headers={'Host': 'www.exe.com'})
        self.assertEqual(response.body, b"[3]")
@wsgi_safe
class DefaultHostMatchingTest(WebTestCase):
    def get_handlers(self):
        return []
    def get_app_kwargs(self):
        return {'default_host': "www.example.com"}
    def test_default_host_matching(self):
        self.app.add_handlers("www.example.com",
                              [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
        self.app.add_handlers(r"www\.example\.com",
                              [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
        self.app.add_handlers("www.test.com",
                              [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
        response = self.fetch("/foo")
        self.assertEqual(response.body, b"[0]")
        response = self.fetch("/bar")
        self.assertEqual(response.body, b"[1]")
        response = self.fetch("/baz")
        self.assertEqual(response.code, 404)
        response = self.fetch("/foo", headers={"X-Real-Ip": "127.0.0.1"})
        self.assertEqual(response.code, 404)
        self.app.default_host = "www.test.com"
        response = self.fetch("/baz")
        self.assertEqual(response.body, b"[2]")
@wsgi_safe
class NamedURLSpecGroupsTest(WebTestCase):
    def get_handlers(self):
        class EchoHandler(RequestHandler):
            def get(self, path):
                self.write(path)
        return [("/str/(?P&lt;path&gt;.*)", EchoHandler),
                (u"/unicode/(?P&lt;path&gt;.*)", EchoHandler)]
    def test_named_urlspec_groups(self):
        response = self.fetch("/str/foo")
        self.assertEqual(response.body, b"foo")
        response = self.fetch("/unicode/bar")
        self.assertEqual(response.body, b"bar")
@wsgi_safe
class ClearHeaderTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_header("h1", "foo")
            self.set_header("h2", "bar")
            self.clear_header("h1")
            self.clear_header("nonexistent")
    def test_clear_header(self):
        response = self.fetch("/")
        self.assertTrue("h1" not in response.headers)
        self.assertEqual(response.headers["h2"], "bar")
class Header204Test(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_status(204)
            self.finish()
    def test_204_headers(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 204)
        self.assertNotIn("Content-Length", response.headers)
        self.assertNotIn("Transfer-Encoding", response.headers)
@wsgi_safe
class Header304Test(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.set_header("Content-Language", "en_US")
            self.write("hello")
    def test_304_headers(self):
        response1 = self.fetch('/')
        self.assertEqual(response1.headers["Content-Length"], "5")
        self.assertEqual(response1.headers["Content-Language"], "en_US")
        response2 = self.fetch('/', headers={
            'If-None-Match': response1.headers["Etag"]})
        self.assertEqual(response2.code, 304)
        self.assertTrue("Content-Length" not in response2.headers)
        self.assertTrue("Content-Language" not in response2.headers)
        self.assertTrue("Transfer-Encoding" not in response2.headers)
@wsgi_safe
class StatusReasonTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            reason = self.request.arguments.get('reason', [])
            self.set_status(int(self.get_argument('code')),
                            reason=reason[0] if reason else None)
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)
    def test_status(self):
        response = self.fetch("/?code=304")
        self.assertEqual(response.code, 304)
        self.assertEqual(response.reason, "Not Modified")
        response = self.fetch("/?code=304&amp;reason=Foo")
        self.assertEqual(response.code, 304)
        self.assertEqual(response.reason, "Foo")
        response = self.fetch("/?code=682&amp;reason=Bar")
        self.assertEqual(response.code, 682)
        self.assertEqual(response.reason, "Bar")
        with ExpectLog(app_log, 'Uncaught exception'):
            response = self.fetch("/?code=682")
        self.assertEqual(response.code, 500)
@wsgi_safe
class DateHeaderTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.write("hello")
    def test_date_header(self):
        response = self.fetch('/')
        header_date = datetime.datetime(
            *email.utils.parsedate(response.headers['Date'])[:6])
        self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
                        datetime.timedelta(seconds=2))
@wsgi_safe
class RaiseWithReasonTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            raise HTTPError(682, reason="Foo")
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)
    def test_raise_with_reason(self):
        response = self.fetch("/")
        self.assertEqual(response.code, 682)
        self.assertEqual(response.reason, "Foo")
        self.assertIn(b'682: Foo', response.body)
    def test_httperror_str(self):
        self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
    def test_httperror_str_from_httputil(self):
        self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
@wsgi_safe
class ErrorHandlerXSRFTest(WebTestCase):
    def get_handlers(self):
        return [('/error', ErrorHandler, dict(status_code=417))]
    def get_app_kwargs(self):
        return dict(xsrf_cookies=True)
    def test_error_xsrf(self):
        response = self.fetch('/error', method='POST', body='')
        self.assertEqual(response.code, 417)
    def test_404_xsrf(self):
        response = self.fetch('/404', method='POST', body='')
        self.assertEqual(response.code, 404)
@wsgi_safe
class GzipTestCase(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            for v in self.get_arguments('vary'):
                self.add_header('Vary', v)
            self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))
    def get_app_kwargs(self):
        return dict(
            gzip=True,
            static_path=os.path.join(os.path.dirname(__file__), 'static'))
    def assert_compressed(self, response):
        self.assertEqual(
            response.headers.get(
                'Content-Encoding',
                response.headers.get('X-Consumed-Content-Encoding')),
            'gzip')
    def test_gzip(self):
        response = self.fetch('/')
        self.assert_compressed(response)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
    def test_gzip_static(self):
        response = self.fetch('/robots.txt')
        self.assert_compressed(response)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
    def test_gzip_not_requested(self):
        response = self.fetch('/', use_gzip=False)
        self.assertNotIn('Content-Encoding', response.headers)
        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
    def test_vary_already_present(self):
        response = self.fetch('/?vary=Accept-Language')
        self.assert_compressed(response)
        self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
                         ['Accept-Language', 'Accept-Encoding'])
    def test_vary_already_present_multiple(self):
        response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
        self.assert_compressed(response)
        self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
                         ['Accept-Language', 'Cookie', 'Accept-Encoding'])
@wsgi_safe
class PathArgsInPrepareTest(WebTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
        def get(self, path):
            assert path == 'foo'
            self.finish()
    def get_handlers(self):
        return [('/pos/(.*)', self.Handler),
                ('/kw/(?P&lt;path&gt;.*)', self.Handler)]
    def test_pos(self):
        response = self.fetch('/pos/foo')
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})
    def test_kw(self):
        response = self.fetch('/kw/foo')
        response.rethrow()
        data = json_decode(response.body)
        self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})
@wsgi_safe
class ClearAllCookiesTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.clear_all_cookies()
            self.write('ok')
    def test_clear_all_cookies(self):
<a name="3"></a>        response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})
        set_cookies = sorted(response.headers.get_list('Set-Cookie'))
        self.assertTrue(set_cookies<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0].startswith('baz=;') or
                        set_cookies[0].startswith('baz="";'))
        self.assertTrue(set_cookies[1].startswith('foo=;') or
                        set_cookies[</b></font>1].startswith('foo="";'))
class PermissionError(Exception):
    pass
@wsgi_safe
class ExceptionHandlerTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            exc = self.get_argument('exc')
            if exc == 'http':
                raise HTTPError(410, "no longer here")
            elif exc == 'zero':
                1 / 0
            elif exc == 'permission':
                raise PermissionError('not allowed')
        def write_error(self, status_code, **kwargs):
            if 'exc_info' in kwargs:
                typ, value, tb = kwargs['exc_info']
                if isinstance(value, PermissionError):
                    self.set_status(403)
                    self.write('PermissionError')
                    return
            RequestHandler.write_error(self, status_code, **kwargs)
        def log_exception(self, typ, value, tb):
            if isinstance(value, PermissionError):
                app_log.warning('custom logging for PermissionError: %s',
                                value.args[0])
            else:
                RequestHandler.log_exception(self, typ, value, tb)
    def test_http_error(self):
        with ExpectLog(gen_log, '.*no longer here'):
            response = self.fetch('/?exc=http')
            self.assertEqual(response.code, 410)
    def test_unknown_error(self):
        with ExpectLog(app_log, 'Uncaught exception'):
            response = self.fetch('/?exc=zero')
            self.assertEqual(response.code, 500)
    def test_known_error(self):
        with ExpectLog(app_log,
                       'custom logging for PermissionError: not allowed'):
            response = self.fetch('/?exc=permission')
            self.assertEqual(response.code, 403)
@wsgi_safe
class BuggyLoggingTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            1 / 0
        def log_exception(self, typ, value, tb):
            1 / 0
    def test_buggy_log_exception(self):
        with ExpectLog(app_log, '.*'):
            self.fetch('/')
@wsgi_safe
class UIMethodUIModuleTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.render('foo.html')
        def value(self):
            return self.get_argument("value")
    def get_app_kwargs(self):
        def my_ui_method(handler, x):
            return "In my_ui_method(%s) with handler value %s." % (
                x, handler.value())
        class MyModule(UIModule):
            def render(self, x):
                return "In MyModule(%s) with handler value %s." % (
                    x, self.handler.value())
        loader = DictLoader({
            'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
        })
        return dict(template_loader=loader,
                    ui_methods={'my_ui_method': my_ui_method},
                    ui_modules={'MyModule': MyModule})
    def tearDown(self):
        super(UIMethodUIModuleTest, self).tearDown()
        RequestHandler._template_loaders.clear()
    def test_ui_method(self):
        response = self.fetch('/?value=asdf')
        self.assertEqual(response.body,
                         b'In my_ui_method(42) with handler value asdf. '
                         b'In MyModule(123) with handler value asdf.')
@wsgi_safe
class GetArgumentErrorTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            try:
                self.get_argument('foo')
                self.write({})
            except MissingArgumentError as e:
                self.write({'arg_name': e.arg_name,
                            'log_message': e.log_message})
    def test_catch_error(self):
        response = self.fetch('/')
        self.assertEqual(json_decode(response.body),
                         {'arg_name': 'foo',
                          'log_message': 'Missing argument foo'})
class MultipleExceptionTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        exc_count = 0
        @asynchronous
        def get(self):
            from salt.ext.tornado.ioloop import IOLoop
            IOLoop.current().add_callback(lambda: 1 / 0)
            IOLoop.current().add_callback(lambda: 1 / 0)
        def log_exception(self, typ, value, tb):
            MultipleExceptionTest.Handler.exc_count += 1
    def test_multi_exception(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 500)
        response = self.fetch('/')
        self.assertEqual(response.code, 500)
        self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)
@wsgi_safe
class SetLazyPropertiesTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.current_user = 'Ben'
            self.locale = locale.get('en_US')
        def get_user_locale(self):
            raise NotImplementedError()
        def get_current_user(self):
            raise NotImplementedError()
        def get(self):
            self.write('Hello %s (%s)' % (self.current_user, self.locale.code))
    def test_set_properties(self):
        response = self.fetch('/')
        self.assertEqual(response.body, b'Hello Ben (en_US)')
@wsgi_safe
class GetCurrentUserTest(WebTestCase):
    def get_app_kwargs(self):
        class WithoutUserModule(UIModule):
            def render(self):
                return ''
        class WithUserModule(UIModule):
            def render(self):
                return str(self.current_user)
        loader = DictLoader({
            'without_user.html': '',
            'with_user.html': '{{ current_user }}',
            'without_user_module.html': '{% module WithoutUserModule() %}',
            'with_user_module.html': '{% module WithUserModule() %}',
        })
        return dict(template_loader=loader,
                    ui_modules={'WithUserModule': WithUserModule,
                                'WithoutUserModule': WithoutUserModule})
    def tearDown(self):
        super(GetCurrentUserTest, self).tearDown()
        RequestHandler._template_loaders.clear()
    def get_handlers(self):
        class CurrentUserHandler(RequestHandler):
            def prepare(self):
                self.has_loaded_current_user = False
            def get_current_user(self):
                self.has_loaded_current_user = True
                return ''
        class WithoutUserHandler(CurrentUserHandler):
            def get(self):
                self.render_string('without_user.html')
                self.finish(str(self.has_loaded_current_user))
        class WithUserHandler(CurrentUserHandler):
            def get(self):
                self.render_string('with_user.html')
                self.finish(str(self.has_loaded_current_user))
        class CurrentUserModuleHandler(CurrentUserHandler):
            def get_template_namespace(self):
                return self.ui
        class WithoutUserModuleHandler(CurrentUserModuleHandler):
            def get(self):
                self.render_string('without_user_module.html')
                self.finish(str(self.has_loaded_current_user))
        class WithUserModuleHandler(CurrentUserModuleHandler):
            def get(self):
                self.render_string('with_user_module.html')
                self.finish(str(self.has_loaded_current_user))
        return [('/without_user', WithoutUserHandler),
                ('/with_user', WithUserHandler),
                ('/without_user_module', WithoutUserModuleHandler),
                ('/with_user_module', WithUserModuleHandler)]
    @unittest.skip('needs fix')
    def test_get_current_user_is_lazy(self):
        response = self.fetch('/without_user')
        self.assertEqual(response.body, b'False')
    def test_get_current_user_works(self):
        response = self.fetch('/with_user')
        self.assertEqual(response.body, b'True')
    def test_get_current_user_from_ui_module_is_lazy(self):
        response = self.fetch('/without_user_module')
        self.assertEqual(response.body, b'False')
    def test_get_current_user_from_ui_module_works(self):
        response = self.fetch('/with_user_module')
        self.assertEqual(response.body, b'True')
@wsgi_safe
class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        pass
    def test_unimplemented_standard_methods(self):
        for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
            response = self.fetch('/', method=method)
            self.assertEqual(response.code, 405)
        for method in ['POST', 'PUT']:
            response = self.fetch('/', method=method, body=b'')
            self.assertEqual(response.code, 405)
class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def other(self):
            self.write('other')
    def test_unimplemented_patch(self):
        response = self.fetch('/', method='PATCH', body=b'')
        self.assertEqual(response.code, 405)
    def test_unimplemented_other(self):
        response = self.fetch('/', method='OTHER',
                              allow_nonstandard_methods=True)
        self.assertEqual(response.code, 405)
@wsgi_safe
class AllHTTPMethodsTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def method(self):
            self.write(self.request.method)
        get = delete = options = post = put = method
    def test_standard_methods(self):
        response = self.fetch('/', method='HEAD')
        self.assertEqual(response.body, b'')
        for method in ['GET', 'DELETE', 'OPTIONS']:
            response = self.fetch('/', method=method)
            self.assertEqual(response.body, utf8(method))
        for method in ['POST', 'PUT']:
            response = self.fetch('/', method=method, body=b'')
            self.assertEqual(response.body, utf8(method))
class PatchMethodTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
        def patch(self):
            self.write('patch')
        def other(self):
            self.write('other')
    def test_patch(self):
        response = self.fetch('/', method='PATCH', body=b'')
        self.assertEqual(response.body, b'patch')
    def test_other(self):
        response = self.fetch('/', method='OTHER',
                              allow_nonstandard_methods=True)
        self.assertEqual(response.body, b'other')
@wsgi_safe
class FinishInPrepareTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def prepare(self):
            self.finish('done')
        def get(self):
            raise Exception('should not reach this method')
    def test_finish_in_prepare(self):
        response = self.fetch('/')
        self.assertEqual(response.body, b'done')
@wsgi_safe
class Default404Test(WebTestCase):
    def get_handlers(self):
        return [('/foo', RequestHandler)]
    def test_404(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 404)
        self.assertEqual(response.body,
                         b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
                         b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')
@wsgi_safe
class Custom404Test(WebTestCase):
    def get_handlers(self):
        return [('/foo', RequestHandler)]
    def get_app_kwargs(self):
        class Custom404Handler(RequestHandler):
            def get(self):
                self.set_status(404)
                self.write('custom 404 response')
        return dict(default_handler_class=Custom404Handler)
    def test_404(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 404)
        self.assertEqual(response.body, b'custom 404 response')
@wsgi_safe
class DefaultHandlerArgumentsTest(WebTestCase):
    def get_handlers(self):
        return [('/foo', RequestHandler)]
    def get_app_kwargs(self):
        return dict(default_handler_class=ErrorHandler,
                    default_handler_args=dict(status_code=403))
    def test_403(self):
        response = self.fetch('/')
        self.assertEqual(response.code, 403)
@wsgi_safe
class HandlerByNameTest(WebTestCase):
    def get_handlers(self):
        return [('/hello1', HelloHandler),
                ('/hello2', 'tornado.test.web_test.HelloHandler'),
                url('/hello3', 'tornado.test.web_test.HelloHandler'),
                ]
    def test_handler_by_name(self):
        resp = self.fetch('/hello1')
        self.assertEqual(resp.body, b'hello')
        resp = self.fetch('/hello2')
        self.assertEqual(resp.body, b'hello')
        resp = self.fetch('/hello3')
        self.assertEqual(resp.body, b'hello')
class StreamingRequestBodyTest(WebTestCase):
    def get_handlers(self):
        @stream_request_body
        class StreamingBodyHandler(RequestHandler):
            def initialize(self, test):
                self.test = test
            def prepare(self):
                self.test.prepared.set_result(None)
            def data_received(self, data):
                self.test.data.set_result(data)
            def get(self):
                self.test.finished.set_result(None)
                self.write({})
        @stream_request_body
        class EarlyReturnHandler(RequestHandler):
            def prepare(self):
                raise HTTPError(401)
        @stream_request_body
        class CloseDetectionHandler(RequestHandler):
            def initialize(self, test):
                self.test = test
            def on_connection_close(self):
                super(CloseDetectionHandler, self).on_connection_close()
                self.test.close_future.set_result(None)
        return [('/stream_body', StreamingBodyHandler, dict(test=self)),
                ('/early_return', EarlyReturnHandler),
                ('/close_detection', CloseDetectionHandler, dict(test=self))]
    def connect(self, url, connection_close):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
        s.connect(("127.0.0.1", self.get_http_port()))
        stream = IOStream(s, io_loop=self.io_loop)
        stream.write(b"GET " + url + b" HTTP/1.1\r\n")
        if connection_close:
            stream.write(b"Connection: close\r\n")
        stream.write(b"Transfer-Encoding: chunked\r\n\r\n")
        return stream
    @gen_test
    def test_streaming_body(self):
        self.prepared = Future()
        self.data = Future()
        self.finished = Future()
        stream = self.connect(b"/stream_body", connection_close=True)
        yield self.prepared
        stream.write(b"4\r\nasdf\r\n")
        data = yield self.data
        self.assertEqual(data, b"asdf")
        self.data = Future()
        stream.write(b"4\r\nqwer\r\n")
        data = yield self.data
        self.assertEquals(data, b"qwer")
        stream.write(b"0\r\n\r\n")
        yield self.finished
        data = yield gen.Task(stream.read_until_close)
        self.assertTrue(data.endswith(b"{}"))
        stream.close()
    @gen_test
    def test_early_return(self):
        stream = self.connect(b"/early_return", connection_close=False)
        data = yield gen.Task(stream.read_until_close)
        self.assertTrue(data.startswith(b"HTTP/1.1 401"))
    @gen_test
    def test_early_return_with_data(self):
        stream = self.connect(b"/early_return", connection_close=False)
        stream.write(b"4\r\nasdf\r\n")
        data = yield gen.Task(stream.read_until_close)
        self.assertTrue(data.startswith(b"HTTP/1.1 401"))
    @gen_test
    def test_close_during_upload(self):
        self.close_future = Future()
        stream = self.connect(b"/close_detection", connection_close=False)
        stream.close()
        yield self.close_future
@stream_request_body
class BaseFlowControlHandler(RequestHandler):
    def initialize(self, test):
        self.test = test
        self.method = None
        self.methods = []
    @contextlib.contextmanager
    def in_method(self, method):
        if self.method is not None:
            self.test.fail("entered method %s while in %s" %
                           (method, self.method))
        self.method = method
        self.methods.append(method)
        try:
            yield
        finally:
            self.method = None
    @gen.coroutine
    def prepare(self):
        self.methods.append('prepare')
        yield gen.Task(IOLoop.current().add_callback)
    @gen.coroutine
    def post(self):
        with self.in_method('post'):
            yield gen.Task(IOLoop.current().add_callback)
        self.write(dict(methods=self.methods))
class BaseStreamingRequestFlowControlTest(object):
    def get_httpserver_options(self):
        return dict(chunk_size=10, decompress_request=True)
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)
    def test_flow_control_fixed_body(self):
        response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
                              method='POST')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))
    def test_flow_control_chunked_body(self):
        chunks = [b'abcd', b'efgh', b'ijkl']
        @gen.coroutine
        def body_producer(write):
            for i in chunks:
                yield write(i)
        response = self.fetch('/', body_producer=body_producer, method='POST')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))
    def test_flow_control_compressed_body(self):
        bytesio = BytesIO()
        gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
        gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
        gzip_file.close()
        compressed_body = bytesio.getvalue()
        response = self.fetch('/', body=compressed_body, method='POST',
                              headers={'Content-Encoding': 'gzip'})
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         dict(methods=['prepare', 'data_received',
                                       'data_received', 'data_received',
                                       'post']))
class DecoratedStreamingRequestFlowControlTest(
        BaseStreamingRequestFlowControlTest,
        WebTestCase):
    def get_handlers(self):
        class DecoratedFlowControlHandler(BaseFlowControlHandler):
            @gen.coroutine
            def data_received(self, data):
                with self.in_method('data_received'):
                    yield gen.Task(IOLoop.current().add_callback)
        return [('/', DecoratedFlowControlHandler, dict(test=self))]
@skipBefore35
class NativeStreamingRequestFlowControlTest(
        BaseStreamingRequestFlowControlTest,
        WebTestCase):
    def get_handlers(self):
        class NativeFlowControlHandler(BaseFlowControlHandler):
            data_received = exec_test(globals(), locals(), """
            async def data_received(self, data):
                with self.in_method('data_received'):
                    await gen.Task(IOLoop.current().add_callback)
            response <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch(u)
            self.assertEqual(response.code, 401)
            self.assertEqual('Basic realm="something"',
                             response.headers.get('WWW-Authenticate'))
            self.assertEqual(b'authentication required', response.</b></font>body)
@wsgi_safe
class DecoratorTest(WebTestCase):
    def get_handlers(self):
        class RemoveSlashHandler(RequestHandler):
            @removeslash
            def get(self):
                pass
        class AddSlashHandler(RequestHandler):
            @addslash
            def get(self):
                pass
        return [("/removeslash/", RemoveSlashHandler),
                ("/addslash", AddSlashHandler),
                ]
    def test_removeslash(self):
        response = self.fetch("/removeslash/", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], "/removeslash")
        response = self.fetch("/removeslash/?foo=bar", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], "/removeslash?foo=bar")
    def test_addslash(self):
        response = self.fetch("/addslash", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], "/addslash/")
        response = self.fetch("/addslash?foo=bar", follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], "/addslash/?foo=bar")
@wsgi_safe
class CacheTest(WebTestCase):
    def get_handlers(self):
        class EtagHandler(RequestHandler):
            def get(self, computed_etag):
                self.write(computed_etag)
            def compute_etag(self):
                return self._write_buffer[0]
        return [
            ('/etag/(.*)', EtagHandler)
        ]
    def test_wildcard_etag(self):
        computed_etag = '"xyzzy"'
        etags = '*'
        self._test_etag(computed_etag, etags, 304)
    def test_strong_etag_match(self):
        computed_etag = '"xyzzy"'
        etags = '"xyzzy"'
        self._test_etag(computed_etag, etags, 304)
    def test_multiple_strong_etag_match(self):
        computed_etag = '"xyzzy1"'
        etags = '"xyzzy1", "xyzzy2"'
        self._test_etag(computed_etag, etags, 304)
    def test_strong_etag_not_match(self):
        computed_etag = '"xyzzy"'
        etags = '"xyzzy1"'
        self._test_etag(computed_etag, etags, 200)
    def test_multiple_strong_etag_not_match(self):
        computed_etag = '"xyzzy"'
        etags = '"xyzzy1", "xyzzy2"'
        self._test_etag(computed_etag, etags, 200)
    def test_weak_etag_match(self):
        computed_etag = '"xyzzy1"'
        etags = 'W/"xyzzy1"'
        self._test_etag(computed_etag, etags, 304)
    def test_multiple_weak_etag_match(self):
        computed_etag = '"xyzzy2"'
        etags = 'W/"xyzzy1", W/"xyzzy2"'
        self._test_etag(computed_etag, etags, 304)
    def test_weak_etag_not_match(self):
        computed_etag = '"xyzzy2"'
        etags = 'W/"xyzzy1"'
        self._test_etag(computed_etag, etags, 200)
    def test_multiple_weak_etag_not_match(self):
        computed_etag = '"xyzzy3"'
        etags = 'W/"xyzzy1", W/"xyzzy2"'
        self._test_etag(computed_etag, etags, 200)
    def _test_etag(self, computed_etag, etags, status_code):
        response = self.fetch(
            '/etag/' + computed_etag,
            headers={'If-None-Match': etags}
        )
        self.assertEqual(response.code, status_code)
@wsgi_safe
class RequestSummaryTest(SimpleHandlerTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.request.remote_ip = None
            self.finish(self._request_summary())
    def test_missing_remote_ip(self):
        resp = self.fetch("/")
        self.assertEqual(resp.body, b"GET / (None)")
class HTTPErrorTest(unittest.TestCase):
    def test_copy(self):
        e = HTTPError(403, reason="Go away")
        e2 = copy.copy(e)
        self.assertIsNot(e, e2)
        self.assertEqual(e.status_code, e2.status_code)
        self.assertEqual(e.reason, e2.reason)
class ApplicationTest(AsyncTestCase):
    def test_listen(self):
        app = Application([])
        server = app.listen(0, address='127.0.0.1')
        server.stop()
class URLSpecReverseTest(unittest.TestCase):
    def test_reverse(self):
        self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
        self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())
    def test_non_reversible(self):
        paths = [
            r'^/api/v\d+/foo/(\w+)$',
        ]
        for path in paths:
            url_spec = url(path, None)
            try:
                result = url_spec.reverse()
                self.fail("did not get expected exception when reversing %s. "
                          "result: %s" % (path, result))
            except ValueError:
                pass
    def test_reverse_arguments(self):
        self.assertEqual('/api/v1/foo/bar',
                         url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))
class RedirectHandlerTest(WebTestCase):
    def get_handlers(self):
        return [
            ('/src', WebRedirectHandler, {'url': '/dst'}),
            (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]
    def test_basic_redirect(self):
        response = self.fetch('/src', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/dst')
    def test_redirect_pattern(self):
        response = self.fetch('/a/b/c', follow_redirects=False)
        self.assertEqual(response.code, 301)
        self.assertEqual(response.headers['Location'], '/b/a/c')
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kiwiproc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import platform
import socket
from xml.dom import minidom
import salt.utils.files
from salt.modules.inspectlib.exceptions import InspectorKiwiProcessorException
try:
    import grp
    import pwd
except ImportError:
    pass
try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree
class KiwiExporter:
    def __init__(self, grains, format):
        self.__grains__ = grains
        self.format = format
        self._data = type("data", (), {})
        self.name = None
    def load(self, **descr):
        for obj, data in descr.items():
            setattr(self._data, obj, data)
        return self
    def export(self, name):
        self.name = name
        root = self._create_doc()
        self._set_description(root)
        self._set_preferences(root)
        self._set_repositories(root)
        self._set_users(root)
        self._set_packages(root)
<a name="4"></a>        return "\n".join(
            [
                line
                for line in minidom<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.parseString(etree.tostring(root, encoding="UTF-8"))
                .toprettyxml(indent="  ")
                .split("\n")
                if line.strip(</b></font>)
            ]
        )
    def _get_package_manager(self):
        ret = None
        if self.__grains__.get("os_family") in ("Kali", "Debian"):
            ret = "apt-get"
        elif self.__grains__.get("os_family", "") == "Suse":
            ret = "zypper"
        elif self.__grains__.get("os_family", "") == "redhat":
            ret = "yum"
        if ret is None:
            raise InspectorKiwiProcessorException(
                "Unsupported platform: {}".format(self.__grains__.get("os_family"))
            )
        return ret
    def _set_preferences(self, node):
        pref = etree.SubElement(node, "preferences")
        pacman = etree.SubElement(pref, "packagemanager")
        pacman.text = self._get_package_manager()
        p_version = etree.SubElement(pref, "version")
        p_version.text = "0.0.1"
        p_type = etree.SubElement(pref, "type")
        p_type.set("image", "vmx")
        for disk_id, disk_data in self._data.system.get("disks", {}).items():
            if disk_id.startswith("/dev"):
<a name="1"></a>                p_type.set("filesystem", disk_data.get("type") or "ext3")
                break
        p_type<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.set("installiso", "true")
        p_type.set("boot", "vmxboot/suse-leap42.1")
        p_type.set("format", self.format)
        p_type.set("bootloader", "grub2")
        p_type.set("timezone", __salt__["timezone.get_zone"]())
        p_type.set("hwclock", __salt__["timezone.get_hwclock"](</b></font>))
        return pref
    def _get_user_groups(self, user):
        return [g.gr_name for g in grp.getgrall() if user in g.gr_mem] + [
            grp.getgrgid(pwd.getpwnam(user).pw_gid).gr_name
        ]
    def _set_users(self, node):
        shadow = {}
        with salt.utils.files.fopen("/etc/shadow") as rfh:
            for sh_line in rfh.read().split(os.linesep):
                if sh_line.strip():
                    login, pwd = sh_line.split(":")[:2]
                    if pwd and pwd[0] not in "!*":
                        shadow[login] = {"p": pwd}
        with salt.utils.files.fopen("/etc/passwd") as rfh:
            for ps_line in rfh.read().split(os.linesep):
                if ps_line.strip():
                    ps_line = ps_line.strip().split(":")
                    if ps_line[0] in shadow:
                        shadow[ps_line[0]]["h"] = ps_line[5]
                        shadow[ps_line[0]]["s"] = ps_line[6]
                        shadow[ps_line[0]]["g"] = self._get_user_groups(ps_line[0])
<a name="2"></a>        users_groups = []
        users_node = etree.SubElement(node, "users")
        for u_name, u_data in shadow.items():
            user_node <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(users_node, "user")
            user_node.set("password", u_data["p"])
            user_node.set("home", u_data["h"])
            user_node.set("name", u_name)
            users_groups.extend(u_data[</b></font>"g"])
        users_node.set("group", ",".join(users_groups))
        return users_node
    def _set_repositories(self, node):
        priority = 99
        for repo_id, repo_data in self._data.software.get("repositories", {}).items():
            if type(repo_data) == list:
                repo_data = repo_data[0]
            if repo_data.get("enabled") or not repo_data.get(
                "disabled"
            ):  # RPM and Debian, respectively
                uri = repo_data.get("baseurl", repo_data.get("uri"))
<a name="3"></a>                if not uri:
                    continue
                repo = etree.SubElement(node, "repository")
                if self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__grains__.get("os_family") in ("Kali", "Debian"):
                    repo.set("alias", repo_id)
                    repo.set("distribution", repo_data["dist"])
                else:
                    repo.set("alias", repo_data[</b></font>"alias"])
                    if self.__grains__.get("os_family", "") == "Suse":
                        repo.set("type", "yast2")  # TODO: Check for options!
                    repo.set("priority", str(priority))
                source = etree.SubElement(repo, "source")
                source.set("path", uri)  # RPM and Debian, respectively
                priority -= 1
    def _set_packages(self, node):
        pkgs = etree.SubElement(node, "packages")
        for pkg_name, pkg_version in sorted(
            self._data.software.get("packages", {}).items()
        ):
            pkg = etree.SubElement(pkgs, "package")
            pkg.set("name", pkg_name)
        if self.__grains__.get("os_family", "") == "Suse":
            for ptn_id, ptn_data in self._data.software.get("patterns", {}).items():
                if ptn_data.get("installed"):
                    ptn = etree.SubElement(pkgs, "namedCollection")
                    ptn.set("name", ptn_id)
        return pkgs
    def _set_description(self, node):
        descr <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(node, "description")
        author = etree.SubElement(descr, "author")
        author.text = "salt.modules.node on {}".format(hostname)
        contact = etree.SubElement(descr, "contact")
        contact.text = "root@{}".format(hostname)
        specs = etree.SubElement(descr, "specification")
        specs.</b></font>text = "Rebuild of {}, based on Salt inspection.".format(hostname)
        return descr
    def _create_doc(self):
        root = etree.Element("image")
        root.set("schemaversion", "6.3")
        root.set("name", self.name)
        return root
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
