<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for web_test.py &amp; kiwiproc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for web_test.py &amp; kiwiproc.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>web_test.py (1.4430285%)<th>kiwiproc.py (18.509615%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(781-786)<td><a href="#" name="0">(248-254)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(481-488)<td><a href="#" name="1">(125-130)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2707-2711)<td><a href="#" name="2">(177-181)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1647-1650)<td><a href="#" name="3">(205-209)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(111-115)<td><a href="#" name="4">(78-81)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.concurrent import Future
3 from salt.ext.tornado import gen
4 from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
5 from salt.ext.tornado.httputil import format_timestamp
6 from salt.ext.tornado.ioloop import IOLoop
7 from salt.ext.tornado.iostream import IOStream
8 from salt.ext.tornado import locale
9 from salt.ext.tornado.log import app_log, gen_log
10 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
11 from salt.ext.tornado.template import DictLoader
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
14 from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
15 from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding
16 import binascii
17 import contextlib
18 import copy
19 import datetime
20 import email.utils
21 import gzip
22 from io import BytesIO
23 import itertools
24 import logging
25 import os
26 import re
27 import socket
28 if PY3:
29     import urllib.parse as urllib_parse  # py3
30 else:
31     import urllib as urllib_parse  # py2
32 wsgi_safe_tests = []
33 def relpath(*a):
34     return os.path.join(os.path.dirname(__file__), *a)
35 def wsgi_safe(cls):
36     wsgi_safe_tests.append(cls)
37     return cls
38 class WebTestCase(AsyncHTTPTestCase):
39     def get_app(self):
40         self.app = Application(self.get_handlers(), **self.get_app_kwargs())
41         return self.app
42     def get_handlers(self):
43         raise NotImplementedError()
44     def get_app_kwargs(self):
45         return {}
46 class SimpleHandlerTestCase(WebTestCase):
47     def get_handlers(self):
48         return [('/', self.Handler)]
49 class HelloHandler(RequestHandler):
50     def get(self):
51         self.write('hello')
52 class CookieTestRequestHandler(RequestHandler):
53     def __init__(self, cookie_secret='0123456789', key_version=None):
54         self._cookies = {}
55         if key_version is None:
56             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
57         else:
58             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
59                                                         key_version=key_version))
60     def get_cookie(self, name):
61         return self._cookies.get(name)
62     def set_cookie(self, name, value, expires_days=None):
63         self._cookies[name] = value
64 class SecureCookieV1Test(unittest.TestCase):
65     def test_round_trip(self):
66         handler = CookieTestRequestHandler()
67         handler.set_secure_cookie('foo', b'bar', version=1)
68         self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
69                          b'bar')
70     def test_cookie_tampering_future_timestamp(self):
71         handler = CookieTestRequestHandler()
72                                   version=1)
73         cookie = handler._cookies['foo']
74         match = re<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
75         self.assertTrue(match)
76         timestamp = match.group(1)
77         sig = match.group(2)
78         self.assertEqual(</b></font>
79             _create_signature_v1(handler.application.settings["cookie_secret"],
80                                  'foo', '12345678', timestamp),
81             sig)
82         self.assertEqual(
83             _create_signature_v1(handler.application.settings["cookie_secret"],
84                                  'foo', '1234', b'5678' + timestamp),
85             sig)
86         handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
87             to_basestring(timestamp), to_basestring(sig)))
88         with ExpectLog(gen_log, "Cookie timestamp in future"):
89             self.assertTrue(
90                 handler.get_secure_cookie('foo', min_version=1) is None)
91     def test_arbitrary_bytes(self):
92         handler = CookieTestRequestHandler()
93         handler.set_secure_cookie('foo', b'\xe9', version=1)
94         self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')
95 class SecureCookieV2Test(unittest.TestCase):
96     KEY_VERSIONS = {
97         0: 'ajklasdf0ojaisdf',
98         1: 'aslkjasaolwkjsdf'
99     }
100     def test_round_trip(self):
101         handler = CookieTestRequestHandler()
102         handler.set_secure_cookie('foo', b'bar', version=2)
103         self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')
104     def test_key_version_roundtrip(self):
105         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
106                                            key_version=0)
107         handler.set_secure_cookie('foo', b'bar')
108         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
109     def test_key_version_roundtrip_differing_version(self):
110         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
111                                            key_version=1)
112         handler.set_secure_cookie('foo', b'bar')
113         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
114     def test_key_version_increment_version(self):
115         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
116                                            key_version=0)
117         handler.set_secure_cookie('foo', b'bar')
118         new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
119                                                key_version=1)
120         new_handler._cookies = handler._cookies
121         self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')
122     def test_key_version_invalidate_version(self):
123         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
124                                            key_version=0)
125         handler.set_secure_cookie('foo', b'bar')
126         new_key_versions = self.KEY_VERSIONS.copy()
127         new_key_versions.pop(0)
128         new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
129                                                key_version=1)
130         new_handler._cookies = handler._cookies
131         self.assertEqual(new_handler.get_secure_cookie('foo'), None)
132 class CookieTest(WebTestCase):
133     def get_handlers(self):
134         class SetCookieHandler(RequestHandler):
135             def get(self):
136                 self.set_cookie("str", "asdf")
137                 self.set_cookie("unicode", u"qwer")
138                 self.set_cookie("bytes", b"zxcv")
139         class GetCookieHandler(RequestHandler):
140             def get(self):
141                 self.write(self.get_cookie("foo", "default"))
142         class SetCookieDomainHandler(RequestHandler):
143             def get(self):
144                 self.set_cookie("unicode_args", "blah", domain=u"foo.com",
145                                 path=u"/foo")
146         class SetCookieSpecialCharHandler(RequestHandler):
147             def get(self):
148                 self.set_cookie("equals", "a=b")
149                 self.set_cookie("semicolon", "a;b")
150                 self.set_cookie("quote", 'a"b')
151         class SetCookieOverwriteHandler(RequestHandler):
152             def get(self):
153                 self.set_cookie("a", "b", domain="example.com")
154                 self.set_cookie("c", "d", domain="example.com")
155                 self.set_cookie("a", "e")
156         class SetCookieMaxAgeHandler(RequestHandler):
157             def get(self):
158                 self.set_cookie("foo", "bar", max_age=10)
159         class SetCookieExpiresDaysHandler(RequestHandler):
160             def get(self):
161                 self.set_cookie("foo", "bar", expires_days=10)
162         class SetCookieFalsyFlags(RequestHandler):
163             def get(self):
164                 self.set_cookie("a", "1", secure=True)
165                 self.set_cookie("b", "1", secure=False)
166                 self.set_cookie("c", "1", httponly=True)
167                 self.set_cookie("d", "1", httponly=False)
168         return [("/set", SetCookieHandler),
169                 ("/get", GetCookieHandler),
170                 ("/set_domain", SetCookieDomainHandler),
171                 ("/special_char", SetCookieSpecialCharHandler),
172                 ("/set_overwrite", SetCookieOverwriteHandler),
173                 ("/set_max_age", SetCookieMaxAgeHandler),
174                 ("/set_expires_days", SetCookieExpiresDaysHandler),
175                 ("/set_falsy_flags", SetCookieFalsyFlags)
176                 ]
177     def test_set_cookie(self):
178         response = self.fetch("/set")
179         self.assertEqual(sorted(response.headers.get_list("Set-Cookie")),
180                          ["bytes=zxcv; Path=/",
181                           "str=asdf; Path=/",
182                           "unicode=qwer; Path=/",
183                           ])
184     def test_get_cookie(self):
185         response = self.fetch("/get", headers={"Cookie": "foo=bar"})
186         self.assertEqual(response.body, b"bar")
187         response = self.fetch("/get", headers={"Cookie": 'foo="bar"'})
188         self.assertEqual(response.body, b"bar")
189         response = self.fetch("/get", headers={"Cookie": "/=exception;"})
190         self.assertEqual(response.body, b"default")
191     def test_set_cookie_domain(self):
192         response = self.fetch("/set_domain")
193         self.assertEqual(response.headers.get_list("Set-Cookie"),
194                          ["unicode_args=blah; Domain=foo.com; Path=/foo"])
195     def test_cookie_special_char(self):
196         response = self.fetch("/special_char")
197         headers = sorted(response.headers.get_list("Set-Cookie"))
198         self.assertEqual(len(headers), 3)
199         self.assertEqual(headers[0], 'equals="a=b"; Path=/')
200         self.assertEqual(headers[1], 'quote="a\\"b"; Path=/')
201         self.assertTrue(headers[2] in ('semicolon="a;b"; Path=/',
202                                        'semicolon="a\\073b"; Path=/'),
203                         headers[2])
204         data = [('foo=a=b', 'a=b'),
205                 ('foo="a=b"', 'a=b'),
206                 ('foo="a;b"', '"a'),  # even quoted, ";" is a delimiter
207                 ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
208                 ('foo="a\\073b"', 'a;b'),
209                 ('foo="a\\"b"', 'a"b'),
210                 ]
211         for header, expected in data:
212             logging.debug("trying %r", header)
213             response = self.fetch("/get", headers={"Cookie": header})
214             self.assertEqual(response.body, utf8(expected))
215     def test_set_cookie_overwrite(self):
216         response = self.fetch("/set_overwrite")
217         headers = response.headers.get_list("Set-Cookie")
218         self.assertEqual(sorted(headers),
219                          ["a=e; Path=/", "c=d; Domain=example.com; Path=/"])
220     def test_set_cookie_max_age(self):
221         response = self.fetch("/set_max_age")
222         headers = response.headers.get_list("Set-Cookie")
223         self.assertEqual(sorted(headers),
224                          ["foo=bar; Max-Age=10; Path=/"])
225     def test_set_cookie_expires_days(self):
226         response = self.fetch("/set_expires_days")
227         header = response.headers.get("Set-Cookie")
228         match = re.match("foo=bar; expires=(?P&lt;expires&gt;.+); Path=/", header)
229         self.assertIsNotNone(match)
230         expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
231         header_expires = datetime.datetime(
232             *email.utils.parsedate(match.groupdict()["expires"])[:6])
233         self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)
234     def test_set_cookie_false_flags(self):
235         response = self.fetch("/set_falsy_flags")
236         headers = sorted(response.headers.get_list("Set-Cookie"))
237         self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
238         self.assertEqual(headers[1].lower(), 'b=1; path=/')
239         self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
240         self.assertEqual(headers[3].lower(), 'd=1; path=/')
241 class AuthRedirectRequestHandler(RequestHandler):
242     def initialize(self, login_url):
243         self.login_url = login_url
244     def get_login_url(self):
245         return self.login_url
246     @authenticated
247     def get(self):
248         self.send_error(500)
249 class AuthRedirectTest(WebTestCase):
250     def get_handlers(self):
251         return [('/relative', AuthRedirectRequestHandler,
252                  dict(login_url='/login')),
253                 ('/absolute', AuthRedirectRequestHandler,
254                  dict(login_url='http://example.com/login'))]
255     def test_relative_auth_redirect(self):
256         self.http_client.fetch(self.get_url('/relative'), self.stop,
257                                follow_redirects=False)
258         response = self.wait()
259         self.assertEqual(response.code, 302)
260         self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')
261     def test_absolute_auth_redirect(self):
262         self.http_client.fetch(self.get_url('/absolute'), self.stop,
263                                follow_redirects=False)
264         response = self.wait()
265         self.assertEqual(response.code, 302)
266         self.assertTrue(re.match(
267             'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
268             response.headers['Location']), response.headers['Location'])
269 class ConnectionCloseHandler(RequestHandler):
270     def initialize(self, test):
271         self.test = test
272     @asynchronous
273     def get(self):
274         self.test.on_handler_waiting()
275     def on_connection_close(self):
276         self.test.on_connection_close()
277 class ConnectionCloseTest(WebTestCase):
278     def get_handlers(self):
279         return [('/', ConnectionCloseHandler, dict(test=self))]
280     def test_connection_close(self):
281         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
282         s.connect(("127.0.0.1", self.get_http_port()))
283         self.stream = IOStream(s, io_loop=self.io_loop)
284         self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
285         self.wait()
286     def on_handler_waiting(self):
287         logging.debug('handler waiting')
288         self.stream.close()
289     def on_connection_close(self):
290         logging.debug('connection closed')
291         self.stop()
292 class EchoHandler(RequestHandler):
293     def get(self, *path_args):
294         for key in self.request.arguments:
295             if type(key) != str:
296                 raise Exception("incorrect type for key: %r" % type(key))
297             for value in self.request.arguments[key]:
298                 if type(value) != bytes:
299                     raise Exception("incorrect type for value: %r" %
300                                     type(value))
301             for value in self.get_arguments(key):
302                 if type(value) != unicode_type:
303                     raise Exception("incorrect type for value: %r" %
304                                     type(value))
305         for arg in path_args:
306             if type(arg) != unicode_type:
307                 raise Exception("incorrect type for path arg: %r" % type(arg))
308         self.write(dict(path=self.request.path,
309                         path_args=path_args,
310                         args=recursive_unicode(self.request.arguments)))
311 class RequestEncodingTest(WebTestCase):
312     def get_handlers(self):
313         return [("/group/(.*)", EchoHandler),
314                 ("/slashes/([^/]*)/([^/]*)", EchoHandler),
315                 ]
316     def fetch_json(self, path):
317         return json_decode(self.fetch(path).body)
318     def test_group_question_mark(self):
319         self.assertEqual(self.fetch_json('/group/%3F'),
320                          dict(path='/group/%3F', path_args=['?'], args={}))
321         self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
322                          dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))
323     def test_group_encoding(self):
324         self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
325                          {u"path": u"/group/%C3%A9",
326                           u"path_args": [u"\u00e9"],
327                           u"args": {u"arg": [u"\u00e9"]}})
328     def test_slashes(self):
329         self.assertEqual(self.fetch_json('/slashes/foo/bar'),
330                          dict(path="/slashes/foo/bar",
331                               path_args=["foo", "bar"],
332                               args={}))
333         self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
334                          dict(path="/slashes/a%2Fb/c%2Fd",
335                               path_args=["a/b", "c/d"],
336                               args={}))
337     def test_error(self):
338         with ExpectLog(gen_log, ".*Invalid unicode"):
339             self.fetch("/group/?arg=%25%e9")
340 class TypeCheckHandler(RequestHandler):
341     def prepare(self):
342         self.errors = {}
343         self.check_type('status', self.get_status(), int)
344         self.check_type('argument', self.get_argument('foo'), unicode_type)
345         self.check_type('cookie_key', list(self.cookies.keys())[0], str)
346         self.check_type('cookie_value', list(self.cookies.values())[0].value, str)
347         if list(self.cookies.keys()) != ['asdf']:
348                             self.cookies.keys())
349         self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
350         self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.check_type('get_cookie', self.get_cookie('asdf'), str)
351         self.check_type('xsrf_token', self.xsrf_token, bytes)
352         self.check_type('xsrf_form_html', self.xsrf_form_html(), str)
353         self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)
354         self.check_type(</b></font>'request_summary', self._request_summary(), str)
355     def get(self, path_component):
356         self.check_type('path_component', path_component, unicode_type)
357         self.write(self.errors)
358     def post(self, path_component):
359         self.check_type('path_component', path_component, unicode_type)
360         self.write(self.errors)
361     def check_type(self, name, obj, expected_type):
362         actual_type = type(obj)
363         if expected_type != actual_type:
364             self.errors[name] = "expected %s, got %s" % (expected_type,
365                                                          actual_type)
366 class DecodeArgHandler(RequestHandler):
367     def decode_argument(self, value, name=None):
368         if type(value) != bytes:
369             raise Exception("unexpected type for value: %r" % type(value))
370         if 'encoding' in self.request.arguments:
371             return value.decode(to_unicode(self.request.arguments['encoding'][0]))
372         else:
373             return value
374     def get(self, arg):
375         def describe(s):
376             if type(s) == bytes:
377                 return ["bytes", native_str(binascii.b2a_hex(s))]
378             elif type(s) == unicode_type:
379                 return ["unicode", s]
380             raise Exception("unknown type")
381         self.write({'path': describe(arg),
382                     'query': describe(self.get_argument("foo")),
383                     })
384 class LinkifyHandler(RequestHandler):
385     def get(self):
386         self.render("linkify.html", message="http://example.com")
387 class UIModuleResourceHandler(RequestHandler):
388     def get(self):
389         self.render("page.html", entries=[1, 2])
390 class OptionalPathHandler(RequestHandler):
391     def get(self, path):
392         self.write({"path": path})
393 class FlowControlHandler(RequestHandler):
394     @asynchronous
395     def get(self):
396         self.write("1")
397         self.flush(callback=self.step2)
398     def step2(self):
399         self.write("2")
400         self.flush(callback=self.step3)
401     def step3(self):
402         self.write("3")
403         self.finish()
404 class MultiHeaderHandler(RequestHandler):
405     def get(self):
406         self.set_header("x-overwrite", "1")
407         self.set_header("X-Overwrite", 2)
408         self.add_header("x-multi", 3)
409         self.add_header("X-Multi", "4")
410 class RedirectHandler(RequestHandler):
411     def get(self):
412         if self.get_argument('permanent', None) is not None:
413             self.redirect('/', permanent=int(self.get_argument('permanent')))
414         elif self.get_argument('status', None) is not None:
415             self.redirect('/', status=int(self.get_argument('status')))
416         else:
417             raise Exception("didn't get permanent or status arguments")
418 class EmptyFlushCallbackHandler(RequestHandler):
419     @asynchronous
420     @gen.engine
421     def get(self):
422         yield gen.Task(self.flush)  # "empty" flush, but writes headers
423         yield gen.Task(self.flush)  # empty flush
424         self.write("o")
425         yield self.flush()  # flushes the "o"
426         yield self.flush()  # empty flush
427         self.finish("k")
428 class HeaderInjectionHandler(RequestHandler):
429     def get(self):
430         try:
431             self.set_header("X-Foo", "foo\r\nX-Bar: baz")
432             raise Exception("Didn't get expected exception")
433         except ValueError as e:
434             if "Unsafe header value" in str(e):
435                 self.finish(b"ok")
436             else:
437                 raise
438 class GetArgumentHandler(RequestHandler):
439     def prepare(self):
440         if self.get_argument('source', None) == 'query':
441             method = self.get_query_argument
442         elif self.get_argument('source', None) == 'body':
443             method = self.get_body_argument
444         else:
445             method = self.get_argument
446         self.finish(method("foo", "default"))
447 class GetArgumentsHandler(RequestHandler):
448     def prepare(self):
449         self.finish(dict(default=self.get_arguments("foo"),
450                          query=self.get_query_arguments("foo"),
451                          body=self.get_body_arguments("foo")))
452 @wsgi_safe
453 class WSGISafeWebTest(WebTestCase):
454     COOKIE_SECRET = "WebTest.COOKIE_SECRET"
455     def get_app_kwargs(self):
456         loader = DictLoader({
457             "linkify.html": "{% module linkify(message) %}",
458             "page.html": """\
459 &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
460 {% for e in entries %}
461 {% module Template("entry.html", entry=e) %}
462 {% end %}
463 &lt;/body&gt;&lt;/html&gt;""",
464             "entry.html": """\
465 {{ set_resources(embedded_css=".entry { margin-bottom: 1em; }", embedded_javascript="js_embed()", css_files=["/base.css", "/foo.css"], javascript_files="/common.js", html_head="&lt;meta&gt;", html_body='&lt;script src="/analytics.js"/&gt;') }}
466 &lt;div class="entry"&gt;...&lt;/div&gt;""",
467         })
468         return dict(template_loader=loader,
469                     autoescape="xhtml_escape",
470                     cookie_secret=self.COOKIE_SECRET)
471     def tearDown(self):
472         super(WSGISafeWebTest, self).tearDown()
473         RequestHandler._template_loaders.clear()
474     def get_handlers(self):
475         urls = [
476             url("/typecheck/(.*)", TypeCheckHandler, name='typecheck'),
477             url("/decode_arg/(.*)", DecodeArgHandler, name='decode_arg'),
478             url("/decode_arg_kw/(?P&lt;arg&gt;.*)", DecodeArgHandler),
479             url("/linkify", LinkifyHandler),
480             url("/uimodule_resources", UIModuleResourceHandler),
481             url("/optional_path/(.+)?", OptionalPathHandler),
482             url("/multi_header", MultiHeaderHandler),
483             url("/redirect", RedirectHandler),
484             url("/web_redirect_permanent", WebRedirectHandler, {"url": "/web_redirect_newpath"}),
485             url("/web_redirect", WebRedirectHandler, {"url": "/web_redirect_newpath", "permanent": False}),
486             url("//web_redirect_double_slash", WebRedirectHandler, {"url": '/web_redirect_newpath'}),
487             url("/header_injection", HeaderInjectionHandler),
488             url("/get_argument", GetArgumentHandler),
489             url("/get_arguments", GetArgumentsHandler),
490         ]
491         return urls
492     def fetch_json(self, *args, **kwargs):
493         response = self.fetch(*args, **kwargs)
494         response.rethrow()
495         return json_decode(response.body)
496     def test_types(self):
497         cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
498                                                       "asdf", "qwer"))
499         response = self.fetch("/typecheck/asdf?foo=bar",
500                               headers={"Cookie": "asdf=" + cookie_value})
501         data = json_decode(response.body)
502         self.assertEqual(data, {})
503         response = self.fetch("/typecheck/asdf?foo=bar", method="POST",
504                               headers={"Cookie": "asdf=" + cookie_value},
505                               body="foo=bar")
506     def test_decode_argument(self):
507         urls = ["/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8",
508                 "/decode_arg/%E9?foo=%E9&amp;encoding=latin1",
509                 "/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1",
510                 ]
511         for req_url in urls:
512             response = self.fetch(req_url)
513             response.rethrow()
514             data = json_decode(response.body)
515             self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
516                                     u'query': [u'unicode', u'\u00e9'],
517                                     })
518         response = self.fetch("/decode_arg/%C3%A9?foo=%C3%A9")
519         response.rethrow()
520         data = json_decode(response.body)
521         self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
522                                 u'query': [u'bytes', u'c3a9'],
523                                 })
524     def test_decode_argument_invalid_unicode(self):
525         with ExpectLog(gen_log, ".*Invalid unicode.*"):
526             response = self.fetch("/typecheck/invalid%FF")
527             self.assertEqual(response.code, 400)
528             response = self.fetch("/typecheck/invalid?foo=%FF")
529             self.assertEqual(response.code, 400)
530     def test_decode_argument_plus(self):
531         urls = ["/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8",
532                 "/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8"]
533         for req_url in urls:
534             response = self.fetch(req_url)
535             response.rethrow()
536             data = json_decode(response.body)
537             self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
538                                     u'query': [u'unicode', u'1 + 1'],
539                                     })
540     def test_reverse_url(self):
541         self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
542                          '/decode_arg/foo')
543         self.assertEqual(self.app.reverse_url('decode_arg', 42),
544                          '/decode_arg/42')
545         self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
546                          '/decode_arg/%E9')
547         self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
548                          '/decode_arg/%C3%A9')
549         self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
550                          '/decode_arg/1%20%2B%201')
551     def test_uimodule_unescaped(self):
552         response = self.fetch("/linkify")
553         self.assertEqual(response.body,
554                          b"&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;")
555     def test_uimodule_resources(self):
556         response = self.fetch("/uimodule_resources")
557         self.assertEqual(response.body, b"""\
558 &lt;html&gt;&lt;head&gt;&lt;link href="/base.css" type="text/css" rel="stylesheet"/&gt;&lt;link href="/foo.css" type="text/css" rel="stylesheet"/&gt;
559 &lt;style type="text/css"&gt;
560 .entry { margin-bottom: 1em; }
561 &lt;/style&gt;
562 &lt;meta&gt;
563 &lt;/head&gt;&lt;body&gt;
564 &lt;div class="entry"&gt;...&lt;/div&gt;
565 &lt;div class="entry"&gt;...&lt;/div&gt;
566 &lt;script src="/common.js" type="text/javascript"&gt;&lt;/script&gt;
567 &lt;script type="text/javascript"&gt;
568 //&lt;![CDATA[
569 js_embed()
570 //]]&gt;
571 &lt;/script&gt;
572 &lt;script src="/analytics.js"/&gt;
573 &lt;/body&gt;&lt;/html&gt;""")
574     def test_optional_path(self):
575         self.assertEqual(self.fetch_json("/optional_path/foo"),
576                          {u"path": u"foo"})
577         self.assertEqual(self.fetch_json("/optional_path/"),
578                          {u"path": None})
579     def test_multi_header(self):
580         response = self.fetch("/multi_header")
581         self.assertEqual(response.headers["x-overwrite"], "2")
582     def test_redirect(self):
583         response <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch("/redirect?permanent=1", follow_redirects=False)
584         self.assertEqual(response.code, 301)
585         response = self.fetch("/redirect?permanent=0", follow_redirects=False)
586         self.assertEqual(response.code, 302)
587         response = self.fetch("/redirect?status=307", follow_redirects=False)
588         self.assertEqual(response.</b></font>code, 307)
589     def test_web_redirect(self):
590         response = self.fetch("/web_redirect_permanent", follow_redirects=False)
591         self.assertEqual(response.code, 301)
592         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
593         response = self.fetch("/web_redirect", follow_redirects=False)
594         self.assertEqual(response.code, 302)
595         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
596     def test_web_redirect_double_slash(self):
597         response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
598         self.assertEqual(response.code, 301)
599         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
600     def test_header_injection(self):
601         response = self.fetch("/header_injection")
602         self.assertEqual(response.body, b"ok")
603     def test_get_argument(self):
604         response = self.fetch("/get_argument?foo=bar")
605         self.assertEqual(response.body, b"bar")
606         response = self.fetch("/get_argument?foo=")
607         self.assertEqual(response.body, b"")
608         response = self.fetch("/get_argument")
609         self.assertEqual(response.body, b"default")
610         body = urllib_parse.urlencode(dict(foo="hello"))
611         response = self.fetch("/get_argument?foo=bar", method="POST", body=body)
612         self.assertEqual(response.body, b"hello")
613         response = self.fetch("/get_arguments?foo=bar",
614                               method="POST", body=body)
615         self.assertEqual(json_decode(response.body),
616                          dict(default=['bar', 'hello'],
617                               query=['bar'],
618                               body=['hello']))
619     def test_get_query_arguments(self):
620         body = urllib_parse.urlencode(dict(foo="hello"))
621         response = self.fetch("/get_argument?source=query&amp;foo=bar",
622                               method="POST", body=body)
623         self.assertEqual(response.body, b"bar")
624         response = self.fetch("/get_argument?source=query&amp;foo=",
625                               method="POST", body=body)
626         self.assertEqual(response.body, b"")
627         response = self.fetch("/get_argument?source=query",
628                               method="POST", body=body)
629         self.assertEqual(response.body, b"default")
630     def test_get_body_arguments(self):
631         body = urllib_parse.urlencode(dict(foo="bar"))
632         response = self.fetch("/get_argument?source=body&amp;foo=hello",
633                               method="POST", body=body)
634         self.assertEqual(response.body, b"bar")
635         body = urllib_parse.urlencode(dict(foo=""))
636         response = self.fetch("/get_argument?source=body&amp;foo=hello",
637                               method="POST", body=body)
638         self.assertEqual(response.body, b"")
639         body = urllib_parse.urlencode(dict())
640         response = self.fetch("/get_argument?source=body&amp;foo=hello",
641                               method="POST", body=body)
642         self.assertEqual(response.body, b"default")
643     def test_no_gzip(self):
644         response = self.fetch('/get_argument')
645         self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
646         self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))
647 class NonWSGIWebTests(WebTestCase):
648     def get_handlers(self):
649         return [("/flow_control", FlowControlHandler),
650                 ("/empty_flush", EmptyFlushCallbackHandler),
651                 ]
652     def test_flow_control(self):
653         self.assertEqual(self.fetch("/flow_control").body, b"123")
654     def test_empty_flush(self):
655         response = self.fetch("/empty_flush")
656         self.assertEqual(response.body, b"ok")
657 @wsgi_safe
658 class ErrorResponseTest(WebTestCase):
659     def get_handlers(self):
660         class DefaultHandler(RequestHandler):
661             def get(self):
662                 if self.get_argument("status", None):
663                     raise HTTPError(int(self.get_argument("status")))
664                 1 / 0
665         class WriteErrorHandler(RequestHandler):
666             def get(self):
667                 if self.get_argument("status", None):
668                     self.send_error(int(self.get_argument("status")))
669                 else:
670                     1 / 0
671             def write_error(self, status_code, **kwargs):
672                 self.set_header("Content-Type", "text/plain")
673                 if "exc_info" in kwargs:
674                     self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
675                 else:
676                     self.write("Status: %d" % status_code)
677         class FailedWriteErrorHandler(RequestHandler):
678             def get(self):
679                 1 / 0
680             def write_error(self, status_code, **kwargs):
681                 raise Exception("exception in write_error")
682         return [url("/default", DefaultHandler),
683                 url("/write_error", WriteErrorHandler),
684                 url("/failed_write_error", FailedWriteErrorHandler),
685                 ]
686     def test_default(self):
687         with ExpectLog(app_log, "Uncaught exception"):
688             response = self.fetch("/default")
689             self.assertEqual(response.code, 500)
690             self.assertTrue(b"500: Internal Server Error" in response.body)
691             response = self.fetch("/default?status=503")
692             self.assertEqual(response.code, 503)
693             self.assertTrue(b"503: Service Unavailable" in response.body)
694     def test_write_error(self):
695         with ExpectLog(app_log, "Uncaught exception"):
696             response = self.fetch("/write_error")
697             self.assertEqual(response.code, 500)
698             self.assertEqual(b"Exception: ZeroDivisionError", response.body)
699             response = self.fetch("/write_error?status=503")
700             self.assertEqual(response.code, 503)
701             self.assertEqual(b"Status: 503", response.body)
702     def test_failed_write_error(self):
703         with ExpectLog(app_log, "Uncaught exception"):
704             response = self.fetch("/failed_write_error")
705             self.assertEqual(response.code, 500)
706             self.assertEqual(b"", response.body)
707 @wsgi_safe
708 class StaticFileTest(WebTestCase):
709     robots_txt_hash = b"f71d20196d4caf35b6a670db8c70b03d"
710     static_dir = os.path.join(os.path.dirname(__file__), 'static')
711     def get_handlers(self):
712         class StaticUrlHandler(RequestHandler):
713             def get(self, path):
714                 with_v = int(self.get_argument('include_version', 1))
715                 self.write(self.static_url(path, include_version=with_v))
716         class AbsoluteStaticUrlHandler(StaticUrlHandler):
717             include_host = True
718         class OverrideStaticUrlHandler(RequestHandler):
719             def get(self, path):
720                 do_include = bool(self.get_argument("include_host"))
721                 self.include_host = not do_include
722                 regular_url = self.static_url(path)
723                 override_url = self.static_url(path, include_host=do_include)
724                 if override_url == regular_url:
725                     return self.write(str(False))
726                 protocol = self.request.protocol + "://"
727                 protocol_length = len(protocol)
728                 check_regular = regular_url.find(protocol, 0, protocol_length)
729                 check_override = override_url.find(protocol, 0, protocol_length)
730                 if do_include:
731                     result = (check_override == 0 and check_regular == -1)
732                 else:
733                     result = (check_override == -1 and check_regular == 0)
734                 self.write(str(result))
735         return [('/static_url/(.*)', StaticUrlHandler),
736                 ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
737                 ('/override_static_url/(.*)', OverrideStaticUrlHandler),
738                 ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]
739     def get_app_kwargs(self):
740         return dict(static_path=relpath('static'))
741     def test_static_files(self):
742         response = self.fetch('/robots.txt')
743         self.assertTrue(b"Disallow: /" in response.body)
744         response = self.fetch('/static/robots.txt')
745         self.assertTrue(b"Disallow: /" in response.body)
746         self.assertEqual(response.headers.get("Content-Type"), "text/plain")
747     def test_static_compressed_files(self):
748         response = self.fetch("/static/sample.xml.gz")
749         self.assertEqual(response.headers.get("Content-Type"),
750                          "application/gzip")
751         response = self.fetch("/static/sample.xml.bz2")
752         self.assertEqual(response.headers.get("Content-Type"),
753                          "application/octet-stream")
754         response = self.fetch("/static/sample.xml")
755         self.assertTrue(response.headers.get("Content-Type")
756                         in set(("text/xml", "application/xml")))
757     def test_static_url(self):
758         response = self.fetch("/static_url/robots.txt")
759         self.assertEqual(response.body,
760                          b"/static/robots.txt?v=" + self.robots_txt_hash)
761     def test_absolute_static_url(self):
762         response = self.fetch("/abs_static_url/robots.txt")
763         self.assertEqual(response.body, (
764             utf8(self.get_url("/")) +
765             b"static/robots.txt?v=" +
766             self.robots_txt_hash
767         ))
768     def test_relative_version_exclusion(self):
769         response = self.fetch("/static_url/robots.txt?include_version=0")
770         self.assertEqual(response.body, b"/static/robots.txt")
771     def test_absolute_version_exclusion(self):
772         response = self.fetch("/abs_static_url/robots.txt?include_version=0")
773         self.assertEqual(response.body,
774                          utf8(self.get_url("/") + "static/robots.txt"))
775     def test_include_host_override(self):
776         self._trigger_include_host_check(False)
777         self._trigger_include_host_check(True)
778     def _trigger_include_host_check(self, include_host):
779         path = "/override_static_url/robots.txt?include_host=%s"
780         response = self.fetch(path % int(include_host))
781         self.assertEqual(response.body, utf8(str(True)))
782     def get_and_head(self, *args, **kwargs):
783         head_response = self.fetch(*args, method="HEAD", **kwargs)
784         get_response = self.fetch(*args, method="GET", **kwargs)
785         content_headers = set()
786         for h in itertools.chain(head_response.headers, get_response.headers):
787             if h.startswith('Content-'):
788                 content_headers.add(h)
789         for h in content_headers:
790             self.assertEqual(head_response.headers.get(h),
791                              get_response.headers.get(h),
792                              "%s differs between GET (%s) and HEAD (%s)" %
793                              (h, head_response.headers.get(h),
794                               get_response.headers.get(h)))
795         return get_response
796     def test_static_304_if_modified_since(self):
797         response1 = self.get_and_head("/static/robots.txt")
798         response2 = self.get_and_head("/static/robots.txt", headers={
799             'If-Modified-Since': response1.headers['Last-Modified']})
800         self.assertEqual(response2.code, 304)
801         self.assertTrue('Content-Length' not in response2.headers)
802         self.assertTrue('Last-Modified' not in response2.headers)
803     def test_static_304_if_none_match(self):
804         response1 = self.get_and_head("/static/robots.txt")
805         response2 = self.get_and_head("/static/robots.txt", headers={
806             'If-None-Match': response1.headers['Etag']})
807         self.assertEqual(response2.code, 304)
808     def test_static_if_modified_since_pre_epoch(self):
809         response = self.get_and_head("/static/robots.txt", headers={
810             'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
811         self.assertEqual(response.code, 200)
812     def test_static_if_modified_since_time_zone(self):
813         stat = os.stat(relpath('static/robots.txt'))
814         response = self.get_and_head('/static/robots.txt', headers={
815             'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})
816         self.assertEqual(response.code, 200)
817         response = self.get_and_head('/static/robots.txt', headers={
818             'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})
819         self.assertEqual(response.code, 304)
820     def test_static_etag(self):
821         response = self.get_and_head('/static/robots.txt')
822         self.assertEqual(utf8(response.headers.get("Etag")),
823                          b'"' + self.robots_txt_hash + b'"')
824     def test_static_with_range(self):
825         response = self.get_and_head('/static/robots.txt', headers={
826             'Range': 'bytes=0-9'})
827         self.assertEqual(response.code, 206)
828         self.assertEqual(response.body, b"User-agent")
829         self.assertEqual(utf8(response.headers.get("Etag")),
830                          b'"' + self.robots_txt_hash + b'"')
831         self.assertEqual(response.headers.get("Content-Length"), "10")
832         self.assertEqual(response.headers.get("Content-Range"),
833                          "bytes 0-9/26")
834     def test_static_with_range_full_file(self):
835         response = self.get_and_head('/static/robots.txt', headers={
836             'Range': 'bytes=0-'})
837         self.assertEqual(response.code, 200)
838         robots_file_path = os.path.join(self.static_dir, "robots.txt")
839         with open(robots_file_path) as f:
840             self.assertEqual(response.body, utf8(f.read()))
841         self.assertEqual(response.headers.get("Content-Length"), "26")
842         self.assertEqual(response.headers.get("Content-Range"), None)
843     def test_static_with_range_full_past_end(self):
844         response = self.get_and_head('/static/robots.txt', headers={
845             'Range': 'bytes=0-10000000'})
846         self.assertEqual(response.code, 200)
847         robots_file_path = os.path.join(self.static_dir, "robots.txt")
848         with open(robots_file_path) as f:
849             self.assertEqual(response.body, utf8(f.read()))
850         self.assertEqual(response.headers.get("Content-Length"), "26")
851         self.assertEqual(response.headers.get("Content-Range"), None)
852     def test_static_with_range_partial_past_end(self):
853         response = self.get_and_head('/static/robots.txt', headers={
854             'Range': 'bytes=1-10000000'})
855         self.assertEqual(response.code, 206)
856         robots_file_path = os.path.join(self.static_dir, "robots.txt")
857         with open(robots_file_path) as f:
858             self.assertEqual(response.body, utf8(f.read()[1:]))
859         self.assertEqual(response.headers.get("Content-Length"), "25")
860         self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
861     def test_static_with_range_end_edge(self):
862         response = self.get_and_head('/static/robots.txt', headers={
863             'Range': 'bytes=22-'})
864         self.assertEqual(response.body, b": /\n")
865         self.assertEqual(response.headers.get("Content-Length"), "4")
866         self.assertEqual(response.headers.get("Content-Range"),
867                          "bytes 22-25/26")
868     def test_static_with_range_neg_end(self):
869         response = self.get_and_head('/static/robots.txt', headers={
870             'Range': 'bytes=-4'})
871         self.assertEqual(response.body, b": /\n")
872         self.assertEqual(response.headers.get("Content-Length"), "4")
873         self.assertEqual(response.headers.get("Content-Range"),
874                          "bytes 22-25/26")
875     def test_static_invalid_range(self):
876         response = self.get_and_head('/static/robots.txt', headers={
877             'Range': 'asdf'})
878         self.assertEqual(response.code, 200)
879     def test_static_unsatisfiable_range_zero_suffix(self):
880         response = self.get_and_head('/static/robots.txt', headers={
881             'Range': 'bytes=-0'})
882         self.assertEqual(response.headers.get("Content-Range"),
883                          "bytes */26")
884         self.assertEqual(response.code, 416)
885     def test_static_unsatisfiable_range_invalid_start(self):
886         response = self.get_and_head('/static/robots.txt', headers={
887             'Range': 'bytes=26'})
888         self.assertEqual(response.code, 416)
889         self.assertEqual(response.headers.get("Content-Range"),
890                          "bytes */26")
891     def test_static_head(self):
892         response = self.fetch('/static/robots.txt', method='HEAD')
893         self.assertEqual(response.code, 200)
894         self.assertEqual(response.body, b'')
895         self.assertEqual(response.headers['Content-Length'], '26')
896         self.assertEqual(utf8(response.headers['Etag']),
897                          b'"' + self.robots_txt_hash + b'"')
898     def test_static_head_range(self):
899         response = self.fetch('/static/robots.txt', method='HEAD',
900                               headers={'Range': 'bytes=1-4'})
901         self.assertEqual(response.code, 206)
902         self.assertEqual(response.body, b'')
903         self.assertEqual(response.headers['Content-Length'], '4')
904         self.assertEqual(utf8(response.headers['Etag']),
905                          b'"' + self.robots_txt_hash + b'"')
906     def test_static_range_if_none_match(self):
907         response = self.get_and_head('/static/robots.txt', headers={
908             'Range': 'bytes=1-4',
909             'If-None-Match': b'"' + self.robots_txt_hash + b'"'})
910         self.assertEqual(response.code, 304)
911         self.assertEqual(response.body, b'')
912         self.assertTrue('Content-Length' not in response.headers)
913         self.assertEqual(utf8(response.headers['Etag']),
914                          b'"' + self.robots_txt_hash + b'"')
915     def test_static_404(self):
916         response = self.get_and_head('/static/blarg')
917         self.assertEqual(response.code, 404)
918     def test_path_traversal_protection(self):
919         self.http_client.close()
920         self.http_client = SimpleAsyncHTTPClient()
921         with ExpectLog(gen_log, ".*not in root static directory"):
922             response = self.get_and_head('/static/../static_foo.txt')
923         self.assertEqual(response.code, 403)
924     @unittest.skipIf(os.name != 'posix', 'non-posix OS')
925     def test_root_static_path(self):
926         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
927                             'static/robots.txt')
928         response = self.get_and_head('/root_static' + urllib_parse.quote(path))
929         self.assertEqual(response.code, 200)
930 @wsgi_safe
931 class StaticDefaultFilenameTest(WebTestCase):
932     def get_app_kwargs(self):
933         return dict(static_path=relpath('static'),
934                     static_handler_args=dict(default_filename='index.html'))
935     def get_handlers(self):
936         return []
937     def test_static_default_filename(self):
938         response = self.fetch('/static/dir/', follow_redirects=False)
939         self.assertEqual(response.code, 200)
940         self.assertEqual(b'this is the index\n', response.body)
941     def test_static_default_redirect(self):
942         response = self.fetch('/static/dir', follow_redirects=False)
943         self.assertEqual(response.code, 301)
944         self.assertTrue(response.headers['Location'].endswith('/static/dir/'))
945 @wsgi_safe
946 class StaticFileWithPathTest(WebTestCase):
947     def get_app_kwargs(self):
948         return dict(static_path=relpath('static'),
949                     static_handler_args=dict(default_filename='index.html'))
950     def get_handlers(self):
951         return [("/foo/(.*)", StaticFileHandler, {
952             "path": relpath("templates/"),
953         })]
954     def test_serve(self):
955         response = self.fetch("/foo/utf8.html")
956         self.assertEqual(response.body, b"H\xc3\xa9llo\n")
957 @wsgi_safe
958 class CustomStaticFileTest(WebTestCase):
959     def get_handlers(self):
960         class MyStaticFileHandler(StaticFileHandler):
961             @classmethod
962             def make_static_url(cls, settings, path):
963                 version_hash = cls.get_version(settings, path)
964                 extension_index = path.rindex('.')
965                 before_version = path[:extension_index]
966                 after_version = path[(extension_index + 1):]
967                 return '/static/%s.%s.%s' % (before_version, version_hash,
968                                              after_version)
969             def parse_url_path(self, url_path):
970                 extension_index = url_path.rindex('.')
971                 version_index = url_path.rindex('.', 0, extension_index)
972                 return '%s%s' % (url_path[:version_index],
973                                  url_path[extension_index:])
974             @classmethod
975             def get_absolute_path(cls, settings, path):
976                 return 'CustomStaticFileTest:' + path
977             def validate_absolute_path(self, root, absolute_path):
978                 return absolute_path
979             @classmethod
980             def get_content(self, path, start=None, end=None):
981                 assert start is None and end is None
982                 if path == 'CustomStaticFileTest:foo.txt':
983                     return b'bar'
984                 raise Exception("unexpected path %r" % path)
985             def get_content_size(self):
986                 if self.absolute_path == 'CustomStaticFileTest:foo.txt':
987                     return 3
988                 raise Exception("unexpected path %r" % self.absolute_path)
989             def get_modified_time(self):
990                 return None
991             @classmethod
992             def get_version(cls, settings, path):
993                 return "42"
994         class StaticUrlHandler(RequestHandler):
995             def get(self, path):
996                 self.write(self.static_url(path))
997         self.static_handler_class = MyStaticFileHandler
998         return [("/static_url/(.*)", StaticUrlHandler)]
999     def get_app_kwargs(self):
1000         return dict(static_path="dummy",
1001                     static_handler_class=self.static_handler_class)
1002     def test_serve(self):
1003         response = self.fetch("/static/foo.42.txt")
1004         self.assertEqual(response.body, b"bar")
1005     def test_static_url(self):
1006         with ExpectLog(gen_log, "Could not open static file", required=False):
1007             response = self.fetch("/static_url/foo.txt")
1008             self.assertEqual(response.body, b"/static/foo.42.txt")
1009 @wsgi_safe
1010 class HostMatchingTest(WebTestCase):
1011     class Handler(RequestHandler):
1012         def initialize(self, reply):
1013             self.reply = reply
1014         def get(self):
1015             self.write(self.reply)
1016     def get_handlers(self):
1017         return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
1018     def test_host_matching(self):
1019         self.app.add_handlers("www.example.com",
1020                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1021         self.app.add_handlers(r"www\.example\.com",
1022                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1023         self.app.add_handlers("www.example.com",
1024                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1025         self.app.add_handlers("www.e.*e.com",
1026                               [("/baz", HostMatchingTest.Handler, {"reply": "[3]"})])
1027         response = self.fetch("/foo")
1028         self.assertEqual(response.body, b"wildcard")
1029         response = self.fetch("/bar")
1030         self.assertEqual(response.code, 404)
1031         response = self.fetch("/baz")
1032         self.assertEqual(response.code, 404)
1033         response = self.fetch("/foo", headers={'Host': 'www.example.com'})
1034         self.assertEqual(response.body, b"[0]")
1035         response = self.fetch("/bar", headers={'Host': 'www.example.com'})
1036         self.assertEqual(response.body, b"[1]")
1037         response = self.fetch("/baz", headers={'Host': 'www.example.com'})
1038         self.assertEqual(response.body, b"[2]")
1039         response = self.fetch("/baz", headers={'Host': 'www.exe.com'})
1040         self.assertEqual(response.body, b"[3]")
1041 @wsgi_safe
1042 class DefaultHostMatchingTest(WebTestCase):
1043     def get_handlers(self):
1044         return []
1045     def get_app_kwargs(self):
1046         return {'default_host': "www.example.com"}
1047     def test_default_host_matching(self):
1048         self.app.add_handlers("www.example.com",
1049                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1050         self.app.add_handlers(r"www\.example\.com",
1051                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1052         self.app.add_handlers("www.test.com",
1053                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1054         response = self.fetch("/foo")
1055         self.assertEqual(response.body, b"[0]")
1056         response = self.fetch("/bar")
1057         self.assertEqual(response.body, b"[1]")
1058         response = self.fetch("/baz")
1059         self.assertEqual(response.code, 404)
1060         response = self.fetch("/foo", headers={"X-Real-Ip": "127.0.0.1"})
1061         self.assertEqual(response.code, 404)
1062         self.app.default_host = "www.test.com"
1063         response = self.fetch("/baz")
1064         self.assertEqual(response.body, b"[2]")
1065 @wsgi_safe
1066 class NamedURLSpecGroupsTest(WebTestCase):
1067     def get_handlers(self):
1068         class EchoHandler(RequestHandler):
1069             def get(self, path):
1070                 self.write(path)
1071         return [("/str/(?P&lt;path&gt;.*)", EchoHandler),
1072                 (u"/unicode/(?P&lt;path&gt;.*)", EchoHandler)]
1073     def test_named_urlspec_groups(self):
1074         response = self.fetch("/str/foo")
1075         self.assertEqual(response.body, b"foo")
1076         response = self.fetch("/unicode/bar")
1077         self.assertEqual(response.body, b"bar")
1078 @wsgi_safe
1079 class ClearHeaderTest(SimpleHandlerTestCase):
1080     class Handler(RequestHandler):
1081         def get(self):
1082             self.set_header("h1", "foo")
1083             self.set_header("h2", "bar")
1084             self.clear_header("h1")
1085             self.clear_header("nonexistent")
1086     def test_clear_header(self):
1087         response = self.fetch("/")
1088         self.assertTrue("h1" not in response.headers)
1089         self.assertEqual(response.headers["h2"], "bar")
1090 class Header204Test(SimpleHandlerTestCase):
1091     class Handler(RequestHandler):
1092         def get(self):
1093             self.set_status(204)
1094             self.finish()
1095     def test_204_headers(self):
1096         response = self.fetch('/')
1097         self.assertEqual(response.code, 204)
1098         self.assertNotIn("Content-Length", response.headers)
1099         self.assertNotIn("Transfer-Encoding", response.headers)
1100 @wsgi_safe
1101 class Header304Test(SimpleHandlerTestCase):
1102     class Handler(RequestHandler):
1103         def get(self):
1104             self.set_header("Content-Language", "en_US")
1105             self.write("hello")
1106     def test_304_headers(self):
1107         response1 = self.fetch('/')
1108         self.assertEqual(response1.headers["Content-Length"], "5")
1109         self.assertEqual(response1.headers["Content-Language"], "en_US")
1110         response2 = self.fetch('/', headers={
1111             'If-None-Match': response1.headers["Etag"]})
1112         self.assertEqual(response2.code, 304)
1113         self.assertTrue("Content-Length" not in response2.headers)
1114         self.assertTrue("Content-Language" not in response2.headers)
1115         self.assertTrue("Transfer-Encoding" not in response2.headers)
1116 @wsgi_safe
1117 class StatusReasonTest(SimpleHandlerTestCase):
1118     class Handler(RequestHandler):
1119         def get(self):
1120             reason = self.request.arguments.get('reason', [])
1121             self.set_status(int(self.get_argument('code')),
1122                             reason=reason[0] if reason else None)
1123     def get_http_client(self):
1124         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1125     def test_status(self):
1126         response = self.fetch("/?code=304")
1127         self.assertEqual(response.code, 304)
1128         self.assertEqual(response.reason, "Not Modified")
1129         response = self.fetch("/?code=304&amp;reason=Foo")
1130         self.assertEqual(response.code, 304)
1131         self.assertEqual(response.reason, "Foo")
1132         response = self.fetch("/?code=682&amp;reason=Bar")
1133         self.assertEqual(response.code, 682)
1134         self.assertEqual(response.reason, "Bar")
1135         with ExpectLog(app_log, 'Uncaught exception'):
1136             response = self.fetch("/?code=682")
1137         self.assertEqual(response.code, 500)
1138 @wsgi_safe
1139 class DateHeaderTest(SimpleHandlerTestCase):
1140     class Handler(RequestHandler):
1141         def get(self):
1142             self.write("hello")
1143     def test_date_header(self):
1144         response = self.fetch('/')
1145         header_date = datetime.datetime(
1146             *email.utils.parsedate(response.headers['Date'])[:6])
1147         self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
1148                         datetime.timedelta(seconds=2))
1149 @wsgi_safe
1150 class RaiseWithReasonTest(SimpleHandlerTestCase):
1151     class Handler(RequestHandler):
1152         def get(self):
1153             raise HTTPError(682, reason="Foo")
1154     def get_http_client(self):
1155         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1156     def test_raise_with_reason(self):
1157         response = self.fetch("/")
1158         self.assertEqual(response.code, 682)
1159         self.assertEqual(response.reason, "Foo")
1160         self.assertIn(b'682: Foo', response.body)
1161     def test_httperror_str(self):
1162         self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
1163     def test_httperror_str_from_httputil(self):
1164         self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
1165 @wsgi_safe
1166 class ErrorHandlerXSRFTest(WebTestCase):
1167     def get_handlers(self):
1168         return [('/error', ErrorHandler, dict(status_code=417))]
1169     def get_app_kwargs(self):
1170         return dict(xsrf_cookies=True)
1171     def test_error_xsrf(self):
1172         response = self.fetch('/error', method='POST', body='')
1173         self.assertEqual(response.code, 417)
1174     def test_404_xsrf(self):
1175         response = self.fetch('/404', method='POST', body='')
1176         self.assertEqual(response.code, 404)
1177 @wsgi_safe
1178 class GzipTestCase(SimpleHandlerTestCase):
1179     class Handler(RequestHandler):
1180         def get(self):
1181             for v in self.get_arguments('vary'):
1182                 self.add_header('Vary', v)
1183             self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))
1184     def get_app_kwargs(self):
1185         return dict(
1186             gzip=True,
1187             static_path=os.path.join(os.path.dirname(__file__), 'static'))
1188     def assert_compressed(self, response):
1189         self.assertEqual(
1190             response.headers.get(
1191                 'Content-Encoding',
1192                 response.headers.get('X-Consumed-Content-Encoding')),
1193             'gzip')
1194     def test_gzip(self):
1195         response = self.fetch('/')
1196         self.assert_compressed(response)
1197         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1198     def test_gzip_static(self):
1199         response = self.fetch('/robots.txt')
1200         self.assert_compressed(response)
1201         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1202     def test_gzip_not_requested(self):
1203         response = self.fetch('/', use_gzip=False)
1204         self.assertNotIn('Content-Encoding', response.headers)
1205         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1206     def test_vary_already_present(self):
1207         response = self.fetch('/?vary=Accept-Language')
1208         self.assert_compressed(response)
1209         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1210                          ['Accept-Language', 'Accept-Encoding'])
1211     def test_vary_already_present_multiple(self):
1212         response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
1213         self.assert_compressed(response)
1214         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1215                          ['Accept-Language', 'Cookie', 'Accept-Encoding'])
1216 @wsgi_safe
1217 class PathArgsInPrepareTest(WebTestCase):
1218     class Handler(RequestHandler):
1219         def prepare(self):
1220             self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
1221         def get(self, path):
1222             assert path == 'foo'
1223             self.finish()
1224     def get_handlers(self):
1225         return [('/pos/(.*)', self.Handler),
1226                 ('/kw/(?P&lt;path&gt;.*)', self.Handler)]
1227     def test_pos(self):
1228         response = self.fetch('/pos/foo')
1229         response.rethrow()
1230         data = json_decode(response.body)
1231         self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})
1232     def test_kw(self):
1233         response = self.fetch('/kw/foo')
1234         response.rethrow()
1235         data = json_decode(response.body)
1236         self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})
1237 @wsgi_safe
1238 class ClearAllCookiesTest(SimpleHandlerTestCase):
1239     class Handler(RequestHandler):
1240         def get(self):
1241             self.clear_all_cookies()
1242             self.write('ok')
1243     def test_clear_all_cookies(self):
1244         set_cookies = sorted(response.headers.get_list('Set-Cookie'))
1245         self.assertTrue(set_cookies<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0].startswith('baz=;') or
1246                         set_cookies[0].startswith('baz="";'))
1247         self.assertTrue(set_cookies[1].startswith('foo=;') or
1248                         set_cookies[</b></font>1].startswith('foo="";'))
1249 class PermissionError(Exception):
1250     pass
1251 @wsgi_safe
1252 class ExceptionHandlerTest(SimpleHandlerTestCase):
1253     class Handler(RequestHandler):
1254         def get(self):
1255             exc = self.get_argument('exc')
1256             if exc == 'http':
1257                 raise HTTPError(410, "no longer here")
1258             elif exc == 'zero':
1259                 1 / 0
1260             elif exc == 'permission':
1261                 raise PermissionError('not allowed')
1262         def write_error(self, status_code, **kwargs):
1263             if 'exc_info' in kwargs:
1264                 typ, value, tb = kwargs['exc_info']
1265                 if isinstance(value, PermissionError):
1266                     self.set_status(403)
1267                     self.write('PermissionError')
1268                     return
1269             RequestHandler.write_error(self, status_code, **kwargs)
1270         def log_exception(self, typ, value, tb):
1271             if isinstance(value, PermissionError):
1272                 app_log.warning('custom logging for PermissionError: %s',
1273                                 value.args[0])
1274             else:
1275                 RequestHandler.log_exception(self, typ, value, tb)
1276     def test_http_error(self):
1277         with ExpectLog(gen_log, '.*no longer here'):
1278             response = self.fetch('/?exc=http')
1279             self.assertEqual(response.code, 410)
1280     def test_unknown_error(self):
1281         with ExpectLog(app_log, 'Uncaught exception'):
1282             response = self.fetch('/?exc=zero')
1283             self.assertEqual(response.code, 500)
1284     def test_known_error(self):
1285         with ExpectLog(app_log,
1286                        'custom logging for PermissionError: not allowed'):
1287             response = self.fetch('/?exc=permission')
1288             self.assertEqual(response.code, 403)
1289 @wsgi_safe
1290 class BuggyLoggingTest(SimpleHandlerTestCase):
1291     class Handler(RequestHandler):
1292         def get(self):
1293             1 / 0
1294         def log_exception(self, typ, value, tb):
1295             1 / 0
1296     def test_buggy_log_exception(self):
1297         with ExpectLog(app_log, '.*'):
1298             self.fetch('/')
1299 @wsgi_safe
1300 class UIMethodUIModuleTest(SimpleHandlerTestCase):
1301     class Handler(RequestHandler):
1302         def get(self):
1303             self.render('foo.html')
1304         def value(self):
1305             return self.get_argument("value")
1306     def get_app_kwargs(self):
1307         def my_ui_method(handler, x):
1308             return "In my_ui_method(%s) with handler value %s." % (
1309                 x, handler.value())
1310         class MyModule(UIModule):
1311             def render(self, x):
1312                 return "In MyModule(%s) with handler value %s." % (
1313                     x, self.handler.value())
1314         loader = DictLoader({
1315             'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
1316         })
1317         return dict(template_loader=loader,
1318                     ui_methods={'my_ui_method': my_ui_method},
1319                     ui_modules={'MyModule': MyModule})
1320     def tearDown(self):
1321         super(UIMethodUIModuleTest, self).tearDown()
1322         RequestHandler._template_loaders.clear()
1323     def test_ui_method(self):
1324         response = self.fetch('/?value=asdf')
1325         self.assertEqual(response.body,
1326                          b'In my_ui_method(42) with handler value asdf. '
1327                          b'In MyModule(123) with handler value asdf.')
1328 @wsgi_safe
1329 class GetArgumentErrorTest(SimpleHandlerTestCase):
1330     class Handler(RequestHandler):
1331         def get(self):
1332             try:
1333                 self.get_argument('foo')
1334                 self.write({})
1335             except MissingArgumentError as e:
1336                 self.write({'arg_name': e.arg_name,
1337                             'log_message': e.log_message})
1338     def test_catch_error(self):
1339         response = self.fetch('/')
1340         self.assertEqual(json_decode(response.body),
1341                          {'arg_name': 'foo',
1342                           'log_message': 'Missing argument foo'})
1343 class MultipleExceptionTest(SimpleHandlerTestCase):
1344     class Handler(RequestHandler):
1345         exc_count = 0
1346         @asynchronous
1347         def get(self):
1348             from salt.ext.tornado.ioloop import IOLoop
1349             IOLoop.current().add_callback(lambda: 1 / 0)
1350             IOLoop.current().add_callback(lambda: 1 / 0)
1351         def log_exception(self, typ, value, tb):
1352             MultipleExceptionTest.Handler.exc_count += 1
1353     def test_multi_exception(self):
1354         response = self.fetch('/')
1355         self.assertEqual(response.code, 500)
1356         response = self.fetch('/')
1357         self.assertEqual(response.code, 500)
1358         self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)
1359 @wsgi_safe
1360 class SetLazyPropertiesTest(SimpleHandlerTestCase):
1361     class Handler(RequestHandler):
1362         def prepare(self):
1363             self.current_user = 'Ben'
1364             self.locale = locale.get('en_US')
1365         def get_user_locale(self):
1366             raise NotImplementedError()
1367         def get_current_user(self):
1368             raise NotImplementedError()
1369         def get(self):
1370             self.write('Hello %s (%s)' % (self.current_user, self.locale.code))
1371     def test_set_properties(self):
1372         response = self.fetch('/')
1373         self.assertEqual(response.body, b'Hello Ben (en_US)')
1374 @wsgi_safe
1375 class GetCurrentUserTest(WebTestCase):
1376     def get_app_kwargs(self):
1377         class WithoutUserModule(UIModule):
1378             def render(self):
1379                 return ''
1380         class WithUserModule(UIModule):
1381             def render(self):
1382                 return str(self.current_user)
1383         loader = DictLoader({
1384             'without_user.html': '',
1385             'with_user.html': '{{ current_user }}',
1386             'without_user_module.html': '{% module WithoutUserModule() %}',
1387             'with_user_module.html': '{% module WithUserModule() %}',
1388         })
1389         return dict(template_loader=loader,
1390                     ui_modules={'WithUserModule': WithUserModule,
1391                                 'WithoutUserModule': WithoutUserModule})
1392     def tearDown(self):
1393         super(GetCurrentUserTest, self).tearDown()
1394         RequestHandler._template_loaders.clear()
1395     def get_handlers(self):
1396         class CurrentUserHandler(RequestHandler):
1397             def prepare(self):
1398                 self.has_loaded_current_user = False
1399             def get_current_user(self):
1400                 self.has_loaded_current_user = True
1401                 return ''
1402         class WithoutUserHandler(CurrentUserHandler):
1403             def get(self):
1404                 self.render_string('without_user.html')
1405                 self.finish(str(self.has_loaded_current_user))
1406         class WithUserHandler(CurrentUserHandler):
1407             def get(self):
1408                 self.render_string('with_user.html')
1409                 self.finish(str(self.has_loaded_current_user))
1410         class CurrentUserModuleHandler(CurrentUserHandler):
1411             def get_template_namespace(self):
1412                 return self.ui
1413         class WithoutUserModuleHandler(CurrentUserModuleHandler):
1414             def get(self):
1415                 self.render_string('without_user_module.html')
1416                 self.finish(str(self.has_loaded_current_user))
1417         class WithUserModuleHandler(CurrentUserModuleHandler):
1418             def get(self):
1419                 self.render_string('with_user_module.html')
1420                 self.finish(str(self.has_loaded_current_user))
1421         return [('/without_user', WithoutUserHandler),
1422                 ('/with_user', WithUserHandler),
1423                 ('/without_user_module', WithoutUserModuleHandler),
1424                 ('/with_user_module', WithUserModuleHandler)]
1425     @unittest.skip('needs fix')
1426     def test_get_current_user_is_lazy(self):
1427         response = self.fetch('/without_user')
1428         self.assertEqual(response.body, b'False')
1429     def test_get_current_user_works(self):
1430         response = self.fetch('/with_user')
1431         self.assertEqual(response.body, b'True')
1432     def test_get_current_user_from_ui_module_is_lazy(self):
1433         response = self.fetch('/without_user_module')
1434         self.assertEqual(response.body, b'False')
1435     def test_get_current_user_from_ui_module_works(self):
1436         response = self.fetch('/with_user_module')
1437         self.assertEqual(response.body, b'True')
1438 @wsgi_safe
1439 class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
1440     class Handler(RequestHandler):
1441         pass
1442     def test_unimplemented_standard_methods(self):
1443         for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
1444             response = self.fetch('/', method=method)
1445             self.assertEqual(response.code, 405)
1446         for method in ['POST', 'PUT']:
1447             response = self.fetch('/', method=method, body=b'')
1448             self.assertEqual(response.code, 405)
1449 class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
1450     class Handler(RequestHandler):
1451         def other(self):
1452             self.write('other')
1453     def test_unimplemented_patch(self):
1454         response = self.fetch('/', method='PATCH', body=b'')
1455         self.assertEqual(response.code, 405)
1456     def test_unimplemented_other(self):
1457         response = self.fetch('/', method='OTHER',
1458                               allow_nonstandard_methods=True)
1459         self.assertEqual(response.code, 405)
1460 @wsgi_safe
1461 class AllHTTPMethodsTest(SimpleHandlerTestCase):
1462     class Handler(RequestHandler):
1463         def method(self):
1464             self.write(self.request.method)
1465         get = delete = options = post = put = method
1466     def test_standard_methods(self):
1467         response = self.fetch('/', method='HEAD')
1468         self.assertEqual(response.body, b'')
1469         for method in ['GET', 'DELETE', 'OPTIONS']:
1470             response = self.fetch('/', method=method)
1471             self.assertEqual(response.body, utf8(method))
1472         for method in ['POST', 'PUT']:
1473             response = self.fetch('/', method=method, body=b'')
1474             self.assertEqual(response.body, utf8(method))
1475 class PatchMethodTest(SimpleHandlerTestCase):
1476     class Handler(RequestHandler):
1477         SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
1478         def patch(self):
1479             self.write('patch')
1480         def other(self):
1481             self.write('other')
1482     def test_patch(self):
1483         response = self.fetch('/', method='PATCH', body=b'')
1484         self.assertEqual(response.body, b'patch')
1485     def test_other(self):
1486         response = self.fetch('/', method='OTHER',
1487                               allow_nonstandard_methods=True)
1488         self.assertEqual(response.body, b'other')
1489 @wsgi_safe
1490 class FinishInPrepareTest(SimpleHandlerTestCase):
1491     class Handler(RequestHandler):
1492         def prepare(self):
1493             self.finish('done')
1494         def get(self):
1495             raise Exception('should not reach this method')
1496     def test_finish_in_prepare(self):
1497         response = self.fetch('/')
1498         self.assertEqual(response.body, b'done')
1499 @wsgi_safe
1500 class Default404Test(WebTestCase):
1501     def get_handlers(self):
1502         return [('/foo', RequestHandler)]
1503     def test_404(self):
1504         response = self.fetch('/')
1505         self.assertEqual(response.code, 404)
1506         self.assertEqual(response.body,
1507                          b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
1508                          b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')
1509 @wsgi_safe
1510 class Custom404Test(WebTestCase):
1511     def get_handlers(self):
1512         return [('/foo', RequestHandler)]
1513     def get_app_kwargs(self):
1514         class Custom404Handler(RequestHandler):
1515             def get(self):
1516                 self.set_status(404)
1517                 self.write('custom 404 response')
1518         return dict(default_handler_class=Custom404Handler)
1519     def test_404(self):
1520         response = self.fetch('/')
1521         self.assertEqual(response.code, 404)
1522         self.assertEqual(response.body, b'custom 404 response')
1523 @wsgi_safe
1524 class DefaultHandlerArgumentsTest(WebTestCase):
1525     def get_handlers(self):
1526         return [('/foo', RequestHandler)]
1527     def get_app_kwargs(self):
1528         return dict(default_handler_class=ErrorHandler,
1529                     default_handler_args=dict(status_code=403))
1530     def test_403(self):
1531         response = self.fetch('/')
1532         self.assertEqual(response.code, 403)
1533 @wsgi_safe
1534 class HandlerByNameTest(WebTestCase):
1535     def get_handlers(self):
1536         return [('/hello1', HelloHandler),
1537                 ('/hello2', 'tornado.test.web_test.HelloHandler'),
1538                 url('/hello3', 'tornado.test.web_test.HelloHandler'),
1539                 ]
1540     def test_handler_by_name(self):
1541         resp = self.fetch('/hello1')
1542         self.assertEqual(resp.body, b'hello')
1543         resp = self.fetch('/hello2')
1544         self.assertEqual(resp.body, b'hello')
1545         resp = self.fetch('/hello3')
1546         self.assertEqual(resp.body, b'hello')
1547 class StreamingRequestBodyTest(WebTestCase):
1548     def get_handlers(self):
1549         @stream_request_body
1550         class StreamingBodyHandler(RequestHandler):
1551             def initialize(self, test):
1552                 self.test = test
1553             def prepare(self):
1554                 self.test.prepared.set_result(None)
1555             def data_received(self, data):
1556                 self.test.data.set_result(data)
1557             def get(self):
1558                 self.test.finished.set_result(None)
1559                 self.write({})
1560         @stream_request_body
1561         class EarlyReturnHandler(RequestHandler):
1562             def prepare(self):
1563                 raise HTTPError(401)
1564         @stream_request_body
1565         class CloseDetectionHandler(RequestHandler):
1566             def initialize(self, test):
1567                 self.test = test
1568             def on_connection_close(self):
1569                 super(CloseDetectionHandler, self).on_connection_close()
1570                 self.test.close_future.set_result(None)
1571         return [('/stream_body', StreamingBodyHandler, dict(test=self)),
1572                 ('/early_return', EarlyReturnHandler),
1573                 ('/close_detection', CloseDetectionHandler, dict(test=self))]
1574     def connect(self, url, connection_close):
1575         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
1576         s.connect(("127.0.0.1", self.get_http_port()))
1577         stream = IOStream(s, io_loop=self.io_loop)
1578         stream.write(b"GET " + url + b" HTTP/1.1\r\n")
1579         if connection_close:
1580             stream.write(b"Connection: close\r\n")
1581         stream.write(b"Transfer-Encoding: chunked\r\n\r\n")
1582         return stream
1583     @gen_test
1584     def test_streaming_body(self):
1585         self.prepared = Future()
1586         self.data = Future()
1587         self.finished = Future()
1588         stream = self.connect(b"/stream_body", connection_close=True)
1589         yield self.prepared
1590         stream.write(b"4\r\nasdf\r\n")
1591         data = yield self.data
1592         self.assertEqual(data, b"asdf")
1593         self.data = Future()
1594         stream.write(b"4\r\nqwer\r\n")
1595         data = yield self.data
1596         self.assertEquals(data, b"qwer")
1597         stream.write(b"0\r\n\r\n")
1598         yield self.finished
1599         data = yield gen.Task(stream.read_until_close)
1600         self.assertTrue(data.endswith(b"{}"))
1601         stream.close()
1602     @gen_test
1603     def test_early_return(self):
1604         stream = self.connect(b"/early_return", connection_close=False)
1605         data = yield gen.Task(stream.read_until_close)
1606         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1607     @gen_test
1608     def test_early_return_with_data(self):
1609         stream = self.connect(b"/early_return", connection_close=False)
1610         stream.write(b"4\r\nasdf\r\n")
1611         data = yield gen.Task(stream.read_until_close)
1612         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1613     @gen_test
1614     def test_close_during_upload(self):
1615         self.close_future = Future()
1616         stream = self.connect(b"/close_detection", connection_close=False)
1617         stream.close()
1618         yield self.close_future
1619 @stream_request_body
1620 class BaseFlowControlHandler(RequestHandler):
1621     def initialize(self, test):
1622         self.test = test
1623         self.method = None
1624         self.methods = []
1625     @contextlib.contextmanager
1626     def in_method(self, method):
1627         if self.method is not None:
1628             self.test.fail("entered method %s while in %s" %
1629                            (method, self.method))
1630         self.method = method
1631         self.methods.append(method)
1632         try:
1633             yield
1634         finally:
1635             self.method = None
1636     @gen.coroutine
1637     def prepare(self):
1638         self.methods.append('prepare')
1639         yield gen.Task(IOLoop.current().add_callback)
1640     @gen.coroutine
1641     def post(self):
1642         with self.in_method('post'):
1643             yield gen.Task(IOLoop.current().add_callback)
1644         self.write(dict(methods=self.methods))
1645 class BaseStreamingRequestFlowControlTest(object):
1646     def get_httpserver_options(self):
1647         return dict(chunk_size=10, decompress_request=True)
1648     def get_http_client(self):
1649         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1650     def test_flow_control_fixed_body(self):
1651         response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
1652                               method='POST')
1653         response.rethrow()
1654         self.assertEqual(json_decode(response.body),
1655                          dict(methods=['prepare', 'data_received',
1656                                        'data_received', 'data_received',
1657                                        'post']))
1658     def test_flow_control_chunked_body(self):
1659         chunks = [b'abcd', b'efgh', b'ijkl']
1660         @gen.coroutine
1661         def body_producer(write):
1662             for i in chunks:
1663                 yield write(i)
1664         response = self.fetch('/', body_producer=body_producer, method='POST')
1665         response.rethrow()
1666         self.assertEqual(json_decode(response.body),
1667                          dict(methods=['prepare', 'data_received',
1668                                        'data_received', 'data_received',
1669                                        'post']))
1670     def test_flow_control_compressed_body(self):
1671         bytesio = BytesIO()
1672         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
1673         gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
1674         gzip_file.close()
1675         compressed_body = bytesio.getvalue()
1676         response = self.fetch('/', body=compressed_body, method='POST',
1677                               headers={'Content-Encoding': 'gzip'})
1678         response.rethrow()
1679         self.assertEqual(json_decode(response.body),
1680                          dict(methods=['prepare', 'data_received',
1681                                        'data_received', 'data_received',
1682                                        'post']))
1683 class DecoratedStreamingRequestFlowControlTest(
1684         BaseStreamingRequestFlowControlTest,
1685         WebTestCase):
1686     def get_handlers(self):
1687         class DecoratedFlowControlHandler(BaseFlowControlHandler):
1688             @gen.coroutine
1689             def data_received(self, data):
1690                 with self.in_method('data_received'):
1691                     yield gen.Task(IOLoop.current().add_callback)
1692         return [('/', DecoratedFlowControlHandler, dict(test=self))]
1693 @skipBefore35
1694 class NativeStreamingRequestFlowControlTest(
1695         BaseStreamingRequestFlowControlTest,
1696         WebTestCase):
1697     def get_handlers(self):
1698         class NativeFlowControlHandler(BaseFlowControlHandler):
1699             data_received = exec_test(globals(), locals(), """
1700             async def data_received(self, data):
1701                 with self.in_method('data_received'):
1702                     await gen.Task(IOLoop.current().add_callback)
1703             """)["data_received"]
1704             response <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch(u)
1705             self.assertEqual(response.code, 401)
1706             self.assertEqual('Basic realm="something"',
1707                              response.headers.get('WWW-Authenticate'))
1708             self.assertEqual(b'authentication required', response.</b></font>body)
1709 @wsgi_safe
1710 class DecoratorTest(WebTestCase):
1711     def get_handlers(self):
1712         class RemoveSlashHandler(RequestHandler):
1713             @removeslash
1714             def get(self):
1715                 pass
1716         class AddSlashHandler(RequestHandler):
1717             @addslash
1718             def get(self):
1719                 pass
1720         return [("/removeslash/", RemoveSlashHandler),
1721                 ("/addslash", AddSlashHandler),
1722                 ]
1723     def test_removeslash(self):
1724         response = self.fetch("/removeslash/", follow_redirects=False)
1725         self.assertEqual(response.code, 301)
1726         self.assertEqual(response.headers['Location'], "/removeslash")
1727         response = self.fetch("/removeslash/?foo=bar", follow_redirects=False)
1728         self.assertEqual(response.code, 301)
1729         self.assertEqual(response.headers['Location'], "/removeslash?foo=bar")
1730     def test_addslash(self):
1731         response = self.fetch("/addslash", follow_redirects=False)
1732         self.assertEqual(response.code, 301)
1733         self.assertEqual(response.headers['Location'], "/addslash/")
1734         response = self.fetch("/addslash?foo=bar", follow_redirects=False)
1735         self.assertEqual(response.code, 301)
1736         self.assertEqual(response.headers['Location'], "/addslash/?foo=bar")
1737 @wsgi_safe
1738 class CacheTest(WebTestCase):
1739     def get_handlers(self):
1740         class EtagHandler(RequestHandler):
1741             def get(self, computed_etag):
1742                 self.write(computed_etag)
1743             def compute_etag(self):
1744                 return self._write_buffer[0]
1745         return [
1746             ('/etag/(.*)', EtagHandler)
1747         ]
1748     def test_wildcard_etag(self):
1749         computed_etag = '"xyzzy"'
1750         etags = '*'
1751         self._test_etag(computed_etag, etags, 304)
1752     def test_strong_etag_match(self):
1753         computed_etag = '"xyzzy"'
1754         etags = '"xyzzy"'
1755         self._test_etag(computed_etag, etags, 304)
1756     def test_multiple_strong_etag_match(self):
1757         computed_etag = '"xyzzy1"'
1758         etags = '"xyzzy1", "xyzzy2"'
1759         self._test_etag(computed_etag, etags, 304)
1760     def test_strong_etag_not_match(self):
1761         computed_etag = '"xyzzy"'
1762         etags = '"xyzzy1"'
1763         self._test_etag(computed_etag, etags, 200)
1764     def test_multiple_strong_etag_not_match(self):
1765         computed_etag = '"xyzzy"'
1766         etags = '"xyzzy1", "xyzzy2"'
1767         self._test_etag(computed_etag, etags, 200)
1768     def test_weak_etag_match(self):
1769         computed_etag = '"xyzzy1"'
1770         etags = 'W/"xyzzy1"'
1771         self._test_etag(computed_etag, etags, 304)
1772     def test_multiple_weak_etag_match(self):
1773         computed_etag = '"xyzzy2"'
1774         etags = 'W/"xyzzy1", W/"xyzzy2"'
1775         self._test_etag(computed_etag, etags, 304)
1776     def test_weak_etag_not_match(self):
1777         computed_etag = '"xyzzy2"'
1778         etags = 'W/"xyzzy1"'
1779         self._test_etag(computed_etag, etags, 200)
1780     def test_multiple_weak_etag_not_match(self):
1781         computed_etag = '"xyzzy3"'
1782         etags = 'W/"xyzzy1", W/"xyzzy2"'
1783         self._test_etag(computed_etag, etags, 200)
1784     def _test_etag(self, computed_etag, etags, status_code):
1785         response = self.fetch(
1786             '/etag/' + computed_etag,
1787             headers={'If-None-Match': etags}
1788         )
1789         self.assertEqual(response.code, status_code)
1790 @wsgi_safe
1791 class RequestSummaryTest(SimpleHandlerTestCase):
1792     class Handler(RequestHandler):
1793         def get(self):
1794             self.request.remote_ip = None
1795             self.finish(self._request_summary())
1796     def test_missing_remote_ip(self):
1797         resp = self.fetch("/")
1798         self.assertEqual(resp.body, b"GET / (None)")
1799 class HTTPErrorTest(unittest.TestCase):
1800     def test_copy(self):
1801         e = HTTPError(403, reason="Go away")
1802         e2 = copy.copy(e)
1803         self.assertIsNot(e, e2)
1804         self.assertEqual(e.status_code, e2.status_code)
1805         self.assertEqual(e.reason, e2.reason)
1806 class ApplicationTest(AsyncTestCase):
1807     def test_listen(self):
1808         app = Application([])
1809         server = app.listen(0, address='127.0.0.1')
1810         server.stop()
1811 class URLSpecReverseTest(unittest.TestCase):
1812     def test_reverse(self):
1813         self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
1814         self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())
1815     def test_non_reversible(self):
1816         paths = [
1817             r'^/api/v\d+/foo/(\w+)$',
1818         ]
1819         for path in paths:
1820             url_spec = url(path, None)
1821             try:
1822                 result = url_spec.reverse()
1823                 self.fail("did not get expected exception when reversing %s. "
1824                           "result: %s" % (path, result))
1825             except ValueError:
1826                 pass
1827     def test_reverse_arguments(self):
1828         self.assertEqual('/api/v1/foo/bar',
1829                          url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))
1830 class RedirectHandlerTest(WebTestCase):
1831     def get_handlers(self):
1832         return [
1833             ('/src', WebRedirectHandler, {'url': '/dst'}),
1834             (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]
1835     def test_basic_redirect(self):
1836         response = self.fetch('/src', follow_redirects=False)
1837         self.assertEqual(response.code, 301)
1838         self.assertEqual(response.headers['Location'], '/dst')
1839     def test_redirect_pattern(self):
1840         response = self.fetch('/a/b/c', follow_redirects=False)
1841         self.assertEqual(response.code, 301)
1842         self.assertEqual(response.headers['Location'], '/b/a/c')
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kiwiproc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import platform
3 import socket
4 from xml.dom import minidom
5 import salt.utils.files
6 from salt.modules.inspectlib.exceptions import InspectorKiwiProcessorException
7 try:
8     import grp
9     import pwd
10 except ImportError:
11     pass
12 try:
13     from lxml import etree
14 except ImportError:
15     import xml.etree.ElementTree as etree
16 class KiwiExporter:
17     """
18     Exports system description as Kiwi configuration.
19     """
20     def __init__(self, grains, format):
21         self.__grains__ = grains
22         self.format = format
23         self._data = type("data", (), {})
24         self.name = None
25     def load(self, **descr):
26         """
27         Load data by keys.
28         :param data:
29         :return:
30         """
31         for obj, data in descr.items():
32             setattr(self._data, obj, data)
33         return self
34     def export(self, name):
35         """
36         Export to the Kiwi config.xml as text.
37         :return:
38         """
39         self.name = name
40         root = self._create_doc()
41         self._set_description(root)
42         self._set_preferences(root)
43         self._set_repositories(root)
44         self._set_users(root)
45         self._set_packages(root)
46             [
47                 line
48                 for line in minidom<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.parseString(etree.tostring(root, encoding="UTF-8"))
49                 .toprettyxml(indent="  ")
50                 .split("\n")
51                 if line.strip(</b></font>)
52             ]
53         )
54     def _get_package_manager(self):
55         """
56         Get package manager.
57         :return:
58         """
59         ret = None
60         if self.__grains__.get("os_family") in ("Kali", "Debian"):
61             ret = "apt-get"
62         elif self.__grains__.get("os_family", "") == "Suse":
63             ret = "zypper"
64         elif self.__grains__.get("os_family", "") == "redhat":
65             ret = "yum"
66         if ret is None:
67             raise InspectorKiwiProcessorException(
68                 "Unsupported platform: {}".format(self.__grains__.get("os_family"))
69             )
70         return ret
71     def _set_preferences(self, node):
72         """
73         Set preferences.
74         :return:
75         """
76         pref = etree.SubElement(node, "preferences")
77         pacman = etree.SubElement(pref, "packagemanager")
78         pacman.text = self._get_package_manager()
79         p_version = etree.SubElement(pref, "version")
80         p_version.text = "0.0.1"
81         p_type = etree.SubElement(pref, "type")
82         p_type.set("image", "vmx")
83         for disk_id, disk_data in self._data.system.get("disks", {}).items():
84             if disk_id.startswith("/dev"):
85                 break
86         p_type<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.set("installiso", "true")
87         p_type.set("boot", "vmxboot/suse-leap42.1")
88         p_type.set("format", self.format)
89         p_type.set("bootloader", "grub2")
90         p_type.set("timezone", __salt__["timezone.get_zone"]())
91         p_type.set("hwclock", __salt__["timezone.get_hwclock"](</b></font>))
92         return pref
93     def _get_user_groups(self, user):
94         """
95         Get user groups.
96         :param user:
97         :return:
98         """
99         return [g.gr_name for g in grp.getgrall() if user in g.gr_mem] + [
100             grp.getgrgid(pwd.getpwnam(user).pw_gid).gr_name
101         ]
102     def _set_users(self, node):
103         """
104         Create existing local users.
105         &lt;users group="root"&gt;
106           &lt;user password="$1$wYJUgpM5$RXMMeASDc035eX.NbYWFl0" home="/root" name="root"/&gt;
107         &lt;/users&gt;
108         :param node:
109         :return:
110         """
111         shadow = {}
112         with salt.utils.files.fopen("/etc/shadow") as rfh:
113             for sh_line in rfh.read().split(os.linesep):
114                 if sh_line.strip():
115                     login, pwd = sh_line.split(":")[:2]
116                     if pwd and pwd[0] not in "!*":
117                         shadow[login] = {"p": pwd}
118         with salt.utils.files.fopen("/etc/passwd") as rfh:
119             for ps_line in rfh.read().split(os.linesep):
120                 if ps_line.strip():
121                     ps_line = ps_line.strip().split(":")
122                     if ps_line[0] in shadow:
123                         shadow[ps_line[0]]["h"] = ps_line[5]
124                         shadow[ps_line[0]]["s"] = ps_line[6]
125                         shadow[ps_line[0]]["g"] = self._get_user_groups(ps_line[0])
126         users_node = etree.SubElement(node, "users")
127         for u_name, u_data in shadow.items():
128             user_node <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(users_node, "user")
129             user_node.set("password", u_data["p"])
130             user_node.set("home", u_data["h"])
131             user_node.set("name", u_name)
132             users_groups.extend(u_data[</b></font>"g"])
133         users_node.set("group", ",".join(users_groups))
134         return users_node
135     def _set_repositories(self, node):
136         """
137         Create repositories.
138         :param node:
139         :return:
140         """
141         priority = 99
142         for repo_id, repo_data in self._data.software.get("repositories", {}).items():
143             if type(repo_data) == list:
144                 repo_data = repo_data[0]
145             if repo_data.get("enabled") or not repo_data.get(
146                 "disabled"
147             ):  # RPM and Debian, respectively
148                 uri = repo_data.get("baseurl", repo_data.get("uri"))
149                     continue
150                 repo = etree.SubElement(node, "repository")
151                 if self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__grains__.get("os_family") in ("Kali", "Debian"):
152                     repo.set("alias", repo_id)
153                     repo.set("distribution", repo_data["dist"])
154                 else:
155                     repo.set("alias", repo_data[</b></font>"alias"])
156                     if self.__grains__.get("os_family", "") == "Suse":
157                         repo.set("type", "yast2")  # TODO: Check for options!
158                     repo.set("priority", str(priority))
159                 source = etree.SubElement(repo, "source")
160                 source.set("path", uri)  # RPM and Debian, respectively
161                 priority -= 1
162     def _set_packages(self, node):
163         """
164         Set packages and collections.
165         :param node:
166         :return:
167         """
168         pkgs = etree.SubElement(node, "packages")
169         for pkg_name, pkg_version in sorted(
170             self._data.software.get("packages", {}).items()
171         ):
172             pkg = etree.SubElement(pkgs, "package")
173             pkg.set("name", pkg_name)
174         if self.__grains__.get("os_family", "") == "Suse":
175             for ptn_id, ptn_data in self._data.software.get("patterns", {}).items():
176                 if ptn_data.get("installed"):
177                     ptn = etree.SubElement(pkgs, "namedCollection")
178                     ptn.set("name", ptn_id)
179         return pkgs
180     def _set_description(self, node):
181         """
182         Create a system description.
183         :return:
184         hostname = socket.getfqdn() or platform.node()
185         descr <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(node, "description")
186         author = etree.SubElement(descr, "author")
187         author.text = "salt.modules.node on {}".format(hostname)
188         contact = etree.SubElement(descr, "contact")
189         contact.text = "root@{}".format(hostname)
190         specs = etree.SubElement(descr, "specification")
191         specs.</b></font>text = "Rebuild of {}, based on Salt inspection.".format(hostname)
192         return descr
193     def _create_doc(self):
194         """
195         Create document.
196         :return:
197         """
198         root = etree.Element("image")
199         root.set("schemaversion", "6.3")
200         root.set("name", self.name)
201         return root
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
