<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for web_test.py &amp; kiwiproc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for web_test.py &amp; kiwiproc.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>web_test.py (1.4430285%)<th>kiwiproc.py (18.509615%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(781-786)<td><a href="#" name="0">(248-254)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(481-488)<td><a href="#" name="1">(125-130)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2707-2711)<td><a href="#" name="2">(177-181)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1647-1650)<td><a href="#" name="3">(205-209)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(111-115)<td><a href="#" name="4">(78-81)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.concurrent import Future
3 from salt.ext.tornado import gen
4 from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
5 from salt.ext.tornado.httputil import format_timestamp
6 from salt.ext.tornado.ioloop import IOLoop
7 from salt.ext.tornado.iostream import IOStream
8 from salt.ext.tornado import locale
9 from salt.ext.tornado.log import app_log, gen_log
10 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
11 from salt.ext.tornado.template import DictLoader
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
14 from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
15 from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding
16 import binascii
17 import contextlib
18 import copy
19 import datetime
20 import email.utils
21 import gzip
22 from io import BytesIO
23 import itertools
24 import logging
25 import os
26 import re
27 import socket
28 if PY3:
29     import urllib.parse as urllib_parse  # py3
30 else:
31     import urllib as urllib_parse  # py2
32 wsgi_safe_tests = []
33 def relpath(*a):
34     return os.path.join(os.path.dirname(__file__), *a)
35 def wsgi_safe(cls):
36     wsgi_safe_tests.append(cls)
37     return cls
38 class WebTestCase(AsyncHTTPTestCase):
39     def get_app(self):
40         self.app = Application(self.get_handlers(), **self.get_app_kwargs())
41         return self.app
42     def get_handlers(self):
43         raise NotImplementedError()
44     def get_app_kwargs(self):
45         return {}
46 class SimpleHandlerTestCase(WebTestCase):
47     def get_handlers(self):
48         return [('/', self.Handler)]
49 class HelloHandler(RequestHandler):
50     def get(self):
51         self.write('hello')
52 class CookieTestRequestHandler(RequestHandler):
53     def __init__(self, cookie_secret='0123456789', key_version=None):
54         self._cookies = {}
55         if key_version is None:
56             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
57         else:
58             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
59                                                         key_version=key_version))
60     def get_cookie(self, name):
61         return self._cookies.get(name)
62     def set_cookie(self, name, value, expires_days=None):
63         self._cookies[name] = value
64 class SecureCookieV1Test(unittest.TestCase):
65     def test_round_trip(self):
66         handler = CookieTestRequestHandler()
67         handler.set_secure_cookie('foo', b'bar', version=1)
68         self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
69                          b'bar')
70     def test_cookie_tampering_future_timestamp(self):
71         handler = CookieTestRequestHandler()
72 <a name="4"></a>        handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),
73                                   version=1)
74         cookie = handler._cookies['foo']
75         match = re<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
76         self.assertTrue(match)
77         timestamp = match.group(1)
78         sig = match.group(2)
79         self.assertEqual(</b></font>
80             _create_signature_v1(handler.application.settings["cookie_secret"],
81                                  'foo', '12345678', timestamp),
82             sig)
83         self.assertEqual(
84             _create_signature_v1(handler.application.settings["cookie_secret"],
85                                  'foo', '1234', b'5678' + timestamp),
86             sig)
87         handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
88             to_basestring(timestamp), to_basestring(sig)))
89         with ExpectLog(gen_log, "Cookie timestamp in future"):
90             self.assertTrue(
91                 handler.get_secure_cookie('foo', min_version=1) is None)
92     def test_arbitrary_bytes(self):
93         handler = CookieTestRequestHandler()
94         handler.set_secure_cookie('foo', b'\xe9', version=1)
95         self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')
96 class SecureCookieV2Test(unittest.TestCase):
97     KEY_VERSIONS = {
98         0: 'ajklasdf0ojaisdf',
99         1: 'aslkjasaolwkjsdf'
100     }
101     def test_round_trip(self):
102         handler = CookieTestRequestHandler()
103         handler.set_secure_cookie('foo', b'bar', version=2)
104         self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')
105     def test_key_version_roundtrip(self):
106         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
107                                            key_version=0)
108         handler.set_secure_cookie('foo', b'bar')
109         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
110     def test_key_version_roundtrip_differing_version(self):
111         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
112                                            key_version=1)
113         handler.set_secure_cookie('foo', b'bar')
114         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
115     def test_key_version_increment_version(self):
116         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
117                                            key_version=0)
118         handler.set_secure_cookie('foo', b'bar')
119         new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
120                                                key_version=1)
121         new_handler._cookies = handler._cookies
122         self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')
123     def test_key_version_invalidate_version(self):
124         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
125                                            key_version=0)
126         handler.set_secure_cookie('foo', b'bar')
127         new_key_versions = self.KEY_VERSIONS.copy()
128         new_key_versions.pop(0)
129         new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
130                                                key_version=1)
131         new_handler._cookies = handler._cookies
132         self.assertEqual(new_handler.get_secure_cookie('foo'), None)
133 class CookieTest(WebTestCase):
134     def get_handlers(self):
135         class SetCookieHandler(RequestHandler):
136             def get(self):
137                 self.set_cookie("str", "asdf")
138                 self.set_cookie("unicode", u"qwer")
139                 self.set_cookie("bytes", b"zxcv")
140         class GetCookieHandler(RequestHandler):
141             def get(self):
142                 self.write(self.get_cookie("foo", "default"))
143         class SetCookieDomainHandler(RequestHandler):
144             def get(self):
145                 self.set_cookie("unicode_args", "blah", domain=u"foo.com",
146                                 path=u"/foo")
147         class SetCookieSpecialCharHandler(RequestHandler):
148             def get(self):
149                 self.set_cookie("equals", "a=b")
150                 self.set_cookie("semicolon", "a;b")
151                 self.set_cookie("quote", 'a"b')
152         class SetCookieOverwriteHandler(RequestHandler):
153             def get(self):
154                 self.set_cookie("a", "b", domain="example.com")
155                 self.set_cookie("c", "d", domain="example.com")
156                 self.set_cookie("a", "e")
157         class SetCookieMaxAgeHandler(RequestHandler):
158             def get(self):
159                 self.set_cookie("foo", "bar", max_age=10)
160         class SetCookieExpiresDaysHandler(RequestHandler):
161             def get(self):
162                 self.set_cookie("foo", "bar", expires_days=10)
163         class SetCookieFalsyFlags(RequestHandler):
164             def get(self):
165                 self.set_cookie("a", "1", secure=True)
166                 self.set_cookie("b", "1", secure=False)
167                 self.set_cookie("c", "1", httponly=True)
168                 self.set_cookie("d", "1", httponly=False)
169         return [("/set", SetCookieHandler),
170                 ("/get", GetCookieHandler),
171                 ("/set_domain", SetCookieDomainHandler),
172                 ("/special_char", SetCookieSpecialCharHandler),
173                 ("/set_overwrite", SetCookieOverwriteHandler),
174                 ("/set_max_age", SetCookieMaxAgeHandler),
175                 ("/set_expires_days", SetCookieExpiresDaysHandler),
176                 ("/set_falsy_flags", SetCookieFalsyFlags)
177                 ]
178     def test_set_cookie(self):
179         response = self.fetch("/set")
180         self.assertEqual(sorted(response.headers.get_list("Set-Cookie")),
181                          ["bytes=zxcv; Path=/",
182                           "str=asdf; Path=/",
183                           "unicode=qwer; Path=/",
184                           ])
185     def test_get_cookie(self):
186         response = self.fetch("/get", headers={"Cookie": "foo=bar"})
187         self.assertEqual(response.body, b"bar")
188         response = self.fetch("/get", headers={"Cookie": 'foo="bar"'})
189         self.assertEqual(response.body, b"bar")
190         response = self.fetch("/get", headers={"Cookie": "/=exception;"})
191         self.assertEqual(response.body, b"default")
192     def test_set_cookie_domain(self):
193         response = self.fetch("/set_domain")
194         self.assertEqual(response.headers.get_list("Set-Cookie"),
195                          ["unicode_args=blah; Domain=foo.com; Path=/foo"])
196     def test_cookie_special_char(self):
197         response = self.fetch("/special_char")
198         headers = sorted(response.headers.get_list("Set-Cookie"))
199         self.assertEqual(len(headers), 3)
200         self.assertEqual(headers[0], 'equals="a=b"; Path=/')
201         self.assertEqual(headers[1], 'quote="a\\"b"; Path=/')
202         self.assertTrue(headers[2] in ('semicolon="a;b"; Path=/',
203                                        'semicolon="a\\073b"; Path=/'),
204                         headers[2])
205         data = [('foo=a=b', 'a=b'),
206                 ('foo="a=b"', 'a=b'),
207                 ('foo="a;b"', '"a'),  # even quoted, ";" is a delimiter
208                 ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
209                 ('foo="a\\073b"', 'a;b'),
210                 ('foo="a\\"b"', 'a"b'),
211                 ]
212         for header, expected in data:
213             logging.debug("trying %r", header)
214             response = self.fetch("/get", headers={"Cookie": header})
215             self.assertEqual(response.body, utf8(expected))
216     def test_set_cookie_overwrite(self):
217         response = self.fetch("/set_overwrite")
218         headers = response.headers.get_list("Set-Cookie")
219         self.assertEqual(sorted(headers),
220                          ["a=e; Path=/", "c=d; Domain=example.com; Path=/"])
221     def test_set_cookie_max_age(self):
222         response = self.fetch("/set_max_age")
223         headers = response.headers.get_list("Set-Cookie")
224         self.assertEqual(sorted(headers),
225                          ["foo=bar; Max-Age=10; Path=/"])
226     def test_set_cookie_expires_days(self):
227         response = self.fetch("/set_expires_days")
228         header = response.headers.get("Set-Cookie")
229         match = re.match("foo=bar; expires=(?P&lt;expires&gt;.+); Path=/", header)
230         self.assertIsNotNone(match)
231         expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
232         header_expires = datetime.datetime(
233             *email.utils.parsedate(match.groupdict()["expires"])[:6])
234         self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)
235     def test_set_cookie_false_flags(self):
236         response = self.fetch("/set_falsy_flags")
237         headers = sorted(response.headers.get_list("Set-Cookie"))
238         self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
239         self.assertEqual(headers[1].lower(), 'b=1; path=/')
240         self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
241         self.assertEqual(headers[3].lower(), 'd=1; path=/')
242 class AuthRedirectRequestHandler(RequestHandler):
243     def initialize(self, login_url):
244         self.login_url = login_url
245     def get_login_url(self):
246         return self.login_url
247     @authenticated
248     def get(self):
249         self.send_error(500)
250 class AuthRedirectTest(WebTestCase):
251     def get_handlers(self):
252         return [('/relative', AuthRedirectRequestHandler,
253                  dict(login_url='/login')),
254                 ('/absolute', AuthRedirectRequestHandler,
255                  dict(login_url='http://example.com/login'))]
256     def test_relative_auth_redirect(self):
257         self.http_client.fetch(self.get_url('/relative'), self.stop,
258                                follow_redirects=False)
259         response = self.wait()
260         self.assertEqual(response.code, 302)
261         self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')
262     def test_absolute_auth_redirect(self):
263         self.http_client.fetch(self.get_url('/absolute'), self.stop,
264                                follow_redirects=False)
265         response = self.wait()
266         self.assertEqual(response.code, 302)
267         self.assertTrue(re.match(
268             'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
269             response.headers['Location']), response.headers['Location'])
270 class ConnectionCloseHandler(RequestHandler):
271     def initialize(self, test):
272         self.test = test
273     @asynchronous
274     def get(self):
275         self.test.on_handler_waiting()
276     def on_connection_close(self):
277         self.test.on_connection_close()
278 class ConnectionCloseTest(WebTestCase):
279     def get_handlers(self):
280         return [('/', ConnectionCloseHandler, dict(test=self))]
281     def test_connection_close(self):
282         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
283         s.connect(("127.0.0.1", self.get_http_port()))
284         self.stream = IOStream(s, io_loop=self.io_loop)
285         self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
286         self.wait()
287     def on_handler_waiting(self):
288         logging.debug('handler waiting')
289         self.stream.close()
290     def on_connection_close(self):
291         logging.debug('connection closed')
292         self.stop()
293 class EchoHandler(RequestHandler):
294     def get(self, *path_args):
295         for key in self.request.arguments:
296             if type(key) != str:
297                 raise Exception("incorrect type for key: %r" % type(key))
298             for value in self.request.arguments[key]:
299                 if type(value) != bytes:
300                     raise Exception("incorrect type for value: %r" %
301                                     type(value))
302             for value in self.get_arguments(key):
303                 if type(value) != unicode_type:
304                     raise Exception("incorrect type for value: %r" %
305                                     type(value))
306         for arg in path_args:
307             if type(arg) != unicode_type:
308                 raise Exception("incorrect type for path arg: %r" % type(arg))
309         self.write(dict(path=self.request.path,
310                         path_args=path_args,
311                         args=recursive_unicode(self.request.arguments)))
312 class RequestEncodingTest(WebTestCase):
313     def get_handlers(self):
314         return [("/group/(.*)", EchoHandler),
315                 ("/slashes/([^/]*)/([^/]*)", EchoHandler),
316                 ]
317     def fetch_json(self, path):
318         return json_decode(self.fetch(path).body)
319     def test_group_question_mark(self):
320         self.assertEqual(self.fetch_json('/group/%3F'),
321                          dict(path='/group/%3F', path_args=['?'], args={}))
322         self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
323                          dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))
324     def test_group_encoding(self):
325         self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
326                          {u"path": u"/group/%C3%A9",
327                           u"path_args": [u"\u00e9"],
328                           u"args": {u"arg": [u"\u00e9"]}})
329     def test_slashes(self):
330         self.assertEqual(self.fetch_json('/slashes/foo/bar'),
331                          dict(path="/slashes/foo/bar",
332                               path_args=["foo", "bar"],
333                               args={}))
334         self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
335                          dict(path="/slashes/a%2Fb/c%2Fd",
336                               path_args=["a/b", "c/d"],
337                               args={}))
338     def test_error(self):
339         with ExpectLog(gen_log, ".*Invalid unicode"):
340             self.fetch("/group/?arg=%25%e9")
341 class TypeCheckHandler(RequestHandler):
342     def prepare(self):
343         self.errors = {}
344         self.check_type('status', self.get_status(), int)
345         self.check_type('argument', self.get_argument('foo'), unicode_type)
346         self.check_type('cookie_key', list(self.cookies.keys())[0], str)
347         self.check_type('cookie_value', list(self.cookies.values())[0].value, str)
348         if list(self.cookies.keys()) != ['asdf']:
349 <a name="1"></a>            raise Exception("unexpected values for cookie keys: %r" %
350                             self.cookies.keys())
351         self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
352         self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.check_type('get_cookie', self.get_cookie('asdf'), str)
353         self.check_type('xsrf_token', self.xsrf_token, bytes)
354         self.check_type('xsrf_form_html', self.xsrf_form_html(), str)
355         self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)
356         self.check_type(</b></font>'request_summary', self._request_summary(), str)
357     def get(self, path_component):
358         self.check_type('path_component', path_component, unicode_type)
359         self.write(self.errors)
360     def post(self, path_component):
361         self.check_type('path_component', path_component, unicode_type)
362         self.write(self.errors)
363     def check_type(self, name, obj, expected_type):
364         actual_type = type(obj)
365         if expected_type != actual_type:
366             self.errors[name] = "expected %s, got %s" % (expected_type,
367                                                          actual_type)
368 class DecodeArgHandler(RequestHandler):
369     def decode_argument(self, value, name=None):
370         if type(value) != bytes:
371             raise Exception("unexpected type for value: %r" % type(value))
372         if 'encoding' in self.request.arguments:
373             return value.decode(to_unicode(self.request.arguments['encoding'][0]))
374         else:
375             return value
376     def get(self, arg):
377         def describe(s):
378             if type(s) == bytes:
379                 return ["bytes", native_str(binascii.b2a_hex(s))]
380             elif type(s) == unicode_type:
381                 return ["unicode", s]
382             raise Exception("unknown type")
383         self.write({'path': describe(arg),
384                     'query': describe(self.get_argument("foo")),
385                     })
386 class LinkifyHandler(RequestHandler):
387     def get(self):
388         self.render("linkify.html", message="http://example.com")
389 class UIModuleResourceHandler(RequestHandler):
390     def get(self):
391         self.render("page.html", entries=[1, 2])
392 class OptionalPathHandler(RequestHandler):
393     def get(self, path):
394         self.write({"path": path})
395 class FlowControlHandler(RequestHandler):
396     @asynchronous
397     def get(self):
398         self.write("1")
399         self.flush(callback=self.step2)
400     def step2(self):
401         self.write("2")
402         self.flush(callback=self.step3)
403     def step3(self):
404         self.write("3")
405         self.finish()
406 class MultiHeaderHandler(RequestHandler):
407     def get(self):
408         self.set_header("x-overwrite", "1")
409         self.set_header("X-Overwrite", 2)
410         self.add_header("x-multi", 3)
411         self.add_header("X-Multi", "4")
412 class RedirectHandler(RequestHandler):
413     def get(self):
414         if self.get_argument('permanent', None) is not None:
415             self.redirect('/', permanent=int(self.get_argument('permanent')))
416         elif self.get_argument('status', None) is not None:
417             self.redirect('/', status=int(self.get_argument('status')))
418         else:
419             raise Exception("didn't get permanent or status arguments")
420 class EmptyFlushCallbackHandler(RequestHandler):
421     @asynchronous
422     @gen.engine
423     def get(self):
424         yield gen.Task(self.flush)  # "empty" flush, but writes headers
425         yield gen.Task(self.flush)  # empty flush
426         self.write("o")
427         yield self.flush()  # flushes the "o"
428         yield self.flush()  # empty flush
429         self.finish("k")
430 class HeaderInjectionHandler(RequestHandler):
431     def get(self):
432         try:
433             self.set_header("X-Foo", "foo\r\nX-Bar: baz")
434             raise Exception("Didn't get expected exception")
435         except ValueError as e:
436             if "Unsafe header value" in str(e):
437                 self.finish(b"ok")
438             else:
439                 raise
440 class GetArgumentHandler(RequestHandler):
441     def prepare(self):
442         if self.get_argument('source', None) == 'query':
443             method = self.get_query_argument
444         elif self.get_argument('source', None) == 'body':
445             method = self.get_body_argument
446         else:
447             method = self.get_argument
448         self.finish(method("foo", "default"))
449 class GetArgumentsHandler(RequestHandler):
450     def prepare(self):
451         self.finish(dict(default=self.get_arguments("foo"),
452                          query=self.get_query_arguments("foo"),
453                          body=self.get_body_arguments("foo")))
454 @wsgi_safe
455 class WSGISafeWebTest(WebTestCase):
456     COOKIE_SECRET = "WebTest.COOKIE_SECRET"
457     def get_app_kwargs(self):
458         loader = DictLoader({
459             "linkify.html": "{% module linkify(message) %}",
460             "page.html": """\
461 &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
462 {% for e in entries %}
463 {% module Template("entry.html", entry=e) %}
464 {% end %}
465 &lt;/body&gt;&lt;/html&gt;""",
466             "entry.html": """\
467 {{ set_resources(embedded_css=".entry { margin-bottom: 1em; }", embedded_javascript="js_embed()", css_files=["/base.css", "/foo.css"], javascript_files="/common.js", html_head="&lt;meta&gt;", html_body='&lt;script src="/analytics.js"/&gt;') }}
468 &lt;div class="entry"&gt;...&lt;/div&gt;""",
469         })
470         return dict(template_loader=loader,
471                     autoescape="xhtml_escape",
472                     cookie_secret=self.COOKIE_SECRET)
473     def tearDown(self):
474         super(WSGISafeWebTest, self).tearDown()
475         RequestHandler._template_loaders.clear()
476     def get_handlers(self):
477         urls = [
478             url("/typecheck/(.*)", TypeCheckHandler, name='typecheck'),
479             url("/decode_arg/(.*)", DecodeArgHandler, name='decode_arg'),
480             url("/decode_arg_kw/(?P&lt;arg&gt;.*)", DecodeArgHandler),
481             url("/linkify", LinkifyHandler),
482             url("/uimodule_resources", UIModuleResourceHandler),
483             url("/optional_path/(.+)?", OptionalPathHandler),
484             url("/multi_header", MultiHeaderHandler),
485             url("/redirect", RedirectHandler),
486             url("/web_redirect_permanent", WebRedirectHandler, {"url": "/web_redirect_newpath"}),
487             url("/web_redirect", WebRedirectHandler, {"url": "/web_redirect_newpath", "permanent": False}),
488             url("//web_redirect_double_slash", WebRedirectHandler, {"url": '/web_redirect_newpath'}),
489             url("/header_injection", HeaderInjectionHandler),
490             url("/get_argument", GetArgumentHandler),
491             url("/get_arguments", GetArgumentsHandler),
492         ]
493         return urls
494     def fetch_json(self, *args, **kwargs):
495         response = self.fetch(*args, **kwargs)
496         response.rethrow()
497         return json_decode(response.body)
498     def test_types(self):
499         cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
500                                                       "asdf", "qwer"))
501         response = self.fetch("/typecheck/asdf?foo=bar",
502                               headers={"Cookie": "asdf=" + cookie_value})
503         data = json_decode(response.body)
504         self.assertEqual(data, {})
505         response = self.fetch("/typecheck/asdf?foo=bar", method="POST",
506                               headers={"Cookie": "asdf=" + cookie_value},
507                               body="foo=bar")
508     def test_decode_argument(self):
509         urls = ["/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8",
510                 "/decode_arg/%E9?foo=%E9&amp;encoding=latin1",
511                 "/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1",
512                 ]
513         for req_url in urls:
514             response = self.fetch(req_url)
515             response.rethrow()
516             data = json_decode(response.body)
517             self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
518                                     u'query': [u'unicode', u'\u00e9'],
519                                     })
520         response = self.fetch("/decode_arg/%C3%A9?foo=%C3%A9")
521         response.rethrow()
522         data = json_decode(response.body)
523         self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
524                                 u'query': [u'bytes', u'c3a9'],
525                                 })
526     def test_decode_argument_invalid_unicode(self):
527         with ExpectLog(gen_log, ".*Invalid unicode.*"):
528             response = self.fetch("/typecheck/invalid%FF")
529             self.assertEqual(response.code, 400)
530             response = self.fetch("/typecheck/invalid?foo=%FF")
531             self.assertEqual(response.code, 400)
532     def test_decode_argument_plus(self):
533         urls = ["/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8",
534                 "/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8"]
535         for req_url in urls:
536             response = self.fetch(req_url)
537             response.rethrow()
538             data = json_decode(response.body)
539             self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
540                                     u'query': [u'unicode', u'1 + 1'],
541                                     })
542     def test_reverse_url(self):
543         self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
544                          '/decode_arg/foo')
545         self.assertEqual(self.app.reverse_url('decode_arg', 42),
546                          '/decode_arg/42')
547         self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
548                          '/decode_arg/%E9')
549         self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
550                          '/decode_arg/%C3%A9')
551         self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
552                          '/decode_arg/1%20%2B%201')
553     def test_uimodule_unescaped(self):
554         response = self.fetch("/linkify")
555         self.assertEqual(response.body,
556                          b"&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;")
557     def test_uimodule_resources(self):
558         response = self.fetch("/uimodule_resources")
559         self.assertEqual(response.body, b"""\
560 &lt;html&gt;&lt;head&gt;&lt;link href="/base.css" type="text/css" rel="stylesheet"/&gt;&lt;link href="/foo.css" type="text/css" rel="stylesheet"/&gt;
561 &lt;style type="text/css"&gt;
562 .entry { margin-bottom: 1em; }
563 &lt;/style&gt;
564 &lt;meta&gt;
565 &lt;/head&gt;&lt;body&gt;
566 &lt;div class="entry"&gt;...&lt;/div&gt;
567 &lt;div class="entry"&gt;...&lt;/div&gt;
568 &lt;script src="/common.js" type="text/javascript"&gt;&lt;/script&gt;
569 &lt;script type="text/javascript"&gt;
570 //&lt;![CDATA[
571 js_embed()
572 //]]&gt;
573 &lt;/script&gt;
574 &lt;script src="/analytics.js"/&gt;
575 &lt;/body&gt;&lt;/html&gt;""")
576     def test_optional_path(self):
577         self.assertEqual(self.fetch_json("/optional_path/foo"),
578                          {u"path": u"foo"})
579         self.assertEqual(self.fetch_json("/optional_path/"),
580                          {u"path": None})
581     def test_multi_header(self):
582         response = self.fetch("/multi_header")
583         self.assertEqual(response.headers["x-overwrite"], "2")
584 <a name="0"></a>        self.assertEqual(response.headers.get_list("x-multi"), ["3", "4"])
585     def test_redirect(self):
586         response <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch("/redirect?permanent=1", follow_redirects=False)
587         self.assertEqual(response.code, 301)
588         response = self.fetch("/redirect?permanent=0", follow_redirects=False)
589         self.assertEqual(response.code, 302)
590         response = self.fetch("/redirect?status=307", follow_redirects=False)
591         self.assertEqual(response.</b></font>code, 307)
592     def test_web_redirect(self):
593         response = self.fetch("/web_redirect_permanent", follow_redirects=False)
594         self.assertEqual(response.code, 301)
595         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
596         response = self.fetch("/web_redirect", follow_redirects=False)
597         self.assertEqual(response.code, 302)
598         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
599     def test_web_redirect_double_slash(self):
600         response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
601         self.assertEqual(response.code, 301)
602         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
603     def test_header_injection(self):
604         response = self.fetch("/header_injection")
605         self.assertEqual(response.body, b"ok")
606     def test_get_argument(self):
607         response = self.fetch("/get_argument?foo=bar")
608         self.assertEqual(response.body, b"bar")
609         response = self.fetch("/get_argument?foo=")
610         self.assertEqual(response.body, b"")
611         response = self.fetch("/get_argument")
612         self.assertEqual(response.body, b"default")
613         body = urllib_parse.urlencode(dict(foo="hello"))
614         response = self.fetch("/get_argument?foo=bar", method="POST", body=body)
615         self.assertEqual(response.body, b"hello")
616         response = self.fetch("/get_arguments?foo=bar",
617                               method="POST", body=body)
618         self.assertEqual(json_decode(response.body),
619                          dict(default=['bar', 'hello'],
620                               query=['bar'],
621                               body=['hello']))
622     def test_get_query_arguments(self):
623         body = urllib_parse.urlencode(dict(foo="hello"))
624         response = self.fetch("/get_argument?source=query&amp;foo=bar",
625                               method="POST", body=body)
626         self.assertEqual(response.body, b"bar")
627         response = self.fetch("/get_argument?source=query&amp;foo=",
628                               method="POST", body=body)
629         self.assertEqual(response.body, b"")
630         response = self.fetch("/get_argument?source=query",
631                               method="POST", body=body)
632         self.assertEqual(response.body, b"default")
633     def test_get_body_arguments(self):
634         body = urllib_parse.urlencode(dict(foo="bar"))
635         response = self.fetch("/get_argument?source=body&amp;foo=hello",
636                               method="POST", body=body)
637         self.assertEqual(response.body, b"bar")
638         body = urllib_parse.urlencode(dict(foo=""))
639         response = self.fetch("/get_argument?source=body&amp;foo=hello",
640                               method="POST", body=body)
641         self.assertEqual(response.body, b"")
642         body = urllib_parse.urlencode(dict())
643         response = self.fetch("/get_argument?source=body&amp;foo=hello",
644                               method="POST", body=body)
645         self.assertEqual(response.body, b"default")
646     def test_no_gzip(self):
647         response = self.fetch('/get_argument')
648         self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
649         self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))
650 class NonWSGIWebTests(WebTestCase):
651     def get_handlers(self):
652         return [("/flow_control", FlowControlHandler),
653                 ("/empty_flush", EmptyFlushCallbackHandler),
654                 ]
655     def test_flow_control(self):
656         self.assertEqual(self.fetch("/flow_control").body, b"123")
657     def test_empty_flush(self):
658         response = self.fetch("/empty_flush")
659         self.assertEqual(response.body, b"ok")
660 @wsgi_safe
661 class ErrorResponseTest(WebTestCase):
662     def get_handlers(self):
663         class DefaultHandler(RequestHandler):
664             def get(self):
665                 if self.get_argument("status", None):
666                     raise HTTPError(int(self.get_argument("status")))
667                 1 / 0
668         class WriteErrorHandler(RequestHandler):
669             def get(self):
670                 if self.get_argument("status", None):
671                     self.send_error(int(self.get_argument("status")))
672                 else:
673                     1 / 0
674             def write_error(self, status_code, **kwargs):
675                 self.set_header("Content-Type", "text/plain")
676                 if "exc_info" in kwargs:
677                     self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
678                 else:
679                     self.write("Status: %d" % status_code)
680         class FailedWriteErrorHandler(RequestHandler):
681             def get(self):
682                 1 / 0
683             def write_error(self, status_code, **kwargs):
684                 raise Exception("exception in write_error")
685         return [url("/default", DefaultHandler),
686                 url("/write_error", WriteErrorHandler),
687                 url("/failed_write_error", FailedWriteErrorHandler),
688                 ]
689     def test_default(self):
690         with ExpectLog(app_log, "Uncaught exception"):
691             response = self.fetch("/default")
692             self.assertEqual(response.code, 500)
693             self.assertTrue(b"500: Internal Server Error" in response.body)
694             response = self.fetch("/default?status=503")
695             self.assertEqual(response.code, 503)
696             self.assertTrue(b"503: Service Unavailable" in response.body)
697     def test_write_error(self):
698         with ExpectLog(app_log, "Uncaught exception"):
699             response = self.fetch("/write_error")
700             self.assertEqual(response.code, 500)
701             self.assertEqual(b"Exception: ZeroDivisionError", response.body)
702             response = self.fetch("/write_error?status=503")
703             self.assertEqual(response.code, 503)
704             self.assertEqual(b"Status: 503", response.body)
705     def test_failed_write_error(self):
706         with ExpectLog(app_log, "Uncaught exception"):
707             response = self.fetch("/failed_write_error")
708             self.assertEqual(response.code, 500)
709             self.assertEqual(b"", response.body)
710 @wsgi_safe
711 class StaticFileTest(WebTestCase):
712     robots_txt_hash = b"f71d20196d4caf35b6a670db8c70b03d"
713     static_dir = os.path.join(os.path.dirname(__file__), 'static')
714     def get_handlers(self):
715         class StaticUrlHandler(RequestHandler):
716             def get(self, path):
717                 with_v = int(self.get_argument('include_version', 1))
718                 self.write(self.static_url(path, include_version=with_v))
719         class AbsoluteStaticUrlHandler(StaticUrlHandler):
720             include_host = True
721         class OverrideStaticUrlHandler(RequestHandler):
722             def get(self, path):
723                 do_include = bool(self.get_argument("include_host"))
724                 self.include_host = not do_include
725                 regular_url = self.static_url(path)
726                 override_url = self.static_url(path, include_host=do_include)
727                 if override_url == regular_url:
728                     return self.write(str(False))
729                 protocol = self.request.protocol + "://"
730                 protocol_length = len(protocol)
731                 check_regular = regular_url.find(protocol, 0, protocol_length)
732                 check_override = override_url.find(protocol, 0, protocol_length)
733                 if do_include:
734                     result = (check_override == 0 and check_regular == -1)
735                 else:
736                     result = (check_override == -1 and check_regular == 0)
737                 self.write(str(result))
738         return [('/static_url/(.*)', StaticUrlHandler),
739                 ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
740                 ('/override_static_url/(.*)', OverrideStaticUrlHandler),
741                 ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]
742     def get_app_kwargs(self):
743         return dict(static_path=relpath('static'))
744     def test_static_files(self):
745         response = self.fetch('/robots.txt')
746         self.assertTrue(b"Disallow: /" in response.body)
747         response = self.fetch('/static/robots.txt')
748         self.assertTrue(b"Disallow: /" in response.body)
749         self.assertEqual(response.headers.get("Content-Type"), "text/plain")
750     def test_static_compressed_files(self):
751         response = self.fetch("/static/sample.xml.gz")
752         self.assertEqual(response.headers.get("Content-Type"),
753                          "application/gzip")
754         response = self.fetch("/static/sample.xml.bz2")
755         self.assertEqual(response.headers.get("Content-Type"),
756                          "application/octet-stream")
757         response = self.fetch("/static/sample.xml")
758         self.assertTrue(response.headers.get("Content-Type")
759                         in set(("text/xml", "application/xml")))
760     def test_static_url(self):
761         response = self.fetch("/static_url/robots.txt")
762         self.assertEqual(response.body,
763                          b"/static/robots.txt?v=" + self.robots_txt_hash)
764     def test_absolute_static_url(self):
765         response = self.fetch("/abs_static_url/robots.txt")
766         self.assertEqual(response.body, (
767             utf8(self.get_url("/")) +
768             b"static/robots.txt?v=" +
769             self.robots_txt_hash
770         ))
771     def test_relative_version_exclusion(self):
772         response = self.fetch("/static_url/robots.txt?include_version=0")
773         self.assertEqual(response.body, b"/static/robots.txt")
774     def test_absolute_version_exclusion(self):
775         response = self.fetch("/abs_static_url/robots.txt?include_version=0")
776         self.assertEqual(response.body,
777                          utf8(self.get_url("/") + "static/robots.txt"))
778     def test_include_host_override(self):
779         self._trigger_include_host_check(False)
780         self._trigger_include_host_check(True)
781     def _trigger_include_host_check(self, include_host):
782         path = "/override_static_url/robots.txt?include_host=%s"
783         response = self.fetch(path % int(include_host))
784         self.assertEqual(response.body, utf8(str(True)))
785     def get_and_head(self, *args, **kwargs):
786         head_response = self.fetch(*args, method="HEAD", **kwargs)
787         get_response = self.fetch(*args, method="GET", **kwargs)
788         content_headers = set()
789         for h in itertools.chain(head_response.headers, get_response.headers):
790             if h.startswith('Content-'):
791                 content_headers.add(h)
792         for h in content_headers:
793             self.assertEqual(head_response.headers.get(h),
794                              get_response.headers.get(h),
795                              "%s differs between GET (%s) and HEAD (%s)" %
796                              (h, head_response.headers.get(h),
797                               get_response.headers.get(h)))
798         return get_response
799     def test_static_304_if_modified_since(self):
800         response1 = self.get_and_head("/static/robots.txt")
801         response2 = self.get_and_head("/static/robots.txt", headers={
802             'If-Modified-Since': response1.headers['Last-Modified']})
803         self.assertEqual(response2.code, 304)
804         self.assertTrue('Content-Length' not in response2.headers)
805         self.assertTrue('Last-Modified' not in response2.headers)
806     def test_static_304_if_none_match(self):
807         response1 = self.get_and_head("/static/robots.txt")
808         response2 = self.get_and_head("/static/robots.txt", headers={
809             'If-None-Match': response1.headers['Etag']})
810         self.assertEqual(response2.code, 304)
811     def test_static_if_modified_since_pre_epoch(self):
812         response = self.get_and_head("/static/robots.txt", headers={
813             'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
814         self.assertEqual(response.code, 200)
815     def test_static_if_modified_since_time_zone(self):
816         stat = os.stat(relpath('static/robots.txt'))
817         response = self.get_and_head('/static/robots.txt', headers={
818             'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})
819         self.assertEqual(response.code, 200)
820         response = self.get_and_head('/static/robots.txt', headers={
821             'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})
822         self.assertEqual(response.code, 304)
823     def test_static_etag(self):
824         response = self.get_and_head('/static/robots.txt')
825         self.assertEqual(utf8(response.headers.get("Etag")),
826                          b'"' + self.robots_txt_hash + b'"')
827     def test_static_with_range(self):
828         response = self.get_and_head('/static/robots.txt', headers={
829             'Range': 'bytes=0-9'})
830         self.assertEqual(response.code, 206)
831         self.assertEqual(response.body, b"User-agent")
832         self.assertEqual(utf8(response.headers.get("Etag")),
833                          b'"' + self.robots_txt_hash + b'"')
834         self.assertEqual(response.headers.get("Content-Length"), "10")
835         self.assertEqual(response.headers.get("Content-Range"),
836                          "bytes 0-9/26")
837     def test_static_with_range_full_file(self):
838         response = self.get_and_head('/static/robots.txt', headers={
839             'Range': 'bytes=0-'})
840         self.assertEqual(response.code, 200)
841         robots_file_path = os.path.join(self.static_dir, "robots.txt")
842         with open(robots_file_path) as f:
843             self.assertEqual(response.body, utf8(f.read()))
844         self.assertEqual(response.headers.get("Content-Length"), "26")
845         self.assertEqual(response.headers.get("Content-Range"), None)
846     def test_static_with_range_full_past_end(self):
847         response = self.get_and_head('/static/robots.txt', headers={
848             'Range': 'bytes=0-10000000'})
849         self.assertEqual(response.code, 200)
850         robots_file_path = os.path.join(self.static_dir, "robots.txt")
851         with open(robots_file_path) as f:
852             self.assertEqual(response.body, utf8(f.read()))
853         self.assertEqual(response.headers.get("Content-Length"), "26")
854         self.assertEqual(response.headers.get("Content-Range"), None)
855     def test_static_with_range_partial_past_end(self):
856         response = self.get_and_head('/static/robots.txt', headers={
857             'Range': 'bytes=1-10000000'})
858         self.assertEqual(response.code, 206)
859         robots_file_path = os.path.join(self.static_dir, "robots.txt")
860         with open(robots_file_path) as f:
861             self.assertEqual(response.body, utf8(f.read()[1:]))
862         self.assertEqual(response.headers.get("Content-Length"), "25")
863         self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
864     def test_static_with_range_end_edge(self):
865         response = self.get_and_head('/static/robots.txt', headers={
866             'Range': 'bytes=22-'})
867         self.assertEqual(response.body, b": /\n")
868         self.assertEqual(response.headers.get("Content-Length"), "4")
869         self.assertEqual(response.headers.get("Content-Range"),
870                          "bytes 22-25/26")
871     def test_static_with_range_neg_end(self):
872         response = self.get_and_head('/static/robots.txt', headers={
873             'Range': 'bytes=-4'})
874         self.assertEqual(response.body, b": /\n")
875         self.assertEqual(response.headers.get("Content-Length"), "4")
876         self.assertEqual(response.headers.get("Content-Range"),
877                          "bytes 22-25/26")
878     def test_static_invalid_range(self):
879         response = self.get_and_head('/static/robots.txt', headers={
880             'Range': 'asdf'})
881         self.assertEqual(response.code, 200)
882     def test_static_unsatisfiable_range_zero_suffix(self):
883         response = self.get_and_head('/static/robots.txt', headers={
884             'Range': 'bytes=-0'})
885         self.assertEqual(response.headers.get("Content-Range"),
886                          "bytes */26")
887         self.assertEqual(response.code, 416)
888     def test_static_unsatisfiable_range_invalid_start(self):
889         response = self.get_and_head('/static/robots.txt', headers={
890             'Range': 'bytes=26'})
891         self.assertEqual(response.code, 416)
892         self.assertEqual(response.headers.get("Content-Range"),
893                          "bytes */26")
894     def test_static_head(self):
895         response = self.fetch('/static/robots.txt', method='HEAD')
896         self.assertEqual(response.code, 200)
897         self.assertEqual(response.body, b'')
898         self.assertEqual(response.headers['Content-Length'], '26')
899         self.assertEqual(utf8(response.headers['Etag']),
900                          b'"' + self.robots_txt_hash + b'"')
901     def test_static_head_range(self):
902         response = self.fetch('/static/robots.txt', method='HEAD',
903                               headers={'Range': 'bytes=1-4'})
904         self.assertEqual(response.code, 206)
905         self.assertEqual(response.body, b'')
906         self.assertEqual(response.headers['Content-Length'], '4')
907         self.assertEqual(utf8(response.headers['Etag']),
908                          b'"' + self.robots_txt_hash + b'"')
909     def test_static_range_if_none_match(self):
910         response = self.get_and_head('/static/robots.txt', headers={
911             'Range': 'bytes=1-4',
912             'If-None-Match': b'"' + self.robots_txt_hash + b'"'})
913         self.assertEqual(response.code, 304)
914         self.assertEqual(response.body, b'')
915         self.assertTrue('Content-Length' not in response.headers)
916         self.assertEqual(utf8(response.headers['Etag']),
917                          b'"' + self.robots_txt_hash + b'"')
918     def test_static_404(self):
919         response = self.get_and_head('/static/blarg')
920         self.assertEqual(response.code, 404)
921     def test_path_traversal_protection(self):
922         self.http_client.close()
923         self.http_client = SimpleAsyncHTTPClient()
924         with ExpectLog(gen_log, ".*not in root static directory"):
925             response = self.get_and_head('/static/../static_foo.txt')
926         self.assertEqual(response.code, 403)
927     @unittest.skipIf(os.name != 'posix', 'non-posix OS')
928     def test_root_static_path(self):
929         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
930                             'static/robots.txt')
931         response = self.get_and_head('/root_static' + urllib_parse.quote(path))
932         self.assertEqual(response.code, 200)
933 @wsgi_safe
934 class StaticDefaultFilenameTest(WebTestCase):
935     def get_app_kwargs(self):
936         return dict(static_path=relpath('static'),
937                     static_handler_args=dict(default_filename='index.html'))
938     def get_handlers(self):
939         return []
940     def test_static_default_filename(self):
941         response = self.fetch('/static/dir/', follow_redirects=False)
942         self.assertEqual(response.code, 200)
943         self.assertEqual(b'this is the index\n', response.body)
944     def test_static_default_redirect(self):
945         response = self.fetch('/static/dir', follow_redirects=False)
946         self.assertEqual(response.code, 301)
947         self.assertTrue(response.headers['Location'].endswith('/static/dir/'))
948 @wsgi_safe
949 class StaticFileWithPathTest(WebTestCase):
950     def get_app_kwargs(self):
951         return dict(static_path=relpath('static'),
952                     static_handler_args=dict(default_filename='index.html'))
953     def get_handlers(self):
954         return [("/foo/(.*)", StaticFileHandler, {
955             "path": relpath("templates/"),
956         })]
957     def test_serve(self):
958         response = self.fetch("/foo/utf8.html")
959         self.assertEqual(response.body, b"H\xc3\xa9llo\n")
960 @wsgi_safe
961 class CustomStaticFileTest(WebTestCase):
962     def get_handlers(self):
963         class MyStaticFileHandler(StaticFileHandler):
964             @classmethod
965             def make_static_url(cls, settings, path):
966                 version_hash = cls.get_version(settings, path)
967                 extension_index = path.rindex('.')
968                 before_version = path[:extension_index]
969                 after_version = path[(extension_index + 1):]
970                 return '/static/%s.%s.%s' % (before_version, version_hash,
971                                              after_version)
972             def parse_url_path(self, url_path):
973                 extension_index = url_path.rindex('.')
974                 version_index = url_path.rindex('.', 0, extension_index)
975                 return '%s%s' % (url_path[:version_index],
976                                  url_path[extension_index:])
977             @classmethod
978             def get_absolute_path(cls, settings, path):
979                 return 'CustomStaticFileTest:' + path
980             def validate_absolute_path(self, root, absolute_path):
981                 return absolute_path
982             @classmethod
983             def get_content(self, path, start=None, end=None):
984                 assert start is None and end is None
985                 if path == 'CustomStaticFileTest:foo.txt':
986                     return b'bar'
987                 raise Exception("unexpected path %r" % path)
988             def get_content_size(self):
989                 if self.absolute_path == 'CustomStaticFileTest:foo.txt':
990                     return 3
991                 raise Exception("unexpected path %r" % self.absolute_path)
992             def get_modified_time(self):
993                 return None
994             @classmethod
995             def get_version(cls, settings, path):
996                 return "42"
997         class StaticUrlHandler(RequestHandler):
998             def get(self, path):
999                 self.write(self.static_url(path))
1000         self.static_handler_class = MyStaticFileHandler
1001         return [("/static_url/(.*)", StaticUrlHandler)]
1002     def get_app_kwargs(self):
1003         return dict(static_path="dummy",
1004                     static_handler_class=self.static_handler_class)
1005     def test_serve(self):
1006         response = self.fetch("/static/foo.42.txt")
1007         self.assertEqual(response.body, b"bar")
1008     def test_static_url(self):
1009         with ExpectLog(gen_log, "Could not open static file", required=False):
1010             response = self.fetch("/static_url/foo.txt")
1011             self.assertEqual(response.body, b"/static/foo.42.txt")
1012 @wsgi_safe
1013 class HostMatchingTest(WebTestCase):
1014     class Handler(RequestHandler):
1015         def initialize(self, reply):
1016             self.reply = reply
1017         def get(self):
1018             self.write(self.reply)
1019     def get_handlers(self):
1020         return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
1021     def test_host_matching(self):
1022         self.app.add_handlers("www.example.com",
1023                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1024         self.app.add_handlers(r"www\.example\.com",
1025                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1026         self.app.add_handlers("www.example.com",
1027                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1028         self.app.add_handlers("www.e.*e.com",
1029                               [("/baz", HostMatchingTest.Handler, {"reply": "[3]"})])
1030         response = self.fetch("/foo")
1031         self.assertEqual(response.body, b"wildcard")
1032         response = self.fetch("/bar")
1033         self.assertEqual(response.code, 404)
1034         response = self.fetch("/baz")
1035         self.assertEqual(response.code, 404)
1036         response = self.fetch("/foo", headers={'Host': 'www.example.com'})
1037         self.assertEqual(response.body, b"[0]")
1038         response = self.fetch("/bar", headers={'Host': 'www.example.com'})
1039         self.assertEqual(response.body, b"[1]")
1040         response = self.fetch("/baz", headers={'Host': 'www.example.com'})
1041         self.assertEqual(response.body, b"[2]")
1042         response = self.fetch("/baz", headers={'Host': 'www.exe.com'})
1043         self.assertEqual(response.body, b"[3]")
1044 @wsgi_safe
1045 class DefaultHostMatchingTest(WebTestCase):
1046     def get_handlers(self):
1047         return []
1048     def get_app_kwargs(self):
1049         return {'default_host': "www.example.com"}
1050     def test_default_host_matching(self):
1051         self.app.add_handlers("www.example.com",
1052                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1053         self.app.add_handlers(r"www\.example\.com",
1054                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1055         self.app.add_handlers("www.test.com",
1056                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1057         response = self.fetch("/foo")
1058         self.assertEqual(response.body, b"[0]")
1059         response = self.fetch("/bar")
1060         self.assertEqual(response.body, b"[1]")
1061         response = self.fetch("/baz")
1062         self.assertEqual(response.code, 404)
1063         response = self.fetch("/foo", headers={"X-Real-Ip": "127.0.0.1"})
1064         self.assertEqual(response.code, 404)
1065         self.app.default_host = "www.test.com"
1066         response = self.fetch("/baz")
1067         self.assertEqual(response.body, b"[2]")
1068 @wsgi_safe
1069 class NamedURLSpecGroupsTest(WebTestCase):
1070     def get_handlers(self):
1071         class EchoHandler(RequestHandler):
1072             def get(self, path):
1073                 self.write(path)
1074         return [("/str/(?P&lt;path&gt;.*)", EchoHandler),
1075                 (u"/unicode/(?P&lt;path&gt;.*)", EchoHandler)]
1076     def test_named_urlspec_groups(self):
1077         response = self.fetch("/str/foo")
1078         self.assertEqual(response.body, b"foo")
1079         response = self.fetch("/unicode/bar")
1080         self.assertEqual(response.body, b"bar")
1081 @wsgi_safe
1082 class ClearHeaderTest(SimpleHandlerTestCase):
1083     class Handler(RequestHandler):
1084         def get(self):
1085             self.set_header("h1", "foo")
1086             self.set_header("h2", "bar")
1087             self.clear_header("h1")
1088             self.clear_header("nonexistent")
1089     def test_clear_header(self):
1090         response = self.fetch("/")
1091         self.assertTrue("h1" not in response.headers)
1092         self.assertEqual(response.headers["h2"], "bar")
1093 class Header204Test(SimpleHandlerTestCase):
1094     class Handler(RequestHandler):
1095         def get(self):
1096             self.set_status(204)
1097             self.finish()
1098     def test_204_headers(self):
1099         response = self.fetch('/')
1100         self.assertEqual(response.code, 204)
1101         self.assertNotIn("Content-Length", response.headers)
1102         self.assertNotIn("Transfer-Encoding", response.headers)
1103 @wsgi_safe
1104 class Header304Test(SimpleHandlerTestCase):
1105     class Handler(RequestHandler):
1106         def get(self):
1107             self.set_header("Content-Language", "en_US")
1108             self.write("hello")
1109     def test_304_headers(self):
1110         response1 = self.fetch('/')
1111         self.assertEqual(response1.headers["Content-Length"], "5")
1112         self.assertEqual(response1.headers["Content-Language"], "en_US")
1113         response2 = self.fetch('/', headers={
1114             'If-None-Match': response1.headers["Etag"]})
1115         self.assertEqual(response2.code, 304)
1116         self.assertTrue("Content-Length" not in response2.headers)
1117         self.assertTrue("Content-Language" not in response2.headers)
1118         self.assertTrue("Transfer-Encoding" not in response2.headers)
1119 @wsgi_safe
1120 class StatusReasonTest(SimpleHandlerTestCase):
1121     class Handler(RequestHandler):
1122         def get(self):
1123             reason = self.request.arguments.get('reason', [])
1124             self.set_status(int(self.get_argument('code')),
1125                             reason=reason[0] if reason else None)
1126     def get_http_client(self):
1127         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1128     def test_status(self):
1129         response = self.fetch("/?code=304")
1130         self.assertEqual(response.code, 304)
1131         self.assertEqual(response.reason, "Not Modified")
1132         response = self.fetch("/?code=304&amp;reason=Foo")
1133         self.assertEqual(response.code, 304)
1134         self.assertEqual(response.reason, "Foo")
1135         response = self.fetch("/?code=682&amp;reason=Bar")
1136         self.assertEqual(response.code, 682)
1137         self.assertEqual(response.reason, "Bar")
1138         with ExpectLog(app_log, 'Uncaught exception'):
1139             response = self.fetch("/?code=682")
1140         self.assertEqual(response.code, 500)
1141 @wsgi_safe
1142 class DateHeaderTest(SimpleHandlerTestCase):
1143     class Handler(RequestHandler):
1144         def get(self):
1145             self.write("hello")
1146     def test_date_header(self):
1147         response = self.fetch('/')
1148         header_date = datetime.datetime(
1149             *email.utils.parsedate(response.headers['Date'])[:6])
1150         self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
1151                         datetime.timedelta(seconds=2))
1152 @wsgi_safe
1153 class RaiseWithReasonTest(SimpleHandlerTestCase):
1154     class Handler(RequestHandler):
1155         def get(self):
1156             raise HTTPError(682, reason="Foo")
1157     def get_http_client(self):
1158         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1159     def test_raise_with_reason(self):
1160         response = self.fetch("/")
1161         self.assertEqual(response.code, 682)
1162         self.assertEqual(response.reason, "Foo")
1163         self.assertIn(b'682: Foo', response.body)
1164     def test_httperror_str(self):
1165         self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
1166     def test_httperror_str_from_httputil(self):
1167         self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
1168 @wsgi_safe
1169 class ErrorHandlerXSRFTest(WebTestCase):
1170     def get_handlers(self):
1171         return [('/error', ErrorHandler, dict(status_code=417))]
1172     def get_app_kwargs(self):
1173         return dict(xsrf_cookies=True)
1174     def test_error_xsrf(self):
1175         response = self.fetch('/error', method='POST', body='')
1176         self.assertEqual(response.code, 417)
1177     def test_404_xsrf(self):
1178         response = self.fetch('/404', method='POST', body='')
1179         self.assertEqual(response.code, 404)
1180 @wsgi_safe
1181 class GzipTestCase(SimpleHandlerTestCase):
1182     class Handler(RequestHandler):
1183         def get(self):
1184             for v in self.get_arguments('vary'):
1185                 self.add_header('Vary', v)
1186             self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))
1187     def get_app_kwargs(self):
1188         return dict(
1189             gzip=True,
1190             static_path=os.path.join(os.path.dirname(__file__), 'static'))
1191     def assert_compressed(self, response):
1192         self.assertEqual(
1193             response.headers.get(
1194                 'Content-Encoding',
1195                 response.headers.get('X-Consumed-Content-Encoding')),
1196             'gzip')
1197     def test_gzip(self):
1198         response = self.fetch('/')
1199         self.assert_compressed(response)
1200         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1201     def test_gzip_static(self):
1202         response = self.fetch('/robots.txt')
1203         self.assert_compressed(response)
1204         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1205     def test_gzip_not_requested(self):
1206         response = self.fetch('/', use_gzip=False)
1207         self.assertNotIn('Content-Encoding', response.headers)
1208         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1209     def test_vary_already_present(self):
1210         response = self.fetch('/?vary=Accept-Language')
1211         self.assert_compressed(response)
1212         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1213                          ['Accept-Language', 'Accept-Encoding'])
1214     def test_vary_already_present_multiple(self):
1215         response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
1216         self.assert_compressed(response)
1217         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1218                          ['Accept-Language', 'Cookie', 'Accept-Encoding'])
1219 @wsgi_safe
1220 class PathArgsInPrepareTest(WebTestCase):
1221     class Handler(RequestHandler):
1222         def prepare(self):
1223             self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
1224         def get(self, path):
1225             assert path == 'foo'
1226             self.finish()
1227     def get_handlers(self):
1228         return [('/pos/(.*)', self.Handler),
1229                 ('/kw/(?P&lt;path&gt;.*)', self.Handler)]
1230     def test_pos(self):
1231         response = self.fetch('/pos/foo')
1232         response.rethrow()
1233         data = json_decode(response.body)
1234         self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})
1235     def test_kw(self):
1236         response = self.fetch('/kw/foo')
1237         response.rethrow()
1238         data = json_decode(response.body)
1239         self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})
1240 @wsgi_safe
1241 class ClearAllCookiesTest(SimpleHandlerTestCase):
1242     class Handler(RequestHandler):
1243         def get(self):
1244             self.clear_all_cookies()
1245             self.write('ok')
1246     def test_clear_all_cookies(self):
1247 <a name="3"></a>        response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})
1248         set_cookies = sorted(response.headers.get_list('Set-Cookie'))
1249         self.assertTrue(set_cookies<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0].startswith('baz=;') or
1250                         set_cookies[0].startswith('baz="";'))
1251         self.assertTrue(set_cookies[1].startswith('foo=;') or
1252                         set_cookies[</b></font>1].startswith('foo="";'))
1253 class PermissionError(Exception):
1254     pass
1255 @wsgi_safe
1256 class ExceptionHandlerTest(SimpleHandlerTestCase):
1257     class Handler(RequestHandler):
1258         def get(self):
1259             exc = self.get_argument('exc')
1260             if exc == 'http':
1261                 raise HTTPError(410, "no longer here")
1262             elif exc == 'zero':
1263                 1 / 0
1264             elif exc == 'permission':
1265                 raise PermissionError('not allowed')
1266         def write_error(self, status_code, **kwargs):
1267             if 'exc_info' in kwargs:
1268                 typ, value, tb = kwargs['exc_info']
1269                 if isinstance(value, PermissionError):
1270                     self.set_status(403)
1271                     self.write('PermissionError')
1272                     return
1273             RequestHandler.write_error(self, status_code, **kwargs)
1274         def log_exception(self, typ, value, tb):
1275             if isinstance(value, PermissionError):
1276                 app_log.warning('custom logging for PermissionError: %s',
1277                                 value.args[0])
1278             else:
1279                 RequestHandler.log_exception(self, typ, value, tb)
1280     def test_http_error(self):
1281         with ExpectLog(gen_log, '.*no longer here'):
1282             response = self.fetch('/?exc=http')
1283             self.assertEqual(response.code, 410)
1284     def test_unknown_error(self):
1285         with ExpectLog(app_log, 'Uncaught exception'):
1286             response = self.fetch('/?exc=zero')
1287             self.assertEqual(response.code, 500)
1288     def test_known_error(self):
1289         with ExpectLog(app_log,
1290                        'custom logging for PermissionError: not allowed'):
1291             response = self.fetch('/?exc=permission')
1292             self.assertEqual(response.code, 403)
1293 @wsgi_safe
1294 class BuggyLoggingTest(SimpleHandlerTestCase):
1295     class Handler(RequestHandler):
1296         def get(self):
1297             1 / 0
1298         def log_exception(self, typ, value, tb):
1299             1 / 0
1300     def test_buggy_log_exception(self):
1301         with ExpectLog(app_log, '.*'):
1302             self.fetch('/')
1303 @wsgi_safe
1304 class UIMethodUIModuleTest(SimpleHandlerTestCase):
1305     class Handler(RequestHandler):
1306         def get(self):
1307             self.render('foo.html')
1308         def value(self):
1309             return self.get_argument("value")
1310     def get_app_kwargs(self):
1311         def my_ui_method(handler, x):
1312             return "In my_ui_method(%s) with handler value %s." % (
1313                 x, handler.value())
1314         class MyModule(UIModule):
1315             def render(self, x):
1316                 return "In MyModule(%s) with handler value %s." % (
1317                     x, self.handler.value())
1318         loader = DictLoader({
1319             'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
1320         })
1321         return dict(template_loader=loader,
1322                     ui_methods={'my_ui_method': my_ui_method},
1323                     ui_modules={'MyModule': MyModule})
1324     def tearDown(self):
1325         super(UIMethodUIModuleTest, self).tearDown()
1326         RequestHandler._template_loaders.clear()
1327     def test_ui_method(self):
1328         response = self.fetch('/?value=asdf')
1329         self.assertEqual(response.body,
1330                          b'In my_ui_method(42) with handler value asdf. '
1331                          b'In MyModule(123) with handler value asdf.')
1332 @wsgi_safe
1333 class GetArgumentErrorTest(SimpleHandlerTestCase):
1334     class Handler(RequestHandler):
1335         def get(self):
1336             try:
1337                 self.get_argument('foo')
1338                 self.write({})
1339             except MissingArgumentError as e:
1340                 self.write({'arg_name': e.arg_name,
1341                             'log_message': e.log_message})
1342     def test_catch_error(self):
1343         response = self.fetch('/')
1344         self.assertEqual(json_decode(response.body),
1345                          {'arg_name': 'foo',
1346                           'log_message': 'Missing argument foo'})
1347 class MultipleExceptionTest(SimpleHandlerTestCase):
1348     class Handler(RequestHandler):
1349         exc_count = 0
1350         @asynchronous
1351         def get(self):
1352             from salt.ext.tornado.ioloop import IOLoop
1353             IOLoop.current().add_callback(lambda: 1 / 0)
1354             IOLoop.current().add_callback(lambda: 1 / 0)
1355         def log_exception(self, typ, value, tb):
1356             MultipleExceptionTest.Handler.exc_count += 1
1357     def test_multi_exception(self):
1358         response = self.fetch('/')
1359         self.assertEqual(response.code, 500)
1360         response = self.fetch('/')
1361         self.assertEqual(response.code, 500)
1362         self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)
1363 @wsgi_safe
1364 class SetLazyPropertiesTest(SimpleHandlerTestCase):
1365     class Handler(RequestHandler):
1366         def prepare(self):
1367             self.current_user = 'Ben'
1368             self.locale = locale.get('en_US')
1369         def get_user_locale(self):
1370             raise NotImplementedError()
1371         def get_current_user(self):
1372             raise NotImplementedError()
1373         def get(self):
1374             self.write('Hello %s (%s)' % (self.current_user, self.locale.code))
1375     def test_set_properties(self):
1376         response = self.fetch('/')
1377         self.assertEqual(response.body, b'Hello Ben (en_US)')
1378 @wsgi_safe
1379 class GetCurrentUserTest(WebTestCase):
1380     def get_app_kwargs(self):
1381         class WithoutUserModule(UIModule):
1382             def render(self):
1383                 return ''
1384         class WithUserModule(UIModule):
1385             def render(self):
1386                 return str(self.current_user)
1387         loader = DictLoader({
1388             'without_user.html': '',
1389             'with_user.html': '{{ current_user }}',
1390             'without_user_module.html': '{% module WithoutUserModule() %}',
1391             'with_user_module.html': '{% module WithUserModule() %}',
1392         })
1393         return dict(template_loader=loader,
1394                     ui_modules={'WithUserModule': WithUserModule,
1395                                 'WithoutUserModule': WithoutUserModule})
1396     def tearDown(self):
1397         super(GetCurrentUserTest, self).tearDown()
1398         RequestHandler._template_loaders.clear()
1399     def get_handlers(self):
1400         class CurrentUserHandler(RequestHandler):
1401             def prepare(self):
1402                 self.has_loaded_current_user = False
1403             def get_current_user(self):
1404                 self.has_loaded_current_user = True
1405                 return ''
1406         class WithoutUserHandler(CurrentUserHandler):
1407             def get(self):
1408                 self.render_string('without_user.html')
1409                 self.finish(str(self.has_loaded_current_user))
1410         class WithUserHandler(CurrentUserHandler):
1411             def get(self):
1412                 self.render_string('with_user.html')
1413                 self.finish(str(self.has_loaded_current_user))
1414         class CurrentUserModuleHandler(CurrentUserHandler):
1415             def get_template_namespace(self):
1416                 return self.ui
1417         class WithoutUserModuleHandler(CurrentUserModuleHandler):
1418             def get(self):
1419                 self.render_string('without_user_module.html')
1420                 self.finish(str(self.has_loaded_current_user))
1421         class WithUserModuleHandler(CurrentUserModuleHandler):
1422             def get(self):
1423                 self.render_string('with_user_module.html')
1424                 self.finish(str(self.has_loaded_current_user))
1425         return [('/without_user', WithoutUserHandler),
1426                 ('/with_user', WithUserHandler),
1427                 ('/without_user_module', WithoutUserModuleHandler),
1428                 ('/with_user_module', WithUserModuleHandler)]
1429     @unittest.skip('needs fix')
1430     def test_get_current_user_is_lazy(self):
1431         response = self.fetch('/without_user')
1432         self.assertEqual(response.body, b'False')
1433     def test_get_current_user_works(self):
1434         response = self.fetch('/with_user')
1435         self.assertEqual(response.body, b'True')
1436     def test_get_current_user_from_ui_module_is_lazy(self):
1437         response = self.fetch('/without_user_module')
1438         self.assertEqual(response.body, b'False')
1439     def test_get_current_user_from_ui_module_works(self):
1440         response = self.fetch('/with_user_module')
1441         self.assertEqual(response.body, b'True')
1442 @wsgi_safe
1443 class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
1444     class Handler(RequestHandler):
1445         pass
1446     def test_unimplemented_standard_methods(self):
1447         for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
1448             response = self.fetch('/', method=method)
1449             self.assertEqual(response.code, 405)
1450         for method in ['POST', 'PUT']:
1451             response = self.fetch('/', method=method, body=b'')
1452             self.assertEqual(response.code, 405)
1453 class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
1454     class Handler(RequestHandler):
1455         def other(self):
1456             self.write('other')
1457     def test_unimplemented_patch(self):
1458         response = self.fetch('/', method='PATCH', body=b'')
1459         self.assertEqual(response.code, 405)
1460     def test_unimplemented_other(self):
1461         response = self.fetch('/', method='OTHER',
1462                               allow_nonstandard_methods=True)
1463         self.assertEqual(response.code, 405)
1464 @wsgi_safe
1465 class AllHTTPMethodsTest(SimpleHandlerTestCase):
1466     class Handler(RequestHandler):
1467         def method(self):
1468             self.write(self.request.method)
1469         get = delete = options = post = put = method
1470     def test_standard_methods(self):
1471         response = self.fetch('/', method='HEAD')
1472         self.assertEqual(response.body, b'')
1473         for method in ['GET', 'DELETE', 'OPTIONS']:
1474             response = self.fetch('/', method=method)
1475             self.assertEqual(response.body, utf8(method))
1476         for method in ['POST', 'PUT']:
1477             response = self.fetch('/', method=method, body=b'')
1478             self.assertEqual(response.body, utf8(method))
1479 class PatchMethodTest(SimpleHandlerTestCase):
1480     class Handler(RequestHandler):
1481         SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
1482         def patch(self):
1483             self.write('patch')
1484         def other(self):
1485             self.write('other')
1486     def test_patch(self):
1487         response = self.fetch('/', method='PATCH', body=b'')
1488         self.assertEqual(response.body, b'patch')
1489     def test_other(self):
1490         response = self.fetch('/', method='OTHER',
1491                               allow_nonstandard_methods=True)
1492         self.assertEqual(response.body, b'other')
1493 @wsgi_safe
1494 class FinishInPrepareTest(SimpleHandlerTestCase):
1495     class Handler(RequestHandler):
1496         def prepare(self):
1497             self.finish('done')
1498         def get(self):
1499             raise Exception('should not reach this method')
1500     def test_finish_in_prepare(self):
1501         response = self.fetch('/')
1502         self.assertEqual(response.body, b'done')
1503 @wsgi_safe
1504 class Default404Test(WebTestCase):
1505     def get_handlers(self):
1506         return [('/foo', RequestHandler)]
1507     def test_404(self):
1508         response = self.fetch('/')
1509         self.assertEqual(response.code, 404)
1510         self.assertEqual(response.body,
1511                          b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
1512                          b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')
1513 @wsgi_safe
1514 class Custom404Test(WebTestCase):
1515     def get_handlers(self):
1516         return [('/foo', RequestHandler)]
1517     def get_app_kwargs(self):
1518         class Custom404Handler(RequestHandler):
1519             def get(self):
1520                 self.set_status(404)
1521                 self.write('custom 404 response')
1522         return dict(default_handler_class=Custom404Handler)
1523     def test_404(self):
1524         response = self.fetch('/')
1525         self.assertEqual(response.code, 404)
1526         self.assertEqual(response.body, b'custom 404 response')
1527 @wsgi_safe
1528 class DefaultHandlerArgumentsTest(WebTestCase):
1529     def get_handlers(self):
1530         return [('/foo', RequestHandler)]
1531     def get_app_kwargs(self):
1532         return dict(default_handler_class=ErrorHandler,
1533                     default_handler_args=dict(status_code=403))
1534     def test_403(self):
1535         response = self.fetch('/')
1536         self.assertEqual(response.code, 403)
1537 @wsgi_safe
1538 class HandlerByNameTest(WebTestCase):
1539     def get_handlers(self):
1540         return [('/hello1', HelloHandler),
1541                 ('/hello2', 'tornado.test.web_test.HelloHandler'),
1542                 url('/hello3', 'tornado.test.web_test.HelloHandler'),
1543                 ]
1544     def test_handler_by_name(self):
1545         resp = self.fetch('/hello1')
1546         self.assertEqual(resp.body, b'hello')
1547         resp = self.fetch('/hello2')
1548         self.assertEqual(resp.body, b'hello')
1549         resp = self.fetch('/hello3')
1550         self.assertEqual(resp.body, b'hello')
1551 class StreamingRequestBodyTest(WebTestCase):
1552     def get_handlers(self):
1553         @stream_request_body
1554         class StreamingBodyHandler(RequestHandler):
1555             def initialize(self, test):
1556                 self.test = test
1557             def prepare(self):
1558                 self.test.prepared.set_result(None)
1559             def data_received(self, data):
1560                 self.test.data.set_result(data)
1561             def get(self):
1562                 self.test.finished.set_result(None)
1563                 self.write({})
1564         @stream_request_body
1565         class EarlyReturnHandler(RequestHandler):
1566             def prepare(self):
1567                 raise HTTPError(401)
1568         @stream_request_body
1569         class CloseDetectionHandler(RequestHandler):
1570             def initialize(self, test):
1571                 self.test = test
1572             def on_connection_close(self):
1573                 super(CloseDetectionHandler, self).on_connection_close()
1574                 self.test.close_future.set_result(None)
1575         return [('/stream_body', StreamingBodyHandler, dict(test=self)),
1576                 ('/early_return', EarlyReturnHandler),
1577                 ('/close_detection', CloseDetectionHandler, dict(test=self))]
1578     def connect(self, url, connection_close):
1579         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
1580         s.connect(("127.0.0.1", self.get_http_port()))
1581         stream = IOStream(s, io_loop=self.io_loop)
1582         stream.write(b"GET " + url + b" HTTP/1.1\r\n")
1583         if connection_close:
1584             stream.write(b"Connection: close\r\n")
1585         stream.write(b"Transfer-Encoding: chunked\r\n\r\n")
1586         return stream
1587     @gen_test
1588     def test_streaming_body(self):
1589         self.prepared = Future()
1590         self.data = Future()
1591         self.finished = Future()
1592         stream = self.connect(b"/stream_body", connection_close=True)
1593         yield self.prepared
1594         stream.write(b"4\r\nasdf\r\n")
1595         data = yield self.data
1596         self.assertEqual(data, b"asdf")
1597         self.data = Future()
1598         stream.write(b"4\r\nqwer\r\n")
1599         data = yield self.data
1600         self.assertEquals(data, b"qwer")
1601         stream.write(b"0\r\n\r\n")
1602         yield self.finished
1603         data = yield gen.Task(stream.read_until_close)
1604         self.assertTrue(data.endswith(b"{}"))
1605         stream.close()
1606     @gen_test
1607     def test_early_return(self):
1608         stream = self.connect(b"/early_return", connection_close=False)
1609         data = yield gen.Task(stream.read_until_close)
1610         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1611     @gen_test
1612     def test_early_return_with_data(self):
1613         stream = self.connect(b"/early_return", connection_close=False)
1614         stream.write(b"4\r\nasdf\r\n")
1615         data = yield gen.Task(stream.read_until_close)
1616         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1617     @gen_test
1618     def test_close_during_upload(self):
1619         self.close_future = Future()
1620         stream = self.connect(b"/close_detection", connection_close=False)
1621         stream.close()
1622         yield self.close_future
1623 @stream_request_body
1624 class BaseFlowControlHandler(RequestHandler):
1625     def initialize(self, test):
1626         self.test = test
1627         self.method = None
1628         self.methods = []
1629     @contextlib.contextmanager
1630     def in_method(self, method):
1631         if self.method is not None:
1632             self.test.fail("entered method %s while in %s" %
1633                            (method, self.method))
1634         self.method = method
1635         self.methods.append(method)
1636         try:
1637             yield
1638         finally:
1639             self.method = None
1640     @gen.coroutine
1641     def prepare(self):
1642         self.methods.append('prepare')
1643         yield gen.Task(IOLoop.current().add_callback)
1644     @gen.coroutine
1645     def post(self):
1646         with self.in_method('post'):
1647             yield gen.Task(IOLoop.current().add_callback)
1648         self.write(dict(methods=self.methods))
1649 class BaseStreamingRequestFlowControlTest(object):
1650     def get_httpserver_options(self):
1651         return dict(chunk_size=10, decompress_request=True)
1652     def get_http_client(self):
1653         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1654     def test_flow_control_fixed_body(self):
1655         response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
1656                               method='POST')
1657         response.rethrow()
1658         self.assertEqual(json_decode(response.body),
1659                          dict(methods=['prepare', 'data_received',
1660                                        'data_received', 'data_received',
1661                                        'post']))
1662     def test_flow_control_chunked_body(self):
1663         chunks = [b'abcd', b'efgh', b'ijkl']
1664         @gen.coroutine
1665         def body_producer(write):
1666             for i in chunks:
1667                 yield write(i)
1668         response = self.fetch('/', body_producer=body_producer, method='POST')
1669         response.rethrow()
1670         self.assertEqual(json_decode(response.body),
1671                          dict(methods=['prepare', 'data_received',
1672                                        'data_received', 'data_received',
1673                                        'post']))
1674     def test_flow_control_compressed_body(self):
1675         bytesio = BytesIO()
1676         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
1677         gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
1678         gzip_file.close()
1679         compressed_body = bytesio.getvalue()
1680         response = self.fetch('/', body=compressed_body, method='POST',
1681                               headers={'Content-Encoding': 'gzip'})
1682         response.rethrow()
1683         self.assertEqual(json_decode(response.body),
1684                          dict(methods=['prepare', 'data_received',
1685                                        'data_received', 'data_received',
1686                                        'post']))
1687 class DecoratedStreamingRequestFlowControlTest(
1688         BaseStreamingRequestFlowControlTest,
1689         WebTestCase):
1690     def get_handlers(self):
1691         class DecoratedFlowControlHandler(BaseFlowControlHandler):
1692             @gen.coroutine
1693             def data_received(self, data):
1694                 with self.in_method('data_received'):
1695                     yield gen.Task(IOLoop.current().add_callback)
1696         return [('/', DecoratedFlowControlHandler, dict(test=self))]
1697 @skipBefore35
1698 class NativeStreamingRequestFlowControlTest(
1699         BaseStreamingRequestFlowControlTest,
1700         WebTestCase):
1701     def get_handlers(self):
1702         class NativeFlowControlHandler(BaseFlowControlHandler):
1703             data_received = exec_test(globals(), locals(), """
1704             async def data_received(self, data):
1705                 with self.in_method('data_received'):
1706                     await gen.Task(IOLoop.current().add_callback)
1707             response <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.fetch(u)
1708             self.assertEqual(response.code, 401)
1709             self.assertEqual('Basic realm="something"',
1710                              response.headers.get('WWW-Authenticate'))
1711             self.assertEqual(b'authentication required', response.</b></font>body)
1712 @wsgi_safe
1713 class DecoratorTest(WebTestCase):
1714     def get_handlers(self):
1715         class RemoveSlashHandler(RequestHandler):
1716             @removeslash
1717             def get(self):
1718                 pass
1719         class AddSlashHandler(RequestHandler):
1720             @addslash
1721             def get(self):
1722                 pass
1723         return [("/removeslash/", RemoveSlashHandler),
1724                 ("/addslash", AddSlashHandler),
1725                 ]
1726     def test_removeslash(self):
1727         response = self.fetch("/removeslash/", follow_redirects=False)
1728         self.assertEqual(response.code, 301)
1729         self.assertEqual(response.headers['Location'], "/removeslash")
1730         response = self.fetch("/removeslash/?foo=bar", follow_redirects=False)
1731         self.assertEqual(response.code, 301)
1732         self.assertEqual(response.headers['Location'], "/removeslash?foo=bar")
1733     def test_addslash(self):
1734         response = self.fetch("/addslash", follow_redirects=False)
1735         self.assertEqual(response.code, 301)
1736         self.assertEqual(response.headers['Location'], "/addslash/")
1737         response = self.fetch("/addslash?foo=bar", follow_redirects=False)
1738         self.assertEqual(response.code, 301)
1739         self.assertEqual(response.headers['Location'], "/addslash/?foo=bar")
1740 @wsgi_safe
1741 class CacheTest(WebTestCase):
1742     def get_handlers(self):
1743         class EtagHandler(RequestHandler):
1744             def get(self, computed_etag):
1745                 self.write(computed_etag)
1746             def compute_etag(self):
1747                 return self._write_buffer[0]
1748         return [
1749             ('/etag/(.*)', EtagHandler)
1750         ]
1751     def test_wildcard_etag(self):
1752         computed_etag = '"xyzzy"'
1753         etags = '*'
1754         self._test_etag(computed_etag, etags, 304)
1755     def test_strong_etag_match(self):
1756         computed_etag = '"xyzzy"'
1757         etags = '"xyzzy"'
1758         self._test_etag(computed_etag, etags, 304)
1759     def test_multiple_strong_etag_match(self):
1760         computed_etag = '"xyzzy1"'
1761         etags = '"xyzzy1", "xyzzy2"'
1762         self._test_etag(computed_etag, etags, 304)
1763     def test_strong_etag_not_match(self):
1764         computed_etag = '"xyzzy"'
1765         etags = '"xyzzy1"'
1766         self._test_etag(computed_etag, etags, 200)
1767     def test_multiple_strong_etag_not_match(self):
1768         computed_etag = '"xyzzy"'
1769         etags = '"xyzzy1", "xyzzy2"'
1770         self._test_etag(computed_etag, etags, 200)
1771     def test_weak_etag_match(self):
1772         computed_etag = '"xyzzy1"'
1773         etags = 'W/"xyzzy1"'
1774         self._test_etag(computed_etag, etags, 304)
1775     def test_multiple_weak_etag_match(self):
1776         computed_etag = '"xyzzy2"'
1777         etags = 'W/"xyzzy1", W/"xyzzy2"'
1778         self._test_etag(computed_etag, etags, 304)
1779     def test_weak_etag_not_match(self):
1780         computed_etag = '"xyzzy2"'
1781         etags = 'W/"xyzzy1"'
1782         self._test_etag(computed_etag, etags, 200)
1783     def test_multiple_weak_etag_not_match(self):
1784         computed_etag = '"xyzzy3"'
1785         etags = 'W/"xyzzy1", W/"xyzzy2"'
1786         self._test_etag(computed_etag, etags, 200)
1787     def _test_etag(self, computed_etag, etags, status_code):
1788         response = self.fetch(
1789             '/etag/' + computed_etag,
1790             headers={'If-None-Match': etags}
1791         )
1792         self.assertEqual(response.code, status_code)
1793 @wsgi_safe
1794 class RequestSummaryTest(SimpleHandlerTestCase):
1795     class Handler(RequestHandler):
1796         def get(self):
1797             self.request.remote_ip = None
1798             self.finish(self._request_summary())
1799     def test_missing_remote_ip(self):
1800         resp = self.fetch("/")
1801         self.assertEqual(resp.body, b"GET / (None)")
1802 class HTTPErrorTest(unittest.TestCase):
1803     def test_copy(self):
1804         e = HTTPError(403, reason="Go away")
1805         e2 = copy.copy(e)
1806         self.assertIsNot(e, e2)
1807         self.assertEqual(e.status_code, e2.status_code)
1808         self.assertEqual(e.reason, e2.reason)
1809 class ApplicationTest(AsyncTestCase):
1810     def test_listen(self):
1811         app = Application([])
1812         server = app.listen(0, address='127.0.0.1')
1813         server.stop()
1814 class URLSpecReverseTest(unittest.TestCase):
1815     def test_reverse(self):
1816         self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
1817         self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())
1818     def test_non_reversible(self):
1819         paths = [
1820             r'^/api/v\d+/foo/(\w+)$',
1821         ]
1822         for path in paths:
1823             url_spec = url(path, None)
1824             try:
1825                 result = url_spec.reverse()
1826                 self.fail("did not get expected exception when reversing %s. "
1827                           "result: %s" % (path, result))
1828             except ValueError:
1829                 pass
1830     def test_reverse_arguments(self):
1831         self.assertEqual('/api/v1/foo/bar',
1832                          url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))
1833 class RedirectHandlerTest(WebTestCase):
1834     def get_handlers(self):
1835         return [
1836             ('/src', WebRedirectHandler, {'url': '/dst'}),
1837             (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]
1838     def test_basic_redirect(self):
1839         response = self.fetch('/src', follow_redirects=False)
1840         self.assertEqual(response.code, 301)
1841         self.assertEqual(response.headers['Location'], '/dst')
1842     def test_redirect_pattern(self):
1843         response = self.fetch('/a/b/c', follow_redirects=False)
1844         self.assertEqual(response.code, 301)
1845         self.assertEqual(response.headers['Location'], '/b/a/c')
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kiwiproc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import platform
3 import socket
4 from xml.dom import minidom
5 import salt.utils.files
6 from salt.modules.inspectlib.exceptions import InspectorKiwiProcessorException
7 try:
8     import grp
9     import pwd
10 except ImportError:
11     pass
12 try:
13     from lxml import etree
14 except ImportError:
15     import xml.etree.ElementTree as etree
16 class KiwiExporter:
17     def __init__(self, grains, format):
18         self.__grains__ = grains
19         self.format = format
20         self._data = type("data", (), {})
21         self.name = None
22     def load(self, **descr):
23         for obj, data in descr.items():
24             setattr(self._data, obj, data)
25         return self
26     def export(self, name):
27         self.name = name
28         root = self._create_doc()
29         self._set_description(root)
30         self._set_preferences(root)
31         self._set_repositories(root)
32         self._set_users(root)
33         self._set_packages(root)
34 <a name="4"></a>        return "\n".join(
35             [
36                 line
37                 for line in minidom<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.parseString(etree.tostring(root, encoding="UTF-8"))
38                 .toprettyxml(indent="  ")
39                 .split("\n")
40                 if line.strip(</b></font>)
41             ]
42         )
43     def _get_package_manager(self):
44         ret = None
45         if self.__grains__.get("os_family") in ("Kali", "Debian"):
46             ret = "apt-get"
47         elif self.__grains__.get("os_family", "") == "Suse":
48             ret = "zypper"
49         elif self.__grains__.get("os_family", "") == "redhat":
50             ret = "yum"
51         if ret is None:
52             raise InspectorKiwiProcessorException(
53                 "Unsupported platform: {}".format(self.__grains__.get("os_family"))
54             )
55         return ret
56     def _set_preferences(self, node):
57         pref = etree.SubElement(node, "preferences")
58         pacman = etree.SubElement(pref, "packagemanager")
59         pacman.text = self._get_package_manager()
60         p_version = etree.SubElement(pref, "version")
61         p_version.text = "0.0.1"
62         p_type = etree.SubElement(pref, "type")
63         p_type.set("image", "vmx")
64         for disk_id, disk_data in self._data.system.get("disks", {}).items():
65             if disk_id.startswith("/dev"):
66 <a name="1"></a>                p_type.set("filesystem", disk_data.get("type") or "ext3")
67                 break
68         p_type<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.set("installiso", "true")
69         p_type.set("boot", "vmxboot/suse-leap42.1")
70         p_type.set("format", self.format)
71         p_type.set("bootloader", "grub2")
72         p_type.set("timezone", __salt__["timezone.get_zone"]())
73         p_type.set("hwclock", __salt__["timezone.get_hwclock"](</b></font>))
74         return pref
75     def _get_user_groups(self, user):
76         return [g.gr_name for g in grp.getgrall() if user in g.gr_mem] + [
77             grp.getgrgid(pwd.getpwnam(user).pw_gid).gr_name
78         ]
79     def _set_users(self, node):
80         shadow = {}
81         with salt.utils.files.fopen("/etc/shadow") as rfh:
82             for sh_line in rfh.read().split(os.linesep):
83                 if sh_line.strip():
84                     login, pwd = sh_line.split(":")[:2]
85                     if pwd and pwd[0] not in "!*":
86                         shadow[login] = {"p": pwd}
87         with salt.utils.files.fopen("/etc/passwd") as rfh:
88             for ps_line in rfh.read().split(os.linesep):
89                 if ps_line.strip():
90                     ps_line = ps_line.strip().split(":")
91                     if ps_line[0] in shadow:
92                         shadow[ps_line[0]]["h"] = ps_line[5]
93                         shadow[ps_line[0]]["s"] = ps_line[6]
94                         shadow[ps_line[0]]["g"] = self._get_user_groups(ps_line[0])
95 <a name="2"></a>        users_groups = []
96         users_node = etree.SubElement(node, "users")
97         for u_name, u_data in shadow.items():
98             user_node <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(users_node, "user")
99             user_node.set("password", u_data["p"])
100             user_node.set("home", u_data["h"])
101             user_node.set("name", u_name)
102             users_groups.extend(u_data[</b></font>"g"])
103         users_node.set("group", ",".join(users_groups))
104         return users_node
105     def _set_repositories(self, node):
106         priority = 99
107         for repo_id, repo_data in self._data.software.get("repositories", {}).items():
108             if type(repo_data) == list:
109                 repo_data = repo_data[0]
110             if repo_data.get("enabled") or not repo_data.get(
111                 "disabled"
112             ):  # RPM and Debian, respectively
113                 uri = repo_data.get("baseurl", repo_data.get("uri"))
114 <a name="3"></a>                if not uri:
115                     continue
116                 repo = etree.SubElement(node, "repository")
117                 if self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__grains__.get("os_family") in ("Kali", "Debian"):
118                     repo.set("alias", repo_id)
119                     repo.set("distribution", repo_data["dist"])
120                 else:
121                     repo.set("alias", repo_data[</b></font>"alias"])
122                     if self.__grains__.get("os_family", "") == "Suse":
123                         repo.set("type", "yast2")  # TODO: Check for options!
124                     repo.set("priority", str(priority))
125                 source = etree.SubElement(repo, "source")
126                 source.set("path", uri)  # RPM and Debian, respectively
127                 priority -= 1
128     def _set_packages(self, node):
129         pkgs = etree.SubElement(node, "packages")
130         for pkg_name, pkg_version in sorted(
131             self._data.software.get("packages", {}).items()
132         ):
133             pkg = etree.SubElement(pkgs, "package")
134             pkg.set("name", pkg_name)
135         if self.__grains__.get("os_family", "") == "Suse":
136             for ptn_id, ptn_data in self._data.software.get("patterns", {}).items():
137                 if ptn_data.get("installed"):
138                     ptn = etree.SubElement(pkgs, "namedCollection")
139                     ptn.set("name", ptn_id)
140         return pkgs
141     def _set_description(self, node):
142         descr <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= etree.SubElement(node, "description")
143         author = etree.SubElement(descr, "author")
144         author.text = "salt.modules.node on {}".format(hostname)
145         contact = etree.SubElement(descr, "contact")
146         contact.text = "root@{}".format(hostname)
147         specs = etree.SubElement(descr, "specification")
148         specs.</b></font>text = "Rebuild of {}, based on Salt inspection.".format(hostname)
149         return descr
150     def _create_doc(self):
151         root = etree.Element("image")
152         root.set("schemaversion", "6.3")
153         root.set("name", self.name)
154         return root
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
