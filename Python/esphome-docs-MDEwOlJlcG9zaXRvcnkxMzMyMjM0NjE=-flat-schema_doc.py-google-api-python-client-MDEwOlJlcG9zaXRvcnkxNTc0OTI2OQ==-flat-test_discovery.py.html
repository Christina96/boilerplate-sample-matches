
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.825453252755066%, Tokens: 9</h2>
        <div class="column">
            <h3>esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</h3>
            <pre><code>1  from genericpath import exists
2  import re
3  import json
4  import urllib
5  from typing import MutableMapping
6  from sphinx.util import logging
7  from docutils import nodes
8  SCHEMA_PATH = "../esphome-vscode/server/src/schema/"
9  CONFIGURATION_VARIABLES = "Configuration variables:"
10  CONFIGURATION_OPTIONS = "Configuration options:"
11  PIN_CONFIGURATION_VARIABLES = "Pin configuration variables:"
12  COMPONENT_HUB = "Component/Hub"
13  JSON_DUMP_PRETTY = True
14  class Statistics:
15      props_documented = 0
16      enums_good = 0
17      enums_bad = 0
18  statistics = Statistics()
19  logger = logging.getLogger(__name__)
20  def setup(app):
21      import os
22      if not os.path.isfile(SCHEMA_PATH + "esphome.json"):
23          logger.info(f"{SCHEMA_PATH} not found. Not documenting schema.")
24          return
25      app.connect("doctree-resolved", doctree_resolved)
26      app.connect("build-finished", build_finished)
27      app.files = {}
28      return {"version": "1.0.0", "parallel_read_safe": True, "parallel_write_safe": True}
29  def find_platform_component(app, platform, component):
30      file_data = get_component_file(app, component)
31      return file_data[f"{component}.{platform}"]["schemas"]["CONFIG_SCHEMA"]
32  def doctree_resolved(app, doctree, docname):
33      if docname == "components/index":
34          return
35      handle_component(app, doctree, docname)
36  PLATFORMS_TITLES = {
37      "Sensor": "sensor",
38      "Binary Sensor": "binary_sensor",
39      "Text Sensor": "text_sensor",
40      "Output": "output",
41      "Cover": "cover",
42      "Button": "button",
43      "Select": "select",
44      "Fan": "fan",
45      "Lock": "lock",
46      "Number": "number",
47      "Climate": "climate",
48      "CAN Bus": "canbus",
49      "Stepper": "stepper",
50      "Switch": "switch",
51      "IÂ²C": "i2c",
52      "Media Player": "media_player",
53      "Microphone": "microphone",
54  }
55  CUSTOM_DOCS = {
56      "guides/automations": {
57          "Global Variables": "globals.schemas.CONFIG_SCHEMA",
58      },
59      "guides/configuration-types": {
60          "Pin Schema": [
61              "esp32.pin.schema",
62              "esp8266.pin.schema",
63          ],
64      },
65      "components/binary_sensor/index": {
66          "Binary Sensor Filters": "binary_sensor.registry.filter",
67      },
68      "components/canbus": {
69          "_LoadSchema": False,
70          "Base CAN Bus Configuration": "canbus.schemas.CANBUS_SCHEMA",
71      },
72      "components/climate/climate_ir": {"_LoadSchema": False, "IR Remote Climate": []},
73      "components/display/index": {
74          "Images": "image.schemas.CONFIG_SCHEMA",
75          "Fonts": "font.schemas.CONFIG_SCHEMA",
76          "Color": "color.schemas.CONFIG_SCHEMA",
77          "Animation": "animation.schemas.CONFIG_SCHEMA",
78      },
79      "components/light/index": {
80          "Base Light Configuration": [
81              "light.schemas.ADDRESSABLE_LIGHT_SCHEMA",
82              "light.schemas.BINARY_LIGHT_SCHEMA",
83              "light.schemas.BRIGHTNESS_ONLY_LIGHT_SCHEMA",
84              "light.schemas.LIGHT_SCHEMA",
85          ],
86          "Light Effects": "light.registry.effects",
87      },
88      "components/light/fastled": {
89          "_LoadSchema": False,
90          "Clockless": "fastled_clockless.platform.light.schemas.CONFIG_SCHEMA",
91          "SPI": "fastled_spi.platform.light.schemas.CONFIG_SCHEMA",
92      },
93      "components/binary_sensor/ttp229": {
94          "_LoadSchema": False,
95      },
96      "components/mcp230xx": {
97          "_LoadSchema": False,
98          PIN_CONFIGURATION_VARIABLES: "mcp23xxx.pin",
99      },
100      "components/mqtt": {
101          "MQTT Component Base Configuration": "core.schemas.MQTT_COMMAND_COMPONENT_SCHEMA",
102          "MQTTMessage": "mqtt.schemas.MQTT_MESSAGE_BASE",
103      },
104      "components/output/index": {
105          "Base Output Configuration": "output.schemas.FLOAT_OUTPUT_SCHEMA",
106      },
107      "components/remote_transmitter": {
108          "Remote Transmitter Actions": "remote_base.schemas.BASE_REMOTE_TRANSMITTER_SCHEMA",
109      },
110      "components/sensor/index": {
111          "Sensor Filters": "sensor.registry.filter",
112      },
113      "components/time": {
114          "_LoadSchema": False,
115          "Base Time Configuration": "time.schemas.TIME_SCHEMA",
116          "on_time Trigger": "time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema",
117          "Home Assistant Time Source": "homeassistant.platform.time.schemas.CONFIG_SCHEMA",
118          "SNTP Time Source": "sntp.platform.time.schemas.CONFIG_SCHEMA",
119          "GPS Time Source": "gps.platform.time.schemas.CONFIG_SCHEMA",
120          "DS1307 Time Source": "ds1307.platform.time.schemas.CONFIG_SCHEMA",
121      },
122      "components/wifi": {
123          "Connecting to Multiple Networks": "wifi.schemas.CONFIG_SCHEMA.schema.config_vars.networks.schema",
124          "Enterprise Authentication": "wifi.schemas.EAP_AUTH_SCHEMA",
125      },
126      "custom/custom_component": {
127          "Generic Custom Component": "custom_component.schemas.CONFIG_SCHEMA"
128      },
129      "components/esp32": {
130          "Arduino framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.arduino",
131          "ESP-IDF framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.esp-idf",
132      },
133      "components/sensor/airthings_ble": {
134          "_LoadSchema": False,
135      },
136      "components/sensor/radon_eye_ble": {
137          "_LoadSchema": False,
138      },
139      "components/sensor/xiaomi_ble": {
140          "_LoadSchema": False,
141      },
142      "components/sensor/xiaomi_miscale2": {
143          "_LoadSchema": False,
144      },
145      "components/mcp23Sxx": {
146          "_LoadSchema": False,
147      },
148      "components/display/lcd_display": {"_LoadSchema": False},
149      "components/display/ssd1306": {"_LoadSchema": False},
150      "components/display/ssd1322": {"_LoadSchema": False},
151      "components/display/ssd1325": {"_LoadSchema": False},
152      "components/display/ssd1327": {"_LoadSchema": False},
153      "components/display/ssd1351": {"_LoadSchema": False},
154      "components/copy": {"_LoadSchema": False},
155      "components/display_menu/index": {
156          "Display Menu": "display_menu_base.schemas.DISPLAY_MENU_BASE_SCHEMA",
157          "Select": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.select",
158          "Menu": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.menu",
159          "Number": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.number",
160          "Switch": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.switch",
161          "Custom": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.custom",
162      },
163      "components/display_menu/lcd_menu": {
164          "LCD Menu": "lcd_menu.schemas.CONFIG_SCHEMA",
165      },
166  }
167  REQUIRED_OPTIONAL_TYPE_REGEX = r"(\(((\*\*Required\*\*)|(\*Optional\*))(,\s(.*))*)\):\s"
168  def get_node_title(node):
169      return list(node.traverse(nodes.title))[0].astext()
170  def read_file(fileName):
171      f = open(SCHEMA_PATH + fileName + ".json", "r", encoding="utf-8-sig")
172      str = f.read()
173      return json.loads(str)
174  def is_config_vars_title(title_text):
175      return title_text == CONFIGURATION_VARIABLES or title_text == CONFIGURATION_OPTIONS
176  class SchemaGeneratorVisitor(nodes.NodeVisitor):
177      def __init__(self, app, doctree, docname):
178          nodes.NodeVisitor.__init__(self, doctree)
179          self.app = app
180          self.doctree = doctree
181          self.docname = docname
182          self.path = docname.split("/")
183          self.json_component = None
184          self.props = None
185          self.platform = None
186          self.json_platform_component = None
187          self.title_id = None
188          self.props_section_title = None
189          self.find_registry = None
190          self.component = None
191          self.section_level = 0
192          self.file_schema = None
193          self.custom_doc = CUSTOM_DOCS.get(docname)
194          if self.path[0] == "components":
195              if len(self.path) == 2:  # root component, e.g. dfplayer, logger
196                  self.component = docname[11:]
197                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
198                      self.file_schema = get_component_file(app, self.component)
199                      self.json_component = self.file_schema[self.component]["schemas"][
200                          "CONFIG_SCHEMA"
201                      ]
202              elif self.path[1] == "display_menu":  # weird folder naming
203                  if self.path[2] == "index":
204                      self.component = "display_menu_base"
205                  else:
206                      self.component = self.path[2]
207                      self.file_schema = get_component_file(app, self.component)
208                      self.json_component = self.file_schema[self.component]["schemas"][
209                          "CONFIG_SCHEMA"
210                      ]
211              else:  # sub component, e.g. output/esp8266_pwm
212                  self.platform = self.path[1]
213                  self.component = self.path[2]
214                  if self.component == "ssd1331":
215                      self.component = "ssd1331_spi"
216                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
217                      if self.component == "index":
218                          self.component = self.platform.replace(" ", "_").lower()
219                          self.file_schema = get_component_file(app, self.component)
220                          self.json_component = self.file_schema[self.component][
221                              "schemas"
222                          ].get(self.component.upper() + "_SCHEMA")
223                          pass
224                      else:
225                          self.json_component = get_component_file(app, self.component)
226                          self.json_platform_component = find_platform_component(
227                              app, self.platform, self.component
228                          )
229          self.previous_title_text = "No title"
230          self.is_component_hub = False
231          self.multi_component = None
232          self.prop_stack = []
233          self.current_prop = None
234          self.filled_props = False
235          self.accept_props = False
236          self.bullet_list_level = 0
237      def set_component_description(self, description, componentName, platformName=None):
238          if platformName is not None:
<span onclick='openModal()' class='match'>239              platform = get_component_file(self.app, platformName)
240              platform[platformName]["components"][componentName.lower()][
</span>241                  "docs"
242              ] = description
243          else:
244              core = get_component_file(self.app, "esphome")["core"]
245              if componentName in core["components"]:
246                  core["components"][componentName]["docs"] = description
247              elif componentName in core["platforms"]:
248                  core["platforms"][componentName]["docs"] = description
249              else:
250                  if componentName != "display_menu_base":
251                      raise ValueError(
252                          "Cannot set description for component " + componentName
253                      )
254      def visit_document(self, node):
255          if self.docname in ["components/sensor/binary_sensor_map"]:
256              raise nodes.SkipChildren
257          if self.docname in ["components/climate/climate_ir"]:
258              return
259          if len(list(node.traverse(nodes.paragraph))) == 0:
260              raise nodes.SkipChildren
261          self.props_section_title = get_node_title(node)
262          description = self.getMarkdownParagraph(node)
263          if self.json_platform_component:
264              self.set_component_description(description, self.component, self.platform)
265          elif self.json_component:
266              self.set_component_description(description, self.component)
267          if self.json_component or self.json_platform_component:
268              if is_component_file(
269                  self.app,
270                  self.component,
271              ):
272                  self.props = self.find_props(
273                      self.json_platform_component
274                      if self.json_platform_component
275                      else self.json_component,
276                      True,
277                  )
278      def visit_table(self, node):
279          if (
280              self.docname == "components/climate/climate_ir"
281              and len(CUSTOM_DOCS["components/climate/climate_ir"]["IR Remote Climate"])
282              == 0
283          ):
284              table_rows = node[0][4]
285              for row in table_rows:
286                  components_paths = [
287                      components + ".platform.climate.schemas.CONFIG_SCHEMA"
288                      for components in row[1].astext().split("\n")
289                  ]
290                  CUSTOM_DOCS["components/climate/climate_ir"][
291                      "IR Remote Climate"
292                  ] += components_paths
293      def depart_document(self, node):
294          pass
295      def visit_section(self, node):
296          self.section_level += 1
297          section_title = get_node_title(node)
298          if self.custom_doc and section_title in self.custom_doc:
299              r = self.custom_doc[section_title]
300              if ".registry." in r:
301                  self.find_registry = r
302      def depart_section(self, node):
303          self.section_level -= 1
304          if self.section_level == 1:
305              self.find_registry = None
306      def unknown_visit(self, node):
307          pass
308      def unknown_departure(self, node):
309          pass
310      def visit_title(self, node):
311          title_text = node.astext()
312          if self.custom_doc is not None and title_text in self.custom_doc:
313              if isinstance(self.custom_doc[title_text], list):
314                  self.multi_component = self.custom_doc[title_text]
315                  self.filled_props = False
316                  self.props = None
317                  desc = self.getMarkdownParagraph(node.parent)
318                  for c in self.multi_component:
319                      if len(c.split(".")) == 2:
320                          self.set_component_description(desc, c.split(".")[0])
321                  return
322              json_component = self.find_component(self.custom_doc[title_text])
323              if not json_component:
324                  return
325              if self.json_component is None:
326                  self.json_component = json_component
327              parts = self.custom_doc[title_text].split(".")
328              if parts[0] not in ["core", "remote_base"] and parts[-1] != "pin":
329                  if parts[1] == "platform":
330                      self.set_component_description(
331                          self.getMarkdownParagraph(node.parent), parts[0], parts[2]
332                      )
333                  else:
334                      self.set_component_description(
335                          self.getMarkdownParagraph(node.parent),
336                          parts[0],
337                      )
338              self.props_section_title = title_text
339              self.props = self.find_props(json_component)
340              return
341          elif title_text == COMPONENT_HUB:
342              self.props_section_title = f"{self.path[-1]} {title_text}"
343              json_component = self.get_component_schema(
344                  self.path[-1] + ".CONFIG_SCHEMA"
345              ).get("schema", {})
346              if json_component:
347                  self.props = self.find_props(json_component)
348                  self.set_component_description(
349                      self.getMarkdownParagraph(node.parent), self.path[-1]
350                  )
351              self.is_component_hub = True
352          elif is_config_vars_title(title_text):
353              if not self.props and self.multi_component is None:
354                  raise ValueError(
355                      f'Found a "{title_text}": title after {self.previous_title_text}. Unknown object.'
356                  )
357          elif title_text == "Over SPI" or title_text == "Over IÂ²C":
358              suffix = "_spi" if "SPI" in title_text else "_i2c"
359              component = self.path[-1] + suffix
360              self.props_section_title = self.path[-1] + " " + title_text
361              if self.platform is not None and not self.is_component_hub:
362                  json_platform_component = find_platform_component(
363                      self.app, self.platform, component
364                  )
365                  if not json_platform_component:
366                      raise ValueError(
367                          f"Cannot find platform {self.platform} component '{component}' after found title: '{title_text}'."
368                      )
369                  self.props = self.find_props(json_platform_component)
370                  json_platform_component["docs"] = self.getMarkdownParagraph(node.parent)
371              else:
372                  json_component = self.get_component_schema(
373                      component + ".CONFIG_SCHEMA"
374                  ).get("schema", {})
375                  if not json_component:
376                      raise ValueError(
377                          f"Cannot find component '{component}' after found title: '{title_text}'."
378                      )
379                  self.props = self.find_props(json_component)
380                  self.set_component_description(
381                      self.getMarkdownParagraph(node.parent), component
382                  )
383          elif (
384              len(
385                  list(
386                      filter(
387                          lambda x: title_text.endswith(x), list(PLATFORMS_TITLES.keys())
388                      )
389                  )
390              )
391              > 0
392          ):
393              if title_text in PLATFORMS_TITLES:
394                  platform_name = PLATFORMS_TITLES[title_text]
395                  if self.path[-1] == "index":
396                      component_name = self.path[-2]
397                  else:
398                      component_name = self.path[-1]
399                  self.props_section_title = component_name + " " + title_text
400              else:
401                  for t in PLATFORMS_TITLES:
402                      if title_text.endswith(t):
403                          component_name = title_text[
404                              0 : len(title_text) - len(t) - 1
405                          ].replace(" ", "_")
406                          platform_name = PLATFORMS_TITLES[t]
407                  if not platform_name:
408                      return
409                  self.props_section_title = title_text
410                  if not is_component_file(self.app, component_name):
411                      return
412              c = find_platform_component(self.app, platform_name, component_name.lower())
413              if c:
414                  self.json_platform_component = c
415                  self.set_component_description(
416                      self.getMarkdownParagraph(node.parent),
417                      component_name,
418                      platform_name,
419                  )
420              try:
421                  self.props = self.find_props(self.json_platform_component)
422              except KeyError:
423                  raise ValueError("Cannot find platform props")
424          elif title_text.endswith("Component") or title_text.endswith("Bus"):
425              split_text = title_text.split(" ")
426              self.props_section_title = title_text
427              component_name = (
428                  "_".join(split_text[:-1]).lower().replace(".", "").replace("iÂ²c", "i2c")
429              )
430              if component_name != self.platform and is_component_file(
431                  self.app, component_name
432              ):
433                  f = get_component_file(self.app, component_name)
434                  description = self.getMarkdownParagraph(node.parent)
435                  if component_name in f:
436                      self.set_component_description(description, component_name)
437                      c = f[component_name]
438                      if c:
439                          self.json_component = c["schemas"]["CONFIG_SCHEMA"]
440                          try:
441                              self.props = self.find_props(self.json_component)
442                              self.multi_component = None
443                          except KeyError:
444                              raise ValueError(
445                                  "Cannot find props for component " + component_name
446                              )
447                          return
448                  elif f"{component_name}.{self.path[1]}" in f:
449                      self.set_component_description(
450                          description, component_name, self.path[1]
451                      )
452                      self.json_platform_component = f[
453                          f"{component_name}.{self.path[1]}"
454                      ]["schemas"]["CONFIG_SCHEMA"]
455                      try:
456                          self.props = self.find_props(self.json_platform_component)
457                      except KeyError:
458                          raise ValueError(
459                              f"Cannot find props for platform {self.path[1]} component {self.component_name}"
460                          )
461                      return
462          elif title_text.endswith("Trigger"):
463              description = self.getMarkdownParagraph(node.parent)
464              split_text = title_text.split(" ")
465              if len(split_text) != 2:
466                  return
467              key = split_text[0]
468              if (
469                  not self.props or not self.props.typed
470              ):  # props are right for typed components so far
471                  c = self.json_component
472                  if c:
473                      trigger_schema = self.find_props(c).get(key)
474                      if trigger_schema is not None:
475                          self.props = self.find_props(trigger_schema)
476              self.props_section_title = title_text
477          elif title_text == PIN_CONFIGURATION_VARIABLES:
478              self.component = self.find_component(self.path[-1] + ".pin")
479              self.props = self.find_props(self.component)
480              self.accept_props = True
481              if not self.component:
482                  raise ValueError(
483                      f'Found a "{PIN_CONFIGURATION_VARIABLES}" entry but could not find pin schema'
484                  )
485          elif title_text.endswith("Action") or title_text.endswith("Condition"):
486              description = self.getMarkdownParagraph(node.parent)
487              split_text = title_text.split(" ")
488              if len(split_text) != 2:
489                  return
490              key = split_text[0]
491              component_parts = split_text[0].split(".")
492              if len(component_parts) == 3:
493                  try:
494                      cv = get_component_file(self.app, component_parts[1])[
495                          component_parts[1] + "." + component_parts[0]
496                      ][split_text[1].lower()][component_parts[2]]
497                  except KeyError:
498                      logger.warn(
499                          f"In {self.docname} cannot found schema of {title_text}"
500                      )
501                      cv = None
502                  if cv is not None:
503                      cv["docs"] = description
504                      self.props = self.find_props(cv.get("schema", {}))
505              elif len(component_parts) == 2:
506                  registry_name = ".".join(
507                      [component_parts[0], "registry", split_text[1].lower()]
508                  )
509                  key = component_parts[1]
510                  self.find_registry_prop(registry_name, key, description)
511              else:
512                  registry_name = f"core.registry.{split_text[1].lower()}"
513                  self.find_registry_prop(registry_name, key, description)
514          if self.section_level == 3 and self.find_registry:
515              name = title_text
516              if name.endswith(" Effect"):
517                  name = title_text[: -len(" Effect")]
518              if name.endswith(" Light"):
519                  name = name[: -len(" Light")]
520              key = name.replace(" ", "_").replace(".", "").lower()
521              description = self.getMarkdownParagraph(node.parent)
522              self.find_registry_prop(self.find_registry, key, description)
523              self.props_section_title = title_text
524      def get_component_schema(self, name):
525          parts = name.split(".")
526          schema_file = get_component_file(self.app, parts[0])
527          if parts[1] == "registry":
528              schema = schema_file.get(parts[0], {}).get(parts[2], {})
529          elif len(parts) == 3:
530              schema = (
531                  schema_file.get(f"{parts[0]}.{parts[1]}")
532                  .get("schemas", {})
533                  .get(parts[2], {})
534              )
535          else:
536              schema = schema_file.get(parts[0], {}).get("schemas", {}).get(parts[1], {})
537          return schema
538      def get_component_config_var(self, name, key):
539          c = self.get_component_schema(name)
540          if key in c:
541              return c[key]
542          if "config_vars" not in c:
543              return c
544          if key in c["config_vars"]:
545              return c["config_vars"][c]
546      def find_registry_prop(self, registry_name, key, description):
547          c = self.get_component_schema(registry_name)
548          if key in c:
549              cv = c[key]
550              if cv is not None:
551                  cv["docs"] = description
552                  self.props = self.find_props(cv.get("schema", {}))
553      def depart_title(self, node):
554          if self.filled_props:
555              self.filled_props = False
556              self.props = None
557              self.current_prop = None
558              self.accept_props = False
559              self.multi_component = None
560          self.previous_title_text = node.astext()
561          self.title_id = node.parent["ids"][0]
562      def find_props_previous_title(self):
563          comp = self.json_component or self.json_platform_component
564          if comp:
565              props = self.find_props(comp)
566              if self.previous_title_text in props:
567                  prop = props[self.previous_title_text]
568                  if prop:
569                      self.props = self.find_props(prop)
570                  else:
571                      self.props = {"__": "none"}
572      def visit_Text(self, node):
573          if self.multi_component:
574              return
575          if is_config_vars_title(node.astext()):
576              if not self.props:
577                  self.find_props_previous_title()
578              if not self.props:
579                  raise ValueError(
580                      f'Found a "{node.astext()}" entry for unknown object after {self.previous_title_text}'
581                  )
582              self.accept_props = True
583          raise nodes.SkipChildren
584      def depart_Text(self, node):
585          pass
586      def visit_paragraph(self, node):
587          if is_config_vars_title(node.astext()):
588              if not self.props and not self.multi_component:
589                  self.find_props_previous_title()
590              if not self.props and not self.multi_component:
591                  logger.info(
592                      f"In {self.docname} / {self.previous_title_text} found a {node.astext()} title and there are no props."
593                  )
594              self.accept_props = True
595          raise nodes.SkipChildren
596      def depart_paragraph(self, node):
597          pass
598      def visit_bullet_list(self, node):
599          self.bullet_list_level = self.bullet_list_level + 1
600          if (
601              self.current_prop
602              and (self.props or self.multi_component)
603              and self.bullet_list_level > 1
604          ):
605              self.prop_stack.append((self.current_prop, node))
606              self.accept_props = True
607              return
608          if not self.props and self.multi_component is None:
609              raise nodes.SkipChildren
610      def depart_bullet_list(self, node):
611          self.bullet_list_level = self.bullet_list_level - 1
612          if len(self.prop_stack) > 0:
613              stack_prop, stack_node = self.prop_stack[-1]
614              if stack_node == node:
615                  self.prop_stack.pop()
616                  self.filled_props = True
617                  self.current_prop = stack_prop
618      def visit_list_item(self, node):
619          if self.accept_props and self.props:
620              self.filled_props = True
621              self.current_prop, found = self.update_prop(node, self.props)
622              if self.current_prop and not found:
623                  logger.info(
624                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
625                  )
626          elif self.multi_component:
627              found_any = False
628              self.current_prop = None
629              for c in self.multi_component:
630                  props = self.find_props(self.find_component(c))
631                  self.current_prop, found = self.update_prop(node, props)
632                  if self.current_prop and found:
633                      found_any = True
634              if self.current_prop and not found_any:
635                  logger.info(
636                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
637                  )
638              self.filled_props = True
639      def depart_list_item(self, node):
640          pass
641      def visit_literal(self, node):
642          raise nodes.SkipChildren
643      def depart_literal(self, node):
644          pass
645      def getMarkdown(self, node):
646          from markdown import Translator
647          t = Translator(
648              urllib.parse.urljoin(self.app.config.html_baseurl, self.docname + ".html"),
649              self.doctree,
650          )
651          node.walkabout(t)
652          return t.output.strip("\n")
653      def getMarkdownParagraph(self, node):
654          paragraph = list(node.traverse(nodes.paragraph))[0]
655          markdown = self.getMarkdown(paragraph)
656          param_type = None
657          try:
658              name_type = markdown[: markdown.index(": ") + 2]
659              ntr = re.search(
660                  REQUIRED_OPTIONAL_TYPE_REGEX,
661                  name_type,
662                  re.IGNORECASE,
663              )
664              if ntr:
665                  param_type = ntr.group(6)
666                  if param_type:
667                      markdown = (
668                          f"**{param_type}**: {markdown[markdown.index(': ') + 2 :]}"
669                      )
670          except ValueError:
671              pass
672          title = list(node.traverse(nodes.title))[0]
673          if len(title) > 0:
674              url = urllib.parse.urljoin(
675                  self.app.config.html_baseurl,
676                  self.docname + ".html#" + title.parent["ids"][0],
677              )
678              if (
679                  self.props_section_title is not None
680                  and self.props_section_title.endswith(title.astext())
681              ):
682                  markdown += f"\n\n*See also: [{self.props_section_title}]({url})*"
683              else:
684                  markdown += f"\n\n*See also: [{self.getMarkdown(title)}]({url})*"
685          return markdown
686      def update_prop(self, node, props):
687          prop_name = None
688          for s_prop, n in self.prop_stack:
689              inner = props.get(s_prop)
690              if inner is not None and "schema" in inner:
691                  props = self.Props(self, inner["schema"])
692              elif inner is not None and inner.get("type") == "typed":
693                  props = self.Props(self, inner)
694              elif inner is not None and inner.get("type") == "enum":
695                  enum_raw = self.getMarkdown(node)
696                  enum_match = re.search(
697                      r"\* `([^`]*)`((:| -) (.*))*", enum_raw, re.IGNORECASE
698                  )
699                  if enum_match:
700                      enum_value = enum_match.group(1)
701                      enum_docs = enum_match.group(4)
702                      found = False
703                      for name in inner["values"]:
704                          if enum_value.upper().replace(" ", "_") == str(name).upper():
705                              found = True
706                              if enum_docs:
707                                  enum_docs = enum_docs.strip()
708                                  if inner["values"][name] is None:
709                                      inner["values"][name] = {"docs": enum_docs}
710                                  else:
711                                      inner["values"][name]["docs"] = enum_docs
712                                  statistics.props_documented += 1
713                                  statistics.enums_good += 1
714                      if not found:
715                          logger.info(
716                              f"In '{self.docname} {self.previous_title_text} Property {s_prop} cannot find enum value {enum_value}"
717                          )
718                  else:
719                      statistics.enums_bad += 1
720                      logger.info(
721                          f"In '{self.docname} {self.previous_title_text} Property {s_prop} unexpected enum member description format"
722                      )
723              else:
724                  return prop_name, False
725          raw = node.rawsource  # this has the full raw rst code for this property
726          if not raw.startswith("**"):
727              return prop_name, False
728          markdown = self.getMarkdown(node)
729          markdown += f"\n\n*See also: [{self.props_section_title}]({urllib.parse.urljoin(self.app.config.html_baseurl, self.docname +'.html#'+self.title_id)})*"
730          try:
731              name_type = markdown[: markdown.index(": ") + 2]
732          except ValueError:
733              logger.info(
734                  f"In '{self.docname} {self.previous_title_text} Property format error. Missing ': ' in {raw}'"
735              )
736              return prop_name, False
737          PROP_NAME_REGEX = r"\*\*(\w*(?:/\w*)*)\*\*"
738          FULL_ITEM_PROP_NAME_TYPE_REGEX = (
739              r"\* " + PROP_NAME_REGEX + r"\s" + REQUIRED_OPTIONAL_TYPE_REGEX
740          )
741          ntr = re.search(
742              FULL_ITEM_PROP_NAME_TYPE_REGEX,
743              name_type,
744              re.IGNORECASE,
745          )
746          if ntr:
747              prop_name = ntr.group(1)
748              param_type = ntr.group(7)
749          else:
750              s2 = re.search(
751                  FULL_ITEM_PROP_NAME_TYPE_REGEX,
752                  markdown,
753                  re.IGNORECASE,
754              )
755              if s2:
756                  s3 = re.search(r"\* " + PROP_NAME_REGEX + r"*:\s", name_type)
757                  if s3 is not None:
758                      prop_name = s3.group(1)
759                  else:
760                      logger.info(
761                          f"In '{self.docname} {self.previous_title_text} Invalid list format: {node.rawsource}"
762                      )
763                  param_type = None
764              else:
765                  logger.info(
766                      f"In '{self.docname} {self.previous_title_text} Invalid property format: {node.rawsource}"
767                  )
768                  return prop_name, False
769          prop_names = str(prop_name)
770          for k in prop_names.split("/"):
771              config_var = props.get(k)
772              if not config_var:
773                  if k in [
774                      "id",
775                      "name",
776                      "internal",
777                      "address",
778                      "i2c_id",
779                      "update_interval",
780                      "uart_id",
781                      "effects",
782                      "gamma_correct",
783                      "default_transition_length",
784                      "flash_transition_length",
785                      "color_correct",
786                      "lambda",
787                      "pages",
788                      "rotation",
789                      "spi_id",
790                      "cs_pin",
791                      "inverted",
792                      "power_supply",
793                      "receiver_id",
794                  ]:
795                      config_var = props[k] = {}
796                  else:
797                      if self.path[1] == "esphome" and k in [
798                          "platform",
799                          "board",
800                          "arduino_version",
801                          "esp8266_restore_from_flash",
802                      ]:
803                          return prop_name, True
804                      return prop_name, False
805              desc = markdown[markdown.index(": ") + 2 :].strip()
806              if param_type:
807                  desc = "**" + param_type + "**: " + desc
808              config_var["docs"] = desc
809          statistics.props_documented += 1
810          return prop_name, True
811      def find_component(self, component_path):
812          path = component_path.split(".")
813          file_content = get_component_file(self.app, path[0])
814          if path[1] == "platform":
815              path[2] = f"{path[0]}.{path[2]}"
816              path = path[2:]
817          component = file_content
818          for p in path:
819              component = component.get(p, {})
820          return component
821      class Props(MutableMapping):
822          def __init__(self, visitor, component, fail_silently=False):
823              self.visitor = visitor
824              self.component = component
825              self.store = self._get_props(component, fail_silently)
826              self.parent = None
827              self.typed = self.component.get("type") == "typed"
828          def _get_props(self, component, fail_silently):
829              if not (
830                  "config_vars" in component
831                  or "extends" in component
832                  or len(component) == 0
833                  or component.get("type") == "typed"
834              ):
835                  if fail_silently:
836                      return None
837                  raise ValueError("Unexpected component data to get props")
838              props = component.get("config_vars")
839              return props
840          def _find_extended(self, component, key):
841              for extended in component.get("extends", []):
842                  c = self.visitor.get_component_schema(extended)
843                  if c.get("type") == "typed":
844                      p = self.visitor.Props(self.visitor, c)
845                      return p[key]
846                  schema = c.get("schema", {})
847                  for k, cv in schema.get("config_vars", {}).items():
848                      if k == key:
849                          return SetObservable(
850                              cv,
851                              setitem_callback=self._set_extended,
852                              inner_key=key,
853                              original_dict=schema.get("config_vars"),
854                          )
855                  ex1 = self._find_extended(schema, key)
856                  if ex1:
857                      return ex1
858          def _set_extended(self, inner_key, original_dict, key, value):
859              original_dict[inner_key][key] = value
860          def _iter_extended(self, component):
861              for extended in component.get("extends", []):
862                  schema = self.visitor.get_component_schema(extended).get("schema", {})
863                  for s in self._iter_extended(schema):
864                      yield s
865                  yield schema
866          def __getitem__(self, key):
867              if self.store and key in self.store:
868                  return self.store[key]
869              extended = self._find_extended(self.component, key)
870              if extended is not None:
871                  return extended
872              if self.component.get("type") == "typed":
873                  return SetObservable(
874                      {key: {"type": "string"}},
875                      setitem_callback=self._set_typed,
876                      inner_key=key,
877                      original_dict={},
878                  )
879          def _set_typed(self, inner_key, original_dict, key, value):
880              if inner_key == self.component.get("typed_key", "type"):
881                  self.component[key] = value
882              else:
883                  for tk, tv in self.component["types"].items():
884                      for cv_k, cv_v in tv["config_vars"].items():
885                          if cv_k == inner_key:
886                              cv_v[key] = value
887          def __setitem__(self, key, value):
888              self.store[key] = value
889          def __delitem__(self, key):
890              self.store.pop(key)
891          def __iter__(self):
892              return iter(self.store)
893          def __len__(self):
894              len_extended = 0
895              if self.component.get("type"):
896                  types = self.component.get("types")
897                  for t, tv in types.items():
898                      for s in self._iter_extended(types.get(t, {})):
899                          len_extended += len(s.get("config_vars", {}))
900                      len_extended += len(tv.get("config_vars", {}))
901                  return len_extended
902              for s in self._iter_extended(self.component):
903                  len_extended += len(s.get("config_vars", {}))
904              return len_extended + (len(self.store) if self.store else 0)
905      def find_props(self, component, fail_silently=False):
906          if component.get("type") in ["trigger", "schema"]:
907              if "schema" not in component:
908                  return None
909              component = component.get("schema")
910          props = self.Props(self, component, fail_silently)
911          if props:
912              self.filled_props = False
913              self.accept_props = False
914              self.current_prop = None
915          return props
916  def handle_component(app, doctree, docname):
917      path = docname.split("/")
918      if path[0] == "components":
919          pass
920      elif docname not in CUSTOM_DOCS:
921          return
922      try:
923          v = SchemaGeneratorVisitor(app, doctree, docname)
924          doctree.walkabout(v)
925      except Exception as e:
926          err_str = f"In {docname}.rst: {str(e)}"
927          logger.warning(err_str)
928  def build_finished(app, exception):
929      for fname, contents in app.files.items():
930          f = open(SCHEMA_PATH + fname + ".json", "w", newline="\n")
931          if JSON_DUMP_PRETTY:
932              f.write(json.dumps(contents, indent=2))
933          else:
934              f.write(json.dumps(contents, separators=(",", ":")))
935      str = f"Documented: {statistics.props_documented} Enums: {statistics.enums_good}/{statistics.enums_bad}"
936      logger.info(str)
937  class SetObservable(dict):
938      def __init__(
939          self,
940          value,
941          setitem_callback=None,
942          inner_key=None,
943          original_dict=None,
944          *args,
945          **kwargs,
946      ):
947          super(SetObservable, self).__init__(value, *args, **kwargs)
948          self._setitem_callback = setitem_callback
949          self.inner_key = inner_key
950          self.original_dict = original_dict
951      def __setitem__(self, key, value):
952          if self._setitem_callback:
953              self._setitem_callback(self.inner_key, self.original_dict, key, value)
954          super(SetObservable, self).__setitem__(key, value)
955  def is_component_file(app: SchemaGeneratorVisitor, component):
956      if component == "core" or component == "automation":
957          component = "esphome"
958      return exists(SCHEMA_PATH + component + ".json")
959  def get_component_file(app: SchemaGeneratorVisitor, component):
960      if component == "core" or component == "automation":
961          component = "esphome"
962      if component not in app.files:
963          app.files[component] = read_file(component)
964      return app.files[component]
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_discovery.py</h3>
            <pre><code>1  #!/usr/bin/env python
2  from __future__ import absolute_import
3  __author__ = "jcgregorio@google.com (Joe Gregorio)"
4  from collections import defaultdict
5  import copy
6  import datetime
7  import io
8  import itertools
9  import json
10  import os
11  import pickle
12  import re
13  import sys
14  import unittest
15  from unittest import mock
16  import urllib
17  import google.api_core.exceptions
18  import google.auth.credentials
19  from google.auth.exceptions import MutualTLSChannelError
20  import google_auth_httplib2
21  import httplib2
22  from parameterized import parameterized
23  import uritemplate
24  try:
25      from oauth2client import GOOGLE_TOKEN_URI
26      from oauth2client.client import GoogleCredentials, OAuth2Credentials
27      HAS_OAUTH2CLIENT = True
28  except ImportError:
29      HAS_OAUTH2CLIENT = False
30  from googleapiclient import _helpers as util
31  from googleapiclient.discovery import (
32      DISCOVERY_URI,
33      MEDIA_BODY_PARAMETER_DEFAULT_VALUE,
34      MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE,
35      STACK_QUERY_PARAMETER_DEFAULT_VALUE,
36      STACK_QUERY_PARAMETERS,
37      V1_DISCOVERY_URI,
38      V2_DISCOVERY_URI,
39      ResourceMethodParameters,
40      _fix_up_media_path_base_url,
41      _fix_up_media_upload,
42      _fix_up_method_description,
43      _fix_up_parameters,
44      _urljoin,
45      build,
46      build_from_document,
47      key2param,
48  )
49  from googleapiclient.discovery_cache import DISCOVERY_DOC_MAX_AGE
50  from googleapiclient.discovery_cache.base import Cache
51  from googleapiclient.errors import (
52      HttpError,
53      InvalidJsonError,
54      MediaUploadSizeError,
55      ResumableUploadError,
56      UnacceptableMimeTypeError,
57      UnknownApiNameOrVersion,
58      UnknownFileType,
59  )
60  from googleapiclient.http import (
61      HttpMock,
62      HttpMockSequence,
63      MediaFileUpload,
64      MediaIoBaseUpload,
65      MediaUpload,
66      MediaUploadProgress,
67      build_http,
68      tunnel_patch,
69  )
70  from googleapiclient.model import JsonModel
71  from googleapiclient.schema import Schemas
72  DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
73  def assertUrisEqual(testcase, expected, actual):
74      expected = urllib.parse.urlparse(expected)
75      actual = urllib.parse.urlparse(actual)
76      testcase.assertEqual(expected.scheme, actual.scheme)
77      testcase.assertEqual(expected.netloc, actual.netloc)
78      testcase.assertEqual(expected.path, actual.path)
79      testcase.assertEqual(expected.params, actual.params)
80      testcase.assertEqual(expected.fragment, actual.fragment)
81      expected_query = urllib.parse.parse_qs(expected.query)
82      actual_query = urllib.parse.parse_qs(actual.query)
83      for name in list(expected_query.keys()):
84          testcase.assertEqual(expected_query[name], actual_query[name])
85      for name in list(actual_query.keys()):
86          testcase.assertEqual(expected_query[name], actual_query[name])
87  def assert_discovery_uri(testcase, actual, service_name, version, discovery):
88      params = {"api": service_name, "apiVersion": version}
89      expanded_requested_uri = uritemplate.expand(discovery, params)
90      assertUrisEqual(testcase, expanded_requested_uri, actual)
91  def validate_discovery_requests(testcase, http_mock, service_name, version, discovery):
92      testcase.assertTrue(len(http_mock.request_sequence) > 0)
93      if len(http_mock.request_sequence) > 0:
94          actual_uri = http_mock.request_sequence[-1][0]
95          assert_discovery_uri(testcase, actual_uri, service_name, version, discovery)
96  def datafile(filename):
97      return os.path.join(DATA_DIR, filename)
98  def read_datafile(filename, mode="r"):
99      with open(datafile(filename), mode=mode) as f:
100          return f.read()
101  class SetupHttplib2(unittest.TestCase):
102      def test_retries(self):
103          self.assertEqual(1, httplib2.RETRIES)
104  class Utilities(unittest.TestCase):
105      def setUp(self):
106          self.zoo_root_desc = json.loads(read_datafile("zoo.json", "r"))
107          self.zoo_get_method_desc = self.zoo_root_desc["methods"]["query"]
108          self.zoo_animals_resource = self.zoo_root_desc["resources"]["animals"]
109          self.zoo_insert_method_desc = self.zoo_animals_resource["methods"]["insert"]
110          self.zoo_schema = Schemas(self.zoo_root_desc)
111      def test_key2param(self):
112          self.assertEqual("max_results", key2param("max-results"))
113          self.assertEqual("x007_bond", key2param("007-bond"))
114      def _base_fix_up_parameters_test(self, method_desc, http_method, root_desc, schema):
115          self.assertEqual(method_desc["httpMethod"], http_method)
116          method_desc_copy = copy.deepcopy(method_desc)
117          self.assertEqual(method_desc, method_desc_copy)
118          parameters = _fix_up_parameters(
119              method_desc_copy, root_desc, http_method, schema
120          )
121          self.assertNotEqual(method_desc, method_desc_copy)
122          for param_name in STACK_QUERY_PARAMETERS:
123              self.assertEqual(
124                  STACK_QUERY_PARAMETER_DEFAULT_VALUE, parameters[param_name]
125              )
126          for param_name, value in root_desc.get("parameters", {}).items():
127              self.assertEqual(value, parameters[param_name])
128          return parameters
129      def test_fix_up_parameters_get(self):
130          parameters = self._base_fix_up_parameters_test(
131              self.zoo_get_method_desc, "GET", self.zoo_root_desc, self.zoo_schema
132          )
133          self.assertFalse("body" in parameters)
134      def test_fix_up_parameters_insert(self):
135          parameters = self._base_fix_up_parameters_test(
136              self.zoo_insert_method_desc, "POST", self.zoo_root_desc, self.zoo_schema
137          )
138          body = {"description": "The request body.", "type": "object", "$ref": "Animal"}
139          self.assertEqual(parameters["body"], body)
140      def test_fix_up_parameters_check_body(self):
141          dummy_root_desc = {}
142          dummy_schema = {
143              "Request": {
144                  "properties": {
145                      "description": "Required. Dummy parameter.",
146                      "type": "string",
147                  }
148              }
149          }
150          no_payload_http_method = "DELETE"
151          with_payload_http_method = "PUT"
152          invalid_method_desc = {"response": "Who cares"}
153          valid_method_desc = {
154              "request": {"key1": "value1", "key2": "value2", "$ref": "Request"}
155          }
156          parameters = _fix_up_parameters(
157              invalid_method_desc, dummy_root_desc, no_payload_http_method, dummy_schema
158          )
159          self.assertFalse("body" in parameters)
160          parameters = _fix_up_parameters(
161              valid_method_desc, dummy_root_desc, no_payload_http_method, dummy_schema
162          )
163          self.assertFalse("body" in parameters)
164          parameters = _fix_up_parameters(
165              invalid_method_desc, dummy_root_desc, with_payload_http_method, dummy_schema
166          )
167          self.assertFalse("body" in parameters)
168          parameters = _fix_up_parameters(
169              valid_method_desc, dummy_root_desc, with_payload_http_method, dummy_schema
170          )
171          body = {
172              "description": "The request body.",
173              "type": "object",
174              "$ref": "Request",
175              "key1": "value1",
176              "key2": "value2",
177          }
178          self.assertEqual(parameters["body"], body)
179      def test_fix_up_parameters_optional_body(self):
180          dummy_schema = {"Request": {"properties": {}}}
181          method_desc = {"request": {"$ref": "Request"}}
182          parameters = _fix_up_parameters(method_desc, {}, "POST", dummy_schema)
183      def _base_fix_up_method_description_test(
184          self,
185          method_desc,
186          initial_parameters,
187          final_parameters,
188          final_accept,
189          final_max_size,
190          final_media_path_url,
191      ):
192          fake_root_desc = {
193              "rootUrl": "http://root/",
194              "servicePath": "fake/",
195              "mtlsRootUrl": "http://root/",
196          }
197          fake_path_url = "fake-path/"
198          accept, max_size, media_path_url = _fix_up_media_upload(
199              method_desc, fake_root_desc, fake_path_url, initial_parameters
200          )
201          self.assertEqual(accept, final_accept)
202          self.assertEqual(max_size, final_max_size)
203          self.assertEqual(media_path_url, final_media_path_url)
204          self.assertEqual(initial_parameters, final_parameters)
205      def test_fix_up_media_upload_no_initial_invalid(self):
206          invalid_method_desc = {"response": "Who cares"}
207          self._base_fix_up_method_description_test(
208              invalid_method_desc, {}, {}, [], 0, None
209          )
210      def test_fix_up_media_upload_no_initial_valid_minimal(self):
211          valid_method_desc = {"mediaUpload": {"accept": []}}
212          final_parameters = {
213              "media_body": MEDIA_BODY_PARAMETER_DEFAULT_VALUE,
214              "media_mime_type": MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE,
215          }
216          self._base_fix_up_method_description_test(
217              valid_method_desc,
218              {},
219              final_parameters,
220              [],
221              0,
222              "http://root/upload/fake/fake-path/",
223          )
224      def test_fix_up_media_upload_no_initial_valid_full(self):
225          final_parameters = {
226              "media_body": MEDIA_BODY_PARAMETER_DEFAULT_VALUE,
227              "media_mime_type": MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE,
228          }
229          ten_gb = 10 * 2**30
230          self._base_fix_up_method_description_test(
231              valid_method_desc,
232              {},
233              final_parameters,
234              ten_gb,
235              "http://root/upload/fake/fake-path/",
236          )
237      def test_fix_up_media_upload_with_initial_invalid(self):
238          invalid_method_desc = {"response": "Who cares"}
239          initial_parameters = {"body": {}}
240          self._base_fix_up_method_description_test(
241              invalid_method_desc, initial_parameters, initial_parameters, [], 0, None
242          )
243      def test_fix_up_media_upload_with_initial_valid_minimal(self):
244          valid_method_desc = {"mediaUpload": {"accept": []}}
245          initial_parameters = {"body": {}}
246          final_parameters = {
247              "body": {},
248              "media_body": MEDIA_BODY_PARAMETER_DEFAULT_VALUE,
249              "media_mime_type": MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE,
250          }
251          self._base_fix_up_method_description_test(
252              valid_method_desc,
253              initial_parameters,
254              final_parameters,
255              [],
256              0,
257              "http://root/upload/fake/fake-path/",
258          )
259      def test_fix_up_media_upload_with_initial_valid_full(self):
260          initial_parameters = {"body": {}}
261          final_parameters = {
262              "body": {},
263              "media_body": MEDIA_BODY_PARAMETER_DEFAULT_VALUE,
264              "media_mime_type": MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE,
265          }
266          ten_gb = 10 * 2**30
267          self._base_fix_up_method_description_test(
268              valid_method_desc,
269              initial_parameters,
270              final_parameters,
271              ten_gb,
272              "http://root/upload/fake/fake-path/",
273          )
274      def test_fix_up_method_description_get(self):
275          result = _fix_up_method_description(
276              self.zoo_get_method_desc, self.zoo_root_desc, self.zoo_schema
277          )
278          path_url = "query"
279          http_method = "GET"
280          method_id = "bigquery.query"
281          accept = []
282          max_size = 0
283          media_path_url = None
284          self.assertEqual(
285              result, (path_url, http_method, method_id, accept, max_size, media_path_url)
286          )
287      def test_fix_up_method_description_insert(self):
288          result = _fix_up_method_description(
289              self.zoo_insert_method_desc, self.zoo_root_desc, self.zoo_schema
290          )
291          path_url = "animals"
292          http_method = "POST"
293          method_id = "zoo.animals.insert"
294          accept = ["image/png"]
295          max_size = 1024
296          media_path_url = "https://www.googleapis.com/upload/zoo/v1/animals"
297          self.assertEqual(
298              result, (path_url, http_method, method_id, accept, max_size, media_path_url)
299          )
300      def test_fix_up_media_path_base_url_same_netloc(self):
301          result = _fix_up_media_path_base_url(
302              "https://www.googleapis.com/upload/foo",
303              "https://www.googleapis.com/upload/bar",
304          )
305          self.assertEqual(result, "https://www.googleapis.com/upload/foo")
306      def test_fix_up_media_path_base_url_different_netloc(self):
307          result = _fix_up_media_path_base_url(
308              "https://www.googleapis.com/upload/foo",
309              "https://www.example.com/upload/bar",
310          )
311          self.assertEqual(result, "https://www.example.com/upload/foo")
312      def test_urljoin(self):
313          simple_bases = ["https://www.googleapis.com", "https://www.googleapis.com/"]
314          long_urls = ["foo/v1/bar:custom?alt=json", "/foo/v1/bar:custom?alt=json"]
315          long_bases = [
316              "https://www.googleapis.com/foo/v1",
317              "https://www.googleapis.com/foo/v1/",
318          ]
319          simple_urls = ["bar:custom?alt=json", "/bar:custom?alt=json"]
320          final_url = "https://www.googleapis.com/foo/v1/bar:custom?alt=json"
321          for base, url in itertools.product(simple_bases, long_urls):
322              self.assertEqual(final_url, _urljoin(base, url))
323          for base, url in itertools.product(long_bases, simple_urls):
324              self.assertEqual(final_url, _urljoin(base, url))
325      def test_ResourceMethodParameters_zoo_get(self):
326          parameters = ResourceMethodParameters(self.zoo_get_method_desc)
327          param_types = {
328              "a": "any",
329              "b": "boolean",
330              "e": "string",
331              "er": "string",
332              "i": "integer",
333              "n": "number",
334              "o": "object",
335              "q": "string",
336              "rr": "string",
337          }
338          keys = list(param_types.keys())
339          self.assertEqual(parameters.argmap, dict((key, key) for key in keys))
340          self.assertEqual(parameters.required_params, [])
341          self.assertEqual(sorted(parameters.repeated_params), ["er", "rr"])
342          self.assertEqual(parameters.pattern_params, {"rr": "[a-z]+"})
343          self.assertEqual(
344              sorted(parameters.query_params),
345              ["a", "b", "e", "er", "i", "n", "o", "q", "rr"],
346          )
347          self.assertEqual(parameters.path_params, set())
348          self.assertEqual(parameters.param_types, param_types)
349          enum_params = {"e": ["foo", "bar"], "er": ["one", "two", "three"]}
350          self.assertEqual(parameters.enum_params, enum_params)
351      def test_ResourceMethodParameters_zoo_animals_patch(self):
352          method_desc = self.zoo_animals_resource["methods"]["patch"]
353          parameters = ResourceMethodParameters(method_desc)
354          param_types = {"name": "string"}
355          keys = list(param_types.keys())
356          self.assertEqual(parameters.argmap, dict((key, key) for key in keys))
357          self.assertEqual(parameters.required_params, ["name"])
358          self.assertEqual(parameters.repeated_params, [])
359          self.assertEqual(parameters.pattern_params, {})
360          self.assertEqual(parameters.query_params, [])
361          self.assertEqual(parameters.path_params, set(["name"]))
362          self.assertEqual(parameters.param_types, param_types)
363          self.assertEqual(parameters.enum_params, {})
364  class Discovery(unittest.TestCase):
365      def test_discovery_http_is_closed(self):
366          http = HttpMock(datafile("malformed.json"), {"status": "200"})
367          service = build("plus", "v1", credentials=mock.sentinel.credentials)
368          http.close.assert_called_once()
369  class DiscoveryErrors(unittest.TestCase):
370      def test_tests_should_be_run_with_strict_positional_enforcement(self):
371          try:
372              plus = build("plus", "v1", None, static_discovery=False)
373              self.fail("should have raised a TypeError exception over missing http=.")
374          except TypeError:
375              pass
376      def test_failed_to_parse_discovery_json(self):
377          self.http = HttpMock(datafile("malformed.json"), {"status": "200"})
378          try:
379              plus = build(
380                  "plus",
381                  "v1",
382                  http=self.http,
383                  cache_discovery=False,
384                  static_discovery=False,
385              )
386              self.fail("should have raised an exception over malformed JSON.")
387          except InvalidJsonError:
388              pass
389      def test_unknown_api_name_or_version(self):
390          http = HttpMockSequence(
391              [
392                  ({"status": "404"}, read_datafile("zoo.json", "rb")),
393                  ({"status": "404"}, read_datafile("zoo.json", "rb")),
394              ]
395          )
396          with self.assertRaises(UnknownApiNameOrVersion):
397              plus = build("plus", "v1", http=http, cache_discovery=False)
398      def test_credentials_and_http_mutually_exclusive(self):
399          http = HttpMock(datafile("plus.json"), {"status": "200"})
400          with self.assertRaises(ValueError):
401              build(
402                  "plus",
403                  "v1",
404                  http=http,
405                  credentials=mock.sentinel.credentials,
406                  static_discovery=False,
407              )
408      def test_credentials_file_and_http_mutually_exclusive(self):
409          http = HttpMock(datafile("plus.json"), {"status": "200"})
410          with self.assertRaises(ValueError):
411              build(
412                  "plus",
413                  "v1",
414                  http=http,
415                  client_options=google.api_core.client_options.ClientOptions(
416                      credentials_file="credentials.json"
417                  ),
418                  static_discovery=False,
419              )
420      def test_credentials_and_credentials_file_mutually_exclusive(self):
421          with self.assertRaises(google.api_core.exceptions.DuplicateCredentialArgs):
422              build(
423                  "plus",
424                  "v1",
425                  credentials=mock.sentinel.credentials,
426                  client_options=google.api_core.client_options.ClientOptions(
427                      credentials_file="credentials.json"
428                  ),
429                  static_discovery=False,
430              )
431  class DiscoveryFromDocument(unittest.TestCase):
432      MOCK_CREDENTIALS = mock.Mock(spec=google.auth.credentials.Credentials)
433      def test_can_build_from_local_document(self):
434          discovery = read_datafile("plus.json")
435          plus = build_from_document(
436              discovery,
437              base="https://www.googleapis.com/",
438              credentials=self.MOCK_CREDENTIALS,
439          )
440          self.assertIsNotNone(plus)
441          self.assertTrue(hasattr(plus, "activities"))
442      def test_can_build_from_local_deserialized_document(self):
443          discovery = read_datafile("plus.json")
444          discovery = json.loads(discovery)
445          plus = build_from_document(
446              discovery,
447              base="https://www.googleapis.com/",
448              credentials=self.MOCK_CREDENTIALS,
449          )
450          self.assertIsNotNone(plus)
451          self.assertTrue(hasattr(plus, "activities"))
452      def test_building_with_base_remembers_base(self):
453          discovery = read_datafile("plus.json")
454          base = "https://www.example.com/"
455          plus = build_from_document(
456              discovery, base=base, credentials=self.MOCK_CREDENTIALS
457          )
458          self.assertEqual("https://www.googleapis.com/plus/v1/", plus._baseUrl)
459      def test_building_with_optional_http_with_authorization(self):
460          discovery = read_datafile("plus.json")
461          plus = build_from_document(
462              discovery,
463              base="https://www.googleapis.com/",
464              credentials=self.MOCK_CREDENTIALS,
465          )
466          self.assertIsInstance(plus._http, google_auth_httplib2.AuthorizedHttp)
467          self.assertIsInstance(plus._http.http, httplib2.Http)
468          self.assertIsInstance(plus._http.http.timeout, int)
469          self.assertGreater(plus._http.http.timeout, 0)
470      def test_building_with_optional_http_with_no_authorization(self):
471          discovery = read_datafile("plus.json")
472          discovery = json.loads(discovery)
473          discovery["auth"] = {}
474          discovery = json.dumps(discovery)
475          plus = build_from_document(
476              discovery, base="https://www.googleapis.com/", credentials=None
477          )
478          self.assertIsInstance(plus._http, httplib2.Http)
479          self.assertIsInstance(plus._http.timeout, int)
480          self.assertGreater(plus._http.timeout, 0)
481      def test_building_with_explicit_http(self):
482          http = HttpMock()
483          discovery = read_datafile("plus.json")
484          plus = build_from_document(
485              discovery, base="https://www.googleapis.com/", http=http
486          )
487          self.assertEqual(plus._http, http)
488      def test_building_with_developer_key_skips_adc(self):
489          discovery = read_datafile("plus.json")
490          plus = build_from_document(
491              discovery, base="https://www.googleapis.com/", developerKey="123"
492          )
493          self.assertIsInstance(plus._http, httplib2.Http)
494          self.assertNotIsInstance(plus._http, google_auth_httplib2.AuthorizedHttp)
495      def test_building_with_context_manager(self):
496          discovery = read_datafile("plus.json")
497          with mock.patch("httplib2.Http") as http:
498              with build_from_document(
499                  discovery,
500                  base="https://www.googleapis.com/",
501                  credentials=self.MOCK_CREDENTIALS,
502              ) as plus:
503                  self.assertIsNotNone(plus)
504                  self.assertTrue(hasattr(plus, "activities"))
505              plus._http.http.close.assert_called_once()
506      def test_resource_close(self):
507          discovery = read_datafile("plus.json")
508          with mock.patch("httplib2.Http", autospec=True) as httplib2_http:
509              http = httplib2_http()
510              plus = build_from_document(
511                  discovery,
512                  base="https://www.googleapis.com/",
513                  http=http,
514              )
515              plus.close()
516              http.close.assert_called_once()
517      def test_resource_close_authorized_http(self):
518          discovery = read_datafile("plus.json")
519          with mock.patch("google_auth_httplib2.AuthorizedHttp", autospec=True):
520              plus = build_from_document(
521                  discovery,
522                  base="https://www.googleapis.com/",
523                  credentials=self.MOCK_CREDENTIALS,
524              )
525              plus.close()
526              plus._http.close.assert_called_once()
527      def test_api_endpoint_override_from_client_options(self):
528          discovery = read_datafile("plus.json")
529          api_endpoint = "https://foo.googleapis.com/"
530          options = google.api_core.client_options.ClientOptions(
531              api_endpoint=api_endpoint
532          )
533          plus = build_from_document(
534              discovery, client_options=options, credentials=self.MOCK_CREDENTIALS
535          )
536          self.assertEqual(plus._baseUrl, api_endpoint)
537      def test_api_endpoint_override_from_client_options_mapping_object(self):
538          discovery = read_datafile("plus.json")
539          api_endpoint = "https://foo.googleapis.com/"
540          mapping_object = defaultdict(str)
541          mapping_object["api_endpoint"] = api_endpoint
542          plus = build_from_document(
543              discovery, client_options=mapping_object, credentials=self.MOCK_CREDENTIALS
544          )
545          self.assertEqual(plus._baseUrl, api_endpoint)
546      def test_api_endpoint_override_from_client_options_dict(self):
547          discovery = read_datafile("plus.json")
548          api_endpoint = "https://foo.googleapis.com/"
549          plus = build_from_document(
550              discovery,
551              client_options={"api_endpoint": api_endpoint},
552              credentials=self.MOCK_CREDENTIALS,
553          )
554          self.assertEqual(plus._baseUrl, api_endpoint)
555      def test_scopes_from_client_options(self):
556          discovery = read_datafile("plus.json")
557          with mock.patch("googleapiclient._auth.default_credentials") as default:
558              plus = build_from_document(
559                  discovery,
560                  client_options={"scopes": ["1", "2"]},
561              )
562          default.assert_called_once_with(scopes=["1", "2"], quota_project_id=None)
563      def test_quota_project_from_client_options(self):
564          discovery = read_datafile("plus.json")
565          with mock.patch("googleapiclient._auth.default_credentials") as default:
566              plus = build_from_document(
567                  discovery,
568                  client_options=google.api_core.client_options.ClientOptions(
569                      quota_project_id="my-project"
570                  ),
571              )
572          default.assert_called_once_with(scopes=None, quota_project_id="my-project")
573      def test_credentials_file_from_client_options(self):
574          discovery = read_datafile("plus.json")
575          with mock.patch("googleapiclient._auth.credentials_from_file") as default:
576              plus = build_from_document(
577                  discovery,
578                  client_options=google.api_core.client_options.ClientOptions(
579                      credentials_file="credentials.json"
580                  ),
581              )
582          default.assert_called_once_with(
583              "credentials.json", scopes=None, quota_project_id=None
584          )
585      def test_self_signed_jwt_enabled(self):
586          service_account_file_path = os.path.join(DATA_DIR, "service_account.json")
587          creds = google.oauth2.service_account.Credentials.from_service_account_file(
588              service_account_file_path
589          )
590          discovery = read_datafile("logging.json")
591          with mock.patch(
592              "google.oauth2.service_account.Credentials._create_self_signed_jwt"
593          ) as _create_self_signed_jwt:
594              build_from_document(
595                  discovery,
596                  credentials=creds,
597                  always_use_jwt_access=True,
598              )
599              _create_self_signed_jwt.assert_called_with(
600                  "https://logging.googleapis.com/"
601              )
602      def test_self_signed_jwt_disabled(self):
603          service_account_file_path = os.path.join(DATA_DIR, "service_account.json")
604          creds = google.oauth2.service_account.Credentials.from_service_account_file(
605              service_account_file_path
606          )
607          discovery = read_datafile("logging.json")
608          with mock.patch(
609              "google.oauth2.service_account.Credentials._create_self_signed_jwt"
610          ) as _create_self_signed_jwt:
611              build_from_document(
612                  discovery,
613                  credentials=creds,
614              )
615              _create_self_signed_jwt.assert_not_called()
616  REGULAR_ENDPOINT = "https://www.googleapis.com/plus/v1/"
617  MTLS_ENDPOINT = "https://www.mtls.googleapis.com/plus/v1/"
618  class DiscoveryFromDocumentMutualTLS(unittest.TestCase):
619      MOCK_CREDENTIALS = mock.Mock(spec=google.auth.credentials.Credentials)
620      ADC_CERT_PATH = "adc_cert_path"
621      ADC_KEY_PATH = "adc_key_path"
622      ADC_PASSPHRASE = "adc_passphrase"
623      def check_http_client_cert(self, resource, has_client_cert="false"):
624          if isinstance(resource._http, google_auth_httplib2.AuthorizedHttp):
625              certs = list(resource._http.http.certificates.iter(""))
626          else:
627              certs = list(resource._http.certificates.iter(""))
628          if has_client_cert == "true":
629              self.assertEqual(len(certs), 1)
630              self.assertEqual(
631                  certs[0], (self.ADC_KEY_PATH, self.ADC_CERT_PATH, self.ADC_PASSPHRASE)
632              )
633          else:
634              self.assertEqual(len(certs), 0)
635      def client_encrypted_cert_source(self):
636          return self.ADC_CERT_PATH, self.ADC_KEY_PATH, self.ADC_PASSPHRASE
637      @parameterized.expand(
638          [
639              ("never", "true"),
640              ("auto", "true"),
641              ("always", "true"),
642              ("never", "false"),
643              ("auto", "false"),
644              ("always", "false"),
645          ]
646      )
647      def test_mtls_not_trigger_if_http_provided(self, use_mtls_env, use_client_cert):
648          discovery = read_datafile("plus.json")
649          with mock.patch.dict(
650              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
651          ):
652              with mock.patch.dict(
653                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
654              ):
655                  plus = build_from_document(discovery, http=httplib2.Http())
656                  self.assertIsNotNone(plus)
657                  self.assertEqual(plus._baseUrl, REGULAR_ENDPOINT)
658                  self.check_http_client_cert(plus, has_client_cert="false")
659      @parameterized.expand(
660          [
661              ("never", "true"),
662              ("auto", "true"),
663              ("always", "true"),
664              ("never", "false"),
665              ("auto", "false"),
666              ("always", "false"),
667          ]
668      )
669      def test_exception_with_client_cert_source(self, use_mtls_env, use_client_cert):
670          discovery = read_datafile("plus.json")
671          with mock.patch.dict(
672              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
673          ):
674              with mock.patch.dict(
675                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
676              ):
677                  with self.assertRaises(MutualTLSChannelError):
678                      build_from_document(
679                          discovery,
680                          credentials=self.MOCK_CREDENTIALS,
681                          client_options={"client_cert_source": mock.Mock()},
682                      )
683      @parameterized.expand(
684          [
685              ("never", "true", REGULAR_ENDPOINT),
686              ("auto", "true", MTLS_ENDPOINT),
687              ("always", "true", MTLS_ENDPOINT),
688              ("never", "false", REGULAR_ENDPOINT),
689              ("auto", "false", REGULAR_ENDPOINT),
690              ("always", "false", MTLS_ENDPOINT),
691          ]
692      )
693      def test_mtls_with_provided_client_cert(
694          self, use_mtls_env, use_client_cert, base_url
695      ):
696          discovery = read_datafile("plus.json")
697          with mock.patch.dict(
698              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
699          ):
700              with mock.patch.dict(
701                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
702              ):
703                  plus = build_from_document(
704                      discovery,
705                      credentials=self.MOCK_CREDENTIALS,
706                      client_options={
707                          "client_encrypted_cert_source": self.client_encrypted_cert_source
708                      },
709                  )
710                  self.assertIsNotNone(plus)
711                  self.check_http_client_cert(plus, has_client_cert=use_client_cert)
712                  self.assertEqual(plus._baseUrl, base_url)
713      @parameterized.expand(
714          [
715              ("never", "true"),
716              ("auto", "true"),
717              ("always", "true"),
718              ("never", "false"),
719              ("auto", "false"),
720              ("always", "false"),
721          ]
722      )
723      def test_endpoint_not_switch(self, use_mtls_env, use_client_cert):
724          discovery = read_datafile("plus.json")
725          with mock.patch.dict(
726              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
727          ):
728              with mock.patch.dict(
729                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
730              ):
731                  plus = build_from_document(
732                      discovery,
733                      credentials=self.MOCK_CREDENTIALS,
734                      client_options={
735                          "api_endpoint": "https://foo.googleapis.com",
736                          "client_encrypted_cert_source": self.client_encrypted_cert_source,
737                      },
738                  )
739                  self.assertIsNotNone(plus)
740                  self.check_http_client_cert(plus, has_client_cert=use_client_cert)
741                  self.assertEqual(plus._baseUrl, "https://foo.googleapis.com")
742      @parameterized.expand(
743          [
744              ("never", "true", REGULAR_ENDPOINT),
745              ("auto", "true", MTLS_ENDPOINT),
746              ("always", "true", MTLS_ENDPOINT),
747              ("never", "false", REGULAR_ENDPOINT),
748              ("auto", "false", REGULAR_ENDPOINT),
749              ("always", "false", MTLS_ENDPOINT),
750          ]
751      )
752      @mock.patch(
753          "google.auth.transport.mtls.has_default_client_cert_source", autospec=True
754      )
755      @mock.patch(
756          "google.auth.transport.mtls.default_client_encrypted_cert_source", autospec=True
757      )
758      def test_mtls_with_default_client_cert(
759          self,
760          use_mtls_env,
761          use_client_cert,
762          base_url,
763          default_client_encrypted_cert_source,
764          has_default_client_cert_source,
765      ):
766          has_default_client_cert_source.return_value = True
767          default_client_encrypted_cert_source.return_value = (
768              self.client_encrypted_cert_source
769          )
770          discovery = read_datafile("plus.json")
771          with mock.patch.dict(
772              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
773          ):
774              with mock.patch.dict(
775                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
776              ):
777                  plus = build_from_document(
778                      discovery,
779                      credentials=self.MOCK_CREDENTIALS,
780                      adc_cert_path=self.ADC_CERT_PATH,
781                      adc_key_path=self.ADC_KEY_PATH,
782                  )
783                  self.assertIsNotNone(plus)
784                  self.check_http_client_cert(plus, has_client_cert=use_client_cert)
785                  self.assertEqual(plus._baseUrl, base_url)
786      @parameterized.expand(
787          [
788              ("never", "true", REGULAR_ENDPOINT),
789              ("auto", "true", REGULAR_ENDPOINT),
790              ("always", "true", MTLS_ENDPOINT),
791              ("never", "false", REGULAR_ENDPOINT),
792              ("auto", "false", REGULAR_ENDPOINT),
793              ("always", "false", MTLS_ENDPOINT),
794          ]
795      )
796      @mock.patch(
797          "google.auth.transport.mtls.has_default_client_cert_source", autospec=True
798      )
799      def test_mtls_with_no_client_cert(
800          self, use_mtls_env, use_client_cert, base_url, has_default_client_cert_source
801      ):
802          has_default_client_cert_source.return_value = False
803          discovery = read_datafile("plus.json")
804          with mock.patch.dict(
805              "os.environ", {"GOOGLE_API_USE_MTLS_ENDPOINT": use_mtls_env}
806          ):
807              with mock.patch.dict(
808                  "os.environ", {"GOOGLE_API_USE_CLIENT_CERTIFICATE": use_client_cert}
809              ):
810                  plus = build_from_document(
811                      discovery,
812                      credentials=self.MOCK_CREDENTIALS,
813                      adc_cert_path=self.ADC_CERT_PATH,
814                      adc_key_path=self.ADC_KEY_PATH,
815                  )
816                  self.assertIsNotNone(plus)
817                  self.check_http_client_cert(plus, has_client_cert="false")
818                  self.assertEqual(plus._baseUrl, base_url)
819  class DiscoveryFromHttp(unittest.TestCase):
820      def setUp(self):
821          self.old_environ = os.environ.copy()
822      def tearDown(self):
823          os.environ = self.old_environ
824      def test_userip_is_added_to_discovery_uri(self):
825          os.environ["REMOTE_ADDR"] = "10.0.0.1"
826          try:
827              http = HttpMockSequence(
828                  [({"status": "400"}, read_datafile("zoo.json", "rb"))]
829              )
830              zoo = build(
831                  "zoo",
832                  "v1",
833                  http=http,
834                  developerKey=None,
835                  discoveryServiceUrl="http://example.com",
836              )
837              self.fail("Should have raised an exception.")
838          except HttpError as e:
839              self.assertEqual(e.uri, "http://example.com?userIp=10.0.0.1")
840      def test_userip_missing_is_not_added_to_discovery_uri(self):
841          try:
842              http = HttpMockSequence(
843                  [({"status": "400"}, read_datafile("zoo.json", "rb"))]
844              )
845              zoo = build(
846                  "zoo",
847                  "v1",
848                  http=http,
849                  developerKey=None,
850                  discoveryServiceUrl="http://example.com",
851              )
852              self.fail("Should have raised an exception.")
853          except HttpError as e:
854              self.assertEqual(e.uri, "http://example.com")
855      def test_key_is_added_to_discovery_uri(self):
856          try:
857              http = HttpMockSequence(
858                  [({"status": "400"}, read_datafile("zoo.json", "rb"))]
859              )
860              zoo = build(
861                  "zoo",
862                  "v1",
863                  http=http,
864                  developerKey="foo",
865                  discoveryServiceUrl="http://example.com",
866                  static_discovery=False,
867              )
868              self.fail("Should have raised an exception.")
869          except HttpError as e:
870              self.assertEqual(e.uri, "http://example.com?key=foo")
871      def test_discovery_loading_from_v2_discovery_uri(self):
872          http = HttpMockSequence(
873              [
874                  ({"status": "404"}, "Not found"),
875                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
876              ]
877          )
878          zoo = build(
879              "zoo", "v1", http=http, cache_discovery=False, static_discovery=False
880          )
881          self.assertTrue(hasattr(zoo, "animals"))
882      def test_api_endpoint_override_from_client_options(self):
883          http = HttpMockSequence(
884              [
885                  ({"status": "404"}, "Not found"),
886                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
887              ]
888          )
889          api_endpoint = "https://foo.googleapis.com/"
890          options = google.api_core.client_options.ClientOptions(
891              api_endpoint=api_endpoint
892          )
893          zoo = build(
894              "zoo",
895              "v1",
896              http=http,
897              cache_discovery=False,
898              client_options=options,
899              static_discovery=False,
900          )
901          self.assertEqual(zoo._baseUrl, api_endpoint)
902      def test_api_endpoint_override_from_client_options_dict(self):
903          http = HttpMockSequence(
904              [
905                  ({"status": "404"}, "Not found"),
906                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
907              ]
908          )
909          api_endpoint = "https://foo.googleapis.com/"
910          zoo = build(
911              "zoo",
912              "v1",
913              http=http,
914              cache_discovery=False,
915              client_options={"api_endpoint": api_endpoint},
916              static_discovery=False,
917          )
918          self.assertEqual(zoo._baseUrl, api_endpoint)
919      def test_discovery_with_empty_version_uses_v2(self):
920          http = HttpMockSequence(
921              [
922                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
923              ]
924          )
925          build(
926              "zoo",
927              version=None,
928              http=http,
929              cache_discovery=False,
930              static_discovery=False,
931          )
932          validate_discovery_requests(self, http, "zoo", None, V2_DISCOVERY_URI)
933      def test_discovery_with_empty_version_preserves_custom_uri(self):
934          http = HttpMockSequence(
935              [
936                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
937              ]
938          )
939          custom_discovery_uri = "https://foo.bar/$discovery"
940          build(
941              "zoo",
942              version=None,
943              http=http,
944              cache_discovery=False,
945              discoveryServiceUrl=custom_discovery_uri,
946              static_discovery=False,
947          )
948          validate_discovery_requests(self, http, "zoo", None, custom_discovery_uri)
949      def test_discovery_with_valid_version_uses_v1(self):
950          http = HttpMockSequence(
951              [
952                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
953              ]
954          )
955          build(
956              "zoo",
957              version="v123",
958              http=http,
959              cache_discovery=False,
960              static_discovery=False,
961          )
962          validate_discovery_requests(self, http, "zoo", "v123", V1_DISCOVERY_URI)
963  class DiscoveryRetryFromHttp(unittest.TestCase):
964      def test_repeated_500_retries_and_fails(self):
965          http = HttpMockSequence(
966              [
967                  ({"status": "500"}, read_datafile("500.json", "rb")),
968                  ({"status": "503"}, read_datafile("503.json", "rb")),
969              ]
970          )
971          with self.assertRaises(HttpError):
972              with mock.patch("time.sleep") as mocked_sleep:
973                  build(
974                      "zoo",
975                      "v1",
976                      http=http,
977                      cache_discovery=False,
978                      static_discovery=False,
979                  )
980          mocked_sleep.assert_called_once()
981          validate_discovery_requests(self, http, "zoo", "v1", V1_DISCOVERY_URI)
982      def test_v2_repeated_500_retries_and_fails(self):
<span onclick='openModal()' class='match'>983          http = HttpMockSequence(
984              [
985                  ({"status": "404"}, "Not found"),  # last v1 discovery call
986                  ({"status": "500"}, read_datafile("500.json", "rb")),
987                  ({"status": "503"}, read_datafile("503.json", "rb")),
</span>988              ]
989          )
990          with self.assertRaises(HttpError):
991              with mock.patch("time.sleep") as mocked_sleep:
992                  build(
993                      "zoo",
994                      "v1",
995                      http=http,
996                      cache_discovery=False,
997                      static_discovery=False,
998                  )
999          mocked_sleep.assert_called_once()
1000          validate_discovery_requests(self, http, "zoo", "v1", V2_DISCOVERY_URI)
1001      def test_single_500_retries_and_succeeds(self):
1002          http = HttpMockSequence(
1003              [
1004                  ({"status": "500"}, read_datafile("500.json", "rb")),
1005                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
1006              ]
1007          )
1008          with mock.patch("time.sleep") as mocked_sleep:
1009              zoo = build(
1010                  "zoo", "v1", http=http, cache_discovery=False, static_discovery=False
1011              )
1012          self.assertTrue(hasattr(zoo, "animals"))
1013          mocked_sleep.assert_called_once()
1014          validate_discovery_requests(self, http, "zoo", "v1", V1_DISCOVERY_URI)
1015      def test_single_500_then_404_retries_and_succeeds(self):
1016          http = HttpMockSequence(
1017              [
1018                  ({"status": "500"}, read_datafile("500.json", "rb")),
1019                  ({"status": "404"}, "Not found"),  # last v1 discovery call
1020                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
1021              ]
1022          )
1023          with mock.patch("time.sleep") as mocked_sleep:
1024              zoo = build(
1025                  "zoo", "v1", http=http, cache_discovery=False, static_discovery=False
1026              )
1027          self.assertTrue(hasattr(zoo, "animals"))
1028          mocked_sleep.assert_called_once()
1029          validate_discovery_requests(self, http, "zoo", "v1", V2_DISCOVERY_URI)
1030  class DiscoveryFromAppEngineCache(unittest.TestCase):
1031      def setUp(self):
1032          self.old_environ = os.environ.copy()
1033          os.environ["GAE_ENV"] = "standard"
1034      def tearDown(self):
1035          os.environ = self.old_environ
1036      def test_appengine_memcache(self):
1037          self.orig_import = __import__
1038          self.mocked_api = mock.MagicMock()
1039          def import_mock(name, *args, **kwargs):
1040              if name == "google.appengine.api":
1041                  return self.mocked_api
1042              return self.orig_import(name, *args, **kwargs)
1043          import_fullname = "__builtin__.__import__"
1044          if sys.version_info[0] >= 3:
1045              import_fullname = "builtins.__import__"
1046          with mock.patch(import_fullname, side_effect=import_mock):
1047              namespace = "google-api-client"
1048              self.http = HttpMock(datafile("plus.json"), {"status": "200"})
1049              self.mocked_api.memcache.get.return_value = None
1050              plus = build("plus", "v1", http=self.http, static_discovery=False)
1051              url = "https://www.googleapis.com/discovery/v1/apis/plus/v1/rest"
1052              self.mocked_api.memcache.get.assert_called_once_with(
1053                  url, namespace=namespace
1054              )
1055              content = read_datafile("plus.json")
1056              self.mocked_api.memcache.set.assert_called_once_with(
1057                  url, content, time=DISCOVERY_DOC_MAX_AGE, namespace=namespace
1058              )
1059              self.mocked_api.memcache.get.return_value = content
1060              self.http = HttpMock(None, {"status": "200"})
1061              plus = build("plus", "v1", http=self.http, static_discovery=False)
1062              self.mocked_api.memcache.get.assert_has_calls(
1063                  [
1064                      mock.call(url, namespace=namespace),
1065                      mock.call(url, namespace=namespace),
1066                  ]
1067              )
1068              self.mocked_api.memcache.set.assert_called_once_with(
1069                  url, content, time=DISCOVERY_DOC_MAX_AGE, namespace=namespace
1070              )
1071  class DiscoveryFromStaticDocument(unittest.TestCase):
1072      def test_retrieve_from_local_when_static_discovery_true(self):
1073          http = HttpMockSequence([({"status": "400"}, "")])
1074          drive = build(
1075              "drive", "v3", http=http, cache_discovery=False, static_discovery=True
1076          )
1077          self.assertIsNotNone(drive)
1078          self.assertTrue(hasattr(drive, "files"))
1079      def test_retrieve_from_internet_when_static_discovery_false(self):
1080          http = HttpMockSequence([({"status": "400"}, "")])
1081          with self.assertRaises(HttpError):
1082              build(
1083                  "drive", "v3", http=http, cache_discovery=False, static_discovery=False
1084              )
1085      def test_unknown_api_when_static_discovery_true(self):
1086          with self.assertRaises(UnknownApiNameOrVersion):
1087              build("doesnotexist", "v3", cache_discovery=False, static_discovery=True)
1088  class DictCache(Cache):
1089      def __init__(self):
1090          self.d = {}
1091      def get(self, url):
1092          return self.d.get(url, None)
1093      def set(self, url, content):
1094          self.d[url] = content
1095      def contains(self, url):
1096          return url in self.d
1097  class DiscoveryFromFileCache(unittest.TestCase):
1098      def test_file_based_cache(self):
1099          cache = mock.Mock(wraps=DictCache())
1100          with mock.patch(
1101              "googleapiclient.discovery_cache.autodetect", return_value=cache
1102          ):
1103              self.http = HttpMock(datafile("plus.json"), {"status": "200"})
1104              plus = build("plus", "v1", http=self.http, static_discovery=False)
1105              url = "https://www.googleapis.com/discovery/v1/apis/plus/v1/rest"
1106              cache.get.assert_called_once_with(url)
1107              content = read_datafile("plus.json")
1108              cache.set.assert_called_once_with(url, content)
1109              self.assertTrue(cache.contains(url))
1110              self.http = HttpMock(None, {"status": "200"})
1111              plus = build("plus", "v1", http=self.http, static_discovery=False)
1112              cache.get.assert_has_calls([mock.call(url), mock.call(url)])
1113              cache.set.assert_called_once_with(url, content)
1114  class Discovery(unittest.TestCase):
1115      def test_method_error_checking(self):
1116          self.http = HttpMock(datafile("plus.json"), {"status": "200"})
1117          plus = build("plus", "v1", http=self.http, static_discovery=False)
1118          try:
1119              plus.activities().list()
1120              self.fail()
1121          except TypeError as e:
1122              self.assertTrue("Missing" in str(e))
1123          try:
1124              plus.activities().list(collection=None, userId=None)
1125              self.fail()
1126          except TypeError as e:
1127              self.assertTrue("Missing" in str(e))
1128          try:
1129              plus.activities().list(collection="not_a_collection_name", userId="me")
1130              self.fail()
1131          except TypeError as e:
1132              self.assertTrue("not an allowed value" in str(e))
1133          try:
1134              plus.activities().list(flubber=12)
1135              self.fail()
1136          except TypeError as e:
1137              self.assertTrue("unexpected" in str(e))
1138      def _check_query_types(self, request):
1139          parsed = urllib.parse.urlparse(request.uri)
1140          q = urllib.parse.parse_qs(parsed.query)
1141          self.assertEqual(q["q"], ["foo"])
1142          self.assertEqual(q["i"], ["1"])
1143          self.assertEqual(q["n"], ["1.0"])
1144          self.assertEqual(q["b"], ["false"])
1145          self.assertEqual(q["a"], ["[1, 2, 3]"])
1146          self.assertEqual(q["o"], ["{'a': 1}"])
1147          self.assertEqual(q["e"], ["bar"])
1148      def test_type_coercion(self):
1149          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1150          zoo = build("zoo", "v1", http=http, static_discovery=False)
1151          request = zoo.query(
1152              q="foo", i=1.0, n=1.0, b=0, a=[1, 2, 3], o={"a": 1}, e="bar"
1153          )
1154          self._check_query_types(request)
1155          request = zoo.query(
1156              q="foo", i=1, n=1, b=False, a=[1, 2, 3], o={"a": 1}, e="bar"
1157          )
1158          self._check_query_types(request)
1159          request = zoo.query(
1160              q="foo", i="1", n="1", b="", a=[1, 2, 3], o={"a": 1}, e="bar", er="two"
1161          )
1162          request = zoo.query(
1163              q="foo",
1164              i="1",
1165              n="1",
1166              b="",
1167              a=[1, 2, 3],
1168              o={"a": 1},
1169              e="bar",
1170              er=["one", "three"],
1171              rr=["foo", "bar"],
1172          )
1173          self._check_query_types(request)
1174          self.assertRaises(TypeError, zoo.query, er=["one", "five"])
1175      def test_optional_stack_query_parameters(self):
1176          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1177          zoo = build("zoo", "v1", http=http, static_discovery=False)
1178          request = zoo.query(trace="html", fields="description")
1179          parsed = urllib.parse.urlparse(request.uri)
1180          q = urllib.parse.parse_qs(parsed.query)
1181          self.assertEqual(q["trace"], ["html"])
1182          self.assertEqual(q["fields"], ["description"])
1183      def test_string_params_value_of_none_get_dropped(self):
1184          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1185          zoo = build("zoo", "v1", http=http, static_discovery=False)
1186          request = zoo.query(trace=None, fields="description")
1187          parsed = urllib.parse.urlparse(request.uri)
1188          q = urllib.parse.parse_qs(parsed.query)
1189          self.assertFalse("trace" in q)
1190      def test_model_added_query_parameters(self):
1191          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1192          zoo = build("zoo", "v1", http=http, static_discovery=False)
1193          request = zoo.animals().get(name="Lion")
1194          parsed = urllib.parse.urlparse(request.uri)
1195          q = urllib.parse.parse_qs(parsed.query)
1196          self.assertEqual(q["alt"], ["json"])
1197          self.assertEqual(request.headers["accept"], "application/json")
1198      def test_fallback_to_raw_model(self):
1199          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1200          zoo = build("zoo", "v1", http=http, static_discovery=False)
1201          request = zoo.animals().getmedia(name="Lion")
1202          parsed = urllib.parse.urlparse(request.uri)
1203          q = urllib.parse.parse_qs(parsed.query)
1204          self.assertTrue("alt" not in q)
1205      def test_patch(self):
1206          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1207          zoo = build("zoo", "v1", http=http, static_discovery=False)
1208          request = zoo.animals().patch(name="lion", body='{"description": "foo"}')
1209          self.assertEqual(request.method, "PATCH")
1210      def test_batch_request_from_discovery(self):
1211          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1212          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1213          batch_request = zoo.new_batch_http_request()
1214          self.assertEqual(
1215              batch_request._batch_uri, "https://www.googleapis.com/batchZoo"
1216          )
1217      def test_batch_request_from_default(self):
1218          self.http = HttpMock(datafile("plus.json"), {"status": "200"})
1219          plus = build(
1220              "plus", "v1", http=self.http, cache_discovery=False, static_discovery=False
1221          )
1222          batch_request = plus.new_batch_http_request()
1223          self.assertEqual(batch_request._batch_uri, "https://www.googleapis.com/batch")
1224      def test_tunnel_patch(self):
1225          http = HttpMockSequence(
1226              [
1227                  ({"status": "200"}, read_datafile("zoo.json", "rb")),
1228                  ({"status": "200"}, "echo_request_headers_as_json"),
1229              ]
1230          )
1231          http = tunnel_patch(http)
1232          zoo = build(
1233              "zoo", "v1", http=http, cache_discovery=False, static_discovery=False
1234          )
1235          resp = zoo.animals().patch(name="lion", body='{"description": "foo"}').execute()
1236          self.assertTrue("x-http-method-override" in resp)
1237      def test_plus_resources(self):
1238          self.http = HttpMock(datafile("plus.json"), {"status": "200"})
1239          plus = build("plus", "v1", http=self.http, static_discovery=False)
1240          self.assertTrue(getattr(plus, "activities"))
1241          self.assertTrue(getattr(plus, "people"))
1242      @unittest.skipIf(not HAS_OAUTH2CLIENT, "oauth2client unavailable.")
1243      def test_oauth2client_credentials(self):
1244          credentials = mock.Mock(spec=GoogleCredentials)
1245          credentials.create_scoped_required.return_value = False
1246          discovery = read_datafile("plus.json")
1247          service = build_from_document(discovery, credentials=credentials)
1248          self.assertEqual(service._http, credentials.authorize.return_value)
1249      def test_google_auth_credentials(self):
1250          credentials = mock.Mock(spec=google.auth.credentials.Credentials)
1251          discovery = read_datafile("plus.json")
1252          service = build_from_document(discovery, credentials=credentials)
1253          self.assertIsInstance(service._http, google_auth_httplib2.AuthorizedHttp)
1254          self.assertEqual(service._http.credentials, credentials)
1255      def test_no_scopes_no_credentials(self):
1256          discovery = read_datafile("zoo.json")
1257          service = build_from_document(discovery)
1258          self.assertIsInstance(service._http, httplib2.Http)
1259      def test_full_featured(self):
1260          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1261          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1262          self.assertTrue(getattr(zoo, "animals"))
1263          request = zoo.animals().list(name="bat", projection="full")
1264          parsed = urllib.parse.urlparse(request.uri)
1265          q = urllib.parse.parse_qs(parsed.query)
1266          self.assertEqual(q["name"], ["bat"])
1267          self.assertEqual(q["projection"], ["full"])
1268      def test_nested_resources(self):
1269          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1270          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1271          self.assertTrue(getattr(zoo, "animals"))
1272          request = zoo.my().favorites().list(max_results="5")
1273          parsed = urllib.parse.urlparse(request.uri)
1274          q = urllib.parse.parse_qs(parsed.query)
1275          self.assertEqual(q["max-results"], ["5"])
1276      def test_top_level_functions(self):
1277          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1278          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1279          self.assertTrue(getattr(zoo, "query"))
1280          request = zoo.query(q="foo")
1281          parsed = urllib.parse.urlparse(request.uri)
1282          q = urllib.parse.parse_qs(parsed.query)
1283          self.assertEqual(q["q"], ["foo"])
1284      def test_simple_media_uploads(self):
1285          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1286          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1287          doc = getattr(zoo.animals().insert, "__doc__")
1288          self.assertTrue("media_body" in doc)
1289      def test_simple_media_upload_no_max_size_provided(self):
1290          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1291          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1292          request = zoo.animals().crossbreed(media_body=datafile("small.png"))
1293          self.assertEqual("image/png", request.headers["content-type"])
1294          self.assertEqual(b"PNG", request.body[1:4])
1295      def test_simple_media_raise_correct_exceptions(self):
1296          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1297          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1298          try:
1299              zoo.animals().insert(media_body=datafile("smiley.png"))
1300              self.fail("should throw exception if media is too large.")
1301          except MediaUploadSizeError:
1302              pass
1303          try:
1304              zoo.animals().insert(media_body=datafile("small.jpg"))
1305              self.fail("should throw exception if mimetype is unacceptable.")
1306          except UnacceptableMimeTypeError:
1307              pass
1308      def test_simple_media_good_upload(self):
1309          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1310          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1311          request = zoo.animals().insert(media_body=datafile("small.png"))
1312          self.assertEqual("image/png", request.headers["content-type"])
1313          self.assertEqual(b"PNG", request.body[1:4])
1314          assertUrisEqual(
1315              self,
1316              "https://www.googleapis.com/upload/zoo/v1/animals?uploadType=media&alt=json",
1317              request.uri,
1318          )
1319      def test_simple_media_unknown_mimetype(self):
1320          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1321          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1322          try:
1323              zoo.animals().insert(media_body=datafile("small-png"))
1324              self.fail("should throw exception if mimetype is unknown.")
1325          except UnknownFileType:
1326              pass
1327          request = zoo.animals().insert(
1328              media_body=datafile("small-png"), media_mime_type="image/png"
1329          )
1330          self.assertEqual("image/png", request.headers["content-type"])
1331          self.assertEqual(b"PNG", request.body[1:4])
1332          assertUrisEqual(
1333              self,
1334              "https://www.googleapis.com/upload/zoo/v1/animals?uploadType=media&alt=json",
1335              request.uri,
1336          )
1337      def test_multipart_media_raise_correct_exceptions(self):
1338          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1339          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1340          try:
1341              zoo.animals().insert(media_body=datafile("smiley.png"), body={})
1342              self.fail("should throw exception if media is too large.")
1343          except MediaUploadSizeError:
1344              pass
1345          try:
1346              zoo.animals().insert(media_body=datafile("small.jpg"), body={})
1347              self.fail("should throw exception if mimetype is unacceptable.")
1348          except UnacceptableMimeTypeError:
1349              pass
1350      def test_multipart_media_good_upload(self, static_discovery=False):
1351          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1352          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1353          request = zoo.animals().insert(media_body=datafile("small.png"), body={})
1354          self.assertTrue(request.headers["content-type"].startswith("multipart/related"))
1355          contents = read_datafile("small.png", "rb")
1356          boundary = re.match(b"--=+([^=]+)", request.body).group(1)
1357          self.assertEqual(
1358              request.body.rstrip(b"\n"),  # Python 2.6 does not add a trailing \n
1359              b"--==============="
1360              + boundary
1361              + b"==\n"
1362              + b"Content-Type: application/json\n"
1363              + b"MIME-Version: 1.0\n\n"
1364              + b'{"data": {}}\n'
1365              + b"--==============="
1366              + boundary
1367              + b"==\n"
1368              + b"Content-Type: image/png\n"
1369              + b"MIME-Version: 1.0\n"
1370              + b"Content-Transfer-Encoding: binary\n\n"
1371              + contents
1372              + b"\n--==============="
1373              + boundary
1374              + b"==--",
1375          )
1376          assertUrisEqual(
1377              self,
1378              "https://www.googleapis.com/upload/zoo/v1/animals?uploadType=multipart&alt=json",
1379              request.uri,
1380          )
1381      def test_media_capable_method_without_media(self):
1382          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1383          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1384          request = zoo.animals().insert(body={})
1385          self.assertTrue(request.headers["content-type"], "application/json")
1386      def test_resumable_multipart_media_good_upload(self):
1387          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1388          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1389          media_upload = MediaFileUpload(datafile("small.png"), resumable=True)
1390          request = zoo.animals().insert(media_body=media_upload, body={})
1391          self.assertTrue(request.headers["content-type"].startswith("application/json"))
1392          self.assertEqual('{"data": {}}', request.body)
1393          self.assertEqual(media_upload, request.resumable)
1394          self.assertEqual("image/png", request.resumable.mimetype())
1395          self.assertNotEqual(request.body, None)
1396          self.assertEqual(request.resumable_uri, None)
1397          http = HttpMockSequence(
1398              [
1399                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1400                  ({"status": "308", "location": "http://upload.example.com/2"}, ""),
1401                  (
1402                      {
1403                          "status": "308",
1404                          "location": "http://upload.example.com/3",
1405                          "range": "0-12",
1406                      },
1407                      "",
1408                  ),
1409                  (
1410                      {
1411                          "status": "308",
1412                          "location": "http://upload.example.com/4",
1413                          "range": "0-%d" % (media_upload.size() - 2),
1414                      },
1415                      "",
1416                  ),
1417                  ({"status": "200"}, '{"foo": "bar"}'),
1418              ]
1419          )
1420          status, body = request.next_chunk(http=http)
1421          self.assertEqual(None, body)
1422          self.assertTrue(isinstance(status, MediaUploadProgress))
1423          self.assertEqual(0, status.resumable_progress)
1424          self.assertEqual(request.resumable_uri, "http://upload.example.com/2")
1425          self.assertEqual(media_upload, request.resumable)
1426          self.assertEqual(0, request.resumable_progress)
1427          status, body = request.next_chunk(http=http)
1428          self.assertEqual(request.resumable_uri, "http://upload.example.com/3")
1429          self.assertEqual(media_upload, request.resumable)
1430          self.assertEqual(13, request.resumable_progress)
1431          status, body = request.next_chunk(http=http)
1432          self.assertEqual(request.resumable_uri, "http://upload.example.com/4")
1433          self.assertEqual(media_upload.size() - 1, request.resumable_progress)
1434          self.assertEqual('{"data": {}}', request.body)
1435          status, body = request.next_chunk(http=http)
1436          self.assertEqual(body, {"foo": "bar"})
1437          self.assertEqual(status, None)
1438      def test_resumable_media_good_upload(self):
1439          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1440          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1441          media_upload = MediaFileUpload(datafile("small.png"), resumable=True)
1442          request = zoo.animals().insert(media_body=media_upload, body=None)
1443          self.assertEqual(media_upload, request.resumable)
1444          self.assertEqual("image/png", request.resumable.mimetype())
1445          self.assertEqual(request.body, None)
1446          self.assertEqual(request.resumable_uri, None)
1447          http = HttpMockSequence(
1448              [
1449                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1450                  (
1451                      {
1452                          "status": "308",
1453                          "location": "http://upload.example.com/2",
1454                          "range": "0-12",
1455                      },
1456                      "",
1457                  ),
1458                  (
1459                      {
1460                          "status": "308",
1461                          "location": "http://upload.example.com/3",
1462                          "range": "0-%d" % (media_upload.size() - 2),
1463                      },
1464                      "",
1465                  ),
1466                  ({"status": "200"}, '{"foo": "bar"}'),
1467              ]
1468          )
1469          status, body = request.next_chunk(http=http)
1470          self.assertEqual(None, body)
1471          self.assertTrue(isinstance(status, MediaUploadProgress))
1472          self.assertEqual(13, status.resumable_progress)
1473          self.assertEqual(request.resumable_uri, "http://upload.example.com/2")
1474          self.assertEqual(media_upload, request.resumable)
1475          self.assertEqual(13, request.resumable_progress)
1476          status, body = request.next_chunk(http=http)
1477          self.assertEqual(request.resumable_uri, "http://upload.example.com/3")
1478          self.assertEqual(media_upload.size() - 1, request.resumable_progress)
1479          self.assertEqual(request.body, None)
1480          status, body = request.next_chunk(http=http)
1481          self.assertEqual(body, {"foo": "bar"})
1482          self.assertEqual(status, None)
1483      def test_resumable_media_good_upload_from_execute(self):
1484          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1485          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1486          media_upload = MediaFileUpload(datafile("small.png"), resumable=True)
1487          request = zoo.animals().insert(media_body=media_upload, body=None)
1488          assertUrisEqual(
1489              self,
1490              "https://www.googleapis.com/upload/zoo/v1/animals?uploadType=resumable&alt=json",
1491              request.uri,
1492          )
1493          http = HttpMockSequence(
1494              [
1495                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1496                  (
1497                      {
1498                          "status": "308",
1499                          "location": "http://upload.example.com/2",
1500                          "range": "0-12",
1501                      },
1502                      "",
1503                  ),
1504                  (
1505                      {
1506                          "status": "308",
1507                          "location": "http://upload.example.com/3",
1508                          "range": "0-%d" % media_upload.size(),
1509                      },
1510                      "",
1511                  ),
1512                  ({"status": "200"}, '{"foo": "bar"}'),
1513              ]
1514          )
1515          body = request.execute(http=http)
1516          self.assertEqual(body, {"foo": "bar"})
1517      def test_resumable_media_fail_unknown_response_code_first_request(self):
1518          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1519          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1520          media_upload = MediaFileUpload(datafile("small.png"), resumable=True)
1521          request = zoo.animals().insert(media_body=media_upload, body=None)
1522          http = HttpMockSequence(
1523              [({"status": "400", "location": "http://upload.example.com"}, "")]
1524          )
1525          try:
1526              request.execute(http=http)
1527              self.fail("Should have raised ResumableUploadError.")
1528          except ResumableUploadError as e:
1529              self.assertEqual(400, e.resp.status)
1530      def test_resumable_media_fail_unknown_response_code_subsequent_request(self):
1531          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1532          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1533          media_upload = MediaFileUpload(datafile("small.png"), resumable=True)
1534          request = zoo.animals().insert(media_body=media_upload, body=None)
1535          http = HttpMockSequence(
1536              [
1537                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1538                  ({"status": "400"}, ""),
1539              ]
1540          )
1541          self.assertRaises(HttpError, request.execute, http=http)
1542          self.assertTrue(request._in_error_state)
1543          http = HttpMockSequence(
1544              [
1545                  ({"status": "308", "range": "0-5"}, ""),
1546                  ({"status": "308", "range": "0-6"}, ""),
1547              ]
1548          )
1549          status, body = request.next_chunk(http=http)
1550          self.assertEqual(
1551              status.resumable_progress,
1552              7,
1553              "Should have first checked length and then tried to PUT more.",
1554          )
1555          self.assertFalse(request._in_error_state)
1556          http = HttpMockSequence([({"status": "400"}, "")])
1557          self.assertRaises(HttpError, request.execute, http=http)
1558          self.assertTrue(request._in_error_state)
1559          http = HttpMockSequence([({"status": "200"}, '{"foo": "bar"}')])
1560          status, body = request.next_chunk(http=http)
1561          self.assertEqual(body, {"foo": "bar"})
1562      def test_media_io_base_stream_unlimited_chunksize_resume(self):
1563          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1564          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1565          fd = io.BytesIO(b'01234"56789"')
1566          media_upload = MediaIoBaseUpload(
1567              fd=fd, mimetype="text/plain", chunksize=-1, resumable=True
1568          )
1569          request = zoo.animals().insert(media_body=media_upload, body=None)
1570          http = HttpMockSequence(
1571              [
1572                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1573                  (
1574                      {
1575                          "status": "308",
1576                          "location": "http://upload.example.com/2",
1577                          "range": "0-4",
1578                      },
1579                      "",
1580                  ),
1581                  ({"status": "200"}, "echo_request_body"),
1582              ]
1583          )
1584          body = request.execute(http=http)
1585          self.assertEqual("56789", body)
1586      def test_media_io_base_stream_chunksize_resume(self):
1587          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1588          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1589          fd = io.BytesIO(b"0123456789")
1590          media_upload = MediaIoBaseUpload(
1591              fd=fd, mimetype="text/plain", chunksize=5, resumable=True
1592          )
1593          request = zoo.animals().insert(media_body=media_upload, body=None)
1594          http = HttpMockSequence(
1595              [
1596                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1597                  ({"status": "400"}, "echo_request_body"),
1598              ]
1599          )
1600          try:
1601              body = request.execute(http=http)
1602          except HttpError as e:
1603              self.assertEqual(b"01234", e.content)
1604      def test_resumable_media_handle_uploads_of_unknown_size(self):
1605          http = HttpMockSequence(
1606              [
1607                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1608                  ({"status": "200"}, "echo_request_headers_as_json"),
1609              ]
1610          )
1611          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1612          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1613          class IoBaseUnknownLength(MediaUpload):
1614              def chunksize(self):
1615                  return 10
1616              def mimetype(self):
1617                  return "image/png"
1618              def size(self):
1619                  return None
1620              def resumable(self):
1621                  return True
1622              def getbytes(self, begin, length):
1623                  return "0123456789"
1624          upload = IoBaseUnknownLength()
1625          request = zoo.animals().insert(media_body=upload, body=None)
1626          status, body = request.next_chunk(http=http)
1627      def test_resumable_media_no_streaming_on_unsupported_platforms(self):
1628          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1629          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1630          class IoBaseHasStream(MediaUpload):
1631              def chunksize(self):
1632                  return 10
1633              def mimetype(self):
1634                  return "image/png"
1635              def size(self):
1636                  return None
1637              def resumable(self):
1638                  return True
1639              def getbytes(self, begin, length):
1640                  return "0123456789"
1641              def has_stream(self):
1642                  return True
1643              def stream(self):
1644                  raise NotImplementedError()
1645          upload = IoBaseHasStream()
1646          orig_version = sys.version_info
1647          sys.version_info = (2, 6, 5, "final", 0)
1648          request = zoo.animals().insert(media_body=upload, body=None)
1649          http = HttpMockSequence(
1650              [
1651                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1652                  ({"status": "200"}, "echo_request_headers_as_json"),
1653              ]
1654          )
1655          self.assertRaises(NotImplementedError, request.next_chunk, http=http)
1656          sys.version_info = orig_version
1657      def test_resumable_media_handle_uploads_of_unknown_size_eof(self):
1658          http = HttpMockSequence(
1659              [
1660                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1661                  ({"status": "200"}, "echo_request_headers_as_json"),
1662              ]
1663          )
1664          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1665          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1666          fd = io.BytesIO(b"data goes here")
1667          upload = MediaIoBaseUpload(
1668              fd=fd, mimetype="image/png", chunksize=15, resumable=True
1669          )
1670          request = zoo.animals().insert(media_body=upload, body=None)
1671          status, body = request.next_chunk(http=http)
1672          self.assertEqual(
1673              body, {"Content-Range": "bytes 0-13/14", "Content-Length": "14"}
1674          )
1675      def test_resumable_media_handle_resume_of_upload_of_unknown_size(self):
1676          http = HttpMockSequence(
1677              [
1678                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1679                  ({"status": "400"}, ""),
1680              ]
1681          )
1682          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1683          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1684          fd = io.BytesIO(b"data goes here")
1685          upload = MediaIoBaseUpload(
1686              fd=fd, mimetype="image/png", chunksize=500, resumable=True
1687          )
1688          request = zoo.animals().insert(media_body=upload, body=None)
1689          self.assertRaises(HttpError, request.next_chunk, http=http)
1690          http = HttpMockSequence(
1691              [({"status": "400", "range": "0-5"}, "echo_request_headers_as_json")]
1692          )
1693          try:
1694              request.next_chunk(http=http)
1695          except HttpError as e:
1696              self.assertEqual(
1697                  expected,
1698                  json.loads(e.content.decode("utf-8")),
1699                  "Should send an empty body when requesting the current upload status.",
1700              )
1701      def test_pickle(self):
1702          sorted_resource_keys = [
1703              "_baseUrl",
1704              "_developerKey",
1705              "_dynamic_attrs",
1706              "_http",
1707              "_model",
1708              "_requestBuilder",
1709              "_resourceDesc",
1710              "_rootDesc",
1711              "_schema",
1712              "animals",
1713              "global_",
1714              "load",
1715              "loadNoTemplate",
1716              "my",
1717              "new_batch_http_request",
1718              "query",
1719              "scopedAnimals",
1720          ]
1721          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1722          zoo = build("zoo", "v1", http=http, static_discovery=False)
1723          self.assertEqual(sorted(zoo.__dict__.keys()), sorted_resource_keys)
1724          pickled_zoo = pickle.dumps(zoo)
1725          new_zoo = pickle.loads(pickled_zoo)
1726          self.assertEqual(sorted(new_zoo.__dict__.keys()), sorted_resource_keys)
1727          self.assertTrue(hasattr(new_zoo, "animals"))
1728          self.assertTrue(callable(new_zoo.animals))
1729          self.assertTrue(hasattr(new_zoo, "global_"))
1730          self.assertTrue(callable(new_zoo.global_))
1731          self.assertTrue(hasattr(new_zoo, "load"))
1732          self.assertTrue(callable(new_zoo.load))
1733          self.assertTrue(hasattr(new_zoo, "loadNoTemplate"))
1734          self.assertTrue(callable(new_zoo.loadNoTemplate))
1735          self.assertTrue(hasattr(new_zoo, "my"))
1736          self.assertTrue(callable(new_zoo.my))
1737          self.assertTrue(hasattr(new_zoo, "query"))
1738          self.assertTrue(callable(new_zoo.query))
1739          self.assertTrue(hasattr(new_zoo, "scopedAnimals"))
1740          self.assertTrue(callable(new_zoo.scopedAnimals))
1741          self.assertEqual(sorted(zoo._dynamic_attrs), sorted(new_zoo._dynamic_attrs))
1742          self.assertEqual(zoo._baseUrl, new_zoo._baseUrl)
1743          self.assertEqual(zoo._developerKey, new_zoo._developerKey)
1744          self.assertEqual(zoo._requestBuilder, new_zoo._requestBuilder)
1745          self.assertEqual(zoo._resourceDesc, new_zoo._resourceDesc)
1746          self.assertEqual(zoo._rootDesc, new_zoo._rootDesc)
1747      def _dummy_zoo_request(self):
1748          zoo_contents = read_datafile("zoo.json")
1749          zoo_uri = uritemplate.expand(DISCOVERY_URI, {"api": "zoo", "apiVersion": "v1"})
1750          if "REMOTE_ADDR" in os.environ:
1751              zoo_uri = util._add_query_parameter(
1752                  zoo_uri, "userIp", os.environ["REMOTE_ADDR"]
1753              )
1754          http = build_http()
1755          original_request = http.request
1756          def wrapped_request(uri, method="GET", *args, **kwargs):
1757              if uri == zoo_uri:
1758                  return httplib2.Response({"status": "200"}), zoo_contents
1759              return original_request(uri, method=method, *args, **kwargs)
1760          http.request = wrapped_request
1761          return http
1762      def _dummy_token(self):
1763          access_token = "foo"
1764          client_id = "some_client_id"
1765          client_secret = "cOuDdkfjxxnv+"
1766          refresh_token = "1/0/a.df219fjls0"
1767          token_expiry = datetime.datetime.utcnow()
1768          user_agent = "refresh_checker/1.0"
1769          return OAuth2Credentials(
1770              access_token,
1771              client_id,
1772              client_secret,
1773              refresh_token,
1774              token_expiry,
1775              GOOGLE_TOKEN_URI,
1776              user_agent,
1777          )
1778      @unittest.skipIf(not HAS_OAUTH2CLIENT, "oauth2client unavailable.")
1779      def test_pickle_with_credentials(self):
1780          credentials = self._dummy_token()
1781          http = self._dummy_zoo_request()
1782          http = credentials.authorize(http)
1783          self.assertTrue(hasattr(http.request, "credentials"))
1784          zoo = build("zoo", "v1", http=http, static_discovery=False)
1785          pickled_zoo = pickle.dumps(zoo)
1786          new_zoo = pickle.loads(pickled_zoo)
1787          self.assertEqual(sorted(zoo.__dict__.keys()), sorted(new_zoo.__dict__.keys()))
1788          new_http = new_zoo._http
1789          self.assertFalse(hasattr(new_http.request, "credentials"))
1790      def test_resumable_media_upload_no_content(self):
1791          self.http = HttpMock(datafile("zoo.json"), {"status": "200"})
1792          zoo = build("zoo", "v1", http=self.http, static_discovery=False)
1793          media_upload = MediaFileUpload(datafile("empty"), resumable=True)
1794          request = zoo.animals().insert(media_body=media_upload, body=None)
1795          self.assertEqual(media_upload, request.resumable)
1796          self.assertEqual(request.body, None)
1797          self.assertEqual(request.resumable_uri, None)
1798          http = HttpMockSequence(
1799              [
1800                  ({"status": "200", "location": "http://upload.example.com"}, ""),
1801                  (
1802                      {
1803                          "status": "308",
1804                          "location": "http://upload.example.com/2",
1805                          "range": "0-0",
1806                      },
1807                      "",
1808                  ),
1809              ]
1810          )
1811          status, body = request.next_chunk(http=http)
1812          self.assertEqual(None, body)
1813          self.assertTrue(isinstance(status, MediaUploadProgress))
1814          self.assertEqual(0, status.progress())
1815  class Next(unittest.TestCase):
1816      def test_next_successful_none_on_no_next_page_token(self):
1817          self.http = HttpMock(datafile("tasks.json"), {"status": "200"})
1818          tasks = build("tasks", "v1", http=self.http)
1819          request = tasks.tasklists().list()
1820          self.assertEqual(None, tasks.tasklists().list_next(request, {}))
1821      def test_next_successful_none_on_empty_page_token(self):
1822          self.http = HttpMock(datafile("tasks.json"), {"status": "200"})
1823          tasks = build("tasks", "v1", http=self.http)
1824          request = tasks.tasklists().list()
1825          next_request = tasks.tasklists().list_next(request, {"nextPageToken": ""})
1826          self.assertEqual(None, next_request)
1827      def test_next_successful_with_next_page_token(self):
1828          self.http = HttpMock(datafile("tasks.json"), {"status": "200"})
1829          tasks = build("tasks", "v1", http=self.http)
1830          request = tasks.tasklists().list()
1831          next_request = tasks.tasklists().list_next(request, {"nextPageToken": "123abc"})
1832          parsed = urllib.parse.urlparse(next_request.uri)
1833          q = urllib.parse.parse_qs(parsed.query)
1834          self.assertEqual(q["pageToken"][0], "123abc")
1835      def test_next_successful_with_next_page_token_alternate_name(self):
1836          self.http = HttpMock(datafile("bigquery.json"), {"status": "200"})
1837          bigquery = build("bigquery", "v2", http=self.http)
1838          request = bigquery.tabledata().list(datasetId="", projectId="", tableId="")
1839          next_request = bigquery.tabledata().list_next(request, {"pageToken": "123abc"})
1840          parsed = urllib.parse.urlparse(next_request.uri)
1841          q = urllib.parse.parse_qs(parsed.query)
1842          self.assertEqual(q["pageToken"][0], "123abc")
1843      def test_next_successful_with_next_page_token_in_body(self):
1844          self.http = HttpMock(datafile("logging.json"), {"status": "200"})
1845          logging = build("logging", "v2", http=self.http)
1846          request = logging.entries().list(body={})
1847          next_request = logging.entries().list_next(request, {"nextPageToken": "123abc"})
1848          body = JsonModel().deserialize(next_request.body)
1849          self.assertEqual(body["pageToken"], "123abc")
1850          self.assertEqual(next_request.body_size, len(next_request.body))
1851      def test_next_with_method_with_no_properties(self):
1852          self.http = HttpMock(datafile("latitude.json"), {"status": "200"})
1853          service = build("latitude", "v1", http=self.http, static_discovery=False)
1854          service.currentLocation().get()
1855      def test_next_nonexistent_with_no_next_page_token(self):
1856          self.http = HttpMock(datafile("drive.json"), {"status": "200"})
1857          drive = build("drive", "v3", http=self.http)
1858          drive.changes().watch(body={})
1859          self.assertFalse(callable(getattr(drive.changes(), "watch_next", None)))
1860      def test_next_successful_with_next_page_token_required(self):
1861          self.http = HttpMock(datafile("drive.json"), {"status": "200"})
1862          drive = build("drive", "v3", http=self.http)
1863          request = drive.changes().list(pageToken="startPageToken")
1864          next_request = drive.changes().list_next(request, {"nextPageToken": "123abc"})
1865          parsed = urllib.parse.urlparse(next_request.uri)
1866          q = urllib.parse.parse_qs(parsed.query)
1867          self.assertEqual(q["pageToken"][0], "123abc")
1868  class MediaGet(unittest.TestCase):
1869      def test_get_media(self):
1870          http = HttpMock(datafile("zoo.json"), {"status": "200"})
1871          zoo = build("zoo", "v1", http=http, static_discovery=False)
1872          request = zoo.animals().get_media(name="Lion")
1873          parsed = urllib.parse.urlparse(request.uri)
1874          q = urllib.parse.parse_qs(parsed.query)
1875          self.assertEqual(q["alt"], ["media"])
1876          http = HttpMockSequence([({"status": "200"}, "standing in for media")])
1877          response = request.execute(http=http)
1878          self.assertEqual(b"standing in for media", response)
1879  if __name__ == "__main__":
1880      unittest.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_discovery.py</div>
                </div>
                <div class="column column_space"><pre><code>239              platform = get_component_file(self.app, platformName)
240              platform[platformName]["components"][componentName.lower()][
</pre></code></div>
                <div class="column column_space"><pre><code>983          http = HttpMockSequence(
984              [
985                  ({"status": "404"}, "Not found"),  # last v1 discovery call
986                  ({"status": "500"}, read_datafile("500.json", "rb")),
987                  ({"status": "503"}, read_datafile("503.json", "rb")),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    