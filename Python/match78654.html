<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_zcbuildout_1.py (4.927007%)<th>simple_httpclient_test.py (3.5952065%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-19)<td><a href="#" name="0">(2-21)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(419-422)<td><a href="#" name="1">(393-397)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(408-415)<td><a href="#" name="2">(220-222)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(201-203)<td><a href="#" name="3">(309-312)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zcbuildout_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import shutil
3 import subprocess
4 import tempfile
5 import urllib.error
6 import urllib.request
7 import pytest
8 import salt.modules.cmdmod as cmd
9 import salt.modules.virtualenv_mod
10 import salt.modules.zcbuildout as buildout
11 import salt.utils.files
12 import salt.utils.path
13 import salt.utils.platform
14 from tests.support.helpers import patched_environ
15 from tests.support.mixins import LoaderModuleMockMixin
16 from tests.support.runtests import RUNTIME_VARS
17 from</b></font> tests.support.unit import TestCase, skipIf
18 KNOWN_VIRTUALENV_BINARY_NAMES = (
19     "virtualenv",
20     "virtualenv2",
21     "virtualenv-2.6",
22     "virtualenv-2.7",
23 )
24 BOOT_INIT = {
25     1: ["var/ver/1/bootstrap/bootstrap.py"],
26     2: ["var/ver/2/bootstrap/bootstrap.py", "b/bootstrap.py"],
27 }
28 log = logging.getLogger(__name__)
29 def download_to(url, dest):
30     req = urllib.request.Request(url)
31     req.add_header(
32         "User-Agent",
33         "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
34     )
35     with salt.utils.files.fopen(dest, "wb") as fic:
36         fic.write(urllib.request.urlopen(req, timeout=10).read())
37 class Base(TestCase, LoaderModuleMockMixin):
38     def setup_loader_modules(self):
39         return {
40             buildout: {
41                 "__salt__": {
42                     "cmd.run_all": cmd.run_all,
43                     "cmd.run": cmd.run,
44                     "cmd.retcode": cmd.retcode,
45                 }
46             }
47         }
48     @classmethod
49     def setUpClass(cls):
50         if not os.path.isdir(RUNTIME_VARS.TMP):
51             os.makedirs(RUNTIME_VARS.TMP)
52         cls.root = os.path.join(RUNTIME_VARS.BASE_FILES, "buildout")
53         cls.rdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
54         cls.tdir = os.path.join(cls.rdir, "test")
55         for idx, url in buildout._URL_VERSIONS.items():
56             log.debug("Downloading bootstrap from %s", url)
57             dest = os.path.join(cls.rdir, "{}_bootstrap.py".format(idx))
58             try:
59                 download_to(url, dest)
60             except urllib.error.URLError as exc:
61                 log.debug("Failed to download %s: %s", url, exc)
62         cls.ppy_st = os.path.join(cls.rdir, "psetuptools")
63         if salt.utils.platform.is_windows():
64             cls.bin_st = os.path.join(cls.ppy_st, "Scripts")
65             cls.py_st = os.path.join(cls.bin_st, "python")
66         else:
67             cls.bin_st = os.path.join(cls.ppy_st, "bin")
68             cls.py_st = os.path.join(cls.bin_st, "python")
69         subprocess.check_call(
70             [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_st]
71         )
72         subprocess.check_call(
73             [os.path.join(cls.bin_st, "pip"), "install", "-U", "setuptools&lt;50.0.0"]
74         )
75         subprocess.check_call(
76             [os.path.join(cls.bin_st, "easy_install"), "-U", "distribute"]
77         )
78     def setUp(self):
79         if salt.utils.platform.is_darwin():
80             self.patched_environ = patched_environ(__cleanup__=["__PYVENV_LAUNCHER__"])
81             self.patched_environ.__enter__()
82             self.addCleanup(self.patched_environ.__exit__)
83         super().setUp()
84         self._remove_dir()
85         shutil.copytree(self.root, self.tdir)
86         for idx in BOOT_INIT:
87             path = os.path.join(self.rdir, "{}_bootstrap.py".format(idx))
88             for fname in BOOT_INIT[idx]:
89                 shutil.copy2(path, os.path.join(self.tdir, fname))
90     def tearDown(self):
91         super().tearDown()
92         self._remove_dir()
93     def _remove_dir(self):
94         if os.path.isdir(self.tdir):
95             shutil.rmtree(self.tdir)
96 @skipIf(
97     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
98     "The 'virtualenv' packaged needs to be installed",
99 )
100 @pytest.mark.requires_network
101 class BuildoutTestCase(Base):
102     @pytest.mark.slow_test
103     def test_onlyif_unless(self):
104         b_dir = os.path.join(self.tdir, "b")
105         ret = buildout.buildout(b_dir, onlyif=RUNTIME_VARS.SHELL_FALSE_PATH)
106         self.assertTrue(ret["comment"] == "onlyif condition is false")
107         self.assertTrue(ret["status"] is True)
108         ret = buildout.buildout(b_dir, unless=RUNTIME_VARS.SHELL_TRUE_PATH)
109         self.assertTrue(ret["comment"] == "unless condition is true")
110         self.assertTrue(ret["status"] is True)
111     @pytest.mark.slow_test
112     def test_salt_callback(self):
113         @buildout._salt_callback
114         def callback1(a, b=1):
115             for i in buildout.LOG.levels:
116                 getattr(buildout.LOG, i)("{}bar".format(i[0]))
117             return "foo"
118         def callback2(a, b=1):
119             raise Exception("foo")
120         ret1 = callback1(1, b=3)
121         ret2 = buildout._salt_callback(callback2)(2, b=6)
122         self.assertEqual(ret2["status"], False)
123         self.assertTrue(ret2["logs_by_level"]["error"][0].startswith("Traceback"))
124         self.assertTrue("Unexpected response from buildout" in ret2["comment"])
125         self.assertEqual(ret2["out"], None)
126         for l in buildout.LOG.levels:
127             self.assertTrue(0 == len(buildout.LOG.by_level[l]))
128     def test_get_bootstrap_url(self):
129         for path in [
130             os<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.join(self.tdir, "var/ver/1/dumppicked"),
131             os.path.join(self.tdir, "var/ver/1/bootstrap"),
132             os.path.join(self.</b></font>tdir, "var/ver/1/versions"),
133         ]:
134             self.assertEqual(
135                 buildout._URL_VERSIONS[1],
136                 buildout._get_bootstrap_url(path),
137                 "b1 url for {}".format(path),
138             )
139         for path in [
140             os.path.join(self.tdir, "/non/existing"),
141             os.path.join(self.tdir, "var/ver/2/versions"),
142             os.path.join(self.tdir, "var/ver/2/bootstrap"),
143             os.path.join(self.tdir, "var/ver/2/default"),
144         ]:
145             self.assertEqual(
146                 buildout._URL_VERSIONS[2],
147                 buildout._get_bootstrap_url(path),
148                 "b2 url for {}".format(path),
149             )
150     @pytest.mark.slow_test
151     def test_get_buildout_ver(self):
152         for path in [
153             os.path.join(self.tdir, "var/ver/1/dumppicked"),
154             os.path.join(self.tdir, "var/ver/1/bootstrap"),
155             os.path.join(self.tdir, "var/ver/1/versions"),
156         ]:
157             self.assertEqual(
158                 1, buildout._get_buildout_ver(path), "1 for {}".format(path)
159             )
160         for path in [
161             os.path.join(self.tdir, "/non/existing"),
162             os.path.join(self.tdir, "var/ver/2/versions"),
163             os.path.join(self.tdir, "var/ver/2/bootstrap"),
164             os.path.join(self.tdir, "var/ver/2/default"),
165         ]:
166             self.assertEqual(
167                 2, buildout._get_buildout_ver(path), "2 for {}".format(path)
168             )
169     @pytest.mark.slow_test
170     def test_get_bootstrap_content(self):
171         self.assertEqual(
172             "",
173             buildout._get_bootstrap_content(os.path.join(self.tdir, "non", "existing")),
174         )
175         self.assertEqual(
176             "",
177             buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "1")),
178         )
179         self.assertEqual(
180             "foo{}".format(os.linesep),
181             buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "2")),
182         )
183     @pytest.mark.slow_test
184     def test_logger_clean(self):
185         buildout.LOG.clear()
186         self.assertTrue(
187             True
188             not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
189         )
190         buildout.LOG.info("foo")
191         self.assertTrue(
192             True in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
193         )
194         buildout.LOG.clear()
195         self.assertTrue(
196             True
197             not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
198         )
199     @pytest.mark.slow_test
200     def test_logger_loggers(self):
201         buildout.LOG.clear()
202         for i in buildout.LOG.levels:
203             getattr(buildout.LOG, i)("foo")
204             getattr(buildout.LOG, i)("bar")
205             getattr(buildout.LOG, i)("moo")
206             self.assertTrue(len(buildout.LOG.by_level[i]) == 3)
207             self.assertEqual(buildout.LOG.by_level[i][0], "foo")
208             self.assertEqual(buildout.LOG.by_level[i][-1], "moo")
209     @pytest.mark.slow_test
210     def test__find_cfgs(self):
211         result = sorted(
212             a.replace(self.root, "") for a in buildout._find_cfgs(self.root)
213         )
214         assertlist = sorted(
215             [
216                 os.path.join(os.sep, "buildout.cfg"),
217                 os.path.join(os.sep, "c", "buildout.cfg"),
218                 os.path.join(os.sep, "etc", "buildout.cfg"),
219                 os.path.join(os.sep, "e", "buildout.cfg"),
220                 os.path.join(os.sep, "b", "buildout.cfg"),
221                 os.path.join(os.sep, "b", "bdistribute", "buildout.cfg"),
222                 os.path.join(os.sep, "b", "b2", "buildout.cfg"),
223                 os.path.join(os.sep, "foo", "buildout.cfg"),
224             ]
225         )
226         self.assertEqual(result, assertlist)
227     def skip_test_upgrade_bootstrap(self):
228         b_dir = os.path.join(self.tdir, "b")
229         bpy = os.path.join(b_dir, "bootstrap.py")
230         buildout.upgrade_bootstrap(b_dir)
231         time1 = os.stat(bpy).st_mtime
232         with salt.utils.files.fopen(bpy) as fic:
233             data = fic.read()
234         self.assertTrue("setdefaulttimeout(2)" in data)
235         flag = os.path.join(b_dir, ".buildout", "2.updated_bootstrap")
236         self.assertTrue(os.path.exists(flag))
237         buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
238         time2 = os.stat(bpy).st_mtime
239         with salt.utils.files.fopen(bpy) as fic:
240             data = fic.read()
241         self.assertTrue("setdefaulttimeout(2)" in data)
242         flag = os.path.join(b_dir, ".buildout", "1.updated_bootstrap")
243         self.assertTrue(os.path.exists(flag))
244         buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
245         time3 = os.stat(bpy).st_mtime
246         self.assertNotEqual(time2, time1)
247         self.assertEqual(time2, time3)
248 @skipIf(
249     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
250     "The 'virtualenv' packaged needs to be installed",
251 )
252 @pytest.mark.requires_network
253 class BuildoutOnlineTestCase(Base):
254     @classmethod
255     def setUpClass(cls):
256         super().setUpClass()
257         cls.ppy_dis = os.path.join(cls.rdir, "pdistribute")
258         cls.ppy_blank = os.path.join(cls.rdir, "pblank")
259         cls.py_dis = os.path.join(cls.ppy_dis, "bin", "python")
260         cls.py_blank = os.path.join(cls.ppy_blank, "bin", "python")
261         try:
262             subprocess.check_call(
263                 [
264                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
265                     "--no-setuptools",
266                     "--no-pip",
267                     cls.ppy_dis,
268                 ]
269             )
270         except subprocess.CalledProcessError:
271             subprocess.check_call(
272                 [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_dis]
273             )
274             url = (
275                 "https://pypi.python.org/packages/source"
276                 "/d/distribute/distribute-0.6.43.tar.gz"
277             )
278             download_to(
279                 url,
280                 os.path.join(cls.ppy_dis, "distribute-0.6.43.tar.gz"),
281             )
282             subprocess.check_call(
283                 [
284                     "tar",
285                     "-C",
286                     cls.ppy_dis,
287                     "-xzvf",
288                     "{}/distribute-0.6.43.tar.gz".format(cls.ppy_dis),
289                 ]
290             )
291             subprocess.check_call(
292                 [
293                     "{}/bin/python".format(cls.ppy_dis),
294                     "{}/distribute-0.6.43/setup.py".format(cls.ppy_dis),
295                     "install",
296                 ]
297             )
298         try:
299             subprocess.check_call(
300                 [
301                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
302                     "--no-setuptools",
303                     "--no-pip",
304                     cls.ppy_blank,
305                 ]
306             )
307         except subprocess.CalledProcessError:
308             subprocess.check_call(
309                 [
310                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
311                     cls.ppy_blank,
312                 ]
313             )
314     @pytest.mark.skip(reason="TODO this test should probably be fixed")
315         b_dir = os.path.join(self.tdir, "b")
316         bd_dir = os.path.join(self.tdir, "b", "bdistribute")
317         b2_dir = os.path.join(self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.tdir, "b", "b2")
318         self.assertTrue(buildout._has_old_distribute(self.py_dis))
319         self.assertFalse(buildout._has_old_distribute(self.py_st))
320         self.</b></font>assertFalse(buildout._has_setuptools7(self.py_dis))
321         self.assertFalse(buildout._has_setuptools7(self.py_blank))
322         ret <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= buildout.bootstrap(bd_dir, buildout_ver=1, python=self.py_dis)
323         comment = ret["outlog"]
324         self.assertTrue("--distribute" in comment)
325         self.assertTrue(</b></font>"Generated script" in comment)
326         ret = buildout.bootstrap(b_dir, buildout_ver=1, python=self.py_blank)
327         comment = ret["outlog"]
328         self.assertTrue(
329             ("Got " in comment and "Generated script" in comment)
330             or ("setuptools&gt;=0.7" in comment)
331         )
332         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_blank)
333         comment = ret["outlog"]
334         self.assertTrue(
335             ("setuptools" in comment and "Generated script" in comment)
336             or ("setuptools&gt;=0.7" in comment)
337         )
338         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
339         comment = ret["outlog"]
340         self.assertTrue(
341             ("setuptools" in comment and "Generated script" in comment)
342             or ("setuptools&gt;=0.7" in comment)
343         )
344         ret = buildout.bootstrap(b2_dir, buildout_ver=2, python=self.py_st)
345         comment = ret["outlog"]
346         self.assertTrue(
347             ("setuptools" in comment and "Creating directory" in comment)
348             or ("setuptools&gt;=0.7" in comment)
349         )
350     @pytest.mark.slow_test
351     def test_run_buildout(self):
352         if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
353             self.skipTest(
354                 "Skiping until upstream resolved"
355                 " https://github.com/pypa/virtualenv/issues/1715"
356             )
357         b_dir = os.path.join(self.tdir, "b")
358         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
359         self.assertTrue(ret["status"])
360         ret = buildout.run_buildout(b_dir, parts=["a", "b"])
361         out = ret["out"]
362         self.assertTrue("Installing a" in out)
363         self.assertTrue("Installing b" in out)
364     @pytest.mark.slow_test
365     def test_buildout(self):
366         if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
367             self.skipTest(
368                 "Skiping until upstream resolved"
369                 " https://github.com/pypa/virtualenv/issues/1715"
370             )
371         b_dir = os.path.join(self.tdir, "b")
372         ret = buildout.buildout(b_dir, buildout_ver=2, python=self.py_st)
373         self.assertTrue(ret["status"])
374         out = ret["out"]
375         comment = ret["comment"]
376         self.assertTrue(ret["status"])
377         self.assertTrue("Creating directory" in out)
378         self.assertTrue("Installing a." in out)
379         self.assertTrue("{} bootstrap.py".format(self.py_st) in comment)
380         self.assertTrue("buildout -c buildout.cfg" in comment)
381         ret = buildout.buildout(
382             b_dir, parts=["a", "b", "c"], buildout_ver=2, python=self.py_st
383         )
384         outlog = ret["outlog"]
385         out = ret["out"]
386         comment = ret["comment"]
387         self.assertTrue("Installing single part: a" in outlog)
388         self.assertTrue("buildout -c buildout.cfg -N install a" in comment)
389         self.assertTrue("Installing b." in out)
390         self.assertTrue("Installing c." in out)
391         ret = buildout.buildout(
392             b_dir, parts=["a", "b", "c"], buildout_ver=2, newest=True, python=self.py_st
393         )
394         outlog = ret["outlog"]
395         out = ret["out"]
396         comment = ret["comment"]
397         self.assertTrue("buildout -c buildout.cfg -n install a" in comment)
398 class BuildoutAPITestCase(TestCase):
399     def test_merge(self):
400         buildout.LOG.clear()
401         buildout.LOG.info("àé")
402         buildout.LOG.info("àé")
403         buildout.LOG.error("àé")
404         buildout.LOG.error("àé")
405         ret1 = buildout._set_status({}, out="éà")
406         uret1 = buildout._set_status({}, out="éà")
407         buildout.LOG.clear()
408         buildout.LOG.info("ççàé")
409         buildout.LOG.info("ççàé")
410         buildout.LOG.error("ççàé")
411         buildout.LOG.error("ççàé")
412         ret2 = buildout._set_status({}, out="çéà")
413         uret2 = buildout._set_status({}, out="çéà")
414         uretm = buildout._merge_statuses([ret1, uret1, ret2, uret2])
415         for ret in ret1, uret1, ret2, uret2:
416             out = ret["out"]
417             if not isinstance(ret["out"], str):
418                 out = ret["out"].decode("utf-8")
419         for out in ["àé", "ççàé"]:
420             self.assertTrue(out in uretm["logs_by_level"]["info"])
421             self.assertTrue(out in uretm["outlog_by_level"])
422     def test_setup(self):
423         buildout.LOG.clear()
424         buildout.LOG.info("àé")
425         buildout.LOG.info("àé")
426         buildout.LOG.error("àé")
427         buildout.LOG.error("àé")
428         ret = buildout._set_status({}, out="éà")
429         uret = buildout._set_status({}, out="éà")
430         self.assertTrue(ret["outlog"] == uret["outlog"])
431         self.assertTrue("àé" in uret["outlog_by_level"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import absolute_import, division, print_function
2 import collections
3 from contextlib import closing
4 import errno
5 import gzip
6 import logging
7 import os
8 import re
9 import socket
10 import ssl
11 import sys
12 from salt.ext.tornado.escape import to_unicode
13 from salt.ext.tornado import gen
14 from salt.ext.tornado.httpclient import AsyncHTTPClient
15 from salt.ext.tornado.httputil import HTTPHeaders, ResponseStartLine
16 from salt.ext.tornado.ioloop import IOLoop
17 from salt.ext.tornado.log import gen_log
18 from</b></font> salt.ext.tornado.concurrent import Future
19 from salt.ext.tornado.netutil import Resolver, bind_sockets
20 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
21 from salt.ext.tornado.test.httpclient_test import ChunkHandler, CountdownHandler, HelloWorldHandler, RedirectHandler
22 from salt.ext.tornado.test import httpclient_test
23 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog
24 from salt.ext.tornado.test.util import skipOnTravis, skipIfNoIPv6, refusing_port, unittest, skipBefore35, exec_test
25 from salt.ext.tornado.web import RequestHandler, Application, asynchronous, url, stream_request_body
26 class SimpleHTTPClientCommonTestCase(httpclient_test.HTTPClientCommonTestCase):
27     def get_http_client(self):
28         client = SimpleAsyncHTTPClient(io_loop=self.io_loop,
29                                        force_instance=True)
30         self.assertTrue(isinstance(client, SimpleAsyncHTTPClient))
31         return client
32 class TriggerHandler(RequestHandler):
33     def initialize(self, queue, wake_callback):
34         self.queue = queue
35         self.wake_callback = wake_callback
36     @asynchronous
37     def get(self):
38         logging.debug("queuing trigger")
39         self.queue.append(self.finish)
40         if self.get_argument("wake", "true") == "true":
41             self.wake_callback()
42 class HangHandler(RequestHandler):
43     @asynchronous
44     def get(self):
45         pass
46 class ContentLengthHandler(RequestHandler):
47     def get(self):
48         self.set_header("Content-Length", self.get_argument("value"))
49         self.write("ok")
50 class HeadHandler(RequestHandler):
51     def head(self):
52         self.set_header("Content-Length", "7")
53 class OptionsHandler(RequestHandler):
54     def options(self):
55         self.set_header("Access-Control-Allow-Origin", "*")
56         self.write("ok")
57 class NoContentHandler(RequestHandler):
58     def get(self):
59         self.set_status(204)
60         self.finish()
61 class SeeOtherPostHandler(RequestHandler):
62     def post(self):
63         redirect_code = int(self.request.body)
64         assert redirect_code in (302, 303), "unexpected body %r" % self.request.body
65         self.set_header("Location", "/see_other_get")
66         self.set_status(redirect_code)
67 class SeeOtherGetHandler(RequestHandler):
68     def get(self):
69         if self.request.body:
70             raise Exception("unexpected body %r" % self.request.body)
71         self.write("ok")
72 class HostEchoHandler(RequestHandler):
73     def get(self):
74         self.write(self.request.headers["Host"])
75 class NoContentLengthHandler(RequestHandler):
76     @asynchronous
77     def get(self):
78         if self.request.version.startswith('HTTP/1'):
79             stream = self.request.connection.detach()
80             stream.write(b"HTTP/1.0 200 OK\r\n\r\n"
81                          b"hello")
82             stream.close()
83         else:
84             self.finish('HTTP/1 required')
85 class EchoPostHandler(RequestHandler):
86     def post(self):
87         self.write(self.request.body)
88 @stream_request_body
89 class RespondInPrepareHandler(RequestHandler):
90     def prepare(self):
91         self.set_status(403)
92         self.finish("forbidden")
93 class SimpleHTTPClientTestMixin(object):
94     def get_app(self):
95         self.triggers = collections.deque()
96         return Application([
97             url("/trigger", TriggerHandler, dict(queue=self.triggers,
98                                                  wake_callback=self.stop)),
99             url("/chunk", ChunkHandler),
100             url("/countdown/([0-9]+)", CountdownHandler, name="countdown"),
101             url("/hang", HangHandler),
102             url("/hello", HelloWorldHandler),
103             url("/content_length", ContentLengthHandler),
104             url("/head", HeadHandler),
105             url("/options", OptionsHandler),
106             url("/no_content", NoContentHandler),
107             url("/see_other_post", SeeOtherPostHandler),
108             url("/see_other_get", SeeOtherGetHandler),
109             url("/host_echo", HostEchoHandler),
110             url("/no_content_length", NoContentLengthHandler),
111             url("/echo_post", EchoPostHandler),
112             url("/respond_in_prepare", RespondInPrepareHandler),
113             url("/redirect", RedirectHandler),
114         ], gzip=True)
115     def test_singleton(self):
116         self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is
117                         SimpleAsyncHTTPClient(self.io_loop))
118         self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
119                         SimpleAsyncHTTPClient(self.io_loop,
120                                               force_instance=True))
121         with closing(IOLoop()) as io_loop2:
122             self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
123                             SimpleAsyncHTTPClient(io_loop2))
124     def test_connection_limit(self):
125         with closing(self.create_client(max_clients=2)) as client:
126             self.assertEqual(client.max_clients, 2)
127             seen = []
128             for i in range(4):
129                 client.fetch(self.get_url("/trigger"),
130                              lambda response, i=i: (seen.append(i), self.stop()))
131             self.wait(condition=lambda: len(self.triggers) == 2)
132             self.assertEqual(len(client.queue), 2)
133             self.triggers.popleft()()
134             self.triggers.popleft()()
135             self.wait(condition=lambda: (len(self.triggers) == 2 and
136                                          len(seen) == 2))
137             self.assertEqual(set(seen), set([0, 1]))
138             self.assertEqual(len(client.queue), 0)
139             self.triggers.popleft()()
140             self.triggers.popleft()()
141             self.wait(condition=lambda: len(seen) == 4)
142             self.assertEqual(set(seen), set([0, 1, 2, 3]))
143             self.assertEqual(len(self.triggers), 0)
144     def test_redirect_connection_limit(self):
145         with closing(self.create_client(max_clients=1)) as client:
146             client.fetch(self.get_url('/countdown/3'), self.stop,
147                          max_redirects=3)
148             response = self.wait()
149             response.rethrow()
150     def test_gzip(self):
151         response = self.fetch("/chunk", use_gzip=False,
152                               headers={"Accept-Encoding": "gzip"})
153         self.assertEqual(response.headers["Content-Encoding"], "gzip")
154         self.assertNotEqual(response.body, b"asdfqwer")
155         self.assertEqual(len(response.body), 34)
156         f = gzip.GzipFile(mode="r", fileobj=response.buffer)
157         self.assertEqual(f.read(), b"asdfqwer")
158     def test_max_redirects(self):
159         response = self.fetch("/countdown/5", max_redirects=3)
160         self.assertTrue(response.request<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.url.endswith("/countdown/5"))
161         self.assertTrue(response.effective_url.endswith("/countdown/2"))
162         self.assertTrue(response.headers[</b></font>"Location"].endswith("/countdown/1"))
163     def test_header_reuse(self):
164         headers = HTTPHeaders({'User-Agent': 'Foo'})
165         self.fetch("/hello", headers=headers)
166         self.assertEqual(list(headers.get_all()), [('User-Agent', 'Foo')])
167     def test_see_other_redirect(self):
168         for code in (302, 303):
169             response = self.fetch("/see_other_post", method="POST", body="%d" % code)
170             self.assertEqual(200, response.code)
171             self.assertTrue(response.request.url.endswith("/see_other_post"))
172             self.assertTrue(response.effective_url.endswith("/see_other_get"))
173             self.assertEqual("POST", response.request.method)
174     @skipOnTravis
175     def test_connect_timeout(self):
176         timeout = 0.1
177         timeout_min, timeout_max = 0.099, 1.0
178         class TimeoutResolver(Resolver):
179             def resolve(self, *args, **kwargs):
180                 return Future()  # never completes
181         with closing(self.create_client(resolver=TimeoutResolver())) as client:
182             client.fetch(self.get_url('/hello'), self.stop,
183                          connect_timeout=timeout)
184             response = self.wait()
185             self.assertEqual(response.code, 599)
186             self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
187                             response.request_time)
188             self.assertEqual(str(response.error), "HTTP 599: Timeout while connecting")
189     @skipOnTravis
190     def test_request_timeout(self):
191         timeout = 0.1
192         timeout_min, timeout_max = 0.099, 0.15
193         if os.name == 'nt':
194             timeout = 0.5
195             timeout_min, timeout_max = 0.4, 0.6
196         response = self.fetch('/trigger?wake=false', request_timeout=timeout)
197         self.assertEqual(response.code, 599)
198         self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
199                         response.request_time)
200         self.assertEqual(str(response.error), "HTTP 599: Timeout during request")
201         self.triggers.popleft()()
202     @skipIfNoIPv6
203     def test_ipv6(self):
204         [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)
205         port = sock.getsockname()[1]
206         self.http_server.add_socket(sock)
207         url = '%s://[::1]:%d/hello' % (self.get_protocol(), port)
208         self.http_client.fetch(url, self.stop, allow_ipv6=False)
209         response = self.wait()
210         self.assertEqual(response.code, 599)
211         self.http_client.fetch(url, self.stop)
212         response = self.wait()
213         self.assertEqual(response.body, b"Hello world!")
214     def xtest_multiple_content_length_accepted(self):
215         response = self.fetch("/content_length?value=2,2")
216         self.assertEqual(response.body, b"ok")
217         response = self.fetch("/content_length?value=2,%202,2")
218         self.assertEqual(response.body, b"ok")
219         response = self.fetch("/content_length?value=2,4")
220         self.assertEqual(response.code, 599)
221         response = self.fetch("/content_length?value=2,%202,3")
222         self.assertEqual(response.code, 599)
223     def test_head_request(self):
224         response = self.fetch("/head", method="HEAD")
225         self.assertEqual(response.code, 200)
226         self.assertEqual(response.headers["content-length"], "7")
227         self.assertFalse(response.body)
228     def test_options_request(self):
229         response = self.fetch("/options", method="OPTIONS")
230         self.assertEqual(response<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.code, 200)
231         self.assertEqual(response.headers["content-length"], "2")
232         self.assertEqual(response.headers["access-control-allow-origin"], "*")
233         self.assertEqual(response.</b></font>body, b"ok")
234     def test_no_content(self):
235         response = self.fetch("/no_content")
236         self.assertEqual(response.code, 204)
237         self.assertNotIn("Content-Length", response.headers)
238     def test_host_header(self):
239         host_re = re.compile(b"^127.0.0.1:[0-9]+$")
240         response = self.fetch("/host_echo")
241         self.assertTrue(host_re.match(response.body))
242         url = self.get_url("/host_echo").replace("http://", "http://me:secret@")
243         self.http_client.fetch(url, self.stop)
244         response = self.wait()
245         self.assertTrue(host_re.match(response.body), response.body)
246     def test_connection_refused(self):
247         cleanup_func, port = refusing_port()
248         self.addCleanup(cleanup_func)
249         with ExpectLog(gen_log, ".*", required=False):
250             self.http_client.fetch("http://127.0.0.1:%d/" % port, self.stop)
251             response = self.wait()
252         self.assertEqual(599, response.code)
253         if sys.platform != 'cygwin':
254             contains_errno = str(errno.ECONNREFUSED) in str(response.error)
255             if not contains_errno and hasattr(errno, "WSAECONNREFUSED"):
256                 contains_errno = str(errno.WSAECONNREFUSED) in str(response.error)
257             self.assertTrue(contains_errno, response.error)
258             expected_message = os.strerror(errno.ECONNREFUSED)
259             self.assertTrue(expected_message in str(response.error),
260                             response.error)
261     def test_queue_timeout(self):
262         with closing(self.create_client(max_clients=1)) as client:
263             client.fetch(self.get_url('/trigger'), self.stop,
264                          request_timeout=10)
265             self.wait()
266             client.fetch(self.get_url('/hello'), self.stop,
267                          connect_timeout=0.1)
268             response = self.wait()
269             self.assertEqual(response.code, 599)
270             self.assertTrue(response.request_time &lt; 1, response.request_time)
271             self.assertEqual(str(response.error), "HTTP 599: Timeout in request queue")
272             self.triggers.popleft()()
273             self.wait()
274     def test_no_content_length(self):
275         response = self.fetch("/no_content_length")
276         if response.body == b"HTTP/1 required":
277             self.skipTest("requires HTTP/1.x")
278         else:
279             self.assertEquals(b"hello", response.body)
280     def sync_body_producer(self, write):
281         write(b'1234')
282         write(b'5678')
283     @gen.coroutine
284     def async_body_producer(self, write):
285         yield write(b'1234')
286         yield gen.Task(IOLoop.current().add_callback)
287         yield write(b'5678')
288     def test_sync_body_producer_chunked(self):
289         response = self.fetch("/echo_post", method="POST",
290                               body_producer=self.sync_body_producer)
291         response.rethrow()
292     def test_sync_body_producer_content_length(self):
293         response <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch("/echo_post", method="POST",
294                               body_producer=self.sync_body_producer,
295                               headers={'Content-Length': '8'})
296         response.rethrow()
297         self.assertEqual(</b></font>response.body, b"12345678")
298     def test_async_body_producer_chunked(self):
299         response = self.fetch("/echo_post", method="POST",
300                               body_producer=self.async_body_producer)
301         response.rethrow()
302         self.assertEqual(response.body, b"12345678")
303     def test_async_body_producer_content_length(self):
304         response = self.fetch("/echo_post", method="POST",
305                               body_producer=self.async_body_producer,
306                               headers={'Content-Length': '8'})
307         response.rethrow()
308         self.assertEqual(response.body, b"12345678")
309     @skipBefore35
310     def test_native_body_producer_chunked(self):
311         namespace = exec_test(globals(), locals(), """
312         async def body_producer(write):
313             await write(b'1234')
314             await gen.Task(IOLoop.current().add_callback)
315             await write(b'5678')
316         response = self.fetch("/echo_post", method="POST",
317                               body_producer=namespace["body_producer"],
318                               headers={'Content-Length': '8'})
319         response.rethrow()
320         self.assertEqual(response.body, b"12345678")
321     def test_100_continue(self):
322         response = self.fetch("/echo_post", method="POST",
323                               body=b"1234",
324                               expect_100_continue=True)
325         self.assertEqual(response.body, b"1234")
326     def test_100_continue_early_response(self):
327         def body_producer(write):
328             raise Exception("should not be called")
329         response = self.fetch("/respond_in_prepare", method="POST",
330                               body_producer=body_producer,
331                               expect_100_continue=True)
332         self.assertEqual(response.code, 403)
333     def test_streaming_follow_redirects(self):
334         headers = []
335         chunks = []
336         self.fetch("/redirect?url=/hello",
337                    header_callback=headers.append,
338                    streaming_callback=chunks.append)
339         chunks = list(map(to_unicode, chunks))
340         self.assertEqual(chunks, ['Hello world!'])
341         num_start_lines = len([h for h in headers if h.startswith("HTTP/")])
342         self.assertEqual(num_start_lines, 1)
343 class SimpleHTTPClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPTestCase):
344     def setUp(self):
345         super(SimpleHTTPClientTestCase, self).setUp()
346         self.http_client = self.create_client()
347     def create_client(self, **kwargs):
348         return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
349                                      **kwargs)
350 class SimpleHTTPSClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPSTestCase):
351     def setUp(self):
352         super(SimpleHTTPSClientTestCase, self).setUp()
353         self.http_client = self.create_client()
354     def create_client(self, **kwargs):
355         return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
356                                      defaults=dict(validate_cert=False),
357                                      **kwargs)
358     def test_ssl_options(self):
359         resp = self.fetch("/hello", ssl_options={})
360         self.assertEqual(resp.body, b"Hello world!")
361     @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
362                      'ssl.SSLContext not present')
363     def test_ssl_context(self):
364         resp = self.fetch("/hello",
365                           ssl_options=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
366         self.assertEqual(resp.body, b"Hello world!")
367     def test_ssl_options_handshake_fail(self):
368         with ExpectLog(gen_log, "SSL Error|Uncaught exception",
369                        required=False):
370             resp = self.fetch(
371                 "/hello", ssl_options=dict(cert_reqs=ssl.CERT_REQUIRED))
372         self.assertRaises(ssl.SSLError, resp.rethrow)
373     @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
374                      'ssl.SSLContext not present')
375     def test_ssl_context_handshake_fail(self):
376         with ExpectLog(gen_log, "SSL Error|Uncaught exception"):
377             ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
378             ctx.verify_mode = ssl.CERT_REQUIRED
379             resp = self.fetch("/hello", ssl_options=ctx)
380         self.assertRaises(ssl.SSLError, resp.rethrow)
381     def test_error_logging(self):
382         with ExpectLog(gen_log, '.*') as expect_log:
383             response = self.fetch("/", validate_cert=True)
384             self.assertEqual(response.code, 599)
385             self.assertIsInstance(response.error, ssl.SSLError)
386         self.assertFalse(expect_log.logged_stack)
387 class CreateAsyncHTTPClientTestCase(AsyncTestCase):
388     def setUp(self):
389         super(CreateAsyncHTTPClientTestCase, self).setUp()
390         self.saved = AsyncHTTPClient._save_configuration()
391     def tearDown(self):
392         AsyncHTTPClient._restore_configuration(self.saved)
393         super(CreateAsyncHTTPClientTestCase, self).tearDown()
394     def test_max_clients(self):
395         AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
396         with closing(AsyncHTTPClient(
397                 self.io_loop, force_instance=True)) as client:
398             self.assertEqual(client.max_clients, 10)
399         with closing(AsyncHTTPClient(
400                 self.io_loop, max_clients=11, force_instance=True)) as client:
401             self.assertEqual(client.max_clients, 11)
402         AsyncHTTPClient.configure(SimpleAsyncHTTPClient, max_clients=12)
403         with closing(AsyncHTTPClient(
404                 self.io_loop, force_instance=True)) as client:
405             self.assertEqual(client.max_clients, 12)
406         with closing(AsyncHTTPClient(
407                 self.io_loop, max_clients=13, force_instance=True)) as client:
408             self.assertEqual(client.max_clients, 13)
409         with closing(AsyncHTTPClient(
410                 self.io_loop, max_clients=14, force_instance=True)) as client:
411             self.assertEqual(client.max_clients, 14)
412 class HTTP100ContinueTestCase(AsyncHTTPTestCase):
413     def respond_100(self, request):
414         self.http1 = request.version.startswith('HTTP/1.')
415         if not self.http1:
416             request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
417                                              HTTPHeaders())
418             request.connection.finish()
419             return
420         self.request = request
421         self.request.connection.stream.write(
422             b"HTTP/1.1 100 CONTINUE\r\n\r\n",
423             self.respond_200)
424     def respond_200(self):
425         self.request.connection.stream.write(
426             b"HTTP/1.1 200 OK\r\nContent-Length: 1\r\n\r\nA",
427             self.request.connection.stream.close)
428     def get_app(self):
429         return self.respond_100
430     def test_100_continue(self):
431         res = self.fetch('/')
432         if not self.http1:
433             self.skipTest("requires HTTP/1.x")
434         self.assertEqual(res.body, b'A')
435 class HTTP204NoContentTestCase(AsyncHTTPTestCase):
436     def respond_204(self, request):
437         self.http1 = request.version.startswith('HTTP/1.')
438         if not self.http1:
439             request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
440                                              HTTPHeaders())
441             request.connection.finish()
442             return
443         stream = request.connection.detach()
444         stream.write(b"HTTP/1.1 204 No content\r\n")
445         if request.arguments.get("error", [False])[-1]:
446             stream.write(b"Content-Length: 5\r\n")
447         else:
448             stream.write(b"Content-Length: 0\r\n")
449         stream.write(b"\r\n")
450         stream.close()
451     def get_app(self):
452         return self.respond_204
453     def test_204_no_content(self):
454         resp = self.fetch('/')
455         if not self.http1:
456             self.skipTest("requires HTTP/1.x")
457         self.assertEqual(resp.code, 204)
458         self.assertEqual(resp.body, b'')
459     def test_204_invalid_content_length(self):
460         with ExpectLog(gen_log, ".*Response with code 204 should not have body"):
461             response = self.fetch("/?error=1")
462             if not self.http1:
463                 self.skipTest("requires HTTP/1.x")
464             if self.http_client.configured_class != SimpleAsyncHTTPClient:
465                 self.skipTest("curl client accepts invalid headers")
466             self.assertEqual(response.code, 599)
467 class HostnameMappingTestCase(AsyncHTTPTestCase):
468     def setUp(self):
469         super(HostnameMappingTestCase, self).setUp()
470         self.http_client = SimpleAsyncHTTPClient(
471             self.io_loop,
472             hostname_mapping={
473                 'www.example.com': '127.0.0.1',
474                 ('foo.example.com', 8000): ('127.0.0.1', self.get_http_port()),
475             })
476     def get_app(self):
477         return Application([url("/hello", HelloWorldHandler), ])
478     def test_hostname_mapping(self):
479         self.http_client.fetch(
480             'http://www.example.com:%d/hello' % self.get_http_port(), self.stop)
481         response = self.wait()
482         response.rethrow()
483         self.assertEqual(response.body, b'Hello world!')
484     def test_port_mapping(self):
485         self.http_client.fetch('http://foo.example.com:8000/hello', self.stop)
486         response = self.wait()
487         response.rethrow()
488         self.assertEqual(response.body, b'Hello world!')
489 class ResolveTimeoutTestCase(AsyncHTTPTestCase):
490     def setUp(self):
491         class BadResolver(Resolver):
492             def resolve(self, *args, **kwargs):
493                 pass
494         super(ResolveTimeoutTestCase, self).setUp()
495         self.http_client = SimpleAsyncHTTPClient(
496             self.io_loop,
497             resolver=BadResolver())
498     def get_app(self):
499         return Application([url("/hello", HelloWorldHandler), ])
500     def test_resolve_timeout(self):
501         response = self.fetch('/hello', connect_timeout=0.1)
502         self.assertEqual(response.code, 599)
503 class MaxHeaderSizeTest(AsyncHTTPTestCase):
504     def get_app(self):
505         class SmallHeaders(RequestHandler):
506             def get(self):
507                 self.set_header("X-Filler", "a" * 100)
508                 self.write("ok")
509         class LargeHeaders(RequestHandler):
510             def get(self):
511                 self.set_header("X-Filler", "a" * 1000)
512                 self.write("ok")
513         return Application([('/small', SmallHeaders),
514                             ('/large', LargeHeaders)])
515     def get_http_client(self):
516         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_header_size=1024)
517     def test_small_headers(self):
518         response = self.fetch('/small')
519         response.rethrow()
520         self.assertEqual(response.body, b'ok')
521     def test_large_headers(self):
522         with ExpectLog(gen_log, "Unsatisfiable read"):
523             response = self.fetch('/large')
524         self.assertEqual(response.code, 599)
525 class MaxBodySizeTest(AsyncHTTPTestCase):
526     def get_app(self):
527         class SmallBody(RequestHandler):
528             def get(self):
529                 self.write("a" * 1024 * 64)
530         class LargeBody(RequestHandler):
531             def get(self):
532                 self.write("a" * 1024 * 100)
533         return Application([('/small', SmallBody),
534                             ('/large', LargeBody)])
535     def get_http_client(self):
536         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 64)
537     def test_small_body(self):
538         response = self.fetch('/small')
539         response.rethrow()
540         self.assertEqual(response.body, b'a' * 1024 * 64)
541     def test_large_body(self):
542         with ExpectLog(gen_log, "Malformed HTTP message from None: Content-Length too long"):
543             response = self.fetch('/large')
544         self.assertEqual(response.code, 599)
545 class MaxBufferSizeTest(AsyncHTTPTestCase):
546     def get_app(self):
547         class LargeBody(RequestHandler):
548             def get(self):
549                 self.write("a" * 1024 * 100)
550         return Application([('/large', LargeBody)])
551     def get_http_client(self):
552         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 100, max_buffer_size=1024 * 64)
553     def test_large_body(self):
554         response = self.fetch('/large')
555         response.rethrow()
556         self.assertEqual(response.body, b'a' * 1024 * 100)
557 class ChunkedWithContentLengthTest(AsyncHTTPTestCase):
558     def get_app(self):
559         class ChunkedWithContentLength(RequestHandler):
560             def get(self):
561                 self.set_header('Transfer-Encoding', 'chunked')
562                 self.write("Hello world")
563         return Application([('/chunkwithcl', ChunkedWithContentLength)])
564     def get_http_client(self):
565         return SimpleAsyncHTTPClient()
566     def test_chunked_with_content_length(self):
567         with ExpectLog(gen_log, ("Malformed HTTP message from None: Response "
568                                  "with both Transfer-Encoding and Content-Length")):
569             response = self.fetch('/chunkwithcl')
570         self.assertEqual(response.code, 599)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
