<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_zcbuildout_1.py (4.927007%)<th>simple_httpclient_test.py (3.5952065%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-19)<td><a href="#" name="0">(2-21)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(419-422)<td><a href="#" name="1">(393-397)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(408-415)<td><a href="#" name="2">(220-222)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(201-203)<td><a href="#" name="3">(309-312)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zcbuildout_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os
3 import shutil
4 import subprocess
5 import tempfile
6 import urllib.error
7 import urllib.request
8 import pytest
9 import salt.modules.cmdmod as cmd
10 import salt.modules.virtualenv_mod
11 import salt.modules.zcbuildout as buildout
12 import salt.utils.files
13 import salt.utils.path
14 import salt.utils.platform
15 from tests.support.helpers import patched_environ
16 from tests.support.mixins import LoaderModuleMockMixin
17 from tests.support.runtests import RUNTIME_VARS
18 from</b></font> tests.support.unit import TestCase, skipIf
19 KNOWN_VIRTUALENV_BINARY_NAMES = (
20     "virtualenv",
21     "virtualenv2",
22     "virtualenv-2.6",
23     "virtualenv-2.7",
24 )
25 BOOT_INIT = {
26     1: ["var/ver/1/bootstrap/bootstrap.py"],
27     2: ["var/ver/2/bootstrap/bootstrap.py", "b/bootstrap.py"],
28 }
29 log = logging.getLogger(__name__)
30 def download_to(url, dest):
31     req = urllib.request.Request(url)
32     req.add_header(
33         "User-Agent",
34         "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
35     )
36     with salt.utils.files.fopen(dest, "wb") as fic:
37         fic.write(urllib.request.urlopen(req, timeout=10).read())
38 class Base(TestCase, LoaderModuleMockMixin):
39     def setup_loader_modules(self):
40         return {
41             buildout: {
42                 "__salt__": {
43                     "cmd.run_all": cmd.run_all,
44                     "cmd.run": cmd.run,
45                     "cmd.retcode": cmd.retcode,
46                 }
47             }
48         }
49     @classmethod
50     def setUpClass(cls):
51         if not os.path.isdir(RUNTIME_VARS.TMP):
52             os.makedirs(RUNTIME_VARS.TMP)
53         cls.root = os.path.join(RUNTIME_VARS.BASE_FILES, "buildout")
54         cls.rdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
55         cls.tdir = os.path.join(cls.rdir, "test")
56         for idx, url in buildout._URL_VERSIONS.items():
57             log.debug("Downloading bootstrap from %s", url)
58             dest = os.path.join(cls.rdir, "{}_bootstrap.py".format(idx))
59             try:
60                 download_to(url, dest)
61             except urllib.error.URLError as exc:
62                 log.debug("Failed to download %s: %s", url, exc)
63         cls.ppy_st = os.path.join(cls.rdir, "psetuptools")
64         if salt.utils.platform.is_windows():
65             cls.bin_st = os.path.join(cls.ppy_st, "Scripts")
66             cls.py_st = os.path.join(cls.bin_st, "python")
67         else:
68             cls.bin_st = os.path.join(cls.ppy_st, "bin")
69             cls.py_st = os.path.join(cls.bin_st, "python")
70         subprocess.check_call(
71             [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_st]
72         )
73         subprocess.check_call(
74             [os.path.join(cls.bin_st, "pip"), "install", "-U", "setuptools&lt;50.0.0"]
75         )
76         subprocess.check_call(
77             [os.path.join(cls.bin_st, "easy_install"), "-U", "distribute"]
78         )
79     def setUp(self):
80         if salt.utils.platform.is_darwin():
81             self.patched_environ = patched_environ(__cleanup__=["__PYVENV_LAUNCHER__"])
82             self.patched_environ.__enter__()
83             self.addCleanup(self.patched_environ.__exit__)
84         super().setUp()
85         self._remove_dir()
86         shutil.copytree(self.root, self.tdir)
87         for idx in BOOT_INIT:
88             path = os.path.join(self.rdir, "{}_bootstrap.py".format(idx))
89             for fname in BOOT_INIT[idx]:
90                 shutil.copy2(path, os.path.join(self.tdir, fname))
91     def tearDown(self):
92         super().tearDown()
93         self._remove_dir()
94     def _remove_dir(self):
95         if os.path.isdir(self.tdir):
96             shutil.rmtree(self.tdir)
97 @skipIf(
98     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
99     "The 'virtualenv' packaged needs to be installed",
100 )
101 @pytest.mark.requires_network
102 class BuildoutTestCase(Base):
103     @pytest.mark.slow_test
104     def test_onlyif_unless(self):
105         b_dir = os.path.join(self.tdir, "b")
106         ret = buildout.buildout(b_dir, onlyif=RUNTIME_VARS.SHELL_FALSE_PATH)
107         self.assertTrue(ret["comment"] == "onlyif condition is false")
108         self.assertTrue(ret["status"] is True)
109         ret = buildout.buildout(b_dir, unless=RUNTIME_VARS.SHELL_TRUE_PATH)
110         self.assertTrue(ret["comment"] == "unless condition is true")
111         self.assertTrue(ret["status"] is True)
112     @pytest.mark.slow_test
113     def test_salt_callback(self):
114         @buildout._salt_callback
115         def callback1(a, b=1):
116             for i in buildout.LOG.levels:
117                 getattr(buildout.LOG, i)("{}bar".format(i[0]))
118             return "foo"
119         def callback2(a, b=1):
120             raise Exception("foo")
121         ret1 = callback1(1, b=3)
122         ret2 = buildout._salt_callback(callback2)(2, b=6)
123         self.assertEqual(ret2["status"], False)
124         self.assertTrue(ret2["logs_by_level"]["error"][0].startswith("Traceback"))
125         self.assertTrue("Unexpected response from buildout" in ret2["comment"])
126         self.assertEqual(ret2["out"], None)
127         for l in buildout.LOG.levels:
128             self.assertTrue(0 == len(buildout.LOG.by_level[l]))
129 <a name="3"></a>    @pytest.mark.slow_test
130     def test_get_bootstrap_url(self):
131         for path in [
132             os<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.join(self.tdir, "var/ver/1/dumppicked"),
133             os.path.join(self.tdir, "var/ver/1/bootstrap"),
134             os.path.join(self.</b></font>tdir, "var/ver/1/versions"),
135         ]:
136             self.assertEqual(
137                 buildout._URL_VERSIONS[1],
138                 buildout._get_bootstrap_url(path),
139                 "b1 url for {}".format(path),
140             )
141         for path in [
142             os.path.join(self.tdir, "/non/existing"),
143             os.path.join(self.tdir, "var/ver/2/versions"),
144             os.path.join(self.tdir, "var/ver/2/bootstrap"),
145             os.path.join(self.tdir, "var/ver/2/default"),
146         ]:
147             self.assertEqual(
148                 buildout._URL_VERSIONS[2],
149                 buildout._get_bootstrap_url(path),
150                 "b2 url for {}".format(path),
151             )
152     @pytest.mark.slow_test
153     def test_get_buildout_ver(self):
154         for path in [
155             os.path.join(self.tdir, "var/ver/1/dumppicked"),
156             os.path.join(self.tdir, "var/ver/1/bootstrap"),
157             os.path.join(self.tdir, "var/ver/1/versions"),
158         ]:
159             self.assertEqual(
160                 1, buildout._get_buildout_ver(path), "1 for {}".format(path)
161             )
162         for path in [
163             os.path.join(self.tdir, "/non/existing"),
164             os.path.join(self.tdir, "var/ver/2/versions"),
165             os.path.join(self.tdir, "var/ver/2/bootstrap"),
166             os.path.join(self.tdir, "var/ver/2/default"),
167         ]:
168             self.assertEqual(
169                 2, buildout._get_buildout_ver(path), "2 for {}".format(path)
170             )
171     @pytest.mark.slow_test
172     def test_get_bootstrap_content(self):
173         self.assertEqual(
174             "",
175             buildout._get_bootstrap_content(os.path.join(self.tdir, "non", "existing")),
176         )
177         self.assertEqual(
178             "",
179             buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "1")),
180         )
181         self.assertEqual(
182             "foo{}".format(os.linesep),
183             buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "2")),
184         )
185     @pytest.mark.slow_test
186     def test_logger_clean(self):
187         buildout.LOG.clear()
188         self.assertTrue(
189             True
190             not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
191         )
192         buildout.LOG.info("foo")
193         self.assertTrue(
194             True in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
195         )
196         buildout.LOG.clear()
197         self.assertTrue(
198             True
199             not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
200         )
201     @pytest.mark.slow_test
202     def test_logger_loggers(self):
203         buildout.LOG.clear()
204         for i in buildout.LOG.levels:
205             getattr(buildout.LOG, i)("foo")
206             getattr(buildout.LOG, i)("bar")
207             getattr(buildout.LOG, i)("moo")
208             self.assertTrue(len(buildout.LOG.by_level[i]) == 3)
209             self.assertEqual(buildout.LOG.by_level[i][0], "foo")
210             self.assertEqual(buildout.LOG.by_level[i][-1], "moo")
211     @pytest.mark.slow_test
212     def test__find_cfgs(self):
213         result = sorted(
214             a.replace(self.root, "") for a in buildout._find_cfgs(self.root)
215         )
216         assertlist = sorted(
217             [
218                 os.path.join(os.sep, "buildout.cfg"),
219                 os.path.join(os.sep, "c", "buildout.cfg"),
220                 os.path.join(os.sep, "etc", "buildout.cfg"),
221                 os.path.join(os.sep, "e", "buildout.cfg"),
222                 os.path.join(os.sep, "b", "buildout.cfg"),
223                 os.path.join(os.sep, "b", "bdistribute", "buildout.cfg"),
224                 os.path.join(os.sep, "b", "b2", "buildout.cfg"),
225                 os.path.join(os.sep, "foo", "buildout.cfg"),
226             ]
227         )
228         self.assertEqual(result, assertlist)
229     def skip_test_upgrade_bootstrap(self):
230         b_dir = os.path.join(self.tdir, "b")
231         bpy = os.path.join(b_dir, "bootstrap.py")
232         buildout.upgrade_bootstrap(b_dir)
233         time1 = os.stat(bpy).st_mtime
234         with salt.utils.files.fopen(bpy) as fic:
235             data = fic.read()
236         self.assertTrue("setdefaulttimeout(2)" in data)
237         flag = os.path.join(b_dir, ".buildout", "2.updated_bootstrap")
238         self.assertTrue(os.path.exists(flag))
239         buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
240         time2 = os.stat(bpy).st_mtime
241         with salt.utils.files.fopen(bpy) as fic:
242             data = fic.read()
243         self.assertTrue("setdefaulttimeout(2)" in data)
244         flag = os.path.join(b_dir, ".buildout", "1.updated_bootstrap")
245         self.assertTrue(os.path.exists(flag))
246         buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
247         time3 = os.stat(bpy).st_mtime
248         self.assertNotEqual(time2, time1)
249         self.assertEqual(time2, time3)
250 @skipIf(
251     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
252     "The 'virtualenv' packaged needs to be installed",
253 )
254 @pytest.mark.requires_network
255 class BuildoutOnlineTestCase(Base):
256     @classmethod
257     def setUpClass(cls):
258         super().setUpClass()
259         cls.ppy_dis = os.path.join(cls.rdir, "pdistribute")
260         cls.ppy_blank = os.path.join(cls.rdir, "pblank")
261         cls.py_dis = os.path.join(cls.ppy_dis, "bin", "python")
262         cls.py_blank = os.path.join(cls.ppy_blank, "bin", "python")
263         try:
264             subprocess.check_call(
265                 [
266                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
267                     "--no-setuptools",
268                     "--no-pip",
269                     cls.ppy_dis,
270                 ]
271             )
272         except subprocess.CalledProcessError:
273             subprocess.check_call(
274                 [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_dis]
275             )
276             url = (
277                 "https://pypi.python.org/packages/source"
278                 "/d/distribute/distribute-0.6.43.tar.gz"
279             )
280             download_to(
281                 url,
282                 os.path.join(cls.ppy_dis, "distribute-0.6.43.tar.gz"),
283             )
284             subprocess.check_call(
285                 [
286                     "tar",
287                     "-C",
288                     cls.ppy_dis,
289                     "-xzvf",
290                     "{}/distribute-0.6.43.tar.gz".format(cls.ppy_dis),
291                 ]
292             )
293             subprocess.check_call(
294                 [
295                     "{}/bin/python".format(cls.ppy_dis),
296                     "{}/distribute-0.6.43/setup.py".format(cls.ppy_dis),
297                     "install",
298                 ]
299             )
300         try:
301             subprocess.check_call(
302                 [
303                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
304                     "--no-setuptools",
305                     "--no-pip",
306                     cls.ppy_blank,
307                 ]
308             )
309         except subprocess.CalledProcessError:
310             subprocess.check_call(
311                 [
312                     salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
313                     cls.ppy_blank,
314                 ]
315             )
316     @pytest.mark.skip(reason="TODO this test should probably be fixed")
317 <a name="2"></a>    def test_buildout_bootstrap(self):
318         b_dir = os.path.join(self.tdir, "b")
319         bd_dir = os.path.join(self.tdir, "b", "bdistribute")
320         b2_dir = os.path.join(self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.tdir, "b", "b2")
321         self.assertTrue(buildout._has_old_distribute(self.py_dis))
322         self.assertFalse(buildout._has_old_distribute(self.py_st))
323         self.</b></font>assertFalse(buildout._has_setuptools7(self.py_dis))
324 <a name="1"></a>        self.assertTrue(buildout._has_setuptools7(self.py_st))
325         self.assertFalse(buildout._has_setuptools7(self.py_blank))
326         ret <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= buildout.bootstrap(bd_dir, buildout_ver=1, python=self.py_dis)
327         comment = ret["outlog"]
328         self.assertTrue("--distribute" in comment)
329         self.assertTrue(</b></font>"Generated script" in comment)
330         ret = buildout.bootstrap(b_dir, buildout_ver=1, python=self.py_blank)
331         comment = ret["outlog"]
332         self.assertTrue(
333             ("Got " in comment and "Generated script" in comment)
334             or ("setuptools&gt;=0.7" in comment)
335         )
336         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_blank)
337         comment = ret["outlog"]
338         self.assertTrue(
339             ("setuptools" in comment and "Generated script" in comment)
340             or ("setuptools&gt;=0.7" in comment)
341         )
342         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
343         comment = ret["outlog"]
344         self.assertTrue(
345             ("setuptools" in comment and "Generated script" in comment)
346             or ("setuptools&gt;=0.7" in comment)
347         )
348         ret = buildout.bootstrap(b2_dir, buildout_ver=2, python=self.py_st)
349         comment = ret["outlog"]
350         self.assertTrue(
351             ("setuptools" in comment and "Creating directory" in comment)
352             or ("setuptools&gt;=0.7" in comment)
353         )
354     @pytest.mark.slow_test
355     def test_run_buildout(self):
356         if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
357             self.skipTest(
358                 "Skiping until upstream resolved"
359                 " https://github.com/pypa/virtualenv/issues/1715"
360             )
361         b_dir = os.path.join(self.tdir, "b")
362         ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
363         self.assertTrue(ret["status"])
364         ret = buildout.run_buildout(b_dir, parts=["a", "b"])
365         out = ret["out"]
366         self.assertTrue("Installing a" in out)
367         self.assertTrue("Installing b" in out)
368     @pytest.mark.slow_test
369     def test_buildout(self):
370         if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
371             self.skipTest(
372                 "Skiping until upstream resolved"
373                 " https://github.com/pypa/virtualenv/issues/1715"
374             )
375         b_dir = os.path.join(self.tdir, "b")
376         ret = buildout.buildout(b_dir, buildout_ver=2, python=self.py_st)
377         self.assertTrue(ret["status"])
378         out = ret["out"]
379         comment = ret["comment"]
380         self.assertTrue(ret["status"])
381         self.assertTrue("Creating directory" in out)
382         self.assertTrue("Installing a." in out)
383         self.assertTrue("{} bootstrap.py".format(self.py_st) in comment)
384         self.assertTrue("buildout -c buildout.cfg" in comment)
385         ret = buildout.buildout(
386             b_dir, parts=["a", "b", "c"], buildout_ver=2, python=self.py_st
387         )
388         outlog = ret["outlog"]
389         out = ret["out"]
390         comment = ret["comment"]
391         self.assertTrue("Installing single part: a" in outlog)
392         self.assertTrue("buildout -c buildout.cfg -N install a" in comment)
393         self.assertTrue("Installing b." in out)
394         self.assertTrue("Installing c." in out)
395         ret = buildout.buildout(
396             b_dir, parts=["a", "b", "c"], buildout_ver=2, newest=True, python=self.py_st
397         )
398         outlog = ret["outlog"]
399         out = ret["out"]
400         comment = ret["comment"]
401         self.assertTrue("buildout -c buildout.cfg -n install a" in comment)
402 class BuildoutAPITestCase(TestCase):
403     def test_merge(self):
404         buildout.LOG.clear()
405         buildout.LOG.info("àé")
406         buildout.LOG.info("àé")
407         buildout.LOG.error("àé")
408         buildout.LOG.error("àé")
409         ret1 = buildout._set_status({}, out="éà")
410         uret1 = buildout._set_status({}, out="éà")
411         buildout.LOG.clear()
412         buildout.LOG.info("ççàé")
413         buildout.LOG.info("ççàé")
414         buildout.LOG.error("ççàé")
415         buildout.LOG.error("ççàé")
416         ret2 = buildout._set_status({}, out="çéà")
417         uret2 = buildout._set_status({}, out="çéà")
418         uretm = buildout._merge_statuses([ret1, uret1, ret2, uret2])
419         for ret in ret1, uret1, ret2, uret2:
420             out = ret["out"]
421             if not isinstance(ret["out"], str):
422                 out = ret["out"].decode("utf-8")
423         for out in ["àé", "ççàé"]:
424             self.assertTrue(out in uretm["logs_by_level"]["info"])
425             self.assertTrue(out in uretm["outlog_by_level"])
426     def test_setup(self):
427         buildout.LOG.clear()
428         buildout.LOG.info("àé")
429         buildout.LOG.info("àé")
430         buildout.LOG.error("àé")
431         buildout.LOG.error("àé")
432         ret = buildout._set_status({}, out="éà")
433         uret = buildout._set_status({}, out="éà")
434         self.assertTrue(ret["outlog"] == uret["outlog"])
435         self.assertTrue("àé" in uret["outlog_by_level"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import absolute_import, division, print_function
2 import collections
3 from contextlib import closing
4 import errno
5 import gzip
6 import logging
7 import os
8 import re
9 import socket
10 import ssl
11 import sys
12 from salt.ext.tornado.escape import to_unicode
13 from salt.ext.tornado import gen
14 from salt.ext.tornado.httpclient import AsyncHTTPClient
15 from salt.ext.tornado.httputil import HTTPHeaders, ResponseStartLine
16 from salt.ext.tornado.ioloop import IOLoop
17 from salt.ext.tornado.log import gen_log
18 from</b></font> salt.ext.tornado.concurrent import Future
19 from salt.ext.tornado.netutil import Resolver, bind_sockets
20 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
21 from salt.ext.tornado.test.httpclient_test import ChunkHandler, CountdownHandler, HelloWorldHandler, RedirectHandler
22 from salt.ext.tornado.test import httpclient_test
23 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog
24 from salt.ext.tornado.test.util import skipOnTravis, skipIfNoIPv6, refusing_port, unittest, skipBefore35, exec_test
25 from salt.ext.tornado.web import RequestHandler, Application, asynchronous, url, stream_request_body
26 class SimpleHTTPClientCommonTestCase(httpclient_test.HTTPClientCommonTestCase):
27     def get_http_client(self):
28         client = SimpleAsyncHTTPClient(io_loop=self.io_loop,
29                                        force_instance=True)
30         self.assertTrue(isinstance(client, SimpleAsyncHTTPClient))
31         return client
32 class TriggerHandler(RequestHandler):
33     def initialize(self, queue, wake_callback):
34         self.queue = queue
35         self.wake_callback = wake_callback
36     @asynchronous
37     def get(self):
38         logging.debug("queuing trigger")
39         self.queue.append(self.finish)
40         if self.get_argument("wake", "true") == "true":
41             self.wake_callback()
42 class HangHandler(RequestHandler):
43     @asynchronous
44     def get(self):
45         pass
46 class ContentLengthHandler(RequestHandler):
47     def get(self):
48         self.set_header("Content-Length", self.get_argument("value"))
49         self.write("ok")
50 class HeadHandler(RequestHandler):
51     def head(self):
52         self.set_header("Content-Length", "7")
53 class OptionsHandler(RequestHandler):
54     def options(self):
55         self.set_header("Access-Control-Allow-Origin", "*")
56         self.write("ok")
57 class NoContentHandler(RequestHandler):
58     def get(self):
59         self.set_status(204)
60         self.finish()
61 class SeeOtherPostHandler(RequestHandler):
62     def post(self):
63         redirect_code = int(self.request.body)
64         assert redirect_code in (302, 303), "unexpected body %r" % self.request.body
65         self.set_header("Location", "/see_other_get")
66         self.set_status(redirect_code)
67 class SeeOtherGetHandler(RequestHandler):
68     def get(self):
69         if self.request.body:
70             raise Exception("unexpected body %r" % self.request.body)
71         self.write("ok")
72 class HostEchoHandler(RequestHandler):
73     def get(self):
74         self.write(self.request.headers["Host"])
75 class NoContentLengthHandler(RequestHandler):
76     @asynchronous
77     def get(self):
78         if self.request.version.startswith('HTTP/1'):
79             stream = self.request.connection.detach()
80             stream.write(b"HTTP/1.0 200 OK\r\n\r\n"
81                          b"hello")
82             stream.close()
83         else:
84             self.finish('HTTP/1 required')
85 class EchoPostHandler(RequestHandler):
86     def post(self):
87         self.write(self.request.body)
88 @stream_request_body
89 class RespondInPrepareHandler(RequestHandler):
90     def prepare(self):
91         self.set_status(403)
92         self.finish("forbidden")
93 class SimpleHTTPClientTestMixin(object):
94     def get_app(self):
95         self.triggers = collections.deque()
96         return Application([
97             url("/trigger", TriggerHandler, dict(queue=self.triggers,
98                                                  wake_callback=self.stop)),
99             url("/chunk", ChunkHandler),
100             url("/countdown/([0-9]+)", CountdownHandler, name="countdown"),
101             url("/hang", HangHandler),
102             url("/hello", HelloWorldHandler),
103             url("/content_length", ContentLengthHandler),
104             url("/head", HeadHandler),
105             url("/options", OptionsHandler),
106             url("/no_content", NoContentHandler),
107             url("/see_other_post", SeeOtherPostHandler),
108             url("/see_other_get", SeeOtherGetHandler),
109             url("/host_echo", HostEchoHandler),
110             url("/no_content_length", NoContentLengthHandler),
111             url("/echo_post", EchoPostHandler),
112             url("/respond_in_prepare", RespondInPrepareHandler),
113             url("/redirect", RedirectHandler),
114         ], gzip=True)
115     def test_singleton(self):
116         self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is
117                         SimpleAsyncHTTPClient(self.io_loop))
118         self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
119                         SimpleAsyncHTTPClient(self.io_loop,
120                                               force_instance=True))
121         with closing(IOLoop()) as io_loop2:
122             self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
123                             SimpleAsyncHTTPClient(io_loop2))
124     def test_connection_limit(self):
125         with closing(self.create_client(max_clients=2)) as client:
126             self.assertEqual(client.max_clients, 2)
127             seen = []
128             for i in range(4):
129                 client.fetch(self.get_url("/trigger"),
130                              lambda response, i=i: (seen.append(i), self.stop()))
131             self.wait(condition=lambda: len(self.triggers) == 2)
132             self.assertEqual(len(client.queue), 2)
133             self.triggers.popleft()()
134             self.triggers.popleft()()
135             self.wait(condition=lambda: (len(self.triggers) == 2 and
136                                          len(seen) == 2))
137             self.assertEqual(set(seen), set([0, 1]))
138             self.assertEqual(len(client.queue), 0)
139             self.triggers.popleft()()
140             self.triggers.popleft()()
141             self.wait(condition=lambda: len(seen) == 4)
142             self.assertEqual(set(seen), set([0, 1, 2, 3]))
143             self.assertEqual(len(self.triggers), 0)
144     def test_redirect_connection_limit(self):
145         with closing(self.create_client(max_clients=1)) as client:
146             client.fetch(self.get_url('/countdown/3'), self.stop,
147                          max_redirects=3)
148             response = self.wait()
149             response.rethrow()
150     def test_gzip(self):
151         response = self.fetch("/chunk", use_gzip=False,
152                               headers={"Accept-Encoding": "gzip"})
153         self.assertEqual(response.headers["Content-Encoding"], "gzip")
154         self.assertNotEqual(response.body, b"asdfqwer")
155         self.assertEqual(len(response.body), 34)
156         f = gzip.GzipFile(mode="r", fileobj=response.buffer)
157         self.assertEqual(f.read(), b"asdfqwer")
158     def test_max_redirects(self):
159         response = self.fetch("/countdown/5", max_redirects=3)
160 <a name="2"></a>        self.assertEqual(302, response.code)
161         self.assertTrue(response.request<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.url.endswith("/countdown/5"))
162         self.assertTrue(response.effective_url.endswith("/countdown/2"))
163         self.assertTrue(response.headers[</b></font>"Location"].endswith("/countdown/1"))
164     def test_header_reuse(self):
165         headers = HTTPHeaders({'User-Agent': 'Foo'})
166         self.fetch("/hello", headers=headers)
167         self.assertEqual(list(headers.get_all()), [('User-Agent', 'Foo')])
168     def test_see_other_redirect(self):
169         for code in (302, 303):
170             response = self.fetch("/see_other_post", method="POST", body="%d" % code)
171             self.assertEqual(200, response.code)
172             self.assertTrue(response.request.url.endswith("/see_other_post"))
173             self.assertTrue(response.effective_url.endswith("/see_other_get"))
174             self.assertEqual("POST", response.request.method)
175     @skipOnTravis
176     def test_connect_timeout(self):
177         timeout = 0.1
178         timeout_min, timeout_max = 0.099, 1.0
179         class TimeoutResolver(Resolver):
180             def resolve(self, *args, **kwargs):
181                 return Future()  # never completes
182         with closing(self.create_client(resolver=TimeoutResolver())) as client:
183             client.fetch(self.get_url('/hello'), self.stop,
184                          connect_timeout=timeout)
185             response = self.wait()
186             self.assertEqual(response.code, 599)
187             self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
188                             response.request_time)
189             self.assertEqual(str(response.error), "HTTP 599: Timeout while connecting")
190     @skipOnTravis
191     def test_request_timeout(self):
192         timeout = 0.1
193         timeout_min, timeout_max = 0.099, 0.15
194         if os.name == 'nt':
195             timeout = 0.5
196             timeout_min, timeout_max = 0.4, 0.6
197         response = self.fetch('/trigger?wake=false', request_timeout=timeout)
198         self.assertEqual(response.code, 599)
199         self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
200                         response.request_time)
201         self.assertEqual(str(response.error), "HTTP 599: Timeout during request")
202         self.triggers.popleft()()
203     @skipIfNoIPv6
204     def test_ipv6(self):
205         [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)
206         port = sock.getsockname()[1]
207         self.http_server.add_socket(sock)
208         url = '%s://[::1]:%d/hello' % (self.get_protocol(), port)
209         self.http_client.fetch(url, self.stop, allow_ipv6=False)
210         response = self.wait()
211         self.assertEqual(response.code, 599)
212         self.http_client.fetch(url, self.stop)
213         response = self.wait()
214         self.assertEqual(response.body, b"Hello world!")
215     def xtest_multiple_content_length_accepted(self):
216         response = self.fetch("/content_length?value=2,2")
217         self.assertEqual(response.body, b"ok")
218         response = self.fetch("/content_length?value=2,%202,2")
219         self.assertEqual(response.body, b"ok")
220         response = self.fetch("/content_length?value=2,4")
221         self.assertEqual(response.code, 599)
222         response = self.fetch("/content_length?value=2,%202,3")
223         self.assertEqual(response.code, 599)
224     def test_head_request(self):
225         response = self.fetch("/head", method="HEAD")
226         self.assertEqual(response.code, 200)
227         self.assertEqual(response.headers["content-length"], "7")
228         self.assertFalse(response.body)
229 <a name="3"></a>
230     def test_options_request(self):
231         response = self.fetch("/options", method="OPTIONS")
232         self.assertEqual(response<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.code, 200)
233         self.assertEqual(response.headers["content-length"], "2")
234         self.assertEqual(response.headers["access-control-allow-origin"], "*")
235         self.assertEqual(response.</b></font>body, b"ok")
236     def test_no_content(self):
237         response = self.fetch("/no_content")
238         self.assertEqual(response.code, 204)
239         self.assertNotIn("Content-Length", response.headers)
240     def test_host_header(self):
241         host_re = re.compile(b"^127.0.0.1:[0-9]+$")
242         response = self.fetch("/host_echo")
243         self.assertTrue(host_re.match(response.body))
244         url = self.get_url("/host_echo").replace("http://", "http://me:secret@")
245         self.http_client.fetch(url, self.stop)
246         response = self.wait()
247         self.assertTrue(host_re.match(response.body), response.body)
248     def test_connection_refused(self):
249         cleanup_func, port = refusing_port()
250         self.addCleanup(cleanup_func)
251         with ExpectLog(gen_log, ".*", required=False):
252             self.http_client.fetch("http://127.0.0.1:%d/" % port, self.stop)
253             response = self.wait()
254         self.assertEqual(599, response.code)
255         if sys.platform != 'cygwin':
256             contains_errno = str(errno.ECONNREFUSED) in str(response.error)
257             if not contains_errno and hasattr(errno, "WSAECONNREFUSED"):
258                 contains_errno = str(errno.WSAECONNREFUSED) in str(response.error)
259             self.assertTrue(contains_errno, response.error)
260             expected_message = os.strerror(errno.ECONNREFUSED)
261             self.assertTrue(expected_message in str(response.error),
262                             response.error)
263     def test_queue_timeout(self):
264         with closing(self.create_client(max_clients=1)) as client:
265             client.fetch(self.get_url('/trigger'), self.stop,
266                          request_timeout=10)
267             self.wait()
268             client.fetch(self.get_url('/hello'), self.stop,
269                          connect_timeout=0.1)
270             response = self.wait()
271             self.assertEqual(response.code, 599)
272             self.assertTrue(response.request_time &lt; 1, response.request_time)
273             self.assertEqual(str(response.error), "HTTP 599: Timeout in request queue")
274             self.triggers.popleft()()
275             self.wait()
276     def test_no_content_length(self):
277         response = self.fetch("/no_content_length")
278         if response.body == b"HTTP/1 required":
279             self.skipTest("requires HTTP/1.x")
280         else:
281             self.assertEquals(b"hello", response.body)
282     def sync_body_producer(self, write):
283         write(b'1234')
284         write(b'5678')
285     @gen.coroutine
286     def async_body_producer(self, write):
287         yield write(b'1234')
288         yield gen.Task(IOLoop.current().add_callback)
289         yield write(b'5678')
290     def test_sync_body_producer_chunked(self):
291         response = self.fetch("/echo_post", method="POST",
292                               body_producer=self.sync_body_producer)
293         response.rethrow()
294 <a name="1"></a>        self.assertEqual(response.body, b"12345678")
295     def test_sync_body_producer_content_length(self):
296         response <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch("/echo_post", method="POST",
297                               body_producer=self.sync_body_producer,
298                               headers={'Content-Length': '8'})
299         response.rethrow()
300         self.assertEqual(</b></font>response.body, b"12345678")
301     def test_async_body_producer_chunked(self):
302         response = self.fetch("/echo_post", method="POST",
303                               body_producer=self.async_body_producer)
304         response.rethrow()
305         self.assertEqual(response.body, b"12345678")
306     def test_async_body_producer_content_length(self):
307         response = self.fetch("/echo_post", method="POST",
308                               body_producer=self.async_body_producer,
309                               headers={'Content-Length': '8'})
310         response.rethrow()
311         self.assertEqual(response.body, b"12345678")
312     @skipBefore35
313     def test_native_body_producer_chunked(self):
314         namespace = exec_test(globals(), locals(), """
315         async def body_producer(write):
316             await write(b'1234')
317             await gen.Task(IOLoop.current().add_callback)
318             await write(b'5678')
319         response = self.fetch("/echo_post", method="POST",
320                               body_producer=namespace["body_producer"],
321                               headers={'Content-Length': '8'})
322         response.rethrow()
323         self.assertEqual(response.body, b"12345678")
324     def test_100_continue(self):
325         response = self.fetch("/echo_post", method="POST",
326                               body=b"1234",
327                               expect_100_continue=True)
328         self.assertEqual(response.body, b"1234")
329     def test_100_continue_early_response(self):
330         def body_producer(write):
331             raise Exception("should not be called")
332         response = self.fetch("/respond_in_prepare", method="POST",
333                               body_producer=body_producer,
334                               expect_100_continue=True)
335         self.assertEqual(response.code, 403)
336     def test_streaming_follow_redirects(self):
337         headers = []
338         chunks = []
339         self.fetch("/redirect?url=/hello",
340                    header_callback=headers.append,
341                    streaming_callback=chunks.append)
342         chunks = list(map(to_unicode, chunks))
343         self.assertEqual(chunks, ['Hello world!'])
344         num_start_lines = len([h for h in headers if h.startswith("HTTP/")])
345         self.assertEqual(num_start_lines, 1)
346 class SimpleHTTPClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPTestCase):
347     def setUp(self):
348         super(SimpleHTTPClientTestCase, self).setUp()
349         self.http_client = self.create_client()
350     def create_client(self, **kwargs):
351         return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
352                                      **kwargs)
353 class SimpleHTTPSClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPSTestCase):
354     def setUp(self):
355         super(SimpleHTTPSClientTestCase, self).setUp()
356         self.http_client = self.create_client()
357     def create_client(self, **kwargs):
358         return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
359                                      defaults=dict(validate_cert=False),
360                                      **kwargs)
361     def test_ssl_options(self):
362         resp = self.fetch("/hello", ssl_options={})
363         self.assertEqual(resp.body, b"Hello world!")
364     @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
365                      'ssl.SSLContext not present')
366     def test_ssl_context(self):
367         resp = self.fetch("/hello",
368                           ssl_options=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
369         self.assertEqual(resp.body, b"Hello world!")
370     def test_ssl_options_handshake_fail(self):
371         with ExpectLog(gen_log, "SSL Error|Uncaught exception",
372                        required=False):
373             resp = self.fetch(
374                 "/hello", ssl_options=dict(cert_reqs=ssl.CERT_REQUIRED))
375         self.assertRaises(ssl.SSLError, resp.rethrow)
376     @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
377                      'ssl.SSLContext not present')
378     def test_ssl_context_handshake_fail(self):
379         with ExpectLog(gen_log, "SSL Error|Uncaught exception"):
380             ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
381             ctx.verify_mode = ssl.CERT_REQUIRED
382             resp = self.fetch("/hello", ssl_options=ctx)
383         self.assertRaises(ssl.SSLError, resp.rethrow)
384     def test_error_logging(self):
385         with ExpectLog(gen_log, '.*') as expect_log:
386             response = self.fetch("/", validate_cert=True)
387             self.assertEqual(response.code, 599)
388             self.assertIsInstance(response.error, ssl.SSLError)
389         self.assertFalse(expect_log.logged_stack)
390 class CreateAsyncHTTPClientTestCase(AsyncTestCase):
391     def setUp(self):
392         super(CreateAsyncHTTPClientTestCase, self).setUp()
393         self.saved = AsyncHTTPClient._save_configuration()
394     def tearDown(self):
395         AsyncHTTPClient._restore_configuration(self.saved)
396         super(CreateAsyncHTTPClientTestCase, self).tearDown()
397     def test_max_clients(self):
398         AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
399         with closing(AsyncHTTPClient(
400                 self.io_loop, force_instance=True)) as client:
401             self.assertEqual(client.max_clients, 10)
402         with closing(AsyncHTTPClient(
403                 self.io_loop, max_clients=11, force_instance=True)) as client:
404             self.assertEqual(client.max_clients, 11)
405         AsyncHTTPClient.configure(SimpleAsyncHTTPClient, max_clients=12)
406         with closing(AsyncHTTPClient(
407                 self.io_loop, force_instance=True)) as client:
408             self.assertEqual(client.max_clients, 12)
409         with closing(AsyncHTTPClient(
410                 self.io_loop, max_clients=13, force_instance=True)) as client:
411             self.assertEqual(client.max_clients, 13)
412         with closing(AsyncHTTPClient(
413                 self.io_loop, max_clients=14, force_instance=True)) as client:
414             self.assertEqual(client.max_clients, 14)
415 class HTTP100ContinueTestCase(AsyncHTTPTestCase):
416     def respond_100(self, request):
417         self.http1 = request.version.startswith('HTTP/1.')
418         if not self.http1:
419             request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
420                                              HTTPHeaders())
421             request.connection.finish()
422             return
423         self.request = request
424         self.request.connection.stream.write(
425             b"HTTP/1.1 100 CONTINUE\r\n\r\n",
426             self.respond_200)
427     def respond_200(self):
428         self.request.connection.stream.write(
429             b"HTTP/1.1 200 OK\r\nContent-Length: 1\r\n\r\nA",
430             self.request.connection.stream.close)
431     def get_app(self):
432         return self.respond_100
433     def test_100_continue(self):
434         res = self.fetch('/')
435         if not self.http1:
436             self.skipTest("requires HTTP/1.x")
437         self.assertEqual(res.body, b'A')
438 class HTTP204NoContentTestCase(AsyncHTTPTestCase):
439     def respond_204(self, request):
440         self.http1 = request.version.startswith('HTTP/1.')
441         if not self.http1:
442             request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
443                                              HTTPHeaders())
444             request.connection.finish()
445             return
446         stream = request.connection.detach()
447         stream.write(b"HTTP/1.1 204 No content\r\n")
448         if request.arguments.get("error", [False])[-1]:
449             stream.write(b"Content-Length: 5\r\n")
450         else:
451             stream.write(b"Content-Length: 0\r\n")
452         stream.write(b"\r\n")
453         stream.close()
454     def get_app(self):
455         return self.respond_204
456     def test_204_no_content(self):
457         resp = self.fetch('/')
458         if not self.http1:
459             self.skipTest("requires HTTP/1.x")
460         self.assertEqual(resp.code, 204)
461         self.assertEqual(resp.body, b'')
462     def test_204_invalid_content_length(self):
463         with ExpectLog(gen_log, ".*Response with code 204 should not have body"):
464             response = self.fetch("/?error=1")
465             if not self.http1:
466                 self.skipTest("requires HTTP/1.x")
467             if self.http_client.configured_class != SimpleAsyncHTTPClient:
468                 self.skipTest("curl client accepts invalid headers")
469             self.assertEqual(response.code, 599)
470 class HostnameMappingTestCase(AsyncHTTPTestCase):
471     def setUp(self):
472         super(HostnameMappingTestCase, self).setUp()
473         self.http_client = SimpleAsyncHTTPClient(
474             self.io_loop,
475             hostname_mapping={
476                 'www.example.com': '127.0.0.1',
477                 ('foo.example.com', 8000): ('127.0.0.1', self.get_http_port()),
478             })
479     def get_app(self):
480         return Application([url("/hello", HelloWorldHandler), ])
481     def test_hostname_mapping(self):
482         self.http_client.fetch(
483             'http://www.example.com:%d/hello' % self.get_http_port(), self.stop)
484         response = self.wait()
485         response.rethrow()
486         self.assertEqual(response.body, b'Hello world!')
487     def test_port_mapping(self):
488         self.http_client.fetch('http://foo.example.com:8000/hello', self.stop)
489         response = self.wait()
490         response.rethrow()
491         self.assertEqual(response.body, b'Hello world!')
492 class ResolveTimeoutTestCase(AsyncHTTPTestCase):
493     def setUp(self):
494         class BadResolver(Resolver):
495             def resolve(self, *args, **kwargs):
496                 pass
497         super(ResolveTimeoutTestCase, self).setUp()
498         self.http_client = SimpleAsyncHTTPClient(
499             self.io_loop,
500             resolver=BadResolver())
501     def get_app(self):
502         return Application([url("/hello", HelloWorldHandler), ])
503     def test_resolve_timeout(self):
504         response = self.fetch('/hello', connect_timeout=0.1)
505         self.assertEqual(response.code, 599)
506 class MaxHeaderSizeTest(AsyncHTTPTestCase):
507     def get_app(self):
508         class SmallHeaders(RequestHandler):
509             def get(self):
510                 self.set_header("X-Filler", "a" * 100)
511                 self.write("ok")
512         class LargeHeaders(RequestHandler):
513             def get(self):
514                 self.set_header("X-Filler", "a" * 1000)
515                 self.write("ok")
516         return Application([('/small', SmallHeaders),
517                             ('/large', LargeHeaders)])
518     def get_http_client(self):
519         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_header_size=1024)
520     def test_small_headers(self):
521         response = self.fetch('/small')
522         response.rethrow()
523         self.assertEqual(response.body, b'ok')
524     def test_large_headers(self):
525         with ExpectLog(gen_log, "Unsatisfiable read"):
526             response = self.fetch('/large')
527         self.assertEqual(response.code, 599)
528 class MaxBodySizeTest(AsyncHTTPTestCase):
529     def get_app(self):
530         class SmallBody(RequestHandler):
531             def get(self):
532                 self.write("a" * 1024 * 64)
533         class LargeBody(RequestHandler):
534             def get(self):
535                 self.write("a" * 1024 * 100)
536         return Application([('/small', SmallBody),
537                             ('/large', LargeBody)])
538     def get_http_client(self):
539         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 64)
540     def test_small_body(self):
541         response = self.fetch('/small')
542         response.rethrow()
543         self.assertEqual(response.body, b'a' * 1024 * 64)
544     def test_large_body(self):
545         with ExpectLog(gen_log, "Malformed HTTP message from None: Content-Length too long"):
546             response = self.fetch('/large')
547         self.assertEqual(response.code, 599)
548 class MaxBufferSizeTest(AsyncHTTPTestCase):
549     def get_app(self):
550         class LargeBody(RequestHandler):
551             def get(self):
552                 self.write("a" * 1024 * 100)
553         return Application([('/large', LargeBody)])
554     def get_http_client(self):
555         return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 100, max_buffer_size=1024 * 64)
556     def test_large_body(self):
557         response = self.fetch('/large')
558         response.rethrow()
559         self.assertEqual(response.body, b'a' * 1024 * 100)
560 class ChunkedWithContentLengthTest(AsyncHTTPTestCase):
561     def get_app(self):
562         class ChunkedWithContentLength(RequestHandler):
563             def get(self):
564                 self.set_header('Transfer-Encoding', 'chunked')
565                 self.write("Hello world")
566         return Application([('/chunkwithcl', ChunkedWithContentLength)])
567     def get_http_client(self):
568         return SimpleAsyncHTTPClient()
569     def test_chunked_with_content_length(self):
570         with ExpectLog(gen_log, ("Malformed HTTP message from None: Response "
571                                  "with both Transfer-Encoding and Content-Length")):
572             response = self.fetch('/chunkwithcl')
573         self.assertEqual(response.code, 599)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
