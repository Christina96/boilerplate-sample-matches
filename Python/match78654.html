<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_zcbuildout_1.py & simple_httpclient_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_zcbuildout_1.py & simple_httpclient_test.py
      </h3>
      <h1 align="center">
        4.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_zcbuildout_1.py (4.927007%)<TH>simple_httpclient_test.py (3.5952065%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match78654-0.html#0',2,'match78654-1.html#0',3)" NAME="0">(1-19)<TD><A HREF="javascript:ZweiFrames('match78654-0.html#0',2,'match78654-1.html#0',3)" NAME="0">(2-21)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match78654-0.html#1',2,'match78654-1.html#1',3)" NAME="1">(419-422)<TD><A HREF="javascript:ZweiFrames('match78654-0.html#1',2,'match78654-1.html#1',3)" NAME="1">(393-397)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match78654-0.html#2',2,'match78654-1.html#2',3)" NAME="2">(408-415)<TD><A HREF="javascript:ZweiFrames('match78654-0.html#2',2,'match78654-1.html#2',3)" NAME="2">(220-222)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match78654-0.html#3',2,'match78654-1.html#3',3)" NAME="3">(201-203)<TD><A HREF="javascript:ZweiFrames('match78654-0.html#3',2,'match78654-1.html#3',3)" NAME="3">(309-312)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zcbuildout_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match78654-1.html#0',3,'match78654-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import logging
import os
import shutil
import subprocess
import tempfile
import urllib.error
import urllib.request

import pytest
import salt.modules.cmdmod as cmd
import salt.modules.virtualenv_mod
import salt.modules.zcbuildout as buildout
import salt.utils.files
import salt.utils.path
import salt.utils.platform
from tests.support.helpers import patched_environ
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.runtests import RUNTIME_VARS
from</B></FONT> tests.support.unit import TestCase, skipIf

KNOWN_VIRTUALENV_BINARY_NAMES = (
    &quot;virtualenv&quot;,
    &quot;virtualenv2&quot;,
    &quot;virtualenv-2.6&quot;,
    &quot;virtualenv-2.7&quot;,
)

BOOT_INIT = {
    1: [&quot;var/ver/1/bootstrap/bootstrap.py&quot;],
    2: [&quot;var/ver/2/bootstrap/bootstrap.py&quot;, &quot;b/bootstrap.py&quot;],
}

log = logging.getLogger(__name__)


def download_to(url, dest):
    req = urllib.request.Request(url)
    req.add_header(
        &quot;User-Agent&quot;,
        &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&quot;,
    )
    with salt.utils.files.fopen(dest, &quot;wb&quot;) as fic:
        fic.write(urllib.request.urlopen(req, timeout=10).read())


class Base(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            buildout: {
                &quot;__salt__&quot;: {
                    &quot;cmd.run_all&quot;: cmd.run_all,
                    &quot;cmd.run&quot;: cmd.run,
                    &quot;cmd.retcode&quot;: cmd.retcode,
                }
            }
        }

    @classmethod
    def setUpClass(cls):
        if not os.path.isdir(RUNTIME_VARS.TMP):
            os.makedirs(RUNTIME_VARS.TMP)

        cls.root = os.path.join(RUNTIME_VARS.BASE_FILES, &quot;buildout&quot;)
        cls.rdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        cls.tdir = os.path.join(cls.rdir, &quot;test&quot;)
        for idx, url in buildout._URL_VERSIONS.items():
            log.debug(&quot;Downloading bootstrap from %s&quot;, url)
            dest = os.path.join(cls.rdir, &quot;{}_bootstrap.py&quot;.format(idx))
            try:
                download_to(url, dest)
            except urllib.error.URLError as exc:
                log.debug(&quot;Failed to download %s: %s&quot;, url, exc)
        # creating a new setuptools install
        cls.ppy_st = os.path.join(cls.rdir, &quot;psetuptools&quot;)
        if salt.utils.platform.is_windows():
            cls.bin_st = os.path.join(cls.ppy_st, &quot;Scripts&quot;)
            cls.py_st = os.path.join(cls.bin_st, &quot;python&quot;)
        else:
            cls.bin_st = os.path.join(cls.ppy_st, &quot;bin&quot;)
            cls.py_st = os.path.join(cls.bin_st, &quot;python&quot;)
        # `--no-site-packages` has been deprecated
        # https://virtualenv.pypa.io/en/stable/reference/#cmdoption-no-site-packages
        subprocess.check_call(
            [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_st]
        )
        # Setuptools &gt;=53.0.0 no longer has easy_install
        # Between 50.0.0 and 53.0.0 it has problems with salt, use an older version
        subprocess.check_call(
            [os.path.join(cls.bin_st, &quot;pip&quot;), &quot;install&quot;, &quot;-U&quot;, &quot;setuptools&lt;50.0.0&quot;]
        )
        # distribute has been merged back in to setuptools as of v0.7. So, no
        # need to upgrade distribute, but this seems to be the only way to get
        # the binary in the right place
        # https://packaging.python.org/key_projects/#setuptools
        # Additionally, this part may fail if the certificate store is outdated
        # on Windows, as it would be in a fresh installation for example. The
        # following commands will fix that. This should be part of the golden
        # images. (https://github.com/saltstack/salt-jenkins/pull/1479)
        # certutil -generateSSTFromWU roots.sst
        # powershell &quot;(Get-ChildItem -Path .\roots.sst) | Import-Certificate -CertStoreLocation Cert:\LocalMachine\Root&quot;
        subprocess.check_call(
            [os.path.join(cls.bin_st, &quot;easy_install&quot;), &quot;-U&quot;, &quot;distribute&quot;]
        )

    def setUp(self):
        if salt.utils.platform.is_darwin():
            self.patched_environ = patched_environ(__cleanup__=[&quot;__PYVENV_LAUNCHER__&quot;])
            self.patched_environ.__enter__()
            self.addCleanup(self.patched_environ.__exit__)

        super().setUp()
        self._remove_dir()
        shutil.copytree(self.root, self.tdir)

        for idx in BOOT_INIT:
            path = os.path.join(self.rdir, &quot;{}_bootstrap.py&quot;.format(idx))
            for fname in BOOT_INIT[idx]:
                shutil.copy2(path, os.path.join(self.tdir, fname))

    def tearDown(self):
        super().tearDown()
        self._remove_dir()

    def _remove_dir(self):
        if os.path.isdir(self.tdir):
            shutil.rmtree(self.tdir)


@skipIf(
    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
    &quot;The 'virtualenv' packaged needs to be installed&quot;,
)
@pytest.mark.requires_network
class BuildoutTestCase(Base):
    @pytest.mark.slow_test
    def test_onlyif_unless(self):
        b_dir = os.path.join(self.tdir, &quot;b&quot;)
        ret = buildout.buildout(b_dir, onlyif=RUNTIME_VARS.SHELL_FALSE_PATH)
        self.assertTrue(ret[&quot;comment&quot;] == &quot;onlyif condition is false&quot;)
        self.assertTrue(ret[&quot;status&quot;] is True)
        ret = buildout.buildout(b_dir, unless=RUNTIME_VARS.SHELL_TRUE_PATH)
        self.assertTrue(ret[&quot;comment&quot;] == &quot;unless condition is true&quot;)
        self.assertTrue(ret[&quot;status&quot;] is True)

    @pytest.mark.slow_test
    def test_salt_callback(self):
        @buildout._salt_callback
        def callback1(a, b=1):
            for i in buildout.LOG.levels:
                getattr(buildout.LOG, i)(&quot;{}bar&quot;.format(i[0]))
            return &quot;foo&quot;

        def callback2(a, b=1):
            raise Exception(&quot;foo&quot;)

        # pylint: disable=invalid-sequence-index
        ret1 = callback1(1, b=3)
        # These lines are throwing pylint errors - disabling for now since we are skipping
        # these tests
        # self.assertEqual(ret1['status'], True)
        # self.assertEqual(ret1['logs_by_level']['warn'], ['wbar'])
        # self.assertEqual(ret1['comment'], '')
        # These lines are throwing pylint errors - disabling for now since we are skipping
        # these tests
        # self.assertTrue(
        #     u''
        #     u'OUTPUT:\n'
        #     u'foo\n'
        #     u''
        #    in ret1['outlog']
        # )

        # These lines are throwing pylint errors - disabling for now since we are skipping
        # these tests
        # self.assertTrue(u'Log summary:\n' in ret1['outlog'])
        # These lines are throwing pylint errors - disabling for now since we are skipping
        # these tests
        # self.assertTrue(
        #     u'INFO: ibar\n'
        #     u'WARN: wbar\n'
        #     u'DEBUG: dbar\n'
        #     u'ERROR: ebar\n'
        #    in ret1['outlog']
        # )
        # These lines are throwing pylint errors - disabling for now since we are skipping
        # these tests
        # self.assertTrue('by level' in ret1['outlog_by_level'])
        # self.assertEqual(ret1['out'], 'foo')
        ret2 = buildout._salt_callback(callback2)(2, b=6)
        self.assertEqual(ret2[&quot;status&quot;], False)
        self.assertTrue(ret2[&quot;logs_by_level&quot;][&quot;error&quot;][0].startswith(&quot;Traceback&quot;))
        self.assertTrue(&quot;Unexpected response from buildout&quot; in ret2[&quot;comment&quot;])
        self.assertEqual(ret2[&quot;out&quot;], None)
        for l in buildout.LOG.levels:
            self.assertTrue(0 == len(buildout.LOG.by_level[l]))
        # pylint: enable=invalid-sequence-index

<A NAME="3"></A>    @pytest.mark.slow_test
    def test_get_bootstrap_url(self):
        for path in [
            os<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match78654-1.html#3',3,'match78654-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.path.join(self.tdir, &quot;var/ver/1/dumppicked&quot;),
            os.path.join(self.tdir, &quot;var/ver/1/bootstrap&quot;),
            os.path.join(self.</B></FONT>tdir, &quot;var/ver/1/versions&quot;),
        ]:
            self.assertEqual(
                buildout._URL_VERSIONS[1],
                buildout._get_bootstrap_url(path),
                &quot;b1 url for {}&quot;.format(path),
            )
        for path in [
            os.path.join(self.tdir, &quot;/non/existing&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/versions&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/bootstrap&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/default&quot;),
        ]:
            self.assertEqual(
                buildout._URL_VERSIONS[2],
                buildout._get_bootstrap_url(path),
                &quot;b2 url for {}&quot;.format(path),
            )

    @pytest.mark.slow_test
    def test_get_buildout_ver(self):
        for path in [
            os.path.join(self.tdir, &quot;var/ver/1/dumppicked&quot;),
            os.path.join(self.tdir, &quot;var/ver/1/bootstrap&quot;),
            os.path.join(self.tdir, &quot;var/ver/1/versions&quot;),
        ]:
            self.assertEqual(
                1, buildout._get_buildout_ver(path), &quot;1 for {}&quot;.format(path)
            )
        for path in [
            os.path.join(self.tdir, &quot;/non/existing&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/versions&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/bootstrap&quot;),
            os.path.join(self.tdir, &quot;var/ver/2/default&quot;),
        ]:
            self.assertEqual(
                2, buildout._get_buildout_ver(path), &quot;2 for {}&quot;.format(path)
            )

    @pytest.mark.slow_test
    def test_get_bootstrap_content(self):
        self.assertEqual(
            &quot;&quot;,
            buildout._get_bootstrap_content(os.path.join(self.tdir, &quot;non&quot;, &quot;existing&quot;)),
        )
        self.assertEqual(
            &quot;&quot;,
            buildout._get_bootstrap_content(os.path.join(self.tdir, &quot;var&quot;, &quot;tb&quot;, &quot;1&quot;)),
        )
        self.assertEqual(
            &quot;foo{}&quot;.format(os.linesep),
            buildout._get_bootstrap_content(os.path.join(self.tdir, &quot;var&quot;, &quot;tb&quot;, &quot;2&quot;)),
        )

    @pytest.mark.slow_test
    def test_logger_clean(self):
        buildout.LOG.clear()
        # nothing in there
        self.assertTrue(
            True
            not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )
        buildout.LOG.info(&quot;foo&quot;)
        self.assertTrue(
            True in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )
        buildout.LOG.clear()
        self.assertTrue(
            True
            not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )

    @pytest.mark.slow_test
    def test_logger_loggers(self):
        buildout.LOG.clear()
        # nothing in there
        for i in buildout.LOG.levels:
            getattr(buildout.LOG, i)(&quot;foo&quot;)
            getattr(buildout.LOG, i)(&quot;bar&quot;)
            getattr(buildout.LOG, i)(&quot;moo&quot;)
            self.assertTrue(len(buildout.LOG.by_level[i]) == 3)
            self.assertEqual(buildout.LOG.by_level[i][0], &quot;foo&quot;)
            self.assertEqual(buildout.LOG.by_level[i][-1], &quot;moo&quot;)

    @pytest.mark.slow_test
    def test__find_cfgs(self):
        result = sorted(
            a.replace(self.root, &quot;&quot;) for a in buildout._find_cfgs(self.root)
        )
        assertlist = sorted(
            [
                os.path.join(os.sep, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;c&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;etc&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;e&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;b&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;b&quot;, &quot;bdistribute&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;b&quot;, &quot;b2&quot;, &quot;buildout.cfg&quot;),
                os.path.join(os.sep, &quot;foo&quot;, &quot;buildout.cfg&quot;),
            ]
        )
        self.assertEqual(result, assertlist)

    def skip_test_upgrade_bootstrap(self):
        b_dir = os.path.join(self.tdir, &quot;b&quot;)
        bpy = os.path.join(b_dir, &quot;bootstrap.py&quot;)
        buildout.upgrade_bootstrap(b_dir)
        time1 = os.stat(bpy).st_mtime
        with salt.utils.files.fopen(bpy) as fic:
            data = fic.read()
        self.assertTrue(&quot;setdefaulttimeout(2)&quot; in data)
        flag = os.path.join(b_dir, &quot;.buildout&quot;, &quot;2.updated_bootstrap&quot;)
        self.assertTrue(os.path.exists(flag))
        buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
        time2 = os.stat(bpy).st_mtime
        with salt.utils.files.fopen(bpy) as fic:
            data = fic.read()
        self.assertTrue(&quot;setdefaulttimeout(2)&quot; in data)
        flag = os.path.join(b_dir, &quot;.buildout&quot;, &quot;1.updated_bootstrap&quot;)
        self.assertTrue(os.path.exists(flag))
        buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
        time3 = os.stat(bpy).st_mtime
        self.assertNotEqual(time2, time1)
        self.assertEqual(time2, time3)


@skipIf(
    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
    &quot;The 'virtualenv' packaged needs to be installed&quot;,
)
@pytest.mark.requires_network
class BuildoutOnlineTestCase(Base):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.ppy_dis = os.path.join(cls.rdir, &quot;pdistribute&quot;)
        cls.ppy_blank = os.path.join(cls.rdir, &quot;pblank&quot;)
        cls.py_dis = os.path.join(cls.ppy_dis, &quot;bin&quot;, &quot;python&quot;)
        cls.py_blank = os.path.join(cls.ppy_blank, &quot;bin&quot;, &quot;python&quot;)
        # creating a distribute based install
        try:
            # `--no-site-packages` has been deprecated
            # https://virtualenv.pypa.io/en/stable/reference/#cmdoption-no-site-packages
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    &quot;--no-setuptools&quot;,
                    &quot;--no-pip&quot;,
                    cls.ppy_dis,
                ]
            )
        except subprocess.CalledProcessError:
            subprocess.check_call(
                [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_dis]
            )

            url = (
                &quot;https://pypi.python.org/packages/source&quot;
                &quot;/d/distribute/distribute-0.6.43.tar.gz&quot;
            )
            download_to(
                url,
                os.path.join(cls.ppy_dis, &quot;distribute-0.6.43.tar.gz&quot;),
            )

            subprocess.check_call(
                [
                    &quot;tar&quot;,
                    &quot;-C&quot;,
                    cls.ppy_dis,
                    &quot;-xzvf&quot;,
                    &quot;{}/distribute-0.6.43.tar.gz&quot;.format(cls.ppy_dis),
                ]
            )

            subprocess.check_call(
                [
                    &quot;{}/bin/python&quot;.format(cls.ppy_dis),
                    &quot;{}/distribute-0.6.43/setup.py&quot;.format(cls.ppy_dis),
                    &quot;install&quot;,
                ]
            )

        # creating a blank based install
        try:
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    &quot;--no-setuptools&quot;,
                    &quot;--no-pip&quot;,
                    cls.ppy_blank,
                ]
            )
        except subprocess.CalledProcessError:
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    cls.ppy_blank,
                ]
            )

    @pytest.mark.skip(reason=&quot;TODO this test should probably be fixed&quot;)
<A NAME="2"></A>    def test_buildout_bootstrap(self):
        b_dir = os.path.join(self.tdir, &quot;b&quot;)
        bd_dir = os.path.join(self.tdir, &quot;b&quot;, &quot;bdistribute&quot;)
        b2_dir = os.path.join(self<FONT color="#980517"><A HREF="javascript:ZweiFrames('match78654-1.html#2',3,'match78654-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.tdir, &quot;b&quot;, &quot;b2&quot;)
        self.assertTrue(buildout._has_old_distribute(self.py_dis))
        # this is too hard to check as on debian &amp; other where old
        # packages are present (virtualenv), we can't have
        # a clean site-packages
        # self.assertFalse(buildout._has_old_distribute(self.py_blank))
        self.assertFalse(buildout._has_old_distribute(self.py_st))
        self.</B></FONT>assertFalse(buildout._has_setuptools7(self.py_dis))
<A NAME="1"></A>        self.assertTrue(buildout._has_setuptools7(self.py_st))
        self.assertFalse(buildout._has_setuptools7(self.py_blank))

        ret <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match78654-1.html#1',3,'match78654-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= buildout.bootstrap(bd_dir, buildout_ver=1, python=self.py_dis)
        comment = ret[&quot;outlog&quot;]
        self.assertTrue(&quot;--distribute&quot; in comment)
        self.assertTrue(</B></FONT>&quot;Generated script&quot; in comment)

        ret = buildout.bootstrap(b_dir, buildout_ver=1, python=self.py_blank)
        comment = ret[&quot;outlog&quot;]
        # as we may have old packages, this test the two
        # behaviors (failure with old setuptools/distribute)
        self.assertTrue(
            (&quot;Got &quot; in comment and &quot;Generated script&quot; in comment)
            or (&quot;setuptools&gt;=0.7&quot; in comment)
        )

        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_blank)
        comment = ret[&quot;outlog&quot;]
        self.assertTrue(
            (&quot;setuptools&quot; in comment and &quot;Generated script&quot; in comment)
            or (&quot;setuptools&gt;=0.7&quot; in comment)
        )

        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
        comment = ret[&quot;outlog&quot;]
        self.assertTrue(
            (&quot;setuptools&quot; in comment and &quot;Generated script&quot; in comment)
            or (&quot;setuptools&gt;=0.7&quot; in comment)
        )

        ret = buildout.bootstrap(b2_dir, buildout_ver=2, python=self.py_st)
        comment = ret[&quot;outlog&quot;]
        self.assertTrue(
            (&quot;setuptools&quot; in comment and &quot;Creating directory&quot; in comment)
            or (&quot;setuptools&gt;=0.7&quot; in comment)
        )

    @pytest.mark.slow_test
    def test_run_buildout(self):
        if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
            self.skipTest(
                &quot;Skiping until upstream resolved&quot;
                &quot; https://github.com/pypa/virtualenv/issues/1715&quot;
            )

        b_dir = os.path.join(self.tdir, &quot;b&quot;)
        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
        self.assertTrue(ret[&quot;status&quot;])
        ret = buildout.run_buildout(b_dir, parts=[&quot;a&quot;, &quot;b&quot;])
        out = ret[&quot;out&quot;]
        self.assertTrue(&quot;Installing a&quot; in out)
        self.assertTrue(&quot;Installing b&quot; in out)

    @pytest.mark.slow_test
    def test_buildout(self):
        if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
            self.skipTest(
                &quot;Skiping until upstream resolved&quot;
                &quot; https://github.com/pypa/virtualenv/issues/1715&quot;
            )

        b_dir = os.path.join(self.tdir, &quot;b&quot;)
        ret = buildout.buildout(b_dir, buildout_ver=2, python=self.py_st)
        self.assertTrue(ret[&quot;status&quot;])
        out = ret[&quot;out&quot;]
        comment = ret[&quot;comment&quot;]
        self.assertTrue(ret[&quot;status&quot;])
        self.assertTrue(&quot;Creating directory&quot; in out)
        self.assertTrue(&quot;Installing a.&quot; in out)
        self.assertTrue(&quot;{} bootstrap.py&quot;.format(self.py_st) in comment)
        self.assertTrue(&quot;buildout -c buildout.cfg&quot; in comment)
        ret = buildout.buildout(
            b_dir, parts=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], buildout_ver=2, python=self.py_st
        )
        outlog = ret[&quot;outlog&quot;]
        out = ret[&quot;out&quot;]
        comment = ret[&quot;comment&quot;]
        self.assertTrue(&quot;Installing single part: a&quot; in outlog)
        self.assertTrue(&quot;buildout -c buildout.cfg -N install a&quot; in comment)
        self.assertTrue(&quot;Installing b.&quot; in out)
        self.assertTrue(&quot;Installing c.&quot; in out)
        ret = buildout.buildout(
            b_dir, parts=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], buildout_ver=2, newest=True, python=self.py_st
        )
        outlog = ret[&quot;outlog&quot;]
        out = ret[&quot;out&quot;]
        comment = ret[&quot;comment&quot;]
        self.assertTrue(&quot;buildout -c buildout.cfg -n install a&quot; in comment)


# TODO: Is this test even still needed?
class BuildoutAPITestCase(TestCase):
    def test_merge(self):
        buildout.LOG.clear()
        buildout.LOG.info(&quot;àé&quot;)
        buildout.LOG.info(&quot;àé&quot;)
        buildout.LOG.error(&quot;àé&quot;)
        buildout.LOG.error(&quot;àé&quot;)
        ret1 = buildout._set_status({}, out=&quot;éà&quot;)
        uret1 = buildout._set_status({}, out=&quot;éà&quot;)
        buildout.LOG.clear()
        buildout.LOG.info(&quot;ççàé&quot;)
        buildout.LOG.info(&quot;ççàé&quot;)
        buildout.LOG.error(&quot;ççàé&quot;)
        buildout.LOG.error(&quot;ççàé&quot;)
        ret2 = buildout._set_status({}, out=&quot;çéà&quot;)
        uret2 = buildout._set_status({}, out=&quot;çéà&quot;)
        uretm = buildout._merge_statuses([ret1, uret1, ret2, uret2])
        for ret in ret1, uret1, ret2, uret2:
            out = ret[&quot;out&quot;]
            if not isinstance(ret[&quot;out&quot;], str):
                out = ret[&quot;out&quot;].decode(&quot;utf-8&quot;)

        for out in [&quot;àé&quot;, &quot;ççàé&quot;]:
            self.assertTrue(out in uretm[&quot;logs_by_level&quot;][&quot;info&quot;])
            self.assertTrue(out in uretm[&quot;outlog_by_level&quot;])

    def test_setup(self):
        buildout.LOG.clear()
        buildout.LOG.info(&quot;àé&quot;)
        buildout.LOG.info(&quot;àé&quot;)
        buildout.LOG.error(&quot;àé&quot;)
        buildout.LOG.error(&quot;àé&quot;)
        ret = buildout._set_status({}, out=&quot;éà&quot;)
        uret = buildout._set_status({}, out=&quot;éà&quot;)
        self.assertTrue(ret[&quot;outlog&quot;] == uret[&quot;outlog&quot;])
        self.assertTrue(&quot;àé&quot; in uret[&quot;outlog_by_level&quot;])
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A># pylint: skip-file
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match78654-0.html#0',2,'match78654-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>from __future__ import absolute_import, division, print_function

import collections
from contextlib import closing
import errno
import gzip
import logging
import os
import re
import socket
import ssl
import sys

from salt.ext.tornado.escape import to_unicode
from salt.ext.tornado import gen
from salt.ext.tornado.httpclient import AsyncHTTPClient
from salt.ext.tornado.httputil import HTTPHeaders, ResponseStartLine
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.log import gen_log
from</B></FONT> salt.ext.tornado.concurrent import Future
from salt.ext.tornado.netutil import Resolver, bind_sockets
from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
from salt.ext.tornado.test.httpclient_test import ChunkHandler, CountdownHandler, HelloWorldHandler, RedirectHandler
from salt.ext.tornado.test import httpclient_test
from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog
from salt.ext.tornado.test.util import skipOnTravis, skipIfNoIPv6, refusing_port, unittest, skipBefore35, exec_test
from salt.ext.tornado.web import RequestHandler, Application, asynchronous, url, stream_request_body


class SimpleHTTPClientCommonTestCase(httpclient_test.HTTPClientCommonTestCase):
    def get_http_client(self):
        client = SimpleAsyncHTTPClient(io_loop=self.io_loop,
                                       force_instance=True)
        self.assertTrue(isinstance(client, SimpleAsyncHTTPClient))
        return client


class TriggerHandler(RequestHandler):
    def initialize(self, queue, wake_callback):
        self.queue = queue
        self.wake_callback = wake_callback

    @asynchronous
    def get(self):
        logging.debug(&quot;queuing trigger&quot;)
        self.queue.append(self.finish)
        if self.get_argument(&quot;wake&quot;, &quot;true&quot;) == &quot;true&quot;:
            self.wake_callback()


class HangHandler(RequestHandler):
    @asynchronous
    def get(self):
        pass


class ContentLengthHandler(RequestHandler):
    def get(self):
        self.set_header(&quot;Content-Length&quot;, self.get_argument(&quot;value&quot;))
        self.write(&quot;ok&quot;)


class HeadHandler(RequestHandler):
    def head(self):
        self.set_header(&quot;Content-Length&quot;, &quot;7&quot;)


class OptionsHandler(RequestHandler):
    def options(self):
        self.set_header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
        self.write(&quot;ok&quot;)


class NoContentHandler(RequestHandler):
    def get(self):
        self.set_status(204)
        self.finish()


class SeeOtherPostHandler(RequestHandler):
    def post(self):
        redirect_code = int(self.request.body)
        assert redirect_code in (302, 303), &quot;unexpected body %r&quot; % self.request.body
        self.set_header(&quot;Location&quot;, &quot;/see_other_get&quot;)
        self.set_status(redirect_code)


class SeeOtherGetHandler(RequestHandler):
    def get(self):
        if self.request.body:
            raise Exception(&quot;unexpected body %r&quot; % self.request.body)
        self.write(&quot;ok&quot;)


class HostEchoHandler(RequestHandler):
    def get(self):
        self.write(self.request.headers[&quot;Host&quot;])


class NoContentLengthHandler(RequestHandler):
    @asynchronous
    def get(self):
        if self.request.version.startswith('HTTP/1'):
            # Emulate the old HTTP/1.0 behavior of returning a body with no
            # content-length.  Tornado handles content-length at the framework
            # level so we have to go around it.
            stream = self.request.connection.detach()
            stream.write(b&quot;HTTP/1.0 200 OK\r\n\r\n&quot;
                         b&quot;hello&quot;)
            stream.close()
        else:
            self.finish('HTTP/1 required')


class EchoPostHandler(RequestHandler):
    def post(self):
        self.write(self.request.body)


@stream_request_body
class RespondInPrepareHandler(RequestHandler):
    def prepare(self):
        self.set_status(403)
        self.finish(&quot;forbidden&quot;)


class SimpleHTTPClientTestMixin(object):
    def get_app(self):
        # callable objects to finish pending /trigger requests
        self.triggers = collections.deque()
        return Application([
            url(&quot;/trigger&quot;, TriggerHandler, dict(queue=self.triggers,
                                                 wake_callback=self.stop)),
            url(&quot;/chunk&quot;, ChunkHandler),
            url(&quot;/countdown/([0-9]+)&quot;, CountdownHandler, name=&quot;countdown&quot;),
            url(&quot;/hang&quot;, HangHandler),
            url(&quot;/hello&quot;, HelloWorldHandler),
            url(&quot;/content_length&quot;, ContentLengthHandler),
            url(&quot;/head&quot;, HeadHandler),
            url(&quot;/options&quot;, OptionsHandler),
            url(&quot;/no_content&quot;, NoContentHandler),
            url(&quot;/see_other_post&quot;, SeeOtherPostHandler),
            url(&quot;/see_other_get&quot;, SeeOtherGetHandler),
            url(&quot;/host_echo&quot;, HostEchoHandler),
            url(&quot;/no_content_length&quot;, NoContentLengthHandler),
            url(&quot;/echo_post&quot;, EchoPostHandler),
            url(&quot;/respond_in_prepare&quot;, RespondInPrepareHandler),
            url(&quot;/redirect&quot;, RedirectHandler),
        ], gzip=True)

    def test_singleton(self):
        # Class &quot;constructor&quot; reuses objects on the same IOLoop
        self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is
                        SimpleAsyncHTTPClient(self.io_loop))
        # unless force_instance is used
        self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
                        SimpleAsyncHTTPClient(self.io_loop,
                                              force_instance=True))
        # different IOLoops use different objects
        with closing(IOLoop()) as io_loop2:
            self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
                            SimpleAsyncHTTPClient(io_loop2))

    def test_connection_limit(self):
        with closing(self.create_client(max_clients=2)) as client:
            self.assertEqual(client.max_clients, 2)
            seen = []
            # Send 4 requests.  Two can be sent immediately, while the others
            # will be queued
            for i in range(4):
                client.fetch(self.get_url(&quot;/trigger&quot;),
                             lambda response, i=i: (seen.append(i), self.stop()))
            self.wait(condition=lambda: len(self.triggers) == 2)
            self.assertEqual(len(client.queue), 2)

            # Finish the first two requests and let the next two through
            self.triggers.popleft()()
            self.triggers.popleft()()
            self.wait(condition=lambda: (len(self.triggers) == 2 and
                                         len(seen) == 2))
            self.assertEqual(set(seen), set([0, 1]))
            self.assertEqual(len(client.queue), 0)

            # Finish all the pending requests
            self.triggers.popleft()()
            self.triggers.popleft()()
            self.wait(condition=lambda: len(seen) == 4)
            self.assertEqual(set(seen), set([0, 1, 2, 3]))
            self.assertEqual(len(self.triggers), 0)

    def test_redirect_connection_limit(self):
        # following redirects should not consume additional connections
        with closing(self.create_client(max_clients=1)) as client:
            client.fetch(self.get_url('/countdown/3'), self.stop,
                         max_redirects=3)
            response = self.wait()
            response.rethrow()

    def test_gzip(self):
        # All the tests in this file should be using gzip, but this test
        # ensures that it is in fact getting compressed.
        # Setting Accept-Encoding manually bypasses the client's
        # decompression so we can see the raw data.
        response = self.fetch(&quot;/chunk&quot;, use_gzip=False,
                              headers={&quot;Accept-Encoding&quot;: &quot;gzip&quot;})
        self.assertEqual(response.headers[&quot;Content-Encoding&quot;], &quot;gzip&quot;)
        self.assertNotEqual(response.body, b&quot;asdfqwer&quot;)
        # Our test data gets bigger when gzipped.  Oops.  :)
        # Chunked encoding bypasses the MIN_LENGTH check.
        self.assertEqual(len(response.body), 34)
        f = gzip.GzipFile(mode=&quot;r&quot;, fileobj=response.buffer)
        self.assertEqual(f.read(), b&quot;asdfqwer&quot;)

    def test_max_redirects(self):
        response = self.fetch(&quot;/countdown/5&quot;, max_redirects=3)
<A NAME="2"></A>        self.assertEqual(302, response.code)
        # We requested 5, followed three redirects for 4, 3, 2, then the last
        # unfollowed redirect is to 1.
        self.assertTrue(response.request<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match78654-0.html#2',2,'match78654-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.url.endswith(&quot;/countdown/5&quot;))
        self.assertTrue(response.effective_url.endswith(&quot;/countdown/2&quot;))
        self.assertTrue(response.headers[</B></FONT>&quot;Location&quot;].endswith(&quot;/countdown/1&quot;))

    def test_header_reuse(self):
        # Apps may reuse a headers object if they are only passing in constant
        # headers like user-agent.  The header object should not be modified.
        headers = HTTPHeaders({'User-Agent': 'Foo'})
        self.fetch(&quot;/hello&quot;, headers=headers)
        self.assertEqual(list(headers.get_all()), [('User-Agent', 'Foo')])

    def test_see_other_redirect(self):
        for code in (302, 303):
            response = self.fetch(&quot;/see_other_post&quot;, method=&quot;POST&quot;, body=&quot;%d&quot; % code)
            self.assertEqual(200, response.code)
            self.assertTrue(response.request.url.endswith(&quot;/see_other_post&quot;))
            self.assertTrue(response.effective_url.endswith(&quot;/see_other_get&quot;))
            # request is the original request, is a POST still
            self.assertEqual(&quot;POST&quot;, response.request.method)

    @skipOnTravis
    def test_connect_timeout(self):
        timeout = 0.1
        timeout_min, timeout_max = 0.099, 1.0

        class TimeoutResolver(Resolver):
            def resolve(self, *args, **kwargs):
                return Future()  # never completes

        with closing(self.create_client(resolver=TimeoutResolver())) as client:
            client.fetch(self.get_url('/hello'), self.stop,
                         connect_timeout=timeout)
            response = self.wait()
            self.assertEqual(response.code, 599)
            self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
                            response.request_time)
            self.assertEqual(str(response.error), &quot;HTTP 599: Timeout while connecting&quot;)

    @skipOnTravis
    def test_request_timeout(self):
        timeout = 0.1
        timeout_min, timeout_max = 0.099, 0.15
        if os.name == 'nt':
            timeout = 0.5
            timeout_min, timeout_max = 0.4, 0.6

        response = self.fetch('/trigger?wake=false', request_timeout=timeout)
        self.assertEqual(response.code, 599)
        self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
                        response.request_time)
        self.assertEqual(str(response.error), &quot;HTTP 599: Timeout during request&quot;)
        # trigger the hanging request to let it clean up after itself
        self.triggers.popleft()()

    @skipIfNoIPv6
    def test_ipv6(self):
        [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)
        port = sock.getsockname()[1]
        self.http_server.add_socket(sock)
        url = '%s://[::1]:%d/hello' % (self.get_protocol(), port)

        # ipv6 is currently enabled by default but can be disabled
        self.http_client.fetch(url, self.stop, allow_ipv6=False)
        response = self.wait()
        self.assertEqual(response.code, 599)

        self.http_client.fetch(url, self.stop)
        response = self.wait()
        self.assertEqual(response.body, b&quot;Hello world!&quot;)

    def xtest_multiple_content_length_accepted(self):
        response = self.fetch(&quot;/content_length?value=2,2&quot;)
        self.assertEqual(response.body, b&quot;ok&quot;)
        response = self.fetch(&quot;/content_length?value=2,%202,2&quot;)
        self.assertEqual(response.body, b&quot;ok&quot;)

        response = self.fetch(&quot;/content_length?value=2,4&quot;)
        self.assertEqual(response.code, 599)
        response = self.fetch(&quot;/content_length?value=2,%202,3&quot;)
        self.assertEqual(response.code, 599)

    def test_head_request(self):
        response = self.fetch(&quot;/head&quot;, method=&quot;HEAD&quot;)
        self.assertEqual(response.code, 200)
        self.assertEqual(response.headers[&quot;content-length&quot;], &quot;7&quot;)
        self.assertFalse(response.body)
<A NAME="3"></A>
    def test_options_request(self):
        response = self.fetch(&quot;/options&quot;, method=&quot;OPTIONS&quot;)
        self.assertEqual(response<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match78654-0.html#3',2,'match78654-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.code, 200)
        self.assertEqual(response.headers[&quot;content-length&quot;], &quot;2&quot;)
        self.assertEqual(response.headers[&quot;access-control-allow-origin&quot;], &quot;*&quot;)
        self.assertEqual(response.</B></FONT>body, b&quot;ok&quot;)

    def test_no_content(self):
        response = self.fetch(&quot;/no_content&quot;)
        self.assertEqual(response.code, 204)
        # 204 status shouldn't have a content-length
        #
        # Tests with a content-length header are included below
        # in HTTP204NoContentTestCase.
        self.assertNotIn(&quot;Content-Length&quot;, response.headers)

    def test_host_header(self):
        host_re = re.compile(b&quot;^127.0.0.1:[0-9]+$&quot;)
        response = self.fetch(&quot;/host_echo&quot;)
        self.assertTrue(host_re.match(response.body))

        url = self.get_url(&quot;/host_echo&quot;).replace(&quot;http://&quot;, &quot;http://me:secret@&quot;)
        self.http_client.fetch(url, self.stop)
        response = self.wait()
        self.assertTrue(host_re.match(response.body), response.body)

    def test_connection_refused(self):
        cleanup_func, port = refusing_port()
        self.addCleanup(cleanup_func)
        with ExpectLog(gen_log, &quot;.*&quot;, required=False):
            self.http_client.fetch(&quot;http://127.0.0.1:%d/&quot; % port, self.stop)
            response = self.wait()
        self.assertEqual(599, response.code)

        if sys.platform != 'cygwin':
            # cygwin returns EPERM instead of ECONNREFUSED here
            contains_errno = str(errno.ECONNREFUSED) in str(response.error)
            if not contains_errno and hasattr(errno, &quot;WSAECONNREFUSED&quot;):
                contains_errno = str(errno.WSAECONNREFUSED) in str(response.error)
            self.assertTrue(contains_errno, response.error)
            # This is usually &quot;Connection refused&quot;.
            # On windows, strerror is broken and returns &quot;Unknown error&quot;.
            expected_message = os.strerror(errno.ECONNREFUSED)
            self.assertTrue(expected_message in str(response.error),
                            response.error)

    def test_queue_timeout(self):
        with closing(self.create_client(max_clients=1)) as client:
            client.fetch(self.get_url('/trigger'), self.stop,
                         request_timeout=10)
            # Wait for the trigger request to block, not complete.
            self.wait()
            client.fetch(self.get_url('/hello'), self.stop,
                         connect_timeout=0.1)
            response = self.wait()

            self.assertEqual(response.code, 599)
            self.assertTrue(response.request_time &lt; 1, response.request_time)
            self.assertEqual(str(response.error), &quot;HTTP 599: Timeout in request queue&quot;)
            self.triggers.popleft()()
            self.wait()

    def test_no_content_length(self):
        response = self.fetch(&quot;/no_content_length&quot;)
        if response.body == b&quot;HTTP/1 required&quot;:
            self.skipTest(&quot;requires HTTP/1.x&quot;)
        else:
            self.assertEquals(b&quot;hello&quot;, response.body)

    def sync_body_producer(self, write):
        write(b'1234')
        write(b'5678')

    @gen.coroutine
    def async_body_producer(self, write):
        yield write(b'1234')
        yield gen.Task(IOLoop.current().add_callback)
        yield write(b'5678')

    def test_sync_body_producer_chunked(self):
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=self.sync_body_producer)
        response.rethrow()
<A NAME="1"></A>        self.assertEqual(response.body, b&quot;12345678&quot;)

    def test_sync_body_producer_content_length(self):
        response <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match78654-0.html#1',2,'match78654-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=self.sync_body_producer,
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(</B></FONT>response.body, b&quot;12345678&quot;)

    def test_async_body_producer_chunked(self):
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=self.async_body_producer)
        response.rethrow()
        self.assertEqual(response.body, b&quot;12345678&quot;)

    def test_async_body_producer_content_length(self):
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=self.async_body_producer,
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(response.body, b&quot;12345678&quot;)

    @skipBefore35
    def test_native_body_producer_chunked(self):
        namespace = exec_test(globals(), locals(), &quot;&quot;&quot;
        async def body_producer(write):
            await write(b'1234')
            await gen.Task(IOLoop.current().add_callback)
            await write(b'5678')
        &quot;&quot;&quot;)
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=namespace[&quot;body_producer&quot;])
        response.rethrow()
        self.assertEqual(response.body, b&quot;12345678&quot;)

    @skipBefore35
    def test_native_body_producer_content_length(self):
        namespace = exec_test(globals(), locals(), &quot;&quot;&quot;
        async def body_producer(write):
            await write(b'1234')
            await gen.Task(IOLoop.current().add_callback)
            await write(b'5678')
        &quot;&quot;&quot;)
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body_producer=namespace[&quot;body_producer&quot;],
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(response.body, b&quot;12345678&quot;)

    def test_100_continue(self):
        response = self.fetch(&quot;/echo_post&quot;, method=&quot;POST&quot;,
                              body=b&quot;1234&quot;,
                              expect_100_continue=True)
        self.assertEqual(response.body, b&quot;1234&quot;)

    def test_100_continue_early_response(self):
        def body_producer(write):
            raise Exception(&quot;should not be called&quot;)
        response = self.fetch(&quot;/respond_in_prepare&quot;, method=&quot;POST&quot;,
                              body_producer=body_producer,
                              expect_100_continue=True)
        self.assertEqual(response.code, 403)

    def test_streaming_follow_redirects(self):
        # When following redirects, header and streaming callbacks
        # should only be called for the final result.
        # TODO(bdarnell): this test belongs in httpclient_test instead of
        # simple_httpclient_test, but it fails with the version of libcurl
        # available on travis-ci. Move it when that has been upgraded
        # or we have a better framework to skip tests based on curl version.
        headers = []
        chunks = []
        self.fetch(&quot;/redirect?url=/hello&quot;,
                   header_callback=headers.append,
                   streaming_callback=chunks.append)
        chunks = list(map(to_unicode, chunks))
        self.assertEqual(chunks, ['Hello world!'])
        # Make sure we only got one set of headers.
        num_start_lines = len([h for h in headers if h.startswith(&quot;HTTP/&quot;)])
        self.assertEqual(num_start_lines, 1)


class SimpleHTTPClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPTestCase):
    def setUp(self):
        super(SimpleHTTPClientTestCase, self).setUp()
        self.http_client = self.create_client()

    def create_client(self, **kwargs):
        return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
                                     **kwargs)


class SimpleHTTPSClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPSTestCase):
    def setUp(self):
        super(SimpleHTTPSClientTestCase, self).setUp()
        self.http_client = self.create_client()

    def create_client(self, **kwargs):
        return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
                                     defaults=dict(validate_cert=False),
                                     **kwargs)

    def test_ssl_options(self):
        resp = self.fetch(&quot;/hello&quot;, ssl_options={})
        self.assertEqual(resp.body, b&quot;Hello world!&quot;)

    @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
                     'ssl.SSLContext not present')
    def test_ssl_context(self):
        resp = self.fetch(&quot;/hello&quot;,
                          ssl_options=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
        self.assertEqual(resp.body, b&quot;Hello world!&quot;)

    def test_ssl_options_handshake_fail(self):
        with ExpectLog(gen_log, &quot;SSL Error|Uncaught exception&quot;,
                       required=False):
            resp = self.fetch(
                &quot;/hello&quot;, ssl_options=dict(cert_reqs=ssl.CERT_REQUIRED))
        self.assertRaises(ssl.SSLError, resp.rethrow)

    @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
                     'ssl.SSLContext not present')
    def test_ssl_context_handshake_fail(self):
        with ExpectLog(gen_log, &quot;SSL Error|Uncaught exception&quot;):
            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            ctx.verify_mode = ssl.CERT_REQUIRED
            resp = self.fetch(&quot;/hello&quot;, ssl_options=ctx)
        self.assertRaises(ssl.SSLError, resp.rethrow)

    def test_error_logging(self):
        # No stack traces are logged for SSL errors (in this case,
        # failure to validate the testing self-signed cert).
        # The SSLError is exposed through ssl.SSLError.
        with ExpectLog(gen_log, '.*') as expect_log:
            response = self.fetch(&quot;/&quot;, validate_cert=True)
            self.assertEqual(response.code, 599)
            self.assertIsInstance(response.error, ssl.SSLError)
        self.assertFalse(expect_log.logged_stack)


class CreateAsyncHTTPClientTestCase(AsyncTestCase):
    def setUp(self):
        super(CreateAsyncHTTPClientTestCase, self).setUp()
        self.saved = AsyncHTTPClient._save_configuration()

    def tearDown(self):
        AsyncHTTPClient._restore_configuration(self.saved)
        super(CreateAsyncHTTPClientTestCase, self).tearDown()

    def test_max_clients(self):
        AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
        with closing(AsyncHTTPClient(
                self.io_loop, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 10)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=11, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 11)

        # Now configure max_clients statically and try overriding it
        # with each way max_clients can be passed
        AsyncHTTPClient.configure(SimpleAsyncHTTPClient, max_clients=12)
        with closing(AsyncHTTPClient(
                self.io_loop, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 12)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=13, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 13)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=14, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 14)


class HTTP100ContinueTestCase(AsyncHTTPTestCase):
    def respond_100(self, request):
        self.http1 = request.version.startswith('HTTP/1.')
        if not self.http1:
            request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
                                             HTTPHeaders())
            request.connection.finish()
            return
        self.request = request
        self.request.connection.stream.write(
            b&quot;HTTP/1.1 100 CONTINUE\r\n\r\n&quot;,
            self.respond_200)

    def respond_200(self):
        self.request.connection.stream.write(
            b&quot;HTTP/1.1 200 OK\r\nContent-Length: 1\r\n\r\nA&quot;,
            self.request.connection.stream.close)

    def get_app(self):
        # Not a full Application, but works as an HTTPServer callback
        return self.respond_100

    def test_100_continue(self):
        res = self.fetch('/')
        if not self.http1:
            self.skipTest(&quot;requires HTTP/1.x&quot;)
        self.assertEqual(res.body, b'A')


class HTTP204NoContentTestCase(AsyncHTTPTestCase):
    def respond_204(self, request):
        self.http1 = request.version.startswith('HTTP/1.')
        if not self.http1:
            # Close the request cleanly in HTTP/2; it will be skipped anyway.
            request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
                                             HTTPHeaders())
            request.connection.finish()
            return

        # A 204 response never has a body, even if doesn't have a content-length
        # (which would otherwise mean read-until-close).  We simulate here a
        # server that sends no content length and does not close the connection.
        #
        # Tests of a 204 response with no Content-Length header are included
        # in SimpleHTTPClientTestMixin.
        stream = request.connection.detach()
        stream.write(b&quot;HTTP/1.1 204 No content\r\n&quot;)
        if request.arguments.get(&quot;error&quot;, [False])[-1]:
            stream.write(b&quot;Content-Length: 5\r\n&quot;)
        else:
            stream.write(b&quot;Content-Length: 0\r\n&quot;)
        stream.write(b&quot;\r\n&quot;)
        stream.close()

    def get_app(self):
        return self.respond_204

    def test_204_no_content(self):
        resp = self.fetch('/')
        if not self.http1:
            self.skipTest(&quot;requires HTTP/1.x&quot;)
        self.assertEqual(resp.code, 204)
        self.assertEqual(resp.body, b'')

    def test_204_invalid_content_length(self):
        # 204 status with non-zero content length is malformed
        with ExpectLog(gen_log, &quot;.*Response with code 204 should not have body&quot;):
            response = self.fetch(&quot;/?error=1&quot;)
            if not self.http1:
                self.skipTest(&quot;requires HTTP/1.x&quot;)
            if self.http_client.configured_class != SimpleAsyncHTTPClient:
                self.skipTest(&quot;curl client accepts invalid headers&quot;)
            self.assertEqual(response.code, 599)


class HostnameMappingTestCase(AsyncHTTPTestCase):
    def setUp(self):
        super(HostnameMappingTestCase, self).setUp()
        self.http_client = SimpleAsyncHTTPClient(
            self.io_loop,
            hostname_mapping={
                'www.example.com': '127.0.0.1',
                ('foo.example.com', 8000): ('127.0.0.1', self.get_http_port()),
            })

    def get_app(self):
        return Application([url(&quot;/hello&quot;, HelloWorldHandler), ])

    def test_hostname_mapping(self):
        self.http_client.fetch(
            'http://www.example.com:%d/hello' % self.get_http_port(), self.stop)
        response = self.wait()
        response.rethrow()
        self.assertEqual(response.body, b'Hello world!')

    def test_port_mapping(self):
        self.http_client.fetch('http://foo.example.com:8000/hello', self.stop)
        response = self.wait()
        response.rethrow()
        self.assertEqual(response.body, b'Hello world!')


class ResolveTimeoutTestCase(AsyncHTTPTestCase):
    def setUp(self):
        # Dummy Resolver subclass that never invokes its callback.
        class BadResolver(Resolver):
            def resolve(self, *args, **kwargs):
                pass

        super(ResolveTimeoutTestCase, self).setUp()
        self.http_client = SimpleAsyncHTTPClient(
            self.io_loop,
            resolver=BadResolver())

    def get_app(self):
        return Application([url(&quot;/hello&quot;, HelloWorldHandler), ])

    def test_resolve_timeout(self):
        response = self.fetch('/hello', connect_timeout=0.1)
        self.assertEqual(response.code, 599)


class MaxHeaderSizeTest(AsyncHTTPTestCase):
    def get_app(self):
        class SmallHeaders(RequestHandler):
            def get(self):
                self.set_header(&quot;X-Filler&quot;, &quot;a&quot; * 100)
                self.write(&quot;ok&quot;)

        class LargeHeaders(RequestHandler):
            def get(self):
                self.set_header(&quot;X-Filler&quot;, &quot;a&quot; * 1000)
                self.write(&quot;ok&quot;)

        return Application([('/small', SmallHeaders),
                            ('/large', LargeHeaders)])

    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_header_size=1024)

    def test_small_headers(self):
        response = self.fetch('/small')
        response.rethrow()
        self.assertEqual(response.body, b'ok')

    def test_large_headers(self):
        with ExpectLog(gen_log, &quot;Unsatisfiable read&quot;):
            response = self.fetch('/large')
        self.assertEqual(response.code, 599)


class MaxBodySizeTest(AsyncHTTPTestCase):
    def get_app(self):
        class SmallBody(RequestHandler):
            def get(self):
                self.write(&quot;a&quot; * 1024 * 64)

        class LargeBody(RequestHandler):
            def get(self):
                self.write(&quot;a&quot; * 1024 * 100)

        return Application([('/small', SmallBody),
                            ('/large', LargeBody)])

    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 64)

    def test_small_body(self):
        response = self.fetch('/small')
        response.rethrow()
        self.assertEqual(response.body, b'a' * 1024 * 64)

    def test_large_body(self):
        with ExpectLog(gen_log, &quot;Malformed HTTP message from None: Content-Length too long&quot;):
            response = self.fetch('/large')
        self.assertEqual(response.code, 599)


class MaxBufferSizeTest(AsyncHTTPTestCase):
    def get_app(self):

        class LargeBody(RequestHandler):
            def get(self):
                self.write(&quot;a&quot; * 1024 * 100)

        return Application([('/large', LargeBody)])

    def get_http_client(self):
        # 100KB body with 64KB buffer
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 100, max_buffer_size=1024 * 64)

    def test_large_body(self):
        response = self.fetch('/large')
        response.rethrow()
        self.assertEqual(response.body, b'a' * 1024 * 100)


class ChunkedWithContentLengthTest(AsyncHTTPTestCase):
    def get_app(self):

        class ChunkedWithContentLength(RequestHandler):
            def get(self):
                # Add an invalid Transfer-Encoding to the response
                self.set_header('Transfer-Encoding', 'chunked')
                self.write(&quot;Hello world&quot;)

        return Application([('/chunkwithcl', ChunkedWithContentLength)])

    def get_http_client(self):
        return SimpleAsyncHTTPClient()

    def test_chunked_with_content_length(self):
        # Make sure the invalid headers are detected
        with ExpectLog(gen_log, (&quot;Malformed HTTP message from None: Response &quot;
                                 &quot;with both Transfer-Encoding and Content-Length&quot;)):
            response = self.fetch('/chunkwithcl')
        self.assertEqual(response.code, 599)
</PRE>
</div>
  </div>
</body>
</html>
