<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_zcbuildout_1.py &amp; simple_httpclient_test.py
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_zcbuildout_1.py (4.927007%)<th>simple_httpclient_test.py (3.5952065%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-19)<td><a href="#" name="0">(2-21)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(419-422)<td><a href="#" name="1">(393-397)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(408-415)<td><a href="#" name="2">(220-222)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(201-203)<td><a href="#" name="3">(309-312)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zcbuildout_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import shutil
import subprocess
import tempfile
import urllib.error
import urllib.request
import pytest
import salt.modules.cmdmod as cmd
import salt.modules.virtualenv_mod
import salt.modules.zcbuildout as buildout
import salt.utils.files
import salt.utils.path
import salt.utils.platform
from tests.support.helpers import patched_environ
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.runtests import RUNTIME_VARS
from</b></font> tests.support.unit import TestCase, skipIf
KNOWN_VIRTUALENV_BINARY_NAMES = (
    "virtualenv",
    "virtualenv2",
    "virtualenv-2.6",
    "virtualenv-2.7",
)
BOOT_INIT = {
    1: ["var/ver/1/bootstrap/bootstrap.py"],
    2: ["var/ver/2/bootstrap/bootstrap.py", "b/bootstrap.py"],
}
log = logging.getLogger(__name__)
def download_to(url, dest):
    req = urllib.request.Request(url)
    req.add_header(
        "User-Agent",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36",
    )
    with salt.utils.files.fopen(dest, "wb") as fic:
        fic.write(urllib.request.urlopen(req, timeout=10).read())
class Base(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            buildout: {
                "__salt__": {
                    "cmd.run_all": cmd.run_all,
                    "cmd.run": cmd.run,
                    "cmd.retcode": cmd.retcode,
                }
            }
        }
    @classmethod
    def setUpClass(cls):
        if not os.path.isdir(RUNTIME_VARS.TMP):
            os.makedirs(RUNTIME_VARS.TMP)
        cls.root = os.path.join(RUNTIME_VARS.BASE_FILES, "buildout")
        cls.rdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        cls.tdir = os.path.join(cls.rdir, "test")
        for idx, url in buildout._URL_VERSIONS.items():
            log.debug("Downloading bootstrap from %s", url)
            dest = os.path.join(cls.rdir, "{}_bootstrap.py".format(idx))
            try:
                download_to(url, dest)
            except urllib.error.URLError as exc:
                log.debug("Failed to download %s: %s", url, exc)
        cls.ppy_st = os.path.join(cls.rdir, "psetuptools")
        if salt.utils.platform.is_windows():
            cls.bin_st = os.path.join(cls.ppy_st, "Scripts")
            cls.py_st = os.path.join(cls.bin_st, "python")
        else:
            cls.bin_st = os.path.join(cls.ppy_st, "bin")
            cls.py_st = os.path.join(cls.bin_st, "python")
        subprocess.check_call(
            [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_st]
        )
        subprocess.check_call(
            [os.path.join(cls.bin_st, "pip"), "install", "-U", "setuptools&lt;50.0.0"]
        )
        subprocess.check_call(
            [os.path.join(cls.bin_st, "easy_install"), "-U", "distribute"]
        )
    def setUp(self):
        if salt.utils.platform.is_darwin():
            self.patched_environ = patched_environ(__cleanup__=["__PYVENV_LAUNCHER__"])
            self.patched_environ.__enter__()
            self.addCleanup(self.patched_environ.__exit__)
        super().setUp()
        self._remove_dir()
        shutil.copytree(self.root, self.tdir)
        for idx in BOOT_INIT:
            path = os.path.join(self.rdir, "{}_bootstrap.py".format(idx))
            for fname in BOOT_INIT[idx]:
                shutil.copy2(path, os.path.join(self.tdir, fname))
    def tearDown(self):
        super().tearDown()
        self._remove_dir()
    def _remove_dir(self):
        if os.path.isdir(self.tdir):
            shutil.rmtree(self.tdir)
@skipIf(
    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
    "The 'virtualenv' packaged needs to be installed",
)
@pytest.mark.requires_network
class BuildoutTestCase(Base):
    @pytest.mark.slow_test
    def test_onlyif_unless(self):
        b_dir = os.path.join(self.tdir, "b")
        ret = buildout.buildout(b_dir, onlyif=RUNTIME_VARS.SHELL_FALSE_PATH)
        self.assertTrue(ret["comment"] == "onlyif condition is false")
        self.assertTrue(ret["status"] is True)
        ret = buildout.buildout(b_dir, unless=RUNTIME_VARS.SHELL_TRUE_PATH)
        self.assertTrue(ret["comment"] == "unless condition is true")
        self.assertTrue(ret["status"] is True)
    @pytest.mark.slow_test
    def test_salt_callback(self):
        @buildout._salt_callback
        def callback1(a, b=1):
            for i in buildout.LOG.levels:
                getattr(buildout.LOG, i)("{}bar".format(i[0]))
            return "foo"
        def callback2(a, b=1):
            raise Exception("foo")
        ret1 = callback1(1, b=3)
        ret2 = buildout._salt_callback(callback2)(2, b=6)
        self.assertEqual(ret2["status"], False)
        self.assertTrue(ret2["logs_by_level"]["error"][0].startswith("Traceback"))
        self.assertTrue("Unexpected response from buildout" in ret2["comment"])
        self.assertEqual(ret2["out"], None)
        for l in buildout.LOG.levels:
            self.assertTrue(0 == len(buildout.LOG.by_level[l]))
    def test_get_bootstrap_url(self):
        for path in [
            os<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.join(self.tdir, "var/ver/1/dumppicked"),
            os.path.join(self.tdir, "var/ver/1/bootstrap"),
            os.path.join(self.</b></font>tdir, "var/ver/1/versions"),
        ]:
            self.assertEqual(
                buildout._URL_VERSIONS[1],
                buildout._get_bootstrap_url(path),
                "b1 url for {}".format(path),
            )
        for path in [
            os.path.join(self.tdir, "/non/existing"),
            os.path.join(self.tdir, "var/ver/2/versions"),
            os.path.join(self.tdir, "var/ver/2/bootstrap"),
            os.path.join(self.tdir, "var/ver/2/default"),
        ]:
            self.assertEqual(
                buildout._URL_VERSIONS[2],
                buildout._get_bootstrap_url(path),
                "b2 url for {}".format(path),
            )
    @pytest.mark.slow_test
    def test_get_buildout_ver(self):
        for path in [
            os.path.join(self.tdir, "var/ver/1/dumppicked"),
            os.path.join(self.tdir, "var/ver/1/bootstrap"),
            os.path.join(self.tdir, "var/ver/1/versions"),
        ]:
            self.assertEqual(
                1, buildout._get_buildout_ver(path), "1 for {}".format(path)
            )
        for path in [
            os.path.join(self.tdir, "/non/existing"),
            os.path.join(self.tdir, "var/ver/2/versions"),
            os.path.join(self.tdir, "var/ver/2/bootstrap"),
            os.path.join(self.tdir, "var/ver/2/default"),
        ]:
            self.assertEqual(
                2, buildout._get_buildout_ver(path), "2 for {}".format(path)
            )
    @pytest.mark.slow_test
    def test_get_bootstrap_content(self):
        self.assertEqual(
            "",
            buildout._get_bootstrap_content(os.path.join(self.tdir, "non", "existing")),
        )
        self.assertEqual(
            "",
            buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "1")),
        )
        self.assertEqual(
            "foo{}".format(os.linesep),
            buildout._get_bootstrap_content(os.path.join(self.tdir, "var", "tb", "2")),
        )
    @pytest.mark.slow_test
    def test_logger_clean(self):
        buildout.LOG.clear()
        self.assertTrue(
            True
            not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )
        buildout.LOG.info("foo")
        self.assertTrue(
            True in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )
        buildout.LOG.clear()
        self.assertTrue(
            True
            not in [len(buildout.LOG.by_level[a]) &gt; 0 for a in buildout.LOG.by_level]
        )
    @pytest.mark.slow_test
    def test_logger_loggers(self):
        buildout.LOG.clear()
        for i in buildout.LOG.levels:
            getattr(buildout.LOG, i)("foo")
            getattr(buildout.LOG, i)("bar")
            getattr(buildout.LOG, i)("moo")
            self.assertTrue(len(buildout.LOG.by_level[i]) == 3)
            self.assertEqual(buildout.LOG.by_level[i][0], "foo")
            self.assertEqual(buildout.LOG.by_level[i][-1], "moo")
    @pytest.mark.slow_test
    def test__find_cfgs(self):
        result = sorted(
            a.replace(self.root, "") for a in buildout._find_cfgs(self.root)
        )
        assertlist = sorted(
            [
                os.path.join(os.sep, "buildout.cfg"),
                os.path.join(os.sep, "c", "buildout.cfg"),
                os.path.join(os.sep, "etc", "buildout.cfg"),
                os.path.join(os.sep, "e", "buildout.cfg"),
                os.path.join(os.sep, "b", "buildout.cfg"),
                os.path.join(os.sep, "b", "bdistribute", "buildout.cfg"),
                os.path.join(os.sep, "b", "b2", "buildout.cfg"),
                os.path.join(os.sep, "foo", "buildout.cfg"),
            ]
        )
        self.assertEqual(result, assertlist)
    def skip_test_upgrade_bootstrap(self):
        b_dir = os.path.join(self.tdir, "b")
        bpy = os.path.join(b_dir, "bootstrap.py")
        buildout.upgrade_bootstrap(b_dir)
        time1 = os.stat(bpy).st_mtime
        with salt.utils.files.fopen(bpy) as fic:
            data = fic.read()
        self.assertTrue("setdefaulttimeout(2)" in data)
        flag = os.path.join(b_dir, ".buildout", "2.updated_bootstrap")
        self.assertTrue(os.path.exists(flag))
        buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
        time2 = os.stat(bpy).st_mtime
        with salt.utils.files.fopen(bpy) as fic:
            data = fic.read()
        self.assertTrue("setdefaulttimeout(2)" in data)
        flag = os.path.join(b_dir, ".buildout", "1.updated_bootstrap")
        self.assertTrue(os.path.exists(flag))
        buildout.upgrade_bootstrap(b_dir, buildout_ver=1)
        time3 = os.stat(bpy).st_mtime
        self.assertNotEqual(time2, time1)
        self.assertEqual(time2, time3)
@skipIf(
    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES) is None,
    "The 'virtualenv' packaged needs to be installed",
)
@pytest.mark.requires_network
class BuildoutOnlineTestCase(Base):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.ppy_dis = os.path.join(cls.rdir, "pdistribute")
        cls.ppy_blank = os.path.join(cls.rdir, "pblank")
        cls.py_dis = os.path.join(cls.ppy_dis, "bin", "python")
        cls.py_blank = os.path.join(cls.ppy_blank, "bin", "python")
        try:
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    "--no-setuptools",
                    "--no-pip",
                    cls.ppy_dis,
                ]
            )
        except subprocess.CalledProcessError:
            subprocess.check_call(
                [salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES), cls.ppy_dis]
            )
            url = (
                "https://pypi.python.org/packages/source"
                "/d/distribute/distribute-0.6.43.tar.gz"
            )
            download_to(
                url,
                os.path.join(cls.ppy_dis, "distribute-0.6.43.tar.gz"),
            )
            subprocess.check_call(
                [
                    "tar",
                    "-C",
                    cls.ppy_dis,
                    "-xzvf",
                    "{}/distribute-0.6.43.tar.gz".format(cls.ppy_dis),
                ]
            )
            subprocess.check_call(
                [
                    "{}/bin/python".format(cls.ppy_dis),
                    "{}/distribute-0.6.43/setup.py".format(cls.ppy_dis),
                    "install",
                ]
            )
        try:
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    "--no-setuptools",
                    "--no-pip",
                    cls.ppy_blank,
                ]
            )
        except subprocess.CalledProcessError:
            subprocess.check_call(
                [
                    salt.utils.path.which_bin(KNOWN_VIRTUALENV_BINARY_NAMES),
                    cls.ppy_blank,
                ]
            )
    @pytest.mark.skip(reason="TODO this test should probably be fixed")
        b_dir = os.path.join(self.tdir, "b")
        bd_dir = os.path.join(self.tdir, "b", "bdistribute")
        b2_dir = os.path.join(self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.tdir, "b", "b2")
        self.assertTrue(buildout._has_old_distribute(self.py_dis))
        self.assertFalse(buildout._has_old_distribute(self.py_st))
        self.</b></font>assertFalse(buildout._has_setuptools7(self.py_dis))
        self.assertFalse(buildout._has_setuptools7(self.py_blank))
        ret <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= buildout.bootstrap(bd_dir, buildout_ver=1, python=self.py_dis)
        comment = ret["outlog"]
        self.assertTrue("--distribute" in comment)
        self.assertTrue(</b></font>"Generated script" in comment)
        ret = buildout.bootstrap(b_dir, buildout_ver=1, python=self.py_blank)
        comment = ret["outlog"]
        self.assertTrue(
            ("Got " in comment and "Generated script" in comment)
            or ("setuptools&gt;=0.7" in comment)
        )
        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_blank)
        comment = ret["outlog"]
        self.assertTrue(
            ("setuptools" in comment and "Generated script" in comment)
            or ("setuptools&gt;=0.7" in comment)
        )
        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
        comment = ret["outlog"]
        self.assertTrue(
            ("setuptools" in comment and "Generated script" in comment)
            or ("setuptools&gt;=0.7" in comment)
        )
        ret = buildout.bootstrap(b2_dir, buildout_ver=2, python=self.py_st)
        comment = ret["outlog"]
        self.assertTrue(
            ("setuptools" in comment and "Creating directory" in comment)
            or ("setuptools&gt;=0.7" in comment)
        )
    @pytest.mark.slow_test
    def test_run_buildout(self):
        if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
            self.skipTest(
                "Skiping until upstream resolved"
                " https://github.com/pypa/virtualenv/issues/1715"
            )
        b_dir = os.path.join(self.tdir, "b")
        ret = buildout.bootstrap(b_dir, buildout_ver=2, python=self.py_st)
        self.assertTrue(ret["status"])
        ret = buildout.run_buildout(b_dir, parts=["a", "b"])
        out = ret["out"]
        self.assertTrue("Installing a" in out)
        self.assertTrue("Installing b" in out)
    @pytest.mark.slow_test
    def test_buildout(self):
        if salt.modules.virtualenv_mod.virtualenv_ver(self.ppy_st) &gt;= (20, 0, 0):
            self.skipTest(
                "Skiping until upstream resolved"
                " https://github.com/pypa/virtualenv/issues/1715"
            )
        b_dir = os.path.join(self.tdir, "b")
        ret = buildout.buildout(b_dir, buildout_ver=2, python=self.py_st)
        self.assertTrue(ret["status"])
        out = ret["out"]
        comment = ret["comment"]
        self.assertTrue(ret["status"])
        self.assertTrue("Creating directory" in out)
        self.assertTrue("Installing a." in out)
        self.assertTrue("{} bootstrap.py".format(self.py_st) in comment)
        self.assertTrue("buildout -c buildout.cfg" in comment)
        ret = buildout.buildout(
            b_dir, parts=["a", "b", "c"], buildout_ver=2, python=self.py_st
        )
        outlog = ret["outlog"]
        out = ret["out"]
        comment = ret["comment"]
        self.assertTrue("Installing single part: a" in outlog)
        self.assertTrue("buildout -c buildout.cfg -N install a" in comment)
        self.assertTrue("Installing b." in out)
        self.assertTrue("Installing c." in out)
        ret = buildout.buildout(
            b_dir, parts=["a", "b", "c"], buildout_ver=2, newest=True, python=self.py_st
        )
        outlog = ret["outlog"]
        out = ret["out"]
        comment = ret["comment"]
        self.assertTrue("buildout -c buildout.cfg -n install a" in comment)
class BuildoutAPITestCase(TestCase):
    def test_merge(self):
        buildout.LOG.clear()
        buildout.LOG.info("àé")
        buildout.LOG.info("àé")
        buildout.LOG.error("àé")
        buildout.LOG.error("àé")
        ret1 = buildout._set_status({}, out="éà")
        uret1 = buildout._set_status({}, out="éà")
        buildout.LOG.clear()
        buildout.LOG.info("ççàé")
        buildout.LOG.info("ççàé")
        buildout.LOG.error("ççàé")
        buildout.LOG.error("ççàé")
        ret2 = buildout._set_status({}, out="çéà")
        uret2 = buildout._set_status({}, out="çéà")
        uretm = buildout._merge_statuses([ret1, uret1, ret2, uret2])
        for ret in ret1, uret1, ret2, uret2:
            out = ret["out"]
            if not isinstance(ret["out"], str):
                out = ret["out"].decode("utf-8")
        for out in ["àé", "ççàé"]:
            self.assertTrue(out in uretm["logs_by_level"]["info"])
            self.assertTrue(out in uretm["outlog_by_level"])
    def test_setup(self):
        buildout.LOG.clear()
        buildout.LOG.info("àé")
        buildout.LOG.info("àé")
        buildout.LOG.error("àé")
        buildout.LOG.error("àé")
        ret = buildout._set_status({}, out="éà")
        uret = buildout._set_status({}, out="éà")
        self.assertTrue(ret["outlog"] == uret["outlog"])
        self.assertTrue("àé" in uret["outlog_by_level"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import absolute_import, division, print_function
import collections
from contextlib import closing
import errno
import gzip
import logging
import os
import re
import socket
import ssl
import sys
from salt.ext.tornado.escape import to_unicode
from salt.ext.tornado import gen
from salt.ext.tornado.httpclient import AsyncHTTPClient
from salt.ext.tornado.httputil import HTTPHeaders, ResponseStartLine
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.log import gen_log
from</b></font> salt.ext.tornado.concurrent import Future
from salt.ext.tornado.netutil import Resolver, bind_sockets
from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
from salt.ext.tornado.test.httpclient_test import ChunkHandler, CountdownHandler, HelloWorldHandler, RedirectHandler
from salt.ext.tornado.test import httpclient_test
from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog
from salt.ext.tornado.test.util import skipOnTravis, skipIfNoIPv6, refusing_port, unittest, skipBefore35, exec_test
from salt.ext.tornado.web import RequestHandler, Application, asynchronous, url, stream_request_body
class SimpleHTTPClientCommonTestCase(httpclient_test.HTTPClientCommonTestCase):
    def get_http_client(self):
        client = SimpleAsyncHTTPClient(io_loop=self.io_loop,
                                       force_instance=True)
        self.assertTrue(isinstance(client, SimpleAsyncHTTPClient))
        return client
class TriggerHandler(RequestHandler):
    def initialize(self, queue, wake_callback):
        self.queue = queue
        self.wake_callback = wake_callback
    @asynchronous
    def get(self):
        logging.debug("queuing trigger")
        self.queue.append(self.finish)
        if self.get_argument("wake", "true") == "true":
            self.wake_callback()
class HangHandler(RequestHandler):
    @asynchronous
    def get(self):
        pass
class ContentLengthHandler(RequestHandler):
    def get(self):
        self.set_header("Content-Length", self.get_argument("value"))
        self.write("ok")
class HeadHandler(RequestHandler):
    def head(self):
        self.set_header("Content-Length", "7")
class OptionsHandler(RequestHandler):
    def options(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.write("ok")
class NoContentHandler(RequestHandler):
    def get(self):
        self.set_status(204)
        self.finish()
class SeeOtherPostHandler(RequestHandler):
    def post(self):
        redirect_code = int(self.request.body)
        assert redirect_code in (302, 303), "unexpected body %r" % self.request.body
        self.set_header("Location", "/see_other_get")
        self.set_status(redirect_code)
class SeeOtherGetHandler(RequestHandler):
    def get(self):
        if self.request.body:
            raise Exception("unexpected body %r" % self.request.body)
        self.write("ok")
class HostEchoHandler(RequestHandler):
    def get(self):
        self.write(self.request.headers["Host"])
class NoContentLengthHandler(RequestHandler):
    @asynchronous
    def get(self):
        if self.request.version.startswith('HTTP/1'):
            stream = self.request.connection.detach()
            stream.write(b"HTTP/1.0 200 OK\r\n\r\n"
                         b"hello")
            stream.close()
        else:
            self.finish('HTTP/1 required')
class EchoPostHandler(RequestHandler):
    def post(self):
        self.write(self.request.body)
@stream_request_body
class RespondInPrepareHandler(RequestHandler):
    def prepare(self):
        self.set_status(403)
        self.finish("forbidden")
class SimpleHTTPClientTestMixin(object):
    def get_app(self):
        self.triggers = collections.deque()
        return Application([
            url("/trigger", TriggerHandler, dict(queue=self.triggers,
                                                 wake_callback=self.stop)),
            url("/chunk", ChunkHandler),
            url("/countdown/([0-9]+)", CountdownHandler, name="countdown"),
            url("/hang", HangHandler),
            url("/hello", HelloWorldHandler),
            url("/content_length", ContentLengthHandler),
            url("/head", HeadHandler),
            url("/options", OptionsHandler),
            url("/no_content", NoContentHandler),
            url("/see_other_post", SeeOtherPostHandler),
            url("/see_other_get", SeeOtherGetHandler),
            url("/host_echo", HostEchoHandler),
            url("/no_content_length", NoContentLengthHandler),
            url("/echo_post", EchoPostHandler),
            url("/respond_in_prepare", RespondInPrepareHandler),
            url("/redirect", RedirectHandler),
        ], gzip=True)
    def test_singleton(self):
        self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is
                        SimpleAsyncHTTPClient(self.io_loop))
        self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
                        SimpleAsyncHTTPClient(self.io_loop,
                                              force_instance=True))
        with closing(IOLoop()) as io_loop2:
            self.assertTrue(SimpleAsyncHTTPClient(self.io_loop) is not
                            SimpleAsyncHTTPClient(io_loop2))
    def test_connection_limit(self):
        with closing(self.create_client(max_clients=2)) as client:
            self.assertEqual(client.max_clients, 2)
            seen = []
            for i in range(4):
                client.fetch(self.get_url("/trigger"),
                             lambda response, i=i: (seen.append(i), self.stop()))
            self.wait(condition=lambda: len(self.triggers) == 2)
            self.assertEqual(len(client.queue), 2)
            self.triggers.popleft()()
            self.triggers.popleft()()
            self.wait(condition=lambda: (len(self.triggers) == 2 and
                                         len(seen) == 2))
            self.assertEqual(set(seen), set([0, 1]))
            self.assertEqual(len(client.queue), 0)
            self.triggers.popleft()()
            self.triggers.popleft()()
            self.wait(condition=lambda: len(seen) == 4)
            self.assertEqual(set(seen), set([0, 1, 2, 3]))
            self.assertEqual(len(self.triggers), 0)
    def test_redirect_connection_limit(self):
        with closing(self.create_client(max_clients=1)) as client:
            client.fetch(self.get_url('/countdown/3'), self.stop,
                         max_redirects=3)
            response = self.wait()
            response.rethrow()
    def test_gzip(self):
        response = self.fetch("/chunk", use_gzip=False,
                              headers={"Accept-Encoding": "gzip"})
        self.assertEqual(response.headers["Content-Encoding"], "gzip")
        self.assertNotEqual(response.body, b"asdfqwer")
        self.assertEqual(len(response.body), 34)
        f = gzip.GzipFile(mode="r", fileobj=response.buffer)
        self.assertEqual(f.read(), b"asdfqwer")
    def test_max_redirects(self):
        response = self.fetch("/countdown/5", max_redirects=3)
        self.assertTrue(response.request<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.url.endswith("/countdown/5"))
        self.assertTrue(response.effective_url.endswith("/countdown/2"))
        self.assertTrue(response.headers[</b></font>"Location"].endswith("/countdown/1"))
    def test_header_reuse(self):
        headers = HTTPHeaders({'User-Agent': 'Foo'})
        self.fetch("/hello", headers=headers)
        self.assertEqual(list(headers.get_all()), [('User-Agent', 'Foo')])
    def test_see_other_redirect(self):
        for code in (302, 303):
            response = self.fetch("/see_other_post", method="POST", body="%d" % code)
            self.assertEqual(200, response.code)
            self.assertTrue(response.request.url.endswith("/see_other_post"))
            self.assertTrue(response.effective_url.endswith("/see_other_get"))
            self.assertEqual("POST", response.request.method)
    @skipOnTravis
    def test_connect_timeout(self):
        timeout = 0.1
        timeout_min, timeout_max = 0.099, 1.0
        class TimeoutResolver(Resolver):
            def resolve(self, *args, **kwargs):
                return Future()  # never completes
        with closing(self.create_client(resolver=TimeoutResolver())) as client:
            client.fetch(self.get_url('/hello'), self.stop,
                         connect_timeout=timeout)
            response = self.wait()
            self.assertEqual(response.code, 599)
            self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
                            response.request_time)
            self.assertEqual(str(response.error), "HTTP 599: Timeout while connecting")
    @skipOnTravis
    def test_request_timeout(self):
        timeout = 0.1
        timeout_min, timeout_max = 0.099, 0.15
        if os.name == 'nt':
            timeout = 0.5
            timeout_min, timeout_max = 0.4, 0.6
        response = self.fetch('/trigger?wake=false', request_timeout=timeout)
        self.assertEqual(response.code, 599)
        self.assertTrue(timeout_min &lt; response.request_time &lt; timeout_max,
                        response.request_time)
        self.assertEqual(str(response.error), "HTTP 599: Timeout during request")
        self.triggers.popleft()()
    @skipIfNoIPv6
    def test_ipv6(self):
        [sock] = bind_sockets(None, '::1', family=socket.AF_INET6)
        port = sock.getsockname()[1]
        self.http_server.add_socket(sock)
        url = '%s://[::1]:%d/hello' % (self.get_protocol(), port)
        self.http_client.fetch(url, self.stop, allow_ipv6=False)
        response = self.wait()
        self.assertEqual(response.code, 599)
        self.http_client.fetch(url, self.stop)
        response = self.wait()
        self.assertEqual(response.body, b"Hello world!")
    def xtest_multiple_content_length_accepted(self):
        response = self.fetch("/content_length?value=2,2")
        self.assertEqual(response.body, b"ok")
        response = self.fetch("/content_length?value=2,%202,2")
        self.assertEqual(response.body, b"ok")
        response = self.fetch("/content_length?value=2,4")
        self.assertEqual(response.code, 599)
        response = self.fetch("/content_length?value=2,%202,3")
        self.assertEqual(response.code, 599)
    def test_head_request(self):
        response = self.fetch("/head", method="HEAD")
        self.assertEqual(response.code, 200)
        self.assertEqual(response.headers["content-length"], "7")
        self.assertFalse(response.body)
    def test_options_request(self):
        response = self.fetch("/options", method="OPTIONS")
        self.assertEqual(response<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.code, 200)
        self.assertEqual(response.headers["content-length"], "2")
        self.assertEqual(response.headers["access-control-allow-origin"], "*")
        self.assertEqual(response.</b></font>body, b"ok")
    def test_no_content(self):
        response = self.fetch("/no_content")
        self.assertEqual(response.code, 204)
        self.assertNotIn("Content-Length", response.headers)
    def test_host_header(self):
        host_re = re.compile(b"^127.0.0.1:[0-9]+$")
        response = self.fetch("/host_echo")
        self.assertTrue(host_re.match(response.body))
        url = self.get_url("/host_echo").replace("http://", "http://me:secret@")
        self.http_client.fetch(url, self.stop)
        response = self.wait()
        self.assertTrue(host_re.match(response.body), response.body)
    def test_connection_refused(self):
        cleanup_func, port = refusing_port()
        self.addCleanup(cleanup_func)
        with ExpectLog(gen_log, ".*", required=False):
            self.http_client.fetch("http://127.0.0.1:%d/" % port, self.stop)
            response = self.wait()
        self.assertEqual(599, response.code)
        if sys.platform != 'cygwin':
            contains_errno = str(errno.ECONNREFUSED) in str(response.error)
            if not contains_errno and hasattr(errno, "WSAECONNREFUSED"):
                contains_errno = str(errno.WSAECONNREFUSED) in str(response.error)
            self.assertTrue(contains_errno, response.error)
            expected_message = os.strerror(errno.ECONNREFUSED)
            self.assertTrue(expected_message in str(response.error),
                            response.error)
    def test_queue_timeout(self):
        with closing(self.create_client(max_clients=1)) as client:
            client.fetch(self.get_url('/trigger'), self.stop,
                         request_timeout=10)
            self.wait()
            client.fetch(self.get_url('/hello'), self.stop,
                         connect_timeout=0.1)
            response = self.wait()
            self.assertEqual(response.code, 599)
            self.assertTrue(response.request_time &lt; 1, response.request_time)
            self.assertEqual(str(response.error), "HTTP 599: Timeout in request queue")
            self.triggers.popleft()()
            self.wait()
    def test_no_content_length(self):
        response = self.fetch("/no_content_length")
        if response.body == b"HTTP/1 required":
            self.skipTest("requires HTTP/1.x")
        else:
            self.assertEquals(b"hello", response.body)
    def sync_body_producer(self, write):
        write(b'1234')
        write(b'5678')
    @gen.coroutine
    def async_body_producer(self, write):
        yield write(b'1234')
        yield gen.Task(IOLoop.current().add_callback)
        yield write(b'5678')
    def test_sync_body_producer_chunked(self):
        response = self.fetch("/echo_post", method="POST",
                              body_producer=self.sync_body_producer)
        response.rethrow()
    def test_sync_body_producer_content_length(self):
        response <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.fetch("/echo_post", method="POST",
                              body_producer=self.sync_body_producer,
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(</b></font>response.body, b"12345678")
    def test_async_body_producer_chunked(self):
        response = self.fetch("/echo_post", method="POST",
                              body_producer=self.async_body_producer)
        response.rethrow()
        self.assertEqual(response.body, b"12345678")
    def test_async_body_producer_content_length(self):
        response = self.fetch("/echo_post", method="POST",
                              body_producer=self.async_body_producer,
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(response.body, b"12345678")
    @skipBefore35
    def test_native_body_producer_chunked(self):
        namespace = exec_test(globals(), locals(), """
        async def body_producer(write):
            await write(b'1234')
            await gen.Task(IOLoop.current().add_callback)
            await write(b'5678')
        """)
        response = self.fetch("/echo_post", method="POST",
                              body_producer=namespace["body_producer"])
        response.rethrow()
        self.assertEqual(response.body, b"12345678")
    @skipBefore35
    def test_native_body_producer_content_length(self):
        namespace = exec_test(globals(), locals(), """
        async def body_producer(write):
            await write(b'1234')
            await gen.Task(IOLoop.current().add_callback)
            await write(b'5678')
        """)
        response = self.fetch("/echo_post", method="POST",
                              body_producer=namespace["body_producer"],
                              headers={'Content-Length': '8'})
        response.rethrow()
        self.assertEqual(response.body, b"12345678")
    def test_100_continue(self):
        response = self.fetch("/echo_post", method="POST",
                              body=b"1234",
                              expect_100_continue=True)
        self.assertEqual(response.body, b"1234")
    def test_100_continue_early_response(self):
        def body_producer(write):
            raise Exception("should not be called")
        response = self.fetch("/respond_in_prepare", method="POST",
                              body_producer=body_producer,
                              expect_100_continue=True)
        self.assertEqual(response.code, 403)
    def test_streaming_follow_redirects(self):
        headers = []
        chunks = []
        self.fetch("/redirect?url=/hello",
                   header_callback=headers.append,
                   streaming_callback=chunks.append)
        chunks = list(map(to_unicode, chunks))
        self.assertEqual(chunks, ['Hello world!'])
        num_start_lines = len([h for h in headers if h.startswith("HTTP/")])
        self.assertEqual(num_start_lines, 1)
class SimpleHTTPClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPTestCase):
    def setUp(self):
        super(SimpleHTTPClientTestCase, self).setUp()
        self.http_client = self.create_client()
    def create_client(self, **kwargs):
        return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
                                     **kwargs)
class SimpleHTTPSClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPSTestCase):
    def setUp(self):
        super(SimpleHTTPSClientTestCase, self).setUp()
        self.http_client = self.create_client()
    def create_client(self, **kwargs):
        return SimpleAsyncHTTPClient(self.io_loop, force_instance=True,
                                     defaults=dict(validate_cert=False),
                                     **kwargs)
    def test_ssl_options(self):
        resp = self.fetch("/hello", ssl_options={})
        self.assertEqual(resp.body, b"Hello world!")
    @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
                     'ssl.SSLContext not present')
    def test_ssl_context(self):
        resp = self.fetch("/hello",
                          ssl_options=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
        self.assertEqual(resp.body, b"Hello world!")
    def test_ssl_options_handshake_fail(self):
        with ExpectLog(gen_log, "SSL Error|Uncaught exception",
                       required=False):
            resp = self.fetch(
                "/hello", ssl_options=dict(cert_reqs=ssl.CERT_REQUIRED))
        self.assertRaises(ssl.SSLError, resp.rethrow)
    @unittest.skipIf(not hasattr(ssl, 'SSLContext'),
                     'ssl.SSLContext not present')
    def test_ssl_context_handshake_fail(self):
        with ExpectLog(gen_log, "SSL Error|Uncaught exception"):
            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            ctx.verify_mode = ssl.CERT_REQUIRED
            resp = self.fetch("/hello", ssl_options=ctx)
        self.assertRaises(ssl.SSLError, resp.rethrow)
    def test_error_logging(self):
        with ExpectLog(gen_log, '.*') as expect_log:
            response = self.fetch("/", validate_cert=True)
            self.assertEqual(response.code, 599)
            self.assertIsInstance(response.error, ssl.SSLError)
        self.assertFalse(expect_log.logged_stack)
class CreateAsyncHTTPClientTestCase(AsyncTestCase):
    def setUp(self):
        super(CreateAsyncHTTPClientTestCase, self).setUp()
        self.saved = AsyncHTTPClient._save_configuration()
    def tearDown(self):
        AsyncHTTPClient._restore_configuration(self.saved)
        super(CreateAsyncHTTPClientTestCase, self).tearDown()
    def test_max_clients(self):
        AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
        with closing(AsyncHTTPClient(
                self.io_loop, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 10)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=11, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 11)
        AsyncHTTPClient.configure(SimpleAsyncHTTPClient, max_clients=12)
        with closing(AsyncHTTPClient(
                self.io_loop, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 12)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=13, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 13)
        with closing(AsyncHTTPClient(
                self.io_loop, max_clients=14, force_instance=True)) as client:
            self.assertEqual(client.max_clients, 14)
class HTTP100ContinueTestCase(AsyncHTTPTestCase):
    def respond_100(self, request):
        self.http1 = request.version.startswith('HTTP/1.')
        if not self.http1:
            request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
                                             HTTPHeaders())
            request.connection.finish()
            return
        self.request = request
        self.request.connection.stream.write(
            b"HTTP/1.1 100 CONTINUE\r\n\r\n",
            self.respond_200)
    def respond_200(self):
        self.request.connection.stream.write(
            b"HTTP/1.1 200 OK\r\nContent-Length: 1\r\n\r\nA",
            self.request.connection.stream.close)
    def get_app(self):
        return self.respond_100
    def test_100_continue(self):
        res = self.fetch('/')
        if not self.http1:
            self.skipTest("requires HTTP/1.x")
        self.assertEqual(res.body, b'A')
class HTTP204NoContentTestCase(AsyncHTTPTestCase):
    def respond_204(self, request):
        self.http1 = request.version.startswith('HTTP/1.')
        if not self.http1:
            request.connection.write_headers(ResponseStartLine('', 200, 'OK'),
                                             HTTPHeaders())
            request.connection.finish()
            return
        stream = request.connection.detach()
        stream.write(b"HTTP/1.1 204 No content\r\n")
        if request.arguments.get("error", [False])[-1]:
            stream.write(b"Content-Length: 5\r\n")
        else:
            stream.write(b"Content-Length: 0\r\n")
        stream.write(b"\r\n")
        stream.close()
    def get_app(self):
        return self.respond_204
    def test_204_no_content(self):
        resp = self.fetch('/')
        if not self.http1:
            self.skipTest("requires HTTP/1.x")
        self.assertEqual(resp.code, 204)
        self.assertEqual(resp.body, b'')
    def test_204_invalid_content_length(self):
        with ExpectLog(gen_log, ".*Response with code 204 should not have body"):
            response = self.fetch("/?error=1")
            if not self.http1:
                self.skipTest("requires HTTP/1.x")
            if self.http_client.configured_class != SimpleAsyncHTTPClient:
                self.skipTest("curl client accepts invalid headers")
            self.assertEqual(response.code, 599)
class HostnameMappingTestCase(AsyncHTTPTestCase):
    def setUp(self):
        super(HostnameMappingTestCase, self).setUp()
        self.http_client = SimpleAsyncHTTPClient(
            self.io_loop,
            hostname_mapping={
                'www.example.com': '127.0.0.1',
                ('foo.example.com', 8000): ('127.0.0.1', self.get_http_port()),
            })
    def get_app(self):
        return Application([url("/hello", HelloWorldHandler), ])
    def test_hostname_mapping(self):
        self.http_client.fetch(
            'http://www.example.com:%d/hello' % self.get_http_port(), self.stop)
        response = self.wait()
        response.rethrow()
        self.assertEqual(response.body, b'Hello world!')
    def test_port_mapping(self):
        self.http_client.fetch('http://foo.example.com:8000/hello', self.stop)
        response = self.wait()
        response.rethrow()
        self.assertEqual(response.body, b'Hello world!')
class ResolveTimeoutTestCase(AsyncHTTPTestCase):
    def setUp(self):
        class BadResolver(Resolver):
            def resolve(self, *args, **kwargs):
                pass
        super(ResolveTimeoutTestCase, self).setUp()
        self.http_client = SimpleAsyncHTTPClient(
            self.io_loop,
            resolver=BadResolver())
    def get_app(self):
        return Application([url("/hello", HelloWorldHandler), ])
    def test_resolve_timeout(self):
        response = self.fetch('/hello', connect_timeout=0.1)
        self.assertEqual(response.code, 599)
class MaxHeaderSizeTest(AsyncHTTPTestCase):
    def get_app(self):
        class SmallHeaders(RequestHandler):
            def get(self):
                self.set_header("X-Filler", "a" * 100)
                self.write("ok")
        class LargeHeaders(RequestHandler):
            def get(self):
                self.set_header("X-Filler", "a" * 1000)
                self.write("ok")
        return Application([('/small', SmallHeaders),
                            ('/large', LargeHeaders)])
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_header_size=1024)
    def test_small_headers(self):
        response = self.fetch('/small')
        response.rethrow()
        self.assertEqual(response.body, b'ok')
    def test_large_headers(self):
        with ExpectLog(gen_log, "Unsatisfiable read"):
            response = self.fetch('/large')
        self.assertEqual(response.code, 599)
class MaxBodySizeTest(AsyncHTTPTestCase):
    def get_app(self):
        class SmallBody(RequestHandler):
            def get(self):
                self.write("a" * 1024 * 64)
        class LargeBody(RequestHandler):
            def get(self):
                self.write("a" * 1024 * 100)
        return Application([('/small', SmallBody),
                            ('/large', LargeBody)])
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 64)
    def test_small_body(self):
        response = self.fetch('/small')
        response.rethrow()
        self.assertEqual(response.body, b'a' * 1024 * 64)
    def test_large_body(self):
        with ExpectLog(gen_log, "Malformed HTTP message from None: Content-Length too long"):
            response = self.fetch('/large')
        self.assertEqual(response.code, 599)
class MaxBufferSizeTest(AsyncHTTPTestCase):
    def get_app(self):
        class LargeBody(RequestHandler):
            def get(self):
                self.write("a" * 1024 * 100)
        return Application([('/large', LargeBody)])
    def get_http_client(self):
        return SimpleAsyncHTTPClient(io_loop=self.io_loop, max_body_size=1024 * 100, max_buffer_size=1024 * 64)
    def test_large_body(self):
        response = self.fetch('/large')
        response.rethrow()
        self.assertEqual(response.body, b'a' * 1024 * 100)
class ChunkedWithContentLengthTest(AsyncHTTPTestCase):
    def get_app(self):
        class ChunkedWithContentLength(RequestHandler):
            def get(self):
                self.set_header('Transfer-Encoding', 'chunked')
                self.write("Hello world")
        return Application([('/chunkwithcl', ChunkedWithContentLength)])
    def get_http_client(self):
        return SimpleAsyncHTTPClient()
    def test_chunked_with_content_length(self):
        with ExpectLog(gen_log, ("Malformed HTTP message from None: Response "
                                 "with both Transfer-Encoding and Content-Length")):
            response = self.fetch('/chunkwithcl')
        self.assertEqual(response.code, 599)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
