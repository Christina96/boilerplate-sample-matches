
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.951856946354883%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-qrcode.py</h3>
            <pre><code>1  import os
2  from pyUltroid import ULTConfig
3  try:
4      import cv2
5  except ImportError:
6      cv2 = None
7  import qrcode
8  from PIL import Image
9  from telethon.tl.types import MessageMediaDocument as doc
10  from . import check_filename, get_string, ultroid_bot, ultroid_cmd
11  @ultroid_cmd(pattern="qrcode( (.*)|$)")
12  async def cd(e):
13      reply = await e.get_reply_message()
14      msg = e.pattern_match.group(1).strip()
15      if reply and reply.text:
16          msg = reply.text
17      elif not msg:
18          return await e.eor("`Give Some Text or Reply", time=5)
19      default, cimg = ULTConfig.thumb, None
20      if reply and (reply.sticker or reply.photo):
21          cimg = await reply.download_media()
22      elif ultroid_bot.me.photo and not ultroid_bot.me.photo.has_video:
23          cimg = await e.client.get_profile_photos(ultroid_bot.uid, limit=1)[0]
24      kk = await e.eor(get_string("com_1"))
25      img = cimg or default
26      ok = Image.open(img)
27      logo = ok.resize((60, 60))
28      cod = qrcode.QRCode(error_correction=qrcode.constants.ERROR_CORRECT_H)
29      cod.add_data(msg)
30      cod.make()
31      imgg = cod.make_image().convert("RGB")
32      pstn = ((imgg.size[0] - logo.size[0]) // 2, (imgg.size[1] - logo.size[1]) // 2)
33      imgg.paste(logo, pstn)
34      newname = check_filename("qr.jpg")
35      imgg.save(newname)
36      await e.client.send_file(e.chat_id, newname, supports_streaming=True)
37      await kk.delete()
38      os.remove(newname)
39      if cimg:
40          os.remove(cimg)
41  @ultroid_cmd(pattern="addqr( (.*)|$)")
42  async def qrwater(e):
43      msg = e.pattern_match.group(1).strip()
44      r = await e.get_reply_message()
45      dl = await e.client.download_media(
46          r, thumb=-1 if isinstance(r.media, doc) else None
47      )
48      if not dl:
49          return await e.eor("`Reply Any Media and Give Text`", time=5)
50      kk = await e.eor(get_string("com_1"))
<span onclick='openModal()' class='match'>51      img_bg = Image.open(dl)
52      qr = qrcode.QRCode(box_size=5)
53      qr.add_data(msg)
</span>54      qr.make()
55      img_qr = qr.make_image()
56      pos = (img_bg.size[0] - img_qr.size[0], img_bg.size[1] - img_qr.size[1])
57      img_bg.paste(img_qr, pos)
58      img_bg.save(dl)
59      await e.client.send_file(e.chat_id, dl, supports_streaming=True)
60      await kk.delete()
61      os.remove(dl)
62  @ultroid_cmd(pattern="qrdecode$")
63  async def decod(e):
64      r = await e.get_reply_message()
65      if not (r and r.media):
66          return await e.eor("`Reply to Qrcode Media`", time=5)
67      kk = await e.eor(get_string("com_1"))
68      dl = await e.client.download_media(
69          r, thumb=-1 if isinstance(r.media, doc) else None
70      )
71      if not dl:
72          return
73      im = cv2.imread(dl)
74      try:
75          det = cv2.QRCodeDetector()
76          tx, y, z = det.detectAndDecode(im)
77          await kk.edit("**Decoded Text:\n\n**" + tx)
78      except BaseException:
79          await kk.edit("`Reply To Media in Which Qr image present.`")
80      os.remove(dl)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-operations.py</h3>
            <pre><code>1  import argparse
2  import os  # noqa: F401. It is used in IDF scripts
3  import traceback
4  import espsecure
5  import esptool
6  from . import fields
7  from .. import util
8  from ..base_operations import (
9      add_common_commands,
10      add_force_write_always,
11      add_show_sensitive_info_option,
12      burn_bit,
13      burn_block_data,
14      burn_efuse,
15      check_error,
16      dump,
17      read_protect_efuse,
18      summary,
19      write_protect_efuse,
20  )
21  def protect_options(p):
22      p.add_argument(
23          "--no-write-protect",
24          help="Disable write-protecting of the key. The key remains writable. "
25          "(The keys use the RS coding scheme that does not support "
26          "post-write data changes. Forced write can damage RS encoding bits.) "
27          "The write-protecting of keypurposes does not depend on the option, "
28          "it will be set anyway.",
29          action="store_true",
30      )
31      p.add_argument(
32          "--no-read-protect",
33          help="Disable read-protecting of the key. The key remains readable software.",
34          action="store_true",
35      )
36  def add_commands(subparsers, efuses):
37      add_common_commands(subparsers, efuses)
38      burn_key = subparsers.add_parser(
39          "burn_key", help="Burn the key block with the specified name"
40      )
41      protect_options(burn_key)
42      add_force_write_always(burn_key)
43      add_show_sensitive_info_option(burn_key)
44      burn_key.add_argument(
45          "block",
46          help="Key block to burn",
47          action="append",
48          choices=efuses.BLOCKS_FOR_KEYS,
49      )
50      burn_key.add_argument(
51          "keyfile",
52          help="File containing 128/256 bits of binary key data",
53          action="append",
54          type=argparse.FileType("rb"),
55      )
56      burn_key.add_argument(
57          "keypurpose",
58          help="Purpose to set.",
59          action="append",
60          choices=fields.EfuseKeyPurposeField.KEY_PURPOSES_NAME,
61      )
62      for _ in range(1):
63          burn_key.add_argument(
64              "block",
65              help="Key block to burn",
66              nargs="?",
67              action="append",
68              metavar="BLOCK",
69              choices=efuses.BLOCKS_FOR_KEYS,
70          )
71          burn_key.add_argument(
72              "keyfile",
73              help="File containing 128/256 bits of binary key data",
74              nargs="?",
75              action="append",
76              metavar="KEYFILE",
77              type=argparse.FileType("rb"),
78          )
79          burn_key.add_argument(
80              "keypurpose",
81              help="Purpose to set.",
82              nargs="?",
83              action="append",
84              metavar="KEYPURPOSE",
85              choices=fields.EfuseKeyPurposeField.KEY_PURPOSES_NAME,
86          )
87      burn_key_digest = subparsers.add_parser(
88          "burn_key_digest",
89          help="Parse an ECDSA public key and burn the digest "
90          "to higher 128-bits of BLOCK_KEY0",
91      )
92      protect_options(burn_key_digest)
93      add_force_write_always(burn_key_digest)
94      add_show_sensitive_info_option(burn_key_digest)
95      burn_key_digest.add_argument(
<span onclick='openModal()' class='match'>96          "keyfile", help="Key file to digest (PEM format)", type=argparse.FileType("rb")
97      )
98      p = subparsers.add_parser(
99          "set_flash_voltage",
100          help="Permanently set the internal flash voltage regulator "
101          "to either 1.8V, 3.3V or OFF. This means GPIO45 can be high or low "
102          "at reset without changing the flash voltage.",
103      )
104      p.add_argument("voltage", help="Voltage selection", choices=["1.8V", "3.3V", "OFF"])
</span>105      p = subparsers.add_parser(
106          "burn_custom_mac", help="Burn a 48-bit Custom MAC Address to EFUSE BLOCK1."
107      )
108      p.add_argument(
109          "mac",
110          help="Custom MAC Address to burn given in hexadecimal format "
111          "with bytes separated by colons (e.g. AA:CD:EF:01:02:03).",
112          type=fields.base_fields.CheckArgValue(efuses, "CUSTOM_MAC"),
113      )
114      add_force_write_always(p)
115      p = subparsers.add_parser("get_custom_mac", help="Prints the Custom MAC Address.")
116  def burn_custom_mac(esp, efuses, args):
117      efuses["CUSTOM_MAC"].save(args.mac)
118      efuses["CUSTOM_MAC_USED"].save(1)
119      if not efuses.burn_all(check_batch_mode=True):
120          return
121      get_custom_mac(esp, efuses, args)
122      print("Successful")
123  def get_custom_mac(esp, efuses, args):
124      print("Custom MAC Address: {}".format(efuses["CUSTOM_MAC"].get()))
125  def set_flash_voltage(esp, efuses, args):
126      raise esptool.FatalError("set_flash_voltage is not supported!")
127  def adc_info(esp, efuses, args):
128      print("")
129      if efuses["BLK_VERSION_MINOR"].get() == 1:
130          print("    RF_REF_I_BIAS_CONFIG:        {}".format(efuses["RF_REF_I_BIAS_CONFIG"].get()))
131          print("    LDO_VOL_BIAS_CONFIG_LOW:     {}".format(efuses["LDO_VOL_BIAS_CONFIG_LOW"].get()))
132          print("    LDO_VOL_BIAS_CONFIG_HIGH:    {}".format(efuses["LDO_VOL_BIAS_CONFIG_HIGH"].get()))
133          print("    PVT_LOW:                     {}".format(efuses["PVT_LOW"].get()))
134          print("    PVT_HIGH:                    {}".format(efuses["PVT_HIGH"].get()))
135          print("    ADC_CALIBRATION_0:           {}".format(efuses["ADC_CALIBRATION_0"].get()))
136          print("    ADC_CALIBRATION_1:           {}".format(efuses["ADC_CALIBRATION_1"].get()))
137          print("    ADC_CALIBRATION_2:           {}".format(efuses["ADC_CALIBRATION_2"].get()))
138      else:
139          print("BLK_VERSION_MINOR = {}".format(efuses["BLK_VERSION_MINOR"].get_meaning()))
140  def burn_key(esp, efuses, args, digest=None):
141      if digest is None:
142          datafile_list = args.keyfile[
143              0 : len([name for name in args.keyfile if name is not None]) :
144          ]
145      else:
146          datafile_list = digest[0 : len([name for name in digest if name is not None]) :]
147      efuses.force_write_always = args.force_write_always
148      block_name_list = args.block[
149          0 : len([name for name in args.block if name is not None]) :
150      ]
151      keypurpose_list = args.keypurpose[
152          0 : len([name for name in args.keypurpose if name is not None]) :
153      ]
154      util.check_duplicate_name_in_list(keypurpose_list)
155      if len(block_name_list) != len(datafile_list) or len(block_name_list) != len(
156          keypurpose_list
157      ):
158          raise esptool.FatalError(
159              "The number of blocks (%d), datafile (%d) and "
160              "keypurpose (%d) should be the same."
161              % (len(block_name_list), len(datafile_list), len(keypurpose_list))
162          )
163      assert 1 <= len(block_name_list) <= 2, "Unexpected case"
164      if len(block_name_list) == 2:
165          incompatible = True if "XTS_AES_128_KEY" in keypurpose_list else False
166          permitted_purposes = [
167              "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS",
168              "SECURE_BOOT_DIGEST",
169          ]
170          incompatible |= (
171              keypurpose_list[0] in permitted_purposes
172              and keypurpose_list[1] not in permitted_purposes
173          )
174          if incompatible:
175              raise esptool.FatalError(
176                  "These keypurposes are incompatible %s" % (keypurpose_list)
177              )
178      print("Burn keys to blocks:")
179      for datafile, keypurpose in zip(datafile_list, keypurpose_list):
180          data = datafile if isinstance(datafile, bytes) else datafile.read()
181          if keypurpose == "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS":
182              efuse = efuses["BLOCK_KEY0_LOW_128"]
183          elif keypurpose == "SECURE_BOOT_DIGEST":
184              efuse = efuses["BLOCK_KEY0_HI_128"]
185              if len(data) == 32:
186                  print(
187                      "\tProgramming only left-most 128-bits from SHA256 hash of "
188                      "public key to highest 128-bits of BLOCK KEY0"
189                  )
190                  data = data[:16]
191              elif len(data) != efuse.bit_len // 8:
192                  raise esptool.FatalError(
193                      "Wrong length of this file for SECURE_BOOT_DIGEST. "
194                      "Got %d (expected %d or %d)" % (len(data), 32, efuse.bit_len // 8)
195                  )
196              assert len(data) == 16, "Only 16 bytes expected"
197          else:
198              efuse = efuses["BLOCK_KEY0"]
199          num_bytes = efuse.bit_len // 8
200          print(" - %s" % (efuse.name), end=" ")
201          revers_msg = None
202          if keypurpose.startswith("XTS_AES_"):
203              revers_msg = "\tReversing byte order for AES-XTS hardware peripheral"
204              data = data[::-1]
205          print(
206              "-> [{}]".format(
207                  util.hexify(data, " ")
208                  if args.show_sensitive_info
209                  else " ".join(["??"] * len(data))
210              )
211          )
212          if revers_msg:
213              print(revers_msg)
214          if len(data) != num_bytes:
215              raise esptool.FatalError(
216                  "Incorrect key file size %d. "
217                  "Key file must be %d bytes (%d bits) of raw binary key data."
218                  % (len(data), num_bytes, num_bytes * 8)
219              )
220          if keypurpose.startswith("XTS_AES_"):
221              read_protect = False if args.no_read_protect else True
222          else:
223              read_protect = False
224          write_protect = not args.no_write_protect
225          efuse.save(data)
226          if keypurpose == "XTS_AES_128_KEY":
227              if efuses["XTS_KEY_LENGTH_256"].get():
228                  print("\t'XTS_KEY_LENGTH_256' is already '1'")
229              else:
230                  print("\tXTS_KEY_LENGTH_256 -> 1")
231                  efuses["XTS_KEY_LENGTH_256"].save(1)
232          if read_protect:
233              print("\tDisabling read to key block")
234              efuse.disable_read()
235          if write_protect:
236              print("\tDisabling write to key block")
237              efuse.disable_write()
238          print("")
239      if not write_protect:
240          print("Keys will remain writeable (due to --no-write-protect)")
241      if args.no_read_protect:
242          print("Keys will remain readable (due to --no-read-protect)")
243      if not efuses.burn_all(check_batch_mode=True):
244          return
245      print("Successful")
246  def burn_key_digest(esp, efuses, args):
247      datafile = args.keyfile
248      args.keypurpose = ["SECURE_BOOT_DIGEST"]
249      args.block = ["BLOCK_KEY0"]
250      digest = espsecure._digest_sbv2_public_key(datafile)
251      digest = digest[:16]
252      num_bytes = efuses["BLOCK_KEY0_HI_128"].bit_len // 8
253      if len(digest) != num_bytes:
254          raise esptool.FatalError(
255              "Incorrect digest size %d. "
256              "Digest must be %d bytes (%d bits) of raw binary key data."
257              % (len(digest), num_bytes, num_bytes * 8)
258          )
259      burn_key(esp, efuses, args, digest=[digest])
260  def espefuse(esp, efuses, args, command):
261      parser = argparse.ArgumentParser()
262      subparsers = parser.add_subparsers(dest="operation")
263      add_commands(subparsers, efuses)
264      try:
265          cmd_line_args = parser.parse_args(command.split())
266      except SystemExit:
267          traceback.print_stack()
268          raise esptool.FatalError('"{}" - incorrect command'.format(command))
269      if cmd_line_args.operation == "execute_scripts":
270          configfiles = cmd_line_args.configfiles
271          index = cmd_line_args.index
272      vars(cmd_line_args).update(vars(args))
273      if cmd_line_args.operation == "execute_scripts":
274          cmd_line_args.configfiles = configfiles
275          cmd_line_args.index = index
276      if cmd_line_args.operation is None:
277          parser.print_help()
278          parser.exit(1)
279      operation_func = globals()[cmd_line_args.operation]
280      operation_func(esp, efuses, cmd_line_args)
281  def execute_scripts(esp, efuses, args):
282      efuses.batch_mode_cnt += 1
283      del args.operation
284      scripts = args.scripts
285      del args.scripts
286      for file in scripts:
287          with open(file.name, "r") as file:
288              exec(compile(file.read(), file.name, "exec"))
289      if args.debug:
290          for block in efuses.blocks:
291              data = block.get_bitstring(from_read=False)
292              block.print_block(data, "regs_for_burn", args.debug)
293      efuses.batch_mode_cnt -= 1
294      if not efuses.burn_all(check_batch_mode=True):
295          return
296      print("Successful")
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-qrcode.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-operations.py</div>
                </div>
                <div class="column column_space"><pre><code>51      img_bg = Image.open(dl)
52      qr = qrcode.QRCode(box_size=5)
53      qr.add_data(msg)
</pre></code></div>
                <div class="column column_space"><pre><code>96          "keyfile", help="Key file to digest (PEM format)", type=argparse.FileType("rb")
97      )
98      p = subparsers.add_parser(
99          "set_flash_voltage",
100          help="Permanently set the internal flash voltage regulator "
101          "to either 1.8V, 3.3V or OFF. This means GPIO45 can be high or low "
102          "at reset without changing the flash voltage.",
103      )
104      p.add_argument("voltage", help="Voltage selection", choices=["1.8V", "3.3V", "OFF"])
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    