<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for augeas.py &amp; ipc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for augeas.py &amp; ipc.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>augeas.py (5.371901%)<th>ipc.py (1.229896%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(30-44)<td><a href="#" name="0">(15-32)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>augeas.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import difflib
import logging
import os.path
import re
import salt.utils.args
import salt.utils.files
import salt.utils.stringutils
from salt.modules.augeas_cfg import METHOD_MAP
log = logging.getLogger(__name__)
def __virtual__():
    if</b></font> "augeas.execute" in __salt__:
        return "augeas"
    return (False, "augeas module could not be loaded")
def _workout_filename(filename):
    if os.path.isfile(filename) or filename == "/":
        if filename == "/":
            filename = None
        return filename
    else:
        return _workout_filename(os.path.dirname(filename))
def _check_filepath(changes):
    filename = None
    for change_ in changes:
        try:
            cmd, arg = change_.split(" ", 1)
            if cmd not in METHOD_MAP:
                error = "Command {} is not supported (yet)".format(cmd)
                raise ValueError(error)
            method = METHOD_MAP[cmd]
            parts = salt.utils.args.shlex_split(arg)
            if method in ["set", "setm", "move", "remove"]:
                filename_ = parts[0]
            else:
                _, _, filename_ = parts
            if not filename_.startswith("/files"):
                error = (
                    "Changes should be prefixed with "
                    "/files if no context is provided,"
                    " change: {}".format(change_)
                )
                raise ValueError(error)
            filename_ = re.sub("^/files|/$", "", filename_)
            if filename is not None:
                if filename != filename_:
                    error = (
                        "Changes should be made to one "
                        "file at a time, detected changes "
                        "to {} and {}".format(filename, filename_)
                    )
                    raise ValueError(error)
            filename = filename_
        except (ValueError, IndexError) as err:
            log.error(err)
            if "error" not in locals():
                error = (
                    "Invalid formatted command, see debug log for details: {}".format(
                        change_
                    )
                )
            else:
                error = str(err)
            raise ValueError(error)
    filename = _workout_filename(filename)
    return filename
def change(name, context=None, changes=None, lens=None, load_path=None, **kwargs):
    ret = {"name": name, "result": False, "comment": "", "changes": {}}
    if not changes or not isinstance(changes, list):
        ret["comment"] = "'changes' must be specified as a list"
        return ret
    if load_path is not None:
        if not isinstance(load_path, list):
            ret["comment"] = "'load_path' must be specified as a list"
            return ret
        else:
            load_path = ":".join(load_path)
    filename = None
    if context is None:
        try:
            filename = _check_filepath(changes)
        except ValueError as err:
            ret["comment"] = "Error: {}".format(err)
            return ret
    else:
        filename = re.sub("^/files|/$", "", context)
    if __opts__["test"]:
        ret["result"] = True
        ret["comment"] = "Executing commands"
        if context:
            ret["comment"] += ' in file "{}":\n'.format(context)
        ret["comment"] += "\n".join(changes)
        return ret
    old_file = []
    if filename is not None and os.path.isfile(filename):
        with salt.utils.files.fopen(filename, "r") as file_:
            old_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
    result = __salt__["augeas.execute"](
        context=context, lens=lens, commands=changes, load_path=load_path
    )
    ret["result"] = result["retval"]
    if ret["result"] is False:
        ret["comment"] = "Error: {}".format(result["error"])
        return ret
    if filename is not None and os.path.isfile(filename):
        with salt.utils.files.fopen(filename, "r") as file_:
            new_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
            diff = "".join(difflib.unified_diff(old_file, new_file, n=0))
        if diff:
            ret["comment"] = "Changes have been saved"
            ret["changes"] = {"diff": diff}
        else:
            ret["comment"] = "No changes made"
    else:
        ret["comment"] = "Changes have been saved"
        ret["changes"] = {"updates": changes}
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ipc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import errno
import logging
import socket
import time
import salt.ext.tornado
<a name="0"></a>import salt.ext.tornado.concurrent
import salt.ext.tornado.gen
import salt.ext.tornado.ioloop
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.ext.tornado.netutil
import salt.transport.client
import salt.transport.frame
import salt.utils.msgpack
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.ioloop import TimeoutError as TornadoTimeoutError
from salt.ext.tornado.iostream import IOStream, StreamClosedError
from salt.ext.tornado.locks import Lock
log = logging.getLogger(__name__)
def future_with_timeout_callback(future):
    if</b></font> future._future_with_timeout is not None:
        future._future_with_timeout._done_callback(future)
class FutureWithTimeout(salt.ext.tornado.concurrent.Future):
    def __init__(self, io_loop, future, timeout):
        super().__init__()
        self.io_loop = io_loop
        self._future = future
        if timeout is not None:
            if timeout &lt; 0.1:
                timeout = 0.1
            self._timeout_handle = self.io_loop.add_timeout(
                self.io_loop.time() + timeout, self._timeout_callback
            )
        else:
            self._timeout_handle = None
        if hasattr(self._future, "_future_with_timeout"):
            self._future._future_with_timeout = self
            if self._future.done():
                future_with_timeout_callback(self._future)
        else:
            self._future._future_with_timeout = self
            self._future.add_done_callback(future_with_timeout_callback)
    def _timeout_callback(self):
        self._timeout_handle = None
        self._future._future_with_timeout = None
        self.set_exception(TornadoTimeoutError())
    def _done_callback(self, future):
        try:
            if self._timeout_handle is not None:
                self.io_loop.remove_timeout(self._timeout_handle)
                self._timeout_handle = None
            self.set_result(future.result())
        except Exception as exc:  # pylint: disable=broad-except
            self.set_exception(exc)
class IPCServer:
    async_methods = [
        "handle_stream",
    ]
    close_methods = [
        "close",
    ]
    def __init__(self, socket_path, io_loop=None, payload_handler=None):
        self.socket_path = socket_path
        self._started = False
        self.payload_handler = payload_handler
        self.sock = None
        self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
        self._closing = False
    def start(self):
        log.trace("IPCServer: binding to socket: %s", self.socket_path)
        if isinstance(self.socket_path, int):
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.sock.setblocking(0)
            self.sock.bind(("127.0.0.1", self.socket_path))
            self.sock.listen(128)
        else:
            self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
        with salt.utils.asynchronous.current_ioloop(self.io_loop):
            salt.ext.tornado.netutil.add_accept_handler(
                self.sock,
                self.handle_connection,
            )
        self._started = True
    @salt.ext.tornado.gen.coroutine
    def handle_stream(self, stream):
        @salt.ext.tornado.gen.coroutine
        def _null(msg):
            raise salt.ext.tornado.gen.Return(None)
        def write_callback(stream, header):
            if header.get("mid"):
                @salt.ext.tornado.gen.coroutine
                def return_message(msg):
                    pack = salt.transport.frame.frame_msg_ipc(
                        msg,
                        header={"mid": header["mid"]},
                        raw_body=True,
                    )
                    yield stream.write(pack)
                return return_message
            else:
                return _null
        if salt.utils.msgpack.version &gt;= (0, 5, 2):
            msgpack_kwargs = {"raw": False}
        else:
            msgpack_kwargs = {"encoding": "utf-8"}
        unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
        while not stream.closed():
            try:
                wire_bytes = yield stream.read_bytes(4096, partial=True)
                unpacker.feed(wire_bytes)
                for framed_msg in unpacker:
                    body = framed_msg["body"]
                    self.io_loop.spawn_callback(
                        self.payload_handler,
                        body,
                        write_callback(stream, framed_msg["head"]),
                    )
            except StreamClosedError:
                log.trace("Client disconnected from IPC %s", self.socket_path)
                break
            except OSError as exc:
                if exc.errno == 0:
                    log.trace(
                        "Exception occurred with error number 0, "
                        "spurious exception: %s",
                        exc,
                    )
                else:
                    log.error("Exception occurred while handling stream: %s", exc)
            except Exception as exc:  # pylint: disable=broad-except
                log.error("Exception occurred while handling stream: %s", exc)
    def handle_connection(self, connection, address):
        log.trace(
            "IPCServer: Handling connection to address: %s",
            address if address else connection,
        )
        try:
            with salt.utils.asynchronous.current_ioloop(self.io_loop):
                stream = IOStream(
                    connection,
                )
            self.io_loop.spawn_callback(self.handle_stream, stream)
        except Exception as exc:  # pylint: disable=broad-except
            log.error("IPC streaming error: %s", exc)
    def close(self):
        if self._closing:
            return
        self._closing = True
        if hasattr(self.sock, "close"):
            self.sock.close()
    def __del__(self):
        try:
            self.close()
        except TypeError:
            pass
    def __enter__(self):
        return self
    def __exit__(self, *args):
        self.close()
class IPCClient:
    def __init__(self, socket_path, io_loop=None):
        self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
        self.socket_path = socket_path
        self._closing = False
        self.stream = None
        if salt.utils.msgpack.version &gt;= (0, 5, 2):
            msgpack_kwargs = {"raw": False}
        else:
            msgpack_kwargs = {"encoding": "utf-8"}
        self.unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
        self._connecting_future = None
    def connected(self):
        return self.stream is not None and not self.stream.closed()
    def connect(self, callback=None, timeout=None):
        if self._connecting_future is not None and not self._connecting_future.done():
            future = self._connecting_future
        else:
            if self._connecting_future is not None:
                self._connecting_future.exception()  # pylint: disable=E0203
            future = salt.ext.tornado.concurrent.Future()
            self._connecting_future = future
            self._connect(timeout)
        if callback is not None:
            def handle_future(future):
                response = future.result()
                self.io_loop.add_callback(callback, response)
            future.add_done_callback(handle_future)
        return future
    @salt.ext.tornado.gen.coroutine
    def _connect(self, timeout=None):
        if isinstance(self.socket_path, int):
            sock_type = socket.AF_INET
            sock_addr = ("127.0.0.1", self.socket_path)
        else:
            sock_type = socket.AF_UNIX
            sock_addr = self.socket_path
        self.stream = None
        if timeout is not None:
            timeout_at = time.time() + timeout
        while True:
            if self._closing:
                break
            if self.stream is None:
                with salt.utils.asynchronous.current_ioloop(self.io_loop):
                    self.stream = IOStream(socket.socket(sock_type, socket.SOCK_STREAM))
            try:
                log.trace("IPCClient: Connecting to socket: %s", self.socket_path)
                yield self.stream.connect(sock_addr)
                self._connecting_future.set_result(True)
                break
            except Exception as e:  # pylint: disable=broad-except
                if self.stream.closed():
                    self.stream = None
                if timeout is None or time.time() &gt; timeout_at:
                    if self.stream is not None:
                        self.stream.close()
                        self.stream = None
                    self._connecting_future.set_exception(e)
                    break
                yield salt.ext.tornado.gen.sleep(1)
    def close(self):
        if self._closing:
            return
        self._closing = True
        self._connecting_future = None
        log.debug("Closing %s instance", self.__class__.__name__)
        if self.stream is not None and not self.stream.closed():
            try:
                self.stream.close()
            except OSError as exc:
                if exc.errno != errno.EBADF:
                    raise
    def __del__(self):
        try:
            self.close()
        except TypeError:
            pass
    def __enter__(self):
        return self
    def __exit__(self, *args):
        self.close()
class IPCMessageClient(IPCClient):
    async_methods = [
        "send",
        "connect",
        "_connect",
    ]
    close_methods = [
        "close",
    ]
    @salt.ext.tornado.gen.coroutine
    def send(self, msg, timeout=None, tries=None):
        if not self.connected():
            yield self.connect()
        pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
        yield self.stream.write(pack)
class IPCMessageServer(IPCServer):
class IPCMessagePublisher:
    def __init__(self, opts, socket_path, io_loop=None):
        self.opts = opts
        self.socket_path = socket_path
        self._started = False
        self.sock = None
        self.io_loop = io_loop or IOLoop.current()
        self._closing = False
        self.streams = set()
    def start(self):
        log.trace("IPCMessagePublisher: binding to socket: %s", self.socket_path)
        if isinstance(self.socket_path, int):
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.sock.setblocking(0)
            self.sock.bind(("127.0.0.1", self.socket_path))
            self.sock.listen(128)
        else:
            self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
        with salt.utils.asynchronous.current_ioloop(self.io_loop):
            salt.ext.tornado.netutil.add_accept_handler(
                self.sock,
                self.handle_connection,
            )
        self._started = True
    @salt.ext.tornado.gen.coroutine
    def _write(self, stream, pack):
        try:
            yield stream.write(pack)
        except StreamClosedError:
            log.trace("Client disconnected from IPC %s", self.socket_path)
            self.streams.discard(stream)
        except Exception as exc:  # pylint: disable=broad-except
            log.error("Exception occurred while handling stream: %s", exc)
            if not stream.closed():
                stream.close()
            self.streams.discard(stream)
    def publish(self, msg):
        if not self.streams:
            return
        pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
        for stream in self.streams:
            self.io_loop.spawn_callback(self._write, stream, pack)
    def handle_connection(self, connection, address):
        log.trace("IPCServer: Handling connection to address: %s", address)
        try:
            kwargs = {}
            if self.opts["ipc_write_buffer"] &gt; 0:
                kwargs["max_write_buffer_size"] = self.opts["ipc_write_buffer"]
                log.trace(
                    "Setting IPC connection write buffer: %s",
                    (self.opts["ipc_write_buffer"]),
                )
            with salt.utils.asynchronous.current_ioloop(self.io_loop):
                stream = IOStream(connection, **kwargs)
            self.streams.add(stream)
            def discard_after_closed():
                self.streams.discard(stream)
            stream.set_close_callback(discard_after_closed)
        except Exception as exc:  # pylint: disable=broad-except
            log.error("IPC streaming error: %s", exc)
    def close(self):
        if self._closing:
            return
        self._closing = True
        for stream in self.streams:
            stream.close()
        self.streams.clear()
        if hasattr(self.sock, "close"):
            self.sock.close()
    def __enter__(self):
        return self
    def __exit__(self, *args):
        self.close()
class IPCMessageSubscriber(IPCClient):
    async_methods = [
        "read",
        "connect",
    ]
    close_methods = [
        "close",
    ]
    def __init__(self, socket_path, io_loop=None):
        super().__init__(socket_path, io_loop=io_loop)
        self._read_stream_future = None
        self._saved_data = []
        self._read_in_progress = Lock()
    @salt.ext.tornado.gen.coroutine
    def _read(self, timeout, callback=None):
        try:
            try:
                yield self._read_in_progress.acquire(timeout=0.00000001)
            except salt.ext.tornado.gen.TimeoutError:
                raise salt.ext.tornado.gen.Return(None)
            exc_to_raise = None
            ret = None
            try:
                while True:
                    if self._read_stream_future is None:
                        self._read_stream_future = self.stream.read_bytes(
                            4096, partial=True
                        )
                    if timeout is None:
                        wire_bytes = yield self._read_stream_future
                    else:
                        wire_bytes = yield FutureWithTimeout(
                            self.io_loop, self._read_stream_future, timeout
                        )
                    self._read_stream_future = None
                    timeout = None
                    self.unpacker.feed(wire_bytes)
                    first_sync_msg = True
                    for framed_msg in self.unpacker:
                        if callback:
                            self.io_loop.spawn_callback(callback, framed_msg["body"])
                        elif first_sync_msg:
                            ret = framed_msg["body"]
                            first_sync_msg = False
                        else:
                            self._saved_data.append(framed_msg["body"])
                    if not first_sync_msg:
                        break
            except TornadoTimeoutError:
                ret = None
            except StreamClosedError as exc:
                log.trace("Subscriber disconnected from IPC %s", self.socket_path)
                self._read_stream_future = None
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    "Exception occurred in Subscriber while handling stream: %s", exc
                )
                self._read_stream_future = None
                exc_to_raise = exc
            self._read_in_progress.release()
            if exc_to_raise is not None:
                raise exc_to_raise  # pylint: disable=E0702
            raise salt.ext.tornado.gen.Return(ret)
        except TypeError:
            pass
    @salt.ext.tornado.gen.coroutine
    def read(self, timeout):
        if self._saved_data:
            res = self._saved_data.pop(0)
            raise salt.ext.tornado.gen.Return(res)
        while not self.connected():
            try:
                yield self.connect(timeout=5)
            except StreamClosedError:
                log.trace(
                    "Subscriber closed stream on IPC %s before connect",
                    self.socket_path,
                )
                yield salt.ext.tornado.gen.sleep(1)
            except Exception as exc:  # pylint: disable=broad-except
                log.error("Exception occurred while Subscriber connecting: %s", exc)
                yield salt.ext.tornado.gen.sleep(1)
        res = yield self._read(timeout)
        raise salt.ext.tornado.gen.Return(res)
    def read_sync(self, timeout=None):
        if self._saved_data:
            return self._saved_data.pop(0)
        return self.io_loop.run_sync(lambda: self._read(timeout))
    @salt.ext.tornado.gen.coroutine
    def read_async(self, callback):
        while not self.connected():
            try:
                yield self.connect(timeout=5)
            except StreamClosedError:
                log.trace(
                    "Subscriber closed stream on IPC %s before connect",
                    self.socket_path,
                )
                yield salt.ext.tornado.gen.sleep(1)
            except Exception as exc:  # pylint: disable=broad-except
                log.error("Exception occurred while Subscriber connecting: %s", exc)
                yield salt.ext.tornado.gen.sleep(1)
        yield self._read(None, callback)
    def close(self):
        if self._closing:
            return
        super().close()
        if self._read_stream_future is not None and self._read_stream_future.done():
            exc = self._read_stream_future.exception()
            if exc and not isinstance(exc, StreamClosedError):
                log.error("Read future returned exception %r", exc)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
