<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for augeas.py &amp; ipc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for augeas.py &amp; ipc.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>augeas.py (5.371901%)<th>ipc.py (1.229896%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(30-44)<td><a href="#" name="0">(15-32)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>augeas.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import difflib
2 import logging
3 import os.path
4 import re
5 import salt.utils.args
6 import salt.utils.files
7 import salt.utils.stringutils
8 from salt.modules.augeas_cfg import METHOD_MAP
9 log = logging.getLogger(__name__)
10 def __virtual__():
11     if</b></font> "augeas.execute" in __salt__:
12         return "augeas"
13     return (False, "augeas module could not be loaded")
14 def _workout_filename(filename):
15     if os.path.isfile(filename) or filename == "/":
16         if filename == "/":
17             filename = None
18         return filename
19     else:
20         return _workout_filename(os.path.dirname(filename))
21 def _check_filepath(changes):
22     filename = None
23     for change_ in changes:
24         try:
25             cmd, arg = change_.split(" ", 1)
26             if cmd not in METHOD_MAP:
27                 error = "Command {} is not supported (yet)".format(cmd)
28                 raise ValueError(error)
29             method = METHOD_MAP[cmd]
30             parts = salt.utils.args.shlex_split(arg)
31             if method in ["set", "setm", "move", "remove"]:
32                 filename_ = parts[0]
33             else:
34                 _, _, filename_ = parts
35             if not filename_.startswith("/files"):
36                 error = (
37                     "Changes should be prefixed with "
38                     "/files if no context is provided,"
39                     " change: {}".format(change_)
40                 )
41                 raise ValueError(error)
42             filename_ = re.sub("^/files|/$", "", filename_)
43             if filename is not None:
44                 if filename != filename_:
45                     error = (
46                         "Changes should be made to one "
47                         "file at a time, detected changes "
48                         "to {} and {}".format(filename, filename_)
49                     )
50                     raise ValueError(error)
51             filename = filename_
52         except (ValueError, IndexError) as err:
53             log.error(err)
54             if "error" not in locals():
55                 error = (
56                     "Invalid formatted command, see debug log for details: {}".format(
57                         change_
58                     )
59                 )
60             else:
61                 error = str(err)
62             raise ValueError(error)
63     filename = _workout_filename(filename)
64     return filename
65 def change(name, context=None, changes=None, lens=None, load_path=None, **kwargs):
66     ret = {"name": name, "result": False, "comment": "", "changes": {}}
67     if not changes or not isinstance(changes, list):
68         ret["comment"] = "'changes' must be specified as a list"
69         return ret
70     if load_path is not None:
71         if not isinstance(load_path, list):
72             ret["comment"] = "'load_path' must be specified as a list"
73             return ret
74         else:
75             load_path = ":".join(load_path)
76     filename = None
77     if context is None:
78         try:
79             filename = _check_filepath(changes)
80         except ValueError as err:
81             ret["comment"] = "Error: {}".format(err)
82             return ret
83     else:
84         filename = re.sub("^/files|/$", "", context)
85     if __opts__["test"]:
86         ret["result"] = True
87         ret["comment"] = "Executing commands"
88         if context:
89             ret["comment"] += ' in file "{}":\n'.format(context)
90         ret["comment"] += "\n".join(changes)
91         return ret
92     old_file = []
93     if filename is not None and os.path.isfile(filename):
94         with salt.utils.files.fopen(filename, "r") as file_:
95             old_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
96     result = __salt__["augeas.execute"](
97         context=context, lens=lens, commands=changes, load_path=load_path
98     )
99     ret["result"] = result["retval"]
100     if ret["result"] is False:
101         ret["comment"] = "Error: {}".format(result["error"])
102         return ret
103     if filename is not None and os.path.isfile(filename):
104         with salt.utils.files.fopen(filename, "r") as file_:
105             new_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
106             diff = "".join(difflib.unified_diff(old_file, new_file, n=0))
107         if diff:
108             ret["comment"] = "Changes have been saved"
109             ret["changes"] = {"diff": diff}
110         else:
111             ret["comment"] = "No changes made"
112     else:
113         ret["comment"] = "Changes have been saved"
114         ret["changes"] = {"updates": changes}
115     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ipc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import logging
3 import socket
4 import time
5 import salt.ext.tornado
6 import salt.ext.tornado.gen
7 import salt.ext.tornado.ioloop
8 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.ext.tornado.netutil
9 import salt.transport.client
10 import salt.transport.frame
11 import salt.utils.msgpack
12 from salt.ext.tornado.ioloop import IOLoop
13 from salt.ext.tornado.ioloop import TimeoutError as TornadoTimeoutError
14 from salt.ext.tornado.iostream import IOStream, StreamClosedError
15 from salt.ext.tornado.locks import Lock
16 log = logging.getLogger(__name__)
17 def future_with_timeout_callback(future):
18     if</b></font> future._future_with_timeout is not None:
19         future._future_with_timeout._done_callback(future)
20 class FutureWithTimeout(salt.ext.tornado.concurrent.Future):
21     def __init__(self, io_loop, future, timeout):
22         super().__init__()
23         self.io_loop = io_loop
24         self._future = future
25         if timeout is not None:
26             if timeout &lt; 0.1:
27                 timeout = 0.1
28             self._timeout_handle = self.io_loop.add_timeout(
29                 self.io_loop.time() + timeout, self._timeout_callback
30             )
31         else:
32             self._timeout_handle = None
33         if hasattr(self._future, "_future_with_timeout"):
34             self._future._future_with_timeout = self
35             if self._future.done():
36                 future_with_timeout_callback(self._future)
37         else:
38             self._future._future_with_timeout = self
39             self._future.add_done_callback(future_with_timeout_callback)
40     def _timeout_callback(self):
41         self._timeout_handle = None
42         self._future._future_with_timeout = None
43         self.set_exception(TornadoTimeoutError())
44     def _done_callback(self, future):
45         try:
46             if self._timeout_handle is not None:
47                 self.io_loop.remove_timeout(self._timeout_handle)
48                 self._timeout_handle = None
49             self.set_result(future.result())
50         except Exception as exc:  # pylint: disable=broad-except
51             self.set_exception(exc)
52 class IPCServer:
53     async_methods = [
54         "handle_stream",
55     ]
56     close_methods = [
57         "close",
58     ]
59     def __init__(self, socket_path, io_loop=None, payload_handler=None):
60         self.socket_path = socket_path
61         self._started = False
62         self.payload_handler = payload_handler
63         self.sock = None
64         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
65         self._closing = False
66     def start(self):
67         log.trace("IPCServer: binding to socket: %s", self.socket_path)
68         if isinstance(self.socket_path, int):
69             self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
70             self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
71             self.sock.setblocking(0)
72             self.sock.bind(("127.0.0.1", self.socket_path))
73             self.sock.listen(128)
74         else:
75             self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
76         with salt.utils.asynchronous.current_ioloop(self.io_loop):
77             salt.ext.tornado.netutil.add_accept_handler(
78                 self.sock,
79                 self.handle_connection,
80             )
81         self._started = True
82     @salt.ext.tornado.gen.coroutine
83     def handle_stream(self, stream):
84         @salt.ext.tornado.gen.coroutine
85         def _null(msg):
86             raise salt.ext.tornado.gen.Return(None)
87         def write_callback(stream, header):
88             if header.get("mid"):
89                 @salt.ext.tornado.gen.coroutine
90                 def return_message(msg):
91                     pack = salt.transport.frame.frame_msg_ipc(
92                         msg,
93                         header={"mid": header["mid"]},
94                         raw_body=True,
95                     )
96                     yield stream.write(pack)
97                 return return_message
98             else:
99                 return _null
100         if salt.utils.msgpack.version &gt;= (0, 5, 2):
101             msgpack_kwargs = {"raw": False}
102         else:
103             msgpack_kwargs = {"encoding": "utf-8"}
104         unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
105         while not stream.closed():
106             try:
107                 wire_bytes = yield stream.read_bytes(4096, partial=True)
108                 unpacker.feed(wire_bytes)
109                 for framed_msg in unpacker:
110                     body = framed_msg["body"]
111                     self.io_loop.spawn_callback(
112                         self.payload_handler,
113                         body,
114                         write_callback(stream, framed_msg["head"]),
115                     )
116             except StreamClosedError:
117                 log.trace("Client disconnected from IPC %s", self.socket_path)
118                 break
119             except OSError as exc:
120                 if exc.errno == 0:
121                     log.trace(
122                         "Exception occurred with error number 0, "
123                         "spurious exception: %s",
124                         exc,
125                     )
126                 else:
127                     log.error("Exception occurred while handling stream: %s", exc)
128             except Exception as exc:  # pylint: disable=broad-except
129                 log.error("Exception occurred while handling stream: %s", exc)
130     def handle_connection(self, connection, address):
131         log.trace(
132             "IPCServer: Handling connection to address: %s",
133             address if address else connection,
134         )
135         try:
136             with salt.utils.asynchronous.current_ioloop(self.io_loop):
137                 stream = IOStream(
138                     connection,
139                 )
140             self.io_loop.spawn_callback(self.handle_stream, stream)
141         except Exception as exc:  # pylint: disable=broad-except
142             log.error("IPC streaming error: %s", exc)
143     def close(self):
144         if self._closing:
145             return
146         self._closing = True
147         if hasattr(self.sock, "close"):
148             self.sock.close()
149     def __del__(self):
150         try:
151             self.close()
152         except TypeError:
153             pass
154     def __enter__(self):
155         return self
156     def __exit__(self, *args):
157         self.close()
158 class IPCClient:
159     def __init__(self, socket_path, io_loop=None):
160         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
161         self.socket_path = socket_path
162         self._closing = False
163         self.stream = None
164         if salt.utils.msgpack.version &gt;= (0, 5, 2):
165             msgpack_kwargs = {"raw": False}
166         else:
167             msgpack_kwargs = {"encoding": "utf-8"}
168         self.unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
169         self._connecting_future = None
170     def connected(self):
171         return self.stream is not None and not self.stream.closed()
172     def connect(self, callback=None, timeout=None):
173         if self._connecting_future is not None and not self._connecting_future.done():
174             future = self._connecting_future
175         else:
176             if self._connecting_future is not None:
177                 self._connecting_future.exception()  # pylint: disable=E0203
178             future = salt.ext.tornado.concurrent.Future()
179             self._connecting_future = future
180             self._connect(timeout)
181         if callback is not None:
182             def handle_future(future):
183                 response = future.result()
184                 self.io_loop.add_callback(callback, response)
185             future.add_done_callback(handle_future)
186         return future
187     @salt.ext.tornado.gen.coroutine
188     def _connect(self, timeout=None):
189         if isinstance(self.socket_path, int):
190             sock_type = socket.AF_INET
191             sock_addr = ("127.0.0.1", self.socket_path)
192         else:
193             sock_type = socket.AF_UNIX
194             sock_addr = self.socket_path
195         self.stream = None
196         if timeout is not None:
197             timeout_at = time.time() + timeout
198         while True:
199             if self._closing:
200                 break
201             if self.stream is None:
202                 with salt.utils.asynchronous.current_ioloop(self.io_loop):
203                     self.stream = IOStream(socket.socket(sock_type, socket.SOCK_STREAM))
204             try:
205                 log.trace("IPCClient: Connecting to socket: %s", self.socket_path)
206                 yield self.stream.connect(sock_addr)
207                 self._connecting_future.set_result(True)
208                 break
209             except Exception as e:  # pylint: disable=broad-except
210                 if self.stream.closed():
211                     self.stream = None
212                 if timeout is None or time.time() &gt; timeout_at:
213                     if self.stream is not None:
214                         self.stream.close()
215                         self.stream = None
216                     self._connecting_future.set_exception(e)
217                     break
218                 yield salt.ext.tornado.gen.sleep(1)
219     def close(self):
220         if self._closing:
221             return
222         self._closing = True
223         self._connecting_future = None
224         log.debug("Closing %s instance", self.__class__.__name__)
225         if self.stream is not None and not self.stream.closed():
226             try:
227                 self.stream.close()
228             except OSError as exc:
229                 if exc.errno != errno.EBADF:
230                     raise
231     def __del__(self):
232         try:
233             self.close()
234         except TypeError:
235             pass
236     def __enter__(self):
237         return self
238     def __exit__(self, *args):
239         self.close()
240 class IPCMessageClient(IPCClient):
241     async_methods = [
242         "send",
243         "connect",
244         "_connect",
245     ]
246     close_methods = [
247         "close",
248     ]
249     @salt.ext.tornado.gen.coroutine
250     def send(self, msg, timeout=None, tries=None):
251         if not self.connected():
252             yield self.connect()
253         pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
254         yield self.stream.write(pack)
255 class IPCMessageServer(IPCServer):
256 class IPCMessagePublisher:
257     def __init__(self, opts, socket_path, io_loop=None):
258         self.opts = opts
259         self.socket_path = socket_path
260         self._started = False
261         self.sock = None
262         self.io_loop = io_loop or IOLoop.current()
263         self._closing = False
264         self.streams = set()
265     def start(self):
266         log.trace("IPCMessagePublisher: binding to socket: %s", self.socket_path)
267         if isinstance(self.socket_path, int):
268             self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
269             self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
270             self.sock.setblocking(0)
271             self.sock.bind(("127.0.0.1", self.socket_path))
272             self.sock.listen(128)
273         else:
274             self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
275         with salt.utils.asynchronous.current_ioloop(self.io_loop):
276             salt.ext.tornado.netutil.add_accept_handler(
277                 self.sock,
278                 self.handle_connection,
279             )
280         self._started = True
281     @salt.ext.tornado.gen.coroutine
282     def _write(self, stream, pack):
283         try:
284             yield stream.write(pack)
285         except StreamClosedError:
286             log.trace("Client disconnected from IPC %s", self.socket_path)
287             self.streams.discard(stream)
288         except Exception as exc:  # pylint: disable=broad-except
289             log.error("Exception occurred while handling stream: %s", exc)
290             if not stream.closed():
291                 stream.close()
292             self.streams.discard(stream)
293     def publish(self, msg):
294         if not self.streams:
295             return
296         pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
297         for stream in self.streams:
298             self.io_loop.spawn_callback(self._write, stream, pack)
299     def handle_connection(self, connection, address):
300         log.trace("IPCServer: Handling connection to address: %s", address)
301         try:
302             kwargs = {}
303             if self.opts["ipc_write_buffer"] &gt; 0:
304                 kwargs["max_write_buffer_size"] = self.opts["ipc_write_buffer"]
305                 log.trace(
306                     "Setting IPC connection write buffer: %s",
307                     (self.opts["ipc_write_buffer"]),
308                 )
309             with salt.utils.asynchronous.current_ioloop(self.io_loop):
310                 stream = IOStream(connection, **kwargs)
311             self.streams.add(stream)
312             def discard_after_closed():
313                 self.streams.discard(stream)
314             stream.set_close_callback(discard_after_closed)
315         except Exception as exc:  # pylint: disable=broad-except
316             log.error("IPC streaming error: %s", exc)
317     def close(self):
318         if self._closing:
319             return
320         self._closing = True
321         for stream in self.streams:
322             stream.close()
323         self.streams.clear()
324         if hasattr(self.sock, "close"):
325             self.sock.close()
326     def __enter__(self):
327         return self
328     def __exit__(self, *args):
329         self.close()
330 class IPCMessageSubscriber(IPCClient):
331     async_methods = [
332         "read",
333         "connect",
334     ]
335     close_methods = [
336         "close",
337     ]
338     def __init__(self, socket_path, io_loop=None):
339         super().__init__(socket_path, io_loop=io_loop)
340         self._read_stream_future = None
341         self._saved_data = []
342         self._read_in_progress = Lock()
343     @salt.ext.tornado.gen.coroutine
344     def _read(self, timeout, callback=None):
345         try:
346             try:
347                 yield self._read_in_progress.acquire(timeout=0.00000001)
348             except salt.ext.tornado.gen.TimeoutError:
349                 raise salt.ext.tornado.gen.Return(None)
350             exc_to_raise = None
351             ret = None
352             try:
353                 while True:
354                     if self._read_stream_future is None:
355                         self._read_stream_future = self.stream.read_bytes(
356                             4096, partial=True
357                         )
358                     if timeout is None:
359                         wire_bytes = yield self._read_stream_future
360                     else:
361                         wire_bytes = yield FutureWithTimeout(
362                             self.io_loop, self._read_stream_future, timeout
363                         )
364                     self._read_stream_future = None
365                     timeout = None
366                     self.unpacker.feed(wire_bytes)
367                     first_sync_msg = True
368                     for framed_msg in self.unpacker:
369                         if callback:
370                             self.io_loop.spawn_callback(callback, framed_msg["body"])
371                         elif first_sync_msg:
372                             ret = framed_msg["body"]
373                             first_sync_msg = False
374                         else:
375                             self._saved_data.append(framed_msg["body"])
376                     if not first_sync_msg:
377                         break
378             except TornadoTimeoutError:
379                 ret = None
380             except StreamClosedError as exc:
381                 log.trace("Subscriber disconnected from IPC %s", self.socket_path)
382                 self._read_stream_future = None
383             except Exception as exc:  # pylint: disable=broad-except
384                 log.error(
385                     "Exception occurred in Subscriber while handling stream: %s", exc
386                 )
387                 self._read_stream_future = None
388                 exc_to_raise = exc
389             self._read_in_progress.release()
390             if exc_to_raise is not None:
391                 raise exc_to_raise  # pylint: disable=E0702
392             raise salt.ext.tornado.gen.Return(ret)
393         except TypeError:
394             pass
395     @salt.ext.tornado.gen.coroutine
396     def read(self, timeout):
397         if self._saved_data:
398             res = self._saved_data.pop(0)
399             raise salt.ext.tornado.gen.Return(res)
400         while not self.connected():
401             try:
402                 yield self.connect(timeout=5)
403             except StreamClosedError:
404                 log.trace(
405                     "Subscriber closed stream on IPC %s before connect",
406                     self.socket_path,
407                 )
408                 yield salt.ext.tornado.gen.sleep(1)
409             except Exception as exc:  # pylint: disable=broad-except
410                 log.error("Exception occurred while Subscriber connecting: %s", exc)
411                 yield salt.ext.tornado.gen.sleep(1)
412         res = yield self._read(timeout)
413         raise salt.ext.tornado.gen.Return(res)
414     def read_sync(self, timeout=None):
415         if self._saved_data:
416             return self._saved_data.pop(0)
417         return self.io_loop.run_sync(lambda: self._read(timeout))
418     @salt.ext.tornado.gen.coroutine
419     def read_async(self, callback):
420         while not self.connected():
421             try:
422                 yield self.connect(timeout=5)
423             except StreamClosedError:
424                 log.trace(
425                     "Subscriber closed stream on IPC %s before connect",
426                     self.socket_path,
427                 )
428                 yield salt.ext.tornado.gen.sleep(1)
429             except Exception as exc:  # pylint: disable=broad-except
430                 log.error("Exception occurred while Subscriber connecting: %s", exc)
431                 yield salt.ext.tornado.gen.sleep(1)
432         yield self._read(None, callback)
433     def close(self):
434         if self._closing:
435             return
436         super().close()
437         if self._read_stream_future is not None and self._read_stream_future.done():
438             exc = self._read_stream_future.exception()
439             if exc and not isinstance(exc, StreamClosedError):
440                 log.error("Read future returned exception %r", exc)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
