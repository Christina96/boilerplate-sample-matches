<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for augeas.py &amp; ipc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for augeas.py &amp; ipc.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>augeas.py (5.371901%)<th>ipc.py (1.229896%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(30-44)<td><a href="#" name="0">(15-32)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>augeas.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import difflib
2 import logging
3 import os.path
4 import re
5 import salt.utils.args
6 import salt.utils.files
7 import salt.utils.stringutils
8 from salt.modules.augeas_cfg import METHOD_MAP
9 log = logging.getLogger(__name__)
10 def __virtual__():
11     if</b></font> "augeas.execute" in __salt__:
12         return "augeas"
13     return (False, "augeas module could not be loaded")
14 def _workout_filename(filename):
15     if os.path.isfile(filename) or filename == "/":
16         if filename == "/":
17             filename = None
18         return filename
19     else:
20         return _workout_filename(os.path.dirname(filename))
21 def _check_filepath(changes):
22     filename = None
23     for change_ in changes:
24         try:
25             cmd, arg = change_.split(" ", 1)
26             if cmd not in METHOD_MAP:
27                 error = "Command {} is not supported (yet)".format(cmd)
28                 raise ValueError(error)
29             method = METHOD_MAP[cmd]
30             parts = salt.utils.args.shlex_split(arg)
31             if method in ["set", "setm", "move", "remove"]:
32                 filename_ = parts[0]
33             else:
34                 _, _, filename_ = parts
35             if not filename_.startswith("/files"):
36                 error = (
37                     "Changes should be prefixed with "
38                     "/files if no context is provided,"
39                     " change: {}".format(change_)
40                 )
41                 raise ValueError(error)
42             filename_ = re.sub("^/files|/$", "", filename_)
43             if filename is not None:
44                 if filename != filename_:
45                     error = (
46                         "Changes should be made to one "
47                         "file at a time, detected changes "
48                         "to {} and {}".format(filename, filename_)
49                     )
50                     raise ValueError(error)
51             filename = filename_
52         except (ValueError, IndexError) as err:
53             log.error(err)
54             if "error" not in locals():
55                 error = (
56                     "Invalid formatted command, see debug log for details: {}".format(
57                         change_
58                     )
59                 )
60             else:
61                 error = str(err)
62             raise ValueError(error)
63     filename = _workout_filename(filename)
64     return filename
65 def change(name, context=None, changes=None, lens=None, load_path=None, **kwargs):
66     ret = {"name": name, "result": False, "comment": "", "changes": {}}
67     if not changes or not isinstance(changes, list):
68         ret["comment"] = "'changes' must be specified as a list"
69         return ret
70     if load_path is not None:
71         if not isinstance(load_path, list):
72             ret["comment"] = "'load_path' must be specified as a list"
73             return ret
74         else:
75             load_path = ":".join(load_path)
76     filename = None
77     if context is None:
78         try:
79             filename = _check_filepath(changes)
80         except ValueError as err:
81             ret["comment"] = "Error: {}".format(err)
82             return ret
83     else:
84         filename = re.sub("^/files|/$", "", context)
85     if __opts__["test"]:
86         ret["result"] = True
87         ret["comment"] = "Executing commands"
88         if context:
89             ret["comment"] += ' in file "{}":\n'.format(context)
90         ret["comment"] += "\n".join(changes)
91         return ret
92     old_file = []
93     if filename is not None and os.path.isfile(filename):
94         with salt.utils.files.fopen(filename, "r") as file_:
95             old_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
96     result = __salt__["augeas.execute"](
97         context=context, lens=lens, commands=changes, load_path=load_path
98     )
99     ret["result"] = result["retval"]
100     if ret["result"] is False:
101         ret["comment"] = "Error: {}".format(result["error"])
102         return ret
103     if filename is not None and os.path.isfile(filename):
104         with salt.utils.files.fopen(filename, "r") as file_:
105             new_file = [salt.utils.stringutils.to_unicode(x) for x in file_.readlines()]
106             diff = "".join(difflib.unified_diff(old_file, new_file, n=0))
107         if diff:
108             ret["comment"] = "Changes have been saved"
109             ret["changes"] = {"diff": diff}
110         else:
111             ret["comment"] = "No changes made"
112     else:
113         ret["comment"] = "Changes have been saved"
114         ret["changes"] = {"updates": changes}
115     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ipc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import logging
3 import socket
4 import time
5 import salt.ext.tornado
6 <a name="0"></a>import salt.ext.tornado.concurrent
7 import salt.ext.tornado.gen
8 import salt.ext.tornado.ioloop
9 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.ext.tornado.netutil
10 import salt.transport.client
11 import salt.transport.frame
12 import salt.utils.msgpack
13 from salt.ext.tornado.ioloop import IOLoop
14 from salt.ext.tornado.ioloop import TimeoutError as TornadoTimeoutError
15 from salt.ext.tornado.iostream import IOStream, StreamClosedError
16 from salt.ext.tornado.locks import Lock
17 log = logging.getLogger(__name__)
18 def future_with_timeout_callback(future):
19     if</b></font> future._future_with_timeout is not None:
20         future._future_with_timeout._done_callback(future)
21 class FutureWithTimeout(salt.ext.tornado.concurrent.Future):
22     def __init__(self, io_loop, future, timeout):
23         super().__init__()
24         self.io_loop = io_loop
25         self._future = future
26         if timeout is not None:
27             if timeout &lt; 0.1:
28                 timeout = 0.1
29             self._timeout_handle = self.io_loop.add_timeout(
30                 self.io_loop.time() + timeout, self._timeout_callback
31             )
32         else:
33             self._timeout_handle = None
34         if hasattr(self._future, "_future_with_timeout"):
35             self._future._future_with_timeout = self
36             if self._future.done():
37                 future_with_timeout_callback(self._future)
38         else:
39             self._future._future_with_timeout = self
40             self._future.add_done_callback(future_with_timeout_callback)
41     def _timeout_callback(self):
42         self._timeout_handle = None
43         self._future._future_with_timeout = None
44         self.set_exception(TornadoTimeoutError())
45     def _done_callback(self, future):
46         try:
47             if self._timeout_handle is not None:
48                 self.io_loop.remove_timeout(self._timeout_handle)
49                 self._timeout_handle = None
50             self.set_result(future.result())
51         except Exception as exc:  # pylint: disable=broad-except
52             self.set_exception(exc)
53 class IPCServer:
54     async_methods = [
55         "handle_stream",
56     ]
57     close_methods = [
58         "close",
59     ]
60     def __init__(self, socket_path, io_loop=None, payload_handler=None):
61         self.socket_path = socket_path
62         self._started = False
63         self.payload_handler = payload_handler
64         self.sock = None
65         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
66         self._closing = False
67     def start(self):
68         log.trace("IPCServer: binding to socket: %s", self.socket_path)
69         if isinstance(self.socket_path, int):
70             self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
71             self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
72             self.sock.setblocking(0)
73             self.sock.bind(("127.0.0.1", self.socket_path))
74             self.sock.listen(128)
75         else:
76             self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
77         with salt.utils.asynchronous.current_ioloop(self.io_loop):
78             salt.ext.tornado.netutil.add_accept_handler(
79                 self.sock,
80                 self.handle_connection,
81             )
82         self._started = True
83     @salt.ext.tornado.gen.coroutine
84     def handle_stream(self, stream):
85         @salt.ext.tornado.gen.coroutine
86         def _null(msg):
87             raise salt.ext.tornado.gen.Return(None)
88         def write_callback(stream, header):
89             if header.get("mid"):
90                 @salt.ext.tornado.gen.coroutine
91                 def return_message(msg):
92                     pack = salt.transport.frame.frame_msg_ipc(
93                         msg,
94                         header={"mid": header["mid"]},
95                         raw_body=True,
96                     )
97                     yield stream.write(pack)
98                 return return_message
99             else:
100                 return _null
101         if salt.utils.msgpack.version &gt;= (0, 5, 2):
102             msgpack_kwargs = {"raw": False}
103         else:
104             msgpack_kwargs = {"encoding": "utf-8"}
105         unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
106         while not stream.closed():
107             try:
108                 wire_bytes = yield stream.read_bytes(4096, partial=True)
109                 unpacker.feed(wire_bytes)
110                 for framed_msg in unpacker:
111                     body = framed_msg["body"]
112                     self.io_loop.spawn_callback(
113                         self.payload_handler,
114                         body,
115                         write_callback(stream, framed_msg["head"]),
116                     )
117             except StreamClosedError:
118                 log.trace("Client disconnected from IPC %s", self.socket_path)
119                 break
120             except OSError as exc:
121                 if exc.errno == 0:
122                     log.trace(
123                         "Exception occurred with error number 0, "
124                         "spurious exception: %s",
125                         exc,
126                     )
127                 else:
128                     log.error("Exception occurred while handling stream: %s", exc)
129             except Exception as exc:  # pylint: disable=broad-except
130                 log.error("Exception occurred while handling stream: %s", exc)
131     def handle_connection(self, connection, address):
132         log.trace(
133             "IPCServer: Handling connection to address: %s",
134             address if address else connection,
135         )
136         try:
137             with salt.utils.asynchronous.current_ioloop(self.io_loop):
138                 stream = IOStream(
139                     connection,
140                 )
141             self.io_loop.spawn_callback(self.handle_stream, stream)
142         except Exception as exc:  # pylint: disable=broad-except
143             log.error("IPC streaming error: %s", exc)
144     def close(self):
145         if self._closing:
146             return
147         self._closing = True
148         if hasattr(self.sock, "close"):
149             self.sock.close()
150     def __del__(self):
151         try:
152             self.close()
153         except TypeError:
154             pass
155     def __enter__(self):
156         return self
157     def __exit__(self, *args):
158         self.close()
159 class IPCClient:
160     def __init__(self, socket_path, io_loop=None):
161         self.io_loop = io_loop or salt.ext.tornado.ioloop.IOLoop.current()
162         self.socket_path = socket_path
163         self._closing = False
164         self.stream = None
165         if salt.utils.msgpack.version &gt;= (0, 5, 2):
166             msgpack_kwargs = {"raw": False}
167         else:
168             msgpack_kwargs = {"encoding": "utf-8"}
169         self.unpacker = salt.utils.msgpack.Unpacker(**msgpack_kwargs)
170         self._connecting_future = None
171     def connected(self):
172         return self.stream is not None and not self.stream.closed()
173     def connect(self, callback=None, timeout=None):
174         if self._connecting_future is not None and not self._connecting_future.done():
175             future = self._connecting_future
176         else:
177             if self._connecting_future is not None:
178                 self._connecting_future.exception()  # pylint: disable=E0203
179             future = salt.ext.tornado.concurrent.Future()
180             self._connecting_future = future
181             self._connect(timeout)
182         if callback is not None:
183             def handle_future(future):
184                 response = future.result()
185                 self.io_loop.add_callback(callback, response)
186             future.add_done_callback(handle_future)
187         return future
188     @salt.ext.tornado.gen.coroutine
189     def _connect(self, timeout=None):
190         if isinstance(self.socket_path, int):
191             sock_type = socket.AF_INET
192             sock_addr = ("127.0.0.1", self.socket_path)
193         else:
194             sock_type = socket.AF_UNIX
195             sock_addr = self.socket_path
196         self.stream = None
197         if timeout is not None:
198             timeout_at = time.time() + timeout
199         while True:
200             if self._closing:
201                 break
202             if self.stream is None:
203                 with salt.utils.asynchronous.current_ioloop(self.io_loop):
204                     self.stream = IOStream(socket.socket(sock_type, socket.SOCK_STREAM))
205             try:
206                 log.trace("IPCClient: Connecting to socket: %s", self.socket_path)
207                 yield self.stream.connect(sock_addr)
208                 self._connecting_future.set_result(True)
209                 break
210             except Exception as e:  # pylint: disable=broad-except
211                 if self.stream.closed():
212                     self.stream = None
213                 if timeout is None or time.time() &gt; timeout_at:
214                     if self.stream is not None:
215                         self.stream.close()
216                         self.stream = None
217                     self._connecting_future.set_exception(e)
218                     break
219                 yield salt.ext.tornado.gen.sleep(1)
220     def close(self):
221         if self._closing:
222             return
223         self._closing = True
224         self._connecting_future = None
225         log.debug("Closing %s instance", self.__class__.__name__)
226         if self.stream is not None and not self.stream.closed():
227             try:
228                 self.stream.close()
229             except OSError as exc:
230                 if exc.errno != errno.EBADF:
231                     raise
232     def __del__(self):
233         try:
234             self.close()
235         except TypeError:
236             pass
237     def __enter__(self):
238         return self
239     def __exit__(self, *args):
240         self.close()
241 class IPCMessageClient(IPCClient):
242     async_methods = [
243         "send",
244         "connect",
245         "_connect",
246     ]
247     close_methods = [
248         "close",
249     ]
250     @salt.ext.tornado.gen.coroutine
251     def send(self, msg, timeout=None, tries=None):
252         if not self.connected():
253             yield self.connect()
254         pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
255         yield self.stream.write(pack)
256 class IPCMessageServer(IPCServer):
257 class IPCMessagePublisher:
258     def __init__(self, opts, socket_path, io_loop=None):
259         self.opts = opts
260         self.socket_path = socket_path
261         self._started = False
262         self.sock = None
263         self.io_loop = io_loop or IOLoop.current()
264         self._closing = False
265         self.streams = set()
266     def start(self):
267         log.trace("IPCMessagePublisher: binding to socket: %s", self.socket_path)
268         if isinstance(self.socket_path, int):
269             self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
270             self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
271             self.sock.setblocking(0)
272             self.sock.bind(("127.0.0.1", self.socket_path))
273             self.sock.listen(128)
274         else:
275             self.sock = salt.ext.tornado.netutil.bind_unix_socket(self.socket_path)
276         with salt.utils.asynchronous.current_ioloop(self.io_loop):
277             salt.ext.tornado.netutil.add_accept_handler(
278                 self.sock,
279                 self.handle_connection,
280             )
281         self._started = True
282     @salt.ext.tornado.gen.coroutine
283     def _write(self, stream, pack):
284         try:
285             yield stream.write(pack)
286         except StreamClosedError:
287             log.trace("Client disconnected from IPC %s", self.socket_path)
288             self.streams.discard(stream)
289         except Exception as exc:  # pylint: disable=broad-except
290             log.error("Exception occurred while handling stream: %s", exc)
291             if not stream.closed():
292                 stream.close()
293             self.streams.discard(stream)
294     def publish(self, msg):
295         if not self.streams:
296             return
297         pack = salt.transport.frame.frame_msg_ipc(msg, raw_body=True)
298         for stream in self.streams:
299             self.io_loop.spawn_callback(self._write, stream, pack)
300     def handle_connection(self, connection, address):
301         log.trace("IPCServer: Handling connection to address: %s", address)
302         try:
303             kwargs = {}
304             if self.opts["ipc_write_buffer"] &gt; 0:
305                 kwargs["max_write_buffer_size"] = self.opts["ipc_write_buffer"]
306                 log.trace(
307                     "Setting IPC connection write buffer: %s",
308                     (self.opts["ipc_write_buffer"]),
309                 )
310             with salt.utils.asynchronous.current_ioloop(self.io_loop):
311                 stream = IOStream(connection, **kwargs)
312             self.streams.add(stream)
313             def discard_after_closed():
314                 self.streams.discard(stream)
315             stream.set_close_callback(discard_after_closed)
316         except Exception as exc:  # pylint: disable=broad-except
317             log.error("IPC streaming error: %s", exc)
318     def close(self):
319         if self._closing:
320             return
321         self._closing = True
322         for stream in self.streams:
323             stream.close()
324         self.streams.clear()
325         if hasattr(self.sock, "close"):
326             self.sock.close()
327     def __enter__(self):
328         return self
329     def __exit__(self, *args):
330         self.close()
331 class IPCMessageSubscriber(IPCClient):
332     async_methods = [
333         "read",
334         "connect",
335     ]
336     close_methods = [
337         "close",
338     ]
339     def __init__(self, socket_path, io_loop=None):
340         super().__init__(socket_path, io_loop=io_loop)
341         self._read_stream_future = None
342         self._saved_data = []
343         self._read_in_progress = Lock()
344     @salt.ext.tornado.gen.coroutine
345     def _read(self, timeout, callback=None):
346         try:
347             try:
348                 yield self._read_in_progress.acquire(timeout=0.00000001)
349             except salt.ext.tornado.gen.TimeoutError:
350                 raise salt.ext.tornado.gen.Return(None)
351             exc_to_raise = None
352             ret = None
353             try:
354                 while True:
355                     if self._read_stream_future is None:
356                         self._read_stream_future = self.stream.read_bytes(
357                             4096, partial=True
358                         )
359                     if timeout is None:
360                         wire_bytes = yield self._read_stream_future
361                     else:
362                         wire_bytes = yield FutureWithTimeout(
363                             self.io_loop, self._read_stream_future, timeout
364                         )
365                     self._read_stream_future = None
366                     timeout = None
367                     self.unpacker.feed(wire_bytes)
368                     first_sync_msg = True
369                     for framed_msg in self.unpacker:
370                         if callback:
371                             self.io_loop.spawn_callback(callback, framed_msg["body"])
372                         elif first_sync_msg:
373                             ret = framed_msg["body"]
374                             first_sync_msg = False
375                         else:
376                             self._saved_data.append(framed_msg["body"])
377                     if not first_sync_msg:
378                         break
379             except TornadoTimeoutError:
380                 ret = None
381             except StreamClosedError as exc:
382                 log.trace("Subscriber disconnected from IPC %s", self.socket_path)
383                 self._read_stream_future = None
384             except Exception as exc:  # pylint: disable=broad-except
385                 log.error(
386                     "Exception occurred in Subscriber while handling stream: %s", exc
387                 )
388                 self._read_stream_future = None
389                 exc_to_raise = exc
390             self._read_in_progress.release()
391             if exc_to_raise is not None:
392                 raise exc_to_raise  # pylint: disable=E0702
393             raise salt.ext.tornado.gen.Return(ret)
394         except TypeError:
395             pass
396     @salt.ext.tornado.gen.coroutine
397     def read(self, timeout):
398         if self._saved_data:
399             res = self._saved_data.pop(0)
400             raise salt.ext.tornado.gen.Return(res)
401         while not self.connected():
402             try:
403                 yield self.connect(timeout=5)
404             except StreamClosedError:
405                 log.trace(
406                     "Subscriber closed stream on IPC %s before connect",
407                     self.socket_path,
408                 )
409                 yield salt.ext.tornado.gen.sleep(1)
410             except Exception as exc:  # pylint: disable=broad-except
411                 log.error("Exception occurred while Subscriber connecting: %s", exc)
412                 yield salt.ext.tornado.gen.sleep(1)
413         res = yield self._read(timeout)
414         raise salt.ext.tornado.gen.Return(res)
415     def read_sync(self, timeout=None):
416         if self._saved_data:
417             return self._saved_data.pop(0)
418         return self.io_loop.run_sync(lambda: self._read(timeout))
419     @salt.ext.tornado.gen.coroutine
420     def read_async(self, callback):
421         while not self.connected():
422             try:
423                 yield self.connect(timeout=5)
424             except StreamClosedError:
425                 log.trace(
426                     "Subscriber closed stream on IPC %s before connect",
427                     self.socket_path,
428                 )
429                 yield salt.ext.tornado.gen.sleep(1)
430             except Exception as exc:  # pylint: disable=broad-except
431                 log.error("Exception occurred while Subscriber connecting: %s", exc)
432                 yield salt.ext.tornado.gen.sleep(1)
433         yield self._read(None, callback)
434     def close(self):
435         if self._closing:
436             return
437         super().close()
438         if self._read_stream_future is not None and self._read_stream_future.done():
439             exc = self._read_stream_future.exception()
440             if exc and not isinstance(exc, StreamClosedError):
441                 log.error("Read future returned exception %r", exc)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
