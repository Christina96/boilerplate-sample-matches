
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.040582726326743%, Tokens: 10</h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-mediatools.py</h3>
            <pre><code>1  import os
2  import time
3  from datetime import datetime as dt
4  from pyUltroid.fns.misc import rotate_image
5  from pyUltroid.fns.tools import make_html_telegraph
6  from . import (
7      LOGS,
8      Telegraph,
9      bash,
10      downloader,
11      get_string,
12      is_url_ok,
13      mediainfo,
14      ultroid_cmd,
15  )
16  try:
17      import cv2
18  except ImportError:
19      LOGS.info("WARNING: 'cv2' not found!")
20      cv2 = None
21  @ultroid_cmd(pattern="mediainfo( (.*)|$)")
22  async def mi(e):
23      r = await e.get_reply_message()
24      match = e.pattern_match.group(1).strip()
25      taime = time.time()
26      extra = ""
27      if r and r.media:
28          xx = mediainfo(r.media)
29          murl = r.media.stringify()
30          url = await make_html_telegraph("Mediainfo", f"<pre>{murl}</pre>")
31          extra = f"**[{xx}]({url})**\n\n"
32          e = await e.eor(f"{extra}`Loading More...`", link_preview=False)
33          if hasattr(r.media, "document"):
34              file = r.media.document
35              mime_type = file.mime_type
36              filename = r.file.name
37              if not filename:
38                  if "audio" in mime_type:
<span onclick='openModal()' class='match'>39                      filename = "audio_" + dt.now().isoformat("_", "seconds") + ".ogg"
40                  elif "video" in mime_type:
41                      filename = "video_" + dt.now().isoformat("_", "seconds") + ".mp4"
</span>42              dl = await downloader(
43                  f"resources/downloads/{filename}",
44                  file,
45                  e,
46                  taime,
47                  f"{extra}`Loading More...`",
48              )
49              naam = dl.name
50          else:
51              naam = await r.download_media()
52      elif match and (
53          os.path.isfile(match)
54          or (match.startswith("https://") and (await is_url_ok(match)))
55      ):
56          naam, xx = match, "file"
57      else:
58          return await e.eor(get_string("cvt_3"), time=5)
59      out, er = await bash(f"mediainfo '{naam}'")
60      if er:
61          LOGS.info(er)
62          out = extra or str(er)
63          return await e.edit(out, link_preview=False)
64      makehtml = ""
65      if naam.endswith((".jpg", ".png")):
66          if os.path.exists(naam):
67              med = "https://graph.org" + Telegraph.upload_file(naam)[0]["src"]
68          else:
69              med = match
70          makehtml += f"<img src='{med}'><br>"
71      for line in out.split("\n"):
72          line = line.strip()
73          if not line:
74              makehtml += "<br>"
75          elif ":" not in line:
76              makehtml += f"<h3>{line}</h3>"
77          else:
78              makehtml += f"<p>{line}</p>"
79      try:
80          urll = await make_html_telegraph("Mediainfo", makehtml)
81      except Exception as er:
82          LOGS.exception(er)
83          return
84      await e.eor(f"{extra}[{get_string('mdi_1')}]({urll})", link_preview=False)
85      if not match:
86          os.remove(naam)
87  @ultroid_cmd(pattern="rotate( (.*)|$)")
88  async def rotate_(ult):
89      match = ult.pattern_match.group(1).strip()
90      if not ult.is_reply:
91          return await ult.eor("`Reply to a media...`")
92      if match:
93          try:
94              match = int(match)
95          except ValueError:
96              match = None
97      if not match:
98          return await ult.eor("`Please provide a valid angle to rotate media..`")
99      reply = await ult.get_reply_message()
100      msg = await ult.eor(get_string("com_1"))
101      photo = reply.game.photo if reply.game else None
102      if reply.video:
103          media = await reply.download_media()
104          file = f"{media}.mp4"
105          await bash(
106              f'ffmpeg -i "{media}" -c copy -metadata:s:v:0 rotate={match} "{file}" -y'
107          )
108      elif photo or reply.photo or reply.sticker:
109          media = await ult.client.download_media(photo or reply)
110          img = cv2.imread(media)
111          new_ = rotate_image(img, match)
112          file = "ult.png"
113          cv2.imwrite(file, new_)
114      else:
115          return await msg.edit("`Unsupported Media..\nReply to Photo/Video`")
116      if os.path.exists(file):
117          await ult.client.send_file(
118              ult.chat_id, file=file, video_note=bool(reply.video_note), reply_to=reply.id
119          )
120      os.remove(media)
121      await msg.try_delete()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, "images", "efuse")
10  S_IMAGES_DIR = os.path.join(TEST_DIR, "secure_images")
11  EFUSE_S_DIR = os.path.join(TEST_DIR, "efuse_scripts")
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f"{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}")
24  print(f"\nHost tests of espefuse.py for {arg_chip}:")
25  print("Running espefuse.py tests...")
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f"{sys.executable} -m espefuse --chip {arg_chip} "
33                  f"--virt --path-efuse-file {self.efuse_file.name} -d"
34              )
35          else:
36              self.base_cmd = (
37                  f"{sys.executable} -m espefuse --chip {arg_chip} "
38                  f"--port {arg_port} -d"
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py("burn_efuse CODING_SCHEME 1")
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, "rb") as f:
72              data = BitStream("0x00") * offset + BitStream(f)
73              blk = data.readlist(f"{data.len // 8}*uint:8")
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = " ".join(f"{num:02x}" for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = " ".join((f"{sys.executable} -m espefuse", cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = " ".join(
82              [self.base_cmd, "--do-not-confirm" if do_not_confirm else "", cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              " ".join([self.base_cmd, "check_error"]), "No errors detected", 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py("--help", check_msg="usage: __main__.py [-h]")
114          self.espefuse_not_virt_py(f"--chip {arg_chip} --help")
115      def test_help2(self):
116          self.espefuse_not_virt_py("", check_msg="usage: __main__.py [-h]", ret_code=1)
117      def test_dump(self):
118          self.espefuse_py("dump -h")
119          self.espefuse_py("dump")
120      def test_summary(self):
121          self.espefuse_py("summary -h")
122          self.espefuse_py("summary")
123      def test_summary_json(self):
124          self.espefuse_py("summary --format json")
125      def test_get_custom_mac(self):
126          self.espefuse_py("get_custom_mac -h")
127          if arg_chip == "esp32":
128              right_msg = "Custom MAC Address is not set in the device."
129          elif arg_chip in ["esp32h2", "esp32h2beta1"]:
130              right_msg = "Custom MAC Address: 00:00:00:00:00:00:00:00 (OK)"
131          else:
132              right_msg = "Custom MAC Address: 00:00:00:00:00:00 (OK)"
133          self.espefuse_py("get_custom_mac", check_msg=right_msg)
134      def test_adc_info(self):
135          self.espefuse_py("adc_info -h")
136          self.espefuse_py("adc_info")
137      def test_check_error(self):
138          self.espefuse_py("check_error -h")
139          self.espefuse_py("check_error")
140          self.espefuse_py("check_error --recovery")
141  class TestReadProtectionCommands(EfuseTestCase):
142      def test_read_protect_efuse(self):
143          self.espefuse_py("read_protect_efuse -h")
144          if arg_chip == "esp32":
145              cmd = "read_protect_efuse \
146                     CODING_SCHEME \
147                     MAC_VERSION \
148                     BLOCK1 \
149                     BLOCK2 \
150                     BLOCK3"
151              count_protects = 5
152          elif arg_chip == "esp32c2":
153              cmd = "read_protect_efuse \
154                     BLOCK_KEY0_LOW_128"
155              count_protects = 1
156          else:
157              self.espefuse_py(
158                  "burn_efuse \
159                  KEY_PURPOSE_0 HMAC_UP \
160                  KEY_PURPOSE_1 XTS_AES_128_KEY \
161                  KEY_PURPOSE_2 XTS_AES_128_KEY \
162                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
163                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
164                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE"
165              )
166              cmd = "read_protect_efuse \
167                     BLOCK_KEY0 \
168                     BLOCK_KEY1 \
169                     BLOCK_KEY2 \
170                     BLOCK_KEY3 \
171                     BLOCK_KEY4 \
172                     BLOCK_KEY5"
173              count_protects = 6
174          self.espefuse_py(cmd)
175          output = self.espefuse_py(cmd)
176          assert count_protects == output.count("is already read protected")
177      def test_read_protect_efuse2(self):
178          self.espefuse_py("write_protect_efuse RD_DIS")
179          if arg_chip == "esp32":
180              efuse_name = "CODING_SCHEME"
181          elif arg_chip == "esp32c2":
182              efuse_name = "BLOCK_KEY0_HI_128"
183          else:
184              efuse_name = "BLOCK_SYS_DATA2"
185          self.espefuse_py(
186              f"read_protect_efuse {efuse_name}",
187              check_msg="A fatal error occurred: This efuse cannot be read-disabled "
188              "due the to RD_DIS field is already write-disabled",
189              ret_code=2,
190          )
191      @pytest.mark.skipif(arg_chip != "esp32", reason="when the purpose of BLOCK2 is set")
192      def test_read_protect_efuse3(self):
193          self.espefuse_py("burn_efuse ABS_DONE_1 1")
194          self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
195          self.espefuse_py(
196              "read_protect_efuse BLOCK2",
197              check_msg="Secure Boot V2 is on (ABS_DONE_1 = True), "
198              "BLOCK2 must be readable, stop this operation!",
199              ret_code=2,
200          )
201      def test_read_protect_efuse4(self):
202          if arg_chip == "esp32":
203              self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
204              msg = "must be readable, please stop this operation!"
205              self.espefuse_py("read_protect_efuse BLOCK2", check_msg=msg)
206          elif arg_chip == "esp32c2":
207              self.espefuse_py(
208                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
209              )
210              self.espefuse_py(
211                  "read_protect_efuse BLOCK_KEY0",
212                  check_msg="A fatal error occurred: "
213                  "BLOCK_KEY0 must be readable, stop this operation!",
214                  ret_code=2,
215              )
216          else:
217              self.espefuse_py(
218                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
219                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
220                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
221                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
222                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
223                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP"
224              )
225              self.espefuse_py(
226                  "read_protect_efuse BLOCK_KEY0",
227                  check_msg="A fatal error occurred: "
228                  "BLOCK_KEY0 must be readable, stop this operation!",
229                  ret_code=2,
230              )
231              self.espefuse_py(
232                  "read_protect_efuse BLOCK_KEY1",
233                  check_msg="A fatal error occurred: "
234                  "BLOCK_KEY1 must be readable, stop this operation!",
235                  ret_code=2,
236              )
237              self.espefuse_py(
238                  "read_protect_efuse BLOCK_KEY2",
239                  check_msg="A fatal error occurred: "
240                  "BLOCK_KEY2 must be readable, stop this operation!",
241                  ret_code=2,
242              )
243              self.espefuse_py(
244                  "read_protect_efuse BLOCK_KEY3",
245                  check_msg="A fatal error occurred: "
246                  "BLOCK_KEY3 must be readable, stop this operation!",
247                  ret_code=2,
248              )
249              self.espefuse_py(
250                  "read_protect_efuse BLOCK_KEY4",
251                  check_msg="A fatal error occurred: "
252                  "BLOCK_KEY4 must be readable, stop this operation!",
253                  ret_code=2,
254              )
255              self.espefuse_py("read_protect_efuse BLOCK_KEY5")
256      @pytest.mark.skipif(
257          arg_chip != "esp32",
258          reason="system parameters efuse read-protection is supported only by esp32, "
259          "other chips protect whole blocks",
260      )
261      def test_burn_and_read_protect_efuse(self):
262          self.espefuse_py(
263              "burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8",
264              check_msg="Efuse FLASH_CRYPT_CONFIG is read-protected. "
265              "Read back the burn value is not possible.",
266          )
267  class TestWriteProtectionCommands(EfuseTestCase):
268      def test_write_protect_efuse(self):
269          self.espefuse_py("write_protect_efuse -h")
270          if arg_chip == "esp32":
271              efuse_lists = 
272              efuse_lists2 = "WR_DIS RD_DIS"
273          elif arg_chip == "esp32c2":
274              efuse_lists = 
275              efuse_lists2 = "RD_DIS DIS_DOWNLOAD_ICACHE"
276          else:
277              efuse_lists = 
278              if arg_chip not in ["esp32h2", "esp32h2beta1"] and arg_chip not in [
279                  "esp32c6"
280              ]:
281                  efuse_lists += 
282              efuse_lists2 = "RD_DIS DIS_ICACHE"
283          self.espefuse_py(f"write_protect_efuse {efuse_lists}")
284          output = self.espefuse_py(f"write_protect_efuse {efuse_lists2}")
285          assert output.count("is already write protected") == 2
286      def test_write_protect_efuse2(self):
287          if arg_chip == "esp32":
288              self.espefuse_py("write_protect_efuse WR_DIS")
289              self.espefuse_py(
290                  "write_protect_efuse CODING_SCHEME",
291                  check_msg="A fatal error occurred: This efuse cannot be write-disabled "
292                  "due to the WR_DIS field is already write-disabled",
293                  ret_code=2,
294              )
295  class TestBurnCustomMacCommands(EfuseTestCase):
296      def test_burn_custom_mac(self):
297          self.espefuse_py("burn_custom_mac -h")
298          cmd = "burn_custom_mac AA:CD:EF:11:22:33"
299          if arg_chip == "esp32":
300              self.espefuse_py(
301                  cmd,
302                  check_msg="Custom MAC Address version 1: "
303                  "aa:cd:ef:11:22:33 (CRC 0x63 OK)",
304              )
305          else:
306              mac_custom = (
307                  "aa:cd:ef:11:22:33:00:00"
308                  if arg_chip in ["esp32h2", "esp32h2beta1"]
309                  else "aa:cd:ef:11:22:33"
310              )
311              self.espefuse_py(cmd, check_msg=f"Custom MAC Address: {mac_custom} (OK)")
312      def test_burn_custom_mac2(self):
313          self.espefuse_py(
314              "burn_custom_mac AA:CD:EF:11:22:33:44",
315              check_msg="A fatal error occurred: MAC Address needs to be a 6-byte "
316              "hexadecimal format separated by colons (:)!",
317              ret_code=2,
318          )
319      def test_burn_custom_mac3(self):
320          self.espefuse_py(
321              "burn_custom_mac AB:CD:EF:11:22:33",
322              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
323              ret_code=2,
324          )
325      @pytest.mark.skipif(
326          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
327      )
328      def test_burn_custom_mac_with_34_coding_scheme(self):
329          self._set_34_coding_scheme()
330          self.espefuse_py("burn_custom_mac -h")
331          self.espefuse_py(
332              "burn_custom_mac AA:CD:EF:01:02:03",
333              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
334          )
335          self.espefuse_py(
336              "get_custom_mac",
337              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
338          )
339          self.espefuse_py(
340              "burn_custom_mac FE:22:33:44:55:66",
341              check_msg="New value contains some bits that cannot be cleared "
342              "(value will be 0x675745ffeffe)",
343              ret_code=2,
344          )
345  @pytest.mark.skipif(
346      arg_chip in ["esp32c2", "esp32h2beta1", "esp32c3", "esp32c6", "esp32h2"],
347      reason=f"TODO: add support set_flash_voltage for {arg_chip}",
348  )
349  class TestSetFlashVoltageCommands(EfuseTestCase):
350      def test_set_flash_voltage_1_8v(self):
351          self.espefuse_py("set_flash_voltage -h")
352          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
353          self.espefuse_py(
354              "set_flash_voltage 1.8V",
355              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
356          )
357          if arg_chip == "esp32":
358              error_msg = "A fatal error occurred: "
359              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
360          else:
361              error_msg = "A fatal error occurred: "
362              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
363          self.espefuse_py(
364              "set_flash_voltage 3.3V",
365              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
366          )
367          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
368      def test_set_flash_voltage_3_3v(self):
369          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
370          self.espefuse_py(
371              "set_flash_voltage 3.3V",
372              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
373          )
374          if arg_chip == "esp32":
375              error_msg = "A fatal error occurred: "
376              "Can't set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned"
377          else:
378              error_msg = "A fatal error occurred: "
379              "Can't set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned"
380          self.espefuse_py("set_flash_voltage 1.8V", check_msg=error_msg, ret_code=2)
381          if arg_chip == "esp32":
382              error_msg = "A fatal error occurred: "
383              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
384          else:
385              error_msg = "A fatal error occurred: "
386              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
387          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
388      def test_set_flash_voltage_off(self):
389          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
390          self.espefuse_py(
391              "set_flash_voltage OFF",
392              check_msg=f"Disable internal flash voltage regulator ({vdd})",
393          )
394          self.espefuse_py(
395              "set_flash_voltage 3.3V",
396              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
397          )
398      def test_set_flash_voltage_off2(self):
399          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
400          self.espefuse_py(
401              "set_flash_voltage OFF",
402              check_msg=f"Disable internal flash voltage regulator ({vdd})",
403          )
404          self.espefuse_py(
405              "set_flash_voltage 1.8V",
406              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
407          )
408  @pytest.mark.skipif(arg_chip != "esp32c3", reason="Not necessary fo all chips")
409  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
410      def test_efuse_is_bool_given_none(self):
411          self.espefuse_py("burn_efuse SECURE_BOOT_KEY_REVOKE0")
412      def test_efuse_is_bool_given_0(self):
413          self.espefuse_py(
414              "burn_efuse SECURE_BOOT_KEY_REVOKE0 0",
415              check_msg="A fatal error occurred: "
416              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
417              "(will always burn 0->1), given value=0",
418              ret_code=2,
419          )
420      def test_efuse_is_bool_given_2(self):
421          self.espefuse_py(
422              "burn_efuse SECURE_BOOT_KEY_REVOKE0 2",
423              check_msg="A fatal error occurred: "
424              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
425              "(will always burn 0->1), given value=2",
426              ret_code=2,
427          )
428      def test_efuse_is_bytes_ok(self):
429          self.espefuse_py(
430              "burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678"
431          )
432      def test_efuse_is_bytes_given_short_val(self):
433          self.espefuse_py(
434              "burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678",
435              check_msg="A fatal error occurred: "
436              "The length of efuse 'OPTIONAL_UNIQUE_ID' (128 bits) "
437              "(given len of the new value= 64 bits)",
438              ret_code=2,
439          )
440      def test_efuse_is_bytes_given_none(self):
441          self.espefuse_py(
442              "burn_efuse OPTIONAL_UNIQUE_ID",
443              check_msg="A fatal error occurred: "
444              "New value required for efuse 'OPTIONAL_UNIQUE_ID' (given None)",
445              ret_code=2,
446          )
447      def test_efuse_is_int_ok(self):
448          self.espefuse_py("burn_efuse SPI_PAD_CONFIG_D 7")
449      def test_efuse_is_int_given_out_of_range_val(self):
450          self.espefuse_py(
451              "burn_efuse SPI_PAD_CONFIG_D 200",
452              check_msg="A fatal error occurred: "
453              "200 is too large an unsigned integer for a bitstring "
454              "of length 6. The allowed range is [0, 63].",
455              ret_code=2,
456          )
457      def test_efuse_is_int_given_none(self):
458          self.espefuse_py(
459              "burn_efuse SPI_PAD_CONFIG_D",
460              check_msg="A fatal error occurred: "
461              "New value required for efuse 'SPI_PAD_CONFIG_D' (given None)",
462              ret_code=2,
463          )
464      def test_efuse_is_int_given_0(self):
465          self.espefuse_py(
466              "burn_efuse SPI_PAD_CONFIG_D 0",
467              check_msg="A fatal error occurred: "
468              "New value should not be 0 for 'SPI_PAD_CONFIG_D' "
469              "(given value= 0)",
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_out_of_range_val(self):
473          self.espefuse_py(
474              "burn_efuse SPI_BOOT_CRYPT_CNT 9",
475              check_msg="A fatal error occurred: "
476              "9 is too large an unsigned integer for a bitstring "
477              "of length 3. The allowed range is [0, 7].",
478              ret_code=2,
479          )
480      def test_efuse_is_bitcount_given_increase_over_max(self):
481          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
482          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
483          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
484          self.espefuse_py(
485              "burn_efuse SPI_BOOT_CRYPT_CNT",
486              check_msg="A fatal error occurred: "
487              "15 is too large an unsigned integer for a bitstring "
488              "of length 3. The allowed range is [0, 7].",
489              ret_code=2,
490          )
491  class TestBurnEfuseCommands(EfuseTestCase):
492      @pytest.mark.skipif(
493          arg_chip != "esp32",
494          reason="IO pins 30 & 31 cannot be set for SPI flash only on esp32",
495      )
496      def test_set_spi_flash_pin_efuses(self):
497          self.espefuse_py(
498              "burn_efuse SPI_PAD_CONFIG_HD 30",
499              check_msg="A fatal error occurred: "
500              "IO pins 30 & 31 cannot be set for SPI flash. 0-29, 32 & 33 only.",
501              ret_code=2,
502          )
503          self.espefuse_py(
504              "burn_efuse SPI_PAD_CONFIG_Q 0x23",
505              check_msg="A fatal error occurred: "
506              "IO pin 35 cannot be set for SPI flash. 0-29, 32 & 33 only.",
507              ret_code=2,
508          )
509          output = self.espefuse_py("burn_efuse SPI_PAD_CONFIG_CS0 33")
510          assert "(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -> 0b11111" in output
511          assert "BURN BLOCK0  - OK (all write block bits are set)" in output
512      def test_burn_mac_custom_efuse(self):
513          crc_msg = "(OK)"
514          self.espefuse_py("burn_efuse -h")
515          if arg_chip == "esp32":
516              self.espefuse_py(
517                  "burn_efuse MAC AA:CD:EF:01:02:03",
518                  check_msg="Writing Factory MAC address is not supported",
519                  ret_code=2,
520              )
521              self.espefuse_py("burn_efuse MAC_VERSION 1")
522              crc_msg = "(CRC 0x56 OK)"
523          if arg_chip == "esp32c2":
524              self.espefuse_py("burn_efuse CUSTOM_MAC_USED 1")
525          self.espefuse_py("burn_efuse -h")
526          self.espefuse_py(
527              "burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03",
528              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
529              ret_code=2,
530          )
531          self.espefuse_py("burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03")
532          if arg_chip in ["esp32h2", "esp32h2beta1"]:
533              self.espefuse_py(
534                  "get_custom_mac", check_msg=f"aa:cd:ef:01:02:03:00:00 {crc_msg}"
535              )
536          else:
537              self.espefuse_py("get_custom_mac", check_msg=f"aa:cd:ef:01:02:03 {crc_msg}")
538      def test_burn_efuse(self):
539          self.espefuse_py("burn_efuse -h")
540          if arg_chip == "esp32":
541              self.espefuse_py(
542                  "burn_efuse \
543                  CHIP_VER_REV2 1 \
544                  DISABLE_DL_ENCRYPT 1 \
545                  CONSOLE_DEBUG_DISABLE 1"
546              )
547              blk1 = "BLOCK1"
548              blk2 = "BLOCK2"
549          elif arg_chip == "esp32c2":
550              self.espefuse_py(
551                  "burn_efuse \
552                  XTS_KEY_LENGTH_256 1 \
553                  UART_PRINT_CONTROL 1 \
554                  FORCE_SEND_RESUME 1"
555              )
556              blk1 = "BLOCK_KEY0"
557              blk2 = None
558          else:
559              self.espefuse_py(
560                  "burn_efuse \
561                  SECURE_BOOT_EN 1 \
562                  UART_PRINT_CONTROL 1"
563              )
564              self.espefuse_py(
565                  "burn_efuse \
566                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168",
567                  check_msg="-> 0x2328ad5ac9145f698f843a26d6eae168",
568              )
569              output = self.espefuse_py("summary -d")
570              assert (
571                  "read_regs: d6eae168 8f843a26 c9145f69 2328ad5a "
572                  "00000000 00000000 00000000 00000000"
573              ) in output
574              assert "= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W" in output
575              efuse_from_blk2 = "BLK_VERSION_MAJOR"
576              if arg_chip == "esp32s2":
577                  efuse_from_blk2 = "BLK_VERSION_MINOR"
578              if arg_chip != "esp32c6":
579                  self.espefuse_py(
580                      f"burn_efuse {efuse_from_blk2} 1",
581                      check_msg="Burn into BLOCK_SYS_DATA is forbidden "
582                      "(RS coding scheme does not allow this).",
583                      ret_code=2,
584                  )
585              blk1 = "BLOCK_KEY1"
586              blk2 = "BLOCK_KEY2"
587          output = self.espefuse_py(
588              f"burn_efuse {blk1}"
589              + " 0x00010203040506070809111111111111111111111111111111110000112233FF"
590          )
591          assert (
592              "-> 0x00010203040506070809111111111111111111111111111111110000112233ff"
593              in output
594          )
595          output = self.espefuse_py("summary -d")
596          assert (
597              "read_regs: 112233ff 11110000 11111111 11111111 "
598              "11111111 08091111 04050607 00010203"
599          ) in output
600          assert (
601              "= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 "
602              "11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W"
603          ) in output
604          if blk2 is not None:
605              output = self.espefuse_py(
606                  f"burn_efuse {blk2}"
607                  + " 00010203040506070809111111111111111111111111111111110000112233FF"
608              )
609              assert (
610                  "-> 0xff33221100001111111111111111111111111111111109080706050403020100"
611                  in output
612              )
613              output = self.espefuse_py("summary -d")
614              assert (
615                  "read_regs: 03020100 07060504 11110908 11111111 "
616                  "11111111 11111111 00001111 ff332211"
617              ) in output
618              assert (
619                  "= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 "
620                  "11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W"
621              ) in output
622      @pytest.mark.skipif(
623          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
624      )
625      def test_burn_efuse_with_34_coding_scheme(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
628          self.espefuse_py("burn_efuse ADC1_TP_LOW 50")
629          self.espefuse_py(
630              "burn_efuse ADC1_TP_HIGH 55",
631              check_msg="Burn into BLOCK3 is forbidden "
632              "(3/4 coding scheme does not allow this)",
633              ret_code=2,
634          )
635      @pytest.mark.skipif(
636          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
637      )
638      def test_burn_efuse_with_34_coding_scheme2(self):
639          self._set_34_coding_scheme()
640          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
641          self.espefuse_py(
642              "burn_efuse \
643              ADC1_TP_LOW 50 \
644              ADC1_TP_HIGH 55 \
645              ADC2_TP_LOW 40 \
646              ADC2_TP_HIGH 45"
647          )
648  class TestBurnKeyCommands(EfuseTestCase):
649      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
650      def test_burn_key_3_key_blocks(self):
651          self.espefuse_py("burn_key -h")
652          self.espefuse_py(
653              f"burn_key BLOCK1 {IMAGES_DIR}/192bit",
654              check_msg="A fatal error occurred: Incorrect key file size 24. "
655              "Key file must be 32 bytes (256 bits) of raw binary key data.",
656              ret_code=2,
657          )
658          self.espefuse_py(
659              f"burn_key \
660              BLOCK1 {IMAGES_DIR}/256bit \
661              BLOCK2 {IMAGES_DIR}/256bit_1 \
662              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key"
663          )
664          output = self.espefuse_py("summary -d")
665          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
666          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
667          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
668          self.espefuse_py(
669              f"burn_key \
670              BLOCK1 {IMAGES_DIR}/256bit \
671              BLOCK2 {IMAGES_DIR}/256bit_1 \
672              BLOCK3 {IMAGES_DIR}/256bit_2"
673          )
674          output = self.espefuse_py("summary -d")
675          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
676          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
677          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
678      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
679      def test_burn_key_1_key_block(self):
680          self.espefuse_py("burn_key -h")
681          self.espefuse_py(
682              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY",
683              check_msg="A fatal error occurred: Incorrect key file size 16. "
684              "Key file must be 32 bytes (256 bits) of raw binary key data.",
685              ret_code=2,
686          )
687          self.espefuse_py(
688              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect"
689          )
690          output = self.espefuse_py("summary -d")
691          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
692          self.espefuse_py(f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY")
693          output = self.espefuse_py("summary -d")
694          assert (
695              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
696              "00000000 00000000 00000000 00000000"
697          ) in output
698          assert (
699              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
700              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
701          ) in output
702      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
703      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
704          self.espefuse_py("burn_key -h")
705          self.espefuse_py(
706              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
707              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST",
708              check_msg="A fatal error occurred: These keypurposes are incompatible "
709              "['XTS_AES_128_KEY', 'SECURE_BOOT_DIGEST']",
710              ret_code=2,
711          )
712          self.espefuse_py(
713              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
714              f"XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
715              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect"
716          )
717          output = self.espefuse_py("summary -d")
718          assert (
719              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
720              "03020100 07060504 0b0a0908 0f0e0d0c"
721          ) in output
722          self.espefuse_py(
723              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
724              "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
725              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
726          )
727          output = self.espefuse_py("summary -d")
728          assert (
729              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
730              "03020100 07060504 0b0a0908 0f0e0d0c"
731          ) in output
732          assert (
733              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
734              "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-"
735          ) in output
736          assert "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
737          assert "= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-" in output
738      @pytest.mark.skipif(
739          arg_chip
740          not in [
741              "esp32s2",
742              "esp32s3",
743              "esp32s3beta1",
744              "esp32c3",
745              "esp32h2beta1",
746              "esp32c6",
747              "esp32h2",
748          ],
749          reason="Only chips with 6 keys",
750      )
751      def test_burn_key_with_6_keys(self):
752          cmd = f"burn_key \
753                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
754                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
755                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY"
756          if arg_chip in ["esp32c3", "esp32c6"] or arg_chip in [
757              "esp32h2",
758              "esp32h2beta1",
759          ]:
760              cmd = cmd.replace("XTS_AES_256_KEY_1", "XTS_AES_128_KEY")
761              cmd = cmd.replace("XTS_AES_256_KEY_2", "XTS_AES_128_KEY")
762          self.espefuse_py(cmd + " --no-read-protect --no-write-protect")
763          output = self.espefuse_py("summary -d")
764          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
765          self.check_data_block_in_log(
766              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
767          )
768          self.check_data_block_in_log(
769              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
770          )
771          self.espefuse_py(cmd)
772          output = self.espefuse_py("summary -d")
773          assert (
774              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
775              "00000000 00000000 00000000 00000000"
776          ) in output
777          assert (
778              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
779              "00000000 00000000 00000000 00000000"
780          ) in output
781          assert (
782              "[6 ] read_regs: 00000000 00000000 00000000 00000000 "
783              "00000000 00000000 00000000 00000000"
784          ) in output
785          self.espefuse_py(
786              f"burn_key \
787              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
788              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
789              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2"
790          )
791          output = self.espefuse_py("summary -d")
792          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
793          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
794          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
795      @pytest.mark.skipif(
796          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
797      )
798      def test_burn_key_with_34_coding_scheme(self):
799          self._set_34_coding_scheme()
800          self.espefuse_py(
801              f"burn_key BLOCK1 {IMAGES_DIR}/256bit",
802              check_msg="A fatal error occurred: Incorrect key file size 32. "
803              "Key file must be 24 bytes (192 bits) of raw binary key data.",
804              ret_code=2,
805          )
806          self.espefuse_py(
807              f"burn_key \
808              BLOCK1 {IMAGES_DIR}/192bit \
809              BLOCK2 {IMAGES_DIR}/192bit_1 \
810              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key"
811          )
812          output = self.espefuse_py("summary -d")
813          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
814          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
815          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
816          self.espefuse_py(
817              f"burn_key \
818              BLOCK1 {IMAGES_DIR}/192bit \
819              BLOCK2 {IMAGES_DIR}/192bit_1 \
820              BLOCK3 {IMAGES_DIR}/192bit_2"
821          )
822          output = self.espefuse_py("summary -d")
823          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
824          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
825          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
826      @pytest.mark.skipif(
827          arg_chip not in ["esp32s2", "esp32s3"],
828          reason="512 bit keys are only supported on ESP32-S2 and S3",
829      )
830      def test_burn_key_512bit(self):
831          self.espefuse_py(
832              f"burn_key \
833              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
834              XTS_AES_256_KEY --no-read-protect --no-write-protect"
835          )
836          output = self.espefuse_py("summary -d")
837          self.check_data_block_in_log(
838              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
839          )
840          self.check_data_block_in_log(
841              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
842          )
843      @pytest.mark.skipif(
844          arg_chip not in ["esp32s2", "esp32s3"],
845          reason="512 bit keys are only supported on ESP32-S2 and S3",
846      )
847      def test_burn_key_512bit_non_consecutive_blocks(self):
848          self.espefuse_py(
849              f"burn_key \
850              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY"
851          )
852          self.espefuse_py(
853              f"burn_key \
854              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0"
855          )
856          self.espefuse_py(
857              f"burn_key \
858              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
859              XTS_AES_256_KEY --no-read-protect --no-write-protect"
860          )
861          self.espefuse_py(
862              f"burn_key \
863              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect"
864          )
865          output = self.espefuse_py("summary -d")
866          self.check_data_block_in_log(
867              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
868          )
869          self.check_data_block_in_log(
870              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
871          )
872          assert (
873              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 "
874              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
875          ) in output
876          assert (
877              "[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 "
878              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
879          ) in output
880      @pytest.mark.skipif(
881          arg_chip not in ["esp32s2", "esp32s3"],
882          reason="512 bit keys are only supported on ESP32-S2 and S3",
883      )
884      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
885          self.espefuse_py(
886              f"burn_key \
887              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
888              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
889              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
890              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
891              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
892              XTS_AES_256_KEY --no-read-protect --no-write-protect"
893          )
894          output = self.espefuse_py("summary -d")
895          self.check_data_block_in_log(
896              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
897          )
898          self.check_data_block_in_log(
899              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
900          )
901          assert (
902              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 "
903              "acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
904          ) in output
905          assert (
906              "[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 "
907              "acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
908          ) in output
909      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
910      def test_burn_key_ecdsa_key(self):
911          self.espefuse_py(
912              f"burn_key \
913              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
914              ECDSA_KEY \
915              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
916              ECDSA_KEY"
917          )
918          output = self.espefuse_py("summary -d")
919          assert 2 == output.count(
920              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
921              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
922          )
923          assert (
924              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
925              "00000000 00000000 00000000 00000000"
926          ) in output
927          assert (
928              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
929              "00000000 00000000 00000000 00000000"
930          ) in output
931      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
932      def test_burn_key_ecdsa_key_check_byte_order(self):
933          self.espefuse_py(
934              f"burn_key \
935              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
936              ECDSA_KEY \
937              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
938              ECDSA_KEY \
939              --no-read-protect"
940          )
941          output = self.espefuse_py("summary -d")
942          assert (
943              "= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 "
944              "cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-"
945          ) in output
946          assert (
947              "= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b "
948              "38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-"
949          ) in output
950          assert (
951              "[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 "
952              "238123cb 4f71b795 00000000 00000000"
953          ) in output
954          assert (
955              "[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed "
956              "8450c238 c39d087a 90066a66 b4548b23"
957          ) in output
958  class TestBurnBlockDataCommands(EfuseTestCase):
959      def test_burn_block_data_check_args(self):
960          self.espefuse_py("burn_block_data -h")
961          blk0 = "BLOCK0"
962          blk1 = "BLOCK1"
963          self.espefuse_py(
964              f"burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}",
965              check_msg="A fatal error occurred: "
966              "The number of block_name (2) and datafile (1) should be the same.",
967              ret_code=2,
968          )
969      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
970      def test_burn_block_data_with_3_key_blocks(self):
971          self.espefuse_py(
972              f"burn_block_data \
973              BLOCK0 {IMAGES_DIR}/224bit \
974              BLOCK3 {IMAGES_DIR}/256bit"
975          )
976          output = self.espefuse_py("summary -d")
977          assert (
978              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
979              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
980          ) in output
981          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
982          self.espefuse_py(
983              f"burn_block_data \
984              BLOCK2 {IMAGES_DIR}/256bit_1"
985          )
986          self.check_data_block_in_log(
987              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
988          )
989          self.espefuse_py(
990              f"burn_block_data \
991              BLOCK1 {IMAGES_DIR}/256bit_2"
992          )
993          self.check_data_block_in_log(
994              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_2"
995          )
996      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
997      def test_burn_block_data_with_1_key_block(self):
998          self.espefuse_py(
999              f"burn_block_data \
1000              BLOCK0 {IMAGES_DIR}/64bit \
1001              BLOCK1 {IMAGES_DIR}/96bit \
1002              BLOCK2 {IMAGES_DIR}/256bit \
1003              BLOCK3 {IMAGES_DIR}/256bit"
1004          )
1005          output = self.espefuse_py("summary -d")
1006          assert "[0 ] read_regs: 00000001 0000000c" in output
1007          assert "[1 ] read_regs: 03020100 07060504 000a0908" in output
1008          assert (
1009              "[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1010              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1011          ) in output
1012          assert (
1013              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1014              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1015          ) in output
1016      @pytest.mark.skipif(
1017          arg_chip
1018          not in [
1019              "esp32s2",
1020              "esp32s3",
1021              "esp32s3beta1",
1022              "esp32c3",
1023              "esp32h2beta1",
1024              "esp32c6",
1025              "esp32h2",
1026          ],
1027          reason="Only chip with 6 keys",
1028      )
1029      def test_burn_block_data_with_6_keys(self):
1030          self.espefuse_py(
1031              f"burn_block_data \
1032              BLOCK0 {IMAGES_DIR}/192bit \
1033              BLOCK3 {IMAGES_DIR}/256bit"
1034          )
1035          output = self.espefuse_py("summary -d")
1036          assert (
1037              "[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1038              in output
1039          )
1040          assert (
1041              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1042              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1043          ) in output
1044          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1045          self.espefuse_py(
1046              f"burn_block_data \
1047              BLOCK10 {IMAGES_DIR}/256bit_1"
1048          )
1049          self.check_data_block_in_log(
1050              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
1051          )
1052          self.espefuse_py(
1053              f"burn_block_data \
1054              BLOCK1 {IMAGES_DIR}/192bit \
1055              BLOCK5 {IMAGES_DIR}/256bit_1 \
1056              BLOCK6 {IMAGES_DIR}/256bit_2"
1057          )
1058          output = self.espefuse_py("summary -d")
1059          assert (
1060              "[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1061              in output
1062          )
1063          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1064          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1", 2)
1065          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
1066      def test_burn_block_data_check_errors(self):
1067          self.espefuse_py(
1068              f"burn_block_data \
1069              BLOCK2 {IMAGES_DIR}/192bit \
1070              BLOCK2 {IMAGES_DIR}/192bit_1",
1071              check_msg="A fatal error occurred: Found repeated",
1072              ret_code=2,
1073          )
1074          self.espefuse_py(
1075              f"burn_block_data \
1076              BLOCK2 {IMAGES_DIR}/192bit \
1077              BLOCK3 {IMAGES_DIR}/192bit_1 \
1078              --offset 4",
1079              check_msg="A fatal error occurred: "
1080              "The 'offset' option is not applicable when a few blocks are passed.",
1081              ret_code=2,
1082          )
1083          self.espefuse_py(
1084              f"burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33",
1085              check_msg="A fatal error occurred: Invalid offset: the block0 only holds",
1086              ret_code=2,
1087          )
1088          self.espefuse_py(
1089              f"burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4",
1090              check_msg="A fatal error occurred: Data does not fit:",
1091              ret_code=2,
1092          )
1093      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1094      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1095          offset = 1
1096          self.espefuse_py(
1097              f"burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit"
1098          )
1099          offset = 4
1100          self.espefuse_py(
1101              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1"
1102          )
1103          self.check_data_block_in_log(
1104              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1105          )
1106          offset = 6
1107          self.espefuse_py(
1108              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2"
1109          )
1110          self.check_data_block_in_log(
1111              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1112          )
1113          offset = 8
1114          self.espefuse_py(
1115              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1116          )
1117          self.check_data_block_in_log(
1118              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1119          )
1120      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1121      def test_burn_block_data_with_offset_1_key_block(self):
1122          offset = 4
1123          self.espefuse_py(f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit")
1124          output = self.espefuse_py("summary -d")
1125          assert "[1 ] read_regs: 00000000 03020100 00060504" in output
1126          offset = 6
1127          self.espefuse_py(
1128              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1"
1129          )
1130          output = self.espefuse_py("summary -d")
1131          assert (
1132              "[2 ] read_regs: 00000000 00110000 05000000 09080706 "
1133              "0d0c0b0a 11100f0e 15141312 00002116"
1134          ) in output
1135          offset = 8
1136          self.espefuse_py(
1137              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1138          )
1139          self.check_data_block_in_log(
1140              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1141          )
1142      @pytest.mark.skipif(
1143          arg_chip
1144          not in [
1145              "esp32s2",
1146              "esp32s3",
1147              "esp32s3beta1",
1148              "esp32c3",
1149              "esp32h2beta1",
1150              "esp32c6",
1151              "esp32h2",
1152          ],
1153          reason="Only chips with 6 keys",
1154      )
1155      def test_burn_block_data_with_offset_6_keys(self):
1156          offset = 4
1157          self.espefuse_py(
1158              f"burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1"
1159          )
1160          self.check_data_block_in_log(
1161              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1162          )
1163          offset = 6
1164          self.espefuse_py(
1165              f"burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2"
1166          )
1167          self.check_data_block_in_log(
1168              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1169          )
1170          offset = 8
1171          self.espefuse_py(
1172              f"burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2"
1173          )
1174          self.check_data_block_in_log(
1175              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1176          )
1177      @pytest.mark.skipif(
1178          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1179      )
1180      def test_burn_block_data_with_34_coding_scheme(self):
1181          self._set_34_coding_scheme()
1182          self.espefuse_py(
1183              f"burn_block_data BLOCK1 {IMAGES_DIR}/256bit",
1184              check_msg="A fatal error occurred: Data does not fit: "
1185              "the block1 size is 24 bytes, data file is 32 bytes, offset 0",
1186              ret_code=2,
1187          )
1188          self.espefuse_py(
1189              f"burn_block_data \
1190              BLOCK1 {IMAGES_DIR}/192bit \
1191              BLOCK2 {IMAGES_DIR}/192bit_1 \
1192              BLOCK3 {IMAGES_DIR}/192bit_2"
1193          )
1194          output = self.espefuse_py("summary -d")
1195          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
1196          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
1197          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
1198      @pytest.mark.skipif(
1199          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1200      )
1201      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1202          self._set_34_coding_scheme()
1203          offset = 4
1204          self.espefuse_py(
1205              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit"
1206          )
1207          self.check_data_block_in_log(
1208              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1209          )
1210          offset = 6
1211          self.espefuse_py(
1212              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit"
1213          )
1214          self.check_data_block_in_log(
1215              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1216          )
1217          offset = 8
1218          self.espefuse_py(
1219              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit"
1220          )
1221          self.check_data_block_in_log(
1222              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1223          )
1224  @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only, supports 2 key blocks")
1225  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1226      def test_burn_key_digest(self):
1227          self.espefuse_py("burn_key_digest -h")
1228          esp = self.get_esptool()
1229          if esp.get_chip_revision() >= 300:
1230              self.espefuse_py(
1231                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1232              )
1233              output = self.espefuse_py("summary -d")
1234              assert (
1235                  " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1236                  "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1237              ) in output
1238          else:
1239              self.espefuse_py(
1240                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1241                  check_msg="Incorrect chip revision for Secure boot v2.",
1242                  ret_code=2,
1243              )
1244      def test_burn_key_from_digest(self):
1245          self.espefuse_py(
1246              f"burn_key \
1247              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key"
1248          )
1249          output = self.espefuse_py("summary -d")
1250          assert 1 == output.count(
1251              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1252              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W"
1253          )
1254      def test_burn_key_digest_with_34_coding_scheme(self):
1255          self._set_34_coding_scheme()
1256          self.espefuse_py(
1257              f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1258              check_msg="burn_key_digest only works with 'None' coding scheme",
1259              ret_code=2,
1260          )
1261  @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only, supports 1 key block")
1262  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1263      def test_burn_key_digest1(self):
1264          self.espefuse_py("burn_key_digest -h")
1265          self.espefuse_py(
1266              f"burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem"
1267          )
1268          output = self.espefuse_py("summary -d")
1269          assert " = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-" in output
1270          assert (
1271              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1272              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1273          ) in output
1274      def test_burn_key_digest2(self):
1275          self.espefuse_py("burn_key_digest -h")
1276          self.espefuse_py(
1277              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem"
1278          )
1279          output = self.espefuse_py("summary -d")
1280          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1281          assert (
1282              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1283              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1284          ) in output
1285      def test_burn_key_from_digest1(self):
1286          self.espefuse_py(
1287              "burn_key BLOCK_KEY0 "
1288              f"{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1289          )
1290          output = self.espefuse_py("summary -d")
1291          assert (
1292              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1293              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1294          ) in output
1295      def test_burn_key_from_digest2(self):
1296          self.espefuse_py(
1297              "burn_key BLOCK_KEY0 "
1298              f"{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1299          )
1300          output = self.espefuse_py("summary -d")
1301          assert (
1302              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1303              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1304          ) in output
1305  @pytest.mark.skipif(
1306      arg_chip
1307      not in [
1308          "esp32s2",
1309          "esp32s3",
1310          "esp32s3beta1",
1311          "esp32c3",
1312          "esp32h2beta1",
1313          "esp32c6",
1314          "esp32h2",
1315      ],
1316      reason="Supports 6 key blocks",
1317  )
1318  class TestBurnKeyDigestCommands(EfuseTestCase):
1319      def test_burn_key_digest(self):
1320          self.espefuse_py("burn_key_digest -h")
1321          self.espefuse_py(
1322              f"burn_key_digest \
1323              BLOCK_KEY0 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1325              BLOCK_KEY1 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1327              BLOCK_KEY2 ",
1328              check_msg="A fatal error occurred: The number of blocks (3), "
1329              "datafile (2) and keypurpose (2) should be the same.",
1330              ret_code=2,
1331          )
1332          self.espefuse_py(
1333              f"burn_key_digest \
1334              BLOCK_KEY0 \
1335              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1336              BLOCK_KEY1 \
1337              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1338              BLOCK_KEY2 \
1339              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2"
1340          )
1341          output = self.espefuse_py("summary -d")
1342          assert 1 == output.count(
1343              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1344              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1345          )
1346          assert 2 == output.count(
1347              " = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 "
1348              "6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-"
1349          )
1350      def test_burn_key_from_digest(self):
1351          self.espefuse_py(
1352              f"burn_key \
1353              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1354          )
1355          output = self.espefuse_py("summary -d")
1356          assert 1 == output.count(
1357              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1358              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1359          )
1360          self.espefuse_py(
1361              f"burn_key_digest \
1362              BLOCK_KEY1 \
1363              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1"
1364          )
1365          output = self.espefuse_py("summary -d")
1366          assert 2 == output.count(
1367              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1368              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1369          )
1370  class TestBurnBitCommands(EfuseTestCase):
1371      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1372      def test_burn_bit_for_chips_with_3_key_blocks(self):
1373          self.espefuse_py("burn_bit -h")
1374          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1375          self.espefuse_py(
1376              "summary",
1377              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 "
1378              "00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1379          )
1380          self.espefuse_py(
1381              "burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254"
1382          )
1383          self.espefuse_py(
1384              "summary",
1385              check_msg="ff ff 01 80 01 00 00 80 01 00 00 80 01 "
1386              "00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0",
1387          )
1388      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1389      def test_burn_bit_for_chips_with_1_key_block(self):
1390          self.espefuse_py("burn_bit -h")
1391          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1392          self.espefuse_py(
1393              "summary",
1394              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1395              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1396          )
1397          self.espefuse_py(
1398              "burn_bit BLOCK3 100",
1399              check_msg="Burn into BLOCK_KEY0 is forbidden "
1400              "(RS coding scheme does not allow this)",
1401              ret_code=2,
1402          )
1403          self.espefuse_py("burn_bit BLOCK0 0 1 2")
1404          self.espefuse_py("summary", check_msg="[0 ] read_regs: 00000007 00000000")
1405      @pytest.mark.skipif(
1406          arg_chip
1407          not in [
1408              "esp32s2",
1409              "esp32s3",
1410              "esp32s3beta1",
1411              "esp32c3",
1412              "esp32h2beta1",
1413              "esp32c6",
1414              "esp32h2",
1415          ],
1416          reason="Only chip with 6 keys",
1417      )
1418      def test_burn_bit_for_chips_with_6_key_blocks(self):
1419          self.espefuse_py("burn_bit -h")
1420          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1421          self.espefuse_py(
1422              "summary",
1423              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1424              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1425          )
1426          self.espefuse_py(
1427              "burn_bit BLOCK3 100",
1428              check_msg="Burn into BLOCK_USR_DATA is forbidden "
1429              "(RS coding scheme does not allow this)",
<span onclick='openModal()' class='match'>1430              ret_code=2,
1431          )
1432          self.espefuse_py("burn_bit BLOCK0 13")
1433          self.espefuse_py(
1434              "summary",
1435              check_msg="[0 ] read_regs: 00002000 00000000 00000000 "
1436              "00000000 00000000 00000000",
1437          )
1438          self.espefuse_py("burn_bit BLOCK0 24")
1439          self.espefuse_py(
</span>1440              "summary",
1441              check_msg="[0 ] read_regs: 01002000 00000000 00000000 "
1442              "00000000 00000000 00000000",
1443          )
1444      @pytest.mark.skipif(
1445          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1446      )
1447      def test_burn_bit_with_34_coding_scheme(self):
1448          self._set_34_coding_scheme()
1449          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191")
1450          self.espefuse_py(
1451              "summary",
1452              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1453              "00 00 01 00 00 00 01 00 00 80",
1454          )
1455          self.espefuse_py(
1456              "burn_bit BLOCK3 17",
1457              check_msg="Burn into BLOCK3 is forbidden "
1458              "(3/4 coding scheme does not allow this).",
1459              ret_code=2,
1460          )
1461  @pytest.mark.skipif(
1462      arg_chip != "esp32", reason="Tests are only for esp32. (TODO: add for all chips)"
1463  )
1464  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1465      def test_1_secure_boot_v1(self):
1466          if arg_chip == "esp32":
1467              self.espefuse_py(
1468                  f"burn_key \
1469                  flash_encryption {IMAGES_DIR}/256bit \
1470                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key"
1471              )
1472              output = self.espefuse_py("summary -d")
1473              self.check_data_block_in_log(
1474                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1475              )
1476              self.check_data_block_in_log(
1477                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
1478              )
1479              self.espefuse_py(
1480                  f"burn_key \
1481                  flash_encryption  {IMAGES_DIR}/256bit \
1482                  secure_boot_v1    {IMAGES_DIR}/256bit_1"
1483              )
1484              output = self.espefuse_py("summary -d")
1485              assert (
1486                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1487                  "00000000 00000000 00000000 00000000"
1488              ) in output
1489              assert (
1490                  "[2 ] read_regs: 00000000 00000000 00000000 00000000 "
1491                  "00000000 00000000 00000000 00000000"
1492              ) in output
1493              assert (
1494                  "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1495                  "00000000 00000000 00000000 00000000"
1496              ) in output
1497      def test_2_secure_boot_v1(self):
1498          if arg_chip == "esp32":
1499              self.espefuse_py(
1500                  f"burn_key \
1501                  flash_encryption {IMAGES_DIR}/256bit \
1502                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key"
1503              )
1504              output = self.espefuse_py("summary -d")
1505              self.check_data_block_in_log(
1506                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1507              )
1508              self.check_data_block_in_log(
1509                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1510              )
1511              self.espefuse_py(
1512                  f"burn_key \
1513                  flash_encryption {IMAGES_DIR}/256bit \
1514                  secure_boot_v2 {IMAGES_DIR}/256bit_1"
1515              )
1516              output = self.espefuse_py("summary -d")
1517              assert (
1518                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1519                  "00000000 00000000 00000000 00000000"
1520              ) in output
1521              self.check_data_block_in_log(
1522                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1523              )
1524  class TestExecuteScriptsCommands(EfuseTestCase):
1525      @classmethod
1526      def setup_class(self):
1527          self.stored_dir = os.getcwd()
1528      @classmethod
1529      def teardown_class(self):
1530          os.chdir(self.stored_dir)
1531      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1532      def test_execute_scripts_with_check_that_only_one_burn(self):
1533          self.espefuse_py("execute_scripts -h")
1534          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1535          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1536          self.espefuse_py("execute_scripts execute_efuse_script2.py")
1537      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1538      def test_execute_scripts_with_check(self):
1539          self.espefuse_py("execute_scripts -h")
1540          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1541          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1542          self.espefuse_py("execute_scripts execute_efuse_script.py")
1543      def test_execute_scripts_with_index_and_config(self):
1544          os.chdir(TEST_DIR)
1545          if arg_chip in ["esp32", "esp32c2"]:
1546              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1547              --configfiles {EFUSE_S_DIR}/esp32/config1.json"
1548          else:
1549              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1550              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json"
1551          self.espefuse_py(cmd)
1552          output = self.espefuse_py("summary -d")
1553          if arg_chip in ["esp32", "esp32c2"]:
1554              assert (
1555                  "[3 ] read_regs: e00007ff 00000000 00000000 00000000 "
1556                  "00000000 00000000 00000000 00000000"
1557              ) in output
1558          else:
1559              assert (
1560                  "[8 ] read_regs: e00007ff 00000000 00000000 00000000 "
1561                  "00000000 00000000 00000000 00000000"
1562              ) in output
1563      def test_execute_scripts_nesting(self):
1564          os.chdir(TEST_DIR)
1565          if arg_chip in ["esp32", "esp32c2"]:
1566              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1567              --configfiles {EFUSE_S_DIR}/esp32/config2.json"
1568          else:
1569              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1570              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json"
1571          self.espefuse_py(cmd)
1572          output = self.espefuse_py("summary -d")
1573          if arg_chip in ["esp32", "esp32c2"]:
1574              assert (
1575                  "[2 ] read_regs: 10000000 00000000 00000000 00000000 "
1576                  "00000000 00000000 00000000 00000000"
1577              ) in output
1578              assert (
1579                  "[3 ] read_regs: ffffffff 00000000 00000000 00000000 "
1580                  "00000000 00000000 00000000 00000000"
1581              ) in output
1582          else:
1583              assert (
1584                  "[7 ] read_regs: 10000000 00000000 00000000 00000000 "
1585                  "00000000 00000000 00000000 00000000"
1586              ) in output
1587              assert (
1588                  "[8 ] read_regs: ffffffff 00000000 00000000 00000000 "
1589                  "00000000 00000000 00000000 00000000"
1590              ) in output
1591  class TestMultipleCommands(EfuseTestCase):
1592      def test_multiple_cmds_help(self):
1593          if arg_chip == "esp32c2":
1594              command1 = (
1595                  f"burn_key_digest {S_IMAGES_DIR}"
1596                  "/ecdsa256_secure_boot_signing_key_v2.pem"
1597              )
1598              command2 = (
1599                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
1600                  "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS"
1601              )
1602          elif arg_chip == "esp32":
1603              command1 = f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1604              command2 = f"burn_key flash_encryption {IMAGES_DIR}/256bit"
1605          else:
1606              command1 = f"burn_key_digest BLOCK_KEY0 \
1607              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0"
1608              command2 = f"burn_key BLOCK_KEY0 \
1609              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1610          self.espefuse_py(
1611              f"-h {command1} {command2}",
1612              check_msg="usage: __main__.py [-h]",
1613          )
1614          self.espefuse_py(
1615              f"{command1} -h {command2}",
1616              check_msg="usage: __main__.py burn_key_digest [-h]",
1617          )
1618          self.espefuse_py(
1619              f"{command1} {command2} -h",
1620              check_msg="usage: __main__.py burn_key [-h]",
1621          )
1622      @pytest.mark.skipif(
1623          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1624      )
1625      def test_1_esp32c2(self):
1626          self.espefuse_py(
1627              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1628              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1629              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1630              summary"
1631          )
1632          output = self.espefuse_py("summary -d")
1633          assert (
1634              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
1635              "f66a0fbf 8b6dd38b a9dab353 040af633"
1636          ) in output
1637          assert " = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-" in output
1638          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1639      @pytest.mark.skipif(
1640          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1641      )
1642      def test_2_esp32c2(self):
1643          self.espefuse_py(
1644              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1645              burn_key BLOCK_KEY0 \
1646              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1647              summary"
1648          )
1649          output = self.espefuse_py("summary -d")
1650          assert (
1651              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1652              "f66a0fbf 8b6dd38b a9dab353 040af633"
1653          ) in output
1654          assert " = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
1655          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1656      def test_burn_bit(self):
1657          if arg_chip == "esp32":
1658              self._set_34_coding_scheme()
1659          self.espefuse_py(
1660              "burn_bit BLOCK2 0 1 2 3 \
1661              burn_bit BLOCK2 4 5 6 7 \
1662              burn_bit BLOCK2 8 9 10 11 \
1663              burn_bit BLOCK2 12 13 14 15 \
1664              summary"
1665          )
1666          output = self.espefuse_py("summary -d")
1667          assert "[2 ] read_regs: 0000ffff 00000000" in output
1668      def test_not_burn_cmds(self):
1669          self.espefuse_py(
1670              "summary \
1671              dump \
1672              get_custom_mac \
1673              adc_info \
1674              check_error"
1675          )
1676  @pytest.mark.skipif(
1677      arg_chip not in ["esp32c3", "esp32c6", "esp32h2", "esp32s3"],
1678      reason="These chips have a hardware bug that limits the use of the KEY5",
1679  )
1680  class TestKeyPurposes(EfuseTestCase):
1681      def test_burn_xts_aes_key_purpose(self):
1682          self.espefuse_py(
1683              "burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY",
1684              check_msg="A fatal error occurred: "
1685              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1686              "key due to a hardware bug (please see TRM for more details)",
1687              ret_code=2,
1688          )
1689      @pytest.mark.skipif(
1690          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1691      )
1692      def test_burn_ecdsa_key_purpose(self):
1693          self.espefuse_py(
1694              "burn_efuse KEY_PURPOSE_5 ECDSA_KEY",
1695              check_msg="A fatal error occurred: "
1696              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1697              "key due to a hardware bug (please see TRM for more details)",
1698              ret_code=2,
1699          )
1700      def test_burn_xts_aes_key(self):
1701          self.espefuse_py(
1702              f"burn_key \
1703              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY",
1704              check_msg="A fatal error occurred: "
1705              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1706              "key due to a hardware bug (please see TRM for more details)",
1707              ret_code=2,
1708          )
1709      @pytest.mark.skipif(
1710          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1711      )
1712      def test_burn_ecdsa_key(self):
1713          self.espefuse_py(
1714              f"burn_key \
1715              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1716              ECDSA_KEY",
1717              check_msg="A fatal error occurred: "
1718              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1719              "key due to a hardware bug (please see TRM for more details)",
1720              ret_code=2,
1721          )
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-mediatools.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                </div>
                <div class="column column_space"><pre><code>39                      filename = "audio_" + dt.now().isoformat("_", "seconds") + ".ogg"
40                  elif "video" in mime_type:
41                      filename = "video_" + dt.now().isoformat("_", "seconds") + ".mp4"
</pre></code></div>
                <div class="column column_space"><pre><code>1430              ret_code=2,
1431          )
1432          self.espefuse_py("burn_bit BLOCK0 13")
1433          self.espefuse_py(
1434              "summary",
1435              check_msg="[0 ] read_regs: 00002000 00000000 00000000 "
1436              "00000000 00000000 00000000",
1437          )
1438          self.espefuse_py("burn_bit BLOCK0 24")
1439          self.espefuse_py(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    