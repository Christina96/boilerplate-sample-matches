<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for stateconf.py &amp; rh_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for stateconf.py &amp; rh_ip.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>stateconf.py (1.6689847%)<th>rh_ip.py (0.7566204%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(209-210)<td><a href="#" name="0">(960-961)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>stateconf.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import getopt
3 import io
4 import logging
5 import os
6 import re
7 from itertools import chain
8 import salt.utils.files
9 import salt.utils.stringutils
10 from salt.exceptions import SaltRenderError
11 __all__ = ["render"]
12 log = logging.getLogger(__name__)
13 __opts__ = {
14     "stateconf_end_marker": r"#\s*-+\s*end of state config\s*-+",
15     "stateconf_start_state": ".start",
16     "stateconf_goal_state": ".goal",
17     "stateconf_state_func": "stateconf.set"
18 }
19 STATE_FUNC = STATE_NAME = ""
20 def __init__(opts):
21     global STATE_NAME, STATE_FUNC
22     STATE_FUNC = __opts__["stateconf_state_func"]
23     STATE_NAME = STATE_FUNC.split(".")[0]
24 MOD_BASENAME = os.path.basename(__file__)
25 INVALID_USAGE_ERROR = SaltRenderError(
26     "Invalid use of {0} renderer!\n"
27         MOD_BASENAME
28     )
29 )
30 def render(input, saltenv="base", sls="", argline="", **kws):
31     gen_start_state = False
32     no_goal_state = False
33     implicit_require = False
34     def process_sls_data(data, context=None, extract=False):
35         sls_dir = os.path.dirname(sls.replace(".", os.path.sep)) if "." in sls else sls
36         ctx = dict(sls_dir=sls_dir if sls_dir else ".")
37         if context:
38             ctx.update(context)
39         tmplout = render_template(
40             io.StringIO(data),
41             saltenv,
42             sls,
43             context=ctx,
44             argline=rt_argline.strip(),
45             **kws
46         )
47         high = render_data(tmplout, saltenv, sls, argline=rd_argline.strip())
48         return process_high_data(high, extract)
49     def process_high_data(high, extract):
50         data = copy.deepcopy(high)
51         try:
52             rewrite_single_shorthand_state_decl(data)
53             rewrite_sls_includes_excludes(data, sls, saltenv)
54             if not extract and implicit_require:
55                 sid = has_names_decls(data)
56                 if sid:
57                     raise SaltRenderError(
58                         "'names' declaration(found in state id: {}) is "
59                         "not supported with implicitly ordered states! You "
60                         "should generate the states in a template for-loop "
61                         "instead.".format(sid)
62                     )
63                 add_implicit_requires(data)
64             if gen_start_state:
65                 add_start_state(data, sls)
66             if not extract and not no_goal_state:
67                 add_goal_state(data)
68             rename_state_ids(data, sls)
69             extract_state_confs(data)
70         except SaltRenderError:
71             raise
72         except Exception as err:  # pylint: disable=broad-except
73             log.exception(
74                 "Error found while pre-processing the salt file %s:\n%s", sls, err
75             )
76             from salt.state import State
77             state = State(__opts__)
78             errors = state.verify_high(high)
79             if errors:
80                 raise SaltRenderError("\n".join(errors))
81             raise SaltRenderError("sls preprocessing/rendering failed!")
82         return data
83     renderers = kws["renderers"]
84     opts, args = getopt.getopt(argline.split(), "Gosp")
85     argline = " ".join(args) if args else "yaml . jinja"
86     if ("-G", "") in opts:
87         no_goal_state = True
88     if ("-o", "") in opts:
89         implicit_require = True
90     if ("-s", "") in opts:
91         gen_start_state = True
92     if ("-p", "") in opts:
93         data = process_high_data(input, extract=False)
94     else:
95         args = [
96             arg.strip().replace("\\.", ".")
97             for arg in re.split(r"\s+(?&lt;!\\)\.\s+", argline, 1)
98         ]
99         try:
100             name, rd_argline = (args[0] + " ").split(" ", 1)
101             render_data = renderers[name]  # e.g., the yaml renderer
102             if implicit_require:
103                 if name == "yaml":
104                     rd_argline = "-o " + rd_argline
105                 else:
106                     raise SaltRenderError(
107                         "Implicit ordering is only supported if the yaml renderer "
108                         "is used!"
109                     )
110             name, rt_argline = (args[1] + " ").split(" ", 1)
111             render_template = renderers[name]  # e.g., the mako renderer
112         except KeyError as err:
113             raise SaltRenderError("Renderer: {} is not available!".format(err))
114         except IndexError:
115         if isinstance(input, str):
116             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(input, "r") as ifile:
117                 sls_templ = salt.utils.stringutils.to_unicode(ifile.read(</b></font>))
118         else:  # assume file-like
119             sls_templ = salt.utils.stringutils.to_unicode(input.read())
120         match = re.search(__opts__["stateconf_end_marker"], sls_templ)
121         if match:
122             process_sls_data(sls_templ[: match.start()], extract=True)
123         if STATE_CONF:
124             tmplctx = STATE_CONF.copy()
125             if tmplctx:
126                 prefix = sls + "::"
127                 tmplctx = {
128                     k[len(prefix) :] if k.startswith(prefix) else k: v
129                     for k, v in tmplctx.items()
130                 }
131         else:
132             tmplctx = {}
133         data = process_sls_data(sls_templ, tmplctx)
134     if log.isEnabledFor(logging.DEBUG):
135         import pprint  # FIXME: pprint OrderedDict
136         log.debug("Rendered sls: %s", pprint.pformat(data))
137     return data
138 def has_names_decls(data):
139     for sid, _, _, args in statelist(data):
140         if sid == "extend":
141             continue
142         for _ in nvlist(args, ["names"]):
143             return sid
144 def rewrite_single_shorthand_state_decl(data):  # pylint: disable=C0103
145     for sid, states in data.items():
146         if isinstance(states, str):
147             data[sid] = {states: []}
148 def rewrite_sls_includes_excludes(data, sls, saltenv):
149     for sid in data:
150         if sid == "include":
151             includes = data[sid]
152             for i, each in enumerate(includes):
153                 if isinstance(each, dict):
154                     slsenv, incl = each.popitem()
155                 else:
156                     slsenv = saltenv
157                     incl = each
158                 if incl.startswith("."):
159                     includes[i] = {slsenv: _relative_to_abs_sls(incl, sls)}
160         elif sid == "exclude":
161             for sdata in data[sid]:
162                 if "sls" in sdata and sdata["sls"].startswith("."):
163                     sdata["sls"] = _relative_to_abs_sls(sdata["sls"], sls)
164 def _local_to_abs_sid(sid, sls):  # id must starts with '.'
165     if "::" in sid:
166         return _relative_to_abs_sls(sid, sls)
167     else:
168         abs_sls = _relative_to_abs_sls(sid, sls + ".")
169         return "::".join(abs_sls.rsplit(".", 1))
170 def _relative_to_abs_sls(relative, sls):
171     levels, suffix = re.match(r"^(\.+)(.*)$", relative).groups()
172     level_count = len(levels)
173     p_comps = sls.split(".")
174     if level_count &gt; len(p_comps):
175         raise SaltRenderError(
176             "Attempted relative include goes beyond top level package"
177         )
178     return ".".join(p_comps[:-level_count] + [suffix])
179 def nvlist(thelist, names=None):
180     for nvitem in thelist:
181         if isinstance(nvitem, dict):
182             name, value = next(iter(nvitem.items()))
183             if names is None or name in names:
184                 yield nvitem, name, value
185 def nvlist2(thelist, names=None):
186     for _, _, value in nvlist(thelist, names):
187         yield from nvlist(value)
188 def statelist(states_dict, sid_excludes=frozenset(["include", "exclude"])):
189     for sid, states in states_dict.items():
190         if sid.startswith("__"):
191             continue
192         if sid in sid_excludes:
193             continue
194         for sname, args in states.items():
195             if sname.startswith("__"):
196                 continue
197             yield sid, states, sname, args
198 REQUISITES = (
199     "require",
200     "require_in",
201     "watch",
202     "watch_in",
203     "use",
204     "use_in",
205     "listen",
206     "listen_in",
207     "onchanges",
208     "onchanges_in",
209     "onfail",
210     "onfail_in",
211 )
212 def rename_state_ids(data, sls, is_extend=False):
213     if "extend" in data and not is_extend:
214         rename_state_ids(data["extend"], sls, True)
215     for sid, _, _, args in statelist(data):
216         for req, sname, sid in nvlist2(args, REQUISITES):
217             if sid.startswith("."):
218                 req[sname] = _local_to_abs_sid(sid, sls)
219     for sid in list(data):
220         if sid.startswith("."):
221             newsid = _local_to_abs_sid(sid, sls)
222             if newsid in data:
223                 raise SaltRenderError(
224                     "Can't rename state id({}) into {} because the later "
225                     "already exists!".format(sid, newsid)
226                 )
227             for sname, args in data[sid].items():
228                 if state_name(sname) == STATE_NAME:
229                     continue
230                 for arg in args:
231                     if isinstance(arg, dict) and next(iter(arg)) == "name":
232                         break
233                 else:
234                     args.insert(0, dict(name=sid[1:]))
235             data[newsid] = data[sid]
236             del data[sid]
237 REQUIRE = ("require", "watch", "listen", "onchanges", "onfail")
238 REQUIRE_IN = ("require_in", "watch_in", "listen_in", "onchanges_in", "onfail_in")
239 EXTENDED_REQUIRE = {}
240 EXTENDED_REQUIRE_IN = {}
241 def add_implicit_requires(data):
242     def T(sid, state):  # pylint: disable=C0103
243         return "{}:{}".format(sid, state_name(state))
244     states_before = set()
245     states_after = set()
246     for sid in data:
247         for state in data[sid]:
248             states_after.add(T(sid, state))
249     prev_state = (None, None)  # (state_name, sid)
250     for sid, states, sname, args in statelist(data):
251         if sid == "extend":
252             for esid, _, _, eargs in statelist(states):
253                 for _, rstate, rsid in nvlist2(eargs, REQUIRE):
254                     EXTENDED_REQUIRE.setdefault(T(esid, rstate), []).append(
255                         (None, rstate, rsid)
256                     )
257                 for _, rstate, rsid in nvlist2(eargs, REQUIRE_IN):
258                     EXTENDED_REQUIRE_IN.setdefault(T(esid, rstate), []).append(
259                         (None, rstate, rsid)
260                     )
261             continue
262         tag = T(sid, sname)
263         states_after.remove(tag)
264         reqs = nvlist2(args, REQUIRE)
265         if tag in EXTENDED_REQUIRE:
266             reqs = chain(reqs, EXTENDED_REQUIRE[tag])
267         for _, rstate, rsid in reqs:
268             if T(rsid, rstate) in states_after:
269                 raise SaltRenderError(
270                     "State({}) can't require/watch/listen/onchanges/onfail a state({})"
271                     " defined after it!".format(tag, T(rsid, rstate))
272                 )
273         reqs = nvlist2(args, REQUIRE_IN)
274         if tag in EXTENDED_REQUIRE_IN:
275             reqs = chain(reqs, EXTENDED_REQUIRE_IN[tag])
276         for _, rstate, rsid in reqs:
277             if T(rsid, rstate) in states_before:
278                 raise SaltRenderError(
279                     "State({}) can't"
280                     " require_in/watch_in/listen_in/onchanges_in/onfail_in a state({})"
281                     " defined before it!".format(tag, T(rsid, rstate))
282                 )
283         if prev_state[0] is not None:
284             try:
285                 next(nvlist(args, ["require"]))[2].insert(0, dict([prev_state]))
286             except StopIteration:  # i.e., there's no require
287                 args.append(dict(require=[dict([prev_state])]))
288         states_before.add(tag)
289         prev_state = (state_name(sname), sid)
290 def add_start_state(data, sls):
291     start_sid = __opts__["stateconf_start_state"]
292     if start_sid in data:
293         raise SaltRenderError(
294             "Can't generate start state({})! The same state id already exists!".format(
295                 start_sid
296             )
297         )
298     if not data:
299         return
300     non_sids = ("include", "exclude", "extend")
301     for sid, states in data.items():
302         if sid in non_sids or sid.startswith("__"):
303             continue
304         if "__sls__" not in states or states["__sls__"] == sls:
305             break
306     else:
307         raise SaltRenderError("Can't determine the first state in the sls file!")
308     reqin = {state_name(next(iter(data[sid].keys()))): sid}
309     data[start_sid] = {STATE_FUNC: [{"require_in": [reqin]}]}
310 def add_goal_state(data):
311     goal_sid = __opts__["stateconf_goal_state"]
312     if goal_sid in data:
313         raise SaltRenderError(
314             "Can't generate goal state({})! The same state id already exists!".format(
315                 goal_sid
316             )
317         )
318     else:
319         reqlist = []
320         for sid, states, state, _ in statelist(data, ("include", "exclude", "extend")):
321             if "__sls__" in states:
322                 continue
323             reqlist.append({state_name(state): sid})
324         data[goal_sid] = {STATE_FUNC: [dict(require=reqlist)]}
325 def state_name(sname):
326     return sname.split(".", 1)[0]
327 class Bunch(dict):
328     def __getattr__(self, name):
329         return self[name]
330 STATE_CONF = {}  # stateconf.set
331 STATE_CONF_EXT = {}  # stateconf.set under extend: ...
332 def extract_state_confs(data, is_extend=False):
333     for state_id, state_dict in data.items():
334         if state_id == "extend" and not is_extend:
335             extract_state_confs(state_dict, True)
336             continue
337         if STATE_NAME in state_dict:
338             key = STATE_NAME
339         elif STATE_FUNC in state_dict:
340             key = STATE_FUNC
341         else:
342             continue
343         to_dict = STATE_CONF_EXT if is_extend else STATE_CONF
344         conf = to_dict.setdefault(state_id, Bunch())
345         for sdk in state_dict[key]:
346             if not isinstance(sdk, dict):
347                 continue
348             key, val = next(iter(sdk.items()))
349             conf[key] = val
350         if not is_extend and state_id in STATE_CONF_EXT:
351             extend = STATE_CONF_EXT[state_id]
352             for requisite in "require", "watch", "listen", "onchanges", "onfail":
353                 if requisite in extend:
354                     extend[requisite] += to_dict[state_id].get(requisite, [])
355             to_dict[state_id].update(STATE_CONF_EXT[state_id])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rh_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import jinja2
4 import jinja2.exceptions
5 import salt.utils.files
6 import salt.utils.json
7 import salt.utils.stringutils
8 import salt.utils.templates
9 import salt.utils.validate.net
10 from salt.exceptions import CommandExecutionError
11 log = logging.getLogger(__name__)
12 JINJA = jinja2.Environment(
13     loader=jinja2.FileSystemLoader(
14         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "rh_ip")
15     )
16 )
17 __virtualname__ = "ip"
18 _BOND_DEFAULTS = {
19     "ad_select": "0",
20     "tx_queues": "16",
21     "lacp_rate": "0",
22     "max_bonds": "1",
23     "use_carrier": "0",
24     "xmit_hash_policy": "layer2",
25 }
26 _RH_NETWORK_SCRIPT_DIR = "/etc/sysconfig/network-scripts"
27 _RH_NETWORK_FILE = "/etc/sysconfig/network"
28 _CONFIG_TRUE = ("yes", "on", "true", "1", True)
29 _CONFIG_FALSE = ("no", "off", "false", "0", False)
30 _IFACE_TYPES = (
31     "eth",
32     "bond",
33     "team",
34     "alias",
35     "clone",
36     "ipsec",
37     "dialup",
38     "bridge",
39     "slave",
40     "teamport",
41     "vlan",
42     "ipip",
43     "ib",
44 )
45 def __virtual__():
46     if __grains__["os_family"] == "RedHat":
47         if __grains__["os"] == "Amazon":
48             if __grains__["osmajorrelease"] &gt;= 2:
49                 return __virtualname__
50         else:
51             return __virtualname__
52     return (
53         False,
54         "The rh_ip execution module cannot be loaded: this module is only available on"
55         " RHEL/Fedora based distributions.",
56     )
57 def _error_msg_iface(iface, option, expected):
58     if isinstance(expected, str):
59         expected = (expected,)
60     msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
61     return msg.format(iface, option, "|".join(str(e) for e in expected))
62 def _error_msg_routes(iface, option, expected):
63     msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
64     return msg.format(iface, option, expected)
65 def _log_default_iface(iface, opt, value):
66     log.info(
67         "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
68     )
69 def _error_msg_network(option, expected):
70     if isinstance(expected, str):
71         expected = (expected,)
72     msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
73     return msg.format(option, "|".join(str(e) for e in expected))
74 def _log_default_network(opt, value):
75     log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
76 def _parse_rh_config(path):
77     rh_config = _read_file(path)
78     cv_rh_config = {}
79     if rh_config:
80         for line in rh_config:
81             line = line.strip()
82             if len(line) == 0 or line.startswith("!") or line.startswith("#"):
83                 continue
84             pair = [p.rstrip() for p in line.split("=", 1)]
85             if len(pair) != 2:
86                 continue
87             name, value = pair
88             cv_rh_config[name.upper()] = value
89     return cv_rh_config
90 def _parse_ethtool_opts(opts, iface):
91     config = {}
92     if "autoneg" in opts:
93         if opts["autoneg"] in _CONFIG_TRUE:
94             config.update({"autoneg": "on"})
95         elif opts["autoneg"] in _CONFIG_FALSE:
96             config.update({"autoneg": "off"})
97         else:
98             _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
99     if "duplex" in opts:
100         valid = ["full", "half"]
101         if opts["duplex"] in valid:
102             config.update({"duplex": opts["duplex"]})
103         else:
104             _raise_error_iface(iface, "duplex", valid)
105     if "speed" in opts:
106         valid = ["10", "100", "1000", "10000"]
107         if str(opts["speed"]) in valid:
108             config.update({"speed": opts["speed"]})
109         else:
110             _raise_error_iface(iface, opts["speed"], valid)
111     if "advertise" in opts:
112         valid = [
113             "0x001",
114             "0x002",
115             "0x004",
116             "0x008",
117             "0x010",
118             "0x020",
119             "0x20000",
120             "0x8000",
121             "0x1000",
122             "0x40000",
123             "0x80000",
124             "0x200000",
125             "0x400000",
126             "0x800000",
127             "0x1000000",
128             "0x2000000",
129             "0x4000000",
130         ]
131         if str(opts["advertise"]) in valid:
132             config.update({"advertise": opts["advertise"]})
133         else:
134             _raise_error_iface(iface, "advertise", valid)
135     if "channels" in opts:
136         channels_cmd = "-L {}".format(iface.strip())
137         channels_params = []
138         for option in ("rx", "tx", "other", "combined"):
139             if option in opts["channels"]:
140                 valid = range(1, __grains__["num_cpus"] + 1)
141                 if opts["channels"][option] in valid:
142                     channels_params.append(
143                         "{} {}".format(option, opts["channels"][option])
144                     )
145                 else:
146                     _raise_error_iface(iface, opts["channels"][option], valid)
147         if channels_params:
148             config.update({channels_cmd: " ".join(channels_params)})
149     valid = _CONFIG_TRUE + _CONFIG_FALSE
150     for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
151         if option in opts:
152             if opts[option] in _CONFIG_TRUE:
153                 config.update({option: "on"})
154             elif opts[option] in _CONFIG_FALSE:
155                 config.update({option: "off"})
156             else:
157                 _raise_error_iface(iface, option, valid)
158     return config
159 def _parse_settings_bond(opts, iface):
160     if opts["mode"] in ("balance-rr", "0"):
161         log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
162         return _parse_settings_bond_0(opts, iface)
163     elif opts["mode"] in ("active-backup", "1"):
164         log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
165         return _parse_settings_bond_1(opts, iface)
166     elif opts["mode"] in ("balance-xor", "2"):
167         log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
168         return _parse_settings_bond_2(opts, iface)
169     elif opts["mode"] in ("broadcast", "3"):
170         log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
171         return _parse_settings_bond_3(opts, iface)
172     elif opts["mode"] in ("802.3ad", "4"):
173         log.info(
174             "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
175         )
176         return _parse_settings_bond_4(opts, iface)
177     elif opts["mode"] in ("balance-tlb", "5"):
178         log.info("Device: %s Bonding Mode: transmit load balancing", iface)
179         return _parse_settings_bond_5(opts, iface)
180     elif opts["mode"] in ("balance-alb", "6"):
181         log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
182         return _parse_settings_bond_6(opts, iface)
183     else:
184         valid = (
185             "0",
186             "1",
187             "2",
188             "3",
189             "4",
190             "5",
191             "6",
192             "balance-rr",
193             "active-backup",
194             "balance-xor",
195             "broadcast",
196             "802.3ad",
197             "balance-tlb",
198             "balance-alb",
199         )
200         _raise_error_iface(iface, "mode", valid)
201 def _parse_settings_miimon(opts, iface):
202     ret = {}
203     for binding in ("miimon", "downdelay", "updelay"):
204         if binding in opts:
205             try:
206                 int(opts[binding])
207                 ret.update({binding: opts[binding]})
208             except Exception:  # pylint: disable=broad-except
209                 _raise_error_iface(iface, binding, "integer")
210     if "miimon" in opts and "downdelay" not in opts:
211         ret["downdelay"] = ret["miimon"] * 2
212     if "miimon" in opts:
213         if not opts["miimon"]:
214             _raise_error_iface(iface, "miimon", "nonzero integer")
215         for binding in ("downdelay", "updelay"):
216             if binding in ret:
217                 if ret[binding] % ret["miimon"]:
218                     _raise_error_iface(
219                         iface,
220                         binding,
221                         "0 or a multiple of miimon ({})".format(ret["miimon"]),
222                     )
223         if "use_carrier" in opts:
224             if opts["use_carrier"] in _CONFIG_TRUE:
225                 ret.update({"use_carrier": "1"})
226             elif opts["use_carrier"] in _CONFIG_FALSE:
227                 ret.update({"use_carrier": "0"})
228             else:
229                 valid = _CONFIG_TRUE + _CONFIG_FALSE
230                 _raise_error_iface(iface, "use_carrier", valid)
231         else:
232             _log_default_iface(iface, "use_carrier", _BOND_DEFAULTS["use_carrier"])
233             ret.update({"use_carrier": _BOND_DEFAULTS["use_carrier"]})
234     return ret
235 def _parse_settings_arp(opts, iface):
236     ret = {}
237     if "arp_interval" in opts:
238         try:
239             int(opts["arp_interval"])
240             ret.update({"arp_interval": opts["arp_interval"]})
241         except Exception:  # pylint: disable=broad-except
242             _raise_error_iface(iface, "arp_interval", "integer")
243         valid = "list of ips (up to 16)"
244         if "arp_ip_target" in opts:
245             if isinstance(opts["arp_ip_target"], list):
246                 if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
247                     ret.update({"arp_ip_target": ",".join(opts["arp_ip_target"])})
248                 else:
249                     _raise_error_iface(iface, "arp_ip_target", valid)
250             else:
251                 _raise_error_iface(iface, "arp_ip_target", valid)
252         else:
253             _raise_error_iface(iface, "arp_ip_target", valid)
254     return ret
255 def _parse_settings_bond_0(opts, iface):
256     bond = {"mode": "0"}
257     bond.update(_parse_settings_miimon(opts, iface))
258     bond.update(_parse_settings_arp(opts, iface))
259     if "miimon" not in opts and "arp_interval" not in opts:
260         _raise_error_iface(
261             iface, "miimon or arp_interval", "at least one of these is required"
262         )
263     return bond
264 def _parse_settings_bond_1(opts, iface):
265     bond = {"mode": "1"}
266     bond.update(_parse_settings_miimon(opts, iface))
267     if "miimon" not in opts:
268         _raise_error_iface(iface, "miimon", "integer")
269     if "primary" in opts:
270         bond.update({"primary": opts["primary"]})
271     return bond
272 def _parse_settings_bond_2(opts, iface):
273     bond = {"mode": "2"}
274     bond.update(_parse_settings_miimon(opts, iface))
275     bond.update(_parse_settings_arp(opts, iface))
276     if "miimon" not in opts and "arp_interval" not in opts:
277         _raise_error_iface(
278             iface, "miimon or arp_interval", "at least one of these is required"
279         )
280     if "hashing-algorithm" in opts:
281         valid = ("layer2", "layer2+3", "layer3+4")
282         if opts["hashing-algorithm"] in valid:
283             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
284         else:
285             _raise_error_iface(iface, "hashing-algorithm", valid)
286     return bond
287 def _parse_settings_bond_3(opts, iface):
288     bond = {"mode": "3"}
289     bond.update(_parse_settings_miimon(opts, iface))
290     if "miimon" not in opts:
291         _raise_error_iface(iface, "miimon", "integer")
292     return bond
293 def _parse_settings_bond_4(opts, iface):
294     bond = {"mode": "4"}
295     bond.update(_parse_settings_miimon(opts, iface))
296     if "miimon" not in opts:
297         _raise_error_iface(iface, "miimon", "integer")
298     for binding in ("lacp_rate", "ad_select"):
299         if binding in opts:
300             if binding == "lacp_rate":
301                 valid = ("fast", "1", "slow", "0")
302                 if opts[binding] not in valid:
303                     _raise_error_iface(iface, binding, valid)
304                 if opts[binding] == "fast":
305                     opts.update({binding: "1"})
306                 if opts[binding] == "slow":
307                     opts.update({binding: "0"})
308             else:
309                 valid = "integer"
310             try:
311                 int(opts[binding])
312                 bond.update({binding: opts[binding]})
313             except Exception:  # pylint: disable=broad-except
314                 _raise_error_iface(iface, binding, valid)
315         else:
316             _log_default_iface(iface, binding, _BOND_DEFAULTS[binding])
317             bond.update({binding: _BOND_DEFAULTS[binding]})
318     if "hashing-algorithm" in opts:
319         if __grains__["os_family"] == "RedHat":
320             if __grains__["osmajorrelease"] &lt; 8:
321                 valid = ("layer2", "layer2+3", "layer3+4", "encap2+3", "encap3+4")
322             else:
323                 valid = (
324                     "layer2",
325                     "layer2+3",
326                     "layer3+4",
327                     "encap2+3",
328                     "encap3+4",
329                     "vlan+srcmac",
330                 )
331         if opts["hashing-algorithm"] in valid:
332             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
333         else:
334             _raise_error_iface(iface, "hashing-algorithm", valid)
335     return bond
336 def _parse_settings_bond_5(opts, iface):
337     bond = {"mode": "5"}
338     bond.update(_parse_settings_miimon(opts, iface))
339     if "miimon" not in opts:
340         _raise_error_iface(iface, "miimon", "integer")
341     if "primary" in opts:
342         bond.update({"primary": opts["primary"]})
343     return bond
344 def _parse_settings_bond_6(opts, iface):
345     bond = {"mode": "6"}
346     bond.update(_parse_settings_miimon(opts, iface))
347     if "miimon" not in opts:
348         _raise_error_iface(iface, "miimon", "integer")
349     if "primary" in opts:
350         bond.update({"primary": opts["primary"]})
351     return bond
352 def _parse_settings_vlan(opts, iface):
353     vlan = {}
354     if "reorder_hdr" in opts:
355         if opts["reorder_hdr"] in _CONFIG_TRUE + _CONFIG_FALSE:
356             vlan.update({"reorder_hdr": opts["reorder_hdr"]})
357         else:
358             valid = _CONFIG_TRUE + _CONFIG_FALSE
359             _raise_error_iface(iface, "reorder_hdr", valid)
360     if "vlan_id" in opts:
361         if opts["vlan_id"] &gt; 0:
362             vlan.update({"vlan_id": opts["vlan_id"]})
363         else:
364             _raise_error_iface(iface, "vlan_id", "Positive integer")
365     if "phys_dev" in opts:
366         if len(opts["phys_dev"]) &gt; 0:
367             vlan.update({"phys_dev": opts["phys_dev"]})
368         else:
369             _raise_error_iface(iface, "phys_dev", "Non-empty string")
370     return vlan
371 def _parse_settings_eth(opts, iface_type, enabled, iface):
372     result = {"name": iface}
373     if "proto" in opts:
374         valid = ["none", "bootp", "dhcp"]
375         if opts["proto"] in valid:
376             result["proto"] = opts["proto"]
377         else:
378             _raise_error_iface(iface, opts["proto"], valid)
379     if "dns" in opts:
380         result["dns"] = opts["dns"]
381         result["peerdns"] = "yes"
382     if "mtu" in opts:
383         try:
384             result["mtu"] = int(opts["mtu"])
385         except ValueError:
386             _raise_error_iface(iface, "mtu", ["integer"])
387     if "hwaddr" in opts and "macaddr" in opts:
388         msg = "Cannot pass both hwaddr and macaddr. Must use either hwaddr or macaddr"
389         log.error(msg)
390         raise AttributeError(msg)
391     if iface_type not in ("bridge",):
392         ethtool = _parse_ethtool_opts(opts, iface)
393         if ethtool:
394             result["ethtool"] = " ".join(
395                 ["{} {}".format(x, y) for x, y in ethtool.items()]
396             )
397     if iface_type == "slave":
398         result["proto"] = "none"
399     if iface_type == "team":
400         result["devicetype"] = "Team"
401         if "team_config" in opts:
402             result["team_config"] = salt.utils.json.dumps(opts["team_config"])
403     if iface_type == "teamport":
404         result["devicetype"] = "TeamPort"
405         result["team_master"] = opts["team_master"]
406         if "team_port_config" in opts:
407             result["team_port_config"] = salt.utils.json.dumps(opts["team_port_config"])
408     if iface_type == "bond":
409         if "mode" not in opts:
410             msg = "Missing required option 'mode'"
411             log.error("%s for bond interface '%s'", msg, iface)
412             raise AttributeError(msg)
413         bonding = _parse_settings_bond(opts, iface)
414         if bonding:
415             result["bonding"] = " ".join(
416                 ["{}={}".format(x, y) for x, y in bonding.items()]
417             )
418             result["devtype"] = "Bond"
419     if iface_type == "vlan":
420         vlan = _parse_settings_vlan(opts, iface)
421         if vlan:
422             result["devtype"] = "Vlan"
423             for opt in vlan:
424                 result[opt] = opts[opt]
425     if iface_type not in ("bond", "team", "vlan", "bridge", "ipip"):
426         auto_addr = False
427         if "hwaddr" in opts:
428             if salt.utils.validate.net.mac(opts["hwaddr"]):
429                 result["hwaddr"] = opts["hwaddr"]
430             elif opts["hwaddr"] == "auto":
431                 auto_addr = True
432             elif opts["hwaddr"] != "none":
433                 _raise_error_iface(
434                     iface, opts["hwaddr"], ("AA:BB:CC:DD:EE:FF", "auto", "none")
435                 )
436         else:
437             auto_addr = True
438         if auto_addr:
439             if iface_type != "slave":
440                 ifaces = __salt__["network.interfaces"]()
441                 if iface in ifaces and "hwaddr" in ifaces[iface]:
442                     result["hwaddr"] = ifaces[iface]["hwaddr"]
443     if iface_type == "eth":
444         result["devtype"] = "Ethernet"
445     if iface_type == "bridge":
446         result["devtype"] = "Bridge"
447         bypassfirewall = True
448         valid = _CONFIG_TRUE + _CONFIG_FALSE
449         for opt in ("bypassfirewall",):
450             if opt in opts:
451                 if opts[opt] in _CONFIG_TRUE:
452                     bypassfirewall = True
453                 elif opts[opt] in _CONFIG_FALSE:
454                     bypassfirewall = False
455                 else:
456                     _raise_error_iface(iface, opts[opt], valid)
457         bridgectls = [
458             "net.bridge.bridge-nf-call-ip6tables",
459             "net.bridge.bridge-nf-call-iptables",
460             "net.bridge.bridge-nf-call-arptables",
461         ]
462         if bypassfirewall:
463             sysctl_value = 0
464         else:
465             sysctl_value = 1
466         for sysctl in bridgectls:
467             try:
468                 __salt__["sysctl.persist"](sysctl, sysctl_value)
469             except CommandExecutionError:
470                 log.warning("Failed to set sysctl: %s", sysctl)
471     else:
472         if "bridge" in opts:
473             result["bridge"] = opts["bridge"]
474     if iface_type == "ipip":
475         result["devtype"] = "IPIP"
476         for opt in ("my_inner_ipaddr", "my_outer_ipaddr"):
477             if opt not in opts:
478                 _raise_error_iface(iface, opt, "1.2.3.4")
479             else:
480                 result[opt] = opts[opt]
481     if iface_type == "ib":
482         result["devtype"] = "InfiniBand"
483     if "prefix" in opts:
484         if "netmask" in opts:
485             msg = "Cannot use prefix and netmask together"
486             log.error(msg)
487             raise AttributeError(msg)
488         result["prefix"] = opts["prefix"]
489     elif "netmask" in opts:
490         result["netmask"] = opts["netmask"]
491     for opt in (
492         "ipaddr",
493         "master",
494         "srcaddr",
495         "delay",
496         "domain",
497         "gateway",
498         "uuid",
499         "nickname",
500         "zone",
501     ):
502         if opt in opts:
503             result[opt] = opts[opt]
504     for opt in ("ipv6addr", "ipv6gateway"):
505         if opt in opts:
506             result[opt] = opts[opt]
507     if "ipaddrs" in opts:
508         result["ipaddrs"] = []
509         for opt in opts["ipaddrs"]:
510             if salt.utils.validate.net.ipv4_addr(opt):
511                 ip, prefix = (i.strip() for i in opt.split("/"))
512                 result["ipaddrs"].append({"ipaddr": ip, "prefix": prefix})
513             else:
514                 msg = "ipv4 CIDR is invalid"
515                 log.error(msg)
516                 raise AttributeError(msg)
517     if "ipv6addrs" in opts:
518         for opt in opts["ipv6addrs"]:
519             if not salt.utils.validate.net.ipv6_addr(opt):
520                 msg = "ipv6 CIDR is invalid"
521                 log.error(msg)
522                 raise AttributeError(msg)
523             result["ipv6addrs"] = opts["ipv6addrs"]
524     if "enable_ipv6" in opts:
525         result["enable_ipv6"] = opts["enable_ipv6"]
526     valid = _CONFIG_TRUE + _CONFIG_FALSE
527     for opt in (
528         "onparent",
529         "peerdns",
530         "peerroutes",
531         "slave",
532         "vlan",
533         "defroute",
534         "stp",
535         "ipv6_peerdns",
536         "ipv6_defroute",
537         "ipv6_peerroutes",
538         "ipv6_autoconf",
539         "ipv4_failure_fatal",
540         "dhcpv6c",
541     ):
542         if opt in opts:
543             if opts[opt] in _CONFIG_TRUE:
544                 result[opt] = "yes"
545             elif opts[opt] in _CONFIG_FALSE:
546                 result[opt] = "no"
547             else:
548                 _raise_error_iface(iface, opts[opt], valid)
549     if "onboot" in opts:
550         log.warning(
551             "The 'onboot' option is controlled by the 'enabled' option. "
552             "Interface: %s Enabled: %s",
553             iface,
554             enabled,
555         )
556     if enabled:
557         result["onboot"] = "yes"
558     else:
559         result["onboot"] = "no"
560     if "userctl" in opts:
561         if opts["userctl"] in _CONFIG_TRUE:
562             result["userctl"] = "yes"
563         elif opts["userctl"] in _CONFIG_FALSE:
564             result["userctl"] = "no"
565         else:
566             _raise_error_iface(iface, opts["userctl"], valid)
567     else:
568         result["userctl"] = "no"
569     if "vlan" in opts:
570         if opts["vlan"] in _CONFIG_TRUE:
571             result["vlan"] = "yes"
572         elif opts["vlan"] in _CONFIG_FALSE:
573             result["vlan"] = "no"
574         else:
575             _raise_error_iface(iface, opts["vlan"], valid)
576     if "arpcheck" in opts:
577         if opts["arpcheck"] in _CONFIG_FALSE:
578             result["arpcheck"] = "no"
579     if "ipaddr_start" in opts:
580         result["ipaddr_start"] = opts["ipaddr_start"]
581     if "ipaddr_end" in opts:
582         result["ipaddr_end"] = opts["ipaddr_end"]
583     if "clonenum_start" in opts:
584         result["clonenum_start"] = opts["clonenum_start"]
585     if "hwaddr" in opts:
586         result["hwaddr"] = opts["hwaddr"]
587     if "macaddr" in opts:
588         result["macaddr"] = opts["macaddr"]
589     if "nm_controlled" in opts:
590         if opts["nm_controlled"] in _CONFIG_TRUE:
591             result["nm_controlled"] = "yes"
592         elif opts["nm_controlled"] in _CONFIG_FALSE:
593             result["nm_controlled"] = "no"
594         else:
595             _raise_error_iface(iface, opts["nm_controlled"], valid)
596     else:
597         result["nm_controlled"] = "no"
598     return result
599 def _parse_routes(iface, opts):
600     opts = {k.lower(): v for (k, v) in opts.items()}
601     result = {}
602     if "routes" not in opts:
603         _raise_error_routes(iface, "routes", "List of routes")
604     for opt in opts:
605         result[opt] = opts[opt]
606     return result
607 def _parse_network_settings(opts, current):
608     opts = {k.lower(): v for (k, v) in opts.items()}
609     current = {k.lower(): v for (k, v) in current.items()}
610     retain_settings = opts.get("retain_settings", False)
611     result = current if retain_settings else {}
612     quote_type = ""
613     valid = _CONFIG_TRUE + _CONFIG_FALSE
614     if "enabled" not in opts:
615         try:
616             opts["networking"] = current["networking"]
617             quote_type = salt.utils.stringutils.is_quoted(opts["networking"])
618             _log_default_network("networking", current["networking"])
619         except ValueError:
620             _raise_error_network("networking", valid)
621     else:
622         opts["networking"] = opts["enabled"]
623     true_val = "{0}yes{0}".format(quote_type)
624     false_val = "{0}no{0}".format(quote_type)
625     networking = salt.utils.stringutils.dequote(opts["networking"])
626     if networking in valid:
627         if networking in _CONFIG_TRUE:
628             result["networking"] = true_val
629         elif networking in _CONFIG_FALSE:
630             result["networking"] = false_val
631     else:
632         _raise_error_network("networking", valid)
633     if "hostname" not in opts:
634         try:
635             opts["hostname"] = current["hostname"]
636             _log_default_network("hostname", current["hostname"])
637         except Exception:  # pylint: disable=broad-except
638             _raise_error_network("hostname", ["server1.example.com"])
639     if opts["hostname"]:
640         result["hostname"] = "{1}{0}{1}".format(
641             salt.utils.stringutils.dequote(opts["hostname"]), quote_type
642         )
643     else:
644         _raise_error_network("hostname", ["server1.example.com"])
645     if "nozeroconf" in opts:
646         nozeroconf = salt.utils.stringutils.dequote(opts["nozeroconf"])
647         if nozeroconf in valid:
648             if nozeroconf in _CONFIG_TRUE:
649                 result["nozeroconf"] = true_val
650             elif nozeroconf in _CONFIG_FALSE:
651                 result["nozeroconf"] = false_val
652         else:
653             _raise_error_network("nozeroconf", valid)
654     for opt in opts:
655         if opt not in ("networking", "hostname", "nozeroconf"):
656             result[opt] = "{1}{0}{1}".format(
657                 salt.utils.stringutils.dequote(opts[opt]), quote_type
658             )
659     return result
660 def _raise_error_iface(iface, option, expected):
661     msg = _error_msg_iface(iface, option, expected)
662     log.error(msg)
663     raise AttributeError(msg)
664 def _raise_error_network(option, expected):
665     msg = _error_msg_network(option, expected)
666     log.error(msg)
667     raise AttributeError(msg)
668 def _raise_error_routes(iface, option, expected):
669     msg = _error_msg_routes(iface, option, expected)
670     log.error(msg)
671     raise AttributeError(msg)
672 def _read_file(path):
673     try:
674         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(path, "rb") as rfh:
675             lines = salt.utils.stringutils.to_unicode(rfh.read(</b></font>)).splitlines()
676             try:
677                 lines.remove("")
678             except ValueError:
679                 pass
680             return lines
681     except Exception:  # pylint: disable=broad-except
682         return []  # Return empty list for type consistency
683 def _write_file_iface(iface, data, folder, pattern):
684     filename = os.path.join(folder, pattern.format(iface))
685     if not os.path.exists(folder):
686         msg = "{0} cannot be written. {1} does not exist"
687         msg = msg.format(filename, folder)
688         log.error(msg)
689         raise AttributeError(msg)
690     with salt.utils.files.fopen(filename, "w") as fp_:
691         fp_.write(salt.utils.stringutils.to_str(data))
692 def _write_file_network(data, filename):
693     with salt.utils.files.fopen(filename, "w") as fp_:
694         fp_.write(salt.utils.stringutils.to_str(data))
695 def _read_temp(data):
696     lines = data.splitlines()
697     try:  # Discard newlines if they exist
698         lines.remove("")
699     except ValueError:
700         pass
701     return lines
702 def build_interface(iface, iface_type, enabled, **settings):
703     if __grains__["os"] == "Fedora":
704         if __grains__["osmajorrelease"] &gt;= 28:
705             rh_major = "8"
706         else:
707             rh_major = "7"
708     elif __grains__["os"] == "Amazon":
709         rh_major = "7"
710     else:
711         rh_major = __grains__["osrelease"][:1]
712     iface_type = iface_type.lower()
713     if iface_type not in _IFACE_TYPES:
714         _raise_error_iface(iface, iface_type, _IFACE_TYPES)
715     if iface_type == "slave":
716         settings["slave"] = "yes"
717         if "master" not in settings:
718             msg = "master is a required setting for slave interfaces"
719             log.error(msg)
720             raise AttributeError(msg)
721     if iface_type == "bond":
722         if "mode" not in settings:
723             msg = "mode is required for bond interfaces"
724             log.error(msg)
725             raise AttributeError(msg)
726         settings["mode"] = str(settings["mode"])
727     if iface_type == "teamport":
728         if "master" not in settings and "team_master" not in settings:
729             msg = "master or team_master is a required setting for teamport interfaces"
730             log.error(msg)
731             raise AttributeError(msg)
732         elif "master" in settings and "team_master" in settings:
733             log.warning(
734                 "Both team_master (%s) and master (%s) were configured "
735                 "for teamport interface %s. Ignoring master in favor of "
736                 "team_master.",
737                 settings["team_master"],
738                 settings["master"],
739                 iface,
740             )
741             del settings["master"]
742         elif "master" in settings:
743             settings["team_master"] = settings.pop("master")
744     if iface_type == "vlan":
745         settings["vlan"] = "yes"
746     if iface_type == "bridge" and not __salt__["pkg.version"]("bridge-utils"):
747         __salt__["pkg.install"]("bridge-utils")
748     if iface_type == "team" and not __salt__["pkg.version"]("teamd"):
749         __salt__["pkg.install"]("teamd")
750     if iface_type in (
751         "eth",
752         "bond",
753         "team",
754         "teamport",
755         "bridge",
756         "slave",
757         "vlan",
758         "ipip",
759         "ib",
760         "alias",
761     ):
762         opts = _parse_settings_eth(settings, iface_type, enabled, iface)
763         try:
764             template = JINJA.get_template("rh{}_eth.jinja".format(rh_major))
765         except jinja2.exceptions.TemplateNotFound:
766             log.error("Could not load template rh%s_eth.jinja", rh_major)
767             return ""
768         ifcfg = template.render(opts)
769     if settings.get("test"):
770         return _read_temp(ifcfg)
771     _write_file_iface(iface, ifcfg, _RH_NETWORK_SCRIPT_DIR, "ifcfg-{0}")
772     path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "ifcfg-{}".format(iface))
773     return _read_file(path)
774 def build_routes(iface, **settings):
775     template = "rh6_route_eth.jinja"
776     try:
777         if int(__grains__["osrelease"][0]) &lt; 6:
778             template = "route_eth.jinja"
779     except ValueError:
780         pass
781     log.debug("Template name: %s", template)
782     opts = _parse_routes(iface, settings)
783     log.debug("Opts: \n %s", opts)
784     try:
785         template = JINJA.get_template(template)
786     except jinja2.exceptions.TemplateNotFound:
787         log.error("Could not load template %s", template)
788         return ""
789     opts6 = []
790     opts4 = []
791     for route in opts["routes"]:
792         ipaddr = route["ipaddr"]
793         if salt.utils.validate.net.ipv6_addr(ipaddr):
794             opts6.append(route)
795         else:
796             opts4.append(route)
797     log.debug("IPv4 routes:\n%s", opts4)
798     log.debug("IPv6 routes:\n%s", opts6)
799     routecfg = template.render(routes=opts4, iface=iface)
800     routecfg6 = template.render(routes=opts6, iface=iface)
801     if settings["test"]:
802         routes = _read_temp(routecfg)
803         routes.extend(_read_temp(routecfg6))
804         return routes
805     _write_file_iface(iface, routecfg, _RH_NETWORK_SCRIPT_DIR, "route-{0}")
806     _write_file_iface(iface, routecfg6, _RH_NETWORK_SCRIPT_DIR, "route6-{0}")
807     path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route-{}".format(iface))
808     path6 = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route6-{}".format(iface))
809     routes = _read_file(path)
810     routes.extend(_read_file(path6))
811     return routes
812 def down(iface, iface_type):
813     if iface_type.lower() not in ("slave", "teamport"):
814         return __salt__["cmd.run"]("ifdown {}".format(iface))
815     return None
816 def get_interface(iface):
817     path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "ifcfg-{}".format(iface))
818     return _read_file(path)
819 def up(iface, iface_type):  # pylint: disable=C0103
820     if iface_type.lower() not in ("slave", "teamport"):
821         return __salt__["cmd.run"]("ifup {}".format(iface))
822     return None
823 def get_routes(iface):
824     path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route-{}".format(iface))
825     path6 = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route6-{}".format(iface))
826     routes = _read_file(path)
827     routes.extend(_read_file(path6))
828     return routes
829 def get_network_settings():
830     return _read_file(_RH_NETWORK_FILE)
831 def apply_network_settings(**settings):
832     if "require_reboot" not in settings:
833         settings["require_reboot"] = False
834     if "apply_hostname" not in settings:
835         settings["apply_hostname"] = False
836     hostname_res = True
837     if settings["apply_hostname"] in _CONFIG_TRUE:
838         if "hostname" in settings:
839             hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
840         else:
841             log.warning(
842                 "The network state sls is trying to apply hostname "
843                 "changes but no hostname is defined."
844             )
845             hostname_res = False
846     res = True
847     if settings["require_reboot"] in _CONFIG_TRUE:
848         log.warning(
849             "The network state sls is requiring a reboot of the system to "
850             "properly apply network configuration."
851         )
852         res = True
853     else:
854         if __grains__["osmajorrelease"] &gt;= 8:
855             res = __salt__["service.restart"]("NetworkManager")
856         else:
857             res = __salt__["service.restart"]("network")
858     return hostname_res and res
859 def build_network_settings(**settings):
860     current_network_settings = _parse_rh_config(_RH_NETWORK_FILE)
861     opts = _parse_network_settings(settings, current_network_settings)
862     try:
863         template = JINJA.get_template("network.jinja")
864     except jinja2.exceptions.TemplateNotFound:
865         log.error("Could not load template network.jinja")
866         return ""
867     network = template.render(opts)
868     if settings["test"]:
869         return _read_temp(network)
870     _write_file_network(network, _RH_NETWORK_FILE)
871     return _read_file(_RH_NETWORK_FILE)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
