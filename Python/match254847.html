<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for stateconf.py &amp; rh_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for stateconf.py &amp; rh_ip.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>stateconf.py (1.6689847%)<th>rh_ip.py (0.7566204%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(209-210)<td><a href="#" name="0">(960-961)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>stateconf.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import getopt
import io
import logging
import os
import re
from itertools import chain
import salt.utils.files
import salt.utils.stringutils
from salt.exceptions import SaltRenderError
__all__ = ["render"]
log = logging.getLogger(__name__)
__opts__ = {
    "stateconf_end_marker": r"#\s*-+\s*end of state config\s*-+",
    "stateconf_start_state": ".start",
    "stateconf_goal_state": ".goal",
    "stateconf_state_func": "stateconf.set"
}
STATE_FUNC = STATE_NAME = ""
def __init__(opts):
    global STATE_NAME, STATE_FUNC
    STATE_FUNC = __opts__["stateconf_state_func"]
    STATE_NAME = STATE_FUNC.split(".")[0]
MOD_BASENAME = os.path.basename(__file__)
INVALID_USAGE_ERROR = SaltRenderError(
    "Invalid use of {0} renderer!\n"
        MOD_BASENAME
    )
)
def render(input, saltenv="base", sls="", argline="", **kws):
    gen_start_state = False
    no_goal_state = False
    implicit_require = False
    def process_sls_data(data, context=None, extract=False):
        sls_dir = os.path.dirname(sls.replace(".", os.path.sep)) if "." in sls else sls
        ctx = dict(sls_dir=sls_dir if sls_dir else ".")
        if context:
            ctx.update(context)
        tmplout = render_template(
            io.StringIO(data),
            saltenv,
            sls,
            context=ctx,
            argline=rt_argline.strip(),
            **kws
        )
        high = render_data(tmplout, saltenv, sls, argline=rd_argline.strip())
        return process_high_data(high, extract)
    def process_high_data(high, extract):
        data = copy.deepcopy(high)
        try:
            rewrite_single_shorthand_state_decl(data)
            rewrite_sls_includes_excludes(data, sls, saltenv)
            if not extract and implicit_require:
                sid = has_names_decls(data)
                if sid:
                    raise SaltRenderError(
                        "'names' declaration(found in state id: {}) is "
                        "not supported with implicitly ordered states! You "
                        "should generate the states in a template for-loop "
                        "instead.".format(sid)
                    )
                add_implicit_requires(data)
            if gen_start_state:
                add_start_state(data, sls)
            if not extract and not no_goal_state:
                add_goal_state(data)
            rename_state_ids(data, sls)
            extract_state_confs(data)
        except SaltRenderError:
            raise
        except Exception as err:  # pylint: disable=broad-except
            log.exception(
                "Error found while pre-processing the salt file %s:\n%s", sls, err
            )
            from salt.state import State
            state = State(__opts__)
            errors = state.verify_high(high)
            if errors:
                raise SaltRenderError("\n".join(errors))
            raise SaltRenderError("sls preprocessing/rendering failed!")
        return data
    renderers = kws["renderers"]
    opts, args = getopt.getopt(argline.split(), "Gosp")
    argline = " ".join(args) if args else "yaml . jinja"
    if ("-G", "") in opts:
        no_goal_state = True
    if ("-o", "") in opts:
        implicit_require = True
    if ("-s", "") in opts:
        gen_start_state = True
    if ("-p", "") in opts:
        data = process_high_data(input, extract=False)
    else:
        args = [
            arg.strip().replace("\\.", ".")
            for arg in re.split(r"\s+(?&lt;!\\)\.\s+", argline, 1)
        ]
        try:
            name, rd_argline = (args[0] + " ").split(" ", 1)
            render_data = renderers[name]  # e.g., the yaml renderer
            if implicit_require:
                if name == "yaml":
                    rd_argline = "-o " + rd_argline
                else:
                    raise SaltRenderError(
                        "Implicit ordering is only supported if the yaml renderer "
                        "is used!"
                    )
            name, rt_argline = (args[1] + " ").split(" ", 1)
            render_template = renderers[name]  # e.g., the mako renderer
        except KeyError as err:
            raise SaltRenderError("Renderer: {} is not available!".format(err))
        except IndexError:
<a name="0"></a>            raise INVALID_USAGE_ERROR
        if isinstance(input, str):
            <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(input, "r") as ifile:
                sls_templ = salt.utils.stringutils.to_unicode(ifile.read(</b></font>))
        else:  # assume file-like
            sls_templ = salt.utils.stringutils.to_unicode(input.read())
        match = re.search(__opts__["stateconf_end_marker"], sls_templ)
        if match:
            process_sls_data(sls_templ[: match.start()], extract=True)
        if STATE_CONF:
            tmplctx = STATE_CONF.copy()
            if tmplctx:
                prefix = sls + "::"
                tmplctx = {
                    k[len(prefix) :] if k.startswith(prefix) else k: v
                    for k, v in tmplctx.items()
                }
        else:
            tmplctx = {}
        data = process_sls_data(sls_templ, tmplctx)
    if log.isEnabledFor(logging.DEBUG):
        import pprint  # FIXME: pprint OrderedDict
        log.debug("Rendered sls: %s", pprint.pformat(data))
    return data
def has_names_decls(data):
    for sid, _, _, args in statelist(data):
        if sid == "extend":
            continue
        for _ in nvlist(args, ["names"]):
            return sid
def rewrite_single_shorthand_state_decl(data):  # pylint: disable=C0103
    for sid, states in data.items():
        if isinstance(states, str):
            data[sid] = {states: []}
def rewrite_sls_includes_excludes(data, sls, saltenv):
    for sid in data:
        if sid == "include":
            includes = data[sid]
            for i, each in enumerate(includes):
                if isinstance(each, dict):
                    slsenv, incl = each.popitem()
                else:
                    slsenv = saltenv
                    incl = each
                if incl.startswith("."):
                    includes[i] = {slsenv: _relative_to_abs_sls(incl, sls)}
        elif sid == "exclude":
            for sdata in data[sid]:
                if "sls" in sdata and sdata["sls"].startswith("."):
                    sdata["sls"] = _relative_to_abs_sls(sdata["sls"], sls)
def _local_to_abs_sid(sid, sls):  # id must starts with '.'
    if "::" in sid:
        return _relative_to_abs_sls(sid, sls)
    else:
        abs_sls = _relative_to_abs_sls(sid, sls + ".")
        return "::".join(abs_sls.rsplit(".", 1))
def _relative_to_abs_sls(relative, sls):
    levels, suffix = re.match(r"^(\.+)(.*)$", relative).groups()
    level_count = len(levels)
    p_comps = sls.split(".")
    if level_count &gt; len(p_comps):
        raise SaltRenderError(
            "Attempted relative include goes beyond top level package"
        )
    return ".".join(p_comps[:-level_count] + [suffix])
def nvlist(thelist, names=None):
    for nvitem in thelist:
        if isinstance(nvitem, dict):
            name, value = next(iter(nvitem.items()))
            if names is None or name in names:
                yield nvitem, name, value
def nvlist2(thelist, names=None):
    for _, _, value in nvlist(thelist, names):
        yield from nvlist(value)
def statelist(states_dict, sid_excludes=frozenset(["include", "exclude"])):
    for sid, states in states_dict.items():
        if sid.startswith("__"):
            continue
        if sid in sid_excludes:
            continue
        for sname, args in states.items():
            if sname.startswith("__"):
                continue
            yield sid, states, sname, args
REQUISITES = (
    "require",
    "require_in",
    "watch",
    "watch_in",
    "use",
    "use_in",
    "listen",
    "listen_in",
    "onchanges",
    "onchanges_in",
    "onfail",
    "onfail_in",
)
def rename_state_ids(data, sls, is_extend=False):
    if "extend" in data and not is_extend:
        rename_state_ids(data["extend"], sls, True)
    for sid, _, _, args in statelist(data):
        for req, sname, sid in nvlist2(args, REQUISITES):
            if sid.startswith("."):
                req[sname] = _local_to_abs_sid(sid, sls)
    for sid in list(data):
        if sid.startswith("."):
            newsid = _local_to_abs_sid(sid, sls)
            if newsid in data:
                raise SaltRenderError(
                    "Can't rename state id({}) into {} because the later "
                    "already exists!".format(sid, newsid)
                )
            for sname, args in data[sid].items():
                if state_name(sname) == STATE_NAME:
                    continue
                for arg in args:
                    if isinstance(arg, dict) and next(iter(arg)) == "name":
                        break
                else:
                    args.insert(0, dict(name=sid[1:]))
            data[newsid] = data[sid]
            del data[sid]
REQUIRE = ("require", "watch", "listen", "onchanges", "onfail")
REQUIRE_IN = ("require_in", "watch_in", "listen_in", "onchanges_in", "onfail_in")
EXTENDED_REQUIRE = {}
EXTENDED_REQUIRE_IN = {}
def add_implicit_requires(data):
    def T(sid, state):  # pylint: disable=C0103
        return "{}:{}".format(sid, state_name(state))
    states_before = set()
    states_after = set()
    for sid in data:
        for state in data[sid]:
            states_after.add(T(sid, state))
    prev_state = (None, None)  # (state_name, sid)
    for sid, states, sname, args in statelist(data):
        if sid == "extend":
            for esid, _, _, eargs in statelist(states):
                for _, rstate, rsid in nvlist2(eargs, REQUIRE):
                    EXTENDED_REQUIRE.setdefault(T(esid, rstate), []).append(
                        (None, rstate, rsid)
                    )
                for _, rstate, rsid in nvlist2(eargs, REQUIRE_IN):
                    EXTENDED_REQUIRE_IN.setdefault(T(esid, rstate), []).append(
                        (None, rstate, rsid)
                    )
            continue
        tag = T(sid, sname)
        states_after.remove(tag)
        reqs = nvlist2(args, REQUIRE)
        if tag in EXTENDED_REQUIRE:
            reqs = chain(reqs, EXTENDED_REQUIRE[tag])
        for _, rstate, rsid in reqs:
            if T(rsid, rstate) in states_after:
                raise SaltRenderError(
                    "State({}) can't require/watch/listen/onchanges/onfail a state({})"
                    " defined after it!".format(tag, T(rsid, rstate))
                )
        reqs = nvlist2(args, REQUIRE_IN)
        if tag in EXTENDED_REQUIRE_IN:
            reqs = chain(reqs, EXTENDED_REQUIRE_IN[tag])
        for _, rstate, rsid in reqs:
            if T(rsid, rstate) in states_before:
                raise SaltRenderError(
                    "State({}) can't"
                    " require_in/watch_in/listen_in/onchanges_in/onfail_in a state({})"
                    " defined before it!".format(tag, T(rsid, rstate))
                )
        if prev_state[0] is not None:
            try:
                next(nvlist(args, ["require"]))[2].insert(0, dict([prev_state]))
            except StopIteration:  # i.e., there's no require
                args.append(dict(require=[dict([prev_state])]))
        states_before.add(tag)
        prev_state = (state_name(sname), sid)
def add_start_state(data, sls):
    start_sid = __opts__["stateconf_start_state"]
    if start_sid in data:
        raise SaltRenderError(
            "Can't generate start state({})! The same state id already exists!".format(
                start_sid
            )
        )
    if not data:
        return
    non_sids = ("include", "exclude", "extend")
    for sid, states in data.items():
        if sid in non_sids or sid.startswith("__"):
            continue
        if "__sls__" not in states or states["__sls__"] == sls:
            break
    else:
        raise SaltRenderError("Can't determine the first state in the sls file!")
    reqin = {state_name(next(iter(data[sid].keys()))): sid}
    data[start_sid] = {STATE_FUNC: [{"require_in": [reqin]}]}
def add_goal_state(data):
    goal_sid = __opts__["stateconf_goal_state"]
    if goal_sid in data:
        raise SaltRenderError(
            "Can't generate goal state({})! The same state id already exists!".format(
                goal_sid
            )
        )
    else:
        reqlist = []
        for sid, states, state, _ in statelist(data, ("include", "exclude", "extend")):
            if "__sls__" in states:
                continue
            reqlist.append({state_name(state): sid})
        data[goal_sid] = {STATE_FUNC: [dict(require=reqlist)]}
def state_name(sname):
    return sname.split(".", 1)[0]
class Bunch(dict):
    def __getattr__(self, name):
        return self[name]
STATE_CONF = {}  # stateconf.set
STATE_CONF_EXT = {}  # stateconf.set under extend: ...
def extract_state_confs(data, is_extend=False):
    for state_id, state_dict in data.items():
        if state_id == "extend" and not is_extend:
            extract_state_confs(state_dict, True)
            continue
        if STATE_NAME in state_dict:
            key = STATE_NAME
        elif STATE_FUNC in state_dict:
            key = STATE_FUNC
        else:
            continue
        to_dict = STATE_CONF_EXT if is_extend else STATE_CONF
        conf = to_dict.setdefault(state_id, Bunch())
        for sdk in state_dict[key]:
            if not isinstance(sdk, dict):
                continue
            key, val = next(iter(sdk.items()))
            conf[key] = val
        if not is_extend and state_id in STATE_CONF_EXT:
            extend = STATE_CONF_EXT[state_id]
            for requisite in "require", "watch", "listen", "onchanges", "onfail":
                if requisite in extend:
                    extend[requisite] += to_dict[state_id].get(requisite, [])
            to_dict[state_id].update(STATE_CONF_EXT[state_id])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>rh_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
import jinja2
import jinja2.exceptions
import salt.utils.files
import salt.utils.json
import salt.utils.stringutils
import salt.utils.templates
import salt.utils.validate.net
from salt.exceptions import CommandExecutionError
log = logging.getLogger(__name__)
JINJA = jinja2.Environment(
    loader=jinja2.FileSystemLoader(
        os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "rh_ip")
    )
)
__virtualname__ = "ip"
_BOND_DEFAULTS = {
    "ad_select": "0",
    "tx_queues": "16",
    "lacp_rate": "0",
    "max_bonds": "1",
    "use_carrier": "0",
    "xmit_hash_policy": "layer2",
}
_RH_NETWORK_SCRIPT_DIR = "/etc/sysconfig/network-scripts"
_RH_NETWORK_FILE = "/etc/sysconfig/network"
_CONFIG_TRUE = ("yes", "on", "true", "1", True)
_CONFIG_FALSE = ("no", "off", "false", "0", False)
_IFACE_TYPES = (
    "eth",
    "bond",
    "team",
    "alias",
    "clone",
    "ipsec",
    "dialup",
    "bridge",
    "slave",
    "teamport",
    "vlan",
    "ipip",
    "ib",
)
def __virtual__():
    if __grains__["os_family"] == "RedHat":
        if __grains__["os"] == "Amazon":
            if __grains__["osmajorrelease"] &gt;= 2:
                return __virtualname__
        else:
            return __virtualname__
    return (
        False,
        "The rh_ip execution module cannot be loaded: this module is only available on"
        " RHEL/Fedora based distributions.",
    )
def _error_msg_iface(iface, option, expected):
    if isinstance(expected, str):
        expected = (expected,)
    msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
    return msg.format(iface, option, "|".join(str(e) for e in expected))
def _error_msg_routes(iface, option, expected):
    msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
    return msg.format(iface, option, expected)
def _log_default_iface(iface, opt, value):
    log.info(
        "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
    )
def _error_msg_network(option, expected):
    if isinstance(expected, str):
        expected = (expected,)
    msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
    return msg.format(option, "|".join(str(e) for e in expected))
def _log_default_network(opt, value):
    log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
def _parse_rh_config(path):
    rh_config = _read_file(path)
    cv_rh_config = {}
    if rh_config:
        for line in rh_config:
            line = line.strip()
            if len(line) == 0 or line.startswith("!") or line.startswith("#"):
                continue
            pair = [p.rstrip() for p in line.split("=", 1)]
            if len(pair) != 2:
                continue
            name, value = pair
            cv_rh_config[name.upper()] = value
    return cv_rh_config
def _parse_ethtool_opts(opts, iface):
    config = {}
    if "autoneg" in opts:
        if opts["autoneg"] in _CONFIG_TRUE:
            config.update({"autoneg": "on"})
        elif opts["autoneg"] in _CONFIG_FALSE:
            config.update({"autoneg": "off"})
        else:
            _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
    if "duplex" in opts:
        valid = ["full", "half"]
        if opts["duplex"] in valid:
            config.update({"duplex": opts["duplex"]})
        else:
            _raise_error_iface(iface, "duplex", valid)
    if "speed" in opts:
        valid = ["10", "100", "1000", "10000"]
        if str(opts["speed"]) in valid:
            config.update({"speed": opts["speed"]})
        else:
            _raise_error_iface(iface, opts["speed"], valid)
    if "advertise" in opts:
        valid = [
            "0x001",
            "0x002",
            "0x004",
            "0x008",
            "0x010",
            "0x020",
            "0x20000",
            "0x8000",
            "0x1000",
            "0x40000",
            "0x80000",
            "0x200000",
            "0x400000",
            "0x800000",
            "0x1000000",
            "0x2000000",
            "0x4000000",
        ]
        if str(opts["advertise"]) in valid:
            config.update({"advertise": opts["advertise"]})
        else:
            _raise_error_iface(iface, "advertise", valid)
    if "channels" in opts:
        channels_cmd = "-L {}".format(iface.strip())
        channels_params = []
        for option in ("rx", "tx", "other", "combined"):
            if option in opts["channels"]:
                valid = range(1, __grains__["num_cpus"] + 1)
                if opts["channels"][option] in valid:
                    channels_params.append(
                        "{} {}".format(option, opts["channels"][option])
                    )
                else:
                    _raise_error_iface(iface, opts["channels"][option], valid)
        if channels_params:
            config.update({channels_cmd: " ".join(channels_params)})
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: "on"})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: "off"})
            else:
                _raise_error_iface(iface, option, valid)
    return config
def _parse_settings_bond(opts, iface):
    if opts["mode"] in ("balance-rr", "0"):
        log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
        return _parse_settings_bond_0(opts, iface)
    elif opts["mode"] in ("active-backup", "1"):
        log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
        return _parse_settings_bond_1(opts, iface)
    elif opts["mode"] in ("balance-xor", "2"):
        log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
        return _parse_settings_bond_2(opts, iface)
    elif opts["mode"] in ("broadcast", "3"):
        log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
        return _parse_settings_bond_3(opts, iface)
    elif opts["mode"] in ("802.3ad", "4"):
        log.info(
            "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
        )
        return _parse_settings_bond_4(opts, iface)
    elif opts["mode"] in ("balance-tlb", "5"):
        log.info("Device: %s Bonding Mode: transmit load balancing", iface)
        return _parse_settings_bond_5(opts, iface)
    elif opts["mode"] in ("balance-alb", "6"):
        log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
        return _parse_settings_bond_6(opts, iface)
    else:
        valid = (
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "balance-rr",
            "active-backup",
            "balance-xor",
            "broadcast",
            "802.3ad",
            "balance-tlb",
            "balance-alb",
        )
        _raise_error_iface(iface, "mode", valid)
def _parse_settings_miimon(opts, iface):
    ret = {}
    for binding in ("miimon", "downdelay", "updelay"):
        if binding in opts:
            try:
                int(opts[binding])
                ret.update({binding: opts[binding]})
            except Exception:  # pylint: disable=broad-except
                _raise_error_iface(iface, binding, "integer")
    if "miimon" in opts and "downdelay" not in opts:
        ret["downdelay"] = ret["miimon"] * 2
    if "miimon" in opts:
        if not opts["miimon"]:
            _raise_error_iface(iface, "miimon", "nonzero integer")
        for binding in ("downdelay", "updelay"):
            if binding in ret:
                if ret[binding] % ret["miimon"]:
                    _raise_error_iface(
                        iface,
                        binding,
                        "0 or a multiple of miimon ({})".format(ret["miimon"]),
                    )
        if "use_carrier" in opts:
            if opts["use_carrier"] in _CONFIG_TRUE:
                ret.update({"use_carrier": "1"})
            elif opts["use_carrier"] in _CONFIG_FALSE:
                ret.update({"use_carrier": "0"})
            else:
                valid = _CONFIG_TRUE + _CONFIG_FALSE
                _raise_error_iface(iface, "use_carrier", valid)
        else:
            _log_default_iface(iface, "use_carrier", _BOND_DEFAULTS["use_carrier"])
            ret.update({"use_carrier": _BOND_DEFAULTS["use_carrier"]})
    return ret
def _parse_settings_arp(opts, iface):
    ret = {}
    if "arp_interval" in opts:
        try:
            int(opts["arp_interval"])
            ret.update({"arp_interval": opts["arp_interval"]})
        except Exception:  # pylint: disable=broad-except
            _raise_error_iface(iface, "arp_interval", "integer")
        valid = "list of ips (up to 16)"
        if "arp_ip_target" in opts:
            if isinstance(opts["arp_ip_target"], list):
                if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
                    ret.update({"arp_ip_target": ",".join(opts["arp_ip_target"])})
                else:
                    _raise_error_iface(iface, "arp_ip_target", valid)
            else:
                _raise_error_iface(iface, "arp_ip_target", valid)
        else:
            _raise_error_iface(iface, "arp_ip_target", valid)
    return ret
def _parse_settings_bond_0(opts, iface):
    bond = {"mode": "0"}
    bond.update(_parse_settings_miimon(opts, iface))
    bond.update(_parse_settings_arp(opts, iface))
    if "miimon" not in opts and "arp_interval" not in opts:
        _raise_error_iface(
            iface, "miimon or arp_interval", "at least one of these is required"
        )
    return bond
def _parse_settings_bond_1(opts, iface):
    bond = {"mode": "1"}
    bond.update(_parse_settings_miimon(opts, iface))
    if "miimon" not in opts:
        _raise_error_iface(iface, "miimon", "integer")
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    return bond
def _parse_settings_bond_2(opts, iface):
    bond = {"mode": "2"}
    bond.update(_parse_settings_miimon(opts, iface))
    bond.update(_parse_settings_arp(opts, iface))
    if "miimon" not in opts and "arp_interval" not in opts:
        _raise_error_iface(
            iface, "miimon or arp_interval", "at least one of these is required"
        )
    if "hashing-algorithm" in opts:
        valid = ("layer2", "layer2+3", "layer3+4")
        if opts["hashing-algorithm"] in valid:
            bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
        else:
            _raise_error_iface(iface, "hashing-algorithm", valid)
    return bond
def _parse_settings_bond_3(opts, iface):
    bond = {"mode": "3"}
    bond.update(_parse_settings_miimon(opts, iface))
    if "miimon" not in opts:
        _raise_error_iface(iface, "miimon", "integer")
    return bond
def _parse_settings_bond_4(opts, iface):
    bond = {"mode": "4"}
    bond.update(_parse_settings_miimon(opts, iface))
    if "miimon" not in opts:
        _raise_error_iface(iface, "miimon", "integer")
    for binding in ("lacp_rate", "ad_select"):
        if binding in opts:
            if binding == "lacp_rate":
                valid = ("fast", "1", "slow", "0")
                if opts[binding] not in valid:
                    _raise_error_iface(iface, binding, valid)
                if opts[binding] == "fast":
                    opts.update({binding: "1"})
                if opts[binding] == "slow":
                    opts.update({binding: "0"})
            else:
                valid = "integer"
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except Exception:  # pylint: disable=broad-except
                _raise_error_iface(iface, binding, valid)
        else:
            _log_default_iface(iface, binding, _BOND_DEFAULTS[binding])
            bond.update({binding: _BOND_DEFAULTS[binding]})
    if "hashing-algorithm" in opts:
        if __grains__["os_family"] == "RedHat":
            if __grains__["osmajorrelease"] &lt; 8:
                valid = ("layer2", "layer2+3", "layer3+4", "encap2+3", "encap3+4")
            else:
                valid = (
                    "layer2",
                    "layer2+3",
                    "layer3+4",
                    "encap2+3",
                    "encap3+4",
                    "vlan+srcmac",
                )
        if opts["hashing-algorithm"] in valid:
            bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
        else:
            _raise_error_iface(iface, "hashing-algorithm", valid)
    return bond
def _parse_settings_bond_5(opts, iface):
    bond = {"mode": "5"}
    bond.update(_parse_settings_miimon(opts, iface))
    if "miimon" not in opts:
        _raise_error_iface(iface, "miimon", "integer")
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    return bond
def _parse_settings_bond_6(opts, iface):
    bond = {"mode": "6"}
    bond.update(_parse_settings_miimon(opts, iface))
    if "miimon" not in opts:
        _raise_error_iface(iface, "miimon", "integer")
    if "primary" in opts:
        bond.update({"primary": opts["primary"]})
    return bond
def _parse_settings_vlan(opts, iface):
    vlan = {}
    if "reorder_hdr" in opts:
        if opts["reorder_hdr"] in _CONFIG_TRUE + _CONFIG_FALSE:
            vlan.update({"reorder_hdr": opts["reorder_hdr"]})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, "reorder_hdr", valid)
    if "vlan_id" in opts:
        if opts["vlan_id"] &gt; 0:
            vlan.update({"vlan_id": opts["vlan_id"]})
        else:
            _raise_error_iface(iface, "vlan_id", "Positive integer")
    if "phys_dev" in opts:
        if len(opts["phys_dev"]) &gt; 0:
            vlan.update({"phys_dev": opts["phys_dev"]})
        else:
            _raise_error_iface(iface, "phys_dev", "Non-empty string")
    return vlan
def _parse_settings_eth(opts, iface_type, enabled, iface):
    result = {"name": iface}
    if "proto" in opts:
        valid = ["none", "bootp", "dhcp"]
        if opts["proto"] in valid:
            result["proto"] = opts["proto"]
        else:
            _raise_error_iface(iface, opts["proto"], valid)
    if "dns" in opts:
        result["dns"] = opts["dns"]
        result["peerdns"] = "yes"
    if "mtu" in opts:
        try:
            result["mtu"] = int(opts["mtu"])
        except ValueError:
            _raise_error_iface(iface, "mtu", ["integer"])
    if "hwaddr" in opts and "macaddr" in opts:
        msg = "Cannot pass both hwaddr and macaddr. Must use either hwaddr or macaddr"
        log.error(msg)
        raise AttributeError(msg)
    if iface_type not in ("bridge",):
        ethtool = _parse_ethtool_opts(opts, iface)
        if ethtool:
            result["ethtool"] = " ".join(
                ["{} {}".format(x, y) for x, y in ethtool.items()]
            )
    if iface_type == "slave":
        result["proto"] = "none"
    if iface_type == "team":
        result["devicetype"] = "Team"
        if "team_config" in opts:
            result["team_config"] = salt.utils.json.dumps(opts["team_config"])
    if iface_type == "teamport":
        result["devicetype"] = "TeamPort"
        result["team_master"] = opts["team_master"]
        if "team_port_config" in opts:
            result["team_port_config"] = salt.utils.json.dumps(opts["team_port_config"])
    if iface_type == "bond":
        if "mode" not in opts:
            msg = "Missing required option 'mode'"
            log.error("%s for bond interface '%s'", msg, iface)
            raise AttributeError(msg)
        bonding = _parse_settings_bond(opts, iface)
        if bonding:
            result["bonding"] = " ".join(
                ["{}={}".format(x, y) for x, y in bonding.items()]
            )
            result["devtype"] = "Bond"
    if iface_type == "vlan":
        vlan = _parse_settings_vlan(opts, iface)
        if vlan:
            result["devtype"] = "Vlan"
            for opt in vlan:
                result[opt] = opts[opt]
    if iface_type not in ("bond", "team", "vlan", "bridge", "ipip"):
        auto_addr = False
        if "hwaddr" in opts:
            if salt.utils.validate.net.mac(opts["hwaddr"]):
                result["hwaddr"] = opts["hwaddr"]
            elif opts["hwaddr"] == "auto":
                auto_addr = True
            elif opts["hwaddr"] != "none":
                _raise_error_iface(
                    iface, opts["hwaddr"], ("AA:BB:CC:DD:EE:FF", "auto", "none")
                )
        else:
            auto_addr = True
        if auto_addr:
            if iface_type != "slave":
                ifaces = __salt__["network.interfaces"]()
                if iface in ifaces and "hwaddr" in ifaces[iface]:
                    result["hwaddr"] = ifaces[iface]["hwaddr"]
    if iface_type == "eth":
        result["devtype"] = "Ethernet"
    if iface_type == "bridge":
        result["devtype"] = "Bridge"
        bypassfirewall = True
        valid = _CONFIG_TRUE + _CONFIG_FALSE
        for opt in ("bypassfirewall",):
            if opt in opts:
                if opts[opt] in _CONFIG_TRUE:
                    bypassfirewall = True
                elif opts[opt] in _CONFIG_FALSE:
                    bypassfirewall = False
                else:
                    _raise_error_iface(iface, opts[opt], valid)
        bridgectls = [
            "net.bridge.bridge-nf-call-ip6tables",
            "net.bridge.bridge-nf-call-iptables",
            "net.bridge.bridge-nf-call-arptables",
        ]
        if bypassfirewall:
            sysctl_value = 0
        else:
            sysctl_value = 1
        for sysctl in bridgectls:
            try:
                __salt__["sysctl.persist"](sysctl, sysctl_value)
            except CommandExecutionError:
                log.warning("Failed to set sysctl: %s", sysctl)
    else:
        if "bridge" in opts:
            result["bridge"] = opts["bridge"]
    if iface_type == "ipip":
        result["devtype"] = "IPIP"
        for opt in ("my_inner_ipaddr", "my_outer_ipaddr"):
            if opt not in opts:
                _raise_error_iface(iface, opt, "1.2.3.4")
            else:
                result[opt] = opts[opt]
    if iface_type == "ib":
        result["devtype"] = "InfiniBand"
    if "prefix" in opts:
        if "netmask" in opts:
            msg = "Cannot use prefix and netmask together"
            log.error(msg)
            raise AttributeError(msg)
        result["prefix"] = opts["prefix"]
    elif "netmask" in opts:
        result["netmask"] = opts["netmask"]
    for opt in (
        "ipaddr",
        "master",
        "srcaddr",
        "delay",
        "domain",
        "gateway",
        "uuid",
        "nickname",
        "zone",
    ):
        if opt in opts:
            result[opt] = opts[opt]
    for opt in ("ipv6addr", "ipv6gateway"):
        if opt in opts:
            result[opt] = opts[opt]
    if "ipaddrs" in opts:
        result["ipaddrs"] = []
        for opt in opts["ipaddrs"]:
            if salt.utils.validate.net.ipv4_addr(opt):
                ip, prefix = (i.strip() for i in opt.split("/"))
                result["ipaddrs"].append({"ipaddr": ip, "prefix": prefix})
            else:
                msg = "ipv4 CIDR is invalid"
                log.error(msg)
                raise AttributeError(msg)
    if "ipv6addrs" in opts:
        for opt in opts["ipv6addrs"]:
            if not salt.utils.validate.net.ipv6_addr(opt):
                msg = "ipv6 CIDR is invalid"
                log.error(msg)
                raise AttributeError(msg)
            result["ipv6addrs"] = opts["ipv6addrs"]
    if "enable_ipv6" in opts:
        result["enable_ipv6"] = opts["enable_ipv6"]
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for opt in (
        "onparent",
        "peerdns",
        "peerroutes",
        "slave",
        "vlan",
        "defroute",
        "stp",
        "ipv6_peerdns",
        "ipv6_defroute",
        "ipv6_peerroutes",
        "ipv6_autoconf",
        "ipv4_failure_fatal",
        "dhcpv6c",
    ):
        if opt in opts:
            if opts[opt] in _CONFIG_TRUE:
                result[opt] = "yes"
            elif opts[opt] in _CONFIG_FALSE:
                result[opt] = "no"
            else:
                _raise_error_iface(iface, opts[opt], valid)
    if "onboot" in opts:
        log.warning(
            "The 'onboot' option is controlled by the 'enabled' option. "
            "Interface: %s Enabled: %s",
            iface,
            enabled,
        )
    if enabled:
        result["onboot"] = "yes"
    else:
        result["onboot"] = "no"
    if "userctl" in opts:
        if opts["userctl"] in _CONFIG_TRUE:
            result["userctl"] = "yes"
        elif opts["userctl"] in _CONFIG_FALSE:
            result["userctl"] = "no"
        else:
            _raise_error_iface(iface, opts["userctl"], valid)
    else:
        result["userctl"] = "no"
    if "vlan" in opts:
        if opts["vlan"] in _CONFIG_TRUE:
            result["vlan"] = "yes"
        elif opts["vlan"] in _CONFIG_FALSE:
            result["vlan"] = "no"
        else:
            _raise_error_iface(iface, opts["vlan"], valid)
    if "arpcheck" in opts:
        if opts["arpcheck"] in _CONFIG_FALSE:
            result["arpcheck"] = "no"
    if "ipaddr_start" in opts:
        result["ipaddr_start"] = opts["ipaddr_start"]
    if "ipaddr_end" in opts:
        result["ipaddr_end"] = opts["ipaddr_end"]
    if "clonenum_start" in opts:
        result["clonenum_start"] = opts["clonenum_start"]
    if "hwaddr" in opts:
        result["hwaddr"] = opts["hwaddr"]
    if "macaddr" in opts:
        result["macaddr"] = opts["macaddr"]
    if "nm_controlled" in opts:
        if opts["nm_controlled"] in _CONFIG_TRUE:
            result["nm_controlled"] = "yes"
        elif opts["nm_controlled"] in _CONFIG_FALSE:
            result["nm_controlled"] = "no"
        else:
            _raise_error_iface(iface, opts["nm_controlled"], valid)
    else:
        result["nm_controlled"] = "no"
    return result
def _parse_routes(iface, opts):
    opts = {k.lower(): v for (k, v) in opts.items()}
    result = {}
    if "routes" not in opts:
        _raise_error_routes(iface, "routes", "List of routes")
    for opt in opts:
        result[opt] = opts[opt]
    return result
def _parse_network_settings(opts, current):
    opts = {k.lower(): v for (k, v) in opts.items()}
    current = {k.lower(): v for (k, v) in current.items()}
    retain_settings = opts.get("retain_settings", False)
    result = current if retain_settings else {}
    quote_type = ""
    valid = _CONFIG_TRUE + _CONFIG_FALSE
    if "enabled" not in opts:
        try:
            opts["networking"] = current["networking"]
            quote_type = salt.utils.stringutils.is_quoted(opts["networking"])
            _log_default_network("networking", current["networking"])
        except ValueError:
            _raise_error_network("networking", valid)
    else:
        opts["networking"] = opts["enabled"]
    true_val = "{0}yes{0}".format(quote_type)
    false_val = "{0}no{0}".format(quote_type)
    networking = salt.utils.stringutils.dequote(opts["networking"])
    if networking in valid:
        if networking in _CONFIG_TRUE:
            result["networking"] = true_val
        elif networking in _CONFIG_FALSE:
            result["networking"] = false_val
    else:
        _raise_error_network("networking", valid)
    if "hostname" not in opts:
        try:
            opts["hostname"] = current["hostname"]
            _log_default_network("hostname", current["hostname"])
        except Exception:  # pylint: disable=broad-except
            _raise_error_network("hostname", ["server1.example.com"])
    if opts["hostname"]:
        result["hostname"] = "{1}{0}{1}".format(
            salt.utils.stringutils.dequote(opts["hostname"]), quote_type
        )
    else:
        _raise_error_network("hostname", ["server1.example.com"])
    if "nozeroconf" in opts:
        nozeroconf = salt.utils.stringutils.dequote(opts["nozeroconf"])
        if nozeroconf in valid:
            if nozeroconf in _CONFIG_TRUE:
                result["nozeroconf"] = true_val
            elif nozeroconf in _CONFIG_FALSE:
                result["nozeroconf"] = false_val
        else:
            _raise_error_network("nozeroconf", valid)
    for opt in opts:
        if opt not in ("networking", "hostname", "nozeroconf"):
            result[opt] = "{1}{0}{1}".format(
                salt.utils.stringutils.dequote(opts[opt]), quote_type
            )
    return result
def _raise_error_iface(iface, option, expected):
    msg = _error_msg_iface(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _raise_error_network(option, expected):
    msg = _error_msg_network(option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _raise_error_routes(iface, option, expected):
    msg = _error_msg_routes(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)
def _read_file(path):
    try:
        <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(path, "rb") as rfh:
            lines = salt.utils.stringutils.to_unicode(rfh.read(</b></font>)).splitlines()
            try:
                lines.remove("")
            except ValueError:
                pass
            return lines
    except Exception:  # pylint: disable=broad-except
        return []  # Return empty list for type consistency
def _write_file_iface(iface, data, folder, pattern):
    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = "{0} cannot be written. {1} does not exist"
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.fopen(filename, "w") as fp_:
        fp_.write(salt.utils.stringutils.to_str(data))
def _write_file_network(data, filename):
    with salt.utils.files.fopen(filename, "w") as fp_:
        fp_.write(salt.utils.stringutils.to_str(data))
def _read_temp(data):
    lines = data.splitlines()
    try:  # Discard newlines if they exist
        lines.remove("")
    except ValueError:
        pass
    return lines
def build_interface(iface, iface_type, enabled, **settings):
    if __grains__["os"] == "Fedora":
        if __grains__["osmajorrelease"] &gt;= 28:
            rh_major = "8"
        else:
            rh_major = "7"
    elif __grains__["os"] == "Amazon":
        rh_major = "7"
    else:
        rh_major = __grains__["osrelease"][:1]
    iface_type = iface_type.lower()
    if iface_type not in _IFACE_TYPES:
        _raise_error_iface(iface, iface_type, _IFACE_TYPES)
    if iface_type == "slave":
        settings["slave"] = "yes"
        if "master" not in settings:
            msg = "master is a required setting for slave interfaces"
            log.error(msg)
            raise AttributeError(msg)
    if iface_type == "bond":
        if "mode" not in settings:
            msg = "mode is required for bond interfaces"
            log.error(msg)
            raise AttributeError(msg)
        settings["mode"] = str(settings["mode"])
    if iface_type == "teamport":
        if "master" not in settings and "team_master" not in settings:
            msg = "master or team_master is a required setting for teamport interfaces"
            log.error(msg)
            raise AttributeError(msg)
        elif "master" in settings and "team_master" in settings:
            log.warning(
                "Both team_master (%s) and master (%s) were configured "
                "for teamport interface %s. Ignoring master in favor of "
                "team_master.",
                settings["team_master"],
                settings["master"],
                iface,
            )
            del settings["master"]
        elif "master" in settings:
            settings["team_master"] = settings.pop("master")
    if iface_type == "vlan":
        settings["vlan"] = "yes"
    if iface_type == "bridge" and not __salt__["pkg.version"]("bridge-utils"):
        __salt__["pkg.install"]("bridge-utils")
    if iface_type == "team" and not __salt__["pkg.version"]("teamd"):
        __salt__["pkg.install"]("teamd")
    if iface_type in (
        "eth",
        "bond",
        "team",
        "teamport",
        "bridge",
        "slave",
        "vlan",
        "ipip",
        "ib",
        "alias",
    ):
        opts = _parse_settings_eth(settings, iface_type, enabled, iface)
        try:
            template = JINJA.get_template("rh{}_eth.jinja".format(rh_major))
        except jinja2.exceptions.TemplateNotFound:
            log.error("Could not load template rh%s_eth.jinja", rh_major)
            return ""
        ifcfg = template.render(opts)
    if settings.get("test"):
        return _read_temp(ifcfg)
    _write_file_iface(iface, ifcfg, _RH_NETWORK_SCRIPT_DIR, "ifcfg-{0}")
    path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "ifcfg-{}".format(iface))
    return _read_file(path)
def build_routes(iface, **settings):
    template = "rh6_route_eth.jinja"
    try:
        if int(__grains__["osrelease"][0]) &lt; 6:
            template = "route_eth.jinja"
    except ValueError:
        pass
    log.debug("Template name: %s", template)
    opts = _parse_routes(iface, settings)
    log.debug("Opts: \n %s", opts)
    try:
        template = JINJA.get_template(template)
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template %s", template)
        return ""
    opts6 = []
    opts4 = []
    for route in opts["routes"]:
        ipaddr = route["ipaddr"]
        if salt.utils.validate.net.ipv6_addr(ipaddr):
            opts6.append(route)
        else:
            opts4.append(route)
    log.debug("IPv4 routes:\n%s", opts4)
    log.debug("IPv6 routes:\n%s", opts6)
    routecfg = template.render(routes=opts4, iface=iface)
    routecfg6 = template.render(routes=opts6, iface=iface)
    if settings["test"]:
        routes = _read_temp(routecfg)
        routes.extend(_read_temp(routecfg6))
        return routes
    _write_file_iface(iface, routecfg, _RH_NETWORK_SCRIPT_DIR, "route-{0}")
    _write_file_iface(iface, routecfg6, _RH_NETWORK_SCRIPT_DIR, "route6-{0}")
    path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route-{}".format(iface))
    path6 = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route6-{}".format(iface))
    routes = _read_file(path)
    routes.extend(_read_file(path6))
    return routes
def down(iface, iface_type):
    if iface_type.lower() not in ("slave", "teamport"):
        return __salt__["cmd.run"]("ifdown {}".format(iface))
    return None
def get_interface(iface):
    path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "ifcfg-{}".format(iface))
    return _read_file(path)
def up(iface, iface_type):  # pylint: disable=C0103
    if iface_type.lower() not in ("slave", "teamport"):
        return __salt__["cmd.run"]("ifup {}".format(iface))
    return None
def get_routes(iface):
    path = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route-{}".format(iface))
    path6 = os.path.join(_RH_NETWORK_SCRIPT_DIR, "route6-{}".format(iface))
    routes = _read_file(path)
    routes.extend(_read_file(path6))
    return routes
def get_network_settings():
    return _read_file(_RH_NETWORK_FILE)
def apply_network_settings(**settings):
    if "require_reboot" not in settings:
        settings["require_reboot"] = False
    if "apply_hostname" not in settings:
        settings["apply_hostname"] = False
    hostname_res = True
    if settings["apply_hostname"] in _CONFIG_TRUE:
        if "hostname" in settings:
            hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
        else:
            log.warning(
                "The network state sls is trying to apply hostname "
                "changes but no hostname is defined."
            )
            hostname_res = False
    res = True
    if settings["require_reboot"] in _CONFIG_TRUE:
        log.warning(
            "The network state sls is requiring a reboot of the system to "
            "properly apply network configuration."
        )
        res = True
    else:
        if __grains__["osmajorrelease"] &gt;= 8:
            res = __salt__["service.restart"]("NetworkManager")
        else:
            res = __salt__["service.restart"]("network")
    return hostname_res and res
def build_network_settings(**settings):
    current_network_settings = _parse_rh_config(_RH_NETWORK_FILE)
    opts = _parse_network_settings(settings, current_network_settings)
    try:
        template = JINJA.get_template("network.jinja")
    except jinja2.exceptions.TemplateNotFound:
        log.error("Could not load template network.jinja")
        return ""
    network = template.render(opts)
    if settings["test"]:
        return _read_temp(network)
    _write_file_network(network, _RH_NETWORK_FILE)
    return _read_file(_RH_NETWORK_FILE)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
