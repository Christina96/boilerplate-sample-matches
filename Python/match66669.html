<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for digitalocean.py & vmware.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for digitalocean.py & vmware.py
      </h3>
      <h1 align="center">
        4.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>digitalocean.py (11.10414%)<TH>vmware.py (2.9888551%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#0',2,'match66669-1.html#0',3)" NAME="0">(269-300)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#0',2,'match66669-1.html#0',3)" NAME="0">(2715-2755)</A><TD ALIGN=center><FONT COLOR="#ff0000">29</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#1',2,'match66669-1.html#1',3)" NAME="1">(62-86)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#1',2,'match66669-1.html#1',3)" NAME="1">(167-191)</A><TD ALIGN=center><FONT COLOR="#d30000">24</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#2',2,'match66669-1.html#2',3)" NAME="2">(906-917)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#2',2,'match66669-1.html#2',3)" NAME="2">(2702-2712)</A><TD ALIGN=center><FONT COLOR="#af0000">20</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#3',2,'match66669-1.html#3',3)" NAME="3">(851-878)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#3',2,'match66669-1.html#3',3)" NAME="3">(2636-2665)</A><TD ALIGN=center><FONT COLOR="#9e0000">18</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#4',2,'match66669-1.html#4',3)" NAME="4">(27-52)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#4',2,'match66669-1.html#4',3)" NAME="4">(119-138)</A><TD ALIGN=center><FONT COLOR="#950000">17</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#5',2,'match66669-1.html#5',3)" NAME="5">(1022-1026)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#5',2,'match66669-1.html#5',3)" NAME="5">(593-598)</A><TD ALIGN=center><FONT COLOR="#8c0000">16</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#6',2,'match66669-1.html#6',3)" NAME="6">(584-598)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#6',2,'match66669-1.html#6',3)" NAME="6">(3365-3378)</A><TD ALIGN=center><FONT COLOR="#8c0000">16</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#7',2,'match66669-1.html#7',3)" NAME="7">(491-497)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#7',2,'match66669-1.html#7',3)" NAME="7">(3005-3013)</A><TD ALIGN=center><FONT COLOR="#720000">13</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#8',2,'match66669-1.html#8',3)" NAME="8">(427-429)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#8',2,'match66669-1.html#8',3)" NAME="8">(3224-3226)</A><TD ALIGN=center><FONT COLOR="#690000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match66669-0.html#9',2,'match66669-1.html#9',3)" NAME="9">(117-134)<TD><A HREF="javascript:ZweiFrames('match66669-0.html#9',2,'match66669-1.html#9',3)" NAME="9">(2070-2102)</A><TD ALIGN=center><FONT COLOR="#690000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>digitalocean.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
DigitalOcean Cloud Module
=========================

The DigitalOcean cloud module is used to control access to the DigitalOcean VPS system.

Use of this module requires a requires a ``personal_access_token``, an ``ssh_key_file``,
and at least one SSH key name in ``ssh_key_names``. More ``ssh_key_names`` can be added
by separating each key with a comma. The ``personal_access_token`` can be found in the
DigitalOcean web interface in the &quot;Apps &amp; API&quot; section. The SSH key name can be found
under the &quot;SSH Keys&quot; section.

.. code-block:: yaml

    # Note: This example is for /etc/salt/cloud.providers or any file in the
    # /etc/salt/cloud.providers.d/ directory.

    my-digital-ocean-config:
      personal_access_token: xxx
      ssh_key_file: /path/to/ssh/key/file
      ssh_key_names: my-key-name,my-key-name-2
      driver: digitalocean

<A NAME="4"></A>:depends: requests
&quot;&quot;&quot;

<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match66669-1.html#4',3,'match66669-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import decimal
import logging
import os
import pprint
import time

import salt.config as config
import salt.utils.cloud
import salt.utils.files
import salt.utils.json
import salt.utils.stringutils
from salt.exceptions import (
    SaltCloudConfigError,
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
    SaltCloudNotFound,
    SaltCloudSystemExit,
    SaltInvocationError,
)

try:
    import requests

    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS =</B></FONT> False

# Get logging started
log = logging.getLogger(__name__)

__virtualname__ = &quot;digitalocean&quot;
__virtual_aliases__ = (&quot;digital_ocean&quot;, &quot;do&quot;)
<A NAME="1"></A>

# Only load in this module if the DIGITALOCEAN configurations are in place
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match66669-1.html#1',3,'match66669-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>def __virtual__():
    &quot;&quot;&quot;
    Check for DigitalOcean configurations
    &quot;&quot;&quot;
    if get_configured_provider() is False:
        return False

    if get_dependencies() is False:
        return False

    return __virtualname__


def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__


def get_configured_provider():
    &quot;&quot;&quot;
    Return the first configured instance.
    &quot;&quot;&quot;
    return config.is_provider_configured(</B></FONT>
        opts=__opts__,
        provider=_get_active_provider_name() or __virtualname__,
        aliases=__virtual_aliases__,
        required_keys=(&quot;personal_access_token&quot;,),
    )


def get_dependencies():
    &quot;&quot;&quot;
    Warn if dependencies aren't met.
    &quot;&quot;&quot;
    return config.check_driver_dependencies(__virtualname__, {&quot;requests&quot;: HAS_REQUESTS})


def avail_locations(call=None):
    &quot;&quot;&quot;
    Return a dict of all available VM locations on the cloud provider with
    relevant data
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_locations function must be called with &quot;
            &quot;-f or --function, or with the --list-locations option&quot;
        )

    items = query(method=&quot;regions&quot;)
    ret = {}
<A NAME="9"></A>    for region in items[&quot;regions&quot;]:
        ret[region[&quot;name&quot;]] = {}
        for item in region.keys():
            ret[region[&quot;name&quot;]][item] = str(region[i<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match66669-1.html#9',3,'match66669-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>tem])

    return ret


def avail_images(call=None):
    &quot;&quot;&quot;
    Return a list of the images that are on the provider
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_images function must be called with &quot;
            &quot;-f or --function, or with the --list-images option&quot;
        )

    fetch = True
    page = 1
    ret =</B></FONT> {}

    while fetch:
        items = query(method=&quot;images&quot;, command=&quot;?page=&quot; + str(page) + &quot;&amp;per_page=200&quot;)

        for image in items[&quot;images&quot;]:
            ret[image[&quot;name&quot;]] = {}
            for item in image.keys():
                ret[image[&quot;name&quot;]][item] = image[item]

        page += 1
        try:
            fetch = &quot;next&quot; in items[&quot;links&quot;][&quot;pages&quot;]
        except KeyError:
            fetch = False

    return ret


def avail_sizes(call=None):
    &quot;&quot;&quot;
    Return a list of the image sizes that are on the provider
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_sizes function must be called with &quot;
            &quot;-f or --function, or with the --list-sizes option&quot;
        )

    items = query(method=&quot;sizes&quot;, command=&quot;?per_page=100&quot;)
    ret = {}
    for size in items[&quot;sizes&quot;]:
        ret[size[&quot;slug&quot;]] = {}
        for item in size.keys():
            ret[size[&quot;slug&quot;]][item] = str(size[item])

    return ret


def list_nodes(call=None):
    &quot;&quot;&quot;
    Return a list of the VMs that are on the provider
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes function must be called with -f or --function.&quot;
        )
    return _list_nodes()


def list_nodes_full(call=None, for_output=True):
    &quot;&quot;&quot;
    Return a list of the VMs that are on the provider
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_full function must be called with -f or --function.&quot;
        )
    return _list_nodes(full=True, for_output=for_output)


def list_nodes_select(call=None):
    &quot;&quot;&quot;
    Return a list of the VMs that are on the provider, with select fields
    &quot;&quot;&quot;
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full(&quot;function&quot;),
        __opts__[&quot;query.selection&quot;],
        call,
    )


def get_image(vm_):
    &quot;&quot;&quot;
    Return the image object to use
    &quot;&quot;&quot;
    images = avail_images()
    vm_image = config.get_cloud_config_value(
        &quot;image&quot;, vm_, __opts__, search_global=False
    )
    if not isinstance(vm_image, str):
        vm_image = str(vm_image)

    for image in images:
        if vm_image in (
            images[image][&quot;name&quot;],
            images[image][&quot;slug&quot;],
            images[image][&quot;id&quot;],
        ):
            if images[image][&quot;slug&quot;] is not None:
                return images[image][&quot;slug&quot;]
            return int(images[image][&quot;id&quot;])
    raise SaltCloudNotFound(
        &quot;The specified image, '{}', could not be found.&quot;.format(vm_image)
    )


def get_size(vm_):
    &quot;&quot;&quot;
    Return the VM's size. Used by create_node().
    &quot;&quot;&quot;
    sizes = avail_sizes()
    vm_size = str(
        config.get_cloud_config_value(&quot;size&quot;, vm_, __opts__, search_global=False)
    )
    for size in sizes:
        if vm_size.lower() == sizes[size][&quot;slug&quot;]:
            return sizes[size][&quot;slug&quot;]
    raise SaltCloudNotFound(
        &quot;The specified size, '{}', could not be found.&quot;.format(vm_size)
    )


def get_location(vm_):
    &quot;&quot;&quot;
    Return the VM's location
    &quot;&quot;&quot;
    locations = avail_locations()
    vm_location = str(
        config.get_cloud_config_value(&quot;location&quot;, vm_, __opts__, search_global=False)
    )

    for location in locations:
        if vm_location in (locations[location][&quot;name&quot;], locations[location][&quot;slug&quot;]):
            return locations[location][&quot;slug&quot;]
    raise SaltCloudNotFound(
        &quot;The specified location, '{}', could not be found.&quot;.format(vm_location)
    )


def create_node(args):
    &quot;&quot;&quot;
<A NAME="0"></A>    Create a node
    &quot;&quot;&quot;
    node = query(method=&quot;droplets&quot;, args=args, http_method=&quot;post&quot;)
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match66669-1.html#0',3,'match66669-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return node


def create(vm_):
    &quot;&quot;&quot;
    Create a single VM from a data dict
    &quot;&quot;&quot;
    try:
        # Check for required profile parameters before sending any API calls.
        if (
            vm_[&quot;profile&quot;]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or &quot;digitalocean&quot;,
                vm_[&quot;profile&quot;],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;starting create&quot;,
        &quot;salt/cloud/{}/creating&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;creating&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[</B></FONT>&quot;transport&quot;],
    )

    log.info(&quot;Creating Cloud VM %s&quot;, vm_[&quot;name&quot;])

    kwargs = {
        &quot;name&quot;: vm_[&quot;name&quot;],
        &quot;size&quot;: get_size(vm_),
        &quot;image&quot;: get_image(vm_),
        &quot;region&quot;: get_location(vm_),
        &quot;ssh_keys&quot;: [],
        &quot;tags&quot;: [],
    }

    # backwards compat
    ssh_key_name = config.get_cloud_config_value(
        &quot;ssh_key_name&quot;, vm_, __opts__, search_global=False
    )

    if ssh_key_name:
        kwargs[&quot;ssh_keys&quot;].append(get_keyid(ssh_key_name))

    ssh_key_names = config.get_cloud_config_value(
        &quot;ssh_key_names&quot;, vm_, __opts__, search_global=False, default=False
    )

    if ssh_key_names:
        for key in ssh_key_names.split(&quot;,&quot;):
            kwargs[&quot;ssh_keys&quot;].append(get_keyid(key))

    key_filename = config.get_cloud_config_value(
        &quot;ssh_key_file&quot;, vm_, __opts__, search_global=False, default=None
    )

    if key_filename is not None and not os.path.isfile(key_filename):
        raise SaltCloudConfigError(
            &quot;The defined key_filename '{}' does not exist&quot;.format(key_filename)
        )

    if not __opts__.get(&quot;ssh_agent&quot;, False) and key_filename is None:
        raise SaltCloudConfigError(
            &quot;The DigitalOcean driver requires an ssh_key_file and an ssh_key_name &quot;
            &quot;because it does not supply a root password upon building the server.&quot;
        )

    ssh_interface = config.get_cloud_config_value(
        &quot;ssh_interface&quot;, vm_, __opts__, search_global=False, default=&quot;public&quot;
    )

    if ssh_interface in [&quot;private&quot;, &quot;public&quot;]:
        log.info(&quot;ssh_interface: Setting interface for ssh to %s&quot;, ssh_interface)
        kwargs[&quot;ssh_interface&quot;] = ssh_interface
    else:
        raise SaltCloudConfigError(
            &quot;The DigitalOcean driver requires ssh_interface to be defined as 'public'&quot;
            &quot; or 'private'.&quot;
        )

    private_networking = config.get_cloud_config_value(
        &quot;private_networking&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=None,
    )

    if private_networking is not None:
        if not isinstance(private_networking, bool):
            raise SaltCloudConfigError(
                &quot;'private_networking' should be a boolean value.&quot;
            )
        kwargs[&quot;private_networking&quot;] = private_networking

    if not private_networking and ssh_interface == &quot;private&quot;:
        raise SaltCloudConfigError(
            &quot;The DigitalOcean driver requires ssh_interface if defined as 'private' &quot;
            &quot;then private_networking should be set as 'True'.&quot;
        )

    backups_enabled = config.get_cloud_config_value(
        &quot;backups_enabled&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=None,
    )

    if backups_enabled is not None:
        if not isinstance(backups_enabled, bool):
            raise SaltCloudConfigError(&quot;'backups_enabled' should be a boolean value.&quot;)
        kwargs[&quot;backups&quot;] = backups_enabled

    ipv6 = config.get_cloud_config_value(
        &quot;ipv6&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=None,
    )

    if ipv6 is not None:
        if not isinstance(ipv6, bool):
            raise SaltCloudConfigError(&quot;'ipv6' should be a boolean value.&quot;)
        kwargs[&quot;ipv6&quot;] = ipv6

    monitoring = config.get_cloud_config_value(
        &quot;monitoring&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=None,
    )

    if monitoring is not None:
        if not isinstance(monitoring, bool):
            raise SaltCloudConfigError(&quot;'monitoring' should be a boolean value.&quot;)
        kwargs[&quot;monitoring&quot;] = monitoring

    kwargs[&quot;tags&quot;] = config.get_cloud_config_value(
        &quot;tags&quot;, vm_, __opts__, search_global=False, default=False
    )

    userdata_file = config.get_cloud_config_value(
        &quot;userdata_file&quot;, vm_, __opts__, search_global=False, default=None
<A NAME="8"></A>    )
    if userdata_file is not None:
        try:
            with salt<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match66669-1.html#8',3,'match66669-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.files.fopen(userdata_file, &quot;r&quot;) as fp_:
                kwargs[&quot;user_data&quot;] = salt.utils.cloud.userdata_template(
                    __opts__, vm_, salt.utils.</B></FONT>stringutils.to_unicode(fp_.read())
                )
        except Exception as exc:  # pylint: disable=broad-except
            log.exception(&quot;Failed to read userdata from %s: %s&quot;, userdata_file, exc)

    create_dns_record = config.get_cloud_config_value(
        &quot;create_dns_record&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=None,
    )

    if create_dns_record:
        log.info(&quot;create_dns_record: will attempt to write DNS records&quot;)
        default_dns_domain = None
        dns_domain_name = vm_[&quot;name&quot;].split(&quot;.&quot;)
        if len(dns_domain_name) &gt; 2:
            log.debug(
                &quot;create_dns_record: inferring default dns_hostname, dns_domain from&quot;
                &quot; minion name as FQDN&quot;
            )
            default_dns_hostname = &quot;.&quot;.join(dns_domain_name[:-2])
            default_dns_domain = &quot;.&quot;.join(dns_domain_name[-2:])
        else:
            log.debug(&quot;create_dns_record: can't infer dns_domain from %s&quot;, vm_[&quot;name&quot;])
            default_dns_hostname = dns_domain_name[0]

        dns_hostname = config.get_cloud_config_value(
            &quot;dns_hostname&quot;,
            vm_,
            __opts__,
            search_global=False,
            default=default_dns_hostname,
        )
        dns_domain = config.get_cloud_config_value(
            &quot;dns_domain&quot;,
            vm_,
            __opts__,
            search_global=False,
            default=default_dns_domain,
        )
        if dns_hostname and dns_domain:
            log.info(
                'create_dns_record: using dns_hostname=&quot;%s&quot;, dns_domain=&quot;%s&quot;',
                dns_hostname,
                dns_domain,
            )
            __add_dns_addr__ = lambda t, d: post_dns_record(
                dns_domain=dns_domain, name=dns_hostname, record_type=t, record_data=d
            )

            log.debug(&quot;create_dns_record: %s&quot;, __add_dns_addr__)
        else:
            log.error(
                &quot;create_dns_record: could not determine dns_hostname and/or dns_domain&quot;
            )
            raise SaltCloudConfigError(
                &quot;'create_dns_record' must be a dict specifying \&quot;domain\&quot; &quot;
<A NAME="7"></A>                'and &quot;hostname&quot; or the minion name must be an FQDN.'
            )

    __utils__<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match66669-1.html#7',3,'match66669-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;requesting instance&quot;,
        &quot;salt/cloud/{}/requesting&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](&quot;requesting&quot;, kwargs, list(kwargs)),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[</B></FONT>&quot;transport&quot;],
    )

    try:
        ret = create_node(kwargs)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error creating %s on DIGITALOCEAN\n\n&quot;
            &quot;The following exception was thrown when trying to &quot;
            &quot;run the initial deployment: %s&quot;,
            vm_[&quot;name&quot;],
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return False

    def __query_node_data(vm_name):
        data = show_instance(vm_name, &quot;action&quot;)
        if not data:
            # Trigger an error in the wait_for_ip function
            return False
        if data[&quot;networks&quot;].get(&quot;v4&quot;):
            for network in data[&quot;networks&quot;][&quot;v4&quot;]:
                if network[&quot;type&quot;] == &quot;public&quot;:
                    return data
        return False

    try:
        data = salt.utils.cloud.wait_for_ip(
            __query_node_data,
            update_args=(vm_[&quot;name&quot;],),
            timeout=config.get_cloud_config_value(
                &quot;wait_for_ip_timeout&quot;, vm_, __opts__, default=10 * 60
            ),
            interval=config.get_cloud_config_value(
                &quot;wait_for_ip_interval&quot;, vm_, __opts__, default=10
            ),
        )
    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
        try:
            # It might be already up, let's destroy it!
            destroy(vm_[&quot;name&quot;])
        except SaltCloudSystemExit:
            pass
        finally:
            raise SaltCloudSystemExit(str(exc))

    if not vm_.get(&quot;ssh_host&quot;):
        vm_[&quot;ssh_host&quot;] = None

    # add DNS records, set ssh_host, default to first found IP, preferring IPv4 for ssh bootstrap script target
    addr_families, dns_arec_types = ((&quot;v4&quot;, &quot;v6&quot;), (&quot;A&quot;, &quot;AAAA&quot;))
    arec_map = dict(list(zip(addr_families, dns_arec_types)))
    for facing, addr_family, ip_address in [
        (net[&quot;type&quot;], family, net[&quot;ip_address&quot;])
        for family in addr_families
        for net in data[&quot;networks&quot;][family]
    ]:
        log.info('found %s IP%s interface for &quot;%s&quot;', facing, addr_family, ip_address)
        dns_rec_type = arec_map[addr_family]
        if facing == &quot;public&quot;:
            if create_dns_record:
                __add_dns_addr__(dns_rec_type, ip_address)
        if facing == ssh_interface:
            if not vm_[&quot;ssh_host&quot;]:
                vm_[&quot;ssh_host&quot;] = ip_address

    if vm_[&quot;ssh_host&quot;] is None:
        raise SaltCloudSystemExit(
            &quot;No suitable IP addresses found for ssh minion bootstrapping: {}&quot;.format(
                repr(data[&quot;networks&quot;])
            )
        )

    log.debug(
        &quot;Found public IP address to use for ssh minion bootstrapping: %s&quot;,
        vm_[&quot;ssh_host&quot;],
    )

    vm_[&quot;key_filename&quot;] = key_filename
    ret = __utils__[&quot;cloud.bootstrap&quot;](vm_, __opts__)
    ret.update(data)

<A NAME="6"></A>    log.info(&quot;Created Cloud VM '%s'&quot;, vm_[&quot;name&quot;])
    log.debug(&quot;'%s' VM creation details:\n%s&quot;, vm_[&quot;name&quot;], pprint.pformat(data))

    __utils__<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match66669-1.html#6',3,'match66669-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;created instance&quot;,
        &quot;salt/cloud/{}/created&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;created&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    return ret


def</B></FONT> query(
    method=&quot;droplets&quot;, droplet_id=None, command=None, args=None, http_method=&quot;get&quot;
):
    &quot;&quot;&quot;
    Make a web call to DigitalOcean
    &quot;&quot;&quot;
    base_path = str(
        config.get_cloud_config_value(
            &quot;api_root&quot;,
            get_configured_provider(),
            __opts__,
            search_global=False,
            default=&quot;https://api.digitalocean.com/v2&quot;,
        )
    )

    path = &quot;{}/{}/&quot;.format(base_path, method)

    if droplet_id:
        path += &quot;{}/&quot;.format(droplet_id)

    if command:
        path += command

    if not isinstance(args, dict):
        args = {}

    personal_access_token = config.get_cloud_config_value(
        &quot;personal_access_token&quot;,
        get_configured_provider(),
        __opts__,
        search_global=False,
    )

    data = salt.utils.json.dumps(args)

    requester = getattr(requests, http_method)
    request = requester(
        path,
        data=data,
        headers={
            &quot;Authorization&quot;: &quot;Bearer &quot; + personal_access_token,
            &quot;Content-Type&quot;: &quot;application/json&quot;,
        },
    )
    if request.status_code &gt; 299:
        raise SaltCloudSystemExit(
            &quot;An error occurred while querying DigitalOcean. HTTP Code: {}  &quot;
            &quot;Error: '{}'&quot;.format(
                request.status_code,
                # request.read()
                request.text,
            )
        )

    log.debug(request.url)

    # success without data
    if request.status_code == 204:
        return True

    content = request.text

    result = salt.utils.json.loads(content)
    if result.get(&quot;status&quot;, &quot;&quot;).lower() == &quot;error&quot;:
        raise SaltCloudSystemExit(pprint.pformat(result.get(&quot;error_message&quot;, {})))

    return result


def script(vm_):
    &quot;&quot;&quot;
    Return the script deployment object
    &quot;&quot;&quot;
    deploy_script = salt.utils.cloud.os_script(
        config.get_cloud_config_value(&quot;script&quot;, vm_, __opts__),
        vm_,
        __opts__,
        salt.utils.cloud.salt_config_to_yaml(
            salt.utils.cloud.minion_config(__opts__, vm_)
        ),
    )
    return deploy_script


def show_instance(name, call=None):
    &quot;&quot;&quot;
    Show the details from DigitalOcean concerning a droplet
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The show_instance action must be called with -a or --action.&quot;
        )
    node = _get_node(name)
    __utils__[&quot;cloud.cache_node&quot;](node, _get_active_provider_name(), __opts__)
    return node


def _get_node(name):
    attempts = 10
    while attempts &gt;= 0:
        try:
            return list_nodes_full(for_output=False)[name]
        except KeyError:
            attempts -= 1
            log.debug(
                &quot;Failed to get the data for node '%s'. Remaining attempts: %s&quot;,
                name,
                attempts,
            )
            # Just a little delay between attempts...
            time.sleep(0.5)
    return {}


def list_keypairs(call=None):
    &quot;&quot;&quot;
    Return a dict of all available VM locations on the cloud provider with
    relevant data
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(&quot;The list_keypairs function must be called with -f or --function.&quot;)
        return False

    fetch = True
    page = 1
    ret = {}

    while fetch:
        items = query(
            method=&quot;account/keys&quot;,
            command=&quot;?page=&quot; + str(page) + &quot;&amp;per_page=100&quot;,
        )

        for key_pair in items[&quot;ssh_keys&quot;]:
            name = key_pair[&quot;name&quot;]
            if name in ret:
                raise SaltCloudSystemExit(
                    &quot;A duplicate key pair name, '{}', was found in DigitalOcean's &quot;
                    &quot;key pair list. Please change the key name stored by DigitalOcean. &quot;
                    &quot;Be sure to adjust the value of 'ssh_key_file' in your cloud &quot;
                    &quot;profile or provider configuration, if necessary.&quot;.format(name)
                )
            ret[name] = {}
            for item in key_pair.keys():
                ret[name][item] = str(key_pair[item])

        page += 1
        try:
            fetch = &quot;next&quot; in items[&quot;links&quot;][&quot;pages&quot;]
        except KeyError:
            fetch = False

    return ret


def show_keypair(kwargs=None, call=None):
    &quot;&quot;&quot;
    Show the details of an SSH keypair
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(&quot;The show_keypair function must be called with -f or --function.&quot;)
        return False

    if not kwargs:
        kwargs = {}

    if &quot;keyname&quot; not in kwargs:
        log.error(&quot;A keyname is required.&quot;)
        return False

    keypairs = list_keypairs(call=&quot;function&quot;)
    keyid = keypairs[kwargs[&quot;keyname&quot;]][&quot;id&quot;]
    log.debug(&quot;Key ID is %s&quot;, keyid)

    details = query(method=&quot;account/keys&quot;, command=keyid)

    return details


def import_keypair(kwargs=None, call=None):
    &quot;&quot;&quot;
    Upload public key to cloud provider.
    Similar to EC2 import_keypair.

    .. versionadded:: 2016.11.0

    kwargs
        file(mandatory): public key file-name
        keyname(mandatory): public key name in the provider
    &quot;&quot;&quot;
    with salt.utils.files.fopen(kwargs[&quot;file&quot;], &quot;r&quot;) as public_key_filename:
        public_key_content = salt.utils.stringutils.to_unicode(
            public_key_filename.read()
        )

    digitalocean_kwargs = {&quot;name&quot;: kwargs[&quot;keyname&quot;], &quot;public_key&quot;: public_key_content}

    created_result = create_key(digitalocean_kwargs, call=call)
    return created_result


def create_key(kwargs=None, call=None):
    &quot;&quot;&quot;
    Upload a public key
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(&quot;The create_key function must be called with -f or --function.&quot;)
        return False

    try:
        result = query(
            method=&quot;account&quot;,
            command=&quot;keys&quot;,
            args={&quot;name&quot;: kwargs[&quot;name&quot;], &quot;public_key&quot;: kwargs[&quot;public_key&quot;]},
            http_method=&quot;post&quot;,
        )
    except KeyError:
        log.info(&quot;`name` and `public_key` arguments must be specified&quot;)
        return False

    return result


def remove_key(kwargs=None, call=None):
    &quot;&quot;&quot;
    Delete public key
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(&quot;The create_key function must be called with -f or --function.&quot;)
        return False

    try:
        result = query(
            method=&quot;account&quot;, command=&quot;keys/&quot; + kwargs[&quot;id&quot;], http_method=&quot;delete&quot;
        )
    except KeyError:
        log.info(&quot;`id` argument must be specified&quot;)
        return False

    return result


def get_keyid(keyname):
    &quot;&quot;&quot;
    Return the ID of the keyname
    &quot;&quot;&quot;
    if not keyname:
        return None
    keypairs = list_keypairs(call=&quot;function&quot;)
<A NAME="3"></A>    keyid = keypairs[keyname][&quot;id&quot;]
    if keyid:
        return keyid
    raise SaltCloudNotFound(<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match66669-1.html#3',3,'match66669-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;The specified ssh key could not be found.&quot;)


def destroy(name, call=None):
    &quot;&quot;&quot;
    Destroy a node. Will check termination protection and warn if enabled.

    CLI Example:

    .. code-block:: bash

        salt-cloud --destroy mymachine
    &quot;&quot;&quot;
    if call == &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The destroy action must be called with -d, --destroy, -a or --action.&quot;
        )

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroying instance&quot;,
        &quot;salt/cloud/{}/destroying&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    data =</B></FONT> show_instance(name, call=&quot;action&quot;)
    node = query(method=&quot;droplets&quot;, droplet_id=data[&quot;id&quot;], http_method=&quot;delete&quot;)

    ## This is all terribly optomistic:
    # vm_ = get_vm_config(name=name)
    # delete_dns_record = config.get_cloud_config_value(
    #     'delete_dns_record', vm_, __opts__, search_global=False, default=None,
    # )
    # TODO: when _vm config data can be made available, we should honor the configuration settings,
    # but until then, we should assume stale DNS records are bad, and default behavior should be to
    # delete them if we can. When this is resolved, also resolve the comments a couple of lines below.
    delete_dns_record = True

    if not isinstance(delete_dns_record, bool):
        raise SaltCloudConfigError(&quot;'delete_dns_record' should be a boolean value.&quot;)
    # When the &quot;to do&quot; a few lines up is resolved, remove these lines and use the if/else logic below.
    log.debug(&quot;Deleting DNS records for %s.&quot;, name)
    destroy_dns_records(name)

    # Until the &quot;to do&quot; from line 754 is taken care of, we don't need this logic.
    # if delete_dns_record:
    #    log.debug('Deleting DNS records for %s.', name)
    #    destroy_dns_records(name)
    # else:
    #    log.debug('delete_dns_record : %s', delete_dns_record)
<A NAME="2"></A>    #    for line in pprint.pformat(dir()).splitlines():
    #       log.debug('delete context: %s', line)

    __utils__<FONT color="#980517"><A HREF="javascript:ZweiFrames('match66669-1.html#2',3,'match66669-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroyed instance&quot;,
        &quot;salt/cloud/{}/destroyed&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    if __opts__.get(&quot;update_cachedir&quot;, False) is True:
        __utils__[&quot;cloud.delete_minion_cachedir&quot;](
            name, _get_active_provider_name().split(&quot;:&quot;)[</B></FONT>0], __opts__
        )

    return node


def post_dns_record(**kwargs):
    &quot;&quot;&quot;
    Creates a DNS record for the given name if the domain is managed with DO.
    &quot;&quot;&quot;
    if &quot;kwargs&quot; in kwargs:  # flatten kwargs if called via salt-cloud -f
        f_kwargs = kwargs[&quot;kwargs&quot;]
        del kwargs[&quot;kwargs&quot;]
        kwargs.update(f_kwargs)
    mandatory_kwargs = (&quot;dns_domain&quot;, &quot;name&quot;, &quot;record_type&quot;, &quot;record_data&quot;)
    for i in mandatory_kwargs:
        if kwargs[i]:
            pass
        else:
            error = '{}=&quot;{}&quot; ## all mandatory args must be provided: {}'.format(
                i, kwargs[i], mandatory_kwargs
            )
            raise SaltInvocationError(error)

    domain = query(method=&quot;domains&quot;, droplet_id=kwargs[&quot;dns_domain&quot;])

    if domain:
        result = query(
            method=&quot;domains&quot;,
            droplet_id=kwargs[&quot;dns_domain&quot;],
            command=&quot;records&quot;,
            args={
                &quot;type&quot;: kwargs[&quot;record_type&quot;],
                &quot;name&quot;: kwargs[&quot;name&quot;],
                &quot;data&quot;: kwargs[&quot;record_data&quot;],
            },
            http_method=&quot;post&quot;,
        )
        return result

    return False


def destroy_dns_records(fqdn):
    &quot;&quot;&quot;
    Deletes DNS records for the given hostname if the domain is managed with DO.
    &quot;&quot;&quot;
    domain = &quot;.&quot;.join(fqdn.split(&quot;.&quot;)[-2:])
    hostname = &quot;.&quot;.join(fqdn.split(&quot;.&quot;)[:-2])
    # TODO: remove this when the todo on 754 is available
    try:
        response = query(method=&quot;domains&quot;, droplet_id=domain, command=&quot;records&quot;)
    except SaltCloudSystemExit:
        log.debug(&quot;Failed to find domains.&quot;)
        return False
    log.debug(&quot;found DNS records: %s&quot;, pprint.pformat(response))
    records = response[&quot;domain_records&quot;]

    if records:
        record_ids = [r[&quot;id&quot;] for r in records if r[&quot;name&quot;].decode() == hostname]
        log.debug(&quot;deleting DNS record IDs: %s&quot;, record_ids)
        for id_ in record_ids:
            try:
                log.info(&quot;deleting DNS record %s&quot;, id_)
                ret = query(
                    method=&quot;domains&quot;,
                    droplet_id=domain,
                    command=&quot;records/{}&quot;.format(id_),
                    http_method=&quot;delete&quot;,
                )
            except SaltCloudSystemExit:
                log.error(
                    &quot;failed to delete DNS domain %s record ID %s.&quot;, domain, hostname
                )
            log.debug(&quot;DNS deletion REST call returned: %s&quot;, pprint.pformat(ret))

    return False


def show_pricing(kwargs=None, call=None):
    &quot;&quot;&quot;
    Show pricing for a particular profile. This is only an estimate, based on
    unofficial pricing sources.

    .. versionadded:: 2015.8.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f show_pricing my-digitalocean-config profile=my-profile
    &quot;&quot;&quot;
    profile = __opts__[&quot;profiles&quot;].get(kwargs[&quot;profile&quot;], {})
    if not profile:
        return {&quot;Error&quot;: &quot;The requested profile was not found&quot;}

    # Make sure the profile belongs to DigitalOcean
    provider = profile.get(&quot;provider&quot;, &quot;0:0&quot;)
    comps = provider.split(&quot;:&quot;)
    if len(comps) &lt; 2 or comps[1] != &quot;digitalocean&quot;:
        return {&quot;Error&quot;: &quot;The requested profile does not belong to DigitalOcean&quot;}

<A NAME="5"></A>    raw = {}
    ret = {}
    sizes = avail_sizes()
    ret[&quot;per_hour&quot;] = decimal.Decimal(sizes<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match66669-1.html#5',3,'match66669-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[profile[&quot;size&quot;]][&quot;price_hourly&quot;])

    ret[&quot;per_day&quot;] = ret[&quot;per_hour&quot;] * 24
    ret[&quot;per_week&quot;] = ret[&quot;per_day&quot;] * 7
    ret[&quot;per_month&quot;] = decimal.Decimal(sizes[profile[&quot;size&quot;]][</B></FONT>&quot;price_monthly&quot;])
    ret[&quot;per_year&quot;] = ret[&quot;per_week&quot;] * 52

    if kwargs.get(&quot;raw&quot;, False):
        ret[&quot;_raw&quot;] = raw

    return {profile[&quot;profile&quot;]: ret}


def list_floating_ips(call=None):
    &quot;&quot;&quot;
    Return a list of the floating ips that are on the provider

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f list_floating_ips my-digitalocean-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_floating_ips function must be called with &quot;
            &quot;-f or --function, or with the --list-floating-ips option&quot;
        )

    fetch = True
    page = 1
    ret = {}

    while fetch:
        items = query(
            method=&quot;floating_ips&quot;,
            command=&quot;?page=&quot; + str(page) + &quot;&amp;per_page=200&quot;,
        )

        for floating_ip in items[&quot;floating_ips&quot;]:
            ret[floating_ip[&quot;ip&quot;]] = {}
            for item in floating_ip.keys():
                ret[floating_ip[&quot;ip&quot;]][item] = floating_ip[item]

        page += 1
        try:
            fetch = &quot;next&quot; in items[&quot;links&quot;][&quot;pages&quot;]
        except KeyError:
            fetch = False

    return ret


def show_floating_ip(kwargs=None, call=None):
    &quot;&quot;&quot;
    Show the details of a floating IP

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f show_floating_ip my-digitalocean-config floating_ip='45.55.96.47'
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(&quot;The show_floating_ip function must be called with -f or --function.&quot;)
        return False

    if not kwargs:
        kwargs = {}

    if &quot;floating_ip&quot; not in kwargs:
        log.error(&quot;A floating IP is required.&quot;)
        return False

    floating_ip = kwargs[&quot;floating_ip&quot;]
    log.debug(&quot;Floating ip is %s&quot;, floating_ip)

    details = query(method=&quot;floating_ips&quot;, command=floating_ip)

    return details


def create_floating_ip(kwargs=None, call=None):
    &quot;&quot;&quot;
    Create a new floating IP

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f create_floating_ip my-digitalocean-config region='NYC2'

        salt-cloud -f create_floating_ip my-digitalocean-config droplet_id='1234567'
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(
            &quot;The create_floating_ip function must be called with -f or --function.&quot;
        )
        return False

    if not kwargs:
        kwargs = {}

    if &quot;droplet_id&quot; in kwargs:
        result = query(
            method=&quot;floating_ips&quot;,
            args={&quot;droplet_id&quot;: kwargs[&quot;droplet_id&quot;]},
            http_method=&quot;post&quot;,
        )

        return result

    elif &quot;region&quot; in kwargs:
        result = query(
            method=&quot;floating_ips&quot;, args={&quot;region&quot;: kwargs[&quot;region&quot;]}, http_method=&quot;post&quot;
        )

        return result

    else:
        log.error(&quot;A droplet_id or region is required.&quot;)
        return False


def delete_floating_ip(kwargs=None, call=None):
    &quot;&quot;&quot;
    Delete a floating IP

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f delete_floating_ip my-digitalocean-config floating_ip='45.55.96.47'
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(
            &quot;The delete_floating_ip function must be called with -f or --function.&quot;
        )
        return False

    if not kwargs:
        kwargs = {}

    if &quot;floating_ip&quot; not in kwargs:
        log.error(&quot;A floating IP is required.&quot;)
        return False

    floating_ip = kwargs[&quot;floating_ip&quot;]
    log.debug(&quot;Floating ip is %s&quot;, kwargs[&quot;floating_ip&quot;])

    result = query(method=&quot;floating_ips&quot;, command=floating_ip, http_method=&quot;delete&quot;)

    return result


def assign_floating_ip(kwargs=None, call=None):
    &quot;&quot;&quot;
    Assign a floating IP

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f assign_floating_ip my-digitalocean-config droplet_id=1234567 floating_ip='45.55.96.47'
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(
            &quot;The assign_floating_ip function must be called with -f or --function.&quot;
        )
        return False

    if not kwargs:
        kwargs = {}

    if &quot;floating_ip&quot; and &quot;droplet_id&quot; not in kwargs:
        log.error(&quot;A floating IP and droplet_id is required.&quot;)
        return False

    result = query(
        method=&quot;floating_ips&quot;,
        command=kwargs[&quot;floating_ip&quot;] + &quot;/actions&quot;,
        args={&quot;droplet_id&quot;: kwargs[&quot;droplet_id&quot;], &quot;type&quot;: &quot;assign&quot;},
        http_method=&quot;post&quot;,
    )

    return result


def unassign_floating_ip(kwargs=None, call=None):
    &quot;&quot;&quot;
    Unassign a floating IP

    .. versionadded:: 2016.3.0

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f unassign_floating_ip my-digitalocean-config floating_ip='45.55.96.47'
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        log.error(
            &quot;The inassign_floating_ip function must be called with -f or --function.&quot;
        )
        return False

    if not kwargs:
        kwargs = {}

    if &quot;floating_ip&quot; not in kwargs:
        log.error(&quot;A floating IP is required.&quot;)
        return False

    result = query(
        method=&quot;floating_ips&quot;,
        command=kwargs[&quot;floating_ip&quot;] + &quot;/actions&quot;,
        args={&quot;type&quot;: &quot;unassign&quot;},
        http_method=&quot;post&quot;,
    )

    return result


def _list_nodes(full=False, for_output=False):
    &quot;&quot;&quot;
    Helper function to format and parse node data.
    &quot;&quot;&quot;
    fetch = True
    page = 1
    ret = {}

    while fetch:
        items = query(method=&quot;droplets&quot;, command=&quot;?page=&quot; + str(page) + &quot;&amp;per_page=200&quot;)
        for node in items[&quot;droplets&quot;]:
            name = node[&quot;name&quot;]
            ret[name] = {}
            if full:
                ret[name] = _get_full_output(node, for_output=for_output)
            else:
                public_ips, private_ips = _get_ips(node[&quot;networks&quot;])
                ret[name] = {
                    &quot;id&quot;: node[&quot;id&quot;],
                    &quot;image&quot;: node[&quot;image&quot;][&quot;name&quot;],
                    &quot;name&quot;: name,
                    &quot;private_ips&quot;: private_ips,
                    &quot;public_ips&quot;: public_ips,
                    &quot;size&quot;: node[&quot;size_slug&quot;],
                    &quot;state&quot;: str(node[&quot;status&quot;]),
                }

        page += 1
        try:
            fetch = &quot;next&quot; in items[&quot;links&quot;][&quot;pages&quot;]
        except KeyError:
            fetch = False

    return ret


def reboot(name, call=None):
    &quot;&quot;&quot;
    Reboot a droplet in DigitalOcean.

    .. versionadded:: 2015.8.8

    name
        The name of the droplet to restart.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a reboot droplet_name
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The reboot action must be called with -a or --action.&quot;
        )

    data = show_instance(name, call=&quot;action&quot;)
    if data.get(&quot;status&quot;) == &quot;off&quot;:
        return {
            &quot;success&quot;: True,
            &quot;action&quot;: &quot;stop&quot;,
            &quot;status&quot;: &quot;off&quot;,
            &quot;msg&quot;: &quot;Machine is already off.&quot;,
        }

    ret = query(
        droplet_id=data[&quot;id&quot;],
        command=&quot;actions&quot;,
        args={&quot;type&quot;: &quot;reboot&quot;},
        http_method=&quot;post&quot;,
    )

    return {
        &quot;success&quot;: True,
        &quot;action&quot;: ret[&quot;action&quot;][&quot;type&quot;],
        &quot;state&quot;: ret[&quot;action&quot;][&quot;status&quot;],
    }


def start(name, call=None):
    &quot;&quot;&quot;
    Start a droplet in DigitalOcean.

    .. versionadded:: 2015.8.8

    name
        The name of the droplet to start.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a start droplet_name
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The start action must be called with -a or --action.&quot;
        )

    data = show_instance(name, call=&quot;action&quot;)
    if data.get(&quot;status&quot;) == &quot;active&quot;:
        return {
            &quot;success&quot;: True,
            &quot;action&quot;: &quot;start&quot;,
            &quot;status&quot;: &quot;active&quot;,
            &quot;msg&quot;: &quot;Machine is already running.&quot;,
        }

    ret = query(
        droplet_id=data[&quot;id&quot;],
        command=&quot;actions&quot;,
        args={&quot;type&quot;: &quot;power_on&quot;},
        http_method=&quot;post&quot;,
    )

    return {
        &quot;success&quot;: True,
        &quot;action&quot;: ret[&quot;action&quot;][&quot;type&quot;],
        &quot;state&quot;: ret[&quot;action&quot;][&quot;status&quot;],
    }


def stop(name, call=None):
    &quot;&quot;&quot;
    Stop a droplet in DigitalOcean.

    .. versionadded:: 2015.8.8

    name
        The name of the droplet to stop.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a stop droplet_name
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    data = show_instance(name, call=&quot;action&quot;)
    if data.get(&quot;status&quot;) == &quot;off&quot;:
        return {
            &quot;success&quot;: True,
            &quot;action&quot;: &quot;stop&quot;,
            &quot;status&quot;: &quot;off&quot;,
            &quot;msg&quot;: &quot;Machine is already off.&quot;,
        }

    ret = query(
        droplet_id=data[&quot;id&quot;],
        command=&quot;actions&quot;,
        args={&quot;type&quot;: &quot;shutdown&quot;},
        http_method=&quot;post&quot;,
    )

    return {
        &quot;success&quot;: True,
        &quot;action&quot;: ret[&quot;action&quot;][&quot;type&quot;],
        &quot;state&quot;: ret[&quot;action&quot;][&quot;status&quot;],
    }


def _get_full_output(node, for_output=False):
    &quot;&quot;&quot;
    Helper function for _list_nodes to loop through all node information.
    Returns a dictionary containing the full information of a node.
    &quot;&quot;&quot;
    ret = {}
    for item in node.keys():
        value = node[item]
        if value is not None and for_output:
            value = str(value)
        ret[item] = value
    return ret


def _get_ips(networks):
    &quot;&quot;&quot;
    Helper function for list_nodes. Returns public and private ip lists based on a
    given network dictionary.
    &quot;&quot;&quot;
    v4s = networks.get(&quot;v4&quot;)
    v6s = networks.get(&quot;v6&quot;)
    public_ips = []
    private_ips = []

    if v4s:
        for item in v4s:
            ip_type = item.get(&quot;type&quot;)
            ip_address = item.get(&quot;ip_address&quot;)
            if ip_type == &quot;public&quot;:
                public_ips.append(ip_address)
            if ip_type == &quot;private&quot;:
                private_ips.append(ip_address)

    if v6s:
        for item in v6s:
            ip_type = item.get(&quot;type&quot;)
            ip_address = item.get(&quot;ip_address&quot;)
            if ip_type == &quot;public&quot;:
                public_ips.append(ip_address)
            if ip_type == &quot;private&quot;:
                private_ips.append(ip_address)

    return public_ips, private_ips
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vmware.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# pylint: disable=C0302
&quot;&quot;&quot;
VMware Cloud Module
===================

.. versionadded:: 2015.5.4

The VMware cloud module allows you to manage VMware ESX, ESXi, and vCenter.

See :ref:`Getting started with VMware &lt;cloud-getting-started-vmware&gt;` to get started.

:codeauthor: Nitin Madhok &lt;nmadhok@g.clemson.edu&gt;


Dependencies
============

- pyVmomi Python Module

pyVmomi
-------

PyVmomi can be installed via pip:

.. code-block:: bash

    pip install pyVmomi

.. note::

    Version 6.0 of pyVmomi has some problems with SSL error handling on certain
    versions of Python. If using version 6.0 of pyVmomi, Python 2.6,
    Python 2.7.9, or newer must be present. This is due to an upstream dependency
    in pyVmomi 6.0 that is not supported in Python versions 2.7 to 2.7.8. If the
    version of Python is not in the supported range, you will need to install an
    earlier version of pyVmomi. See `Issue #29537`_ for more information.

.. _Issue #29537: https://github.com/saltstack/salt/issues/29537

Based on the note above, to install an earlier version of pyVmomi than the
version currently listed in PyPi, run the following:

.. code-block:: bash

    pip install pyVmomi==5.5.0.2014.1.1

The 5.5.0.2014.1.1 is a known stable version that this original VMware cloud
driver was developed against.

.. note::
    Ensure python pyVmomi module is installed by running following one-liner
    check. The output should be 0.

    .. code-block:: bash

       python -c &quot;import pyVmomi&quot; ; echo $?


Configuration
=============

To use this module, set up the vCenter or ESX/ESXi URL, username and password in the
cloud configuration at
``/etc/salt/cloud.providers`` or ``/etc/salt/cloud.providers.d/vmware.conf``:

.. code-block:: yaml

    my-vmware-config:
      driver: vmware
      user: 'DOMAIN\\user'
      password: 'verybadpass'
      url: '10.20.30.40'

    vcenter01:
      driver: vmware
      user: 'DOMAIN\\user'
      password: 'verybadpass'
      url: 'vcenter01.domain.com'
      protocol: 'https'
      port: 443

    vcenter02:
      driver: vmware
      user: 'DOMAIN\\user'
      password: 'verybadpass'
      url: 'vcenter02.domain.com'
      protocol: 'http'
      port: 80

    esx01:
      driver: vmware
      user: 'admin'
      password: 'verybadpass'
      url: 'esx01.domain.com'

.. note::

    Optionally, ``protocol`` and ``port`` can be specified if the vCenter
    server is not using the defaults. Default is ``protocol: https`` and
    ``port: 443``.

.. note::
    .. versionchanged:: 2015.8.0

    The ``provider`` parameter in cloud provider configuration was renamed to ``driver``.
    This change was made to avoid confusion with the ``provider`` parameter that is
    used in cloud profile configuration. Cloud provider configuration now uses ``driver``
    to refer to the salt-cloud driver that provides the underlying functionality to
    connect to a cloud provider, while cloud profile configuration continues to use
    ``provider`` to refer to the cloud provider configuration that you define.

To test the connection for ``my-vmware-config`` specified in the cloud
configuration, run :py:func:`test_vcenter_connection`
&quot;&quot;&quot;

<A NAME="4"></A>import logging
import os.path
import pprint
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#4',2,'match66669-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import re
import subprocess
import time
from random import randint

import salt.config as config
import salt.utils.cloud
import salt.utils.network
import salt.utils.stringutils
import salt.utils.vmware
import salt.utils.xmlutil
from salt.exceptions import SaltCloudSystemExit

try:
    # Attempt to import pyVmomi libs
    from pyVmomi import vim  # pylint: disable=no-name-in-module

    HAS_PYVMOMI = True
except ImportError:
    HAS_PYVMOMI =</B></FONT> False

# Disable InsecureRequestWarning generated on python &gt; 2.6
try:
    from requests.packages.urllib3 import (
        disable_warnings,
    )  # pylint: disable=no-name-in-module

    disable_warnings()
except ImportError:
    pass

ESX_5_5_NAME_PORTION = &quot;VMware ESXi 5.5&quot;
SAFE_ESX_5_5_CONTROLLER_KEY_INDEX = 200
FLATTEN_DISK_FULL_CLONE = &quot;moveAllDiskBackingsAndDisallowSharing&quot;
COPY_ALL_DISKS_FULL_CLONE = &quot;moveAllDiskBackingsAndAllowSharing&quot;
CURRENT_STATE_LINKED_CLONE = &quot;moveChildMostDiskBacking&quot;
QUICK_LINKED_CLONE = &quot;createNewChildDiskBacking&quot;


IP_RE = r&quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;

# Get logging started
log = logging.getLogger(__name__)

__virtualname__ = &quot;vmware&quot;
<A NAME="1"></A>

# Only load in this module if the VMware configurations are in place
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#1',2,'match66669-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>def __virtual__():
    &quot;&quot;&quot;
    Check for VMware configuration and if required libs are available.
    &quot;&quot;&quot;
    if get_configured_provider() is False:
        return False

    if get_dependencies() is False:
        return False

    return __virtualname__


def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__


def get_configured_provider():
    &quot;&quot;&quot;
    Return the first configured instance.
    &quot;&quot;&quot;
    return config.is_provider_configured(</B></FONT>
        __opts__,
        _get_active_provider_name() or __virtualname__,
        (
            &quot;url&quot;,
            &quot;user&quot;,
            &quot;password&quot;,
        ),
    )


def get_dependencies():
    &quot;&quot;&quot;
    Warn if dependencies aren't met.
    &quot;&quot;&quot;
    deps = {
        &quot;pyVmomi&quot;: HAS_PYVMOMI,
    }
    return config.check_driver_dependencies(__virtualname__, deps)


def script(vm_):
    &quot;&quot;&quot;
    Return the script deployment object
    &quot;&quot;&quot;
    script_name = config.get_cloud_config_value(&quot;script&quot;, vm_, __opts__)
    if not script_name:
        script_name = &quot;bootstrap-salt&quot;

    return salt.utils.cloud.os_script(
        script_name,
        vm_,
        __opts__,
        salt.utils.cloud.salt_config_to_yaml(
            salt.utils.cloud.minion_config(__opts__, vm_)
        ),
    )


def _str_to_bool(var):
    if isinstance(var, bool):
        return var

    if isinstance(var, str):
        return True if var.lower() == &quot;true&quot; else False

    return None


def _get_si():
    &quot;&quot;&quot;
    Authenticate with vCenter server and return service instance object.
    &quot;&quot;&quot;

    url = config.get_cloud_config_value(
        &quot;url&quot;, get_configured_provider(), __opts__, search_global=False
    )
    username = config.get_cloud_config_value(
        &quot;user&quot;, get_configured_provider(), __opts__, search_global=False
    )
    password = config.get_cloud_config_value(
        &quot;password&quot;, get_configured_provider(), __opts__, search_global=False
    )
    protocol = config.get_cloud_config_value(
        &quot;protocol&quot;,
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=&quot;https&quot;,
    )
    port = config.get_cloud_config_value(
        &quot;port&quot;, get_configured_provider(), __opts__, search_global=False, default=443
    )
    verify_ssl = config.get_cloud_config_value(
        &quot;verify_ssl&quot;,
        get_configured_provider(),
        __opts__,
        search_global=False,
        default=True,
    )
    return salt.utils.vmware.get_service_instance(
        url, username, password, protocol=protocol, port=port, verify_ssl=verify_ssl
    )


def _edit_existing_hard_disk_helper(disk, size_kb=None, size_gb=None, mode=None):
    if size_kb or size_gb:
        disk.capacityInKB = size_kb if size_kb else int(size_gb * 1024.0 * 1024.0)
    if mode:
        disk.backing.diskMode = mode
    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    disk_spec.device = disk

    return disk_spec


def _add_new_hard_disk_helper(
    disk_label,
    size_gb,
    unit_number,
    controller_key=1000,
    thin_provision=False,
    eagerly_scrub=False,
    datastore=None,
    vm_name=None,
):
    random_key = randint(-2099, -2000)
    size_kb = int(size_gb * 1024.0 * 1024.0)

    disk_spec = vim.vm.device.VirtualDeviceSpec()
    disk_spec.fileOperation = &quot;create&quot;
    disk_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add

    disk_spec.device = vim.vm.device.VirtualDisk()
    disk_spec.device.key = random_key
    disk_spec.device.deviceInfo = vim.Description()
    disk_spec.device.deviceInfo.label = disk_label
    disk_spec.device.deviceInfo.summary = &quot;{} GB&quot;.format(size_gb)

    disk_spec.device.backing = vim.vm.device.VirtualDisk.FlatVer2BackingInfo()
    disk_spec.device.backing.thinProvisioned = thin_provision
    disk_spec.device.backing.eagerlyScrub = eagerly_scrub
    disk_spec.device.backing.diskMode = &quot;persistent&quot;

    if datastore:
        datastore_ref = salt.utils.vmware.get_mor_using_container_view(
            _get_si(), vim.Datastore, datastore
        )

        if not datastore_ref:
            # check if it is a datastore cluster instead
            datastore_cluster_ref = salt.utils.vmware.get_mor_using_container_view(
                _get_si(), vim.StoragePod, datastore
            )

            if not datastore_cluster_ref:
                # datastore/datastore cluster specified does not exist
                raise SaltCloudSystemExit(
                    &quot;Specified datastore/datastore cluster ({}) for disk ({}) does not&quot;
                    &quot; exist&quot;.format(datastore, disk_label)
                )

            # datastore cluster has been specified
            # find datastore with most free space available
            #
            # TODO: Get DRS Recommendations instead of finding datastore with most free space
            datastore_list = salt.utils.vmware.get_datastores(
                _get_si(), datastore_cluster_ref, get_all_datastores=True
            )
            datastore_free_space = 0
            for ds_ref in datastore_list:
                log.trace(
                    &quot;Found datastore (%s) with free space (%s) in datastore &quot;
                    &quot;cluster (%s)&quot;,
                    ds_ref.name,
                    ds_ref.summary.freeSpace,
                    datastore,
                )
                if (
                    ds_ref.summary.accessible
                    and ds_ref.summary.freeSpace &gt; datastore_free_space
                ):
                    datastore_free_space = ds_ref.summary.freeSpace
                    datastore_ref = ds_ref

            if not datastore_ref:
                # datastore cluster specified does not have any accessible datastores
                raise SaltCloudSystemExit(
                    &quot;Specified datastore cluster ({}) for disk ({}) does not have any&quot;
                    &quot; accessible datastores available&quot;.format(datastore, disk_label)
                )

        datastore_path = &quot;[&quot; + str(datastore_ref.name) + &quot;] &quot; + vm_name
        disk_spec.device.backing.fileName = datastore_path + &quot;/&quot; + disk_label + &quot;.vmdk&quot;
        disk_spec.device.backing.datastore = datastore_ref
        log.trace(
            &quot;Using datastore (%s) for disk (%s), vm_name (%s)&quot;,
            datastore_ref.name,
            disk_label,
            vm_name,
        )

    disk_spec.device.controllerKey = controller_key
    disk_spec.device.unitNumber = unit_number
    disk_spec.device.capacityInKB = size_kb

    return disk_spec


def _edit_existing_network_adapter(
    network_adapter, new_network_name, adapter_type, switch_type, container_ref=None
):
    adapter_type.strip().lower()
    switch_type.strip().lower()

    if adapter_type in [&quot;vmxnet&quot;, &quot;vmxnet2&quot;, &quot;vmxnet3&quot;, &quot;e1000&quot;, &quot;e1000e&quot;]:
        edited_network_adapter = salt.utils.vmware.get_network_adapter_type(
            adapter_type
        )
        if isinstance(network_adapter, type(edited_network_adapter)):
            edited_network_adapter = network_adapter
        else:
            log.debug(
                &quot;Changing type of '%s' from '%s' to '%s'&quot;,
                network_adapter.deviceInfo.label,
                type(network_adapter).__name__.rsplit(&quot;.&quot;, 1)[1][7:].lower(),
                adapter_type,
            )
    else:
        # If type not specified or does not match, don't change adapter type
        if adapter_type:
            log.error(
                &quot;Cannot change type of '%s' to '%s'. Not changing type&quot;,
                network_adapter.deviceInfo.label,
                adapter_type,
            )
        edited_network_adapter = network_adapter

    if switch_type == &quot;standard&quot;:
        network_ref = salt.utils.vmware.get_mor_by_property(
            _get_si(), vim.Network, new_network_name, container_ref=container_ref
        )
        edited_network_adapter.backing = (
            vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        )
        edited_network_adapter.backing.deviceName = new_network_name
        edited_network_adapter.backing.network = network_ref
    elif switch_type == &quot;distributed&quot;:
        network_ref = salt.utils.vmware.get_mor_by_property(
            _get_si(),
            vim.dvs.DistributedVirtualPortgroup,
            new_network_name,
            container_ref=container_ref,
        )
        dvs_port_connection = vim.dvs.PortConnection(
            portgroupKey=network_ref.key,
            switchUuid=network_ref.config.distributedVirtualSwitch.uuid,
        )
        edited_network_adapter.backing = (
            vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        )
        edited_network_adapter.backing.port = dvs_port_connection
    else:
        # If switch type not specified or does not match, show error and return
        if not switch_type:
            err_msg = (
                &quot;The switch type to be used by '{}' has not been specified&quot;.format(
                    network_adapter.deviceInfo.label
                )
            )
        else:
            err_msg = &quot;Cannot create '{}'. Invalid/unsupported switch type '{}'&quot;.format(
                network_adapter.deviceInfo.label, switch_type
            )
        raise SaltCloudSystemExit(err_msg)

    edited_network_adapter.key = network_adapter.key
    edited_network_adapter.deviceInfo = network_adapter.deviceInfo
    edited_network_adapter.deviceInfo.summary = new_network_name
    edited_network_adapter.connectable = network_adapter.connectable
    edited_network_adapter.slotInfo = network_adapter.slotInfo
    edited_network_adapter.controllerKey = network_adapter.controllerKey
    edited_network_adapter.unitNumber = network_adapter.unitNumber
    edited_network_adapter.addressType = network_adapter.addressType
    edited_network_adapter.macAddress = network_adapter.macAddress
    edited_network_adapter.wakeOnLanEnabled = network_adapter.wakeOnLanEnabled
    network_spec = vim.vm.device.VirtualDeviceSpec()
    network_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    network_spec.device = edited_network_adapter

    return network_spec


def _add_new_network_adapter_helper(
    network_adapter_label,
    network_name,
    adapter_type,
    switch_type,
    mac,
    container_ref=None,
):
    random_key = randint(-4099, -4000)

    adapter_type.strip().lower()
    switch_type.strip().lower()
    network_spec = vim.vm.device.VirtualDeviceSpec()

    if adapter_type in [&quot;vmxnet&quot;, &quot;vmxnet2&quot;, &quot;vmxnet3&quot;, &quot;e1000&quot;, &quot;e1000e&quot;]:
        network_spec.device = salt.utils.vmware.get_network_adapter_type(adapter_type)
    else:
        # If type not specified or does not match, create adapter of type vmxnet3
        if not adapter_type:
            log.debug(
                &quot;The type of '%s' has not been specified. &quot;
                &quot;Creating default type 'vmxnet3'&quot;,
                network_adapter_label,
            )
        else:
            log.error(
                &quot;Cannot create network adapter of type '%s'. &quot;
                &quot;Creating '%s' of default type 'vmxnet3'&quot;,
                adapter_type,
                network_adapter_label,
            )
        network_spec.device = vim.vm.device.VirtualVmxnet3()

    network_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add

    if switch_type == &quot;standard&quot;:
        network_spec.device.backing = (
            vim.vm.device.VirtualEthernetCard.NetworkBackingInfo()
        )
        network_spec.device.backing.deviceName = network_name
        network_spec.device.backing.network = salt.utils.vmware.get_mor_by_property(
            _get_si(), vim.Network, network_name, container_ref=container_ref
        )
    elif switch_type == &quot;distributed&quot;:
        network_ref = salt.utils.vmware.get_mor_by_property(
            _get_si(),
            vim.dvs.DistributedVirtualPortgroup,
            network_name,
            container_ref=container_ref,
        )
        dvs_port_connection = vim.dvs.PortConnection(
            portgroupKey=network_ref.key,
            switchUuid=network_ref.config.distributedVirtualSwitch.uuid,
        )
        network_spec.device.backing = (
            vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo()
        )
        network_spec.device.backing.port = dvs_port_connection
    else:
        # If switch type not specified or does not match, show error and return
        if not switch_type:
            err_msg = (
                &quot;The switch type to be used by '{}' has not been specified&quot;.format(
                    network_adapter_label
                )
            )
        else:
            err_msg = &quot;Cannot create '{}'. Invalid/unsupported switch type '{}'&quot;.format(
                network_adapter_label, switch_type
            )
        raise SaltCloudSystemExit(err_msg)

    if mac != &quot;&quot;:
        network_spec.device.addressType = &quot;assigned&quot;
        network_spec.device.macAddress = mac
    network_spec.device.key = random_key
    network_spec.device.deviceInfo = vim.Description()
    network_spec.device.deviceInfo.label = network_adapter_label
    network_spec.device.deviceInfo.summary = network_name
    network_spec.device.wakeOnLanEnabled = True
    network_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    network_spec.device.connectable.startConnected = True
    network_spec.device.connectable.allowGuestControl = True

    return network_spec


def _edit_existing_scsi_controller(scsi_controller, bus_sharing):
    scsi_controller.sharedBus = bus_sharing
    scsi_spec = vim.vm.device.VirtualDeviceSpec()
    scsi_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    scsi_spec.device = scsi_controller

    return scsi_spec


def _add_new_scsi_controller_helper(scsi_controller_label, properties, bus_number):
    random_key = randint(-1050, -1000)
    adapter_type = properties[&quot;type&quot;].strip().lower() if &quot;type&quot; in properties else None
    bus_sharing = (
        properties[&quot;bus_sharing&quot;].strip().lower()
        if &quot;bus_sharing&quot; in properties
        else None
    )

    scsi_spec = vim.vm.device.VirtualDeviceSpec()

    if adapter_type == &quot;lsilogic&quot;:
        summary = &quot;LSI Logic&quot;
        scsi_spec.device = vim.vm.device.VirtualLsiLogicController()
    elif adapter_type == &quot;lsilogic_sas&quot;:
        summary = &quot;LSI Logic Sas&quot;
        scsi_spec.device = vim.vm.device.VirtualLsiLogicSASController()
    elif adapter_type == &quot;paravirtual&quot;:
        summary = &quot;VMware paravirtual SCSI&quot;
        scsi_spec.device = vim.vm.device.ParaVirtualSCSIController()
    else:
        # If type not specified or does not match, show error and return
        if not adapter_type:
            err_msg = &quot;The type of '{}' has not been specified&quot;.format(
                scsi_controller_label
            )
        else:
            err_msg = &quot;Cannot create '{}'. Invalid/unsupported type '{}'&quot;.format(
                scsi_controller_label, adapter_type
<A NAME="5"></A>            )
        raise SaltCloudSystemExit(err_msg)

    scsi_spec.operation = vim.vm.device.VirtualDeviceSpec<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#5',2,'match66669-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.Operation.add

    scsi_spec.device.key = random_key
    scsi_spec.device.busNumber = bus_number
    scsi_spec.device.deviceInfo = vim.Description()
    scsi_spec.device.deviceInfo.</B></FONT>label = scsi_controller_label
    scsi_spec.device.deviceInfo.summary = summary

    if bus_sharing == &quot;virtual&quot;:
        # Virtual disks can be shared between virtual machines on the same server
        scsi_spec.device.sharedBus = (
            vim.vm.device.VirtualSCSIController.Sharing.virtualSharing
        )

    elif bus_sharing == &quot;physical&quot;:
        # Virtual disks can be shared between virtual machines on any server
        scsi_spec.device.sharedBus = (
            vim.vm.device.VirtualSCSIController.Sharing.physicalSharing
        )

    else:
        # Virtual disks cannot be shared between virtual machines
        scsi_spec.device.sharedBus = (
            vim.vm.device.VirtualSCSIController.Sharing.noSharing
        )

    return scsi_spec


def _add_new_ide_controller_helper(ide_controller_label, controller_key, bus_number):
    &quot;&quot;&quot;
    Helper function for adding new IDE controllers

    .. versionadded:: 2016.3.0

    Args:
      ide_controller_label: label of the IDE controller
      controller_key: if not None, the controller key to use; otherwise it is randomly generated
      bus_number: bus number

    Returns: created device spec for an IDE controller

    &quot;&quot;&quot;
    if controller_key is None:
        controller_key = randint(-200, 250)

    ide_spec = vim.vm.device.VirtualDeviceSpec()
    ide_spec.device = vim.vm.device.VirtualIDEController()

    ide_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add

    ide_spec.device.key = controller_key
    ide_spec.device.busNumber = bus_number
    ide_spec.device.deviceInfo = vim.Description()
    ide_spec.device.deviceInfo.label = ide_controller_label
    ide_spec.device.deviceInfo.summary = ide_controller_label

    return ide_spec


def _set_cd_or_dvd_backing_type(drive, device_type, mode, iso_path):
    if device_type == &quot;datastore_iso_file&quot;:
        drive.backing = vim.vm.device.VirtualCdrom.IsoBackingInfo()
        drive.backing.fileName = iso_path

        datastore = iso_path.partition(&quot;[&quot;)[-1].rpartition(&quot;]&quot;)[0]
        datastore_ref = salt.utils.vmware.get_mor_by_property(
            _get_si(), vim.Datastore, datastore
        )
        if datastore_ref:
            drive.backing.datastore = datastore_ref

        drive.deviceInfo.summary = &quot;ISO {}&quot;.format(iso_path)

    elif device_type == &quot;client_device&quot;:
        if mode == &quot;passthrough&quot;:
            drive.backing = vim.vm.device.VirtualCdrom.RemotePassthroughBackingInfo()
            drive.deviceInfo.summary = &quot;Remote Device&quot;
        elif mode == &quot;atapi&quot;:
            drive.backing = vim.vm.device.VirtualCdrom.RemoteAtapiBackingInfo()
            drive.deviceInfo.summary = &quot;Remote ATAPI&quot;

    return drive


def _edit_existing_cd_or_dvd_drive(drive, device_type, mode, iso_path):
    device_type.strip().lower()
    mode.strip().lower()

    drive_spec = vim.vm.device.VirtualDeviceSpec()
    drive_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.edit
    drive_spec.device = _set_cd_or_dvd_backing_type(drive, device_type, mode, iso_path)

    return drive_spec


def _add_new_cd_or_dvd_drive_helper(
    drive_label, controller_key, device_type, mode, iso_path
):
    random_key = randint(-3025, -3000)

    device_type.strip().lower()
    mode.strip().lower()

    drive_spec = vim.vm.device.VirtualDeviceSpec()
    drive_spec.operation = vim.vm.device.VirtualDeviceSpec.Operation.add
    drive_spec.device = vim.vm.device.VirtualCdrom()
    drive_spec.device.deviceInfo = vim.Description()

    if device_type in [&quot;datastore_iso_file&quot;, &quot;client_device&quot;]:
        drive_spec.device = _set_cd_or_dvd_backing_type(
            drive_spec.device, device_type, mode, iso_path
        )
    else:
        # If device_type not specified or does not match, create drive of Client type with Passthough mode
        if not device_type:
            log.debug(
                &quot;The 'device_type' of '%s' has not been specified. &quot;
                &quot;Creating default type 'client_device'&quot;,
                drive_label,
            )
        else:
            log.error(
                &quot;Cannot create CD/DVD drive of type '%s'. &quot;
                &quot;Creating '%s' of default type 'client_device'&quot;,
                device_type,
                drive_label,
            )
        drive_spec.device.backing = (
            vim.vm.device.VirtualCdrom.RemotePassthroughBackingInfo()
        )
        drive_spec.device.deviceInfo.summary = &quot;Remote Device&quot;

    drive_spec.device.key = random_key
    drive_spec.device.deviceInfo.label = drive_label
    drive_spec.device.controllerKey = controller_key
    drive_spec.device.connectable = vim.vm.device.VirtualDevice.ConnectInfo()
    drive_spec.device.connectable.startConnected = True
    drive_spec.device.connectable.allowGuestControl = True

    return drive_spec


def _set_network_adapter_mapping(adapter_specs):
    adapter_mapping = vim.vm.customization.AdapterMapping()
    adapter_mapping.adapter = vim.vm.customization.IPSettings()

    if &quot;domain&quot; in list(adapter_specs.keys()):
        domain = adapter_specs[&quot;domain&quot;]
        adapter_mapping.adapter.dnsDomain = domain
    if &quot;gateway&quot; in list(adapter_specs.keys()):
        gateway = adapter_specs[&quot;gateway&quot;]
        adapter_mapping.adapter.gateway = gateway
    if &quot;ip&quot; in list(adapter_specs.keys()):
        ip = str(adapter_specs[&quot;ip&quot;])
        subnet_mask = str(adapter_specs[&quot;subnet_mask&quot;])
        adapter_mapping.adapter.ip = vim.vm.customization.FixedIp(ipAddress=ip)
        adapter_mapping.adapter.subnetMask = subnet_mask
    else:
        adapter_mapping.adapter.ip = vim.vm.customization.DhcpIpGenerator()

    return adapter_mapping


def _get_mode_spec(device, mode, disk_spec):
    if device.backing.diskMode != mode:
        if not disk_spec:
            disk_spec = _edit_existing_hard_disk_helper(disk=device, mode=mode)
        else:
            disk_spec.device.backing.diskMode = mode
    return disk_spec


def _get_size_spec(device, size_gb=None, size_kb=None):
    if size_kb is None and size_gb is not None:
        size_kb = int(size_gb * 1024.0 * 1024.0)
    disk_spec = (
        _edit_existing_hard_disk_helper(disk=device, size_kb=size_kb)
        if device.capacityInKB &lt; size_kb
        else None
    )
    return disk_spec


def _iter_disk_unit_number(unit_number):
    &quot;&quot;&quot;
    Apparently vmware reserves ID 7 for SCSI controllers, so we cannot specify
    hard drives for 7.

    Skip 7 to make sure.
    &quot;&quot;&quot;
    unit_number += 1
    if unit_number == 7:
        unit_number += 1
    return unit_number


def _manage_devices(devices, vm=None, container_ref=None, new_vm_name=None):
    unit_number = 0
    bus_number = 0
    device_specs = []
    existing_disks_label = []
    existing_scsi_controllers_label = []
    existing_ide_controllers_label = []
    existing_network_adapters_label = []
    existing_cd_drives_label = []
    ide_controllers = {}
    nics_map = []
    cloning_from_vm = vm is not None

    if cloning_from_vm:
        # loop through all the devices the vm/template has
        # check if the device needs to be created or configured
        for device in vm.config.hardware.device:
            if isinstance(device, vim.vm.device.VirtualDisk):
                # this is a hard disk
                if &quot;disk&quot; in list(devices.keys()):
                    # there is atleast one disk specified to be created/configured
                    unit_number = _iter_disk_unit_number(unit_number)
                    existing_disks_label.append(device.deviceInfo.label)
                    if device.deviceInfo.label in list(devices[&quot;disk&quot;].keys()):
                        disk_spec = None
                        if &quot;size&quot; in devices[&quot;disk&quot;][device.deviceInfo.label]:
                            size_gb = float(
                                devices[&quot;disk&quot;][device.deviceInfo.label][&quot;size&quot;]
                            )
                            size_kb = int(size_gb * 1024.0 * 1024.0)
                        else:
                            # User didn't specify disk size in the cloud
                            # profile so use the existing disk size
                            size_kb = device.capacityInKB
                            size_gb = size_kb / (1024.0 * 1024.0)
                            log.debug(
                                &quot;Virtual disk size for '%s' was not &quot;
                                &quot;specified in the cloud profile or map file. &quot;
                                &quot;Using existing virtual disk size of '%sGB'&quot;,
                                device.deviceInfo.label,
                                size_gb,
                            )

                        if device.capacityInKB &gt; size_kb:
                            raise SaltCloudSystemExit(
                                &quot;The specified disk size '{}GB' for '{}' is &quot;
                                &quot;smaller than the disk image size '{}GB'. It must &quot;
                                &quot;be equal to or greater than the disk image&quot;.format(
                                    float(
                                        devices[&quot;disk&quot;][device.deviceInfo.label][&quot;size&quot;]
                                    ),
                                    device.deviceInfo.label,
                                    float(device.capacityInKB / (1024.0 * 1024.0)),
                                )
                            )
                        else:
                            disk_spec = _get_size_spec(device=device, size_kb=size_kb)

                        if &quot;mode&quot; in devices[&quot;disk&quot;][device.deviceInfo.label]:
                            if devices[&quot;disk&quot;][device.deviceInfo.label][&quot;mode&quot;] in [
                                &quot;independent_persistent&quot;,
                                &quot;independent_nonpersistent&quot;,
                                &quot;dependent&quot;,
                            ]:
                                mode = devices[&quot;disk&quot;][device.deviceInfo.label][&quot;mode&quot;]
                                disk_spec = _get_mode_spec(device, mode, disk_spec)
                            else:
                                raise SaltCloudSystemExit(
                                    &quot;Invalid disk backing mode specified!&quot;
                                )
                        if disk_spec is not None:
                            device_specs.append(disk_spec)

            elif isinstance(
                device.backing,
                (
                    vim.vm.device.VirtualEthernetCard.NetworkBackingInfo,
                    vim.vm.device.VirtualEthernetCard.DistributedVirtualPortBackingInfo,
                ),
            ):
                # this is a network adapter
                if &quot;network&quot; in list(devices.keys()):
                    # there is atleast one network adapter specified to be created/configured
                    existing_network_adapters_label.append(device.deviceInfo.label)
                    if device.deviceInfo.label in list(devices[&quot;network&quot;].keys()):
                        network_name = devices[&quot;network&quot;][device.deviceInfo.label][
                            &quot;name&quot;
                        ]
                        adapter_type = (
                            devices[&quot;network&quot;][device.deviceInfo.label][&quot;adapter_type&quot;]
                            if &quot;adapter_type&quot;
                            in devices[&quot;network&quot;][device.deviceInfo.label]
                            else &quot;&quot;
                        )
                        switch_type = (
                            devices[&quot;network&quot;][device.deviceInfo.label][&quot;switch_type&quot;]
                            if &quot;switch_type&quot;
                            in devices[&quot;network&quot;][device.deviceInfo.label]
                            else &quot;&quot;
                        )
                        network_spec = _edit_existing_network_adapter(
                            device,
                            network_name,
                            adapter_type,
                            switch_type,
                            container_ref,
                        )
                        adapter_mapping = _set_network_adapter_mapping(
                            devices[&quot;network&quot;][device.deviceInfo.label]
                        )
                        device_specs.append(network_spec)
                        nics_map.append(adapter_mapping)

            elif hasattr(device, &quot;scsiCtlrUnitNumber&quot;):
                # this is a SCSI controller
                if &quot;scsi&quot; in list(devices.keys()):
                    # there is atleast one SCSI controller specified to be created/configured
                    bus_number += 1
                    existing_scsi_controllers_label.append(device.deviceInfo.label)
                    if device.deviceInfo.label in list(devices[&quot;scsi&quot;].keys()):
                        # Modify the existing SCSI controller
                        scsi_controller_properties = devices[&quot;scsi&quot;][
                            device.deviceInfo.label
                        ]
                        bus_sharing = (
                            scsi_controller_properties[&quot;bus_sharing&quot;].strip().lower()
                            if &quot;bus_sharing&quot; in scsi_controller_properties
                            else None
                        )
                        if bus_sharing and bus_sharing in [&quot;virtual&quot;, &quot;physical&quot;, &quot;no&quot;]:
                            bus_sharing = &quot;{}Sharing&quot;.format(bus_sharing)
                            if bus_sharing != device.sharedBus:
                                # Only edit the SCSI controller if bus_sharing is different
                                scsi_spec = _edit_existing_scsi_controller(
                                    device, bus_sharing
                                )
                                device_specs.append(scsi_spec)

            elif isinstance(device, vim.vm.device.VirtualCdrom):
                # this is a cd/dvd drive
                if &quot;cd&quot; in list(devices.keys()):
                    # there is atleast one cd/dvd drive specified to be created/configured
                    existing_cd_drives_label.append(device.deviceInfo.label)
                    if device.deviceInfo.label in list(devices[&quot;cd&quot;].keys()):
                        device_type = (
                            devices[&quot;cd&quot;][device.deviceInfo.label][&quot;device_type&quot;]
                            if &quot;device_type&quot; in devices[&quot;cd&quot;][device.deviceInfo.label]
                            else &quot;&quot;
                        )
                        mode = (
                            devices[&quot;cd&quot;][device.deviceInfo.label][&quot;mode&quot;]
                            if &quot;mode&quot; in devices[&quot;cd&quot;][device.deviceInfo.label]
                            else &quot;&quot;
                        )
                        iso_path = (
                            devices[&quot;cd&quot;][device.deviceInfo.label][&quot;iso_path&quot;]
                            if &quot;iso_path&quot; in devices[&quot;cd&quot;][device.deviceInfo.label]
                            else &quot;&quot;
                        )
                        cd_drive_spec = _edit_existing_cd_or_dvd_drive(
                            device, device_type, mode, iso_path
                        )
                        device_specs.append(cd_drive_spec)

            elif isinstance(device, vim.vm.device.VirtualIDEController):
                # this is an IDE controller to add new cd drives to
                ide_controllers[device.key] = len(device.device)

    if &quot;network&quot; in list(devices.keys()):
        network_adapters_to_create = list(
            set(devices[&quot;network&quot;].keys()) - set(existing_network_adapters_label)
        )
        network_adapters_to_create.sort()
        if network_adapters_to_create:
            log.debug(&quot;Networks adapters to create: %s&quot;, network_adapters_to_create)
        for network_adapter_label in network_adapters_to_create:
            network_name = devices[&quot;network&quot;][network_adapter_label][&quot;name&quot;]
            adapter_type = (
                devices[&quot;network&quot;][network_adapter_label][&quot;adapter_type&quot;]
                if &quot;adapter_type&quot; in devices[&quot;network&quot;][network_adapter_label]
                else &quot;&quot;
            )
            switch_type = (
                devices[&quot;network&quot;][network_adapter_label][&quot;switch_type&quot;]
                if &quot;switch_type&quot; in devices[&quot;network&quot;][network_adapter_label]
                else &quot;&quot;
            )
            mac = (
                devices[&quot;network&quot;][network_adapter_label][&quot;mac&quot;]
                if &quot;mac&quot; in devices[&quot;network&quot;][network_adapter_label]
                else &quot;&quot;
            )
            # create the network adapter
            network_spec = _add_new_network_adapter_helper(
                network_adapter_label,
                network_name,
                adapter_type,
                switch_type,
                mac,
                container_ref,
            )
            adapter_mapping = _set_network_adapter_mapping(
                devices[&quot;network&quot;][network_adapter_label]
            )
            device_specs.append(network_spec)
            nics_map.append(adapter_mapping)

    if &quot;scsi&quot; in list(devices.keys()):
        scsi_controllers_to_create = list(
            set(devices[&quot;scsi&quot;].keys()) - set(existing_scsi_controllers_label)
        )
        scsi_controllers_to_create.sort()
        if scsi_controllers_to_create:
            log.debug(&quot;SCSI controllers to create: %s&quot;, scsi_controllers_to_create)
        for scsi_controller_label in scsi_controllers_to_create:
            # create the SCSI controller
            scsi_controller_properties = devices[&quot;scsi&quot;][scsi_controller_label]
            scsi_spec = _add_new_scsi_controller_helper(
                scsi_controller_label, scsi_controller_properties, bus_number
            )
            device_specs.append(scsi_spec)
            bus_number += 1

    if &quot;ide&quot; in list(devices.keys()):
        ide_controllers_to_create = list(
            set(devices[&quot;ide&quot;].keys()) - set(existing_ide_controllers_label)
        )
        ide_controllers_to_create.sort()
        if ide_controllers_to_create:
            log.debug(&quot;IDE controllers to create: %s&quot;, ide_controllers_to_create)

        # ESX 5.5 (and possibly earlier?) set the IDE controller key themselves, indexed starting at
        # 200. Rather than doing a create task/get vm/reconfig task dance we query the server and
        # if it's ESX 5.5 we supply a controller starting at 200 and work out way upwards from there
        # ESX 6 (and, one assumes, vCenter) does not display this problem and so continues to use
        # the randomly generated indexes
        vcenter_name = get_vcenter_version(call=&quot;function&quot;)
        controller_index = (
            SAFE_ESX_5_5_CONTROLLER_KEY_INDEX
            if ESX_5_5_NAME_PORTION in vcenter_name
            else None
        )

        for ide_controller_label in ide_controllers_to_create:
            # create the IDE controller
            ide_spec = _add_new_ide_controller_helper(
                ide_controller_label, controller_index, bus_number
            )
            device_specs.append(ide_spec)
            bus_number += 1
            if controller_index is not None:
                controller_index += 1

    if &quot;disk&quot; in list(devices.keys()):
        disks_to_create = list(set(devices[&quot;disk&quot;].keys()) - set(existing_disks_label))
        disks_to_create.sort()
        if disks_to_create:
            log.debug(&quot;Hard disks to create: %s&quot;, disks_to_create)
        for disk_label in disks_to_create:
            # create the disk
            size_gb = float(devices[&quot;disk&quot;][disk_label][&quot;size&quot;])
            thin_provision = (
                bool(devices[&quot;disk&quot;][disk_label][&quot;thin_provision&quot;])
                if &quot;thin_provision&quot; in devices[&quot;disk&quot;][disk_label]
                else False
            )
            eagerly_scrub = (
                bool(devices[&quot;disk&quot;][disk_label][&quot;eagerly_scrub&quot;])
                if &quot;eagerly_scrub&quot; in devices[&quot;disk&quot;][disk_label]
                else False
            )
            datastore = devices[&quot;disk&quot;][disk_label].get(&quot;datastore&quot;, None)
            disk_spec = _add_new_hard_disk_helper(
                disk_label,
                size_gb,
                unit_number,
                thin_provision=thin_provision,
                eagerly_scrub=eagerly_scrub,
                datastore=datastore,
                vm_name=new_vm_name,
            )

            # when creating both SCSI controller and Hard disk at the same time we need the randomly
            # assigned (temporary) key of the newly created SCSI controller
            if &quot;controller&quot; in devices[&quot;disk&quot;][disk_label]:
                for spec in device_specs:
                    if (
                        spec.device.deviceInfo.label
                        == devices[&quot;disk&quot;][disk_label][&quot;controller&quot;]
                    ):
                        disk_spec.device.controllerKey = spec.device.key
                        break

            device_specs.append(disk_spec)
            unit_number = _iter_disk_unit_number(unit_number)

    if &quot;cd&quot; in list(devices.keys()):
        cd_drives_to_create = list(
            set(devices[&quot;cd&quot;].keys()) - set(existing_cd_drives_label)
        )
        cd_drives_to_create.sort()
        if cd_drives_to_create:
            log.debug(&quot;CD/DVD drives to create: %s&quot;, cd_drives_to_create)
        for cd_drive_label in cd_drives_to_create:
            # create the CD/DVD drive
            device_type = (
                devices[&quot;cd&quot;][cd_drive_label][&quot;device_type&quot;]
                if &quot;device_type&quot; in devices[&quot;cd&quot;][cd_drive_label]
                else &quot;&quot;
            )
            mode = (
                devices[&quot;cd&quot;][cd_drive_label][&quot;mode&quot;]
                if &quot;mode&quot; in devices[&quot;cd&quot;][cd_drive_label]
                else &quot;&quot;
            )
            iso_path = (
                devices[&quot;cd&quot;][cd_drive_label][&quot;iso_path&quot;]
                if &quot;iso_path&quot; in devices[&quot;cd&quot;][cd_drive_label]
                else &quot;&quot;
            )
            controller_key = None

            # When creating both IDE controller and CD/DVD drive at the same time we need the randomly
            # assigned (temporary) key of the newly created IDE controller
            if &quot;controller&quot; in devices[&quot;cd&quot;][cd_drive_label]:
                for spec in device_specs:
                    if (
                        spec.device.deviceInfo.label
                        == devices[&quot;cd&quot;][cd_drive_label][&quot;controller&quot;]
                    ):
                        controller_key = spec.device.key
                        ide_controllers[controller_key] = 0
                        break
            else:
                for ide_controller_key, num_devices in ide_controllers.items():
                    if num_devices &lt; 2:
                        controller_key = ide_controller_key
                        break

            if not controller_key:
                log.error(
                    &quot;No more available controllers for '%s'. &quot;
                    &quot;All IDE controllers are currently in use&quot;,
                    cd_drive_label,
                )
            else:
                cd_drive_spec = _add_new_cd_or_dvd_drive_helper(
                    cd_drive_label, controller_key, device_type, mode, iso_path
                )
                device_specs.append(cd_drive_spec)
                ide_controllers[controller_key] += 1

    ret = {&quot;device_specs&quot;: device_specs, &quot;nics_map&quot;: nics_map}

    return ret


def _wait_for_vmware_tools(vm_ref, max_wait):
    time_counter = 0
    starttime = time.time()
    while time_counter &lt; max_wait:
        if time_counter % 5 == 0:
            log.info(
                &quot;[ %s ] Waiting for VMware tools to be running [%s s]&quot;,
                vm_ref.name,
                time_counter,
            )
        if str(vm_ref.summary.guest.toolsRunningStatus) == &quot;guestToolsRunning&quot;:
            log.info(
                &quot;[ %s ] Successfully got VMware tools running on the guest in &quot;
                &quot;%s seconds&quot;,
                vm_ref.name,
                time_counter,
            )
            return True

        time.sleep(1.0 - ((time.time() - starttime) % 1.0))
        time_counter += 1
    log.warning(
        &quot;[ %s ] Timeout Reached. VMware tools still not running after waiting &quot;
        &quot;for %s seconds&quot;,
        vm_ref.name,
        max_wait,
    )
    return False


def _valid_ip(ip_address):
    &quot;&quot;&quot;
    Check if the IP address is valid
    Return either True or False
    &quot;&quot;&quot;

    # Make sure IP has four octets
    octets = ip_address.split(&quot;.&quot;)
    if len(octets) != 4:
        return False

    # convert octet from string to int
    for i, octet in enumerate(octets):

        try:
            octets[i] = int(octet)
        except ValueError:
            # couldn't convert octet to an integer
            return False

    # map variables to elements of octets list
    first_octet, second_octet, third_octet, fourth_octet = octets

    # Check first_octet meets conditions
    if first_octet &lt; 1 or first_octet &gt; 223 or first_octet == 127:
        return False

    # Check 169.254.X.X condition
    if first_octet == 169 and second_octet == 254:
        return False

    # Check 2nd - 4th octets
    for octet in (second_octet, third_octet, fourth_octet):
        if (octet &lt; 0) or (octet &gt; 255):
            return False
    # Passed all of the checks
    return True


def _wait_for_ip(vm_ref, max_wait):
    max_wait_vmware_tools = max_wait
    max_wait_ip = max_wait
    vmware_tools_status = _wait_for_vmware_tools(vm_ref, max_wait_vmware_tools)
    if not vmware_tools_status:
        # VMware will only report the IP if VMware tools are installed. Try to
        # determine the IP using DNS
        vm_name = vm_ref.summary.config.name
        resolved_ips = salt.utils.network.host_to_ips(vm_name)
        log.debug(
            &quot;Timeout waiting for VMware tools. The name %s resolved to %s&quot;,
            vm_name,
            resolved_ips,
        )
        if isinstance(resolved_ips, list) and resolved_ips:
            return resolved_ips[0]
        return False
    time_counter = 0
    starttime = time.time()
    while time_counter &lt; max_wait_ip:
        if time_counter % 5 == 0:
            log.info(
                &quot;[ %s ] Waiting to retrieve IPv4 information [%s s]&quot;,
                vm_ref.name,
                time_counter,
            )

        if vm_ref.summary.guest.ipAddress and _valid_ip(vm_ref.summary.guest.ipAddress):
            log.info(
                &quot;[ %s ] Successfully retrieved IPv4 information in %s seconds&quot;,
                vm_ref.name,
                time_counter,
            )
            return vm_ref.summary.guest.ipAddress
        for net in vm_ref.guest.net:
            if net.ipConfig.ipAddress:
                for current_ip in net.ipConfig.ipAddress:
                    if _valid_ip(current_ip.ipAddress):
                        log.info(
                            &quot;[ %s ] Successfully retrieved IPv4 information &quot;
                            &quot;in %s seconds&quot;,
                            vm_ref.name,
                            time_counter,
                        )
                        return current_ip.ipAddress
        time.sleep(1.0 - ((time.time() - starttime) % 1.0))
        time_counter += 1
    log.warning(
        &quot;[ %s ] Timeout Reached. Unable to retrieve IPv4 information after &quot;
        &quot;waiting for %s seconds&quot;,
        vm_ref.name,
        max_wait_ip,
    )
    return False


def _wait_for_host(host_ref, task_type, sleep_seconds=5, log_level=&quot;debug&quot;):
    time_counter = 0
    starttime = time.time()
    while host_ref.runtime.connectionState != &quot;notResponding&quot;:
        if time_counter % sleep_seconds == 0:
            log.log(
                logging.INFO if log_level == &quot;info&quot; else logging.DEBUG,
                &quot;[ %s ] Waiting for host %s to finish [%s s]&quot;,
                host_ref.name,
                task_type,
                time_counter,
            )
        time.sleep(1.0 - ((time.time() - starttime) % 1.0))
        time_counter += 1
    while host_ref.runtime.connectionState != &quot;connected&quot;:
        if time_counter % sleep_seconds == 0:
            log.log(
                logging.INFO if log_level == &quot;info&quot; else logging.DEBUG,
                &quot;[ %s ] Waiting for host %s to finish [%s s]&quot;,
                host_ref.name,
                task_type,
                time_counter,
            )
        time.sleep(1.0 - ((time.time() - starttime) % 1.0))
        time_counter += 1
    if host_ref.runtime.connectionState == &quot;connected&quot;:
        log.log(
            logging.INFO if log_level == &quot;info&quot; else logging.DEBUG,
            &quot;[ %s ] Successfully completed host %s in %s seconds&quot;,
            host_ref.name,
            task_type,
            time_counter,
        )
    else:
        log.error(&quot;Could not connect back to the host system&quot;)


def _format_instance_info_select(vm, selection):
    def defaultto(machine, section, default=&quot;N/A&quot;):
        &quot;&quot;&quot;
        Return either a named value from a VirtualMachineConfig or a
        default string &quot;N/A&quot;.
        &quot;&quot;&quot;
        return default if section not in machine else machine[section]

    vm_select_info = {}

    if &quot;id&quot; in selection:
        vm_select_info[&quot;id&quot;] = vm[&quot;name&quot;]

    if &quot;image&quot; in selection:
        vm_select_info[&quot;image&quot;] = &quot;{} (Detected)&quot;.format(
            defaultto(vm, &quot;config.guestFullName&quot;)
        )

    if &quot;size&quot; in selection:
        cpu = defaultto(vm, &quot;config.hardware.numCPU&quot;)
        ram = &quot;{} MB&quot;.format(defaultto(vm, &quot;config.hardware.memoryMB&quot;))
        vm_select_info[&quot;size&quot;] = &quot;cpu: {}\nram: {}&quot;.format(cpu, ram)
        vm_select_info[&quot;size_dict&quot;] = {
            &quot;cpu&quot;: cpu,
            &quot;memory&quot;: ram,
        }

    if &quot;state&quot; in selection:
        vm_select_info[&quot;state&quot;] = str(defaultto(vm, &quot;summary.runtime.powerState&quot;))

    if &quot;guest_id&quot; in selection:
        vm_select_info[&quot;guest_id&quot;] = defaultto(vm, &quot;config.guestId&quot;)

    if &quot;hostname&quot; in selection:
        vm_select_info[&quot;hostname&quot;] = vm[&quot;object&quot;].guest.hostName

    if &quot;path&quot; in selection:
        vm_select_info[&quot;path&quot;] = defaultto(vm, &quot;config.files.vmPathName&quot;)

    if &quot;tools_status&quot; in selection:
        vm_select_info[&quot;tools_status&quot;] = str(defaultto(vm, &quot;guest.toolsStatus&quot;))

    if &quot;private_ips&quot; in selection or &quot;networks&quot; in selection:
        network_full_info = {}
        ip_addresses = []

        if &quot;guest.net&quot; in vm:
            for net in vm[&quot;guest.net&quot;]:
                network_full_info[net.network] = {
                    &quot;connected&quot;: net.connected,
                    &quot;ip_addresses&quot;: net.ipAddress,
                    &quot;mac_address&quot;: net.macAddress,
                }
                ip_addresses.extend(net.ipAddress)

        if &quot;private_ips&quot; in selection:
            vm_select_info[&quot;private_ips&quot;] = ip_addresses

        if &quot;networks&quot; in selection:
            vm_select_info[&quot;networks&quot;] = network_full_info

    if any(x in [&quot;devices&quot;, &quot;mac_address&quot;, &quot;mac_addresses&quot;] for x in selection):
        device_full_info = {}
        device_mac_addresses = []
        if &quot;config.hardware.device&quot; in vm:
            for device in vm[&quot;config.hardware.device&quot;]:
                device_full_info[device.deviceInfo.label] = {}
                if &quot;devices&quot; in selection:
                    device_full_info[device.deviceInfo.label][&quot;key&quot;] = (device.key,)
                    device_full_info[device.deviceInfo.label][&quot;label&quot;] = (
                        device.deviceInfo.label,
                    )
                    device_full_info[device.deviceInfo.label][&quot;summary&quot;] = (
                        device.deviceInfo.summary,
                    )
                    device_full_info[device.deviceInfo.label][&quot;type&quot;] = type(
                        device
                    ).__name__.rsplit(&quot;.&quot;, 1)[1]

                    if device.unitNumber:
                        device_full_info[device.deviceInfo.label][
                            &quot;unitNumber&quot;
                        ] = device.unitNumber

                    if hasattr(device, &quot;connectable&quot;) and device.connectable:
                        device_full_info[device.deviceInfo.label][
                            &quot;startConnected&quot;
                        ] = device.connectable.startConnected
                        device_full_info[device.deviceInfo.label][
                            &quot;allowGuestControl&quot;
                        ] = device.connectable.allowGuestControl
                        device_full_info[device.deviceInfo.label][
                            &quot;connected&quot;
                        ] = device.connectable.connected
                        device_full_info[device.deviceInfo.label][
                            &quot;status&quot;
                        ] = device.connectable.status

                    if hasattr(device, &quot;controllerKey&quot;) and device.controllerKey:
                        device_full_info[device.deviceInfo.label][
                            &quot;controllerKey&quot;
                        ] = device.controllerKey

                    if hasattr(device, &quot;addressType&quot;):
                        device_full_info[device.deviceInfo.label][
                            &quot;addressType&quot;
                        ] = device.addressType

                    if hasattr(device, &quot;busNumber&quot;):
                        device_full_info[device.deviceInfo.label][
                            &quot;busNumber&quot;
                        ] = device.busNumber

                    if hasattr(device, &quot;device&quot;):
                        device_full_info[device.deviceInfo.label][
                            &quot;deviceKeys&quot;
                        ] = device.device

                    if hasattr(device, &quot;videoRamSizeInKB&quot;):
                        device_full_info[device.deviceInfo.label][
                            &quot;videoRamSizeInKB&quot;
                        ] = device.videoRamSizeInKB

                    if isinstance(device, vim.vm.device.VirtualDisk):
                        device_full_info[device.deviceInfo.label][
                            &quot;capacityInKB&quot;
                        ] = device.capacityInKB
                        device_full_info[device.deviceInfo.label][
                            &quot;diskMode&quot;
                        ] = device.backing.diskMode
                        device_full_info[device.deviceInfo.label][
                            &quot;fileName&quot;
                        ] = device.backing.fileName

                if hasattr(device, &quot;macAddress&quot;):
                    device_full_info[device.deviceInfo.label][
                        &quot;macAddress&quot;
                    ] = device.macAddress
                    device_mac_addresses.append(device.macAddress)

        if &quot;devices&quot; in selection:
            vm_select_info[&quot;devices&quot;] = device_full_info

        if &quot;mac_address&quot; in selection or &quot;mac_addresses&quot; in selection:
            vm_select_info[&quot;mac_addresses&quot;] = device_mac_addresses

    if &quot;storage&quot; in selection:
        storage_full_info = {
            &quot;committed&quot;: int(vm[&quot;summary.storage.committed&quot;])
            if &quot;summary.storage.committed&quot; in vm
            else &quot;N/A&quot;,
            &quot;uncommitted&quot;: int(vm[&quot;summary.storage.uncommitted&quot;])
            if &quot;summary.storage.uncommitted&quot; in vm
            else &quot;N/A&quot;,
            &quot;unshared&quot;: int(vm[&quot;summary.storage.unshared&quot;])
            if &quot;summary.storage.unshared&quot; in vm
            else &quot;N/A&quot;,
        }
        vm_select_info[&quot;storage&quot;] = storage_full_info

    if &quot;files&quot; in selection:
        file_full_info = {}
        if &quot;layoutEx.file&quot; in vm:
            for filename in vm[&quot;layoutEx.file&quot;]:
                file_full_info[filename.key] = {
                    &quot;key&quot;: filename.key,
                    &quot;name&quot;: filename.name,
                    &quot;size&quot;: filename.size,
                    &quot;type&quot;: filename.type,
                }
        vm_select_info[&quot;files&quot;] = file_full_info

    return vm_select_info


def _format_instance_info(vm):
    device_full_info = {}
    device_mac_addresses = []
    if &quot;config.hardware.device&quot; in vm:
        for device in vm[&quot;config.hardware.device&quot;]:
            device_full_info[device.deviceInfo.label] = {
                &quot;key&quot;: device.key,
                &quot;label&quot;: device.deviceInfo.label,
                &quot;summary&quot;: device.deviceInfo.summary,
                &quot;type&quot;: type(device).__name__.rsplit(&quot;.&quot;, 1)[1],
            }

            if device.unitNumber:
                device_full_info[device.deviceInfo.label][
                    &quot;unitNumber&quot;
                ] = device.unitNumber

            if hasattr(device, &quot;connectable&quot;) and device.connectable:
                device_full_info[device.deviceInfo.label][
                    &quot;startConnected&quot;
                ] = device.connectable.startConnected
                device_full_info[device.deviceInfo.label][
                    &quot;allowGuestControl&quot;
                ] = device.connectable.allowGuestControl
                device_full_info[device.deviceInfo.label][
                    &quot;connected&quot;
                ] = device.connectable.connected
                device_full_info[device.deviceInfo.label][
                    &quot;status&quot;
                ] = device.connectable.status

            if hasattr(device, &quot;controllerKey&quot;) and device.controllerKey:
                device_full_info[device.deviceInfo.label][
                    &quot;controllerKey&quot;
                ] = device.controllerKey

            if hasattr(device, &quot;addressType&quot;):
                device_full_info[device.deviceInfo.label][
                    &quot;addressType&quot;
                ] = device.addressType

            if hasattr(device, &quot;macAddress&quot;):
                device_full_info[device.deviceInfo.label][
                    &quot;macAddress&quot;
                ] = device.macAddress
                device_mac_addresses.append(device.macAddress)

            if hasattr(device, &quot;busNumber&quot;):
                device_full_info[device.deviceInfo.label][
                    &quot;busNumber&quot;
                ] = device.busNumber

            if hasattr(device, &quot;device&quot;):
                device_full_info[device.deviceInfo.label][&quot;deviceKeys&quot;] = device.device

            if hasattr(device, &quot;videoRamSizeInKB&quot;):
                device_full_info[device.deviceInfo.label][
                    &quot;videoRamSizeInKB&quot;
                ] = device.videoRamSizeInKB

            if isinstance(device, vim.vm.device.VirtualDisk):
                device_full_info[device.deviceInfo.label][
                    &quot;capacityInKB&quot;
                ] = device.capacityInKB
                device_full_info[device.deviceInfo.label][
                    &quot;diskMode&quot;
                ] = device.backing.diskMode
                device_full_info[device.deviceInfo.label][
                    &quot;fileName&quot;
                ] = device.backing.fileName

    storage_full_info = {
        &quot;committed&quot;: int(vm[&quot;summary.storage.committed&quot;])
        if &quot;summary.storage.committed&quot; in vm
        else &quot;N/A&quot;,
        &quot;uncommitted&quot;: int(vm[&quot;summary.storage.uncommitted&quot;])
        if &quot;summary.storage.uncommitted&quot; in vm
        else &quot;N/A&quot;,
        &quot;unshared&quot;: int(vm[&quot;summary.storage.unshared&quot;])
        if &quot;summary.storage.unshared&quot; in vm
        else &quot;N/A&quot;,
    }

    file_full_info = {}
    if &quot;layoutEx.file&quot; in vm:
        for filename in vm[&quot;layoutEx.file&quot;]:
            file_full_info[filename.key] = {
                &quot;key&quot;: filename.key,
                &quot;name&quot;: filename.name,
                &quot;size&quot;: filename.size,
                &quot;type&quot;: filename.type,
            }

    network_full_info = {}
    ip_addresses = []
    if &quot;guest.net&quot; in vm:
        for net in vm[&quot;guest.net&quot;]:
            network_full_info[net.network] = {
                &quot;connected&quot;: net.connected,
                &quot;ip_addresses&quot;: net.ipAddress,
                &quot;mac_address&quot;: net.macAddress,
            }
            ip_addresses.extend(net.ipAddress)

    cpu = vm[&quot;config.hardware.numCPU&quot;] if &quot;config.hardware.numCPU&quot; in vm else &quot;N/A&quot;
    ram = (
        &quot;{} MB&quot;.format(vm[&quot;config.hardware.memoryMB&quot;])
        if &quot;config.hardware.memoryMB&quot; in vm
        else &quot;N/A&quot;
    )
    vm_full_info = {
        &quot;id&quot;: str(vm[&quot;name&quot;]),
        &quot;image&quot;: &quot;{} (Detected)&quot;.format(vm[&quot;config.guestFullName&quot;])
        if &quot;config.guestFullName&quot; in vm
        else &quot;N/A&quot;,
        &quot;size&quot;: &quot;cpu: {}\nram: {}&quot;.format(cpu, ram),
        &quot;size_dict&quot;: {&quot;cpu&quot;: cpu, &quot;memory&quot;: ram},
        &quot;state&quot;: str(vm[&quot;summary.runtime.powerState&quot;])
        if &quot;summary.runtime.powerState&quot; in vm
        else &quot;N/A&quot;,
        &quot;private_ips&quot;: ip_addresses,
        &quot;public_ips&quot;: [],
        &quot;devices&quot;: device_full_info,
        &quot;storage&quot;: storage_full_info,
        &quot;files&quot;: file_full_info,
        &quot;guest_id&quot;: str(vm[&quot;config.guestId&quot;]) if &quot;config.guestId&quot; in vm else &quot;N/A&quot;,
        &quot;hostname&quot;: str(vm[&quot;object&quot;].guest.hostName),
        &quot;mac_addresses&quot;: device_mac_addresses,
        &quot;networks&quot;: network_full_info,
        &quot;path&quot;: str(vm[&quot;config.files.vmPathName&quot;])
        if &quot;config.files.vmPathName&quot; in vm
        else &quot;N/A&quot;,
        &quot;tools_status&quot;: str(vm[&quot;guest.toolsStatus&quot;])
        if &quot;guest.toolsStatus&quot; in vm
        else &quot;N/A&quot;,
    }

    return vm_full_info


def _get_snapshots(snapshot_list, current_snapshot=None, parent_snapshot_path=&quot;&quot;):
    snapshots = {}
    for snapshot in snapshot_list:
        snapshot_path = &quot;{}/{}&quot;.format(parent_snapshot_path, snapshot.name)
        snapshots[snapshot_path] = {
            &quot;name&quot;: snapshot.name,
            &quot;description&quot;: snapshot.description,
            &quot;created&quot;: str(snapshot.createTime).split(&quot;.&quot;)[0],
            &quot;state&quot;: snapshot.state,
            &quot;path&quot;: snapshot_path,
        }

        if current_snapshot and current_snapshot == snapshot.snapshot:
            return snapshots[snapshot_path]

        # Check if child snapshots exist
        if snapshot.childSnapshotList:
            ret = _get_snapshots(
                snapshot.childSnapshotList, current_snapshot, snapshot_path
            )
            if current_snapshot:
                return ret
            snapshots.update(ret)

    return snapshots


def _get_snapshot_ref_helper(base_snapshot, snapshot_name):
    if base_snapshot.name == snapshot_name:
        return base_snapshot

    for snapshot in base_snapshot.childSnapshotList:
        snapshot_ref = _get_snapshot_ref_helper(snapshot, snapshot_name)
        if snapshot_ref is not None:
            return snapshot_ref

    return None


def _get_snapshot_ref_by_name(vm_ref, snapshot_name):
    snapshot_ref = None
    try:
        for root_snapshot in vm_ref.snapshot.rootSnapshotList:
            snapshot_ref = _get_snapshot_ref_helper(root_snapshot, snapshot_name)
            if snapshot_ref is not None:
                break
    except (IndexError, AttributeError):
        snapshot_ref = None

    return snapshot_ref


def _upg_tools_helper(vm, reboot=False):
    # Exit if template
    if vm.config.template:
        status = &quot;VMware tools cannot be updated on a template&quot;

    # Exit if VMware tools is already up to date
    elif vm.guest.toolsStatus == &quot;toolsOk&quot;:
        status = &quot;VMware tools is already up to date&quot;

    # Exit if VM is not powered on
    elif vm.summary.runtime.powerState != &quot;poweredOn&quot;:
        status = &quot;VM must be powered on to upgrade tools&quot;

    # Exit if VMware tools is either not running or not installed
    elif vm.guest.toolsStatus in [&quot;toolsNotRunning&quot;, &quot;toolsNotInstalled&quot;]:
        status = &quot;VMware tools is either not running or not installed&quot;

    # If vmware tools is out of date, check major OS family
    # Upgrade tools on Linux and Windows guests
    elif vm.guest.toolsStatus == &quot;toolsOld&quot;:
        log.info(&quot;Upgrading VMware tools on %s&quot;, vm.name)
        try:
            if vm.guest.guestFamily == &quot;windowsGuest&quot; and not reboot:
                log.info(&quot;Reboot suppressed on %s&quot;, vm.name)
                task = vm.UpgradeTools('/S /v&quot;/qn REBOOT=R&quot;')
            elif vm.guest.guestFamily in [&quot;linuxGuest&quot;, &quot;windowsGuest&quot;]:
                task = vm.UpgradeTools()
            else:
                return &quot;Only Linux and Windows guests are currently supported&quot;
            salt.utils.vmware.wait_for_task(
                task, vm.name, &quot;tools upgrade&quot;, sleep_seconds=5, log_level=&quot;info&quot;
            )
        except Exception as exc:  # pylint: disable=broad-except
            log.error(
                &quot;Error while upgrading VMware tools on VM %s: %s&quot;,
                vm.name,
                exc,
                # Show the traceback if the debug logging level is enabled
                exc_info_on_loglevel=logging.DEBUG,
            )
            return &quot;VMware tools upgrade failed&quot;
        status = &quot;VMware tools upgrade succeeded&quot;
    else:
        status = &quot;VMWare tools could not be upgraded&quot;

    return status


def _get_hba_type(hba_type):
    &quot;&quot;&quot;
    Convert a string representation of a HostHostBusAdapter into an
    object reference.
    &quot;&quot;&quot;
    if hba_type == &quot;parallel&quot;:
        return vim.host.ParallelScsiHba
    elif hba_type == &quot;block&quot;:
        return vim.host.BlockHba
    elif hba_type == &quot;iscsi&quot;:
        return vim.host.InternetScsiHba
    elif hba_type == &quot;fibre&quot;:
        return vim.host.FibreChannelHba

    raise ValueError(&quot;Unknown Host Bus Adapter Type&quot;)


def test_vcenter_connection(kwargs=None, call=None):
    &quot;&quot;&quot;
    Test if the connection can be made to the vCenter server using
    the specified credentials inside ``/etc/salt/cloud.providers``
    or ``/etc/salt/cloud.providers.d/vmware.conf``

    CLI Example:

    .. code-block:: bash

        salt-cloud -f test_vcenter_connection my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The test_vcenter_connection function must be called with -f or --function.&quot;
        )

    try:
        # Get the service instance object
        _get_si()
    except Exception as exc:  # pylint: disable=broad-except
        return &quot;failed to connect: {}&quot;.format(exc)

    return &quot;connection successful&quot;


def get_vcenter_version(kwargs=None, call=None):
    &quot;&quot;&quot;
    Show the vCenter Server version with build number.

    CLI Example:

    .. code-block:: bash

        salt-cloud -f get_vcenter_version my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The get_vcenter_version function must be called with -f or --function.&quot;
        )

    # Get the inventory
    inv = salt.utils.vmware.get_inventory(_get_si())

    return inv.about.fullName


def list_datacenters(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the data centers for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_datacenters my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_datacenters function must be called with -f or --function.&quot;
        )

    return {&quot;Datacenters&quot;: salt.utils.vmware.list_datacenters(_get_si())}


def list_portgroups(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the distributed virtual portgroups for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_portgroups my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_portgroups function must be called with -f or --function.&quot;
        )

    return {&quot;Portgroups&quot;: salt.utils.vmware.list_portgroups(_get_si())}


def list_clusters(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the clusters for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_clusters my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_clusters function must be called with -f or --function.&quot;
        )

    return {&quot;Clusters&quot;: salt.utils.vmware.list_clusters(_get_si())}


def list_datastore_clusters(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the datastore clusters for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_datastore_clusters my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_datastore_clusters function must be called with -f or --function.&quot;
        )

    return {&quot;Datastore Clusters&quot;: salt.utils.vmware.list_datastore_clusters(_get_si())}


def list_datastores(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the datastores for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_datastores my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_datastores function must be called with -f or --function.&quot;
        )

    return {&quot;Datastores&quot;: salt.utils.vmware.list_datastores(_get_si())}


def list_hosts(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the hosts for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hosts my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_hosts function must be called with -f or --function.&quot;
        )

    return {&quot;Hosts&quot;: salt.utils.vmware.list_hosts(_get_si())}


def list_resourcepools(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the resource pools for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_resourcepools my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_resourcepools function must be called with -f or --function.&quot;
        )

    return {&quot;Resource Pools&quot;: salt.utils.vmware.list_resourcepools(_get_si())}


def list_networks(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the standard networks for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_networks my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_networks function must be called with -f or --function.&quot;
        )

    return {&quot;Networks&quot;: salt.utils.vmware.list_networks(_get_si())}


def list_nodes_min(kwargs=None, call=None):
    &quot;&quot;&quot;
    Return a list of all VMs and templates that are on the specified provider, with no details

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_nodes_min my-vmware-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_min function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = [&quot;name&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        ret[vm[&quot;name&quot;]] = {&quot;state&quot;: &quot;Running&quot;, &quot;id&quot;: vm[&quot;name&quot;]}

    return ret


def list_nodes(kwargs=None, call=None):
    &quot;&quot;&quot;
    Return a list of all VMs and templates that are on the specified provider, with basic fields

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_nodes my-vmware-config

    To return a list of all VMs and templates present on ALL configured providers, with basic
    fields:

    CLI Example:

    .. code-block:: bash

        salt-cloud -Q
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = [
        &quot;name&quot;,
        &quot;guest.ipAddress&quot;,
        &quot;config.guestFullName&quot;,
        &quot;config.hardware.numCPU&quot;,
        &quot;config.hardware.memoryMB&quot;,
        &quot;summary.runtime.powerState&quot;,
    ]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        cpu = vm[&quot;config.hardware.numCPU&quot;] if &quot;config.hardware.numCPU&quot; in vm else &quot;N/A&quot;
        ram = (
            &quot;{} MB&quot;.format(vm[&quot;config.hardware.memoryMB&quot;])
            if &quot;config.hardware.memoryMB&quot; in vm
            else &quot;N/A&quot;
        )
        vm_info = {
            &quot;id&quot;: vm[&quot;name&quot;],
            &quot;image&quot;: &quot;{} (Detected)&quot;.format(vm[&quot;config.guestFullName&quot;])
            if &quot;config.guestFullName&quot; in vm
            else &quot;N/A&quot;,
            &quot;size&quot;: &quot;cpu: {}\nram: {}&quot;.format(cpu, ram),
            &quot;size_dict&quot;: {&quot;cpu&quot;: cpu, &quot;memory&quot;: ram},
            &quot;state&quot;: str(vm[&quot;summary.runtime.powerState&quot;])
            if &quot;summary.runtime.powerState&quot; in vm
            else &quot;N/A&quot;,
            &quot;private_ips&quot;: [vm[&quot;guest.ipAddress&quot;]] if &quot;guest.ipAddress&quot; in vm else [],
            &quot;public_ips&quot;: [],
        }
        ret[vm_info[&quot;id&quot;]] = vm_info

    return ret


def list_nodes_full(kwargs=None, call=None):
    &quot;&quot;&quot;
    Return a list of all VMs and templates that are on the specified provider, with full details

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_nodes_full my-vmware-config

    To return a list of all VMs and templates present on ALL configured providers, with full
    details:

    CLI Example:

    .. code-block:: bash

        salt-cloud -F
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_full function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = [
        &quot;config.hardware.device&quot;,
        &quot;summary.storage.committed&quot;,
        &quot;summary.storage.uncommitted&quot;,
        &quot;summary.storage.unshared&quot;,
        &quot;layoutEx.file&quot;,
        &quot;config.guestFullName&quot;,
        &quot;config.guestId&quot;,
        &quot;guest.net&quot;,
        &quot;config.hardware.memoryMB&quot;,
        &quot;name&quot;,
        &quot;config.hardware.numCPU&quot;,
        &quot;config.files.vmPathName&quot;,
        &quot;summary.runtime.powerState&quot;,
        &quot;guest.toolsStatus&quot;,
    ]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
<A NAME="9"></A>    )

    for vm in vm_list:
        ret[vm[&quot;name&quot;]] = _format_instance_info(<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#9',2,'match66669-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>vm)

    return ret


def list_nodes_select(call=None):
    &quot;&quot;&quot;
    Return a list of all VMs and templates that are on the specified provider, with fields
    specified under ``query.selection`` in ``/etc/salt/cloud``

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_nodes_select my-vmware-config

    To return a list of all VMs and templates present on ALL configured providers, with
    fields specified under ``query.selection`` in ``/etc/salt/cloud``:

    CLI Example:

    .. code-block:: bash

        salt-cloud -S
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_select function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = []
    selection =</B></FONT> __opts__.get(&quot;query.selection&quot;)

    if not selection:
        raise SaltCloudSystemExit(&quot;query.selection not found in /etc/salt/cloud&quot;)

    if &quot;id&quot; in selection:
        vm_properties.append(&quot;name&quot;)

    if &quot;image&quot; in selection:
        vm_properties.append(&quot;config.guestFullName&quot;)

    if &quot;size&quot; in selection:
        vm_properties.extend([&quot;config.hardware.numCPU&quot;, &quot;config.hardware.memoryMB&quot;])

    if &quot;state&quot; in selection:
        vm_properties.append(&quot;summary.runtime.powerState&quot;)

    if &quot;private_ips&quot; in selection or &quot;networks&quot; in selection:
        vm_properties.append(&quot;guest.net&quot;)

    if (
        &quot;devices&quot; in selection
        or &quot;mac_address&quot; in selection
        or &quot;mac_addresses&quot; in selection
    ):
        vm_properties.append(&quot;config.hardware.device&quot;)

    if &quot;storage&quot; in selection:
        vm_properties.extend(
            [
                &quot;config.hardware.device&quot;,
                &quot;summary.storage.committed&quot;,
                &quot;summary.storage.uncommitted&quot;,
                &quot;summary.storage.unshared&quot;,
            ]
        )

    if &quot;files&quot; in selection:
        vm_properties.append(&quot;layoutEx.file&quot;)

    if &quot;guest_id&quot; in selection:
        vm_properties.append(&quot;config.guestId&quot;)

    if &quot;hostname&quot; in selection:
        vm_properties.append(&quot;guest.hostName&quot;)

    if &quot;path&quot; in selection:
        vm_properties.append(&quot;config.files.vmPathName&quot;)

    if &quot;tools_status&quot; in selection:
        vm_properties.append(&quot;guest.toolsStatus&quot;)

    if not vm_properties:
        return {}
    elif &quot;name&quot; not in vm_properties:
        vm_properties.append(&quot;name&quot;)

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        ret[vm[&quot;name&quot;]] = _format_instance_info_select(vm, selection)
    return ret


def show_instance(name, call=None):
    &quot;&quot;&quot;
    List all available details of the specified VM

    CLI Example:

    .. code-block:: bash

        salt-cloud -a show_instance vmname
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The show_instance action must be called with -a or --action.&quot;
        )

    vm_properties = [
        &quot;config.hardware.device&quot;,
        &quot;summary.storage.committed&quot;,
        &quot;summary.storage.uncommitted&quot;,
        &quot;summary.storage.unshared&quot;,
        &quot;layoutEx.file&quot;,
        &quot;config.guestFullName&quot;,
        &quot;config.guestId&quot;,
        &quot;guest.net&quot;,
        &quot;config.hardware.memoryMB&quot;,
        &quot;name&quot;,
        &quot;config.hardware.numCPU&quot;,
        &quot;config.files.vmPathName&quot;,
        &quot;summary.runtime.powerState&quot;,
        &quot;guest.toolsStatus&quot;,
    ]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            return _format_instance_info(vm)

    return {}


def avail_images(call=None):
    &quot;&quot;&quot;
    Return a list of all the templates present in this VMware environment with basic
    details

    CLI Example:

    .. code-block:: bash

        salt-cloud --list-images my-vmware-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_images function must be called with &quot;
            &quot;-f or --function, or with the --list-images option.&quot;
        )

    templates = {}
    vm_properties = [
        &quot;name&quot;,
        &quot;config.template&quot;,
        &quot;config.guestFullName&quot;,
        &quot;config.hardware.numCPU&quot;,
        &quot;config.hardware.memoryMB&quot;,
    ]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if &quot;config.template&quot; in vm and vm[&quot;config.template&quot;]:
            templates[vm[&quot;name&quot;]] = {
                &quot;name&quot;: vm[&quot;name&quot;],
                &quot;guest_fullname&quot;: vm[&quot;config.guestFullName&quot;]
                if &quot;config.guestFullName&quot; in vm
                else &quot;N/A&quot;,
                &quot;cpus&quot;: vm[&quot;config.hardware.numCPU&quot;]
                if &quot;config.hardware.numCPU&quot; in vm
                else &quot;N/A&quot;,
                &quot;ram&quot;: vm[&quot;config.hardware.memoryMB&quot;]
                if &quot;config.hardware.memoryMB&quot; in vm
                else &quot;N/A&quot;,
            }

    return templates


def avail_locations(call=None):
    &quot;&quot;&quot;
    Return a list of all the available locations/datacenters in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud --list-locations my-vmware-config
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_locations function must be called with &quot;
            &quot;-f or --function, or with the --list-locations option.&quot;
        )

    return list_datacenters(call=&quot;function&quot;)


def avail_sizes(call=None):
    &quot;&quot;&quot;
    Return a list of all the available sizes in this VMware environment.

    CLI Example:

    .. code-block:: bash

        salt-cloud --list-sizes my-vmware-config

    .. note::

        Since sizes are built into templates, this function will return
        an empty dictionary.

    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_sizes function must be called with &quot;
            &quot;-f or --function, or with the --list-sizes option.&quot;
        )

    log.warning(
        &quot;Because sizes are built into templates with VMware, there are no sizes &quot;
        &quot;to return.&quot;
    )

    return {}


def list_templates(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the templates present in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_templates my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_templates function must be called with -f or --function.&quot;
        )

    return {&quot;Templates&quot;: avail_images(call=&quot;function&quot;)}


def list_folders(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the folders for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_folders my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_folders function must be called with -f or --function.&quot;
        )

    return {&quot;Folders&quot;: salt.utils.vmware.list_folders(_get_si())}


def list_snapshots(kwargs=None, call=None):
    &quot;&quot;&quot;
    List snapshots either for all VMs and templates or for a specific VM/template
    in this VMware environment

    To list snapshots for all VMs and templates:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_snapshots my-vmware-config

    To list snapshots for a specific VM/template:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_snapshots my-vmware-config name=&quot;vmname&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_snapshots function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = [&quot;name&quot;, &quot;rootSnapshot&quot;, &quot;snapshot&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;rootSnapshot&quot;]:
            if kwargs and kwargs.get(&quot;name&quot;) == vm[&quot;name&quot;]:
                return {vm[&quot;name&quot;]: _get_snapshots(vm[&quot;snapshot&quot;].rootSnapshotList)}
            else:
                ret[vm[&quot;name&quot;]] = _get_snapshots(vm[&quot;snapshot&quot;].rootSnapshotList)
        else:
            if kwargs and kwargs.get(&quot;name&quot;) == vm[&quot;name&quot;]:
                return {}

    return ret


def start(name, call=None):
    &quot;&quot;&quot;
    To start/power on a VM using its name

    CLI Example:

    .. code-block:: bash

        salt-cloud -a start vmname
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The start action must be called with -a or --action.&quot;
        )

    vm_properties = [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if vm[&quot;summary.runtime.powerState&quot;] == &quot;poweredOn&quot;:
                ret = &quot;already powered on&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            try:
                log.info(&quot;Starting VM %s&quot;, name)
                task = vm[&quot;object&quot;].PowerOn()
                salt.utils.vmware.wait_for_task(task, name, &quot;power on&quot;)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while powering on VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return &quot;failed to power on&quot;

    return &quot;powered on&quot;


def stop(name, soft=False, call=None):
    &quot;&quot;&quot;
    To stop/power off a VM using its name

    .. note::

        If ``soft=True`` then issues a command to the guest operating system
        asking it to perform a clean shutdown of all services.
        Default is soft=False

        For ``soft=True`` vmtools should be installed on guest system.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a stop vmname
        salt-cloud -a stop vmname soft=True
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    vm_properties = [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if vm[&quot;summary.runtime.powerState&quot;] == &quot;poweredOff&quot;:
                ret = &quot;already powered off&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            try:
                log.info(&quot;Stopping VM %s&quot;, name)
                if soft:
                    vm[&quot;object&quot;].ShutdownGuest()
                else:
                    task = vm[&quot;object&quot;].PowerOff()
                    salt.utils.vmware.wait_for_task(task, name, &quot;power off&quot;)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while powering off VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return &quot;failed to power off&quot;

    return &quot;powered off&quot;


def suspend(name, call=None):
    &quot;&quot;&quot;
    To suspend a VM using its name

    CLI Example:

    .. code-block:: bash

        salt-cloud -a suspend vmname
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The suspend action must be called with -a or --action.&quot;
        )

    vm_properties = [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if vm[&quot;summary.runtime.powerState&quot;] == &quot;poweredOff&quot;:
                ret = &quot;cannot suspend in powered off state&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            elif vm[&quot;summary.runtime.powerState&quot;] == &quot;suspended&quot;:
                ret = &quot;already suspended&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            try:
                log.info(&quot;Suspending VM %s&quot;, name)
                task = vm[&quot;object&quot;].Suspend()
                salt.utils.vmware.wait_for_task(task, name, &quot;suspend&quot;)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while suspending VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return &quot;failed to suspend&quot;

    return &quot;suspended&quot;


def reset(name, soft=False, call=None):
    &quot;&quot;&quot;
    To reset a VM using its name

    .. note::

        If ``soft=True`` then issues a command to the guest operating system
        asking it to perform a reboot. Otherwise hypervisor will terminate VM and start it again.
        Default is soft=False

        For ``soft=True`` vmtools should be installed on guest system.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a reset vmname
        salt-cloud -a reset vmname soft=True
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The reset action must be called with -a or --action.&quot;
        )

    vm_properties = [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if (
                vm[&quot;summary.runtime.powerState&quot;] == &quot;suspended&quot;
                or vm[&quot;summary.runtime.powerState&quot;] == &quot;poweredOff&quot;
            ):
                ret = &quot;cannot reset in suspended/powered off state&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            try:
                log.info(&quot;Resetting VM %s&quot;, name)
                if soft:
                    vm[&quot;object&quot;].RebootGuest()
                else:
                    task = vm[&quot;object&quot;].ResetVM_Task()
                    salt.utils.vmware.wait_for_task(task, name, &quot;reset&quot;)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while resetting VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return &quot;failed to reset&quot;

    return &quot;reset&quot;


def terminate(name, call=None):
    &quot;&quot;&quot;
    To do an immediate power off of a VM using its name. A ``SIGKILL``
    is issued to the vmx process of the VM

    CLI Example:

    .. code-block:: bash

        salt-cloud -a terminate vmname
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The terminate action must be called with -a or --action.&quot;
        )

    vm_properties = [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if vm[&quot;summary.runtime.powerState&quot;] == &quot;poweredOff&quot;:
                ret = &quot;already powered off&quot;
                log.info(&quot;VM %s %s&quot;, name, ret)
                return ret
            try:
                log.info(&quot;Terminating VM %s&quot;, name)
                vm[&quot;object&quot;].Terminate()
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while terminating VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
<A NAME="3"></A>                )
                return &quot;failed to terminate&quot;

    r<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#3',2,'match66669-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>eturn &quot;terminated&quot;


def destroy(name, call=None):
    &quot;&quot;&quot;
    To destroy a VM from the VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -d vmname
        salt-cloud --destroy vmname
        salt-cloud -a destroy vmname
    &quot;&quot;&quot;
    if call == &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The destroy action must be called with -d, --destroy, -a or --action.&quot;
        )

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroying instance&quot;,
        &quot;salt/cloud/{}/destroying&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    vm_properties =</B></FONT> [&quot;name&quot;, &quot;summary.runtime.powerState&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        if vm[&quot;name&quot;] == name:
            if vm[&quot;summary.runtime.powerState&quot;] != &quot;poweredOff&quot;:
                # Power off the vm first
                try:
                    log.info(&quot;Powering Off VM %s&quot;, name)
                    task = vm[&quot;object&quot;].PowerOff()
                    salt.utils.vmware.wait_for_task(task, name, &quot;power off&quot;)
                except Exception as exc:  # pylint: disable=broad-except
                    log.error(
                        &quot;Error while powering off VM %s: %s&quot;,
                        name,
                        exc,
                        # Show the traceback if the debug logging level is enabled
                        exc_info_on_loglevel=logging.DEBUG,
                    )
                    return &quot;failed to destroy&quot;
            try:
                log.info(&quot;Destroying VM %s&quot;, name)
                task = vm[&quot;object&quot;].Destroy_Task()
                salt.utils.vmware.wait_for_task(task, name, &quot;destroy&quot;)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Error while destroying VM %s: %s&quot;,
                    name,
                    exc,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
<A NAME="2"></A>                )
                return &quot;failed to destroy&quot;

    __utils__<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#2',2,'match66669-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroyed instance&quot;,
        &quot;salt/cloud/{}/destroyed&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )
    if __opts__.get(&quot;update_cachedir&quot;, False) is True:
        __utils__[&quot;cloud.delete_minion_cachedir&quot;](
<A NAME="0"></A>            name, _get_active_provider_name().split(&quot;:&quot;)[</B></FONT>0], __opts__
        )

    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#0',2,'match66669-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return True


def create(vm_):
    &quot;&quot;&quot;
    To create a single VM in the VMware environment.

    Sample profile and arguments that can be specified in it can be found
    :ref:`here. &lt;vmware-cloud-profile&gt;`

    CLI Example:

    .. code-block:: bash

        salt-cloud -p vmware-centos6.5 vmname
    &quot;&quot;&quot;
    try:
        # Check for required profile parameters before sending any API calls.
        if (
            vm_[&quot;profile&quot;]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or &quot;vmware&quot;,
                vm_[&quot;profile&quot;],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;starting create&quot;,
        &quot;salt/cloud/{}/creating&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;creating&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[</B></FONT>&quot;transport&quot;],
    )

    vm_name = config.get_cloud_config_value(&quot;name&quot;, vm_, __opts__, default=None)
    folder = config.get_cloud_config_value(&quot;folder&quot;, vm_, __opts__, default=None)
    datacenter = config.get_cloud_config_value(
        &quot;datacenter&quot;, vm_, __opts__, default=None
    )
    resourcepool = config.get_cloud_config_value(
        &quot;resourcepool&quot;, vm_, __opts__, default=None
    )
    cluster = config.get_cloud_config_value(&quot;cluster&quot;, vm_, __opts__, default=None)
    datastore = config.get_cloud_config_value(&quot;datastore&quot;, vm_, __opts__, default=None)
    host = config.get_cloud_config_value(&quot;host&quot;, vm_, __opts__, default=None)
    template = config.get_cloud_config_value(&quot;template&quot;, vm_, __opts__, default=False)
    num_cpus = config.get_cloud_config_value(&quot;num_cpus&quot;, vm_, __opts__, default=None)
    cores_per_socket = config.get_cloud_config_value(
        &quot;cores_per_socket&quot;, vm_, __opts__, default=None
    )
    instant_clone = config.get_cloud_config_value(
        &quot;instant_clone&quot;, vm_, __opts__, default=False
    )
    memory = config.get_cloud_config_value(&quot;memory&quot;, vm_, __opts__, default=None)
    devices = config.get_cloud_config_value(&quot;devices&quot;, vm_, __opts__, default=None)
    extra_config = config.get_cloud_config_value(
        &quot;extra_config&quot;, vm_, __opts__, default=None
    )
    annotation = config.get_cloud_config_value(
        &quot;annotation&quot;, vm_, __opts__, default=None
    )
    power = config.get_cloud_config_value(&quot;power_on&quot;, vm_, __opts__, default=True)
    key_filename = config.get_cloud_config_value(
        &quot;private_key&quot;, vm_, __opts__, search_global=False, default=None
    )
    deploy = config.get_cloud_config_value(
        &quot;deploy&quot;, vm_, __opts__, search_global=True, default=True
    )
    wait_for_ip_timeout = config.get_cloud_config_value(
        &quot;wait_for_ip_timeout&quot;, vm_, __opts__, default=20 * 60
    )
    domain = config.get_cloud_config_value(
        &quot;domain&quot;, vm_, __opts__, search_global=False, default=&quot;local&quot;
    )
    hardware_version = config.get_cloud_config_value(
        &quot;hardware_version&quot;, vm_, __opts__, search_global=False, default=None
    )
    guest_id = config.get_cloud_config_value(
        &quot;image&quot;, vm_, __opts__, search_global=False, default=None
    )
    customization = config.get_cloud_config_value(
        &quot;customization&quot;, vm_, __opts__, search_global=False, default=True
    )
    customization_spec = config.get_cloud_config_value(
        &quot;customization_spec&quot;, vm_, __opts__, search_global=False, default=None
    )
    win_password = config.get_cloud_config_value(
        &quot;win_password&quot;, vm_, __opts__, search_global=False, default=None
    )
    win_organization_name = config.get_cloud_config_value(
        &quot;win_organization_name&quot;,
        vm_,
        __opts__,
        search_global=False,
        default=&quot;Organization&quot;,
    )
    plain_text = config.get_cloud_config_value(
        &quot;plain_text&quot;, vm_, __opts__, search_global=False, default=False
    )
    win_user_fullname = config.get_cloud_config_value(
        &quot;win_user_fullname&quot;, vm_, __opts__, search_global=False, default=&quot;Windows User&quot;
    )
    win_run_once = config.get_cloud_config_value(
        &quot;win_run_once&quot;, vm_, __opts__, search_global=False, default=None
    )
    cpu_hot_add = config.get_cloud_config_value(
        &quot;cpu_hot_add&quot;, vm_, __opts__, search_global=False, default=None
    )
    cpu_hot_remove = config.get_cloud_config_value(
        &quot;cpu_hot_remove&quot;, vm_, __opts__, search_global=False, default=None
    )
    mem_hot_add = config.get_cloud_config_value(
        &quot;mem_hot_add&quot;, vm_, __opts__, search_global=False, default=None
    )
    nested_hv = config.get_cloud_config_value(
        &quot;nested_hv&quot;, vm_, __opts__, search_global=False, default=None
    )
    vpmc = config.get_cloud_config_value(
        &quot;vpmc&quot;, vm_, __opts__, search_global=False, default=None
    )

    # Get service instance object
    si = _get_si()

    container_ref = None

    # If datacenter is specified, set the container reference to start search from it instead
    if datacenter:
        datacenter_ref = salt.utils.vmware.get_mor_by_property(
            _get_si(), vim.Datacenter, datacenter
        )
        container_ref = datacenter_ref if datacenter_ref else None

    if &quot;clonefrom&quot; in vm_:
        # If datacenter is specified, set the container reference to start search from it instead
        if datacenter:
            datacenter_ref = salt.utils.vmware.get_mor_by_property(
                si, vim.Datacenter, datacenter
            )
            container_ref = datacenter_ref if datacenter_ref else None

        # Clone VM/template from specified VM/template
        object_ref = salt.utils.vmware.get_mor_by_property(
            si, vim.VirtualMachine, vm_[&quot;clonefrom&quot;], container_ref=container_ref
        )
        if object_ref:
            clone_type = &quot;template&quot; if object_ref.config.template else &quot;vm&quot;
        else:
            raise SaltCloudSystemExit(
                &quot;The VM/template that you have specified under clonefrom does not&quot;
                &quot; exist.&quot;
            )
    else:
        clone_type = None
        object_ref = None

    # Either a cluster, or a resource pool must be specified when cloning from template or creating.
    if resourcepool:
        resourcepool_ref = salt.utils.vmware.get_mor_by_property(
            si, vim.ResourcePool, resourcepool, container_ref=container_ref
        )
        if not resourcepool_ref:
            log.error(&quot;Specified resource pool: '%s' does not exist&quot;, resourcepool)
            if not clone_type or clone_type == &quot;template&quot;:
                raise SaltCloudSystemExit(
                    &quot;You must specify a resource pool that exists.&quot;
                )
    elif cluster:
        cluster_ref = salt.utils.vmware.get_mor_by_property(
            si, vim.ClusterComputeResource, cluster, container_ref=container_ref
        )
        if not cluster_ref:
            log.error(&quot;Specified cluster: '%s' does not exist&quot;, cluster)
            if not clone_type or clone_type == &quot;template&quot;:
                raise SaltCloudSystemExit(&quot;You must specify a cluster that exists.&quot;)
        else:
            resourcepool_ref = cluster_ref.resourcePool
    elif clone_type == &quot;template&quot;:
        raise SaltCloudSystemExit(
            &quot;You must either specify a cluster or a resource pool when cloning from a&quot;
            &quot; template.&quot;
        )
    elif not clone_type:
        raise SaltCloudSystemExit(
            &quot;You must either specify a cluster or a resource pool when creating.&quot;
        )
    else:
        log.debug(&quot;Using resource pool used by the %s %s&quot;, clone_type, vm_[&quot;clonefrom&quot;])

    # Either a datacenter or a folder can be optionally specified when cloning, required when creating.
    # If not specified when cloning, the existing VM/template\'s parent folder is used.
    if folder:
        folder_parts = folder.split(&quot;/&quot;)
        search_reference = container_ref
        for folder_part in folder_parts:
            if folder_part:
                folder_ref = salt.utils.vmware.get_mor_by_property(
                    si, vim.Folder, folder_part, container_ref=search_reference
                )
                search_reference = folder_ref
        if not folder_ref:
            log.error(&quot;Specified folder: '%s' does not exist&quot;, folder)
            log.debug(
                &quot;Using folder in which %s %s is present&quot;, clone_type, vm_[&quot;clonefrom&quot;]
            )
            folder_ref = object_ref.parent
    elif datacenter:
        if not datacenter_ref:
            log.error(&quot;Specified datacenter: '%s' does not exist&quot;, datacenter)
            log.debug(
                &quot;Using datacenter folder in which %s %s is present&quot;,
                clone_type,
                vm_[&quot;clonefrom&quot;],
            )
            folder_ref = object_ref.parent
        else:
            folder_ref = datacenter_ref.vmFolder
    elif not clone_type:
        raise SaltCloudSystemExit(
            &quot;You must either specify a folder or a datacenter when creating not&quot;
            &quot; cloning.&quot;
        )
    else:
        log.debug(
            &quot;Using folder in which %s %s is present&quot;, clone_type, vm_[&quot;clonefrom&quot;]
        )
        folder_ref = object_ref.parent

    if &quot;clonefrom&quot; in vm_:
        # Create the relocation specs
        reloc_spec = vim.vm.RelocateSpec()

        if (resourcepool and resourcepool_ref) or (cluster and cluster_ref):
            reloc_spec.pool = resourcepool_ref

        # Either a datastore/datastore cluster can be optionally specified.
        # If not specified, the current datastore is used.
        if datastore:
            datastore_ref = salt.utils.vmware.get_mor_by_property(
                si, vim.Datastore, datastore, container_ref=container_ref
            )
            if datastore_ref:
                # specific datastore has been specified
                reloc_spec.datastore = datastore_ref
            else:
                datastore_cluster_ref = salt.utils.vmware.get_mor_by_property(
                    si, vim.StoragePod, datastore, container_ref=container_ref
                )
                if not datastore_cluster_ref:
                    log.error(
                        &quot;Specified datastore/datastore cluster: '%s' does not exist&quot;,
                        datastore,
                    )
                    log.debug(
                        &quot;Using datastore used by the %s %s&quot;,
                        clone_type,
                        vm_[&quot;clonefrom&quot;],
                    )
        else:
            log.debug(&quot;No datastore/datastore cluster specified&quot;)
            log.debug(&quot;Using datastore used by the %s %s&quot;, clone_type, vm_[&quot;clonefrom&quot;])

        if host:
            host_ref = salt.utils.vmware.get_mor_by_property(
                si, vim.HostSystem, host, container_ref=container_ref
            )
            if host_ref:
                reloc_spec.host = host_ref
            else:
                log.error(&quot;Specified host: '%s' does not exist&quot;, host)

        if instant_clone:
            instant_clone_spec = vim.vm.InstantCloneSpec()
            instant_clone_spec.name = vm_name
            instant_clone_spec.location = reloc_spec

            event_kwargs = vm_.copy()
            if event_kwargs.get(&quot;password&quot;):
<A NAME="7"></A>                del event_kwargs[&quot;password&quot;]

            try:
                __utils__<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#7',2,'match66669-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;cloud.fire_event&quot;](
                    &quot;event&quot;,
                    &quot;requesting instance&quot;,
                    &quot;salt/cloud/{}/requesting&quot;.format(vm_[&quot;name&quot;]),
                    args=__utils__[&quot;cloud.filter_event&quot;](
                        &quot;requesting&quot;, event_kwargs, list(event_kwargs)
                    ),
                    sock_dir=__opts__[&quot;sock_dir&quot;],
                    transport=__opts__[</B></FONT>&quot;transport&quot;],
                )

                log.info(
                    &quot;Creating %s from %s(%s)&quot;, vm_[&quot;name&quot;], clone_type, vm_[&quot;clonefrom&quot;]
                )

                if datastore and not datastore_ref and datastore_cluster_ref:
                    # datastore cluster has been specified so apply Storage DRS recommendations
                    pod_spec = vim.storageDrs.PodSelectionSpec(
                        storagePod=datastore_cluster_ref
                    )

                    storage_spec = vim.storageDrs.StoragePlacementSpec(
                        type=&quot;clone&quot;,
                        vm=object_ref,
                        podSelectionSpec=pod_spec,
                        cloneName=vm_name,
                        folder=folder_ref,
                    )

                    # get recommended datastores
                    recommended_datastores = (
                        si.content.storageResourceManager.RecommendDatastores(
                            storageSpec=storage_spec
                        )
                    )

                    # apply storage DRS recommendations
                    task = si.content.storageResourceManager.ApplyStorageDrsRecommendation_Task(
                        recommended_datastores.recommendations[0].key
                    )
                    salt.utils.vmware.wait_for_task(
                        task, vm_name, &quot;apply storage DRS recommendations&quot;, 5, &quot;info&quot;
                    )
                else:
                    # Instant clone the VM
                    task = object_ref.InstantClone_Task(spec=instant_clone_spec)
                    salt.utils.vmware.wait_for_task(
                        task, vm_name, &quot;Instantclone&quot;, 5, &quot;info&quot;
                    )

            except Exception as exc:  # pylint: disable=broad-except
                err_msg = &quot;Error Instant cloning {}: {}&quot;.format(vm_[&quot;name&quot;], exc)
                log.error(
                    err_msg,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return {&quot;Error&quot;: err_msg}

            new_vm_ref = salt.utils.vmware.get_mor_by_property(
                si, vim.VirtualMachine, vm_name, container_ref=container_ref
            )
            out = None
            if not template and power:
                ip = _wait_for_ip(new_vm_ref, wait_for_ip_timeout)
                if ip:
                    log.info(&quot;[ %s ] IPv4 is: %s&quot;, vm_name, ip)
                    # ssh or smb using ip and install salt only if deploy is True
                    if deploy:
                        vm_[&quot;key_filename&quot;] = key_filename
                        # if specified, prefer ssh_host to the discovered ip address
                        if &quot;ssh_host&quot; not in vm_:
                            vm_[&quot;ssh_host&quot;] = ip
                        log.info(&quot;[ %s ] Deploying to %s&quot;, vm_name, vm_[&quot;ssh_host&quot;])

                        out = __utils__[&quot;cloud.bootstrap&quot;](vm_, __opts__)

            data = show_instance(vm_name, call=&quot;action&quot;)

            if deploy and isinstance(out, dict):
                data[&quot;deploy_kwargs&quot;] = out.get(&quot;deploy_kwargs&quot;, {})

            __utils__[&quot;cloud.fire_event&quot;](
                &quot;event&quot;,
                &quot;created instance&quot;,
                &quot;salt/cloud/{}/created&quot;.format(vm_[&quot;name&quot;]),
                args=__utils__[&quot;cloud.filter_event&quot;](
                    &quot;created&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
                ),
                sock_dir=__opts__[&quot;sock_dir&quot;],
                transport=__opts__[&quot;transport&quot;],
            )
            return {&quot;Instant Clone created successfully&quot;: data}

    else:
        if not datastore:
            raise SaltCloudSystemExit(
                &quot;You must specify a datastore when creating not cloning.&quot;
            )
        else:
            datastore_ref = salt.utils.vmware.get_mor_by_property(
                si, vim.Datastore, datastore
            )
            if not datastore_ref:
                raise SaltCloudSystemExit(
                    &quot;Specified datastore: '{}' does not exist&quot;.format(datastore)
                )

        if host:
            host_ref = salt.utils.vmware.get_mor_by_property(
                _get_si(), vim.HostSystem, host, container_ref=container_ref
            )
            if not host_ref:
                log.error(&quot;Specified host: '%s' does not exist&quot;, host)

    # Create the config specs
    config_spec = vim.vm.ConfigSpec()

    # If the hardware version is specified and if it is different from the current
    # hardware version, then schedule a hardware version upgrade
    if hardware_version and object_ref is not None:
        hardware_version = &quot;vmx-{:02}&quot;.format(hardware_version)
        if hardware_version != object_ref.config.version:
            log.debug(
                &quot;Scheduling hardware version upgrade from %s to %s&quot;,
                object_ref.config.version,
                hardware_version,
            )
            scheduled_hardware_upgrade = vim.vm.ScheduledHardwareUpgradeInfo()
            scheduled_hardware_upgrade.upgradePolicy = &quot;always&quot;
            scheduled_hardware_upgrade.versionKey = hardware_version
            config_spec.scheduledHardwareUpgradeInfo = scheduled_hardware_upgrade
        else:
            log.debug(&quot;Virtual hardware version already set to %s&quot;, hardware_version)

    if num_cpus:
        log.debug(&quot;Setting cpu to: %s&quot;, num_cpus)
        config_spec.numCPUs = int(num_cpus)

    if cores_per_socket:
        log.debug(&quot;Setting cores per socket to: %s&quot;, cores_per_socket)
        config_spec.numCoresPerSocket = int(cores_per_socket)

    if memory:
        try:
            memory_num, memory_unit = re.findall(r&quot;[^\W\d_]+|\d+.\d+|\d+&quot;, memory)
            if memory_unit.lower() == &quot;mb&quot;:
                memory_mb = int(memory_num)
            elif memory_unit.lower() == &quot;gb&quot;:
                memory_mb = int(float(memory_num) * 1024.0)
            else:
                err_msg = &quot;Invalid memory type specified: '{}'&quot;.format(memory_unit)
                log.error(err_msg)
                return {&quot;Error&quot;: err_msg}
        except (TypeError, ValueError):
            memory_mb = int(memory)
        log.debug(&quot;Setting memory to: %s MB&quot;, memory_mb)
        config_spec.memoryMB = memory_mb

    if devices:
        specs = _manage_devices(
            devices, vm=object_ref, container_ref=container_ref, new_vm_name=vm_name
        )
        config_spec.deviceChange = specs[&quot;device_specs&quot;]

    if cpu_hot_add and hasattr(config_spec, &quot;cpuHotAddEnabled&quot;):
        config_spec.cpuHotAddEnabled = bool(cpu_hot_add)

    if cpu_hot_remove and hasattr(config_spec, &quot;cpuHotRemoveEnabled&quot;):
        config_spec.cpuHotRemoveEnabled = bool(cpu_hot_remove)

    if mem_hot_add and hasattr(config_spec, &quot;memoryHotAddEnabled&quot;):
        config_spec.memoryHotAddEnabled = bool(mem_hot_add)

    if nested_hv and hasattr(config_spec, &quot;nestedHVEnabled&quot;):
        config_spec.nestedHVEnabled = bool(nested_hv)

    if vpmc and hasattr(config_spec, &quot;vPMCEnabled&quot;):
        config_spec.vPMCEnabled = bool(vpmc)

    if extra_config:
        for key, value in extra_config.items():
            option = vim.option.OptionValue(key=key, value=value)
            config_spec.extraConfig.append(option)

    if annotation:
        config_spec.annotation = str(annotation)

    if &quot;clonefrom&quot; in vm_:
        clone_spec = handle_snapshot(config_spec, object_ref, reloc_spec, template, vm_)
        if not clone_spec:
            clone_spec = build_clonespec(config_spec, object_ref, reloc_spec, template)

        if customization and customization_spec:
            customization_spec = salt.utils.vmware.get_customizationspec_ref(
                si=si, customization_spec_name=customization_spec
            )
            clone_spec.customization = customization_spec.spec
        elif customization and (devices and &quot;network&quot; in list(devices.keys())):
            global_ip = vim.vm.customization.GlobalIPSettings()
            if &quot;dns_servers&quot; in list(vm_.keys()):
                global_ip.dnsServerList = vm_[&quot;dns_servers&quot;]

            if &quot;domain&quot; in list(vm_.keys()):
                global_ip.dnsSuffixList = vm_[&quot;domain&quot;]

            non_hostname_chars = re.compile(r&quot;[^\w-]&quot;)
            if re.search(non_hostname_chars, vm_name):
                host_name = re.split(non_hostname_chars, vm_name, maxsplit=1)[0]
                domain_name = re.split(non_hostname_chars, vm_name, maxsplit=1)[-1]
            else:
                host_name = vm_name
                domain_name = domain

            if &quot;Windows&quot; not in object_ref.config.guestFullName:
                identity = vim.vm.customization.LinuxPrep()
<A NAME="8"></A>                identity.hostName = vim.vm.customization.FixedName(name=host_name)
                identity.domain = domain_name
            else:
                identity = vim<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#8',2,'match66669-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.vm.customization.Sysprep()
                identity.guiUnattended = vim.vm.customization.GuiUnattended()
                identity.guiUnattended.</B></FONT>autoLogon = True
                identity.guiUnattended.autoLogonCount = 1
                identity.guiUnattended.password = vim.vm.customization.Password()
                identity.guiUnattended.password.value = win_password
                identity.guiUnattended.password.plainText = plain_text
                if win_run_once:
                    identity.guiRunOnce = vim.vm.customization.GuiRunOnce()
                    identity.guiRunOnce.commandList = win_run_once
                identity.userData = vim.vm.customization.UserData()
                identity.userData.fullName = win_user_fullname
                identity.userData.orgName = win_organization_name
                identity.userData.computerName = vim.vm.customization.FixedName()
                identity.userData.computerName.name = host_name
                identity.identification = vim.vm.customization.Identification()
            custom_spec = vim.vm.customization.Specification(
                globalIPSettings=global_ip,
                identity=identity,
                nicSettingMap=specs[&quot;nics_map&quot;],
            )
            clone_spec.customization = custom_spec

        if not template:
            clone_spec.powerOn = power

        log.debug(&quot;clone_spec set to:\n%s&quot;, pprint.pformat(clone_spec))

    else:
        config_spec.name = vm_name
        config_spec.files = vim.vm.FileInfo()
        config_spec.files.vmPathName = &quot;[{0}] {1}/{1}.vmx&quot;.format(datastore, vm_name)
        config_spec.guestId = guest_id

        log.debug(&quot;config_spec set to:\n%s&quot;, pprint.pformat(config_spec))

    event_kwargs = vm_.copy()
    if event_kwargs.get(&quot;password&quot;):
        del event_kwargs[&quot;password&quot;]

    try:
        __utils__[&quot;cloud.fire_event&quot;](
            &quot;event&quot;,
            &quot;requesting instance&quot;,
            &quot;salt/cloud/{}/requesting&quot;.format(vm_[&quot;name&quot;]),
            args=__utils__[&quot;cloud.filter_event&quot;](
                &quot;requesting&quot;, event_kwargs, list(event_kwargs)
            ),
            sock_dir=__opts__[&quot;sock_dir&quot;],
            transport=__opts__[&quot;transport&quot;],
        )

        if &quot;clonefrom&quot; in vm_:
            log.info(
                &quot;Creating %s from %s(%s)&quot;, vm_[&quot;name&quot;], clone_type, vm_[&quot;clonefrom&quot;]
            )

            if datastore and not datastore_ref and datastore_cluster_ref:
                # datastore cluster has been specified so apply Storage DRS recommendations
                pod_spec = vim.storageDrs.PodSelectionSpec(
                    storagePod=datastore_cluster_ref
                )

                storage_spec = vim.storageDrs.StoragePlacementSpec(
                    type=&quot;clone&quot;,
                    vm=object_ref,
                    podSelectionSpec=pod_spec,
                    cloneSpec=clone_spec,
                    cloneName=vm_name,
                    folder=folder_ref,
                )

                # get recommended datastores
                recommended_datastores = (
                    si.content.storageResourceManager.RecommendDatastores(
                        storageSpec=storage_spec
                    )
                )

                # apply storage DRS recommendations
                task = si.content.storageResourceManager.ApplyStorageDrsRecommendation_Task(
                    recommended_datastores.recommendations[0].key
                )
                salt.utils.vmware.wait_for_task(
                    task, vm_name, &quot;apply storage DRS recommendations&quot;, 5, &quot;info&quot;
                )
            else:
                # clone the VM/template
                task = object_ref.Clone(folder_ref, vm_name, clone_spec)
                salt.utils.vmware.wait_for_task(task, vm_name, &quot;clone&quot;, 5, &quot;info&quot;)
        else:
            log.info(&quot;Creating %s&quot;, vm_[&quot;name&quot;])

            if host:
                task = folder_ref.CreateVM_Task(config_spec, resourcepool_ref, host_ref)
            else:
                task = folder_ref.CreateVM_Task(config_spec, resourcepool_ref)
            salt.utils.vmware.wait_for_task(task, vm_name, &quot;create&quot;, 15, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        err_msg = &quot;Error creating {}: {}&quot;.format(vm_[&quot;name&quot;], exc)
        log.error(
            err_msg,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {&quot;Error&quot;: err_msg}

    new_vm_ref = salt.utils.vmware.get_mor_by_property(
        si, vim.VirtualMachine, vm_name, container_ref=container_ref
    )

    # Find how to power on in CreateVM_Task (if possible), for now this will do
    try:
        if not clone_type and power:
            task = new_vm_ref.PowerOn()
            salt.utils.vmware.wait_for_task(task, vm_name, &quot;power&quot;, 5, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.info(&quot;Powering on the VM threw this exception. Ignoring.&quot;)
        log.info(exc)

    # If it a template or if it does not need to be powered on then do not wait for the IP
    out = None
    if not template and power:
        ip = _wait_for_ip(new_vm_ref, wait_for_ip_timeout)
        if ip:
            log.info(&quot;[ %s ] IPv4 is: %s&quot;, vm_name, ip)
            # ssh or smb using ip and install salt only if deploy is True
            if deploy:
                vm_[&quot;key_filename&quot;] = key_filename
                # if specified, prefer ssh_host to the discovered ip address
                if &quot;ssh_host&quot; not in vm_:
                    vm_[&quot;ssh_host&quot;] = ip
                log.info(&quot;[ %s ] Deploying to %s&quot;, vm_name, vm_[&quot;ssh_host&quot;])

                out = __utils__[&quot;cloud.bootstrap&quot;](vm_, __opts__)

    data = show_instance(vm_name, call=&quot;action&quot;)

<A NAME="6"></A>    if deploy and isinstance(out, dict):
        data[&quot;deploy_kwargs&quot;] = out.get(&quot;deploy_kwargs&quot;, {})

    __utils__<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match66669-0.html#6',2,'match66669-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;created instance&quot;,
        &quot;salt/cloud/{}/created&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;created&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )
    return data


def</B></FONT> handle_snapshot(config_spec, object_ref, reloc_spec, template, vm_):
    &quot;&quot;&quot;
    Returns a clone spec for cloning from shapshots
    :rtype vim.vm.CloneSpec
    &quot;&quot;&quot;
    if &quot;snapshot&quot; not in vm_:
        return None

    allowed_types = [
        FLATTEN_DISK_FULL_CLONE,
        COPY_ALL_DISKS_FULL_CLONE,
        CURRENT_STATE_LINKED_CLONE,
        QUICK_LINKED_CLONE,
    ]

    clone_spec = get_clonespec_for_valid_snapshot(
        config_spec, object_ref, reloc_spec, template, vm_
    )
    if not clone_spec:
        raise SaltCloudSystemExit(
            &quot;Invalid disk move type specified supported types are {}&quot;.format(
                &quot; &quot;.join(allowed_types)
            )
        )
    return clone_spec


def get_clonespec_for_valid_snapshot(
    config_spec, object_ref, reloc_spec, template, vm_
):
    &quot;&quot;&quot;
    return clonespec only if values are valid
    &quot;&quot;&quot;
    moving = True
    if QUICK_LINKED_CLONE == vm_[&quot;snapshot&quot;][&quot;disk_move_type&quot;]:
        reloc_spec.diskMoveType = QUICK_LINKED_CLONE
    elif CURRENT_STATE_LINKED_CLONE == vm_[&quot;snapshot&quot;][&quot;disk_move_type&quot;]:
        reloc_spec.diskMoveType = CURRENT_STATE_LINKED_CLONE
    elif COPY_ALL_DISKS_FULL_CLONE == vm_[&quot;snapshot&quot;][&quot;disk_move_type&quot;]:
        reloc_spec.diskMoveType = COPY_ALL_DISKS_FULL_CLONE
    elif FLATTEN_DISK_FULL_CLONE == vm_[&quot;snapshot&quot;][&quot;disk_move_type&quot;]:
        reloc_spec.diskMoveType = FLATTEN_DISK_FULL_CLONE
    else:
        moving = False

    if moving:
        return build_clonespec(config_spec, object_ref, reloc_spec, template)

    return None


def build_clonespec(config_spec, object_ref, reloc_spec, template):
    &quot;&quot;&quot;
    Returns the clone spec
    &quot;&quot;&quot;
    if reloc_spec.diskMoveType == QUICK_LINKED_CLONE:
        return vim.vm.CloneSpec(
            template=template,
            location=reloc_spec,
            config=config_spec,
            snapshot=object_ref.snapshot.currentSnapshot,
        )

    return vim.vm.CloneSpec(template=template, location=reloc_spec, config=config_spec)


def create_datacenter(kwargs=None, call=None):
    &quot;&quot;&quot;
    Create a new data center in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f create_datacenter my-vmware-config name=&quot;MyNewDatacenter&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_datacenter function must be called with -f or --function.&quot;
        )

    datacenter_name = kwargs.get(&quot;name&quot;) if kwargs and &quot;name&quot; in kwargs else None

    if not datacenter_name:
        raise SaltCloudSystemExit(
            &quot;You must specify name of the new datacenter to be created.&quot;
        )

    if not datacenter_name or len(datacenter_name) &gt;= 80:
        raise SaltCloudSystemExit(
            &quot;The datacenter name must be a non empty string of less than 80 characters.&quot;
        )

    # Get the service instance
    si = _get_si()

    # Check if datacenter already exists
    datacenter_ref = salt.utils.vmware.get_mor_by_property(
        si, vim.Datacenter, datacenter_name
    )
    if datacenter_ref:
        return {datacenter_name: &quot;datacenter already exists&quot;}

    folder = si.content.rootFolder

    # Verify that the folder is of type vim.Folder
    if isinstance(folder, vim.Folder):
        try:
            folder.CreateDatacenter(name=datacenter_name)
        except Exception as exc:  # pylint: disable=broad-except
            log.error(
                &quot;Error creating datacenter %s: %s&quot;,
                datacenter_name,
                exc,
                # Show the traceback if the debug logging level is enabled
                exc_info_on_loglevel=logging.DEBUG,
            )
            return False

        log.debug(&quot;Created datacenter %s&quot;, datacenter_name)
        return {datacenter_name: &quot;created&quot;}

    return False


def create_cluster(kwargs=None, call=None):
    &quot;&quot;&quot;
    Create a new cluster under the specified datacenter in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f create_cluster my-vmware-config name=&quot;myNewCluster&quot; datacenter=&quot;datacenterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_cluster function must be called with -f or --function.&quot;
        )

    cluster_name = kwargs.get(&quot;name&quot;) if kwargs and &quot;name&quot; in kwargs else None
    datacenter = kwargs.get(&quot;datacenter&quot;) if kwargs and &quot;datacenter&quot; in kwargs else None

    if not cluster_name:
        raise SaltCloudSystemExit(
            &quot;You must specify name of the new cluster to be created.&quot;
        )

    if not datacenter:
        raise SaltCloudSystemExit(
            &quot;You must specify name of the datacenter where the cluster should be&quot;
            &quot; created.&quot;
        )

    # Get the service instance
    si = _get_si()

    if not isinstance(datacenter, vim.Datacenter):
        datacenter = salt.utils.vmware.get_mor_by_property(
            si, vim.Datacenter, datacenter
        )
        if not datacenter:
            raise SaltCloudSystemExit(&quot;The specified datacenter does not exist.&quot;)

    # Check if cluster already exists
    cluster_ref = salt.utils.vmware.get_mor_by_property(
        si, vim.ClusterComputeResource, cluster_name
    )
    if cluster_ref:
        return {cluster_name: &quot;cluster already exists&quot;}

    cluster_spec = vim.cluster.ConfigSpecEx()
    folder = datacenter.hostFolder

    # Verify that the folder is of type vim.Folder
    if isinstance(folder, vim.Folder):
        try:
            folder.CreateClusterEx(name=cluster_name, spec=cluster_spec)
        except Exception as exc:  # pylint: disable=broad-except
            log.error(
                &quot;Error creating cluster %s: %s&quot;,
                cluster_name,
                exc,
                # Show the traceback if the debug logging level is enabled
                exc_info_on_loglevel=logging.DEBUG,
            )
            return False

        log.debug(
            &quot;Created cluster %s under datacenter %s&quot;, cluster_name, datacenter.name
        )
        return {cluster_name: &quot;created&quot;}

    return False


def rescan_hba(kwargs=None, call=None):
    &quot;&quot;&quot;
    To rescan a specified HBA or all the HBAs on the Host System

    CLI Example:

    .. code-block:: bash

        salt-cloud -f rescan_hba my-vmware-config host=&quot;hostSystemName&quot;
        salt-cloud -f rescan_hba my-vmware-config hba=&quot;hbaDeviceName&quot; host=&quot;hostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The rescan_hba function must be called with -f or --function.&quot;
        )

    hba = kwargs.get(&quot;hba&quot;) if kwargs and &quot;hba&quot; in kwargs else None
    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    host_ref = salt.utils.vmware.get_mor_by_property(
        _get_si(), vim.HostSystem, host_name
    )

    try:
        if hba:
            log.info(&quot;Rescanning HBA %s on host %s&quot;, hba, host_name)
            host_ref.configManager.storageSystem.RescanHba(hba)
            ret = &quot;rescanned HBA {}&quot;.format(hba)
        else:
            log.info(&quot;Rescanning all HBAs on host %s&quot;, host_name)
            host_ref.configManager.storageSystem.RescanAllHba()
            ret = &quot;rescanned all HBAs&quot;
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while rescaning HBA on host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to rescan HBA&quot;}

    return {host_name: ret}


def upgrade_tools_all(call=None):
    &quot;&quot;&quot;
    To upgrade VMware Tools on all virtual machines present in
    the specified provider

    .. note::

        If the virtual machine is running Windows OS, this function
        will attempt to suppress the automatic reboot caused by a
        VMware Tools upgrade.

    CLI Example:

    .. code-block:: bash

        salt-cloud -f upgrade_tools_all my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The upgrade_tools_all function must be called with -f or --function.&quot;
        )

    ret = {}
    vm_properties = [&quot;name&quot;]

    vm_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.VirtualMachine, vm_properties
    )

    for vm in vm_list:
        ret[vm[&quot;name&quot;]] = _upg_tools_helper(vm[&quot;object&quot;])

    return ret


def upgrade_tools(name, reboot=False, call=None):
    &quot;&quot;&quot;
    To upgrade VMware Tools on a specified virtual machine.

    .. note::

        If the virtual machine is running Windows OS, use ``reboot=True``
        to reboot the virtual machine after VMware tools upgrade. Default
        is ``reboot=False``

    CLI Example:

    .. code-block:: bash

        salt-cloud -a upgrade_tools vmname
        salt-cloud -a upgrade_tools vmname reboot=True
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The upgrade_tools action must be called with -a or --action.&quot;
        )

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    return _upg_tools_helper(vm_ref, reboot)


def list_hosts_by_cluster(kwargs=None, call=None):
    &quot;&quot;&quot;
    List hosts for each cluster; or hosts for a specified cluster in
    this VMware environment

    To list hosts for each cluster:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hosts_by_cluster my-vmware-config

    To list hosts for a specified cluster:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hosts_by_cluster my-vmware-config cluster=&quot;clusterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_hosts_by_cluster function must be called with -f or --function.&quot;
        )

    ret = {}
    cluster_name = kwargs.get(&quot;cluster&quot;) if kwargs and &quot;cluster&quot; in kwargs else None
    cluster_properties = [&quot;name&quot;]

    cluster_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.ClusterComputeResource, cluster_properties
    )

    for cluster in cluster_list:
        ret[cluster[&quot;name&quot;]] = []
        for host in cluster[&quot;object&quot;].host:
            if isinstance(host, vim.HostSystem):
                ret[cluster[&quot;name&quot;]].append(host.name)
        if cluster_name and cluster_name == cluster[&quot;name&quot;]:
            return {&quot;Hosts by Cluster&quot;: {cluster_name: ret[cluster_name]}}

    return {&quot;Hosts by Cluster&quot;: ret}


def list_clusters_by_datacenter(kwargs=None, call=None):
    &quot;&quot;&quot;
    List clusters for each datacenter; or clusters for a specified datacenter in
    this VMware environment

    To list clusters for each datacenter:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_clusters_by_datacenter my-vmware-config

    To list clusters for a specified datacenter:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_clusters_by_datacenter my-vmware-config datacenter=&quot;datacenterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_clusters_by_datacenter function must be called with &quot;
            &quot;-f or --function.&quot;
        )

    ret = {}
    datacenter_name = (
        kwargs.get(&quot;datacenter&quot;) if kwargs and &quot;datacenter&quot; in kwargs else None
    )
    datacenter_properties = [&quot;name&quot;]

    datacenter_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.Datacenter, datacenter_properties
    )

    for datacenter in datacenter_list:
        ret[datacenter[&quot;name&quot;]] = []
        for cluster in datacenter[&quot;object&quot;].hostFolder.childEntity:
            if isinstance(cluster, vim.ClusterComputeResource):
                ret[datacenter[&quot;name&quot;]].append(cluster.name)
        if datacenter_name and datacenter_name == datacenter[&quot;name&quot;]:
            return {&quot;Clusters by Datacenter&quot;: {datacenter_name: ret[datacenter_name]}}

    return {&quot;Clusters by Datacenter&quot;: ret}


def list_hosts_by_datacenter(kwargs=None, call=None):
    &quot;&quot;&quot;
    List hosts for each datacenter; or hosts for a specified datacenter in
    this VMware environment

    To list hosts for each datacenter:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hosts_by_datacenter my-vmware-config

    To list hosts for a specified datacenter:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hosts_by_datacenter my-vmware-config datacenter=&quot;datacenterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_hosts_by_datacenter function must be called with &quot;
            &quot;-f or --function.&quot;
        )

    ret = {}
    datacenter_name = (
        kwargs.get(&quot;datacenter&quot;) if kwargs and &quot;datacenter&quot; in kwargs else None
    )
    datacenter_properties = [&quot;name&quot;]

    datacenter_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.Datacenter, datacenter_properties
    )

    for datacenter in datacenter_list:
        ret[datacenter[&quot;name&quot;]] = []
        for cluster in datacenter[&quot;object&quot;].hostFolder.childEntity:
            if isinstance(cluster, vim.ClusterComputeResource):
                for host in cluster.host:
                    if isinstance(host, vim.HostSystem):
                        ret[datacenter[&quot;name&quot;]].append(host.name)
        if datacenter_name and datacenter_name == datacenter[&quot;name&quot;]:
            return {&quot;Hosts by Datacenter&quot;: {datacenter_name: ret[datacenter_name]}}

    return {&quot;Hosts by Datacenter&quot;: ret}


def list_hbas(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all HBAs for each host system; or all HBAs for a specified host
    system; or HBAs of specified type for each host system; or HBAs of
    specified type for a specified host system in this VMware environment

    .. note::

        You can specify type as either ``parallel``, ``iscsi``, ``block``
        or ``fibre``.

    To list all HBAs for each host system:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hbas my-vmware-config

    To list all HBAs for a specified host system:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hbas my-vmware-config host=&quot;hostSystemName&quot;

    To list HBAs of specified type for each host system:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hbas my-vmware-config type=&quot;HBAType&quot;

    To list HBAs of specified type for a specified host system:

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_hbas my-vmware-config host=&quot;hostSystemName&quot; type=&quot;HBAtype&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_hbas function must be called with -f or --function.&quot;
        )

    ret = {}
    hba_type = kwargs.get(&quot;type&quot;).lower() if kwargs and &quot;type&quot; in kwargs else None
    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None
    host_properties = [&quot;name&quot;, &quot;config.storageDevice.hostBusAdapter&quot;]

    if hba_type and hba_type not in [&quot;parallel&quot;, &quot;block&quot;, &quot;iscsi&quot;, &quot;fibre&quot;]:
        raise SaltCloudSystemExit(
            &quot;Specified hba type {} currently not supported.&quot;.format(hba_type)
        )

    host_list = salt.utils.vmware.get_mors_with_properties(
        _get_si(), vim.HostSystem, host_properties
    )

    for host in host_list:
        ret[host[&quot;name&quot;]] = {}
        for hba in host[&quot;config.storageDevice.hostBusAdapter&quot;]:
            hba_spec = {
                &quot;driver&quot;: hba.driver,
                &quot;status&quot;: hba.status,
                &quot;type&quot;: type(hba).__name__.rsplit(&quot;.&quot;, 1)[1],
            }
            if hba_type:
                if isinstance(hba, _get_hba_type(hba_type)):
                    if hba.model in ret[host[&quot;name&quot;]]:
                        ret[host[&quot;name&quot;]][hba.model][hba.device] = hba_spec
                    else:
                        ret[host[&quot;name&quot;]][hba.model] = {hba.device: hba_spec}
            else:
                if hba.model in ret[host[&quot;name&quot;]]:
                    ret[host[&quot;name&quot;]][hba.model][hba.device] = hba_spec
                else:
                    ret[host[&quot;name&quot;]][hba.model] = {hba.device: hba_spec}
        if host[&quot;name&quot;] == host_name:
            return {&quot;HBAs by Host&quot;: {host_name: ret[host_name]}}

    return {&quot;HBAs by Host&quot;: ret}


def list_dvs(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the distributed virtual switches for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_dvs my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_dvs function must be called with -f or --function.&quot;
        )

    return {&quot;Distributed Virtual Switches&quot;: salt.utils.vmware.list_dvs(_get_si())}


def list_vapps(kwargs=None, call=None):
    &quot;&quot;&quot;
    List all the vApps for this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f list_vapps my-vmware-config
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_vapps function must be called with -f or --function.&quot;
        )

    return {&quot;vApps&quot;: salt.utils.vmware.list_vapps(_get_si())}


def enter_maintenance_mode(kwargs=None, call=None):
    &quot;&quot;&quot;
    To put the specified host system in maintenance mode in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f enter_maintenance_mode my-vmware-config host=&quot;myHostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The enter_maintenance_mode function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    host_ref = salt.utils.vmware.get_mor_by_property(
        _get_si(), vim.HostSystem, host_name
    )

    if not host_name or not host_ref:
        raise SaltCloudSystemExit(&quot;You must specify a valid name of the host system.&quot;)

    if host_ref.runtime.inMaintenanceMode:
        return {host_name: &quot;already in maintenance mode&quot;}

    try:
        task = host_ref.EnterMaintenanceMode(timeout=0, evacuatePoweredOffVms=True)
        salt.utils.vmware.wait_for_task(task, host_name, &quot;enter maintenance mode&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while moving host system %s in maintenance mode: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to enter maintenance mode&quot;}

    return {host_name: &quot;entered maintenance mode&quot;}


def exit_maintenance_mode(kwargs=None, call=None):
    &quot;&quot;&quot;
    To take the specified host system out of maintenance mode in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f exit_maintenance_mode my-vmware-config host=&quot;myHostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The exit_maintenance_mode function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    host_ref = salt.utils.vmware.get_mor_by_property(
        _get_si(), vim.HostSystem, host_name
    )

    if not host_name or not host_ref:
        raise SaltCloudSystemExit(&quot;You must specify a valid name of the host system.&quot;)

    if not host_ref.runtime.inMaintenanceMode:
        return {host_name: &quot;already not in maintenance mode&quot;}

    try:
        task = host_ref.ExitMaintenanceMode(timeout=0)
        salt.utils.vmware.wait_for_task(task, host_name, &quot;exit maintenance mode&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while moving host system %s out of maintenance mode: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to exit maintenance mode&quot;}

    return {host_name: &quot;exited maintenance mode&quot;}


def create_folder(kwargs=None, call=None):
    &quot;&quot;&quot;
    Create the specified folder path in this VMware environment

    .. note::

        To create a Host and Cluster Folder under a Datacenter, specify
        ``path=&quot;/yourDatacenterName/host/yourFolderName&quot;``

        To create a Network Folder under a Datacenter, specify
        ``path=&quot;/yourDatacenterName/network/yourFolderName&quot;``

        To create a Storage Folder under a Datacenter, specify
        ``path=&quot;/yourDatacenterName/datastore/yourFolderName&quot;``

        To create a VM and Template Folder under a Datacenter, specify
        ``path=&quot;/yourDatacenterName/vm/yourFolderName&quot;``

    CLI Example:

    .. code-block:: bash

        salt-cloud -f create_folder my-vmware-config path=&quot;/Local/a/b/c&quot;
        salt-cloud -f create_folder my-vmware-config path=&quot;/MyDatacenter/vm/MyVMFolder&quot;
        salt-cloud -f create_folder my-vmware-config path=&quot;/MyDatacenter/host/MyHostFolder&quot;
        salt-cloud -f create_folder my-vmware-config path=&quot;/MyDatacenter/network/MyNetworkFolder&quot;
        salt-cloud -f create_folder my-vmware-config path=&quot;/MyDatacenter/storage/MyStorageFolder&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_folder function must be called with -f or --function.&quot;
        )

    # Get the service instance object
    si = _get_si()

    folder_path = kwargs.get(&quot;path&quot;) if kwargs and &quot;path&quot; in kwargs else None

    if not folder_path:
        raise SaltCloudSystemExit(&quot;You must specify a non empty folder path.&quot;)

    folder_refs = []
    inventory_path = &quot;/&quot;
    path_exists = True

    # Split the path in a list and loop over it to check for its existence
    for index, folder_name in enumerate(
        os.path.normpath(folder_path.strip(&quot;/&quot;)).split(&quot;/&quot;)
    ):
        inventory_path = os.path.join(inventory_path, folder_name)
        folder_ref = si.content.searchIndex.FindByInventoryPath(
            inventoryPath=inventory_path
        )
        if isinstance(folder_ref, vim.Folder):
            # This is a folder that exists so just append and skip it
            log.debug(&quot;Path %s/ exists in the inventory&quot;, inventory_path)
            folder_refs.append(folder_ref)
        elif isinstance(folder_ref, vim.Datacenter):
            # This is a datacenter that exists so just append and skip it
            log.debug(&quot;Path %s/ exists in the inventory&quot;, inventory_path)
            folder_refs.append(folder_ref)
        else:
            path_exists = False
            if not folder_refs:
                # If this is the first folder, create it under the rootFolder
                log.debug(
                    &quot;Creating folder %s under rootFolder in the inventory&quot;, folder_name
                )
                folder_refs.append(si.content.rootFolder.CreateFolder(folder_name))
            else:
                # Create the folder under the parent folder
                log.debug(&quot;Creating path %s/ in the inventory&quot;, inventory_path)
                folder_refs.append(folder_refs[index - 1].CreateFolder(folder_name))

    if path_exists:
        return {inventory_path: &quot;specified path already exists&quot;}

    return {inventory_path: &quot;created the specified path&quot;}


def create_snapshot(name, kwargs=None, call=None):
    &quot;&quot;&quot;
    Create a snapshot of the specified virtual machine in this VMware
    environment

    .. note::

        If the VM is powered on, the internal state of the VM (memory
        dump) is included in the snapshot by default which will also set
        the power state of the snapshot to &quot;powered on&quot;. You can set
        ``memdump=False`` to override this. This field is ignored if
        the virtual machine is powered off or if the VM does not support
        snapshots with memory dumps. Default is ``memdump=True``

    .. note::

        If the VM is powered on when the snapshot is taken, VMware Tools
        can be used to quiesce the file system in the virtual machine by
        setting ``quiesce=True``. This field is ignored if the virtual
        machine is powered off; if VMware Tools are not available or if
        ``memdump=True``. Default is ``quiesce=False``

    CLI Example:

    .. code-block:: bash

        salt-cloud -a create_snapshot vmname snapshot_name=&quot;mySnapshot&quot;
        salt-cloud -a create_snapshot vmname snapshot_name=&quot;mySnapshot&quot; [description=&quot;My snapshot&quot;] [memdump=False] [quiesce=True]
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_snapshot action must be called with -a or --action.&quot;
        )

    if kwargs is None:
        kwargs = {}

    snapshot_name = (
        kwargs.get(&quot;snapshot_name&quot;) if kwargs and &quot;snapshot_name&quot; in kwargs else None
    )

    if not snapshot_name:
        raise SaltCloudSystemExit(
            &quot;You must specify snapshot name for the snapshot to be created.&quot;
        )

    memdump = _str_to_bool(kwargs.get(&quot;memdump&quot;, True))
    quiesce = _str_to_bool(kwargs.get(&quot;quiesce&quot;, False))

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    if vm_ref.summary.runtime.powerState != &quot;poweredOn&quot;:
        log.debug(
            &quot;VM %s is not powered on. Setting both memdump and quiesce to False&quot;, name
        )
        memdump = False
        quiesce = False

    if memdump and quiesce:
        # Either memdump or quiesce should be set to True
        log.warning(
            &quot;You can only set either memdump or quiesce to True. Setting quiesce=False&quot;
        )
        quiesce = False

    desc = kwargs.get(&quot;description&quot;) if &quot;description&quot; in kwargs else &quot;&quot;

    try:
        task = vm_ref.CreateSnapshot(snapshot_name, desc, memdump, quiesce)
        salt.utils.vmware.wait_for_task(task, name, &quot;create snapshot&quot;, 5, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while creating snapshot of %s: %s&quot;,
            name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return &quot;failed to create snapshot&quot;

    return {
        &quot;Snapshot created successfully&quot;: _get_snapshots(
            vm_ref.snapshot.rootSnapshotList, vm_ref.snapshot.currentSnapshot
        )
    }


def revert_to_snapshot(name, kwargs=None, call=None):
    &quot;&quot;&quot;
    Revert virtual machine to its current snapshot. If no snapshot
    exists, the state of the virtual machine remains unchanged

    .. note::

        The virtual machine will be powered on if the power state of
        the snapshot when it was created was set to &quot;Powered On&quot;. Set
        ``power_off=True`` so that the virtual machine stays powered
        off regardless of the power state of the snapshot when it was
        created. Default is ``power_off=False``.

        If the power state of the snapshot when it was created was
        &quot;Powered On&quot; and if ``power_off=True``, the VM will be put in
        suspended state after it has been reverted to the snapshot.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a revert_to_snapshot vmame [power_off=True]
        salt-cloud -a revert_to_snapshot vmame snapshot_name=&quot;selectedSnapshot&quot; [power_off=True]
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The revert_to_snapshot action must be called with -a or --action.&quot;
        )

    if kwargs is None:
        kwargs = {}

    snapshot_name = (
        kwargs.get(&quot;snapshot_name&quot;) if kwargs and &quot;snapshot_name&quot; in kwargs else None
    )

    suppress_power_on = _str_to_bool(kwargs.get(&quot;power_off&quot;, False))

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    if not vm_ref.rootSnapshot:
        log.error(&quot;VM %s does not contain any current snapshots&quot;, name)
        return &quot;revert failed&quot;

    msg = &quot;reverted to current snapshot&quot;

    try:
        if snapshot_name is None:
            log.debug(&quot;Reverting VM %s to current snapshot&quot;, name)
            task = vm_ref.RevertToCurrentSnapshot(suppressPowerOn=suppress_power_on)
        else:
            log.debug(&quot;Reverting VM %s to snapshot %s&quot;, name, snapshot_name)
            msg = &quot;reverted to snapshot {}&quot;.format(snapshot_name)
            snapshot_ref = _get_snapshot_ref_by_name(vm_ref, snapshot_name)
            if snapshot_ref is None:
                return &quot;specified snapshot '{}' does not exist&quot;.format(snapshot_name)
            task = snapshot_ref.snapshot.Revert(suppressPowerOn=suppress_power_on)

        salt.utils.vmware.wait_for_task(task, name, &quot;revert to snapshot&quot;, 5, &quot;info&quot;)

    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while reverting VM %s to snapshot: %s&quot;,
            name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return &quot;revert failed&quot;

    return msg


def remove_snapshot(name, kwargs=None, call=None):
    &quot;&quot;&quot;
    Remove a snapshot of the specified virtual machine in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -a remove_snapshot vmname snapshot_name=&quot;mySnapshot&quot;
        salt-cloud -a remove_snapshot vmname snapshot_name=&quot;mySnapshot&quot; [remove_children=&quot;True&quot;]
    &quot;&quot;&quot;

    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_snapshot action must be called with -a or --action.&quot;
        )

    if kwargs is None:
        kwargs = {}

    snapshot_name = (
        kwargs.get(&quot;snapshot_name&quot;) if kwargs and &quot;snapshot_name&quot; in kwargs else None
    )
    remove_children = _str_to_bool(kwargs.get(&quot;remove_children&quot;, False))

    if not snapshot_name:
        raise SaltCloudSystemExit(
            &quot;You must specify snapshot name for the snapshot to be deleted.&quot;
        )

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    if not _get_snapshot_ref_by_name(vm_ref, snapshot_name):
        raise SaltCloudSystemExit(
            &quot;Сould not find the snapshot with the specified name.&quot;
        )

    try:
        snap_obj = _get_snapshot_ref_by_name(vm_ref, snapshot_name).snapshot
        task = snap_obj.RemoveSnapshot_Task(remove_children)
        salt.utils.vmware.wait_for_task(task, name, &quot;remove snapshot&quot;, 5, &quot;info&quot;)

    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while removing snapshot of %s: %s&quot;,
            name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return &quot;failed to remove snapshot&quot;

    if vm_ref.snapshot:
        return {
            &quot;Snapshot removed successfully&quot;: _get_snapshots(
                vm_ref.snapshot.rootSnapshotList, vm_ref.snapshot.currentSnapshot
            )
        }

    return &quot;Snapshots removed successfully&quot;


def remove_all_snapshots(name, kwargs=None, call=None):
    &quot;&quot;&quot;
    Remove all the snapshots present for the specified virtual machine.

    .. note::

        All the snapshots higher up in the hierarchy of the current snapshot tree
        are consolidated and their virtual disks are merged. To override this
        behavior and only remove all snapshots, set ``merge_snapshots=False``.
        Default is ``merge_snapshots=True``

    CLI Example:

    .. code-block:: bash

        salt-cloud -a remove_all_snapshots vmname [merge_snapshots=False]
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The remove_all_snapshots action must be called with -a or --action.&quot;
        )

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    try:
        task = vm_ref.RemoveAllSnapshots()
        salt.utils.vmware.wait_for_task(task, name, &quot;remove snapshots&quot;, 5, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while removing snapshots on VM %s: %s&quot;,
            name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return &quot;Failed to remove snapshots&quot;

    return &quot;Removed all snapshots&quot;


def convert_to_template(name, kwargs=None, call=None):
    &quot;&quot;&quot;
    Convert the specified virtual machine to template.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a convert_to_template vmname
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The convert_to_template action must be called with -a or --action.&quot;
        )

    vm_ref = salt.utils.vmware.get_mor_by_property(_get_si(), vim.VirtualMachine, name)

    if vm_ref.config.template:
        raise SaltCloudSystemExit(&quot;{} already a template&quot;.format(name))

    try:
        vm_ref.MarkAsTemplate()
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while converting VM to template %s: %s&quot;,
            name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return &quot;failed to convert to teamplate&quot;

    return &quot;{} converted to template&quot;.format(name)


def add_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Add a host system to the specified cluster or datacenter in this VMware environment

    .. note::

        To use this function, you need to specify ``esxi_host_user`` and
        ``esxi_host_password`` under your provider configuration set up at
        ``/etc/salt/cloud.providers`` or ``/etc/salt/cloud.providers.d/vmware.conf``:

        .. code-block:: yaml

            vcenter01:
              driver: vmware
              user: 'DOMAIN\\user'
              password: 'verybadpass'
              url: 'vcenter01.domain.com'

              # Required when adding a host system
              esxi_host_user: 'root'
              esxi_host_password: 'myhostpassword'
              # Optional fields that can be specified when adding a host system
              esxi_host_ssl_thumbprint: '12:A3:45:B6:CD:7E:F8:90:A1:BC:23:45:D6:78:9E:FA:01:2B:34:CD'

        The SSL thumbprint of the host system can be optionally specified by setting
        ``esxi_host_ssl_thumbprint`` under your provider configuration. To get the SSL
        thumbprint of the host system, execute the following command from a remote
        server:

        .. code-block:: bash

            echo -n | openssl s_client -connect &lt;YOUR-HOSTSYSTEM-DNS/IP&gt;:443 2&gt;/dev/null | openssl x509 -noout -fingerprint -sha1

    CLI Example:

    .. code-block:: bash

        salt-cloud -f add_host my-vmware-config host=&quot;myHostSystemName&quot; cluster=&quot;myClusterName&quot;
        salt-cloud -f add_host my-vmware-config host=&quot;myHostSystemName&quot; datacenter=&quot;myDatacenterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The add_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None
    cluster_name = kwargs.get(&quot;cluster&quot;) if kwargs and &quot;cluster&quot; in kwargs else None
    datacenter_name = (
        kwargs.get(&quot;datacenter&quot;) if kwargs and &quot;datacenter&quot; in kwargs else None
    )

    host_user = config.get_cloud_config_value(
        &quot;esxi_host_user&quot;, get_configured_provider(), __opts__, search_global=False
    )
    host_password = config.get_cloud_config_value(
        &quot;esxi_host_password&quot;, get_configured_provider(), __opts__, search_global=False
    )
    host_ssl_thumbprint = config.get_cloud_config_value(
        &quot;esxi_host_ssl_thumbprint&quot;,
        get_configured_provider(),
        __opts__,
        search_global=False,
    )

    if not host_user:
        raise SaltCloudSystemExit(
            &quot;You must specify the ESXi host username in your providers config.&quot;
        )

    if not host_password:
        raise SaltCloudSystemExit(
            &quot;You must specify the ESXi host password in your providers config.&quot;
        )

    if not host_name:
        raise SaltCloudSystemExit(
            &quot;You must specify either the IP or DNS name of the host system.&quot;
        )

    if (cluster_name and datacenter_name) or not (cluster_name or datacenter_name):
        raise SaltCloudSystemExit(
            &quot;You must specify either the cluster name or the datacenter name.&quot;
        )

    # Get the service instance
    si = _get_si()

    if cluster_name:
        cluster_ref = salt.utils.vmware.get_mor_by_property(
            si, vim.ClusterComputeResource, cluster_name
        )
        if not cluster_ref:
            raise SaltCloudSystemExit(&quot;Specified cluster does not exist.&quot;)

    if datacenter_name:
        datacenter_ref = salt.utils.vmware.get_mor_by_property(
            si, vim.Datacenter, datacenter_name
        )
        if not datacenter_ref:
            raise SaltCloudSystemExit(&quot;Specified datacenter does not exist.&quot;)

    spec = vim.host.ConnectSpec(
        hostName=host_name,
        userName=host_user,
        password=host_password,
    )

    if host_ssl_thumbprint:
        spec.sslThumbprint = host_ssl_thumbprint
    else:
        log.warning(&quot;SSL thumbprint has not been specified in provider configuration&quot;)
        # This smells like a not-so-good idea. A plenty of VMWare VCenters
        # do not listen to the default port 443.
        try:
            log.debug(&quot;Trying to get the SSL thumbprint directly from the host system&quot;)
            p1 = subprocess.Popen(
                (&quot;echo&quot;, &quot;-n&quot;), stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )
            p2 = subprocess.Popen(
                (&quot;openssl&quot;, &quot;s_client&quot;, &quot;-connect&quot;, &quot;{}:443&quot;.format(host_name)),
                stdin=p1.stdout,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            p3 = subprocess.Popen(
                (&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-sha1&quot;),
                stdin=p2.stdout,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            out = salt.utils.stringutils.to_str(p3.stdout.read())
            ssl_thumbprint = out.split(&quot;=&quot;)[-1].strip()
            log.debug(
                &quot;SSL thumbprint received from the host system: %s&quot;, ssl_thumbprint
            )
            spec.sslThumbprint = ssl_thumbprint
        except Exception as exc:  # pylint: disable=broad-except
            log.error(
                &quot;Error while trying to get SSL thumbprint of host %s: %s&quot;,
                host_name,
                exc,
                # Show the traceback if the debug logging level is enabled
                exc_info_on_loglevel=logging.DEBUG,
            )
            return {host_name: &quot;failed to add host&quot;}

    try:
        if cluster_name:
            task = cluster_ref.AddHost(spec=spec, asConnected=True)
            ret = &quot;added host system to cluster {}&quot;.format(cluster_name)
        if datacenter_name:
            task = datacenter_ref.hostFolder.AddStandaloneHost(
                spec=spec, addConnected=True
            )
            ret = &quot;added host system to datacenter {}&quot;.format(datacenter_name)
        salt.utils.vmware.wait_for_task(task, host_name, &quot;add host system&quot;, 5, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        if isinstance(exc, vim.fault.SSLVerifyFault):
            log.error(&quot;Authenticity of the host's SSL certificate is not verified&quot;)
            log.info(
                &quot;Try again after setting the esxi_host_ssl_thumbprint &quot;
                &quot;to %s in provider configuration&quot;,
                spec.sslThumbprint,
            )
        log.error(
            &quot;Error while adding host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to add host&quot;}

    return {host_name: ret}


def remove_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Remove the specified host system from this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f remove_host my-vmware-config host=&quot;myHostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The remove_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    # Get the service instance
    si = _get_si()

    host_ref = salt.utils.vmware.get_mor_by_property(si, vim.HostSystem, host_name)
    if not host_ref:
        raise SaltCloudSystemExit(&quot;Specified host system does not exist.&quot;)

    try:
        if isinstance(host_ref.parent, vim.ClusterComputeResource):
            # This is a host system that is part of a Cluster
            task = host_ref.Destroy_Task()
        else:
            # This is a standalone host system
            task = host_ref.parent.Destroy_Task()
        salt.utils.vmware.wait_for_task(
            task, host_name, &quot;remove host&quot;, log_level=&quot;info&quot;
        )
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while removing host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to remove host&quot;}

    return {host_name: &quot;removed host from vcenter&quot;}


def connect_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Connect the specified host system in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f connect_host my-vmware-config host=&quot;myHostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The connect_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    # Get the service instance
    si = _get_si()

    host_ref = salt.utils.vmware.get_mor_by_property(si, vim.HostSystem, host_name)
    if not host_ref:
        raise SaltCloudSystemExit(&quot;Specified host system does not exist.&quot;)

    if host_ref.runtime.connectionState == &quot;connected&quot;:
        return {host_name: &quot;host system already connected&quot;}

    try:
        task = host_ref.ReconnectHost_Task()
        salt.utils.vmware.wait_for_task(task, host_name, &quot;connect host&quot;, 5, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while connecting host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to connect host&quot;}

    return {host_name: &quot;connected host&quot;}


def disconnect_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Disconnect the specified host system in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f disconnect_host my-vmware-config host=&quot;myHostSystemName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The disconnect_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    # Get the service instance
    si = _get_si()

    host_ref = salt.utils.vmware.get_mor_by_property(si, vim.HostSystem, host_name)
    if not host_ref:
        raise SaltCloudSystemExit(&quot;Specified host system does not exist.&quot;)

    if host_ref.runtime.connectionState == &quot;disconnected&quot;:
        return {host_name: &quot;host system already disconnected&quot;}

    try:
        task = host_ref.DisconnectHost_Task()
        salt.utils.vmware.wait_for_task(
            task, host_name, &quot;disconnect host&quot;, log_level=&quot;info&quot;
        )
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while disconnecting host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to disconnect host&quot;}

    return {host_name: &quot;disconnected host&quot;}


def reboot_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Reboot the specified host system in this VMware environment

    .. note::

        If the host system is not in maintenance mode, it will not be rebooted. If you
        want to reboot the host system regardless of whether it is in maintenance mode,
        set ``force=True``. Default is ``force=False``.

    CLI Example:

    .. code-block:: bash

        salt-cloud -f reboot_host my-vmware-config host=&quot;myHostSystemName&quot; [force=True]
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The reboot_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None
    force = _str_to_bool(kwargs.get(&quot;force&quot;)) if kwargs and &quot;force&quot; in kwargs else False

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    # Get the service instance
    si = _get_si()

    host_ref = salt.utils.vmware.get_mor_by_property(si, vim.HostSystem, host_name)
    if not host_ref:
        raise SaltCloudSystemExit(&quot;Specified host system does not exist.&quot;)

    if host_ref.runtime.connectionState == &quot;notResponding&quot;:
        raise SaltCloudSystemExit(
            &quot;Specified host system cannot be rebooted in it's current state (not&quot;
            &quot; responding).&quot;
        )

    if not host_ref.capability.rebootSupported:
        raise SaltCloudSystemExit(&quot;Specified host system does not support reboot.&quot;)

    if not host_ref.runtime.inMaintenanceMode and not force:
        raise SaltCloudSystemExit(
            &quot;Specified host system is not in maintenance mode. Specify force=True to&quot;
            &quot; force reboot even if there are virtual machines running or other&quot;
            &quot; operations in progress.&quot;
        )

    try:
        host_ref.RebootHost_Task(force)
        _wait_for_host(host_ref, &quot;reboot&quot;, 10, &quot;info&quot;)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while rebooting host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to reboot host&quot;}

    return {host_name: &quot;rebooted host&quot;}


def create_datastore_cluster(kwargs=None, call=None):
    &quot;&quot;&quot;
    Create a new datastore cluster for the specified datacenter in this VMware environment

    CLI Example:

    .. code-block:: bash

        salt-cloud -f create_datastore_cluster my-vmware-config name=&quot;datastoreClusterName&quot; datacenter=&quot;datacenterName&quot;
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The create_datastore_cluster function must be called with &quot;
            &quot;-f or --function.&quot;
        )

    datastore_cluster_name = kwargs.get(&quot;name&quot;) if kwargs and &quot;name&quot; in kwargs else None
    datacenter_name = (
        kwargs.get(&quot;datacenter&quot;) if kwargs and &quot;datacenter&quot; in kwargs else None
    )

    if not datastore_cluster_name:
        raise SaltCloudSystemExit(
            &quot;You must specify name of the new datastore cluster to be created.&quot;
        )

    if not datastore_cluster_name or len(datastore_cluster_name) &gt;= 80:
        raise SaltCloudSystemExit(
            &quot;The datastore cluster name must be a non empty string of less than 80&quot;
            &quot; characters.&quot;
        )

    if not datacenter_name:
        raise SaltCloudSystemExit(
            &quot;You must specify name of the datacenter where the datastore cluster should&quot;
            &quot; be created.&quot;
        )

    # Get the service instance
    si = _get_si()

    # Check if datastore cluster already exists
    datastore_cluster_ref = salt.utils.vmware.get_mor_by_property(
        si, vim.StoragePod, datastore_cluster_name
    )
    if datastore_cluster_ref:
        return {datastore_cluster_name: &quot;datastore cluster already exists&quot;}

    datacenter_ref = salt.utils.vmware.get_mor_by_property(
        si, vim.Datacenter, datacenter_name
    )
    if not datacenter_ref:
        raise SaltCloudSystemExit(&quot;The specified datacenter does not exist.&quot;)

    try:
        datacenter_ref.datastoreFolder.CreateStoragePod(name=datastore_cluster_name)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error creating datastore cluster %s: %s&quot;,
            datastore_cluster_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return False

    return {datastore_cluster_name: &quot;created&quot;}


def shutdown_host(kwargs=None, call=None):
    &quot;&quot;&quot;
    Shut down the specified host system in this VMware environment

    .. note::

        If the host system is not in maintenance mode, it will not be shut down. If you
        want to shut down the host system regardless of whether it is in maintenance mode,
        set ``force=True``. Default is ``force=False``.

    CLI Example:

    .. code-block:: bash

        salt-cloud -f shutdown_host my-vmware-config host=&quot;myHostSystemName&quot; [force=True]
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The shutdown_host function must be called with -f or --function.&quot;
        )

    host_name = kwargs.get(&quot;host&quot;) if kwargs and &quot;host&quot; in kwargs else None
    force = _str_to_bool(kwargs.get(&quot;force&quot;)) if kwargs and &quot;force&quot; in kwargs else False

    if not host_name:
        raise SaltCloudSystemExit(&quot;You must specify name of the host system.&quot;)

    # Get the service instance
    si = _get_si()

    host_ref = salt.utils.vmware.get_mor_by_property(si, vim.HostSystem, host_name)
    if not host_ref:
        raise SaltCloudSystemExit(&quot;Specified host system does not exist.&quot;)

    if host_ref.runtime.connectionState == &quot;notResponding&quot;:
        raise SaltCloudSystemExit(
            &quot;Specified host system cannot be shut down in it's current state (not&quot;
            &quot; responding).&quot;
        )

    if not host_ref.capability.rebootSupported:
        raise SaltCloudSystemExit(&quot;Specified host system does not support shutdown.&quot;)

    if not host_ref.runtime.inMaintenanceMode and not force:
        raise SaltCloudSystemExit(
            &quot;Specified host system is not in maintenance mode. Specify force=True to&quot;
            &quot; force reboot even if there are virtual machines running or other&quot;
            &quot; operations in progress.&quot;
        )

    try:
        host_ref.ShutdownHost_Task(force)
    except Exception as exc:  # pylint: disable=broad-except
        log.error(
            &quot;Error while shutting down host %s: %s&quot;,
            host_name,
            exc,
            # Show the traceback if the debug logging level is enabled
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {host_name: &quot;failed to shut down host&quot;}

    return {host_name: &quot;shut down host&quot;}
</PRE>
</div>
  </div>
</body>
</html>
