<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for boto_elasticache.py & boto_iam.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for boto_elasticache.py & boto_iam.py
      </h3>
      <h1 align="center">
        13.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>boto_elasticache.py (52.09302%)<TH>boto_iam.py (8.005718%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#0',2,'match11856-1.html#0',3)" NAME="0">(486-502)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#0',2,'match11856-1.html#0',3)" NAME="0">(1630-1641)</A><TD ALIGN=center><FONT COLOR="#ff0000">29</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#1',2,'match11856-1.html#1',3)" NAME="1">(353-391)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#1',2,'match11856-1.html#1',3)" NAME="1">(1742-1791)</A><TD ALIGN=center><FONT COLOR="#ff0000">29</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#2',2,'match11856-1.html#2',3)" NAME="2">(319-332)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#2',2,'match11856-1.html#2',3)" NAME="2">(1118-1131)</A><TD ALIGN=center><FONT COLOR="#db0000">25</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#3',2,'match11856-1.html#3',3)" NAME="3">(520-533)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#3',2,'match11856-1.html#3',3)" NAME="3">(1721-1731)</A><TD ALIGN=center><FONT COLOR="#b80000">21</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#4',2,'match11856-1.html#4',3)" NAME="4">(509-518)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#4',2,'match11856-1.html#4',3)" NAME="4">(881-887)</A><TD ALIGN=center><FONT COLOR="#9e0000">18</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#5',2,'match11856-1.html#5',3)" NAME="5">(333-342)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#5',2,'match11856-1.html#5',3)" NAME="5">(1914-1921)</A><TD ALIGN=center><FONT COLOR="#950000">17</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#6',2,'match11856-1.html#6',3)" NAME="6">(94-113)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#6',2,'match11856-1.html#6',3)" NAME="6">(1484-1557)</A><TD ALIGN=center><FONT COLOR="#950000">17</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#7',2,'match11856-1.html#7',3)" NAME="7">(450-468)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#7',2,'match11856-1.html#7',3)" NAME="7">(1278-1287)</A><TD ALIGN=center><FONT COLOR="#8c0000">16</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#8',2,'match11856-1.html#8',3)" NAME="8">(477-482)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#8',2,'match11856-1.html#8',3)" NAME="8">(841-846)</A><TD ALIGN=center><FONT COLOR="#830000">15</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#9',2,'match11856-1.html#9',3)" NAME="9">(268-280)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#9',2,'match11856-1.html#9',3)" NAME="9">(1310-1324)</A><TD ALIGN=center><FONT COLOR="#720000">13</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#10',2,'match11856-1.html#10',3)" NAME="10">(443-449)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#10',2,'match11856-1.html#10',3)" NAME="10">(649-653)</A><TD ALIGN=center><FONT COLOR="#690000">12</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match11856-0.html#11',2,'match11856-1.html#11',3)" NAME="11">(232-239)<TD><A HREF="javascript:ZweiFrames('match11856-0.html#11',2,'match11856-1.html#11',3)" NAME="11">(429-432)</A><TD ALIGN=center><FONT COLOR="#690000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_elasticache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage Elasticache
==================

.. versionadded:: 2014.7.0

Create, destroy and update Elasticache clusters. Be aware that this interacts
with Amazon's services, and so may incur charges.

Note: This module currently only supports creation and deletion of
elasticache resources and will not modify clusters when their configuration
changes in your state files.

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit elasticache credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    elasticache.keyid: GKTADJGHEIQSXMKKRBJ08H
    elasticache.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    myprofile:
      keyid: GKTADJGHEIQSXMKKRBJ08H
      key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
        region: us-east-1

.. code-block:: yaml

    Ensure myelasticache exists:
      boto_elasticache.present:
        - name: myelasticache
        - engine: redis
        - cache_node_type: cache.t1.micro
        - num_cache_nodes: 1
        - notification_topic_arn: arn:aws:sns:us-east-1:879879:my-sns-topic
        - region: us-east-1
        - keyid: GKTADJGHEIQSXMKKRBJ08H
        - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    # Using a profile from pillars
    Ensure myelasticache exists:
      boto_elasticache.present:
        - name: myelasticache
        - engine: redis
        - cache_node_type: cache.t1.micro
        - num_cache_nodes: 1
        - notification_topic_arn: arn:aws:sns:us-east-1:879879:my-sns-topic
        - region: us-east-1
        - profile: myprofile

    # Passing in a profile
    Ensure myelasticache exists:
      boto_elasticache.present:
        - name: myelasticache
        - engine: redis
        - cache_node_type: cache.t1.micro
        - num_cache_nodes: 1
        - notification_topic_arn: arn:aws:sns:us-east-1:879879:my-sns-topic
        - region: us-east-1
        - profile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
&quot;&quot;&quot;


import logging

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto is available.
    &quot;&quot;&quot;
    if &quot;boto_elasticache.exists&quot; in __salt__:
        return &quot;boto_elasticache&quot;
    return (False, &quot;boto_elasticache module could not be loaded&quot;)
<A NAME="6"></A>

def cache_cluster_present(*args, **kwargs):
    return present(<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match11856-1.html#6',3,'match11856-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>*args, **kwargs)


def present(
    name,
    engine=None,
    cache_node_type=None,
    num_cache_nodes=None,
    preferred_availability_zone=None,
    port=None,
    cache_parameter_group_name=None,
    cache_security_group_names=None,
    replication_group_id=None,
    auto_minor_version_upgrade=True,
    security_group_ids=None,
    cache_subnet_group_name=None,
    engine_version=None,
    notification_topic_arn=None,
    preferred_maintenance_window=None,
    wait=</B></FONT>None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure the cache cluster exists.

    name
        Name of the cache cluster (cache cluster id).

    engine
        The name of the cache engine to be used for this cache cluster. Valid
        values are memcached or redis.

    cache_node_type
        The compute and memory capacity of the nodes in the cache cluster.
        cache.t1.micro, cache.m1.small, etc. See: https://boto.readthedocs.io/en/latest/ref/elasticache.html#boto.elasticache.layer1.ElastiCacheConnection.create_cache_cluster

    num_cache_nodes
        The number of cache nodes that the cache cluster will have.

    preferred_availability_zone
        The EC2 Availability Zone in which the cache cluster will be created.
        All cache nodes belonging to a cache cluster are placed in the
        preferred availability zone.

    port
        The port number on which each of the cache nodes will accept
        connections.

    cache_parameter_group_name
        The name of the cache parameter group to associate with this cache
        cluster. If this argument is omitted, the default cache parameter group
        for the specified engine will be used.

    cache_security_group_names
        A list of cache security group names to associate with this cache
        cluster. Use this parameter only when you are creating a cluster
        outside of a VPC.

    replication_group_id
        The replication group to which this cache cluster should belong. If
        this parameter is specified, the cache cluster will be added to the
        specified replication group as a read replica; otherwise, the cache
        cluster will be a standalone primary that is not part of any
        replication group.

    auto_minor_version_upgrade
        Determines whether minor engine upgrades will be applied automatically
        to the cache cluster during the maintenance window. A value of True
        allows these upgrades to occur; False disables automatic upgrades.

    security_group_ids
        One or more VPC security groups associated with the cache cluster. Use
        this parameter only when you are creating a cluster in a VPC.

    cache_subnet_group_name
        The name of the cache subnet group to be used for the cache cluster.
        Use this parameter only when you are creating a cluster in a VPC.

    engine_version
        The version number of the cache engine to be used for this cluster.

    notification_topic_arn
        The Amazon Resource Name (ARN) of the Amazon Simple Notification
        Service (SNS) topic to which notifications will be sent. The Amazon SNS
        topic owner must be the same as the cache cluster owner.

    preferred_maintenance_window
        The weekly time range (in UTC) during which system maintenance can
        occur. Example: sun:05:00-sun:09:00

    wait
        Boolean. Wait for confirmation from boto that the cluster is in the
        available state.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if cache_security_group_names and cache_subnet_group_name:
        _subnet_group = __salt__[&quot;boto_elasticache.get_cache_subnet_group&quot;](
            cache_subnet_group_name, region, key, keyid, profile
        )
        vpc_id = _subnet_group[&quot;vpc_id&quot;]
        if not security_group_ids:
            security_group_ids = []
        _security_group_ids = __salt__[&quot;boto_secgroup.convert_to_group_ids&quot;](
            groups=cache_security_group_names,
            vpc_id=vpc_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        security_group_ids.extend(_security_group_ids)
        cache_security_group_names = None
    config = __salt__[&quot;boto_elasticache.get_config&quot;](name, region, key, keyid, profile)
    if config is None:
        msg = &quot;Failed to retrieve cache cluster info from AWS.&quot;
        ret[&quot;comment&quot;] = msg
        ret[&quot;result&quot;] = None
        return ret
    elif not config:
<A NAME="11"></A>        if __opts__[&quot;test&quot;]:
            msg = &quot;Cache cluster {} is set to be created.&quot;.format(name)
            ret[&quot;comment&quot;] = msg
            ret<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match11856-1.html#11',3,'match11856-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_elasticache.create&quot;](
            name=name,
            num_cache_nodes=num_cache_nodes,
            cache_node_type=cache_node_type,
            engine=engine,
            replication_group_id=</B></FONT>replication_group_id,
            engine_version=engine_version,
            cache_parameter_group_name=cache_parameter_group_name,
            cache_subnet_group_name=cache_subnet_group_name,
            cache_security_group_names=cache_security_group_names,
            security_group_ids=security_group_ids,
            preferred_availability_zone=preferred_availability_zone,
            preferred_maintenance_window=preferred_maintenance_window,
            port=port,
            notification_topic_arn=notification_topic_arn,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            wait=wait,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if created:
            ret[&quot;changes&quot;][&quot;old&quot;] = None
            config = __salt__[&quot;boto_elasticache.get_config&quot;](
                name, region, key, keyid, profile
            )
            ret[&quot;changes&quot;][&quot;new&quot;] = config
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to create {} cache cluster.&quot;.format(name)
<A NAME="9"></A>            return ret
    # TODO: support modification of existing elasticache clusters
    else:
        ret[&quot;comment&quot;] = &quot;Cache cluster {} is present.&quot;<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match11856-1.html#9',3,'match11856-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.format(name)
    return ret


def subnet_group_present(
    name,
    subnet_ids=None,
    subnet_names=None,
    description=None,
    tags=None,
    region=None,
    key=None,
    keyid=</B></FONT>None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure ElastiCache subnet group exists.

    .. versionadded:: 2015.8.0

    name
        The name for the ElastiCache subnet group. This value is stored as a lowercase string.

    subnet_ids
        A list of VPC subnet IDs for the cache subnet group.  Exclusive with subnet_names.

    subnet_names
        A list of VPC subnet names for the cache subnet group.  Exclusive with subnet_ids.

    description
        Subnet group description.

    tags
        A list of tags.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    &quot;&quot;&quot;
<A NAME="2"></A>    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    exists = __salt__[&quot;boto_elasticache.subnet_group_exists&quot;](
        name=name, tags<FONT color="#980517"><A HREF="javascript:ZweiFrames('match11856-1.html#2',3,'match11856-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=tags, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Subnet group {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_elasticache.create_subnet_group&quot;](
            name=name,
            subnet_ids=subnet_ids,
            subnet_names=subnet_names,
<A NAME="5"></A>            description=description,
            tags=tags,
            region=</B></FONT>region,
            key<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match11856-1.html#5',3,'match11856-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=key,
            keyid=keyid,
            profile=profile,
        )
        if not created:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to create {} subnet group.&quot;.format(name)
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = None
        ret[&quot;changes&quot;][</B></FONT>&quot;new&quot;] = name
        ret[&quot;comment&quot;] = &quot;Subnet group {} created.&quot;.format(name)
        return ret
    ret[&quot;comment&quot;] = &quot;Subnet group present.&quot;
    return ret


def cache_cluster_absent(*args, **kwargs):
<A NAME="1"></A>    return absent(*args, **kwargs)


def absent(name, wait<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match11856-1.html#1',3,'match11856-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=True, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Ensure the named elasticache cluster is deleted.

    name
        Name of the cache cluster.

    wait
        Boolean. Wait for confirmation from boto that the cluster is in the
        deleting state.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    is_present = __salt__[&quot;boto_elasticache.exists&quot;](name, region, key, keyid, profile)

    if is_present:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Cache cluster {} is set to be removed.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        deleted = __salt__[&quot;boto_elasticache.delete&quot;](
            name, wait, region, key, keyid, profile
        )
        if deleted:
            ret[&quot;changes&quot;][&quot;old&quot;] = name
            ret[</B></FONT>&quot;changes&quot;][&quot;new&quot;] = None
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to delete {} cache cluster.&quot;.format(name)
    else:
        ret[&quot;comment&quot;] = &quot;{} does not exist in {}.&quot;.format(name, region)
    return ret


def replication_group_present(*args, **kwargs):
    return creategroup(*args, **kwargs)


def creategroup(
    name,
    primary_cluster_id,
    replication_group_description,
    wait=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure the a replication group is create.

    name
        Name of replication group

    wait
        Waits for the group to be available

    primary_cluster_id
        Name of the master cache node

    replication_group_description
        Description for the group

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
<A NAME="10"></A>        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    is_present <FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match11856-1.html#10',3,'match11856-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= __salt__[&quot;boto_elasticache.group_exists&quot;](
        name, region, key, keyid, profile
    )
    if not is_present:
<A NAME="7"></A>        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Replication {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] =</B></FONT> None
        created <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match11856-1.html#7',3,'match11856-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= __salt__[&quot;boto_elasticache.create_replication_group&quot;](
            name,
            primary_cluster_id,
            replication_group_description,
            wait,
            region,
            key,
            keyid,
            profile,
        )
        if created:
            config = __salt__[&quot;boto_elasticache.describe_replication_group&quot;](
                name, region, key, keyid, profile
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = None
            ret[&quot;changes&quot;][&quot;new&quot;] = config
            ret[&quot;result&quot;] = True
        else:
            ret[</B></FONT>&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to create {} replication group.&quot;.format(name)
    else:
        ret[&quot;comment&quot;] = &quot;{} replication group exists .&quot;.format(name)
        ret[&quot;result&quot;] = True
    return ret
<A NAME="8"></A>

def subnet_group_absent(
    name, tags=None, region<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match11856-1.html#8',3,'match11856-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=None, key=None, keyid=None, profile=None
):
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    exists = __salt__[&quot;boto_elasticache.subnet_group_exists&quot;](
        name=name, tags=tags, region=region, key=key, keyid=keyid, profile=</B></FONT>profile
<A NAME="0"></A>    )
    if not exists:
        ret[&quot;result&quot;] = True
        ret<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match11856-1.html#0',3,'match11856-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;comment&quot;] = &quot;{} ElastiCache subnet group does not exist.&quot;.format(name)
        return ret

    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;ElastiCache subnet group {} is set to be removed.&quot;.format(
            name
        )
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_elasticache.delete_subnet_group&quot;](
        name, region, key, keyid, profile
    )
    if not deleted:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to delete {} ElastiCache subnet group.&quot;.format(name)
        return ret
    ret[</B></FONT>&quot;changes&quot;][&quot;old&quot;] = name
    ret[&quot;changes&quot;][&quot;new&quot;] = None
    ret[&quot;comment&quot;] = &quot;ElastiCache subnet group {} deleted.&quot;.format(name)
    return ret
<A NAME="4"></A>

def replication_group_absent(
    name, tags=None, region<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match11856-1.html#4',3,'match11856-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=None, key=None, keyid=None, profile=None
):
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    exists = __salt__[&quot;boto_elasticache.group_exists&quot;](
        name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
<A NAME="3"></A>        ret[&quot;result&quot;] = True
        ret[</B></FONT>&quot;comment&quot;] = &quot;{} ElastiCache replication group does not exist.&quot;.format(name)
        log.info(ret[&quot;comment&quot;])
        <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match11856-1.html#3',3,'match11856-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return ret

    if __opts__[&quot;test&quot;]:
        ret[
            &quot;comment&quot;
        ] = &quot;ElastiCache replication group {} is set to be removed.&quot;.format(name)
        ret[&quot;result&quot;] = True
        return ret
    deleted = __salt__[&quot;boto_elasticache.delete_replication_group&quot;](
        name, region, key, keyid, profile
    )
    if not deleted:
        ret[&quot;result&quot;] = False
        log.error(ret[</B></FONT>&quot;comment&quot;])
        ret[&quot;comment&quot;] = &quot;Failed to delete {} ElastiCache replication group.&quot;.format(
            name
        )
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = name
    ret[&quot;changes&quot;][&quot;new&quot;] = None
    ret[&quot;comment&quot;] = &quot;ElastiCache replication group {} deleted.&quot;.format(name)
    log.info(ret[&quot;comment&quot;])
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage IAM objects
==================

.. versionadded:: 2015.8.0

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit IAM credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    delete-user:
      boto_iam.user_absent:
        - name: myuser
        - delete_keys: true


.. code-block:: yaml

    delete-keys:
      boto_iam.keys_absent:
        - access_keys:
          - 'AKIAJHTMIQ2ASDFLASDF'
          - 'PQIAJHTMIQ2ASRTLASFR'
        - user_name: myuser

.. code-block:: yaml

    create-user:
      boto_iam.user_present:
        - name: myuser
        - policies:
            mypolicy: |
                {
                    &quot;Version&quot;: &quot;2012-10-17&quot;,
                    &quot;Statement&quot;: [{
                    &quot;Effect&quot;: &quot;Allow&quot;,
                    &quot;Action&quot;: &quot;*&quot;,
                    &quot;Resource&quot;: &quot;*&quot;}]
                }
        - password: NewPassword$$1
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create-group:
      boto_iam.group_present:
        - name: mygroup
        - users:
          - myuser
          - myuser1
        - policies:
            mypolicy: |
                {
                    &quot;Version&quot;: &quot;2012-10-17&quot;,
                    &quot;Statement&quot;: [{
                    &quot;Effect&quot;: &quot;Allow&quot;,
                    &quot;Action&quot;: &quot;*&quot;,
                    &quot;Resource&quot;: &quot;*&quot;}]
                }
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    change-policy:
      boto_iam.account_policy:
        - change_password: True
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    create server certificate:
      boto_iam.server_cert_present:
        - name: mycert
        - public_key: salt://base/mycert.crt
        - private_key: salt://base/mycert.key
        - cert_chain: salt://base/mycert_chain.crt
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    delete server certificate:
      boto_iam.server_cert_absent:
        - name: mycert

.. code-block:: yaml

    create keys for user:
      boto_iam.keys_present:
        - name: myusername
        - number: 2
        - save_dir: /root
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create policy:
      boto_iam.policy_present:
        - name: myname
        - policy_document: '{&quot;MyPolicy&quot;: &quot;Statement&quot;: [{&quot;Action&quot;: [&quot;sqs:*&quot;], &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: [&quot;arn:aws:sqs:*:*:*&quot;], &quot;Sid&quot;: &quot;MyPolicySqs1&quot;}]}'
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    add-saml-provider:
      boto_iam.saml_provider_present:
        - name: my_saml_provider
        - saml_metadata_document: salt://base/files/provider.xml
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
&quot;&quot;&quot;

import logging
import os
import xml.etree.ElementTree as ET

import salt.utils.data
import salt.utils.dictupdate as dictupdate
import salt.utils.files
import salt.utils.json
import salt.utils.odict as odict
import salt.utils.stringutils

log = logging.getLogger(__name__)

__virtualname__ = &quot;boto_iam&quot;


def __virtual__():
    &quot;&quot;&quot;
    Only load if elementtree xml library and boto are available.
    &quot;&quot;&quot;
    if &quot;boto_iam.get_user&quot; in __salt__:
        return True
    else:
        return (
            False,
            &quot;Cannot load {} state: boto_iam module unavailable&quot;.format(__virtualname__),
        )


def user_absent(
    name,
    delete_keys=True,
    delete_mfa_devices=True,
    delete_profile=True,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user is absent. User cannot be deleted if it has keys.

    name (string)
        The name of the new user.

    delete_keys (bool)
        Delete all keys from user.

    delete_mfa_devices (bool)
        Delete all mfa devices from user.

        .. versionadded:: 2016.3.0

    delete_profile (bool)
        Delete profile from user.

        .. versionadded:: 2016.3.0

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(name)
        return ret
    # delete the user's access keys
    if delete_keys:
        keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        log.debug(&quot;Keys for user %s are %s.&quot;, name, keys)
        if isinstance(keys, dict):
            keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
                &quot;access_key_metadata&quot;
            ]
            for k in keys:
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;Key {} is set to be deleted.&quot;.format(k[&quot;access_key_id&quot;]),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    if _delete_key(
                        ret, k[&quot;access_key_id&quot;], name, region, key, keyid, profile
                    ):
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;Key {} has been deleted.&quot;.format(k[&quot;access_key_id&quot;]),
                            ]
                        )
                        ret[&quot;changes&quot;][k[&quot;access_key_id&quot;]] = &quot;deleted&quot;
    # delete the user's MFA tokens
    if delete_mfa_devices:
        devices = __salt__[&quot;boto_iam.get_all_mfa_devices&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        if devices:
            for d in devices:
                serial = d[&quot;serial_number&quot;]
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;IAM user {} MFA device {} is set to be deactivated.&quot;.format(
                                name, serial
                            ),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    mfa_deactivated = __salt__[&quot;boto_iam.deactivate_mfa_device&quot;](
                        user_name=name,
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deactivated:
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;IAM user {} MFA device {} is deactivated.&quot;.format(
                                    name, serial
                                ),
                            ]
                        )
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;Virtual MFA device {} is set to be deleted.&quot;.format(
                                serial
                            ),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    mfa_deleted = __salt__[&quot;boto_iam.delete_virtual_mfa_device&quot;](
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deleted:
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;Virtual MFA device {} is deleted.&quot;.format(serial),
                            ]
                        )
    # delete the user's login profile
    if delete_profile:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;IAM user {} login profile is set to be deleted.&quot;.format(name),
                ]
            )
            ret[&quot;result&quot;] = None
        else:
            profile_deleted = __salt__[&quot;boto_iam.delete_login_profile&quot;](
                name, region, key, keyid, profile
            )
            if profile_deleted:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;IAM user {} login profile is deleted.&quot;.format(name),
                    ]
                )
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM user {} managed policies are set to be detached.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _user_policies_detached(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM user {} inline policies are set to be deleted.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _user_policies_deleted(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    # finally, actually delete the user
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM user {} is set to be deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_user&quot;](name, region, key, keyid, profile)
    if deleted is True:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM user {} is deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;deleted&quot;] = name
        return ret
    ret[&quot;comment&quot;] = &quot;IAM user {} could not be deleted.\n {}&quot;.format(name, deleted)
    ret[&quot;result&quot;] = False
    return ret


def keys_present(
    name,
    number,
    save_dir,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    save_format=&quot;{2}\n{0}\n{3}\n{1}\n&quot;,
):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Ensure the IAM access keys are present.

    name (string)
        The name of the new user.

    number (int)
        Number of keys that user should have.

    save_dir (string)
        The directory that the key/keys will be saved. Keys are saved to a file named according
        to the username privided.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.

    save_format (dict)
        Save format is repeated for each key. Default format is
        &quot;{2}\\n{0}\\n{3}\\n{1}\\n&quot;, where {0} and {1} are placeholders for new
        key_id and key respectively, whereas {2} and {3} are &quot;key_id-{number}&quot;
        and 'key-{number}' strings kept for compatibility.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(name)
        return ret
    if not isinstance(number, int):
        ret[&quot;comment&quot;] = &quot;The number of keys must be an integer.&quot;
        ret[&quot;result&quot;] = False
<A NAME="11"></A>        return ret
    if not os.path.isdir(save_dir):
        ret[&quot;comment&quot;] = &quot;The directory {} does not exist.&quot;.format(save_dir)
        ret<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#11',2,'match11856-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;result&quot;] = False
        return ret
    keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=</B></FONT>profile
    )
    if isinstance(keys, str):
        log.debug(&quot;keys are : false %s&quot;, keys)
        error, message = _get_error(keys)
        ret[&quot;comment&quot;] = &quot;Could not get keys.\n{}\n{}&quot;.format(error, message)
        ret[&quot;result&quot;] = False
        return ret
    keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
        &quot;access_key_metadata&quot;
    ]
    log.debug(&quot;Keys are : %s.&quot;, keys)
    if len(keys) &gt;= number:
        ret[&quot;comment&quot;] = &quot;The number of keys exist for user {}&quot;.format(name)
        ret[&quot;result&quot;] = True
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Access key is set to be created for {}.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    new_keys = {}
    for i in range(number - len(keys)):
        created = __salt__[&quot;boto_iam.create_access_key&quot;](
            name, region, key, keyid, profile
        )
        if isinstance(created, str):
            error, message = _get_error(created)
            ret[&quot;comment&quot;] = &quot;Could not create keys.\n{}\n{}&quot;.format(error, message)
            ret[&quot;result&quot;] = False
            return ret
        log.debug(&quot;Created is : %s&quot;, created)
        response = &quot;create_access_key_response&quot;
        result = &quot;create_access_key_result&quot;
        new_keys[str(i)] = {}
        new_keys[str(i)][&quot;key_id&quot;] = created[response][result][&quot;access_key&quot;][
            &quot;access_key_id&quot;
        ]
        new_keys[str(i)][&quot;secret_key&quot;] = created[response][result][&quot;access_key&quot;][
            &quot;secret_access_key&quot;
        ]
    try:
        with salt.utils.files.fopen(&quot;{}/{}&quot;.format(save_dir, name), &quot;a&quot;) as _wrf:
            for key_num, key in new_keys.items():
                key_id = key[&quot;key_id&quot;]
                secret_key = key[&quot;secret_key&quot;]
                _wrf.write(
                    salt.utils.stringutils.to_str(
                        save_format.format(
                            key_id,
                            secret_key,
                            &quot;key_id-{}&quot;.format(key_num),
                            &quot;key-{}&quot;.format(key_num),
                        )
                    )
                )
        ret[&quot;comment&quot;] = &quot;Keys have been written to file {}/{}.&quot;.format(save_dir, name)
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;] = new_keys
        return ret
    except OSError:
        ret[&quot;comment&quot;] = &quot;Could not write to file {}/{}.&quot;.format(save_dir, name)
        ret[&quot;result&quot;] = False
        return ret


def keys_absent(
    access_keys, user_name, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user access_key_id is absent.

    access_key_id (list)
        A list of access key ids

    user_name (string)
        The username of the user

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: access_keys, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](user_name, region, key, keyid, profile):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(user_name)
        return ret
    for k in access_keys:
        ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
    return ret


def _delete_key(
    ret, access_key_id, user_name, region=None, key=None, keyid=None, profile=None
):
    keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
        user_name=user_name, region=region, key=key, keyid=keyid, profile=profile
    )
    log.debug(&quot;Keys for user %s are : %s.&quot;, keys, user_name)
    if isinstance(keys, str):
        log.debug(&quot;Keys %s are a string. Something went wrong.&quot;, keys)
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Key {} could not be deleted.&quot;.format(access_key_id)]
        )
        return ret
    keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
        &quot;access_key_metadata&quot;
    ]
    for k in keys:
        log.debug(
            &quot;Key is: %s and is compared with: %s&quot;, k[&quot;access_key_id&quot;], access_key_id
        )
        if str(k[&quot;access_key_id&quot;]) == str(access_key_id):
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;Access key {} is set to be deleted.&quot;.format(
                    access_key_id
                )
                ret[&quot;result&quot;] = None
                return ret
            deleted = __salt__[&quot;boto_iam.delete_access_key&quot;](
                access_key_id, user_name, region, key, keyid, profile
            )
            if deleted:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [ret[&quot;comment&quot;], &quot;Key {} has been deleted.&quot;.format(access_key_id)]
                )
                ret[&quot;changes&quot;][access_key_id] = &quot;deleted&quot;
                return ret
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Key {} could not be deleted.&quot;.format(access_key_id)]
            )
            return ret
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Key {} does not exist.&quot;.format(k)])
        return ret


def user_present(
    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    password=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user is present

    name (string)
        The name of the new user.

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of managed policy names or ARNs that should be attached to this
        user.

    password (string)
        The password for the new user. Must comply with account policy.

    path (string)
        The path of the user. Default is '/'.

        .. versionadded:: 2015.8.2

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
<A NAME="10"></A>        _policy = __salt__[&quot;pillar.get&quot;](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists <FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#10',2,'match11856-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile)
    if not exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM user {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] =</B></FONT> None
            return ret
        created = __salt__[&quot;boto_iam.create_user&quot;](
            name, path, region, key, keyid, profile
        )
        if created:
            ret[&quot;changes&quot;][&quot;user&quot;] = created
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;User {} has been created.&quot;.format(name)]
            )
            if password:
                ret = _case_password(ret, name, password, region, key, keyid, profile)
            _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
            ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
            ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    else:
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;User {} is present.&quot;.format(name)])
        if password:
            ret = _case_password(ret, name, password, region, key, keyid, profile)
        _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
        ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    return ret


def _user_policies_present(
    name, policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__[&quot;boto_iam.get_user_policy&quot;](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug(&quot;Policy mismatch:\n%s\n%s&quot;, _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    for policy_name in _list:
        if policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on user {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policies&quot;: _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__[&quot;boto_iam.put_user_policy&quot;](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} for user {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__[&quot;boto_iam.delete_user_policy&quot;](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to user {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
        ret[&quot;comment&quot;] = &quot;{} policies modified on user {}.&quot;.format(
            &quot;, &quot;.join(_list), name
        )
    return ret


def _user_policies_attached(
    name, managed_policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__[&quot;boto_iam.list_entities_for_policy&quot;](
            policy,
            entity_filter=&quot;User&quot;,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for userdict in entities.get(&quot;policy_users&quot;, []):
            if name == userdict.get(&quot;user_name&quot;):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    for policy_data in _list:
        if (
            policy_data.get(&quot;policy_name&quot;) not in managed_policies
            and policy_data.get(&quot;policy_arn&quot;) not in managed_policies
        ):
            policies_to_detach.append(policy_data.get(&quot;policy_arn&quot;))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on user {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__[&quot;boto_iam.attach_user_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to user {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__[&quot;boto_iam.detach_user_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to remove policy {} from user {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
        log.debug(newpolicies)
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
        ret[&quot;comment&quot;] = &quot;{} policies modified on user {}.&quot;.format(
            &quot;, &quot;.join(newpolicies), name
        )
<A NAME="8"></A>    return ret


def _user_policies_detached(name, region<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#8',2,'match11856-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies =</B></FONT> [x.get(&quot;policy_arn&quot;) for x in _list]
    if not _list:
        ret[&quot;comment&quot;] = &quot;No attached policies in user {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be detached from user {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__[&quot;boto_iam.detach_user_policy&quot;](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from user {}&quot;.format(policy_arn, name)
            return ret
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies detached from user {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
<A NAME="4"></A>    return ret


def _user_policies_deleted(name, region<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#4',2,'match11856-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    oldpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret[&quot;comment&quot;] = &quot;No inline policies in user {}.&quot;.</B></FONT>format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be deleted from user {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;inline_policies&quot;: oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__[&quot;boto_iam.delete_user_policy&quot;](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from user {}&quot;.format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies deleted from user {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
    return ret


def _case_password(
    ret, name, password, region=None, key=None, keyid=None, profile=None
):
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Login policy for {} is set to be changed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    login = __salt__[&quot;boto_iam.create_login_profile&quot;](
        name, password, region, key, keyid, profile
    )
    log.debug(&quot;Login is : %s.&quot;, login)
    if login:
        if &quot;Conflict&quot; in login:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Login profile for user {} exists.&quot;.format(name)]
            )
        else:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Password has been added to User {}.&quot;.format(name)]
            )
            ret[&quot;changes&quot;][&quot;password&quot;] = &quot;REDACTED&quot;
    else:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;Password for user {} could not be set.\nPlease check your password&quot;
                &quot; policy.&quot;.format(name),
            ]
        )
    return ret


def group_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM group is absent.

    name (string)
        The name of the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_group&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;IAM Group {} does not exist.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM group {} managed policies are set to be detached.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _group_policies_detached(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM group {} inline policies are set to be deleted.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _group_policies_deleted(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    ret[&quot;comment&quot;] = &quot; &quot;.join(
        [ret[&quot;comment&quot;], &quot;IAM group {} users are set to be removed.&quot;.format(name)]
    )
    existing_users = __salt__[&quot;boto_iam.get_group_members&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    # finally, actually delete the group
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM group {} is set to be deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_group&quot;](name, region, key, keyid, profile)
    if deleted is True:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM group {} is deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;deleted&quot;] = name
        return ret
    ret[&quot;comment&quot;] = &quot;IAM group {} could not be deleted.\n {}&quot;.format(name, deleted)
    ret[&quot;result&quot;] = False
    return ret


def group_present(
    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    users=None,
    path=&quot;/&quot;,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM group is present

    name (string)
        The name of the new group.

    path (string)
        The path for the group, defaults to '/'

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of policy names or ARNs that should be attached to this group.

    users (list)
        A list of users to be added to the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    delete_policies (boolean)
        Delete or detach existing policies that are not in the given list of policies.
        Default value is ``True``. If ``False`` is specified, existing policies
        will not be deleted or detached allowing manual modifications on the IAM group
        to be persistent.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__[&quot;pillar.get&quot;](policy)
<A NAME="2"></A>        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__[&quot;boto_iam.get_group&quot;](
        group_name<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#2',2,'match11856-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM group {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_iam.create_group&quot;](
            group_name=name,
            path=path,
            region=region,
            key=key,
            keyid=keyid,
            profile=</B></FONT>profile,
        )
        if not created:
            ret[&quot;comment&quot;] = &quot;Failed to create IAM group {}.&quot;.format(name)
            ret[&quot;result&quot;] = False
            return ret
        ret[&quot;changes&quot;][&quot;group&quot;] = created
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Group {} has been created.&quot;.format(name)]
        )
    else:
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Group {} is present.&quot;.format(name)])
    # Group exists, ensure group policies and users are set.
    _ret = _group_policies_present(
        name, _policies, region, key, keyid, profile, delete_policies
    )
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    _ret = _group_policies_attached(
        name, managed_policies, region, key, keyid, profile, delete_policies
    )
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    if users is not None:
        log.debug(&quot;Users are : %s.&quot;, users)
        existing_users = __salt__[&quot;boto_iam.get_group_members&quot;](
            group_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
    return ret


def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
    _users = []
    for user in existing_users:
        _users.append(user[&quot;user_name&quot;])
    log.debug(&quot;upstream users are %s&quot;, _users)
    for user in users:
        log.debug(&quot;users are %s&quot;, user)
        if user in _users:
            log.debug(&quot;user exists&quot;)
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;User {} is already a member of group {}.&quot;.format(user, group_name),
                ]
            )
            continue
        else:
            log.debug(&quot;user is set to be added %s&quot;, user)
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;User {} is set to be added to group {}.&quot;.format(
                    user, group_name
                )
                ret[&quot;result&quot;] = None
            else:
                __salt__[&quot;boto_iam.add_user_to_group&quot;](
                    user, group_name, region, key, keyid, profile
                )
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} has been added to group {}.&quot;.format(user, group_name),
                    ]
                )
                ret[&quot;changes&quot;][user] = group_name
    for user in _users:
        if user not in users:
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} is set to be removed from group {}.&quot;.format(
                            user, group_name
                        ),
                    ]
                )
                ret[&quot;result&quot;] = None
            else:
                __salt__[&quot;boto_iam.remove_user_from_group&quot;](
                    group_name=group_name,
                    user_name=user,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} has been removed from group {}.&quot;.format(
                            user, group_name
                        ),
                    ]
                )
                ret[&quot;changes&quot;][user] = &quot;Removed from group {}.&quot;.format(group_name)
    return ret


def _group_policies_present(
    name,
    policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__[&quot;boto_iam.get_group_policy&quot;](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug(&quot;Policy mismatch:\n%s\n%s&quot;, _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        name, region, key, keyid, profile
    )
    for policy_name in _list:
        if delete_policies and policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on group {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
<A NAME="7"></A>            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policies&quot;: _list}
        for policy_name, policy in policies_to_create.items():
            policy_set <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#7',2,'match11856-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= __salt__[&quot;boto_iam.put_group_policy&quot;](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                    name, region, key, keyid, profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.</B></FONT>format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__[&quot;boto_iam.delete_group_policy&quot;](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                    name, region, key, keyid, profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
            name, region, key, keyid, profile
<A NAME="9"></A>        )
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
        ret[&quot;comment&quot;] = &quot;{} policies modified on group {}.&quot;.format(
            &quot;, &quot;<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#9',2,'match11856-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.join(_list), name
        )
    return ret


def _group_policies_attached(
    name,
    managed_policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    detach_policies=True,
):
    ret =</B></FONT> {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__[&quot;boto_iam.list_entities_for_policy&quot;](
            policy,
            entity_filter=&quot;Group&quot;,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for groupdict in entities.get(&quot;policy_groups&quot;, []):
            if name == groupdict.get(&quot;group_name&quot;):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    for policy_data in _list:
        if (
            detach_policies
            and policy_data.get(&quot;policy_name&quot;) not in managed_policies
            and policy_data.get(&quot;policy_arn&quot;) not in managed_policies
        ):
            policies_to_detach.append(policy_data.get(&quot;policy_arn&quot;))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on group {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__[&quot;boto_iam.attach_group_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__[&quot;boto_iam.detach_group_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to remove policy {} from group {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
        log.debug(newpolicies)
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
        ret[&quot;comment&quot;] = &quot;{} policies modified on group {}.&quot;.format(
            &quot;, &quot;.join(newpolicies), name
        )
    return ret


def _group_policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    if not _list:
        ret[&quot;comment&quot;] = &quot;No attached policies in group {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be detached from group {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__[&quot;boto_iam.detach_group_policy&quot;](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from group {}&quot;.format(
                policy_arn, name
            )
            return ret
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies detached from group {}.&quot;.format(
        &quot;, &quot;.join(newpolicies), name
    )
    return ret


def _group_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    oldpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret[&quot;comment&quot;] = &quot;No inline policies in group {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be deleted from group {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;inline_policies&quot;: oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__[&quot;boto_iam.delete_group_policy&quot;](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from group {}&quot;.format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
<A NAME="6"></A>    ret[&quot;comment&quot;] = &quot;{} policies deleted from group {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
    r<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#6',2,'match11856-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>eturn ret


def account_policy(
    name=None,
    allow_users_to_change_password=None,
    hard_expiry=None,
    max_password_age=None,
    minimum_password_length=None,
    password_reuse_prevention=None,
    require_lowercase_characters=None,
    require_numbers=None,
    require_symbols=None,
    require_uppercase_characters=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Change account policy.

    .. versionadded:: 2015.8.0

    name (string)
        The name of the account policy

    allow_users_to_change_password (bool)
        Allows all IAM users in your account to
        use the AWS Management Console to change their own passwords.

    hard_expiry (bool)
        Prevents IAM users from setting a new password after their
        password has expired.

    max_password_age (int)
        The number of days that an IAM user password is valid.

    minimum_password_length (int)
        The minimum number of characters allowed in an IAM user password.

    password_reuse_prevention (int)
        Specifies the number of previous passwords
        that IAM users are prevented from reusing.

    require_lowercase_characters (bool)
        Specifies whether IAM user passwords
        must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).

    require_numbers (bool)
        Specifies whether IAM user passwords must contain at
        least one numeric character (0 to 9).

    require_symbols (bool)
        Specifies whether IAM user passwords must contain at
        least one of the following non-alphanumeric characters: ! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '

    require_uppercase_characters (bool)
        Specifies whether IAM user passwords must
        contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
    &quot;&quot;&quot;
    config =</B></FONT> locals()
    ret = {&quot;name&quot;: &quot;Account Policy&quot;, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    info = __salt__[&quot;boto_iam.get_account_policy&quot;](region, key, keyid, profile)
    if not info:
        ret[&quot;comment&quot;] = &quot;Account policy is not Enabled.&quot;
        ret[&quot;result&quot;] = False
        return ret
    for key, value in config.items():
        if key in (&quot;region&quot;, &quot;key&quot;, &quot;keyid&quot;, &quot;profile&quot;, &quot;name&quot;):
            continue
        if value is not None and str(info[key]) != str(value).lower():
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;Policy value {} has been set to {}.&quot;.format(value, info[key]),
                ]
            )
            ret[&quot;changes&quot;][key] = str(value).lower()
    if not ret[&quot;changes&quot;]:
        ret[&quot;comment&quot;] = &quot;Account policy is not changed.&quot;
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Account policy is set to be changed.&quot;
        ret[&quot;result&quot;] = None
        return ret
    if __salt__[&quot;boto_iam.update_account_password_policy&quot;](
        allow_users_to_change_password,
        hard_expiry,
        max_password_age,
        minimum_password_length,
        password_reuse_prevention,
        require_lowercase_characters,
        require_numbers,
        require_symbols,
        require_uppercase_characters,
        region,
        key,
        keyid,
        profile,
    ):
        return ret
    ret[&quot;comment&quot;] = &quot;Account policy is not changed.&quot;
    ret[&quot;changes&quot;] = {}
    ret[&quot;result&quot;] = False
    return ret


def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Deletes a server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
        The profile that contains a dict of region, key, keyid
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_iam.get_server_certificate&quot;](
<A NAME="0"></A>        name, region, key, keyid, profile
    )
    if not exists:
        ret<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#0',2,'match11856-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;comment&quot;] = &quot;Certificate {} does not exist.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Server certificate {} is set to be deleted.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_server_cert&quot;](name, region, key, keyid, profile)
    if not deleted:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Certificate {} failed to be deleted.&quot;.format(name)
        return ret
    ret[</B></FONT>&quot;comment&quot;] = &quot;Certificate {} was deleted.&quot;.format(name)
    ret[&quot;changes&quot;] = deleted
    return ret


def server_cert_present(
    name,
    public_key,
    private_key,
    cert_chain=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Crete server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    public_key (string)
        The contents of the public key certificate in PEM-encoded format.

    private_key (string)
        The contents of the private key in PEM-encoded format.

    cert_chain (string)
        The contents of the certificate chain. This is typically a
        concatenation of the PEM-encoded public key certificates of the chain.

    path (string)
        The path for the server certificate.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
        The profile that contains a dict of region, key, keyid
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_iam.get_server_certificate&quot;](
        name, region, key, keyid, profile
    )
    log.debug(&quot;Variables are : %s.&quot;, locals())
    if exists:
        ret[&quot;comment&quot;] = &quot;Certificate {} exists.&quot;.format(name)
        return ret
    if &quot;salt://&quot; in public_key:
        try:
            public_key = __salt__[&quot;cp.get_file_str&quot;](public_key)
        except OSError as e:
            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(public_key)
            ret[&quot;result&quot;] = False
            return ret
    if &quot;salt://&quot; in private_key:
        try:
            private_key = __salt__[&quot;cp.get_file_str&quot;](private_key)
        except OSError as e:
            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(private_key)
            ret[&quot;result&quot;] = False
            return ret
    if cert_chain is not None and &quot;salt://&quot; in cert_chain:
        try:
            cert_chain = __salt__[&quot;cp.get_file_str&quot;](cert_chain)
        except OSError as e:
<A NAME="3"></A>            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(cert_chain)
            ret[&quot;result&quot;] = False
            <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#3',2,'match11856-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Server certificate {} is set to be created.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    created = __salt__[&quot;boto_iam.upload_server_cert&quot;](
        name, public_key, private_key, cert_chain, path, region, key, keyid, profile
    )
    if created is not False:
        ret[&quot;comment&quot;] = &quot;Certificate {} was created.&quot;.format(name)
        ret[</B></FONT>&quot;changes&quot;] = created
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;Certificate {} failed to be created.&quot;.format(name)
    return ret


def policy_present(
<A NAME="1"></A>    name,
    policy_document,
    path=None,
    description<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#1',2,'match11856-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy is present

    name (string)
        The name of the new policy.

    policy_document (dict)
        The document of the new policy

    path (string)
        The path in which the policy will be created. Default is '/'.

    description (string)
        Description

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policy = __salt__[&quot;boto_iam.get_policy&quot;](name, region, key, keyid, profile)
    if not policy:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM policy {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_iam.create_policy&quot;](
            name, policy_document, path, description, region, key, keyid, profile
        )
        if created:
            ret[&quot;changes&quot;][&quot;policy&quot;] = created
            ret[</B></FONT>&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Policy {} has been created.&quot;.format(name)]
            )
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to update policy.&quot;
            ret[&quot;changes&quot;] = {}
            return ret
    else:
        policy = policy.get(&quot;policy&quot;, {})
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Policy {} is present.&quot;.format(name)]
        )
        _describe = __salt__[&quot;boto_iam.get_policy_version&quot;](
            name, policy.get(&quot;default_version_id&quot;), region, key, keyid, profile
        ).get(&quot;policy_version&quot;, {})
        if isinstance(_describe[&quot;document&quot;], str):
            describeDict = salt.utils.json.loads(_describe[&quot;document&quot;])
        else:
            describeDict = _describe[&quot;document&quot;]

        if isinstance(policy_document, str):
            policy_document = salt.utils.json.loads(policy_document)

        r = salt.utils.data.compare_dicts(describeDict, policy_document)

        if bool(r):
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;Policy {} set to be modified.&quot;.format(name)
                ret[&quot;result&quot;] = None
                return ret

            ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Policy to be modified&quot;])
            policy_document = salt.utils.json.dumps(policy_document)

            r = __salt__[&quot;boto_iam.create_policy_version&quot;](
                policy_name=name,
                policy_document=policy_document,
                set_as_default=True,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r.get(&quot;created&quot;):
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to update policy: {}.&quot;.format(
                    r[&quot;error&quot;][&quot;message&quot;]
                )
                ret[&quot;changes&quot;] = {}
                return ret

            __salt__[&quot;boto_iam.delete_policy_version&quot;](
                policy_name=name,
                version_id=policy[&quot;default_version_id&quot;],
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )

            ret[&quot;changes&quot;].setdefault(&quot;new&quot;, {})[&quot;document&quot;] = policy_document
            ret[&quot;changes&quot;].setdefault(&quot;old&quot;, {})[&quot;document&quot;] = _describe[&quot;document&quot;]
    return ret


def policy_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy with the specified name is absent

    name (string)
        The name of the new policy.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    r = __salt__[&quot;boto_iam.policy_exists&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r:
        ret[&quot;comment&quot;] = &quot;Policy {} does not exist.&quot;.format(name)
        return ret

    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Policy {} is set to be removed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    # delete non-default versions
    versions = __salt__[&quot;boto_iam.list_policy_versions&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if versions:
        for version in versions:
            if version.get(&quot;is_default_version&quot;, False) in (&quot;true&quot;, True):
                continue
            r = __salt__[&quot;boto_iam.delete_policy_version&quot;](
                name,
                version_id=version.get(&quot;version_id&quot;),
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r:
                ret[&quot;result&quot;] = False
<A NAME="5"></A>                ret[&quot;comment&quot;] = &quot;Failed to delete policy {}.&quot;.format(name)
                return ret
    r = __salt__[&quot;boto_iam.delete_policy&quot;](
        name, region=region, key<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match11856-0.html#5',2,'match11856-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=key, keyid=keyid, profile=profile
    )
    if not r:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to delete policy {}.&quot;.format(name)
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policy&quot;: name}
    ret[</B></FONT>&quot;changes&quot;][&quot;new&quot;] = {&quot;policy&quot;: None}
    ret[&quot;comment&quot;] = &quot;Policy {} deleted.&quot;.format(name)
    return ret


def saml_provider_present(
    name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is present.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if &quot;salt://&quot; in saml_metadata_document:
        try:
            saml_metadata_document = __salt__[&quot;cp.get_file_str&quot;](saml_metadata_document)
            ET.fromstring(saml_metadata_document)
        except OSError as e:
            log.debug(e)
            ret[
                &quot;comment&quot;
            ] = &quot;SAML document file {} not found or could not be loaded&quot;.format(name)
            ret[&quot;result&quot;] = False
            return ret
    for provider in __salt__[&quot;boto_iam.list_saml_providers&quot;](
        region=region, key=key, keyid=keyid, profile=profile
    ):
        if provider == name:
            ret[&quot;comment&quot;] = &quot;SAML provider {} is present.&quot;.format(name)
            return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is set to be create.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    created = __salt__[&quot;boto_iam.create_saml_provider&quot;](
        name,
        saml_metadata_document,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if created:
        ret[&quot;comment&quot;] = &quot;SAML provider {} was created.&quot;.format(name)
        ret[&quot;changes&quot;][&quot;new&quot;] = name
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;SAML provider {} failed to be created.&quot;.format(name)
    return ret


def saml_provider_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is absent.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    provider = __salt__[&quot;boto_iam.list_saml_providers&quot;](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if len(provider) == 0:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is absent.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is set to be removed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_saml_provider&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if deleted is not False:
        ret[&quot;comment&quot;] = &quot;SAML provider {} was deleted.&quot;.format(name)
        ret[&quot;changes&quot;][&quot;old&quot;] = name
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;SAML provider {} failed to be deleted.&quot;.format(name)
    return ret


def _get_error(error):
    # Converts boto exception to string that can be used to output error.
    error = &quot;\n&quot;.join(error.split(&quot;\n&quot;)[1:])
    error = ET.fromstring(error)
    code = error[0][1].text
    message = error[0][2].text
    return code, message
</PRE>
</div>
  </div>
</body>
</html>
