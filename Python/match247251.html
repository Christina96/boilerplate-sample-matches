<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_payload_1.py &amp; win_task.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_payload_1.py &amp; win_task.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_payload_1.py (3.9473684%)<th>win_task.py (0.65970314%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(170-173)<td><a href="#" name="0">(357-362)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_payload_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import logging
4 import salt.exceptions
5 import salt.payload
6 from salt.utils import immutabletypes
7 from salt.utils.odict import OrderedDict
8 log = logging.getLogger(__name__)
9 def assert_no_ordered_dict(data):
10     if isinstance(data, OrderedDict):
11         raise AssertionError("Found an ordered dictionary")
12     if isinstance(data, dict):
13         for value in data.values():
14             assert_no_ordered_dict(value)
15     elif isinstance(data, (list, tuple)):
16         for chunk in data:
17             assert_no_ordered_dict(chunk)
18 def test_list_nested_odicts():
19     idata = {"pillar": [OrderedDict(environment="dev")]}
20     odata = salt.payload.loads(salt.payload.dumps(idata.copy()))
21     assert_no_ordered_dict(odata)
22     assert idata == odata
23 def test_datetime_dump_load():
24     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
25     idata = {dtvalue: dtvalue}
26     sdata = salt.payload.dumps(idata.copy())
27     odata = salt.payload.loads(sdata)
28     assert (
29         sdata
30         == b"\x81\xc7\x18N20010203T04:05:06.000007\xc7\x18N20010203T04:05:06.000007"
31     )
32     assert idata == odata
33 def test_verylong_dump_load():
34     idata = {"jid": 20180227140750302662}
35     sdata = salt.payload.dumps(idata.copy())
36     odata = salt.payload.loads(sdata)
37     idata["jid"] = "{}".format(idata["jid"])
38     assert idata == odata
39 def test_immutable_dict_dump_load():
40     idata = {"dict": {"key": "value"}}
41     sdata = salt.payload.dumps({"dict": immutabletypes.ImmutableDict(idata["dict"])})
42     odata = salt.payload.loads(sdata)
43     assert idata == odata
44 def test_immutable_list_dump_load():
45     idata = {"list": [1, 2, 3]}
46     sdata = salt.payload.dumps({"list": immutabletypes.ImmutableList(idata["list"])})
47     odata = salt.payload.loads(sdata)
48     assert idata == odata
49 def test_immutable_set_dump_load():
50     idata = {"set": ["red", "green", "blue"]}
51     sdata = salt.payload.dumps({"set": immutabletypes.ImmutableSet(idata["set"])})
52     odata = salt.payload.loads(sdata)
53     assert idata == odata
54 def test_odict_dump_load():
55     data = OrderedDict()
56     data["a"] = "b"
57     data["y"] = "z"
58     data["j"] = "k"
59     data["w"] = "x"
60     sdata = salt.payload.dumps({"set": data})
61     odata = salt.payload.loads(sdata)
62     assert {"set": dict(data)}, odata
63 def test_mixed_dump_load():
64     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
65     od = OrderedDict()
66     od["a"] = "b"
67     od["y"] = "z"
68     od["j"] = "k"
69     od["w"] = "x"
70     idata = {
71         dtvalue: dtvalue,  # datetime
72         "jid": 20180227140750302662,  # long int
73         "dict": immutabletypes.ImmutableDict({"key": "value"}),  # immutable dict
74         "list": immutabletypes.ImmutableList([1, 2, 3]),  # immutable list
75         "set": immutabletypes.ImmutableSet(("red", "green", "blue")),  # immutable set
76         "odict": od,  # odict
77     }
78     edata = {
79         dtvalue: dtvalue,  # datetime, == input
80         "jid": "20180227140750302662",  # string repr of long int
81         "dict": {"key": "value"},  # builtin dict
82         "list": [1, 2, 3],  # builtin list
83         "set": ["red", "green", "blue"],  # builtin set
84         "odict": dict(od),  # builtin dict
85     }
86     sdata = salt.payload.dumps(idata)
87     odata = salt.payload.loads(sdata)
88     assert edata == odata
89 def test_recursive_dump_load():
90     data = {"name": "roscivs"}
91     data["data"] = data  # Data all the things!
92     sdata = salt.payload.dumps(data)
93     odata = salt.payload.loads(sdata)
94     assert "recursion" in odata["data"].lower()
95 def test_recursive_dump_load_with_identical_non_recursive_types():
96     repeating = "repeating element"
97     data = {
98         "a": "a",  # Test CPython implementation detail. Short
99         "b": "a",  # strings are interned.
100         "c": 13,  # So are small numbers.
101         "d": 13,
102         "fnord": repeating,
103         "repeating": [
104             [[[[{"one": repeating, "two": repeating}], repeating, 13, "a"]]],
105             repeating,
106             repeating,
107             repeating,
108     }
109     data["repeating"][0]<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0][0].append(data)
110     sdata = salt.payload.dumps(copy.deepcopy(data))
111     odata = salt.</b></font>payload.loads(sdata)
112     del odata["repeating"][0][0][0][-1], data["repeating"][0][0][0][-1]
113     assert odata == data
114 def test_raw_vs_encoding_none():
115     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
116     idata = {dtvalue: "strval"}
117     sdata = salt.payload.dumps(idata.copy())
118     odata = salt.payload.loads(sdata, encoding=None)
119     assert isinstance(odata[dtvalue], str)
120 def test_raw_vs_encoding_utf8():
121     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
122     idata = {dtvalue: "strval"}
123     sdata = salt.payload.dumps(idata.copy())
124     odata = salt.payload.loads(sdata, encoding="utf-8")
125     assert isinstance(odata[dtvalue], str)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_task.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import time
3 from datetime import datetime
4 import salt.utils.platform
5 import salt.utils.winapi
6 from salt.exceptions import ArgumentValueError, CommandExecutionError
7 try:
8     import pythoncom
9     import win32com.client
10     HAS_DEPENDENCIES = True
11 except ImportError:
12     HAS_DEPENDENCIES = False
13 log = logging.getLogger(__name__)
14 __virtualname__ = "task"
15 TASK_ACTION_EXEC = 0
16 TASK_ACTION_COM_HANDLER = 5
17 TASK_ACTION_SEND_EMAIL = 6
18 TASK_ACTION_SHOW_MESSAGE = 7
19 TASK_COMPATIBILITY_AT = 0
20 TASK_COMPATIBILITY_V1 = 1
21 TASK_COMPATIBILITY_V2 = 2
22 TASK_COMPATIBILITY_V3 = 3
23 TASK_VALIDATE_ONLY = 0x1
24 TASK_CREATE = 0x2
25 TASK_UPDATE = 0x4
26 TASK_CREATE_OR_UPDATE = 0x6
27 TASK_DISABLE = 0x8
28 TASK_DONT_ADD_PRINCIPAL_ACE = 0x10
29 TASK_IGNORE_REGISTRATION_TRIGGERS = 0x20
30 TASK_INSTANCES_PARALLEL = 0
31 TASK_INSTANCES_QUEUE = 1
32 TASK_INSTANCES_IGNORE_NEW = 2
33 TASK_INSTANCES_STOP_EXISTING = 3
34 TASK_LOGON_NONE = 0
35 TASK_LOGON_PASSWORD = 1
36 TASK_LOGON_S4U = 2
37 TASK_LOGON_INTERACTIVE_TOKEN = 3
38 TASK_LOGON_GROUP = 4
39 TASK_LOGON_SERVICE_ACCOUNT = 5
40 TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = 6
41 TASK_RUNLEVEL_LUA = 0
42 TASK_RUNLEVEL_HIGHEST = 1
43 TASK_STATE_UNKNOWN = 0
44 TASK_STATE_DISABLED = 1
45 TASK_STATE_QUEUED = 2
46 TASK_STATE_READY = 3
47 TASK_STATE_RUNNING = 4
48 TASK_TRIGGER_EVENT = 0
49 TASK_TRIGGER_TIME = 1
50 TASK_TRIGGER_DAILY = 2
51 TASK_TRIGGER_WEEKLY = 3
52 TASK_TRIGGER_MONTHLY = 4
53 TASK_TRIGGER_MONTHLYDOW = 5
54 TASK_TRIGGER_IDLE = 6
55 TASK_TRIGGER_REGISTRATION = 7
56 TASK_TRIGGER_BOOT = 8
57 TASK_TRIGGER_LOGON = 9
58 TASK_TRIGGER_SESSION_STATE_CHANGE = 11
59 duration = {
60     "Immediately": "PT0M",
61     "Indefinitely": "",
62     "Do not wait": "PT0M",
63     "15 seconds": "PT15S",
64     "30 seconds": "PT30S",
65     "1 minute": "PT1M",
66     "5 minutes": "PT5M",
67     "10 minutes": "PT10M",
68     "15 minutes": "PT15M",
69     "30 minutes": "PT30M",
70     "1 hour": "PT1H",
71     "2 hours": "PT2H",
72     "4 hours": "PT4H",
73     "8 hours": "PT8H",
74     "12 hours": "PT12H",
75     "1 day": ["P1D", "PT24H"],
76     "3 days": ["P3D", "PT72H"],
77     "30 days": "P30D",
78     "90 days": "P90D",
79     "180 days": "P180D",
80     "365 days": "P365D",
81 }
82 action_types = {
83     "Execute": TASK_ACTION_EXEC,
84     "Email": TASK_ACTION_SEND_EMAIL,
85     "Message": TASK_ACTION_SHOW_MESSAGE,
86 }
87 trigger_types = {
88     "Event": TASK_TRIGGER_EVENT,
89     "Once": TASK_TRIGGER_TIME,
90     "Daily": TASK_TRIGGER_DAILY,
91     "Weekly": TASK_TRIGGER_WEEKLY,
92     "Monthly": TASK_TRIGGER_MONTHLY,
93     "MonthlyDay": TASK_TRIGGER_MONTHLYDOW,
94     "OnIdle": TASK_TRIGGER_IDLE,
95     "OnTaskCreation": TASK_TRIGGER_REGISTRATION,
96     "OnBoot": TASK_TRIGGER_BOOT,
97     "OnLogon": TASK_TRIGGER_LOGON,
98     "OnSessionChange": TASK_TRIGGER_SESSION_STATE_CHANGE,
99 }
100 states = {
101     TASK_STATE_UNKNOWN: "Unknown",
102     TASK_STATE_DISABLED: "Disabled",
103     TASK_STATE_QUEUED: "Queued",
104     TASK_STATE_READY: "Ready",
105     TASK_STATE_RUNNING: "Running",
106 }
107 instances = {
108     "Parallel": TASK_INSTANCES_PARALLEL,
109     "Queue": TASK_INSTANCES_QUEUE,
110     "No New Instance": TASK_INSTANCES_IGNORE_NEW,
111     "Stop Existing": TASK_INSTANCES_STOP_EXISTING,
112 }
113 results = {
114     0x0: "The operation completed successfully",
115     0x1: "Incorrect or unknown function called",
116     0x2: "File not found",
117     0xA: "The environment is incorrect",
118     0x41300: "Task is ready to run at its next scheduled time",
119     0x41301: "Task is currently running",
120     0x41302: "Task is disabled",
121     0x41303: "Task has not yet run",
122     0x41304: "There are no more runs scheduled for this task",
123     0x41306: "Task was terminated by the user",
124     0x8004130F: "Credentials became corrupted",
125     0x8004131F: "An instance of this task is already running",
126     0x800710E0: "The operator or administrator has refused the request",
127     0x800704DD: "The service is not available (Run only when logged in?)",
128     0xC000013A: "The application terminated as a result of CTRL+C",
129     0xC06D007E: "Unknown software exception",
130 }
131 def __virtual__():
132     if salt.utils.platform.is_windows():
133         if not HAS_DEPENDENCIES:
134             log.warning("Could not load dependencies for %s", __virtualname__)
135         return __virtualname__
136     return False, "Module win_task: module only works on Windows systems"
137 def _get_date_time_format(dt_string):
138     valid_formats = [
139         "%I:%M:%S %p",
140         "%I:%M %p",
141         "%H:%M:%S",
142         "%H:%M",
143         "%Y-%m-%d",
144         "%m-%d-%y",
145         "%m-%d-%Y",
146         "%m/%d/%y",
147         "%m/%d/%Y",
148         "%Y/%m/%d",
149     ]
150     for dt_format in valid_formats:
151         try:
152             datetime.strptime(dt_string, dt_format)
153             return dt_format
154         except ValueError:
155             continue
156     return False
157 def _get_date_value(date):
158     try:
159         return "{}".format(date)
160     except ValueError:
161         return "Never"
162 def _reverse_lookup(dictionary, value):
163     value_index = -1
164     for idx, dict_value in enumerate(dictionary.values()):
165         if type(dict_value) == list:
166             if value in dict_value:
167                 value_index = idx
168                 break
169         elif value == dict_value:
170             value_index = idx
171             break
172     return list(dictionary)[value_index]
173 def _lookup_first(dictionary, key):
174     value = dictionary[key]
175     if type(value) == list:
176         return value[0]
177     else:
178         return value
179 def _save_task_definition(
180     name, task_folder, task_definition, user_name, password, logon_type
181 ):
182     try:
183         task_folder.RegisterTaskDefinition(
184             name,
185             task_definition,
186             TASK_CREATE_OR_UPDATE,
187             user_name,
188             password,
189             logon_type,
190         )
191         return True
192     except pythoncom.com_error as error:
193         hr, msg, exc, arg = error.args  # pylint: disable=W0633
194         fc = {
195             -2147024773: (
196                 "The filename, directory name, or volume label syntax is incorrect"
197             ),
198             -2147024894: "The system cannot find the file specified",
199             -2147216615: "Required element or attribute missing",
200             -2147216616: "Value incorrectly formatted or out of range",
201             -2147352571: "Access denied",
202         }
203         try:
204             failure_code = fc[exc[5]]
205         except KeyError:
206             failure_code = "Unknown Failure: {}".format(error)
207         log.debug("Failed to modify task: %s", failure_code)
208         return "Failed to modify task: {}".format(failure_code)
209 def list_tasks(location="\\"):
210     r"""
211     List all tasks located in a specific location in the task scheduler.
212     Args:
213         location (str):
214             A string value representing the folder from which you want to list
215             tasks. Default is ``\`` which is the root for the task scheduler
216             (``C:\Windows\System32\tasks``).
217     Returns:
218         list: Returns a list of tasks
219     CLI Example:
220     .. code-block:: bash
221         salt 'minion-id' task.list_tasks
222     """
223     with salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.winapi.Com():
224         task_service = win32com.client.Dispatch("Schedule.Service")
225         task_service.Connect()
226         task_folder = task_service.</b></font>GetFolder(location)
227         tasks = task_folder.GetTasks(0)
228         ret = []
229         for task in tasks:
230             ret.append(task.Name)
231     return ret
232 def list_folders(location="\\"):
233     r"""
234     List all folders located in a specific location in the task scheduler.
235     Args:
236         location (str):
237             A string value representing the folder from which you want to list
238             tasks. Default is ``\`` which is the root for the task scheduler
239             (``C:\Windows\System32\tasks``).
240     Returns:
241         list: Returns a list of folders.
242     CLI Example:
243     .. code-block:: bash
244         salt 'minion-id' task.list_folders
245         salt 'minion-id' task.list_folders Microsoft
246     """
247     with salt.utils.winapi.Com():
248         task_service = win32com.client.Dispatch("Schedule.Service")
249         task_service.Connect()
250         task_folder = task_service.GetFolder(location)
251         folders = task_folder.GetFolders(0)
252         ret = []
253         for folder in folders:
254             ret.append(folder.Name)
255     return ret
256 def list_triggers(name, location="\\"):
257     r"""
258     List all triggers that pertain to a task in the specified location.
259     Args:
260         name (str):
261             The name of the task for which list triggers.
262         location (str):
263             A string value representing the location of the task from which to
264             list triggers. Default is ``\`` which is the root for the task
265             scheduler (``C:\Windows\System32\tasks``).
266     Returns:
267         list: Returns a list of triggers.
268     CLI Example:
269     .. code-block:: bash
270         salt 'minion-id' task.list_triggers &lt;task_name&gt;
271         salt '*' task.list_triggers XblGameSaveTask Microsoft\XblGameSave
272     """
273     with salt.utils.winapi.Com():
274         task_service = win32com.client.Dispatch("Schedule.Service")
275         task_service.Connect()
276         task_folder = task_service.GetFolder(location)
277         task_definition = task_folder.GetTask(name).Definition
278         triggers = task_definition.Triggers
279         ret = []
280         for trigger in triggers:
281             ret.append(trigger.Id)
282     return ret
283 def list_actions(name, location="\\"):
284     r"""
285     List all actions that pertain to a task in the specified location.
286     Args:
287         name (str):
288             The name of the task for which list actions.
289         location (str):
290             A string value representing the location of the task from which to
291             list actions. Default is ``\`` which is the root for the task
292             scheduler (``C:\Windows\System32\tasks``).
293     Returns:
294         list: Returns a list of actions.
295     CLI Example:
296     .. code-block:: bash
297         salt 'minion-id' task.list_actions &lt;task_name&gt;
298         salt 'minion-id' task.list_actions XblGameSaveTask Microsoft\XblGameSave
299     """
300     with salt.utils.winapi.Com():
301         task_service = win32com.client.Dispatch("Schedule.Service")
302         task_service.Connect()
303         task_folder = task_service.GetFolder(location)
304         task_definition = task_folder.GetTask(name).Definition
305         actions = task_definition.Actions
306         ret = []
307         for action in actions:
308             ret.append(action.Id)
309     return ret
310 def create_task(
311     name, location="\\", user_name="System", password=None, force=False, **kwargs
312 ):
313     r"""
314     Create a new task in the designated location. This function has many keyword
315     arguments that are not listed here. For additional arguments see:
316         - :py:func:`edit_task`
317         - :py:func:`add_action`
318         - :py:func:`add_trigger`
319     Args:
320         name (str):
321             The name of the task. This will be displayed in the task scheduler.
322         location (str):
323             A string value representing the location in which to create the
324             task. Default is ``\`` which is the root for the task scheduler
325             (``C:\Windows\System32\tasks``).
326         user_name (str):
327             The user account under which to run the task. To specify the
328             'System' account, use 'System'. The password will be ignored.
329         password (str):
330             The password to use for authentication. This should set the task to
331             run whether the user is logged in or not, but is currently not
332             working.
333         force (bool):
334             If the task exists, overwrite the existing task.
335     Returns:
336         bool: ``True`` if successful, otherwise ``False``
337     CLI Example:
338     .. code-block:: bash
339         salt 'minion-id' task.create_task &lt;task_name&gt; user_name=System force=True action_type=Execute cmd='del /Q /S C:\\Temp' trigger_type=Once start_date=2016-12-1 start_time=01:00
340     """
341     if name in list_tasks(location) and not force:
342         return "{} already exists".format(name)
343     with salt.utils.winapi.Com():
344         task_service = win32com.client.Dispatch("Schedule.Service")
345         task_service.Connect()
346         task_definition = task_service.NewTask(0)
347         edit_task(
348             task_definition=task_definition,
349             user_name=user_name,
350             password=password,
351             **kwargs
352         )
353         add_action(task_definition=task_definition, **kwargs)
354         add_trigger(task_definition=task_definition, **kwargs)
355         task_folder = task_service.GetFolder(location)
356         _save_task_definition(
357             name=name,
358             task_folder=task_folder,
359             task_definition=task_definition,
360             user_name=task_definition.Principal.UserID,
361             password=password,
362             logon_type=task_definition.Principal.LogonType,
363         )
364     return name in list_tasks(location)
365 def create_task_from_xml(
366     name, location="\\", xml_text=None, xml_path=None, user_name="System", password=None
367 ):
368     r"""
369     Create a task based on XML. Source can be a file or a string of XML.
370     Args:
371         name (str):
372             The name of the task. This will be displayed in the task scheduler.
373         location (str):
374             A string value representing the location in which to create the
375             task. Default is ``\`` which is the root for the task scheduler
376             (``C:\Windows\System32\tasks``).
377         xml_text (str):
378             A string of xml representing the task to be created. This will be
379             overridden by ``xml_path`` if passed.
380         xml_path (str):
381             The path to an XML file on the local system containing the xml that
382             defines the task. This will override ``xml_text``
383         user_name (str):
384             The user account under which to run the task. To specify the
385             'System' account, use 'System'. The password will be ignored.
386         password (str):
387             The password to use for authentication. This should set the task to
388             run whether the user is logged in or not, but is currently not
389             working.
390     Returns:
391         bool: ``True`` if successful, otherwise ``False``
392         str: A string with the error message if there is an error
393     Raises:
394         ArgumentValueError: If arguments are invalid
395         CommandExecutionError
396     CLI Example:
397     .. code-block:: bash
398         salt '*' task.create_task_from_xml &lt;task_name&gt; xml_path=C:\task.xml
399     """
400     if name in list_tasks(location):
401         return "{} already exists".format(name)
402     if not xml_text and not xml_path:
403         raise ArgumentValueError("Must specify either xml_text or xml_path")
404     with salt.utils.winapi.Com():
405         task_service = win32com.client.Dispatch("Schedule.Service")
406         task_service.Connect()
407         if xml_path:
408             xml_text = xml_path
409         task_folder = task_service.GetFolder(location)
410         if user_name:
411             if user_name.lower() == "system":
412                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
413                 user_name = "SYSTEM"
414                 password = None
415             else:
416                 if password:
417                     logon_type = TASK_LOGON_PASSWORD
418                 else:
419                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
420         else:
421             password = None
422             logon_type = TASK_LOGON_NONE
423         try:
424             task_folder.RegisterTask(
425                 name, xml_text, TASK_CREATE, user_name, password, logon_type
426             )
427         except pythoncom.com_error as error:
428             hr, msg, exc, arg = error.args  # pylint: disable=W0633
429             error_code = hex(exc[5] + 2 ** 32)
430             fc = {
431                 0x80041319: "Required element or attribute missing",
432                 0x80041318: "Value incorrectly formatted or out of range",
433                 0x80020005: "Access denied",
434                 0x80041309: "A task's trigger is not found",
435                 0x8004130A: (
436                     "One or more of the properties required to run this "
437                     "task have not been set"
438                 ),
439                 0x8004130C: (
440                     "The Task Scheduler service is not installed on this computer"
441                 ),
442                 0x8004130D: "The task object could not be opened",
443                 0x8004130E: (
444                     "The object is either an invalid task object or is not "
445                     "a task object"
446                 ),
447                 0x8004130F: (
448                     "No account information could be found in the Task "
449                     "Scheduler security database for the task indicated"
450                 ),
451                 0x80041310: "Unable to establish existence of the account specified",
452                 0x80041311: (
453                     "Corruption was detected in the Task Scheduler "
454                     "security database; the database has been reset"
455                 ),
456                 0x80041313: "The task object version is either unsupported or invalid",
457                 0x80041314: (
458                     "The task has been configured with an unsupported "
459                     "combination of account settings and run time options"
460                 ),
461                 0x80041315: "The Task Scheduler Service is not running",
462                 0x80041316: "The task XML contains an unexpected node",
463                 0x80041317: (
464                     "The task XML contains an element or attribute from an "
465                     "unexpected namespace"
466                 ),
467                 0x8004131A: "The task XML is malformed",
468                 0x0004131C: (
469                     "The task is registered, but may fail to start. Batch "
470                     "logon privilege needs to be enabled for the task principal"
471                 ),
472                 0x8004131D: "The task XML contains too many nodes of the same type",
473             }
474             try:
475                 failure_code = fc[error_code]
476             except KeyError:
477                 failure_code = "Unknown Failure: {}".format(error_code)
478             finally:
479                 log.debug("Failed to create task: %s", failure_code)
480             raise CommandExecutionError(failure_code)
481     return name in list_tasks(location)
482 def create_folder(name, location="\\"):
483     r"""
484     Create a folder in which to create tasks.
485     Args:
486         name (str):
487             The name of the folder. This will be displayed in the task
488             scheduler.
489         location (str):
490             A string value representing the location in which to create the
491             folder. Default is ``\`` which is the root for the task scheduler
492             (``C:\Windows\System32\tasks``).
493     Returns:
494         bool: ``True`` if successful, otherwise ``False``
495     CLI Example:
496     .. code-block:: bash
497         salt 'minion-id' task.create_folder &lt;folder_name&gt;
498     """
499     if name in list_folders(location):
500         return "{} already exists".format(name)
501     with salt.utils.winapi.Com():
502         task_service = win32com.client.Dispatch("Schedule.Service")
503         task_service.Connect()
504         task_folder = task_service.GetFolder(location)
505         task_folder.CreateFolder(name)
506     return name in list_folders(location)
507 def edit_task(
508     name=None,
509     location="\\",
510     user_name=None,
511     password=None,
512     description=None,
513     enabled=None,
514     hidden=None,
515     run_if_idle=None,
516     idle_duration=None,
517     idle_wait_timeout=None,
518     idle_stop_on_end=None,
519     idle_restart=None,
520     ac_only=None,
521     stop_if_on_batteries=None,
522     wake_to_run=None,
523     run_if_network=None,
524     network_id=None,
525     network_name=None,
526     allow_demand_start=None,
527     start_when_available=None,
528     restart_every=None,
529     restart_count=3,
530     execution_time_limit=None,
531     force_stop=None,
532     delete_after=None,
533     multiple_instances=None,
534     **kwargs
535 ):
536     r"""
537     Edit the parameters of a task. Triggers and Actions cannot be edited yet.
538     Args:
539         name (str):
540             The name of the task. This will be displayed in the task scheduler.
541         location (str):
542             A string value representing the location in which to create the
543             task. Default is ``\`` which is the root for the task scheduler
544             (``C:\Windows\System32\tasks``).
545         user_name (str):
546             The user account under which to run the task. To specify the
547             'System' account, use 'System'. The password will be ignored.
548         password (str):
549             The password to use for authentication. This should set the task to
550             run whether the user is logged in or not, but is currently not
551             working.
552             .. note::
553                 The combination of user_name and password determine how the
554                 task runs. For example, if a username is passed without at
555                 password the task will only run when the user is logged in. If a
556                 password is passed as well the task will run whether the user is
557                 logged on or not. If you pass 'System' as the username the task
558                 will run as the system account (the password parameter is
559                 ignored).
560         description (str):
561             A string representing the text that will be displayed in the
562             description field in the task scheduler.
563         enabled (bool):
564             A boolean value representing whether or not the task is enabled.
565         hidden (bool):
566             A boolean value representing whether or not the task is hidden.
567         run_if_idle (bool):
568             Boolean value that indicates that the Task Scheduler will run the
569             task only if the computer is in an idle state.
570         idle_duration (str):
571             A value that indicates the amount of time that the computer must be
572             in an idle state before the task is run. Valid values are:
573                 - 1 minute
574                 - 5 minutes
575                 - 10 minutes
576                 - 15 minutes
577                 - 30 minutes
578                 - 1 hour
579         idle_wait_timeout (str):
580             A value that indicates the amount of time that the Task Scheduler
581             will wait for an idle condition to occur. Valid values are:
582                 - Do not wait
583                 - 1 minute
584                 - 5 minutes
585                 - 10 minutes
586                 - 15 minutes
587                 - 30 minutes
588                 - 1 hour
589                 - 2 hours
590         idle_stop_on_end (bool):
591             Boolean value that indicates that the Task Scheduler will terminate
592             the task if the idle condition ends before the task is completed.
593         idle_restart (bool):
594             Boolean value that indicates whether the task is restarted when the
595             computer cycles into an idle condition more than once.
596         ac_only (bool):
597             Boolean value that indicates that the Task Scheduler will launch the
598             task only while on AC power.
599         stop_if_on_batteries (bool):
600             Boolean value that indicates that the task will be stopped if the
601             computer begins to run on battery power.
602         wake_to_run (bool):
603             Boolean value that indicates that the Task Scheduler will wake the
604             computer when it is time to run the task.
605         run_if_network (bool):
606             Boolean value that indicates that the Task Scheduler will run the
607             task only when a network is available.
608         network_id (guid):
609             GUID value that identifies a network profile.
610         network_name (str):
611             Sets the name of a network profile. The name is used for display
612             purposes.
613         allow_demand_start (bool):
614             Boolean value that indicates that the task can be started by using
615             either the Run command or the Context menu.
616         start_when_available (bool):
617             Boolean value that indicates that the Task Scheduler can start the
618             task at any time after its scheduled time has passed.
619         restart_every (str):
620             A value that specifies the interval between task restart attempts.
621             Valid values are:
622                 - False (to disable)
623                 - 1 minute
624                 - 5 minutes
625                 - 10 minutes
626                 - 15 minutes
627                 - 30 minutes
628                 - 1 hour
629                 - 2 hours
630         restart_count (int):
631             The number of times the Task Scheduler will attempt to restart the
632             task. Valid values are integers 1 - 999.
633         execution_time_limit (bool, str):
634             The amount of time allowed to complete the task. Valid values are:
635                 - False (to disable)
636                 - 1 hour
637                 - 2 hours
638                 - 4 hours
639                 - 8 hours
640                 - 12 hours
641                 - 1 day
642                 - 3 days
643         force_stop (bool):
644             Boolean value that indicates that the task may be terminated by
645             using TerminateProcess.
646         delete_after (bool, str):
647             The amount of time that the Task Scheduler will wait before deleting
648             the task after it expires. Requires a trigger with an expiration
649             date. Valid values are:
650                 - False (to disable)
651                 - Immediately
652                 - 30 days
653                 - 90 days
654                 - 180 days
655                 - 365 days
656         multiple_instances (str):
657             Sets the policy that defines how the Task Scheduler deals with
658             multiple instances of the task. Valid values are:
659                 - Parallel
660                 - Queue
661                 - No New Instance
662                 - Stop Existing
663     Returns:
664         bool: ``True`` if successful, otherwise ``False``
665     CLI Example:
666     .. code-block:: bash
667         salt '*' task.edit_task &lt;task_name&gt; description='This task is awesome'
668     """
669     with salt.utils.winapi.Com():
670         save_definition = False
671         if kwargs.get("task_definition", False):
672             task_definition = kwargs.get("task_definition")
673         else:
674             save_definition = True
675             if not name:
676                 return 'Required parameter "name" not passed'
677             if name in list_tasks(location):
678                 task_service = win32com.client.Dispatch("Schedule.Service")
679                 task_service.Connect()
680                 task_folder = task_service.GetFolder(location)
681                 task_definition = task_folder.GetTask(name).Definition
682             else:
683                 return "{} not found".format(name)
684         if save_definition:
685             task_definition.RegistrationInfo.Author = "Salt Minion"
686             task_definition.RegistrationInfo.Source = "Salt Minion Daemon"
687         if description is not None:
688             task_definition.RegistrationInfo.Description = description
689         if user_name:
690             if user_name.lower() == "system":
691                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
692                 user_name = "SYSTEM"
693                 password = None
694             else:
695                 task_definition.Principal.Id = user_name
696                 if password:
697                     logon_type = TASK_LOGON_PASSWORD
698                 else:
699                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
700             task_definition.Principal.UserID = user_name
701             task_definition.Principal.DisplayName = user_name
702             task_definition.Principal.LogonType = logon_type
703             task_definition.Principal.RunLevel = TASK_RUNLEVEL_HIGHEST
704         else:
705             user_name = None
706             password = None
707         if enabled is not None:
708             task_definition.Settings.Enabled = enabled
709         if hidden is not None:
710             task_definition.Settings.Hidden = hidden
711         if run_if_idle is not None:
712             task_definition.Settings.RunOnlyIfIdle = run_if_idle
713         if task_definition.Settings.RunOnlyIfIdle:
714             if idle_stop_on_end is not None:
715                 task_definition.Settings.IdleSettings.StopOnIdleEnd = idle_stop_on_end
716             if idle_restart is not None:
717                 task_definition.Settings.IdleSettings.RestartOnIdle = idle_restart
718             if idle_duration is not None:
719                 if idle_duration in duration:
720                     task_definition.Settings.IdleSettings.IdleDuration = _lookup_first(
721                         duration, idle_duration
722                     )
723                 else:
724                     return 'Invalid value for "idle_duration"'
725             if idle_wait_timeout is not None:
726                 if idle_wait_timeout in duration:
727                     task_definition.Settings.IdleSettings.WaitTimeout = _lookup_first(
728                         duration, idle_wait_timeout
729                     )
730                 else:
731                     return 'Invalid value for "idle_wait_timeout"'
732         if ac_only is not None:
733             task_definition.Settings.DisallowStartIfOnBatteries = ac_only
734         if stop_if_on_batteries is not None:
735             task_definition.Settings.StopIfGoingOnBatteries = stop_if_on_batteries
736         if wake_to_run is not None:
737             task_definition.Settings.WakeToRun = wake_to_run
738         if run_if_network is not None:
739             task_definition.Settings.RunOnlyIfNetworkAvailable = run_if_network
740         if task_definition.Settings.RunOnlyIfNetworkAvailable:
741             if network_id:
742                 task_definition.Settings.NetworkSettings.Id = network_id
743             if network_name:
744                 task_definition.Settings.NetworkSettings.Name = network_name
745         if allow_demand_start is not None:
746             task_definition.Settings.AllowDemandStart = allow_demand_start
747         if start_when_available is not None:
748             task_definition.Settings.StartWhenAvailable = start_when_available
749         if restart_every is not None:
750             if restart_every is False:
751                 task_definition.Settings.RestartInterval = ""
752             else:
753                 if restart_every in duration:
754                     task_definition.Settings.RestartInterval = _lookup_first(
755                         duration, restart_every
756                     )
757                 else:
758                     return 'Invalid value for "restart_every"'
759         if task_definition.Settings.RestartInterval:
760             if restart_count is not None:
761                 if restart_count in range(1, 999):
762                     task_definition.Settings.RestartCount = restart_count
763                 else:
764                     return '"restart_count" must be a value between 1 and 999'
765         if execution_time_limit is not None:
766             if execution_time_limit is False:
767                 task_definition.Settings.ExecutionTimeLimit = "PT0S"
768             else:
769                 if execution_time_limit in duration:
770                     task_definition.Settings.ExecutionTimeLimit = _lookup_first(
771                         duration, execution_time_limit
772                     )
773                 else:
774                     return 'Invalid value for "execution_time_limit"'
775         if force_stop is not None:
776             task_definition.Settings.AllowHardTerminate = force_stop
777         if delete_after is not None:
778             if delete_after is False:
779                 task_definition.Settings.DeleteExpiredTaskAfter = ""
780             if delete_after in duration:
781                 task_definition.Settings.DeleteExpiredTaskAfter = _lookup_first(
782                     duration, delete_after
783                 )
784             else:
785                 return 'Invalid value for "delete_after"'
786         if multiple_instances is not None:
787             task_definition.Settings.MultipleInstances = instances[multiple_instances]
788         if save_definition:
789             return _save_task_definition(
790                 name=name,
791                 task_folder=task_folder,
792                 task_definition=task_definition,
793                 user_name=user_name,
794                 password=password,
795                 logon_type=task_definition.Principal.LogonType,
796             )
797 def delete_task(name, location="\\"):
798     r"""
799     Delete a task from the task scheduler.
800     Args:
801         name (str):
802             The name of the task to delete.
803         location (str):
804             A string value representing the location of the task. Default is
805             ``\`` which is the root for the task scheduler
806             (``C:\Windows\System32\tasks``).
807     Returns:
808         bool: ``True`` if successful, otherwise ``False``
809     CLI Example:
810     .. code-block:: bash
811         salt 'minion-id' task.delete_task &lt;task_name&gt;
812     """
813     if name not in list_tasks(location):
814         return "{} not found in {}".format(name, location)
815     with salt.utils.winapi.Com():
816         task_service = win32com.client.Dispatch("Schedule.Service")
817         task_service.Connect()
818         task_folder = task_service.GetFolder(location)
819         task_folder.DeleteTask(name, 0)
820     return name not in list_tasks(location)
821 def delete_folder(name, location="\\"):
822     r"""
823     Delete a folder from the task scheduler.
824     Args:
825         name (str):
826             The name of the folder to delete.
827         location (str):
828             A string value representing the location of the folder.  Default is
829             ``\`` which is the root for the task scheduler
830             (``C:\Windows\System32\tasks``).
831     Returns:
832         bool: ``True`` if successful, otherwise ``False``
833     CLI Example:
834     .. code-block:: bash
835         salt 'minion-id' task.delete_folder &lt;folder_name&gt;
836     """
837     if name not in list_folders(location):
838         return "{} not found in {}".format(name, location)
839     with salt.utils.winapi.Com():
840         task_service = win32com.client.Dispatch("Schedule.Service")
841         task_service.Connect()
842         task_folder = task_service.GetFolder(location)
843         task_folder.DeleteFolder(name, 0)
844     return name not in list_folders(location)
845 def run(name, location="\\"):
846     r"""
847     Run a scheduled task manually.
848     Args:
849         name (str):
850             The name of the task to run.
851         location (str):
852             A string value representing the location of the task. Default is
853             ``\`` which is the root for the task scheduler
854             (``C:\Windows\System32\tasks``).
855     Returns:
856         bool: ``True`` if successful, otherwise ``False``
857     CLI Example:
858     .. code-block:: bash
859         salt 'minion-id' task.run &lt;task_name&gt;
860     """
861     if name not in list_tasks(location):
862         return "{} not found in {}".format(name, location)
863     with salt.utils.winapi.Com():
864         task_service = win32com.client.Dispatch("Schedule.Service")
865         task_service.Connect()
866         task_folder = task_service.GetFolder(location)
867         task = task_folder.GetTask(name)
868         try:
869             task.Run("")
870             return True
871         except pythoncom.com_error:
872             return False
873 def run_wait(name, location="\\"):
874     r"""
875     Run a scheduled task and return when the task finishes
876     Args:
877         name (str):
878             The name of the task to run.
879         location (str):
880             A string value representing the location of the task. Default is
881             ``\`` which is the root for the task scheduler
882             (``C:\Windows\System32\tasks``).
883     Returns:
884         bool: ``True`` if successful, otherwise ``False``
885     CLI Example:
886     .. code-block:: bash
887         salt 'minion-id' task.run_wait &lt;task_name&gt;
888     """
889     if name not in list_tasks(location):
890         return "{} not found in {}".format(name, location)
891     with salt.utils.winapi.Com():
892         task_service = win32com.client.Dispatch("Schedule.Service")
893         task_service.Connect()
894         task_folder = task_service.GetFolder(location)
895         task = task_folder.GetTask(name)
896         if task.State == TASK_STATE_RUNNING:
897             return "Task already running"
898         try:
899             task.Run("")
900             time.sleep(1)
901             running = True
902         except pythoncom.com_error:
903             return False
904         while running:
905             running = False
906             try:
907                 running_tasks = task_service.GetRunningTasks(0)
908                 if running_tasks.Count:
909                     for item in running_tasks:
910                         if item.Name == name:
911                             running = True
912             except pythoncom.com_error:
913                 running = False
914     return True
915 def stop(name, location="\\"):
916     r"""
917     Stop a scheduled task.
918     Args:
919         name (str):
920             The name of the task to stop.
921         location (str):
922             A string value representing the location of the task. Default is
923             ``\`` which is the root for the task scheduler
924             (``C:\Windows\System32\tasks``).
925     Returns:
926         bool: ``True`` if successful, otherwise ``False``
927     CLI Example:
928     .. code-block:: bash
929         salt 'minion-id' task.list_stop &lt;task_name&gt;
930     """
931     if name not in list_tasks(location):
932         return "{} not found in {}".format(name, location)
933     with salt.utils.winapi.Com():
934         task_service = win32com.client.Dispatch("Schedule.Service")
935         task_service.Connect()
936         task_folder = task_service.GetFolder(location)
937         task = task_folder.GetTask(name)
938         try:
939             task.Stop(0)
940             return True
941         except pythoncom.com_error:
942             return False
943 def status(name, location="\\"):
944     r"""
945     Determine the status of a task. Is it Running, Queued, Ready, etc.
946     Args:
947         name (str):
948             The name of the task for which to return the status
949         location (str):
950             A string value representing the location of the task. Default is
951             ``\`` which is the root for the task scheduler
952             (``C:\Windows\System32\tasks``).
953     Returns:
954         str: The current status of the task. Will be one of the following:
955             - Unknown
956             - Disabled
957             - Queued
958             - Ready
959             - Running
960     CLI Example:
961     .. code-block:: bash
962         salt 'minion-id' task.list_status &lt;task_name&gt;
963     """
964     if name not in list_tasks(location):
965         return "{} not found in {}".format(name, location)
966     with salt.utils.winapi.Com():
967         task_service = win32com.client.Dispatch("Schedule.Service")
968         task_service.Connect()
969         task_folder = task_service.GetFolder(location)
970         task = task_folder.GetTask(name)
971         return states[task.State]
972 def info(name, location="\\"):
973     r"""
974     Get the details about a task in the task scheduler.
975     Args:
976         name (str):
977             The name of the task for which to return the status
978         location (str):
979             A string value representing the location of the task. Default is
980             ``\`` which is the root for the task scheduler
981             (``C:\Windows\System32\tasks``).
982     Returns:
983         dict: A dictionary containing the task configuration
984     CLI Example:
985     .. code-block:: bash
986         salt 'minion-id' task.info &lt;task_name&gt;
987     """
988     if name not in list_tasks(location):
989         return "{} not found in {}".format(name, location)
990     with salt.utils.winapi.Com():
991         task_service = win32com.client.Dispatch("Schedule.Service")
992         task_service.Connect()
993         task_folder = task_service.GetFolder(location)
994         task = task_folder.GetTask(name)
995         properties = {
996             "enabled": task.Enabled,
997             "last_run": _get_date_value(task.LastRunTime),
998             "last_run_result": results[task.LastTaskResult],
999             "missed_runs": task.NumberOfMissedRuns,
1000             "next_run": _get_date_value(task.NextRunTime),
1001             "status": states[task.State],
1002         }
1003         def_set = task.Definition.Settings
1004         settings = {
1005             "allow_demand_start": def_set.AllowDemandStart,
1006             "force_stop": def_set.AllowHardTerminate,
1007         }
1008         if def_set.DeleteExpiredTaskAfter == "":
1009             settings["delete_after"] = False
1010         elif def_set.DeleteExpiredTaskAfter == "PT0S":
1011             settings["delete_after"] = "Immediately"
1012         else:
1013             settings["delete_after"] = _reverse_lookup(
1014                 duration, def_set.DeleteExpiredTaskAfter
1015             )
1016         if def_set.ExecutionTimeLimit == "":
1017             settings["execution_time_limit"] = False
1018         else:
1019             settings["execution_time_limit"] = _reverse_lookup(
1020                 duration, def_set.ExecutionTimeLimit
1021             )
1022         settings["multiple_instances"] = _reverse_lookup(
1023             instances, def_set.MultipleInstances
1024         )
1025         if def_set.RestartInterval == "":
1026             settings["restart_interval"] = False
1027         else:
1028             settings["restart_interval"] = _reverse_lookup(
1029                 duration, def_set.RestartInterval
1030             )
1031         if settings["restart_interval"]:
1032             settings["restart_count"] = def_set.RestartCount
1033         settings["stop_if_on_batteries"] = def_set.StopIfGoingOnBatteries
1034         settings["wake_to_run"] = def_set.WakeToRun
1035         conditions = {
1036             "ac_only": def_set.DisallowStartIfOnBatteries,
1037             "run_if_idle": def_set.RunOnlyIfIdle,
1038             "run_if_network": def_set.RunOnlyIfNetworkAvailable,
1039             "start_when_available": def_set.StartWhenAvailable,
1040         }
1041         if conditions["run_if_idle"]:
1042             idle_set = def_set.IdleSettings
1043             conditions["idle_duration"] = idle_set.IdleDuration
1044             conditions["idle_restart"] = idle_set.RestartOnIdle
1045             conditions["idle_stop_on_end"] = idle_set.StopOnIdleEnd
1046             conditions["idle_wait_timeout"] = idle_set.WaitTimeout
1047         if conditions["run_if_network"]:
1048             net_set = def_set.NetworkSettings
1049             conditions["network_id"] = net_set.Id
1050             conditions["network_name"] = net_set.Name
1051         actions = []
1052         for actionObj in task.Definition.Actions:
1053             action = {"action_type": _reverse_lookup(action_types, actionObj.Type)}
1054             if actionObj.Path:
1055                 action["cmd"] = actionObj.Path
1056             if actionObj.Arguments:
1057                 action["arguments"] = actionObj.Arguments
1058             if actionObj.WorkingDirectory:
1059                 action["working_dir"] = actionObj.WorkingDirectory
1060             actions.append(action)
1061         triggers = []
1062         for triggerObj in task.Definition.Triggers:
1063             trigger = {"trigger_type": _reverse_lookup(trigger_types, triggerObj.Type)}
1064             if triggerObj.ExecutionTimeLimit:
1065                 trigger["execution_time_limit"] = _reverse_lookup(
1066                     duration, triggerObj.ExecutionTimeLimit
1067                 )
1068             if triggerObj.StartBoundary:
1069                 start_date, start_time = triggerObj.StartBoundary.split("T", 1)
1070                 trigger["start_date"] = start_date
1071                 trigger["start_time"] = start_time
1072             if triggerObj.EndBoundary:
1073                 end_date, end_time = triggerObj.EndBoundary.split("T", 1)
1074                 trigger["end_date"] = end_date
1075                 trigger["end_time"] = end_time
1076             trigger["enabled"] = triggerObj.Enabled
1077             if hasattr(triggerObj, "RandomDelay"):
1078                 if triggerObj.RandomDelay:
1079                     trigger["random_delay"] = _reverse_lookup(
1080                         duration, triggerObj.RandomDelay
1081                     )
1082                 else:
1083                     trigger["random_delay"] = False
1084             if hasattr(triggerObj, "Delay"):
1085                 if triggerObj.Delay:
1086                     trigger["delay"] = _reverse_lookup(duration, triggerObj.Delay)
1087                 else:
1088                     trigger["delay"] = False
1089             triggers.append(trigger)
1090         properties["settings"] = settings
1091         properties["conditions"] = conditions
1092         properties["actions"] = actions
1093         properties["triggers"] = triggers
1094         ret = properties
1095     return ret
1096 def add_action(name=None, location="\\", action_type="Execute", **kwargs):
1097     r"""
1098     Add an action to a task.
1099     Args:
1100         name (str):
1101             The name of the task to which to add the action.
1102         location (str):
1103             A string value representing the location of the task. Default is
1104             ``\`` which is the root for the task scheduler
1105             (``C:\Windows\System32\tasks``).
1106         action_type (str):
1107             The type of action to add. There are three action types. Each one
1108             requires its own set of Keyword Arguments (kwargs). Valid values
1109             are:
1110                 - Execute
1111                 - Email
1112                 - Message
1113     Required arguments for each action_type:
1114     **Execute**
1115         Execute a command or an executable
1116             cmd (str):
1117                 (required) The command or executable to run.
1118             arguments (str):
1119                 (optional) Arguments to be passed to the command or executable.
1120                 To launch a script the first command will need to be the
1121                 interpreter for the script. For example, to run a vbscript you
1122                 would pass ``cscript.exe`` in the ``cmd`` parameter and pass the
1123                 script in the ``arguments`` parameter as follows:
1124                     - ``cmd='cscript.exe' arguments='c:\scripts\myscript.vbs'``
1125                 Batch files do not need an interpreter and may be passed to the
1126                 cmd parameter directly.
1127             start_in (str):
1128                 (optional) The current working directory for the command.
1129     **Email**
1130         Send and email. Requires ``server``, ``from``, and ``to`` or ``cc``.
1131             from (str): The sender
1132             reply_to (str): Who to reply to
1133             to (str): The recipient
1134             cc (str): The CC recipient
1135             bcc (str): The BCC recipient
1136             subject (str): The subject of the email
1137             body (str): The Message Body of the email
1138             server (str): The server used to send the email
1139             attachments (list):
1140                 A list of attachments. These will be the paths to the files to
1141                 attach. ie: ``attachments="['C:\attachment1.txt',
1142                 'C:\attachment2.txt']"``
1143     **Message**
1144         Display a dialog box. The task must be set to "Run only when user is
1145         logged on" in order for the dialog box to display. Both parameters are
1146         required.
1147             title (str):
1148                 The dialog box title.
1149             message (str):
1150                 The dialog box message body
1151     Returns:
1152         dict: A dictionary containing the task configuration
1153     CLI Example:
1154     .. code-block:: bash
1155         salt 'minion-id' task.add_action &lt;task_name&gt; cmd='del /Q /S C:\\Temp'
1156     """
1157     with salt.utils.winapi.Com():
1158         save_definition = False
1159         if kwargs.get("task_definition", False):
1160             task_definition = kwargs.get("task_definition")
1161         else:
1162             save_definition = True
1163             if not name:
1164                 return 'Required parameter "name" not passed'
1165             if name in list_tasks(location):
1166                 task_service = win32com.client.Dispatch("Schedule.Service")
1167                 task_service.Connect()
1168                 task_folder = task_service.GetFolder(location)
1169                 task_definition = task_folder.GetTask(name).Definition
1170             else:
1171                 return "{} not found".format(name)
1172         task_action = task_definition.Actions.Create(action_types[action_type])
1173         if action_types[action_type] == TASK_ACTION_EXEC:
1174             task_action.Id = "Execute_ID1"
1175             if kwargs.get("cmd", False):
1176                 task_action.Path = kwargs.get("cmd")
1177             else:
1178                 return 'Required parameter "cmd" not found'
1179             task_action.Arguments = kwargs.get("arguments", "")
1180             task_action.WorkingDirectory = kwargs.get("start_in", "")
1181         elif action_types[action_type] == TASK_ACTION_SEND_EMAIL:
1182             task_action.Id = "Email_ID1"
1183             if kwargs.get("server", False):
1184                 task_action.Server = kwargs.get("server")
1185             else:
1186                 return 'Required parameter "server" not found'
1187             if kwargs.get("from", False):
1188                 task_action.From = kwargs.get("from")
1189             else:
1190                 return 'Required parameter "from" not found'
1191             if kwargs.get("to", False) or kwargs.get("cc", False):
1192                 if kwargs.get("to"):
1193                     task_action.To = kwargs.get("to")
1194                 if kwargs.get("cc"):
1195                     task_action.Cc = kwargs.get("cc")
1196             else:
1197                 return 'Required parameter "to" or "cc" not found'
1198             if kwargs.get("reply_to"):
1199                 task_action.ReplyTo = kwargs.get("reply_to")
1200             if kwargs.get("bcc"):
1201                 task_action.Bcc = kwargs.get("bcc")
1202             if kwargs.get("subject"):
1203                 task_action.Subject = kwargs.get("subject")
1204             if kwargs.get("body"):
1205                 task_action.Body = kwargs.get("body")
1206             if kwargs.get("attachments"):
1207                 task_action.Attachments = kwargs.get("attachments")
1208         elif action_types[action_type] == TASK_ACTION_SHOW_MESSAGE:
1209             task_action.Id = "Message_ID1"
1210             if kwargs.get("title", False):
1211                 task_action.Title = kwargs.get("title")
1212             else:
1213                 return 'Required parameter "title" not found'
1214             if kwargs.get("message", False):
1215                 task_action.MessageBody = kwargs.get("message")
1216             else:
1217                 return 'Required parameter "message" not found'
1218         if save_definition:
1219             return _save_task_definition(
1220                 name=name,
1221                 task_folder=task_folder,
1222                 task_definition=task_definition,
1223                 user_name=task_definition.Principal.UserID,
1224                 password=None,
1225                 logon_type=task_definition.Principal.LogonType,
1226             )
1227 def _clear_actions(name, location="\\"):
1228     r"""
1229     Remove all actions from the task.
1230     :param str name: The name of the task from which to clear all actions.
1231     :param str location: A string value representing the location of the task.
1232     Default is ``\`` which is the root for the task scheduler
1233     (``C:\Windows\System32\tasks``).
1234     :return: True if successful, False if unsuccessful
1235     :rtype: bool
1236     """
1237     if name not in list_tasks(location):
1238         return "{} not found in {}".format(name, location)
1239     with salt.utils.winapi.Com():
1240         task_service = win32com.client.Dispatch("Schedule.Service")
1241         task_service.Connect()
1242         task_folder = task_service.GetFolder(location)
1243         task_definition = task_folder.GetTask(name).Definition
1244         actions = task_definition.Actions
1245         actions.Clear()
1246         return _save_task_definition(
1247             name=name,
1248             task_folder=task_folder,
1249             task_definition=task_definition,
1250             user_name=task_definition.Principal.UserID,
1251             password=None,
1252             logon_type=task_definition.Principal.LogonType,
1253         )
1254 def add_trigger(
1255     name=None,
1256     location="\\",
1257     trigger_type=None,
1258     trigger_enabled=True,
1259     start_date=None,
1260     start_time=None,
1261     end_date=None,
1262     end_time=None,
1263     random_delay=None,
1264     repeat_interval=None,
1265     repeat_duration=None,
1266     repeat_stop_at_duration_end=False,
1267     execution_time_limit=None,
1268     delay=None,
1269     **kwargs
1270 ):
1271     r"""
1272     Add a trigger to a Windows Scheduled task
1273     .. note::
1274         Arguments are parsed by the YAML loader and are subject to
1275         yaml's idiosyncrasies. Therefore, time values in some
1276         formats (``%H:%M:%S`` and ``%H:%M``) should to be quoted.
1277         See `YAML IDIOSYNCRASIES`_ for more details.
1278     .. _`YAML IDIOSYNCRASIES`: https://docs.saltproject.io/en/latest/topics/troubleshooting/yaml_idiosyncrasies.html#time-expressions
1279     Args:
1280         name (str):
1281             The name of the task to which to add the trigger.
1282         location (str):
1283             A string value representing the location of the task. Default is
1284             ``\`` which is the root for the task scheduler
1285             (``C:\Windows\System32\tasks``).
1286         trigger_type (str):
1287             The type of trigger to create. This is defined when the trigger is
1288             created and cannot be changed later. Options are as follows:
1289                 - Event
1290                 - Once
1291                 - Daily
1292                 - Weekly
1293                 - Monthly
1294                 - MonthlyDay
1295                 - OnIdle
1296                 - OnTaskCreation
1297                 - OnBoot
1298                 - OnLogon
1299                 - OnSessionChange
1300         trigger_enabled (bool):
1301             Boolean value that indicates whether the trigger is enabled.
1302         start_date (str):
1303             The date when the trigger is activated. If no value is passed, the
1304             current date will be used. Can be one of the following formats:
1305                 - %Y-%m-%d
1306                 - %m-%d-%y
1307                 - %m-%d-%Y
1308                 - %m/%d/%y
1309                 - %m/%d/%Y
1310                 - %Y/%m/%d
1311         start_time (str):
1312             The time when the trigger is activated. If no value is passed,
1313             midnight will be used. Can be one of the following formats:
1314                 - %I:%M:%S %p
1315                 - %I:%M %p
1316                 - %H:%M:%S
1317                 - %H:%M
1318         end_date (str):
1319             The date when the trigger is deactivated. The trigger cannot start
1320             the task after it is deactivated. Can be one of the following
1321             formats:
1322                 - %Y-%m-%d
1323                 - %m-%d-%y
1324                 - %m-%d-%Y
1325                 - %m/%d/%y
1326                 - %m/%d/%Y
1327                 - %Y/%m/%d
1328         end_time (str):
1329             The time when the trigger is deactivated. If this is not passed
1330             with ``end_date`` it will be set to midnight. Can be one of the
1331             following formats:
1332                 - %I:%M:%S %p
1333                 - %I:%M %p
1334                 - %H:%M:%S
1335                 - %H:%M
1336         random_delay (str):
1337             The delay time that is randomly added to the start time of the
1338             trigger. Valid values are:
1339                 - 30 seconds
1340                 - 1 minute
1341                 - 30 minutes
1342                 - 1 hour
1343                 - 8 hours
1344                 - 1 day
1345             .. note::
1346                 This parameter applies to the following trigger types
1347                     - Once
1348                     - Daily
1349                     - Weekly
1350                     - Monthly
1351                     - MonthlyDay
1352         repeat_interval (str):
1353             The amount of time between each restart of the task. Valid values
1354             are:
1355                 - 5 minutes
1356                 - 10 minutes
1357                 - 15 minutes
1358                 - 30 minutes
1359                 - 1 hour
1360         repeat_duration (str):
1361             How long the pattern is repeated. Valid values are:
1362                 - Indefinitely
1363                 - 15 minutes
1364                 - 30 minutes
1365                 - 1 hour
1366                 - 12 hours
1367                 - 1 day
1368         repeat_stop_at_duration_end (bool):
1369             Boolean value that indicates if a running instance of the task is
1370             stopped at the end of the repetition pattern duration.
1371         execution_time_limit (str):
1372             The maximum amount of time that the task launched by the trigger is
1373             allowed to run. Valid values are:
1374                 - 30 minutes
1375                 - 1 hour
1376                 - 2 hours
1377                 - 4 hours
1378                 - 8 hours
1379                 - 12 hours
1380                 - 1 day
1381                 - 3 days (default)
1382         delay (str):
1383             The time the trigger waits after its activation to start the task.
1384             Valid values are:
1385                 - 15 seconds
1386                 - 30 seconds
1387                 - 1 minute
1388                 - 30 minutes
1389                 - 1 hour
1390                 - 8 hours
1391                 - 1 day
1392             .. note::
1393                 This parameter applies to the following trigger types:
1394                     - OnLogon
1395                     - OnBoot
1396                     - Event
1397                     - OnTaskCreation
1398                     - OnSessionChange
1399     **kwargs**
1400     There are optional keyword arguments determined by the type of trigger
1401     being defined. They are as follows:
1402     *Event*
1403         The trigger will be fired by an event.
1404             subscription (str):
1405                 An event definition in xml format that fires the trigger. The
1406                 easiest way to get this would is to create an event in Windows
1407                 Task Scheduler and then copy the xml text.
1408     *Once*
1409         No special parameters required.
1410     *Daily*
1411         The task will run daily.
1412             days_interval (int):
1413                 The interval between days in the schedule. An interval of 1
1414                 produces a daily schedule. An interval of 2 produces an
1415                 every-other day schedule. If no interval is specified, 1 is
1416                 used. Valid entries are 1 - 999.
1417     *Weekly*
1418         The task will run weekly.
1419             weeks_interval (int):
1420                 The interval between weeks in the schedule. An interval of 1
1421                 produces a weekly schedule. An interval of 2 produces an
1422                 every-other week schedule. If no interval is specified, 1 is
1423                 used. Valid entries are 1 - 52.
1424             days_of_week (list):
1425                 Sets the days of the week on which the task runs. Should be a
1426                 list. ie: ``['Monday','Wednesday','Friday']``. Valid entries are
1427                 the names of the days of the week.
1428     *Monthly*
1429         The task will run monthly.
1430             months_of_year (list):
1431                 Sets the months of the year during which the task runs. Should
1432                 be a list. ie: ``['January','July']``. Valid entries are the
1433                 full names of all the months.
1434             days_of_month (list):
1435                 Sets the days of the month during which the task runs. Should be
1436                 a list. ie: ``[1, 15, 'Last']``. Options are all days of the
1437                 month 1 - 31 and the word 'Last' to indicate the last day of the
1438                 month.
1439             last_day_of_month (bool):
1440                 Boolean value that indicates that the task runs on the last day
1441                 of the month regardless of the actual date of that day.
1442                 .. note::
1443                     You can set the task to run on the last day of the month by
1444                     either including the word 'Last' in the list of days, or
1445                     setting the parameter 'last_day_of_month' equal to ``True``.
1446     *MonthlyDay*
1447         The task will run monthly on the specified day.
1448             months_of_year (list):
1449                 Sets the months of the year during which the task runs. Should
1450                 be a list. ie: ``['January','July']``. Valid entries are the
1451                 full names of all the months.
1452             weeks_of_month (list):
1453                 Sets the weeks of the month during which the task runs. Should
1454                 be a list. ie: ``['First','Third']``. Valid options are:
1455                     - First
1456                     - Second
1457                     - Third
1458                     - Fourth
1459             last_week_of_month (bool):
1460                 Boolean value that indicates that the task runs on the last week
1461                 of the month.
1462             days_of_week (list):
1463                 Sets the days of the week during which the task runs. Should be
1464                 a list. ie: ``['Monday','Wednesday','Friday']``.  Valid entries
1465                 are the names of the days of the week.
1466     *OnIdle*
1467         No special parameters required.
1468     *OnTaskCreation*
1469         No special parameters required.
1470     *OnBoot*
1471         No special parameters required.
1472     *OnLogon*
1473         No special parameters required.
1474     *OnSessionChange*
1475         The task will be triggered by a session change.
1476             session_user_name (str):
1477                 Sets the user for the Terminal Server session. When a session
1478                 state change is detected for this user, a task is started. To
1479                 detect session status change for any user, do not pass this
1480                 parameter.
1481             state_change (str):
1482                 Sets the kind of Terminal Server session change that would
1483                 trigger a task launch. Valid options are:
1484                     - ConsoleConnect: When you connect to a user session (switch
1485                       users)
1486                     - ConsoleDisconnect: When you disconnect a user session
1487                       (switch users)
1488                     - RemoteConnect: When a user connects via Remote Desktop
1489                     - RemoteDisconnect: When a user disconnects via Remote
1490                       Desktop
1491                     - SessionLock: When the workstation is locked
1492                     - SessionUnlock: When the workstation is unlocked
1493     Returns:
1494         bool: ``True`` if successful, otherwise ``False``
1495     CLI Example:
1496     .. code-block:: bash
1497         salt 'minion-id' task.add_trigger &lt;task_name&gt; trigger_type=Once trigger_enabled=True start_date=2016/12/1 start_time='"12:01"'
1498     """
1499     if not trigger_type:
1500         return 'Required parameter "trigger_type" not specified'
1501     state_changes = {
1502         "ConsoleConnect": 1,
1503         "ConsoleDisconnect": 2,
1504         "RemoteConnect": 3,
1505         "RemoteDisconnect": 4,
1506         "SessionLock": 7,
1507         "SessionUnlock": 8,
1508     }
1509     days = {
1510         1: 0x1,
1511         2: 0x2,
1512         3: 0x4,
1513         4: 0x8,
1514         5: 0x10,
1515         6: 0x20,
1516         7: 0x40,
1517         8: 0x80,
1518         9: 0x100,
1519         10: 0x200,
1520         11: 0x400,
1521         12: 0x800,
1522         13: 0x1000,
1523         14: 0x2000,
1524         15: 0x4000,
1525         16: 0x8000,
1526         17: 0x10000,
1527         18: 0x20000,
1528         19: 0x40000,
1529         20: 0x80000,
1530         21: 0x100000,
1531         22: 0x200000,
1532         23: 0x400000,
1533         24: 0x800000,
1534         25: 0x1000000,
1535         26: 0x2000000,
1536         27: 0x4000000,
1537         28: 0x8000000,
1538         29: 0x10000000,
1539         30: 0x20000000,
1540         31: 0x40000000,
1541         "Last": 0x80000000,
1542     }
1543     weekdays = {
1544         "Sunday": 0x1,
1545         "Monday": 0x2,
1546         "Tuesday": 0x4,
1547         "Wednesday": 0x8,
1548         "Thursday": 0x10,
1549         "Friday": 0x20,
1550         "Saturday": 0x40,
1551     }
1552     weeks = {"First": 0x1, "Second": 0x2, "Third": 0x4, "Fourth": 0x8}
1553     months = {
1554         "January": 0x1,
1555         "February": 0x2,
1556         "March": 0x4,
1557         "April": 0x8,
1558         "May": 0x10,
1559         "June": 0x20,
1560         "July": 0x40,
1561         "August": 0x80,
1562         "September": 0x100,
1563         "October": 0x200,
1564         "November": 0x400,
1565         "December": 0x800,
1566     }
1567     if start_date:
1568         date_format = _get_date_time_format(start_date)
1569         if date_format:
1570             dt_obj = datetime.strptime(start_date, date_format)
1571         else:
1572             return "Invalid start_date"
1573     else:
1574         dt_obj = datetime.now()
1575     if start_time:
1576         time_format = _get_date_time_format(start_time)
1577         if time_format:
1578             tm_obj = datetime.strptime(start_time, time_format)
1579         else:
1580             return "Invalid start_time"
1581     else:
1582         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1583     start_boundary = "{}T{}".format(
1584         dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1585     )
1586     dt_obj = None
1587     if end_date:
1588         date_format = _get_date_time_format(end_date)
1589         if date_format:
1590             dt_obj = datetime.strptime(end_date, date_format)
1591         else:
1592             return "Invalid end_date"
1593     if end_time:
1594         time_format = _get_date_time_format(end_time)
1595         if time_format:
1596             tm_obj = datetime.strptime(end_time, time_format)
1597         else:
1598             return "Invalid end_time"
1599     else:
1600         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1601     end_boundary = None
1602     if dt_obj and tm_obj:
1603         end_boundary = "{}T{}".format(
1604             dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1605         )
1606     with salt.utils.winapi.Com():
1607         save_definition = False
1608         if kwargs.get("task_definition", False):
1609             task_definition = kwargs.get("task_definition")
1610         else:
1611             save_definition = True
1612             if not name:
1613                 return 'Required parameter "name" not passed'
1614             if name in list_tasks(location):
1615                 task_service = win32com.client.Dispatch("Schedule.Service")
1616                 task_service.Connect()
1617                 task_folder = task_service.GetFolder(location)
1618                 task_definition = task_folder.GetTask(name).Definition
1619             else:
1620                 return "{} not found".format(name)
1621         trigger = task_definition.Triggers.Create(trigger_types[trigger_type])
1622         trigger.StartBoundary = start_boundary
1623         if delay:
1624             trigger.Delay = _lookup_first(duration, delay)
1625         if random_delay:
1626             trigger.RandomDelay = _lookup_first(duration, random_delay)
1627         if repeat_interval:
1628             trigger.Repetition.Interval = _lookup_first(duration, repeat_interval)
1629             if repeat_duration:
1630                 trigger.Repetition.Duration = _lookup_first(duration, repeat_duration)
1631             trigger.Repetition.StopAtDurationEnd = repeat_stop_at_duration_end
1632         if execution_time_limit:
1633             trigger.ExecutionTimeLimit = _lookup_first(duration, execution_time_limit)
1634         if end_boundary:
1635             trigger.EndBoundary = end_boundary
1636         trigger.Enabled = trigger_enabled
1637         if trigger_types[trigger_type] == TASK_TRIGGER_EVENT:
1638             if kwargs.get("subscription", False):
1639                 trigger.Id = "Event_ID1"
1640                 trigger.Subscription = kwargs.get("subscription")
1641             else:
1642                 return 'Required parameter "subscription" not passed'
1643         elif trigger_types[trigger_type] == TASK_TRIGGER_TIME:
1644             trigger.Id = "Once_ID1"
1645         elif trigger_types[trigger_type] == TASK_TRIGGER_DAILY:
1646             trigger.Id = "Daily_ID1"
1647             trigger.DaysInterval = kwargs.get("days_interval", 1)
1648         elif trigger_types[trigger_type] == TASK_TRIGGER_WEEKLY:
1649             trigger.Id = "Weekly_ID1"
1650             trigger.WeeksInterval = kwargs.get("weeks_interval", 1)
1651             if kwargs.get("days_of_week", False):
1652                 bits_days = 0
1653                 for weekday in kwargs.get("days_of_week"):
1654                     bits_days |= weekdays[weekday]
1655                 trigger.DaysOfWeek = bits_days
1656             else:
1657                 return 'Required parameter "days_of_week" not passed'
1658         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLY:
1659             trigger.Id = "Monthly_ID1"
1660             if kwargs.get("months_of_year", False):
1661                 bits_months = 0
1662                 for month in kwargs.get("months_of_year"):
1663                     bits_months |= months[month]
1664                 trigger.MonthsOfYear = bits_months
1665             else:
1666                 return 'Required parameter "months_of_year" not passed'
1667             if kwargs.get("days_of_month", False) or kwargs.get(
1668                 "last_day_of_month", False
1669             ):
1670                 if kwargs.get("days_of_month", False):
1671                     bits_days = 0
1672                     for day in kwargs.get("days_of_month"):
1673                         bits_days |= days[day]
1674                     trigger.DaysOfMonth = bits_days
1675                 trigger.RunOnLastDayOfMonth = kwargs.get("last_day_of_month", False)
1676             else:
1677                 return (
1678                     'Monthly trigger requires "days_of_month" or "last_day_of_'
1679                     'month" parameters'
1680                 )
1681         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLYDOW:
1682             trigger.Id = "Monthly_DOW_ID1"
1683             if kwargs.get("months_of_year", False):
1684                 bits_months = 0
1685                 for month in kwargs.get("months_of_year"):
1686                     bits_months |= months[month]
1687                 trigger.MonthsOfYear = bits_months
1688             else:
1689                 return 'Required parameter "months_of_year" not passed'
1690             if kwargs.get("weeks_of_month", False) or kwargs.get(
1691                 "last_week_of_month", False
1692             ):
1693                 if kwargs.get("weeks_of_month", False):
1694                     bits_weeks = 0
1695                     for week in kwargs.get("weeks_of_month"):
1696                         bits_weeks |= weeks[week]
1697                     trigger.WeeksOfMonth = bits_weeks
1698                 trigger.RunOnLastWeekOfMonth = kwargs.get("last_week_of_month", False)
1699             else:
1700                 return (
1701                     'Monthly DOW trigger requires "weeks_of_month" or "last_'
1702                     'week_of_month" parameters'
1703                 )
1704             if kwargs.get("days_of_week", False):
1705                 bits_days = 0
1706                 for weekday in kwargs.get("days_of_week"):
1707                     bits_days |= weekdays[weekday]
1708                 trigger.DaysOfWeek = bits_days
1709             else:
1710                 return 'Required parameter "days_of_week" not passed'
1711         elif trigger_types[trigger_type] == TASK_TRIGGER_IDLE:
1712             trigger.Id = "OnIdle_ID1"
1713         elif trigger_types[trigger_type] == TASK_TRIGGER_REGISTRATION:
1714             trigger.Id = "OnTaskCreation_ID1"
1715         elif trigger_types[trigger_type] == TASK_TRIGGER_BOOT:
1716             trigger.Id = "OnBoot_ID1"
1717         elif trigger_types[trigger_type] == TASK_TRIGGER_LOGON:
1718             trigger.Id = "OnLogon_ID1"
1719         elif trigger_types[trigger_type] == TASK_TRIGGER_SESSION_STATE_CHANGE:
1720             trigger.Id = "OnSessionStateChange_ID1"
1721             if kwargs.get("session_user_name", False):
1722                 trigger.UserId = kwargs.get("session_user_name")
1723             if kwargs.get("state_change", False):
1724                 trigger.StateChange = state_changes[kwargs.get("state_change")]
1725             else:
1726                 return 'Required parameter "state_change" not passed'
1727         if save_definition:
1728             return _save_task_definition(
1729                 name=name,
1730                 task_folder=task_folder,
1731                 task_definition=task_definition,
1732                 user_name=task_definition.Principal.UserID,
1733                 password=None,
1734                 logon_type=task_definition.Principal.LogonType,
1735             )
1736 def clear_triggers(name, location="\\"):
1737     r"""
1738     Remove all triggers from the task.
1739     Args:
1740         name (str):
1741             The name of the task from which to clear all triggers.
1742         location (str):
1743             A string value representing the location of the task. Default is
1744             ``\`` which is the root for the task scheduler
1745             (``C:\Windows\System32\tasks``).
1746     Returns:
1747         bool: ``True`` if successful, otherwise ``False``
1748     CLI Example:
1749     .. code-block:: bash
1750         salt 'minion-id' task.clear_trigger &lt;task_name&gt;
1751     """
1752     if name not in list_tasks(location):
1753         return "{} not found in {}".format(name, location)
1754     with salt.utils.winapi.Com():
1755         task_service = win32com.client.Dispatch("Schedule.Service")
1756         task_service.Connect()
1757         task_folder = task_service.GetFolder(location)
1758         task_definition = task_folder.GetTask(name).Definition
1759         triggers = task_definition.Triggers
1760         triggers.Clear()
1761         return _save_task_definition(
1762             name=name,
1763             task_folder=task_folder,
1764             task_definition=task_definition,
1765             user_name=task_definition.Principal.UserID,
1766             password=None,
1767             logon_type=task_definition.Principal.LogonType,
1768         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
