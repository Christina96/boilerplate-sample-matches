<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_payload_1.py &amp; win_task.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_payload_1.py &amp; win_task.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_payload_1.py (3.9473684%)<th>win_task.py (0.65970314%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(170-173)<td><a href="#" name="0">(357-362)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_payload_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import logging
4 import salt.exceptions
5 import salt.payload
6 from salt.utils import immutabletypes
7 from salt.utils.odict import OrderedDict
8 log = logging.getLogger(__name__)
9 def assert_no_ordered_dict(data):
10     if isinstance(data, OrderedDict):
11         raise AssertionError("Found an ordered dictionary")
12     if isinstance(data, dict):
13         for value in data.values():
14             assert_no_ordered_dict(value)
15     elif isinstance(data, (list, tuple)):
16         for chunk in data:
17             assert_no_ordered_dict(chunk)
18 def test_list_nested_odicts():
19     idata = {"pillar": [OrderedDict(environment="dev")]}
20     odata = salt.payload.loads(salt.payload.dumps(idata.copy()))
21     assert_no_ordered_dict(odata)
22     assert idata == odata
23 def test_datetime_dump_load():
24     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
25     idata = {dtvalue: dtvalue}
26     sdata = salt.payload.dumps(idata.copy())
27     odata = salt.payload.loads(sdata)
28     assert (
29         sdata
30         == b"\x81\xc7\x18N20010203T04:05:06.000007\xc7\x18N20010203T04:05:06.000007"
31     )
32     assert idata == odata
33 def test_verylong_dump_load():
34     idata = {"jid": 20180227140750302662}
35     sdata = salt.payload.dumps(idata.copy())
36     odata = salt.payload.loads(sdata)
37     idata["jid"] = "{}".format(idata["jid"])
38     assert idata == odata
39 def test_immutable_dict_dump_load():
40     idata = {"dict": {"key": "value"}}
41     sdata = salt.payload.dumps({"dict": immutabletypes.ImmutableDict(idata["dict"])})
42     odata = salt.payload.loads(sdata)
43     assert idata == odata
44 def test_immutable_list_dump_load():
45     idata = {"list": [1, 2, 3]}
46     sdata = salt.payload.dumps({"list": immutabletypes.ImmutableList(idata["list"])})
47     odata = salt.payload.loads(sdata)
48     assert idata == odata
49 def test_immutable_set_dump_load():
50     idata = {"set": ["red", "green", "blue"]}
51     sdata = salt.payload.dumps({"set": immutabletypes.ImmutableSet(idata["set"])})
52     odata = salt.payload.loads(sdata)
53     assert idata == odata
54 def test_odict_dump_load():
55     data = OrderedDict()
56     data["a"] = "b"
57     data["y"] = "z"
58     data["j"] = "k"
59     data["w"] = "x"
60     sdata = salt.payload.dumps({"set": data})
61     odata = salt.payload.loads(sdata)
62     assert {"set": dict(data)}, odata
63 def test_mixed_dump_load():
64     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
65     od = OrderedDict()
66     od["a"] = "b"
67     od["y"] = "z"
68     od["j"] = "k"
69     od["w"] = "x"
70     idata = {
71         dtvalue: dtvalue,  # datetime
72         "jid": 20180227140750302662,  # long int
73         "dict": immutabletypes.ImmutableDict({"key": "value"}),  # immutable dict
74         "list": immutabletypes.ImmutableList([1, 2, 3]),  # immutable list
75         "set": immutabletypes.ImmutableSet(("red", "green", "blue")),  # immutable set
76         "odict": od,  # odict
77     }
78     edata = {
79         dtvalue: dtvalue,  # datetime, == input
80         "jid": "20180227140750302662",  # string repr of long int
81         "dict": {"key": "value"},  # builtin dict
82         "list": [1, 2, 3],  # builtin list
83         "set": ["red", "green", "blue"],  # builtin set
84         "odict": dict(od),  # builtin dict
85     }
86     sdata = salt.payload.dumps(idata)
87     odata = salt.payload.loads(sdata)
88     assert edata == odata
89 def test_recursive_dump_load():
90     data = {"name": "roscivs"}
91     data["data"] = data  # Data all the things!
92     sdata = salt.payload.dumps(data)
93     odata = salt.payload.loads(sdata)
94     assert "recursion" in odata["data"].lower()
95 def test_recursive_dump_load_with_identical_non_recursive_types():
96     repeating = "repeating element"
97     data = {
98         "a": "a",  # Test CPython implementation detail. Short
99         "b": "a",  # strings are interned.
100         "c": 13,  # So are small numbers.
101         "d": 13,
102         "fnord": repeating,
103         "repeating": [
104             [[[[{"one": repeating, "two": repeating}], repeating, 13, "a"]]],
105             repeating,
106             repeating,
107             repeating,
108 <a name="0"></a>        ],
109     }
110     data["repeating"][0]<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0][0].append(data)
111     sdata = salt.payload.dumps(copy.deepcopy(data))
112     odata = salt.</b></font>payload.loads(sdata)
113     del odata["repeating"][0][0][0][-1], data["repeating"][0][0][0][-1]
114     assert odata == data
115 def test_raw_vs_encoding_none():
116     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
117     idata = {dtvalue: "strval"}
118     sdata = salt.payload.dumps(idata.copy())
119     odata = salt.payload.loads(sdata, encoding=None)
120     assert isinstance(odata[dtvalue], str)
121 def test_raw_vs_encoding_utf8():
122     dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
123     idata = {dtvalue: "strval"}
124     sdata = salt.payload.dumps(idata.copy())
125     odata = salt.payload.loads(sdata, encoding="utf-8")
126     assert isinstance(odata[dtvalue], str)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_task.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import time
3 from datetime import datetime
4 import salt.utils.platform
5 import salt.utils.winapi
6 from salt.exceptions import ArgumentValueError, CommandExecutionError
7 try:
8     import pythoncom
9     import win32com.client
10     HAS_DEPENDENCIES = True
11 except ImportError:
12     HAS_DEPENDENCIES = False
13 log = logging.getLogger(__name__)
14 __virtualname__ = "task"
15 TASK_ACTION_EXEC = 0
16 TASK_ACTION_COM_HANDLER = 5
17 TASK_ACTION_SEND_EMAIL = 6
18 TASK_ACTION_SHOW_MESSAGE = 7
19 TASK_COMPATIBILITY_AT = 0
20 TASK_COMPATIBILITY_V1 = 1
21 TASK_COMPATIBILITY_V2 = 2
22 TASK_COMPATIBILITY_V3 = 3
23 TASK_VALIDATE_ONLY = 0x1
24 TASK_CREATE = 0x2
25 TASK_UPDATE = 0x4
26 TASK_CREATE_OR_UPDATE = 0x6
27 TASK_DISABLE = 0x8
28 TASK_DONT_ADD_PRINCIPAL_ACE = 0x10
29 TASK_IGNORE_REGISTRATION_TRIGGERS = 0x20
30 TASK_INSTANCES_PARALLEL = 0
31 TASK_INSTANCES_QUEUE = 1
32 TASK_INSTANCES_IGNORE_NEW = 2
33 TASK_INSTANCES_STOP_EXISTING = 3
34 TASK_LOGON_NONE = 0
35 TASK_LOGON_PASSWORD = 1
36 TASK_LOGON_S4U = 2
37 TASK_LOGON_INTERACTIVE_TOKEN = 3
38 TASK_LOGON_GROUP = 4
39 TASK_LOGON_SERVICE_ACCOUNT = 5
40 TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = 6
41 TASK_RUNLEVEL_LUA = 0
42 TASK_RUNLEVEL_HIGHEST = 1
43 TASK_STATE_UNKNOWN = 0
44 TASK_STATE_DISABLED = 1
45 TASK_STATE_QUEUED = 2
46 TASK_STATE_READY = 3
47 TASK_STATE_RUNNING = 4
48 TASK_TRIGGER_EVENT = 0
49 TASK_TRIGGER_TIME = 1
50 TASK_TRIGGER_DAILY = 2
51 TASK_TRIGGER_WEEKLY = 3
52 TASK_TRIGGER_MONTHLY = 4
53 TASK_TRIGGER_MONTHLYDOW = 5
54 TASK_TRIGGER_IDLE = 6
55 TASK_TRIGGER_REGISTRATION = 7
56 TASK_TRIGGER_BOOT = 8
57 TASK_TRIGGER_LOGON = 9
58 TASK_TRIGGER_SESSION_STATE_CHANGE = 11
59 duration = {
60     "Immediately": "PT0M",
61     "Indefinitely": "",
62     "Do not wait": "PT0M",
63     "15 seconds": "PT15S",
64     "30 seconds": "PT30S",
65     "1 minute": "PT1M",
66     "5 minutes": "PT5M",
67     "10 minutes": "PT10M",
68     "15 minutes": "PT15M",
69     "30 minutes": "PT30M",
70     "1 hour": "PT1H",
71     "2 hours": "PT2H",
72     "4 hours": "PT4H",
73     "8 hours": "PT8H",
74     "12 hours": "PT12H",
75     "1 day": ["P1D", "PT24H"],
76     "3 days": ["P3D", "PT72H"],
77     "30 days": "P30D",
78     "90 days": "P90D",
79     "180 days": "P180D",
80     "365 days": "P365D",
81 }
82 action_types = {
83     "Execute": TASK_ACTION_EXEC,
84     "Email": TASK_ACTION_SEND_EMAIL,
85     "Message": TASK_ACTION_SHOW_MESSAGE,
86 }
87 trigger_types = {
88     "Event": TASK_TRIGGER_EVENT,
89     "Once": TASK_TRIGGER_TIME,
90     "Daily": TASK_TRIGGER_DAILY,
91     "Weekly": TASK_TRIGGER_WEEKLY,
92     "Monthly": TASK_TRIGGER_MONTHLY,
93     "MonthlyDay": TASK_TRIGGER_MONTHLYDOW,
94     "OnIdle": TASK_TRIGGER_IDLE,
95     "OnTaskCreation": TASK_TRIGGER_REGISTRATION,
96     "OnBoot": TASK_TRIGGER_BOOT,
97     "OnLogon": TASK_TRIGGER_LOGON,
98     "OnSessionChange": TASK_TRIGGER_SESSION_STATE_CHANGE,
99 }
100 states = {
101     TASK_STATE_UNKNOWN: "Unknown",
102     TASK_STATE_DISABLED: "Disabled",
103     TASK_STATE_QUEUED: "Queued",
104     TASK_STATE_READY: "Ready",
105     TASK_STATE_RUNNING: "Running",
106 }
107 instances = {
108     "Parallel": TASK_INSTANCES_PARALLEL,
109     "Queue": TASK_INSTANCES_QUEUE,
110     "No New Instance": TASK_INSTANCES_IGNORE_NEW,
111     "Stop Existing": TASK_INSTANCES_STOP_EXISTING,
112 }
113 results = {
114     0x0: "The operation completed successfully",
115     0x1: "Incorrect or unknown function called",
116     0x2: "File not found",
117     0xA: "The environment is incorrect",
118     0x41300: "Task is ready to run at its next scheduled time",
119     0x41301: "Task is currently running",
120     0x41302: "Task is disabled",
121     0x41303: "Task has not yet run",
122     0x41304: "There are no more runs scheduled for this task",
123     0x41306: "Task was terminated by the user",
124     0x8004130F: "Credentials became corrupted",
125     0x8004131F: "An instance of this task is already running",
126     0x800710E0: "The operator or administrator has refused the request",
127     0x800704DD: "The service is not available (Run only when logged in?)",
128     0xC000013A: "The application terminated as a result of CTRL+C",
129     0xC06D007E: "Unknown software exception",
130 }
131 def __virtual__():
132     if salt.utils.platform.is_windows():
133         if not HAS_DEPENDENCIES:
134             log.warning("Could not load dependencies for %s", __virtualname__)
135         return __virtualname__
136     return False, "Module win_task: module only works on Windows systems"
137 def _get_date_time_format(dt_string):
138     valid_formats = [
139         "%I:%M:%S %p",
140         "%I:%M %p",
141         "%H:%M:%S",
142         "%H:%M",
143         "%Y-%m-%d",
144         "%m-%d-%y",
145         "%m-%d-%Y",
146         "%m/%d/%y",
147         "%m/%d/%Y",
148         "%Y/%m/%d",
149     ]
150     for dt_format in valid_formats:
151         try:
152             datetime.strptime(dt_string, dt_format)
153             return dt_format
154         except ValueError:
155             continue
156     return False
157 def _get_date_value(date):
158     try:
159         return "{}".format(date)
160     except ValueError:
161         return "Never"
162 def _reverse_lookup(dictionary, value):
163     value_index = -1
164     for idx, dict_value in enumerate(dictionary.values()):
165         if type(dict_value) == list:
166             if value in dict_value:
167                 value_index = idx
168                 break
169         elif value == dict_value:
170             value_index = idx
171             break
172     return list(dictionary)[value_index]
173 def _lookup_first(dictionary, key):
174     value = dictionary[key]
175     if type(value) == list:
176         return value[0]
177     else:
178         return value
179 def _save_task_definition(
180     name, task_folder, task_definition, user_name, password, logon_type
181 ):
182     try:
183         task_folder.RegisterTaskDefinition(
184             name,
185             task_definition,
186             TASK_CREATE_OR_UPDATE,
187             user_name,
188             password,
189             logon_type,
190         )
191         return True
192     except pythoncom.com_error as error:
193         hr, msg, exc, arg = error.args  # pylint: disable=W0633
194         fc = {
195             -2147024773: (
196                 "The filename, directory name, or volume label syntax is incorrect"
197             ),
198             -2147024894: "The system cannot find the file specified",
199             -2147216615: "Required element or attribute missing",
200             -2147216616: "Value incorrectly formatted or out of range",
201             -2147352571: "Access denied",
202         }
203         try:
204             failure_code = fc[exc[5]]
205         except KeyError:
206             failure_code = "Unknown Failure: {}".format(error)
207         log.debug("Failed to modify task: %s", failure_code)
208         return "Failed to modify task: {}".format(failure_code)
209 def list_tasks(location="\\"):
210     r"""
211     List all tasks located in a specific location in the task scheduler.
212     Args:
213         location (str):
214             A string value representing the folder from which you want to list
215             tasks. Default is ``\`` which is the root for the task scheduler
216             (``C:\Windows\System32\tasks``).
217     Returns:
218         list: Returns a list of tasks
219     CLI Example:
220     .. code-block:: bash
221         salt 'minion-id' task.list_tasks
222 <a name="0"></a>        salt 'minion-id' task.list_tasks Microsoft\XblGameSave
223     with salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.winapi.Com():
224         task_service = win32com.client.Dispatch("Schedule.Service")
225         task_service.Connect()
226         task_folder = task_service.</b></font>GetFolder(location)
227         tasks = task_folder.GetTasks(0)
228         ret = []
229         for task in tasks:
230             ret.append(task.Name)
231     return ret
232 def list_folders(location="\\"):
233     r"""
234     List all folders located in a specific location in the task scheduler.
235     Args:
236         location (str):
237             A string value representing the folder from which you want to list
238             tasks. Default is ``\`` which is the root for the task scheduler
239             (``C:\Windows\System32\tasks``).
240     Returns:
241         list: Returns a list of folders.
242     CLI Example:
243     .. code-block:: bash
244         salt 'minion-id' task.list_folders
245         salt 'minion-id' task.list_folders Microsoft
246     with salt.utils.winapi.Com():
247         task_service = win32com.client.Dispatch("Schedule.Service")
248         task_service.Connect()
249         task_folder = task_service.GetFolder(location)
250         task_definition = task_folder.GetTask(name).Definition
251         triggers = task_definition.Triggers
252         ret = []
253         for trigger in triggers:
254             ret.append(trigger.Id)
255     return ret
256 def list_actions(name, location="\\"):
257     r"""
258     List all actions that pertain to a task in the specified location.
259     Args:
260         name (str):
261             The name of the task for which list actions.
262         location (str):
263             A string value representing the location of the task from which to
264             list actions. Default is ``\`` which is the root for the task
265             scheduler (``C:\Windows\System32\tasks``).
266     Returns:
267         list: Returns a list of actions.
268     CLI Example:
269     .. code-block:: bash
270         salt 'minion-id' task.list_actions &lt;task_name&gt;
271         salt 'minion-id' task.list_actions XblGameSaveTask Microsoft\XblGameSave
272     if name in list_tasks(location) and not force:
273         return "{} already exists".format(name)
274     with salt.utils.winapi.Com():
275         task_service = win32com.client.Dispatch("Schedule.Service")
276         task_service.Connect()
277         task_definition = task_service.NewTask(0)
278         edit_task(
279             task_definition=task_definition,
280             user_name=user_name,
281             password=password,
282             **kwargs
283         )
284         add_action(task_definition=task_definition, **kwargs)
285         add_trigger(task_definition=task_definition, **kwargs)
286         task_folder = task_service.GetFolder(location)
287         _save_task_definition(
288             name=name,
289             task_folder=task_folder,
290             task_definition=task_definition,
291             user_name=task_definition.Principal.UserID,
292             password=password,
293             logon_type=task_definition.Principal.LogonType,
294         )
295     return name in list_tasks(location)
296 def create_task_from_xml(
297     name, location="\\", xml_text=None, xml_path=None, user_name="System", password=None
298 ):
299     r"""
300     Create a task based on XML. Source can be a file or a string of XML.
301     Args:
302         name (str):
303             The name of the task. This will be displayed in the task scheduler.
304         location (str):
305             A string value representing the location in which to create the
306             task. Default is ``\`` which is the root for the task scheduler
307             (``C:\Windows\System32\tasks``).
308         xml_text (str):
309             A string of xml representing the task to be created. This will be
310             overridden by ``xml_path`` if passed.
311         xml_path (str):
312             The path to an XML file on the local system containing the xml that
313             defines the task. This will override ``xml_text``
314         user_name (str):
315             The user account under which to run the task. To specify the
316             'System' account, use 'System'. The password will be ignored.
317         password (str):
318             The password to use for authentication. This should set the task to
319             run whether the user is logged in or not, but is currently not
320             working.
321     Returns:
322         bool: ``True`` if successful, otherwise ``False``
323         str: A string with the error message if there is an error
324     Raises:
325         ArgumentValueError: If arguments are invalid
326         CommandExecutionError
327     CLI Example:
328     .. code-block:: bash
329         salt '*' task.create_task_from_xml &lt;task_name&gt; xml_path=C:\task.xml
330     """
331     if name in list_tasks(location):
332         return "{} already exists".format(name)
333     if not xml_text and not xml_path:
334         raise ArgumentValueError("Must specify either xml_text or xml_path")
335     with salt.utils.winapi.Com():
336         task_service = win32com.client.Dispatch("Schedule.Service")
337         task_service.Connect()
338         if xml_path:
339             xml_text = xml_path
340         task_folder = task_service.GetFolder(location)
341         if user_name:
342             if user_name.lower() == "system":
343                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
344                 user_name = "SYSTEM"
345                 password = None
346             else:
347                 if password:
348                     logon_type = TASK_LOGON_PASSWORD
349                 else:
350                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
351         else:
352             password = None
353             logon_type = TASK_LOGON_NONE
354         try:
355             task_folder.RegisterTask(
356                 name, xml_text, TASK_CREATE, user_name, password, logon_type
357             )
358         except pythoncom.com_error as error:
359             hr, msg, exc, arg = error.args  # pylint: disable=W0633
360             error_code = hex(exc[5] + 2 ** 32)
361             fc = {
362                 0x80041319: "Required element or attribute missing",
363                 0x80041318: "Value incorrectly formatted or out of range",
364                 0x80020005: "Access denied",
365                 0x80041309: "A task's trigger is not found",
366                 0x8004130A: (
367                     "One or more of the properties required to run this "
368                     "task have not been set"
369                 ),
370                 0x8004130C: (
371                     "The Task Scheduler service is not installed on this computer"
372                 ),
373                 0x8004130D: "The task object could not be opened",
374                 0x8004130E: (
375                     "The object is either an invalid task object or is not "
376                     "a task object"
377                 ),
378                 0x8004130F: (
379                     "No account information could be found in the Task "
380                     "Scheduler security database for the task indicated"
381                 ),
382                 0x80041310: "Unable to establish existence of the account specified",
383                 0x80041311: (
384                     "Corruption was detected in the Task Scheduler "
385                     "security database; the database has been reset"
386                 ),
387                 0x80041313: "The task object version is either unsupported or invalid",
388                 0x80041314: (
389                     "The task has been configured with an unsupported "
390                     "combination of account settings and run time options"
391                 ),
392                 0x80041315: "The Task Scheduler Service is not running",
393                 0x80041316: "The task XML contains an unexpected node",
394                 0x80041317: (
395                     "The task XML contains an element or attribute from an "
396                     "unexpected namespace"
397                 ),
398                 0x8004131A: "The task XML is malformed",
399                 0x0004131C: (
400                     "The task is registered, but may fail to start. Batch "
401                     "logon privilege needs to be enabled for the task principal"
402                 ),
403                 0x8004131D: "The task XML contains too many nodes of the same type",
404             }
405             try:
406                 failure_code = fc[error_code]
407             except KeyError:
408                 failure_code = "Unknown Failure: {}".format(error_code)
409             finally:
410                 log.debug("Failed to create task: %s", failure_code)
411             raise CommandExecutionError(failure_code)
412     return name in list_tasks(location)
413 def create_folder(name, location="\\"):
414     r"""
415     Create a folder in which to create tasks.
416     Args:
417         name (str):
418             The name of the folder. This will be displayed in the task
419             scheduler.
420         location (str):
421             A string value representing the location in which to create the
422             folder. Default is ``\`` which is the root for the task scheduler
423             (``C:\Windows\System32\tasks``).
424     Returns:
425         bool: ``True`` if successful, otherwise ``False``
426     CLI Example:
427     .. code-block:: bash
428         salt 'minion-id' task.create_folder &lt;folder_name&gt;
429     """
430     if name in list_folders(location):
431         return "{} already exists".format(name)
432     with salt.utils.winapi.Com():
433         task_service = win32com.client.Dispatch("Schedule.Service")
434         task_service.Connect()
435         task_folder = task_service.GetFolder(location)
436         task_folder.CreateFolder(name)
437     return name in list_folders(location)
438 def edit_task(
439     name=None,
440     location="\\",
441     user_name=None,
442     password=None,
443     description=None,
444     enabled=None,
445     hidden=None,
446     run_if_idle=None,
447     idle_duration=None,
448     idle_wait_timeout=None,
449     idle_stop_on_end=None,
450     idle_restart=None,
451     ac_only=None,
452     stop_if_on_batteries=None,
453     wake_to_run=None,
454     run_if_network=None,
455     network_id=None,
456     network_name=None,
457     allow_demand_start=None,
458     start_when_available=None,
459     restart_every=None,
460     restart_count=3,
461     execution_time_limit=None,
462     force_stop=None,
463     delete_after=None,
464     multiple_instances=None,
465     **kwargs
466 ):
467     r"""
468     Edit the parameters of a task. Triggers and Actions cannot be edited yet.
469     Args:
470         name (str):
471             The name of the task. This will be displayed in the task scheduler.
472         location (str):
473             A string value representing the location in which to create the
474             task. Default is ``\`` which is the root for the task scheduler
475             (``C:\Windows\System32\tasks``).
476         user_name (str):
477             The user account under which to run the task. To specify the
478             'System' account, use 'System'. The password will be ignored.
479         password (str):
480             The password to use for authentication. This should set the task to
481             run whether the user is logged in or not, but is currently not
482             working.
483             .. note::
484                 The combination of user_name and password determine how the
485                 task runs. For example, if a username is passed without at
486                 password the task will only run when the user is logged in. If a
487                 password is passed as well the task will run whether the user is
488                 logged on or not. If you pass 'System' as the username the task
489                 will run as the system account (the password parameter is
490                 ignored).
491         description (str):
492             A string representing the text that will be displayed in the
493             description field in the task scheduler.
494         enabled (bool):
495             A boolean value representing whether or not the task is enabled.
496         hidden (bool):
497             A boolean value representing whether or not the task is hidden.
498         run_if_idle (bool):
499             Boolean value that indicates that the Task Scheduler will run the
500             task only if the computer is in an idle state.
501         idle_duration (str):
502             A value that indicates the amount of time that the computer must be
503             in an idle state before the task is run. Valid values are:
504                 - 1 minute
505                 - 5 minutes
506                 - 10 minutes
507                 - 15 minutes
508                 - 30 minutes
509                 - 1 hour
510         idle_wait_timeout (str):
511             A value that indicates the amount of time that the Task Scheduler
512             will wait for an idle condition to occur. Valid values are:
513                 - Do not wait
514                 - 1 minute
515                 - 5 minutes
516                 - 10 minutes
517                 - 15 minutes
518                 - 30 minutes
519                 - 1 hour
520                 - 2 hours
521         idle_stop_on_end (bool):
522             Boolean value that indicates that the Task Scheduler will terminate
523             the task if the idle condition ends before the task is completed.
524         idle_restart (bool):
525             Boolean value that indicates whether the task is restarted when the
526             computer cycles into an idle condition more than once.
527         ac_only (bool):
528             Boolean value that indicates that the Task Scheduler will launch the
529             task only while on AC power.
530         stop_if_on_batteries (bool):
531             Boolean value that indicates that the task will be stopped if the
532             computer begins to run on battery power.
533         wake_to_run (bool):
534             Boolean value that indicates that the Task Scheduler will wake the
535             computer when it is time to run the task.
536         run_if_network (bool):
537             Boolean value that indicates that the Task Scheduler will run the
538             task only when a network is available.
539         network_id (guid):
540             GUID value that identifies a network profile.
541         network_name (str):
542             Sets the name of a network profile. The name is used for display
543             purposes.
544         allow_demand_start (bool):
545             Boolean value that indicates that the task can be started by using
546             either the Run command or the Context menu.
547         start_when_available (bool):
548             Boolean value that indicates that the Task Scheduler can start the
549             task at any time after its scheduled time has passed.
550         restart_every (str):
551             A value that specifies the interval between task restart attempts.
552             Valid values are:
553                 - False (to disable)
554                 - 1 minute
555                 - 5 minutes
556                 - 10 minutes
557                 - 15 minutes
558                 - 30 minutes
559                 - 1 hour
560                 - 2 hours
561         restart_count (int):
562             The number of times the Task Scheduler will attempt to restart the
563             task. Valid values are integers 1 - 999.
564         execution_time_limit (bool, str):
565             The amount of time allowed to complete the task. Valid values are:
566                 - False (to disable)
567                 - 1 hour
568                 - 2 hours
569                 - 4 hours
570                 - 8 hours
571                 - 12 hours
572                 - 1 day
573                 - 3 days
574         force_stop (bool):
575             Boolean value that indicates that the task may be terminated by
576             using TerminateProcess.
577         delete_after (bool, str):
578             The amount of time that the Task Scheduler will wait before deleting
579             the task after it expires. Requires a trigger with an expiration
580             date. Valid values are:
581                 - False (to disable)
582                 - Immediately
583                 - 30 days
584                 - 90 days
585                 - 180 days
586                 - 365 days
587         multiple_instances (str):
588             Sets the policy that defines how the Task Scheduler deals with
589             multiple instances of the task. Valid values are:
590                 - Parallel
591                 - Queue
592                 - No New Instance
593                 - Stop Existing
594     Returns:
595         bool: ``True`` if successful, otherwise ``False``
596     CLI Example:
597     .. code-block:: bash
598         salt '*' task.edit_task &lt;task_name&gt; description='This task is awesome'
599     """
600     with salt.utils.winapi.Com():
601         save_definition = False
602         if kwargs.get("task_definition", False):
603             task_definition = kwargs.get("task_definition")
604         else:
605             save_definition = True
606             if not name:
607                 return 'Required parameter "name" not passed'
608             if name in list_tasks(location):
609                 task_service = win32com.client.Dispatch("Schedule.Service")
610                 task_service.Connect()
611                 task_folder = task_service.GetFolder(location)
612                 task_definition = task_folder.GetTask(name).Definition
613             else:
614                 return "{} not found".format(name)
615         if save_definition:
616             task_definition.RegistrationInfo.Author = "Salt Minion"
617             task_definition.RegistrationInfo.Source = "Salt Minion Daemon"
618         if description is not None:
619             task_definition.RegistrationInfo.Description = description
620         if user_name:
621             if user_name.lower() == "system":
622                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
623                 user_name = "SYSTEM"
624                 password = None
625             else:
626                 task_definition.Principal.Id = user_name
627                 if password:
628                     logon_type = TASK_LOGON_PASSWORD
629                 else:
630                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
631             task_definition.Principal.UserID = user_name
632             task_definition.Principal.DisplayName = user_name
633             task_definition.Principal.LogonType = logon_type
634             task_definition.Principal.RunLevel = TASK_RUNLEVEL_HIGHEST
635         else:
636             user_name = None
637             password = None
638         if enabled is not None:
639             task_definition.Settings.Enabled = enabled
640         if hidden is not None:
641             task_definition.Settings.Hidden = hidden
642         if run_if_idle is not None:
643             task_definition.Settings.RunOnlyIfIdle = run_if_idle
644         if task_definition.Settings.RunOnlyIfIdle:
645             if idle_stop_on_end is not None:
646                 task_definition.Settings.IdleSettings.StopOnIdleEnd = idle_stop_on_end
647             if idle_restart is not None:
648                 task_definition.Settings.IdleSettings.RestartOnIdle = idle_restart
649             if idle_duration is not None:
650                 if idle_duration in duration:
651                     task_definition.Settings.IdleSettings.IdleDuration = _lookup_first(
652                         duration, idle_duration
653                     )
654                 else:
655                     return 'Invalid value for "idle_duration"'
656             if idle_wait_timeout is not None:
657                 if idle_wait_timeout in duration:
658                     task_definition.Settings.IdleSettings.WaitTimeout = _lookup_first(
659                         duration, idle_wait_timeout
660                     )
661                 else:
662                     return 'Invalid value for "idle_wait_timeout"'
663         if ac_only is not None:
664             task_definition.Settings.DisallowStartIfOnBatteries = ac_only
665         if stop_if_on_batteries is not None:
666             task_definition.Settings.StopIfGoingOnBatteries = stop_if_on_batteries
667         if wake_to_run is not None:
668             task_definition.Settings.WakeToRun = wake_to_run
669         if run_if_network is not None:
670             task_definition.Settings.RunOnlyIfNetworkAvailable = run_if_network
671         if task_definition.Settings.RunOnlyIfNetworkAvailable:
672             if network_id:
673                 task_definition.Settings.NetworkSettings.Id = network_id
674             if network_name:
675                 task_definition.Settings.NetworkSettings.Name = network_name
676         if allow_demand_start is not None:
677             task_definition.Settings.AllowDemandStart = allow_demand_start
678         if start_when_available is not None:
679             task_definition.Settings.StartWhenAvailable = start_when_available
680         if restart_every is not None:
681             if restart_every is False:
682                 task_definition.Settings.RestartInterval = ""
683             else:
684                 if restart_every in duration:
685                     task_definition.Settings.RestartInterval = _lookup_first(
686                         duration, restart_every
687                     )
688                 else:
689                     return 'Invalid value for "restart_every"'
690         if task_definition.Settings.RestartInterval:
691             if restart_count is not None:
692                 if restart_count in range(1, 999):
693                     task_definition.Settings.RestartCount = restart_count
694                 else:
695                     return '"restart_count" must be a value between 1 and 999'
696         if execution_time_limit is not None:
697             if execution_time_limit is False:
698                 task_definition.Settings.ExecutionTimeLimit = "PT0S"
699             else:
700                 if execution_time_limit in duration:
701                     task_definition.Settings.ExecutionTimeLimit = _lookup_first(
702                         duration, execution_time_limit
703                     )
704                 else:
705                     return 'Invalid value for "execution_time_limit"'
706         if force_stop is not None:
707             task_definition.Settings.AllowHardTerminate = force_stop
708         if delete_after is not None:
709             if delete_after is False:
710                 task_definition.Settings.DeleteExpiredTaskAfter = ""
711             if delete_after in duration:
712                 task_definition.Settings.DeleteExpiredTaskAfter = _lookup_first(
713                     duration, delete_after
714                 )
715             else:
716                 return 'Invalid value for "delete_after"'
717         if multiple_instances is not None:
718             task_definition.Settings.MultipleInstances = instances[multiple_instances]
719         if save_definition:
720             return _save_task_definition(
721                 name=name,
722                 task_folder=task_folder,
723                 task_definition=task_definition,
724                 user_name=user_name,
725                 password=password,
726                 logon_type=task_definition.Principal.LogonType,
727             )
728 def delete_task(name, location="\\"):
729     r"""
730     Delete a task from the task scheduler.
731     Args:
732         name (str):
733             The name of the task to delete.
734         location (str):
735             A string value representing the location of the task. Default is
736             ``\`` which is the root for the task scheduler
737             (``C:\Windows\System32\tasks``).
738     Returns:
739         bool: ``True`` if successful, otherwise ``False``
740     CLI Example:
741     .. code-block:: bash
742         salt 'minion-id' task.delete_task &lt;task_name&gt;
743     """
744     if name not in list_tasks(location):
745         return "{} not found in {}".format(name, location)
746     with salt.utils.winapi.Com():
747         task_service = win32com.client.Dispatch("Schedule.Service")
748         task_service.Connect()
749         task_folder = task_service.GetFolder(location)
750         task_folder.DeleteTask(name, 0)
751     return name not in list_tasks(location)
752 def delete_folder(name, location="\\"):
753     r"""
754     Delete a folder from the task scheduler.
755     Args:
756         name (str):
757             The name of the folder to delete.
758         location (str):
759             A string value representing the location of the folder.  Default is
760             ``\`` which is the root for the task scheduler
761             (``C:\Windows\System32\tasks``).
762     Returns:
763         bool: ``True`` if successful, otherwise ``False``
764     CLI Example:
765     .. code-block:: bash
766         salt 'minion-id' task.delete_folder &lt;folder_name&gt;
767     """
768     if name not in list_folders(location):
769         return "{} not found in {}".format(name, location)
770     with salt.utils.winapi.Com():
771         task_service = win32com.client.Dispatch("Schedule.Service")
772         task_service.Connect()
773         task_folder = task_service.GetFolder(location)
774         task_folder.DeleteFolder(name, 0)
775     return name not in list_folders(location)
776 def run(name, location="\\"):
777     r"""
778     Run a scheduled task manually.
779     Args:
780         name (str):
781             The name of the task to run.
782         location (str):
783             A string value representing the location of the task. Default is
784             ``\`` which is the root for the task scheduler
785             (``C:\Windows\System32\tasks``).
786     Returns:
787         bool: ``True`` if successful, otherwise ``False``
788     CLI Example:
789     .. code-block:: bash
790         salt 'minion-id' task.run &lt;task_name&gt;
791     """
792     if name not in list_tasks(location):
793         return "{} not found in {}".format(name, location)
794     with salt.utils.winapi.Com():
795         task_service = win32com.client.Dispatch("Schedule.Service")
796         task_service.Connect()
797         task_folder = task_service.GetFolder(location)
798         task = task_folder.GetTask(name)
799         try:
800             task.Run("")
801             return True
802         except pythoncom.com_error:
803             return False
804 def run_wait(name, location="\\"):
805     r"""
806     Run a scheduled task and return when the task finishes
807     Args:
808         name (str):
809             The name of the task to run.
810         location (str):
811             A string value representing the location of the task. Default is
812             ``\`` which is the root for the task scheduler
813             (``C:\Windows\System32\tasks``).
814     Returns:
815         bool: ``True`` if successful, otherwise ``False``
816     CLI Example:
817     .. code-block:: bash
818         salt 'minion-id' task.run_wait &lt;task_name&gt;
819     """
820     if name not in list_tasks(location):
821         return "{} not found in {}".format(name, location)
822     with salt.utils.winapi.Com():
823         task_service = win32com.client.Dispatch("Schedule.Service")
824         task_service.Connect()
825         task_folder = task_service.GetFolder(location)
826         task = task_folder.GetTask(name)
827         if task.State == TASK_STATE_RUNNING:
828             return "Task already running"
829         try:
830             task.Run("")
831             time.sleep(1)
832             running = True
833         except pythoncom.com_error:
834             return False
835         while running:
836             running = False
837             try:
838                 running_tasks = task_service.GetRunningTasks(0)
839                 if running_tasks.Count:
840                     for item in running_tasks:
841                         if item.Name == name:
842                             running = True
843             except pythoncom.com_error:
844                 running = False
845     return True
846 def stop(name, location="\\"):
847     r"""
848     Stop a scheduled task.
849     Args:
850         name (str):
851             The name of the task to stop.
852         location (str):
853             A string value representing the location of the task. Default is
854             ``\`` which is the root for the task scheduler
855             (``C:\Windows\System32\tasks``).
856     Returns:
857         bool: ``True`` if successful, otherwise ``False``
858     CLI Example:
859     .. code-block:: bash
860         salt 'minion-id' task.list_stop &lt;task_name&gt;
861     """
862     if name not in list_tasks(location):
863         return "{} not found in {}".format(name, location)
864     with salt.utils.winapi.Com():
865         task_service = win32com.client.Dispatch("Schedule.Service")
866         task_service.Connect()
867         task_folder = task_service.GetFolder(location)
868         task = task_folder.GetTask(name)
869         try:
870             task.Stop(0)
871             return True
872         except pythoncom.com_error:
873             return False
874 def status(name, location="\\"):
875     r"""
876     Determine the status of a task. Is it Running, Queued, Ready, etc.
877     Args:
878         name (str):
879             The name of the task for which to return the status
880         location (str):
881             A string value representing the location of the task. Default is
882             ``\`` which is the root for the task scheduler
883             (``C:\Windows\System32\tasks``).
884     Returns:
885         str: The current status of the task. Will be one of the following:
886             - Unknown
887             - Disabled
888             - Queued
889             - Ready
890             - Running
891     CLI Example:
892     .. code-block:: bash
893         salt 'minion-id' task.list_status &lt;task_name&gt;
894     """
895     if name not in list_tasks(location):
896         return "{} not found in {}".format(name, location)
897     with salt.utils.winapi.Com():
898         task_service = win32com.client.Dispatch("Schedule.Service")
899         task_service.Connect()
900         task_folder = task_service.GetFolder(location)
901         task = task_folder.GetTask(name)
902         return states[task.State]
903 def info(name, location="\\"):
904     r"""
905     Get the details about a task in the task scheduler.
906     Args:
907         name (str):
908             The name of the task for which to return the status
909         location (str):
910             A string value representing the location of the task. Default is
911             ``\`` which is the root for the task scheduler
912             (``C:\Windows\System32\tasks``).
913     Returns:
914         dict: A dictionary containing the task configuration
915     CLI Example:
916     .. code-block:: bash
917         salt 'minion-id' task.info &lt;task_name&gt;
918     """
919     if name not in list_tasks(location):
920         return "{} not found in {}".format(name, location)
921     with salt.utils.winapi.Com():
922         task_service = win32com.client.Dispatch("Schedule.Service")
923         task_service.Connect()
924         task_folder = task_service.GetFolder(location)
925         task = task_folder.GetTask(name)
926         properties = {
927             "enabled": task.Enabled,
928             "last_run": _get_date_value(task.LastRunTime),
929             "last_run_result": results[task.LastTaskResult],
930             "missed_runs": task.NumberOfMissedRuns,
931             "next_run": _get_date_value(task.NextRunTime),
932             "status": states[task.State],
933         }
934         def_set = task.Definition.Settings
935         settings = {
936             "allow_demand_start": def_set.AllowDemandStart,
937             "force_stop": def_set.AllowHardTerminate,
938         }
939         if def_set.DeleteExpiredTaskAfter == "":
940             settings["delete_after"] = False
941         elif def_set.DeleteExpiredTaskAfter == "PT0S":
942             settings["delete_after"] = "Immediately"
943         else:
944             settings["delete_after"] = _reverse_lookup(
945                 duration, def_set.DeleteExpiredTaskAfter
946             )
947         if def_set.ExecutionTimeLimit == "":
948             settings["execution_time_limit"] = False
949         else:
950             settings["execution_time_limit"] = _reverse_lookup(
951                 duration, def_set.ExecutionTimeLimit
952             )
953         settings["multiple_instances"] = _reverse_lookup(
954             instances, def_set.MultipleInstances
955         )
956         if def_set.RestartInterval == "":
957             settings["restart_interval"] = False
958         else:
959             settings["restart_interval"] = _reverse_lookup(
960                 duration, def_set.RestartInterval
961             )
962         if settings["restart_interval"]:
963             settings["restart_count"] = def_set.RestartCount
964         settings["stop_if_on_batteries"] = def_set.StopIfGoingOnBatteries
965         settings["wake_to_run"] = def_set.WakeToRun
966         conditions = {
967             "ac_only": def_set.DisallowStartIfOnBatteries,
968             "run_if_idle": def_set.RunOnlyIfIdle,
969             "run_if_network": def_set.RunOnlyIfNetworkAvailable,
970             "start_when_available": def_set.StartWhenAvailable,
971         }
972         if conditions["run_if_idle"]:
973             idle_set = def_set.IdleSettings
974             conditions["idle_duration"] = idle_set.IdleDuration
975             conditions["idle_restart"] = idle_set.RestartOnIdle
976             conditions["idle_stop_on_end"] = idle_set.StopOnIdleEnd
977             conditions["idle_wait_timeout"] = idle_set.WaitTimeout
978         if conditions["run_if_network"]:
979             net_set = def_set.NetworkSettings
980             conditions["network_id"] = net_set.Id
981             conditions["network_name"] = net_set.Name
982         actions = []
983         for actionObj in task.Definition.Actions:
984             action = {"action_type": _reverse_lookup(action_types, actionObj.Type)}
985             if actionObj.Path:
986                 action["cmd"] = actionObj.Path
987             if actionObj.Arguments:
988                 action["arguments"] = actionObj.Arguments
989             if actionObj.WorkingDirectory:
990                 action["working_dir"] = actionObj.WorkingDirectory
991             actions.append(action)
992         triggers = []
993         for triggerObj in task.Definition.Triggers:
994             trigger = {"trigger_type": _reverse_lookup(trigger_types, triggerObj.Type)}
995             if triggerObj.ExecutionTimeLimit:
996                 trigger["execution_time_limit"] = _reverse_lookup(
997                     duration, triggerObj.ExecutionTimeLimit
998                 )
999             if triggerObj.StartBoundary:
1000                 start_date, start_time = triggerObj.StartBoundary.split("T", 1)
1001                 trigger["start_date"] = start_date
1002                 trigger["start_time"] = start_time
1003             if triggerObj.EndBoundary:
1004                 end_date, end_time = triggerObj.EndBoundary.split("T", 1)
1005                 trigger["end_date"] = end_date
1006                 trigger["end_time"] = end_time
1007             trigger["enabled"] = triggerObj.Enabled
1008             if hasattr(triggerObj, "RandomDelay"):
1009                 if triggerObj.RandomDelay:
1010                     trigger["random_delay"] = _reverse_lookup(
1011                         duration, triggerObj.RandomDelay
1012                     )
1013                 else:
1014                     trigger["random_delay"] = False
1015             if hasattr(triggerObj, "Delay"):
1016                 if triggerObj.Delay:
1017                     trigger["delay"] = _reverse_lookup(duration, triggerObj.Delay)
1018                 else:
1019                     trigger["delay"] = False
1020             triggers.append(trigger)
1021         properties["settings"] = settings
1022         properties["conditions"] = conditions
1023         properties["actions"] = actions
1024         properties["triggers"] = triggers
1025         ret = properties
1026     return ret
1027 def add_action(name=None, location="\\", action_type="Execute", **kwargs):
1028     r"""
1029     Add an action to a task.
1030     Args:
1031         name (str):
1032             The name of the task to which to add the action.
1033         location (str):
1034             A string value representing the location of the task. Default is
1035             ``\`` which is the root for the task scheduler
1036             (``C:\Windows\System32\tasks``).
1037         action_type (str):
1038             The type of action to add. There are three action types. Each one
1039             requires its own set of Keyword Arguments (kwargs). Valid values
1040             are:
1041                 - Execute
1042                 - Email
1043                 - Message
1044     Required arguments for each action_type:
1045     **Execute**
1046         Execute a command or an executable
1047             cmd (str):
1048                 (required) The command or executable to run.
1049             arguments (str):
1050                 (optional) Arguments to be passed to the command or executable.
1051                 To launch a script the first command will need to be the
1052                 interpreter for the script. For example, to run a vbscript you
1053                 would pass ``cscript.exe`` in the ``cmd`` parameter and pass the
1054                 script in the ``arguments`` parameter as follows:
1055                     - ``cmd='cscript.exe' arguments='c:\scripts\myscript.vbs'``
1056                 Batch files do not need an interpreter and may be passed to the
1057                 cmd parameter directly.
1058             start_in (str):
1059                 (optional) The current working directory for the command.
1060     **Email**
1061         Send and email. Requires ``server``, ``from``, and ``to`` or ``cc``.
1062             from (str): The sender
1063             reply_to (str): Who to reply to
1064             to (str): The recipient
1065             cc (str): The CC recipient
1066             bcc (str): The BCC recipient
1067             subject (str): The subject of the email
1068             body (str): The Message Body of the email
1069             server (str): The server used to send the email
1070             attachments (list):
1071                 A list of attachments. These will be the paths to the files to
1072                 attach. ie: ``attachments="['C:\attachment1.txt',
1073                 'C:\attachment2.txt']"``
1074     **Message**
1075         Display a dialog box. The task must be set to "Run only when user is
1076         logged on" in order for the dialog box to display. Both parameters are
1077         required.
1078             title (str):
1079                 The dialog box title.
1080             message (str):
1081                 The dialog box message body
1082     Returns:
1083         dict: A dictionary containing the task configuration
1084     CLI Example:
1085     .. code-block:: bash
1086         salt 'minion-id' task.add_action &lt;task_name&gt; cmd='del /Q /S C:\\Temp'
1087     """
1088     with salt.utils.winapi.Com():
1089         save_definition = False
1090         if kwargs.get("task_definition", False):
1091             task_definition = kwargs.get("task_definition")
1092         else:
1093             save_definition = True
1094             if not name:
1095                 return 'Required parameter "name" not passed'
1096             if name in list_tasks(location):
1097                 task_service = win32com.client.Dispatch("Schedule.Service")
1098                 task_service.Connect()
1099                 task_folder = task_service.GetFolder(location)
1100                 task_definition = task_folder.GetTask(name).Definition
1101             else:
1102                 return "{} not found".format(name)
1103         task_action = task_definition.Actions.Create(action_types[action_type])
1104         if action_types[action_type] == TASK_ACTION_EXEC:
1105             task_action.Id = "Execute_ID1"
1106             if kwargs.get("cmd", False):
1107                 task_action.Path = kwargs.get("cmd")
1108             else:
1109                 return 'Required parameter "cmd" not found'
1110             task_action.Arguments = kwargs.get("arguments", "")
1111             task_action.WorkingDirectory = kwargs.get("start_in", "")
1112         elif action_types[action_type] == TASK_ACTION_SEND_EMAIL:
1113             task_action.Id = "Email_ID1"
1114             if kwargs.get("server", False):
1115                 task_action.Server = kwargs.get("server")
1116             else:
1117                 return 'Required parameter "server" not found'
1118             if kwargs.get("from", False):
1119                 task_action.From = kwargs.get("from")
1120             else:
1121                 return 'Required parameter "from" not found'
1122             if kwargs.get("to", False) or kwargs.get("cc", False):
1123                 if kwargs.get("to"):
1124                     task_action.To = kwargs.get("to")
1125                 if kwargs.get("cc"):
1126                     task_action.Cc = kwargs.get("cc")
1127             else:
1128                 return 'Required parameter "to" or "cc" not found'
1129             if kwargs.get("reply_to"):
1130                 task_action.ReplyTo = kwargs.get("reply_to")
1131             if kwargs.get("bcc"):
1132                 task_action.Bcc = kwargs.get("bcc")
1133             if kwargs.get("subject"):
1134                 task_action.Subject = kwargs.get("subject")
1135             if kwargs.get("body"):
1136                 task_action.Body = kwargs.get("body")
1137             if kwargs.get("attachments"):
1138                 task_action.Attachments = kwargs.get("attachments")
1139         elif action_types[action_type] == TASK_ACTION_SHOW_MESSAGE:
1140             task_action.Id = "Message_ID1"
1141             if kwargs.get("title", False):
1142                 task_action.Title = kwargs.get("title")
1143             else:
1144                 return 'Required parameter "title" not found'
1145             if kwargs.get("message", False):
1146                 task_action.MessageBody = kwargs.get("message")
1147             else:
1148                 return 'Required parameter "message" not found'
1149         if save_definition:
1150             return _save_task_definition(
1151                 name=name,
1152                 task_folder=task_folder,
1153                 task_definition=task_definition,
1154                 user_name=task_definition.Principal.UserID,
1155                 password=None,
1156                 logon_type=task_definition.Principal.LogonType,
1157             )
1158 def _clear_actions(name, location="\\"):
1159     r"""
1160     Remove all actions from the task.
1161     :param str name: The name of the task from which to clear all actions.
1162     :param str location: A string value representing the location of the task.
1163     Default is ``\`` which is the root for the task scheduler
1164     (``C:\Windows\System32\tasks``).
1165     :return: True if successful, False if unsuccessful
1166     :rtype: bool
1167     if not trigger_type:
1168         return 'Required parameter "trigger_type" not specified'
1169     state_changes = {
1170         "ConsoleConnect": 1,
1171         "ConsoleDisconnect": 2,
1172         "RemoteConnect": 3,
1173         "RemoteDisconnect": 4,
1174         "SessionLock": 7,
1175         "SessionUnlock": 8,
1176     }
1177     days = {
1178         1: 0x1,
1179         2: 0x2,
1180         3: 0x4,
1181         4: 0x8,
1182         5: 0x10,
1183         6: 0x20,
1184         7: 0x40,
1185         8: 0x80,
1186         9: 0x100,
1187         10: 0x200,
1188         11: 0x400,
1189         12: 0x800,
1190         13: 0x1000,
1191         14: 0x2000,
1192         15: 0x4000,
1193         16: 0x8000,
1194         17: 0x10000,
1195         18: 0x20000,
1196         19: 0x40000,
1197         20: 0x80000,
1198         21: 0x100000,
1199         22: 0x200000,
1200         23: 0x400000,
1201         24: 0x800000,
1202         25: 0x1000000,
1203         26: 0x2000000,
1204         27: 0x4000000,
1205         28: 0x8000000,
1206         29: 0x10000000,
1207         30: 0x20000000,
1208         31: 0x40000000,
1209         "Last": 0x80000000,
1210     }
1211     weekdays = {
1212         "Sunday": 0x1,
1213         "Monday": 0x2,
1214         "Tuesday": 0x4,
1215         "Wednesday": 0x8,
1216         "Thursday": 0x10,
1217         "Friday": 0x20,
1218         "Saturday": 0x40,
1219     }
1220     weeks = {"First": 0x1, "Second": 0x2, "Third": 0x4, "Fourth": 0x8}
1221     months = {
1222         "January": 0x1,
1223         "February": 0x2,
1224         "March": 0x4,
1225         "April": 0x8,
1226         "May": 0x10,
1227         "June": 0x20,
1228         "July": 0x40,
1229         "August": 0x80,
1230         "September": 0x100,
1231         "October": 0x200,
1232         "November": 0x400,
1233         "December": 0x800,
1234     }
1235     if start_date:
1236         date_format = _get_date_time_format(start_date)
1237         if date_format:
1238             dt_obj = datetime.strptime(start_date, date_format)
1239         else:
1240             return "Invalid start_date"
1241     else:
1242         dt_obj = datetime.now()
1243     if start_time:
1244         time_format = _get_date_time_format(start_time)
1245         if time_format:
1246             tm_obj = datetime.strptime(start_time, time_format)
1247         else:
1248             return "Invalid start_time"
1249     else:
1250         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1251     start_boundary = "{}T{}".format(
1252         dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1253     )
1254     dt_obj = None
1255     if end_date:
1256         date_format = _get_date_time_format(end_date)
1257         if date_format:
1258             dt_obj = datetime.strptime(end_date, date_format)
1259         else:
1260             return "Invalid end_date"
1261     if end_time:
1262         time_format = _get_date_time_format(end_time)
1263         if time_format:
1264             tm_obj = datetime.strptime(end_time, time_format)
1265         else:
1266             return "Invalid end_time"
1267     else:
1268         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1269     end_boundary = None
1270     if dt_obj and tm_obj:
1271         end_boundary = "{}T{}".format(
1272             dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1273         )
1274     with salt.utils.winapi.Com():
1275         save_definition = False
1276         if kwargs.get("task_definition", False):
1277             task_definition = kwargs.get("task_definition")
1278         else:
1279             save_definition = True
1280             if not name:
1281                 return 'Required parameter "name" not passed'
1282             if name in list_tasks(location):
1283                 task_service = win32com.client.Dispatch("Schedule.Service")
1284                 task_service.Connect()
1285                 task_folder = task_service.GetFolder(location)
1286                 task_definition = task_folder.GetTask(name).Definition
1287             else:
1288                 return "{} not found".format(name)
1289         trigger = task_definition.Triggers.Create(trigger_types[trigger_type])
1290         trigger.StartBoundary = start_boundary
1291         if delay:
1292             trigger.Delay = _lookup_first(duration, delay)
1293         if random_delay:
1294             trigger.RandomDelay = _lookup_first(duration, random_delay)
1295         if repeat_interval:
1296             trigger.Repetition.Interval = _lookup_first(duration, repeat_interval)
1297             if repeat_duration:
1298                 trigger.Repetition.Duration = _lookup_first(duration, repeat_duration)
1299             trigger.Repetition.StopAtDurationEnd = repeat_stop_at_duration_end
1300         if execution_time_limit:
1301             trigger.ExecutionTimeLimit = _lookup_first(duration, execution_time_limit)
1302         if end_boundary:
1303             trigger.EndBoundary = end_boundary
1304         trigger.Enabled = trigger_enabled
1305         if trigger_types[trigger_type] == TASK_TRIGGER_EVENT:
1306             if kwargs.get("subscription", False):
1307                 trigger.Id = "Event_ID1"
1308                 trigger.Subscription = kwargs.get("subscription")
1309             else:
1310                 return 'Required parameter "subscription" not passed'
1311         elif trigger_types[trigger_type] == TASK_TRIGGER_TIME:
1312             trigger.Id = "Once_ID1"
1313         elif trigger_types[trigger_type] == TASK_TRIGGER_DAILY:
1314             trigger.Id = "Daily_ID1"
1315             trigger.DaysInterval = kwargs.get("days_interval", 1)
1316         elif trigger_types[trigger_type] == TASK_TRIGGER_WEEKLY:
1317             trigger.Id = "Weekly_ID1"
1318             trigger.WeeksInterval = kwargs.get("weeks_interval", 1)
1319             if kwargs.get("days_of_week", False):
1320                 bits_days = 0
1321                 for weekday in kwargs.get("days_of_week"):
1322                     bits_days |= weekdays[weekday]
1323                 trigger.DaysOfWeek = bits_days
1324             else:
1325                 return 'Required parameter "days_of_week" not passed'
1326         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLY:
1327             trigger.Id = "Monthly_ID1"
1328             if kwargs.get("months_of_year", False):
1329                 bits_months = 0
1330                 for month in kwargs.get("months_of_year"):
1331                     bits_months |= months[month]
1332                 trigger.MonthsOfYear = bits_months
1333             else:
1334                 return 'Required parameter "months_of_year" not passed'
1335             if kwargs.get("days_of_month", False) or kwargs.get(
1336                 "last_day_of_month", False
1337             ):
1338                 if kwargs.get("days_of_month", False):
1339                     bits_days = 0
1340                     for day in kwargs.get("days_of_month"):
1341                         bits_days |= days[day]
1342                     trigger.DaysOfMonth = bits_days
1343                 trigger.RunOnLastDayOfMonth = kwargs.get("last_day_of_month", False)
1344             else:
1345                 return (
1346                     'Monthly trigger requires "days_of_month" or "last_day_of_'
1347                     'month" parameters'
1348                 )
1349         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLYDOW:
1350             trigger.Id = "Monthly_DOW_ID1"
1351             if kwargs.get("months_of_year", False):
1352                 bits_months = 0
1353                 for month in kwargs.get("months_of_year"):
1354                     bits_months |= months[month]
1355                 trigger.MonthsOfYear = bits_months
1356             else:
1357                 return 'Required parameter "months_of_year" not passed'
1358             if kwargs.get("weeks_of_month", False) or kwargs.get(
1359                 "last_week_of_month", False
1360             ):
1361                 if kwargs.get("weeks_of_month", False):
1362                     bits_weeks = 0
1363                     for week in kwargs.get("weeks_of_month"):
1364                         bits_weeks |= weeks[week]
1365                     trigger.WeeksOfMonth = bits_weeks
1366                 trigger.RunOnLastWeekOfMonth = kwargs.get("last_week_of_month", False)
1367             else:
1368                 return (
1369                     'Monthly DOW trigger requires "weeks_of_month" or "last_'
1370                     'week_of_month" parameters'
1371                 )
1372             if kwargs.get("days_of_week", False):
1373                 bits_days = 0
1374                 for weekday in kwargs.get("days_of_week"):
1375                     bits_days |= weekdays[weekday]
1376                 trigger.DaysOfWeek = bits_days
1377             else:
1378                 return 'Required parameter "days_of_week" not passed'
1379         elif trigger_types[trigger_type] == TASK_TRIGGER_IDLE:
1380             trigger.Id = "OnIdle_ID1"
1381         elif trigger_types[trigger_type] == TASK_TRIGGER_REGISTRATION:
1382             trigger.Id = "OnTaskCreation_ID1"
1383         elif trigger_types[trigger_type] == TASK_TRIGGER_BOOT:
1384             trigger.Id = "OnBoot_ID1"
1385         elif trigger_types[trigger_type] == TASK_TRIGGER_LOGON:
1386             trigger.Id = "OnLogon_ID1"
1387         elif trigger_types[trigger_type] == TASK_TRIGGER_SESSION_STATE_CHANGE:
1388             trigger.Id = "OnSessionStateChange_ID1"
1389             if kwargs.get("session_user_name", False):
1390                 trigger.UserId = kwargs.get("session_user_name")
1391             if kwargs.get("state_change", False):
1392                 trigger.StateChange = state_changes[kwargs.get("state_change")]
1393             else:
1394                 return 'Required parameter "state_change" not passed'
1395         if save_definition:
1396             return _save_task_definition(
1397                 name=name,
1398                 task_folder=task_folder,
1399                 task_definition=task_definition,
1400                 user_name=task_definition.Principal.UserID,
1401                 password=None,
1402                 logon_type=task_definition.Principal.LogonType,
1403             )
1404 def clear_triggers(name, location="\\"):
1405     r"""
1406     Remove all triggers from the task.
1407     Args:
1408         name (str):
1409             The name of the task from which to clear all triggers.
1410         location (str):
1411             A string value representing the location of the task. Default is
1412             ``\`` which is the root for the task scheduler
1413             (``C:\Windows\System32\tasks``).
1414     Returns:
1415         bool: ``True`` if successful, otherwise ``False``
1416     CLI Example:
1417     .. code-block:: bash
1418         salt 'minion-id' task.clear_trigger &lt;task_name&gt;
1419     """
1420     if name not in list_tasks(location):
1421         return "{} not found in {}".format(name, location)
1422     with salt.utils.winapi.Com():
1423         task_service = win32com.client.Dispatch("Schedule.Service")
1424         task_service.Connect()
1425         task_folder = task_service.GetFolder(location)
1426         task_definition = task_folder.GetTask(name).Definition
1427         triggers = task_definition.Triggers
1428         triggers.Clear()
1429         return _save_task_definition(
1430             name=name,
1431             task_folder=task_folder,
1432             task_definition=task_definition,
1433             user_name=task_definition.Principal.UserID,
1434             password=None,
1435             logon_type=task_definition.Principal.LogonType,
1436         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
