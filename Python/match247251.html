<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_payload_1.py &amp; win_task.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_payload_1.py &amp; win_task.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_payload_1.py (3.9473684%)<th>win_task.py (0.65970314%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(170-173)<td><a href="#" name="0">(357-362)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_payload_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import datetime
import logging
import salt.exceptions
import salt.payload
from salt.utils import immutabletypes
from salt.utils.odict import OrderedDict
log = logging.getLogger(__name__)
def assert_no_ordered_dict(data):
    if isinstance(data, OrderedDict):
        raise AssertionError("Found an ordered dictionary")
    if isinstance(data, dict):
        for value in data.values():
            assert_no_ordered_dict(value)
    elif isinstance(data, (list, tuple)):
        for chunk in data:
            assert_no_ordered_dict(chunk)
def test_list_nested_odicts():
    idata = {"pillar": [OrderedDict(environment="dev")]}
    odata = salt.payload.loads(salt.payload.dumps(idata.copy()))
    assert_no_ordered_dict(odata)
    assert idata == odata
def test_datetime_dump_load():
    dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
    idata = {dtvalue: dtvalue}
    sdata = salt.payload.dumps(idata.copy())
    odata = salt.payload.loads(sdata)
    assert (
        sdata
        == b"\x81\xc7\x18N20010203T04:05:06.000007\xc7\x18N20010203T04:05:06.000007"
    )
    assert idata == odata
def test_verylong_dump_load():
    idata = {"jid": 20180227140750302662}
    sdata = salt.payload.dumps(idata.copy())
    odata = salt.payload.loads(sdata)
    idata["jid"] = "{}".format(idata["jid"])
    assert idata == odata
def test_immutable_dict_dump_load():
    idata = {"dict": {"key": "value"}}
    sdata = salt.payload.dumps({"dict": immutabletypes.ImmutableDict(idata["dict"])})
    odata = salt.payload.loads(sdata)
    assert idata == odata
def test_immutable_list_dump_load():
    idata = {"list": [1, 2, 3]}
    sdata = salt.payload.dumps({"list": immutabletypes.ImmutableList(idata["list"])})
    odata = salt.payload.loads(sdata)
    assert idata == odata
def test_immutable_set_dump_load():
    idata = {"set": ["red", "green", "blue"]}
    sdata = salt.payload.dumps({"set": immutabletypes.ImmutableSet(idata["set"])})
    odata = salt.payload.loads(sdata)
    assert idata == odata
def test_odict_dump_load():
    data = OrderedDict()
    data["a"] = "b"
    data["y"] = "z"
    data["j"] = "k"
    data["w"] = "x"
    sdata = salt.payload.dumps({"set": data})
    odata = salt.payload.loads(sdata)
    assert {"set": dict(data)}, odata
def test_mixed_dump_load():
    dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
    od = OrderedDict()
    od["a"] = "b"
    od["y"] = "z"
    od["j"] = "k"
    od["w"] = "x"
    idata = {
        dtvalue: dtvalue,  # datetime
        "jid": 20180227140750302662,  # long int
        "dict": immutabletypes.ImmutableDict({"key": "value"}),  # immutable dict
        "list": immutabletypes.ImmutableList([1, 2, 3]),  # immutable list
        "set": immutabletypes.ImmutableSet(("red", "green", "blue")),  # immutable set
        "odict": od,  # odict
    }
    edata = {
        dtvalue: dtvalue,  # datetime, == input
        "jid": "20180227140750302662",  # string repr of long int
        "dict": {"key": "value"},  # builtin dict
        "list": [1, 2, 3],  # builtin list
        "set": ["red", "green", "blue"],  # builtin set
        "odict": dict(od),  # builtin dict
    }
    sdata = salt.payload.dumps(idata)
    odata = salt.payload.loads(sdata)
    assert edata == odata
def test_recursive_dump_load():
    data = {"name": "roscivs"}
    data["data"] = data  # Data all the things!
    sdata = salt.payload.dumps(data)
    odata = salt.payload.loads(sdata)
    assert "recursion" in odata["data"].lower()
def test_recursive_dump_load_with_identical_non_recursive_types():
    repeating = "repeating element"
    data = {
        "a": "a",  # Test CPython implementation detail. Short
        "b": "a",  # strings are interned.
        "c": 13,  # So are small numbers.
        "d": 13,
        "fnord": repeating,
        "repeating": [
            [[[[{"one": repeating, "two": repeating}], repeating, 13, "a"]]],
            repeating,
            repeating,
            repeating,
<a name="0"></a>        ],
    }
    data["repeating"][0]<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0][0].append(data)
    sdata = salt.payload.dumps(copy.deepcopy(data))
    odata = salt.</b></font>payload.loads(sdata)
    del odata["repeating"][0][0][0][-1], data["repeating"][0][0][0][-1]
    assert odata == data
def test_raw_vs_encoding_none():
    dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
    idata = {dtvalue: "strval"}
    sdata = salt.payload.dumps(idata.copy())
    odata = salt.payload.loads(sdata, encoding=None)
    assert isinstance(odata[dtvalue], str)
def test_raw_vs_encoding_utf8():
    dtvalue = datetime.datetime(2001, 2, 3, 4, 5, 6, 7)
    idata = {dtvalue: "strval"}
    sdata = salt.payload.dumps(idata.copy())
    odata = salt.payload.loads(sdata, encoding="utf-8")
    assert isinstance(odata[dtvalue], str)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_task.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import time
from datetime import datetime
import salt.utils.platform
import salt.utils.winapi
from salt.exceptions import ArgumentValueError, CommandExecutionError
try:
    import pythoncom
    import win32com.client
    HAS_DEPENDENCIES = True
except ImportError:
    HAS_DEPENDENCIES = False
log = logging.getLogger(__name__)
__virtualname__ = "task"
TASK_ACTION_EXEC = 0
TASK_ACTION_COM_HANDLER = 5
TASK_ACTION_SEND_EMAIL = 6
TASK_ACTION_SHOW_MESSAGE = 7
TASK_COMPATIBILITY_AT = 0
TASK_COMPATIBILITY_V1 = 1
TASK_COMPATIBILITY_V2 = 2
TASK_COMPATIBILITY_V3 = 3
TASK_VALIDATE_ONLY = 0x1
TASK_CREATE = 0x2
TASK_UPDATE = 0x4
TASK_CREATE_OR_UPDATE = 0x6
TASK_DISABLE = 0x8
TASK_DONT_ADD_PRINCIPAL_ACE = 0x10
TASK_IGNORE_REGISTRATION_TRIGGERS = 0x20
TASK_INSTANCES_PARALLEL = 0
TASK_INSTANCES_QUEUE = 1
TASK_INSTANCES_IGNORE_NEW = 2
TASK_INSTANCES_STOP_EXISTING = 3
TASK_LOGON_NONE = 0
TASK_LOGON_PASSWORD = 1
TASK_LOGON_S4U = 2
TASK_LOGON_INTERACTIVE_TOKEN = 3
TASK_LOGON_GROUP = 4
TASK_LOGON_SERVICE_ACCOUNT = 5
TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = 6
TASK_RUNLEVEL_LUA = 0
TASK_RUNLEVEL_HIGHEST = 1
TASK_STATE_UNKNOWN = 0
TASK_STATE_DISABLED = 1
TASK_STATE_QUEUED = 2
TASK_STATE_READY = 3
TASK_STATE_RUNNING = 4
TASK_TRIGGER_EVENT = 0
TASK_TRIGGER_TIME = 1
TASK_TRIGGER_DAILY = 2
TASK_TRIGGER_WEEKLY = 3
TASK_TRIGGER_MONTHLY = 4
TASK_TRIGGER_MONTHLYDOW = 5
TASK_TRIGGER_IDLE = 6
TASK_TRIGGER_REGISTRATION = 7
TASK_TRIGGER_BOOT = 8
TASK_TRIGGER_LOGON = 9
TASK_TRIGGER_SESSION_STATE_CHANGE = 11
duration = {
    "Immediately": "PT0M",
    "Indefinitely": "",
    "Do not wait": "PT0M",
    "15 seconds": "PT15S",
    "30 seconds": "PT30S",
    "1 minute": "PT1M",
    "5 minutes": "PT5M",
    "10 minutes": "PT10M",
    "15 minutes": "PT15M",
    "30 minutes": "PT30M",
    "1 hour": "PT1H",
    "2 hours": "PT2H",
    "4 hours": "PT4H",
    "8 hours": "PT8H",
    "12 hours": "PT12H",
    "1 day": ["P1D", "PT24H"],
    "3 days": ["P3D", "PT72H"],
    "30 days": "P30D",
    "90 days": "P90D",
    "180 days": "P180D",
    "365 days": "P365D",
}
action_types = {
    "Execute": TASK_ACTION_EXEC,
    "Email": TASK_ACTION_SEND_EMAIL,
    "Message": TASK_ACTION_SHOW_MESSAGE,
}
trigger_types = {
    "Event": TASK_TRIGGER_EVENT,
    "Once": TASK_TRIGGER_TIME,
    "Daily": TASK_TRIGGER_DAILY,
    "Weekly": TASK_TRIGGER_WEEKLY,
    "Monthly": TASK_TRIGGER_MONTHLY,
    "MonthlyDay": TASK_TRIGGER_MONTHLYDOW,
    "OnIdle": TASK_TRIGGER_IDLE,
    "OnTaskCreation": TASK_TRIGGER_REGISTRATION,
    "OnBoot": TASK_TRIGGER_BOOT,
    "OnLogon": TASK_TRIGGER_LOGON,
    "OnSessionChange": TASK_TRIGGER_SESSION_STATE_CHANGE,
}
states = {
    TASK_STATE_UNKNOWN: "Unknown",
    TASK_STATE_DISABLED: "Disabled",
    TASK_STATE_QUEUED: "Queued",
    TASK_STATE_READY: "Ready",
    TASK_STATE_RUNNING: "Running",
}
instances = {
    "Parallel": TASK_INSTANCES_PARALLEL,
    "Queue": TASK_INSTANCES_QUEUE,
    "No New Instance": TASK_INSTANCES_IGNORE_NEW,
    "Stop Existing": TASK_INSTANCES_STOP_EXISTING,
}
results = {
    0x0: "The operation completed successfully",
    0x1: "Incorrect or unknown function called",
    0x2: "File not found",
    0xA: "The environment is incorrect",
    0x41300: "Task is ready to run at its next scheduled time",
    0x41301: "Task is currently running",
    0x41302: "Task is disabled",
    0x41303: "Task has not yet run",
    0x41304: "There are no more runs scheduled for this task",
    0x41306: "Task was terminated by the user",
    0x8004130F: "Credentials became corrupted",
    0x8004131F: "An instance of this task is already running",
    0x800710E0: "The operator or administrator has refused the request",
    0x800704DD: "The service is not available (Run only when logged in?)",
    0xC000013A: "The application terminated as a result of CTRL+C",
    0xC06D007E: "Unknown software exception",
}
def __virtual__():
    if salt.utils.platform.is_windows():
        if not HAS_DEPENDENCIES:
            log.warning("Could not load dependencies for %s", __virtualname__)
        return __virtualname__
    return False, "Module win_task: module only works on Windows systems"
def _get_date_time_format(dt_string):
    valid_formats = [
        "%I:%M:%S %p",
        "%I:%M %p",
        "%H:%M:%S",
        "%H:%M",
        "%Y-%m-%d",
        "%m-%d-%y",
        "%m-%d-%Y",
        "%m/%d/%y",
        "%m/%d/%Y",
        "%Y/%m/%d",
    ]
    for dt_format in valid_formats:
        try:
            datetime.strptime(dt_string, dt_format)
            return dt_format
        except ValueError:
            continue
    return False
def _get_date_value(date):
    try:
        return "{}".format(date)
    except ValueError:
        return "Never"
def _reverse_lookup(dictionary, value):
    value_index = -1
    for idx, dict_value in enumerate(dictionary.values()):
        if type(dict_value) == list:
            if value in dict_value:
                value_index = idx
                break
        elif value == dict_value:
            value_index = idx
            break
    return list(dictionary)[value_index]
def _lookup_first(dictionary, key):
    value = dictionary[key]
    if type(value) == list:
        return value[0]
    else:
        return value
def _save_task_definition(
    name, task_folder, task_definition, user_name, password, logon_type
):
    try:
        task_folder.RegisterTaskDefinition(
            name,
            task_definition,
            TASK_CREATE_OR_UPDATE,
            user_name,
            password,
            logon_type,
        )
        return True
    except pythoncom.com_error as error:
        hr, msg, exc, arg = error.args  # pylint: disable=W0633
        fc = {
            -2147024773: (
                "The filename, directory name, or volume label syntax is incorrect"
            ),
            -2147024894: "The system cannot find the file specified",
            -2147216615: "Required element or attribute missing",
            -2147216616: "Value incorrectly formatted or out of range",
            -2147352571: "Access denied",
        }
        try:
            failure_code = fc[exc[5]]
        except KeyError:
            failure_code = "Unknown Failure: {}".format(error)
        log.debug("Failed to modify task: %s", failure_code)
        return "Failed to modify task: {}".format(failure_code)
def list_tasks(location="\\"):
    r"""
    List all tasks located in a specific location in the task scheduler.
    Args:
        location (str):
            A string value representing the folder from which you want to list
            tasks. Default is ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        list: Returns a list of tasks
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.list_tasks
<a name="0"></a>        salt 'minion-id' task.list_tasks Microsoft\XblGameSave
    with salt<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.</b></font>GetFolder(location)
        tasks = task_folder.GetTasks(0)
        ret = []
        for task in tasks:
            ret.append(task.Name)
    return ret
def list_folders(location="\\"):
    r"""
    List all folders located in a specific location in the task scheduler.
    Args:
        location (str):
            A string value representing the folder from which you want to list
            tasks. Default is ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        list: Returns a list of folders.
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.list_folders
        salt 'minion-id' task.list_folders Microsoft
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task_definition = task_folder.GetTask(name).Definition
        triggers = task_definition.Triggers
        ret = []
        for trigger in triggers:
            ret.append(trigger.Id)
    return ret
def list_actions(name, location="\\"):
    r"""
    List all actions that pertain to a task in the specified location.
    Args:
        name (str):
            The name of the task for which list actions.
        location (str):
            A string value representing the location of the task from which to
            list actions. Default is ``\`` which is the root for the task
            scheduler (``C:\Windows\System32\tasks``).
    Returns:
        list: Returns a list of actions.
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.list_actions &lt;task_name&gt;
        salt 'minion-id' task.list_actions XblGameSaveTask Microsoft\XblGameSave
    if name in list_tasks(location) and not force:
        return "{} already exists".format(name)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_definition = task_service.NewTask(0)
        edit_task(
            task_definition=task_definition,
            user_name=user_name,
            password=password,
            **kwargs
        )
        add_action(task_definition=task_definition, **kwargs)
        add_trigger(task_definition=task_definition, **kwargs)
        task_folder = task_service.GetFolder(location)
        _save_task_definition(
            name=name,
            task_folder=task_folder,
            task_definition=task_definition,
            user_name=task_definition.Principal.UserID,
            password=password,
            logon_type=task_definition.Principal.LogonType,
        )
    return name in list_tasks(location)
def create_task_from_xml(
    name, location="\\", xml_text=None, xml_path=None, user_name="System", password=None
):
    r"""
    Create a task based on XML. Source can be a file or a string of XML.
    Args:
        name (str):
            The name of the task. This will be displayed in the task scheduler.
        location (str):
            A string value representing the location in which to create the
            task. Default is ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
        xml_text (str):
            A string of xml representing the task to be created. This will be
            overridden by ``xml_path`` if passed.
        xml_path (str):
            The path to an XML file on the local system containing the xml that
            defines the task. This will override ``xml_text``
        user_name (str):
            The user account under which to run the task. To specify the
            'System' account, use 'System'. The password will be ignored.
        password (str):
            The password to use for authentication. This should set the task to
            run whether the user is logged in or not, but is currently not
            working.
    Returns:
        bool: ``True`` if successful, otherwise ``False``
        str: A string with the error message if there is an error
    Raises:
        ArgumentValueError: If arguments are invalid
        CommandExecutionError
    CLI Example:
    .. code-block:: bash
        salt '*' task.create_task_from_xml &lt;task_name&gt; xml_path=C:\task.xml
    """
    if name in list_tasks(location):
        return "{} already exists".format(name)
    if not xml_text and not xml_path:
        raise ArgumentValueError("Must specify either xml_text or xml_path")
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        if xml_path:
            xml_text = xml_path
        task_folder = task_service.GetFolder(location)
        if user_name:
            if user_name.lower() == "system":
                logon_type = TASK_LOGON_SERVICE_ACCOUNT
                user_name = "SYSTEM"
                password = None
            else:
                if password:
                    logon_type = TASK_LOGON_PASSWORD
                else:
                    logon_type = TASK_LOGON_INTERACTIVE_TOKEN
        else:
            password = None
            logon_type = TASK_LOGON_NONE
        try:
            task_folder.RegisterTask(
                name, xml_text, TASK_CREATE, user_name, password, logon_type
            )
        except pythoncom.com_error as error:
            hr, msg, exc, arg = error.args  # pylint: disable=W0633
            error_code = hex(exc[5] + 2 ** 32)
            fc = {
                0x80041319: "Required element or attribute missing",
                0x80041318: "Value incorrectly formatted or out of range",
                0x80020005: "Access denied",
                0x80041309: "A task's trigger is not found",
                0x8004130A: (
                    "One or more of the properties required to run this "
                    "task have not been set"
                ),
                0x8004130C: (
                    "The Task Scheduler service is not installed on this computer"
                ),
                0x8004130D: "The task object could not be opened",
                0x8004130E: (
                    "The object is either an invalid task object or is not "
                    "a task object"
                ),
                0x8004130F: (
                    "No account information could be found in the Task "
                    "Scheduler security database for the task indicated"
                ),
                0x80041310: "Unable to establish existence of the account specified",
                0x80041311: (
                    "Corruption was detected in the Task Scheduler "
                    "security database; the database has been reset"
                ),
                0x80041313: "The task object version is either unsupported or invalid",
                0x80041314: (
                    "The task has been configured with an unsupported "
                    "combination of account settings and run time options"
                ),
                0x80041315: "The Task Scheduler Service is not running",
                0x80041316: "The task XML contains an unexpected node",
                0x80041317: (
                    "The task XML contains an element or attribute from an "
                    "unexpected namespace"
                ),
                0x8004131A: "The task XML is malformed",
                0x0004131C: (
                    "The task is registered, but may fail to start. Batch "
                    "logon privilege needs to be enabled for the task principal"
                ),
                0x8004131D: "The task XML contains too many nodes of the same type",
            }
            try:
                failure_code = fc[error_code]
            except KeyError:
                failure_code = "Unknown Failure: {}".format(error_code)
            finally:
                log.debug("Failed to create task: %s", failure_code)
            raise CommandExecutionError(failure_code)
    return name in list_tasks(location)
def create_folder(name, location="\\"):
    r"""
    Create a folder in which to create tasks.
    Args:
        name (str):
            The name of the folder. This will be displayed in the task
            scheduler.
        location (str):
            A string value representing the location in which to create the
            folder. Default is ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.create_folder &lt;folder_name&gt;
    """
    if name in list_folders(location):
        return "{} already exists".format(name)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task_folder.CreateFolder(name)
    return name in list_folders(location)
def edit_task(
    name=None,
    location="\\",
    user_name=None,
    password=None,
    description=None,
    enabled=None,
    hidden=None,
    run_if_idle=None,
    idle_duration=None,
    idle_wait_timeout=None,
    idle_stop_on_end=None,
    idle_restart=None,
    ac_only=None,
    stop_if_on_batteries=None,
    wake_to_run=None,
    run_if_network=None,
    network_id=None,
    network_name=None,
    allow_demand_start=None,
    start_when_available=None,
    restart_every=None,
    restart_count=3,
    execution_time_limit=None,
    force_stop=None,
    delete_after=None,
    multiple_instances=None,
    **kwargs
):
    r"""
    Edit the parameters of a task. Triggers and Actions cannot be edited yet.
    Args:
        name (str):
            The name of the task. This will be displayed in the task scheduler.
        location (str):
            A string value representing the location in which to create the
            task. Default is ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
        user_name (str):
            The user account under which to run the task. To specify the
            'System' account, use 'System'. The password will be ignored.
        password (str):
            The password to use for authentication. This should set the task to
            run whether the user is logged in or not, but is currently not
            working.
            .. note::
                The combination of user_name and password determine how the
                task runs. For example, if a username is passed without at
                password the task will only run when the user is logged in. If a
                password is passed as well the task will run whether the user is
                logged on or not. If you pass 'System' as the username the task
                will run as the system account (the password parameter is
                ignored).
        description (str):
            A string representing the text that will be displayed in the
            description field in the task scheduler.
        enabled (bool):
            A boolean value representing whether or not the task is enabled.
        hidden (bool):
            A boolean value representing whether or not the task is hidden.
        run_if_idle (bool):
            Boolean value that indicates that the Task Scheduler will run the
            task only if the computer is in an idle state.
        idle_duration (str):
            A value that indicates the amount of time that the computer must be
            in an idle state before the task is run. Valid values are:
                - 1 minute
                - 5 minutes
                - 10 minutes
                - 15 minutes
                - 30 minutes
                - 1 hour
        idle_wait_timeout (str):
            A value that indicates the amount of time that the Task Scheduler
            will wait for an idle condition to occur. Valid values are:
                - Do not wait
                - 1 minute
                - 5 minutes
                - 10 minutes
                - 15 minutes
                - 30 minutes
                - 1 hour
                - 2 hours
        idle_stop_on_end (bool):
            Boolean value that indicates that the Task Scheduler will terminate
            the task if the idle condition ends before the task is completed.
        idle_restart (bool):
            Boolean value that indicates whether the task is restarted when the
            computer cycles into an idle condition more than once.
        ac_only (bool):
            Boolean value that indicates that the Task Scheduler will launch the
            task only while on AC power.
        stop_if_on_batteries (bool):
            Boolean value that indicates that the task will be stopped if the
            computer begins to run on battery power.
        wake_to_run (bool):
            Boolean value that indicates that the Task Scheduler will wake the
            computer when it is time to run the task.
        run_if_network (bool):
            Boolean value that indicates that the Task Scheduler will run the
            task only when a network is available.
        network_id (guid):
            GUID value that identifies a network profile.
        network_name (str):
            Sets the name of a network profile. The name is used for display
            purposes.
        allow_demand_start (bool):
            Boolean value that indicates that the task can be started by using
            either the Run command or the Context menu.
        start_when_available (bool):
            Boolean value that indicates that the Task Scheduler can start the
            task at any time after its scheduled time has passed.
        restart_every (str):
            A value that specifies the interval between task restart attempts.
            Valid values are:
                - False (to disable)
                - 1 minute
                - 5 minutes
                - 10 minutes
                - 15 minutes
                - 30 minutes
                - 1 hour
                - 2 hours
        restart_count (int):
            The number of times the Task Scheduler will attempt to restart the
            task. Valid values are integers 1 - 999.
        execution_time_limit (bool, str):
            The amount of time allowed to complete the task. Valid values are:
                - False (to disable)
                - 1 hour
                - 2 hours
                - 4 hours
                - 8 hours
                - 12 hours
                - 1 day
                - 3 days
        force_stop (bool):
            Boolean value that indicates that the task may be terminated by
            using TerminateProcess.
        delete_after (bool, str):
            The amount of time that the Task Scheduler will wait before deleting
            the task after it expires. Requires a trigger with an expiration
            date. Valid values are:
                - False (to disable)
                - Immediately
                - 30 days
                - 90 days
                - 180 days
                - 365 days
        multiple_instances (str):
            Sets the policy that defines how the Task Scheduler deals with
            multiple instances of the task. Valid values are:
                - Parallel
                - Queue
                - No New Instance
                - Stop Existing
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt '*' task.edit_task &lt;task_name&gt; description='This task is awesome'
    """
    with salt.utils.winapi.Com():
        save_definition = False
        if kwargs.get("task_definition", False):
            task_definition = kwargs.get("task_definition")
        else:
            save_definition = True
            if not name:
                return 'Required parameter "name" not passed'
            if name in list_tasks(location):
                task_service = win32com.client.Dispatch("Schedule.Service")
                task_service.Connect()
                task_folder = task_service.GetFolder(location)
                task_definition = task_folder.GetTask(name).Definition
            else:
                return "{} not found".format(name)
        if save_definition:
            task_definition.RegistrationInfo.Author = "Salt Minion"
            task_definition.RegistrationInfo.Source = "Salt Minion Daemon"
        if description is not None:
            task_definition.RegistrationInfo.Description = description
        if user_name:
            if user_name.lower() == "system":
                logon_type = TASK_LOGON_SERVICE_ACCOUNT
                user_name = "SYSTEM"
                password = None
            else:
                task_definition.Principal.Id = user_name
                if password:
                    logon_type = TASK_LOGON_PASSWORD
                else:
                    logon_type = TASK_LOGON_INTERACTIVE_TOKEN
            task_definition.Principal.UserID = user_name
            task_definition.Principal.DisplayName = user_name
            task_definition.Principal.LogonType = logon_type
            task_definition.Principal.RunLevel = TASK_RUNLEVEL_HIGHEST
        else:
            user_name = None
            password = None
        if enabled is not None:
            task_definition.Settings.Enabled = enabled
        if hidden is not None:
            task_definition.Settings.Hidden = hidden
        if run_if_idle is not None:
            task_definition.Settings.RunOnlyIfIdle = run_if_idle
        if task_definition.Settings.RunOnlyIfIdle:
            if idle_stop_on_end is not None:
                task_definition.Settings.IdleSettings.StopOnIdleEnd = idle_stop_on_end
            if idle_restart is not None:
                task_definition.Settings.IdleSettings.RestartOnIdle = idle_restart
            if idle_duration is not None:
                if idle_duration in duration:
                    task_definition.Settings.IdleSettings.IdleDuration = _lookup_first(
                        duration, idle_duration
                    )
                else:
                    return 'Invalid value for "idle_duration"'
            if idle_wait_timeout is not None:
                if idle_wait_timeout in duration:
                    task_definition.Settings.IdleSettings.WaitTimeout = _lookup_first(
                        duration, idle_wait_timeout
                    )
                else:
                    return 'Invalid value for "idle_wait_timeout"'
        if ac_only is not None:
            task_definition.Settings.DisallowStartIfOnBatteries = ac_only
        if stop_if_on_batteries is not None:
            task_definition.Settings.StopIfGoingOnBatteries = stop_if_on_batteries
        if wake_to_run is not None:
            task_definition.Settings.WakeToRun = wake_to_run
        if run_if_network is not None:
            task_definition.Settings.RunOnlyIfNetworkAvailable = run_if_network
        if task_definition.Settings.RunOnlyIfNetworkAvailable:
            if network_id:
                task_definition.Settings.NetworkSettings.Id = network_id
            if network_name:
                task_definition.Settings.NetworkSettings.Name = network_name
        if allow_demand_start is not None:
            task_definition.Settings.AllowDemandStart = allow_demand_start
        if start_when_available is not None:
            task_definition.Settings.StartWhenAvailable = start_when_available
        if restart_every is not None:
            if restart_every is False:
                task_definition.Settings.RestartInterval = ""
            else:
                if restart_every in duration:
                    task_definition.Settings.RestartInterval = _lookup_first(
                        duration, restart_every
                    )
                else:
                    return 'Invalid value for "restart_every"'
        if task_definition.Settings.RestartInterval:
            if restart_count is not None:
                if restart_count in range(1, 999):
                    task_definition.Settings.RestartCount = restart_count
                else:
                    return '"restart_count" must be a value between 1 and 999'
        if execution_time_limit is not None:
            if execution_time_limit is False:
                task_definition.Settings.ExecutionTimeLimit = "PT0S"
            else:
                if execution_time_limit in duration:
                    task_definition.Settings.ExecutionTimeLimit = _lookup_first(
                        duration, execution_time_limit
                    )
                else:
                    return 'Invalid value for "execution_time_limit"'
        if force_stop is not None:
            task_definition.Settings.AllowHardTerminate = force_stop
        if delete_after is not None:
            if delete_after is False:
                task_definition.Settings.DeleteExpiredTaskAfter = ""
            if delete_after in duration:
                task_definition.Settings.DeleteExpiredTaskAfter = _lookup_first(
                    duration, delete_after
                )
            else:
                return 'Invalid value for "delete_after"'
        if multiple_instances is not None:
            task_definition.Settings.MultipleInstances = instances[multiple_instances]
        if save_definition:
            return _save_task_definition(
                name=name,
                task_folder=task_folder,
                task_definition=task_definition,
                user_name=user_name,
                password=password,
                logon_type=task_definition.Principal.LogonType,
            )
def delete_task(name, location="\\"):
    r"""
    Delete a task from the task scheduler.
    Args:
        name (str):
            The name of the task to delete.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.delete_task &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task_folder.DeleteTask(name, 0)
    return name not in list_tasks(location)
def delete_folder(name, location="\\"):
    r"""
    Delete a folder from the task scheduler.
    Args:
        name (str):
            The name of the folder to delete.
        location (str):
            A string value representing the location of the folder.  Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.delete_folder &lt;folder_name&gt;
    """
    if name not in list_folders(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task_folder.DeleteFolder(name, 0)
    return name not in list_folders(location)
def run(name, location="\\"):
    r"""
    Run a scheduled task manually.
    Args:
        name (str):
            The name of the task to run.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.run &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task = task_folder.GetTask(name)
        try:
            task.Run("")
            return True
        except pythoncom.com_error:
            return False
def run_wait(name, location="\\"):
    r"""
    Run a scheduled task and return when the task finishes
    Args:
        name (str):
            The name of the task to run.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.run_wait &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task = task_folder.GetTask(name)
        if task.State == TASK_STATE_RUNNING:
            return "Task already running"
        try:
            task.Run("")
            time.sleep(1)
            running = True
        except pythoncom.com_error:
            return False
        while running:
            running = False
            try:
                running_tasks = task_service.GetRunningTasks(0)
                if running_tasks.Count:
                    for item in running_tasks:
                        if item.Name == name:
                            running = True
            except pythoncom.com_error:
                running = False
    return True
def stop(name, location="\\"):
    r"""
    Stop a scheduled task.
    Args:
        name (str):
            The name of the task to stop.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.list_stop &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task = task_folder.GetTask(name)
        try:
            task.Stop(0)
            return True
        except pythoncom.com_error:
            return False
def status(name, location="\\"):
    r"""
    Determine the status of a task. Is it Running, Queued, Ready, etc.
    Args:
        name (str):
            The name of the task for which to return the status
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        str: The current status of the task. Will be one of the following:
            - Unknown
            - Disabled
            - Queued
            - Ready
            - Running
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.list_status &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task = task_folder.GetTask(name)
        return states[task.State]
def info(name, location="\\"):
    r"""
    Get the details about a task in the task scheduler.
    Args:
        name (str):
            The name of the task for which to return the status
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        dict: A dictionary containing the task configuration
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.info &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task = task_folder.GetTask(name)
        properties = {
            "enabled": task.Enabled,
            "last_run": _get_date_value(task.LastRunTime),
            "last_run_result": results[task.LastTaskResult],
            "missed_runs": task.NumberOfMissedRuns,
            "next_run": _get_date_value(task.NextRunTime),
            "status": states[task.State],
        }
        def_set = task.Definition.Settings
        settings = {
            "allow_demand_start": def_set.AllowDemandStart,
            "force_stop": def_set.AllowHardTerminate,
        }
        if def_set.DeleteExpiredTaskAfter == "":
            settings["delete_after"] = False
        elif def_set.DeleteExpiredTaskAfter == "PT0S":
            settings["delete_after"] = "Immediately"
        else:
            settings["delete_after"] = _reverse_lookup(
                duration, def_set.DeleteExpiredTaskAfter
            )
        if def_set.ExecutionTimeLimit == "":
            settings["execution_time_limit"] = False
        else:
            settings["execution_time_limit"] = _reverse_lookup(
                duration, def_set.ExecutionTimeLimit
            )
        settings["multiple_instances"] = _reverse_lookup(
            instances, def_set.MultipleInstances
        )
        if def_set.RestartInterval == "":
            settings["restart_interval"] = False
        else:
            settings["restart_interval"] = _reverse_lookup(
                duration, def_set.RestartInterval
            )
        if settings["restart_interval"]:
            settings["restart_count"] = def_set.RestartCount
        settings["stop_if_on_batteries"] = def_set.StopIfGoingOnBatteries
        settings["wake_to_run"] = def_set.WakeToRun
        conditions = {
            "ac_only": def_set.DisallowStartIfOnBatteries,
            "run_if_idle": def_set.RunOnlyIfIdle,
            "run_if_network": def_set.RunOnlyIfNetworkAvailable,
            "start_when_available": def_set.StartWhenAvailable,
        }
        if conditions["run_if_idle"]:
            idle_set = def_set.IdleSettings
            conditions["idle_duration"] = idle_set.IdleDuration
            conditions["idle_restart"] = idle_set.RestartOnIdle
            conditions["idle_stop_on_end"] = idle_set.StopOnIdleEnd
            conditions["idle_wait_timeout"] = idle_set.WaitTimeout
        if conditions["run_if_network"]:
            net_set = def_set.NetworkSettings
            conditions["network_id"] = net_set.Id
            conditions["network_name"] = net_set.Name
        actions = []
        for actionObj in task.Definition.Actions:
            action = {"action_type": _reverse_lookup(action_types, actionObj.Type)}
            if actionObj.Path:
                action["cmd"] = actionObj.Path
            if actionObj.Arguments:
                action["arguments"] = actionObj.Arguments
            if actionObj.WorkingDirectory:
                action["working_dir"] = actionObj.WorkingDirectory
            actions.append(action)
        triggers = []
        for triggerObj in task.Definition.Triggers:
            trigger = {"trigger_type": _reverse_lookup(trigger_types, triggerObj.Type)}
            if triggerObj.ExecutionTimeLimit:
                trigger["execution_time_limit"] = _reverse_lookup(
                    duration, triggerObj.ExecutionTimeLimit
                )
            if triggerObj.StartBoundary:
                start_date, start_time = triggerObj.StartBoundary.split("T", 1)
                trigger["start_date"] = start_date
                trigger["start_time"] = start_time
            if triggerObj.EndBoundary:
                end_date, end_time = triggerObj.EndBoundary.split("T", 1)
                trigger["end_date"] = end_date
                trigger["end_time"] = end_time
            trigger["enabled"] = triggerObj.Enabled
            if hasattr(triggerObj, "RandomDelay"):
                if triggerObj.RandomDelay:
                    trigger["random_delay"] = _reverse_lookup(
                        duration, triggerObj.RandomDelay
                    )
                else:
                    trigger["random_delay"] = False
            if hasattr(triggerObj, "Delay"):
                if triggerObj.Delay:
                    trigger["delay"] = _reverse_lookup(duration, triggerObj.Delay)
                else:
                    trigger["delay"] = False
            triggers.append(trigger)
        properties["settings"] = settings
        properties["conditions"] = conditions
        properties["actions"] = actions
        properties["triggers"] = triggers
        ret = properties
    return ret
def add_action(name=None, location="\\", action_type="Execute", **kwargs):
    r"""
    Add an action to a task.
    Args:
        name (str):
            The name of the task to which to add the action.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
        action_type (str):
            The type of action to add. There are three action types. Each one
            requires its own set of Keyword Arguments (kwargs). Valid values
            are:
                - Execute
                - Email
                - Message
    Required arguments for each action_type:
    **Execute**
        Execute a command or an executable
            cmd (str):
                (required) The command or executable to run.
            arguments (str):
                (optional) Arguments to be passed to the command or executable.
                To launch a script the first command will need to be the
                interpreter for the script. For example, to run a vbscript you
                would pass ``cscript.exe`` in the ``cmd`` parameter and pass the
                script in the ``arguments`` parameter as follows:
                    - ``cmd='cscript.exe' arguments='c:\scripts\myscript.vbs'``
                Batch files do not need an interpreter and may be passed to the
                cmd parameter directly.
            start_in (str):
                (optional) The current working directory for the command.
    **Email**
        Send and email. Requires ``server``, ``from``, and ``to`` or ``cc``.
            from (str): The sender
            reply_to (str): Who to reply to
            to (str): The recipient
            cc (str): The CC recipient
            bcc (str): The BCC recipient
            subject (str): The subject of the email
            body (str): The Message Body of the email
            server (str): The server used to send the email
            attachments (list):
                A list of attachments. These will be the paths to the files to
                attach. ie: ``attachments="['C:\attachment1.txt',
                'C:\attachment2.txt']"``
    **Message**
        Display a dialog box. The task must be set to "Run only when user is
        logged on" in order for the dialog box to display. Both parameters are
        required.
            title (str):
                The dialog box title.
            message (str):
                The dialog box message body
    Returns:
        dict: A dictionary containing the task configuration
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.add_action &lt;task_name&gt; cmd='del /Q /S C:\\Temp'
    """
    with salt.utils.winapi.Com():
        save_definition = False
        if kwargs.get("task_definition", False):
            task_definition = kwargs.get("task_definition")
        else:
            save_definition = True
            if not name:
                return 'Required parameter "name" not passed'
            if name in list_tasks(location):
                task_service = win32com.client.Dispatch("Schedule.Service")
                task_service.Connect()
                task_folder = task_service.GetFolder(location)
                task_definition = task_folder.GetTask(name).Definition
            else:
                return "{} not found".format(name)
        task_action = task_definition.Actions.Create(action_types[action_type])
        if action_types[action_type] == TASK_ACTION_EXEC:
            task_action.Id = "Execute_ID1"
            if kwargs.get("cmd", False):
                task_action.Path = kwargs.get("cmd")
            else:
                return 'Required parameter "cmd" not found'
            task_action.Arguments = kwargs.get("arguments", "")
            task_action.WorkingDirectory = kwargs.get("start_in", "")
        elif action_types[action_type] == TASK_ACTION_SEND_EMAIL:
            task_action.Id = "Email_ID1"
            if kwargs.get("server", False):
                task_action.Server = kwargs.get("server")
            else:
                return 'Required parameter "server" not found'
            if kwargs.get("from", False):
                task_action.From = kwargs.get("from")
            else:
                return 'Required parameter "from" not found'
            if kwargs.get("to", False) or kwargs.get("cc", False):
                if kwargs.get("to"):
                    task_action.To = kwargs.get("to")
                if kwargs.get("cc"):
                    task_action.Cc = kwargs.get("cc")
            else:
                return 'Required parameter "to" or "cc" not found'
            if kwargs.get("reply_to"):
                task_action.ReplyTo = kwargs.get("reply_to")
            if kwargs.get("bcc"):
                task_action.Bcc = kwargs.get("bcc")
            if kwargs.get("subject"):
                task_action.Subject = kwargs.get("subject")
            if kwargs.get("body"):
                task_action.Body = kwargs.get("body")
            if kwargs.get("attachments"):
                task_action.Attachments = kwargs.get("attachments")
        elif action_types[action_type] == TASK_ACTION_SHOW_MESSAGE:
            task_action.Id = "Message_ID1"
            if kwargs.get("title", False):
                task_action.Title = kwargs.get("title")
            else:
                return 'Required parameter "title" not found'
            if kwargs.get("message", False):
                task_action.MessageBody = kwargs.get("message")
            else:
                return 'Required parameter "message" not found'
        if save_definition:
            return _save_task_definition(
                name=name,
                task_folder=task_folder,
                task_definition=task_definition,
                user_name=task_definition.Principal.UserID,
                password=None,
                logon_type=task_definition.Principal.LogonType,
            )
def _clear_actions(name, location="\\"):
    r"""
    Remove all actions from the task.
    :param str name: The name of the task from which to clear all actions.
    :param str location: A string value representing the location of the task.
    Default is ``\`` which is the root for the task scheduler
    (``C:\Windows\System32\tasks``).
    :return: True if successful, False if unsuccessful
    :rtype: bool
    if not trigger_type:
        return 'Required parameter "trigger_type" not specified'
    state_changes = {
        "ConsoleConnect": 1,
        "ConsoleDisconnect": 2,
        "RemoteConnect": 3,
        "RemoteDisconnect": 4,
        "SessionLock": 7,
        "SessionUnlock": 8,
    }
    days = {
        1: 0x1,
        2: 0x2,
        3: 0x4,
        4: 0x8,
        5: 0x10,
        6: 0x20,
        7: 0x40,
        8: 0x80,
        9: 0x100,
        10: 0x200,
        11: 0x400,
        12: 0x800,
        13: 0x1000,
        14: 0x2000,
        15: 0x4000,
        16: 0x8000,
        17: 0x10000,
        18: 0x20000,
        19: 0x40000,
        20: 0x80000,
        21: 0x100000,
        22: 0x200000,
        23: 0x400000,
        24: 0x800000,
        25: 0x1000000,
        26: 0x2000000,
        27: 0x4000000,
        28: 0x8000000,
        29: 0x10000000,
        30: 0x20000000,
        31: 0x40000000,
        "Last": 0x80000000,
    }
    weekdays = {
        "Sunday": 0x1,
        "Monday": 0x2,
        "Tuesday": 0x4,
        "Wednesday": 0x8,
        "Thursday": 0x10,
        "Friday": 0x20,
        "Saturday": 0x40,
    }
    weeks = {"First": 0x1, "Second": 0x2, "Third": 0x4, "Fourth": 0x8}
    months = {
        "January": 0x1,
        "February": 0x2,
        "March": 0x4,
        "April": 0x8,
        "May": 0x10,
        "June": 0x20,
        "July": 0x40,
        "August": 0x80,
        "September": 0x100,
        "October": 0x200,
        "November": 0x400,
        "December": 0x800,
    }
    if start_date:
        date_format = _get_date_time_format(start_date)
        if date_format:
            dt_obj = datetime.strptime(start_date, date_format)
        else:
            return "Invalid start_date"
    else:
        dt_obj = datetime.now()
    if start_time:
        time_format = _get_date_time_format(start_time)
        if time_format:
            tm_obj = datetime.strptime(start_time, time_format)
        else:
            return "Invalid start_time"
    else:
        tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
    start_boundary = "{}T{}".format(
        dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
    )
    dt_obj = None
    if end_date:
        date_format = _get_date_time_format(end_date)
        if date_format:
            dt_obj = datetime.strptime(end_date, date_format)
        else:
            return "Invalid end_date"
    if end_time:
        time_format = _get_date_time_format(end_time)
        if time_format:
            tm_obj = datetime.strptime(end_time, time_format)
        else:
            return "Invalid end_time"
    else:
        tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
    end_boundary = None
    if dt_obj and tm_obj:
        end_boundary = "{}T{}".format(
            dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
        )
    with salt.utils.winapi.Com():
        save_definition = False
        if kwargs.get("task_definition", False):
            task_definition = kwargs.get("task_definition")
        else:
            save_definition = True
            if not name:
                return 'Required parameter "name" not passed'
            if name in list_tasks(location):
                task_service = win32com.client.Dispatch("Schedule.Service")
                task_service.Connect()
                task_folder = task_service.GetFolder(location)
                task_definition = task_folder.GetTask(name).Definition
            else:
                return "{} not found".format(name)
        trigger = task_definition.Triggers.Create(trigger_types[trigger_type])
        trigger.StartBoundary = start_boundary
        if delay:
            trigger.Delay = _lookup_first(duration, delay)
        if random_delay:
            trigger.RandomDelay = _lookup_first(duration, random_delay)
        if repeat_interval:
            trigger.Repetition.Interval = _lookup_first(duration, repeat_interval)
            if repeat_duration:
                trigger.Repetition.Duration = _lookup_first(duration, repeat_duration)
            trigger.Repetition.StopAtDurationEnd = repeat_stop_at_duration_end
        if execution_time_limit:
            trigger.ExecutionTimeLimit = _lookup_first(duration, execution_time_limit)
        if end_boundary:
            trigger.EndBoundary = end_boundary
        trigger.Enabled = trigger_enabled
        if trigger_types[trigger_type] == TASK_TRIGGER_EVENT:
            if kwargs.get("subscription", False):
                trigger.Id = "Event_ID1"
                trigger.Subscription = kwargs.get("subscription")
            else:
                return 'Required parameter "subscription" not passed'
        elif trigger_types[trigger_type] == TASK_TRIGGER_TIME:
            trigger.Id = "Once_ID1"
        elif trigger_types[trigger_type] == TASK_TRIGGER_DAILY:
            trigger.Id = "Daily_ID1"
            trigger.DaysInterval = kwargs.get("days_interval", 1)
        elif trigger_types[trigger_type] == TASK_TRIGGER_WEEKLY:
            trigger.Id = "Weekly_ID1"
            trigger.WeeksInterval = kwargs.get("weeks_interval", 1)
            if kwargs.get("days_of_week", False):
                bits_days = 0
                for weekday in kwargs.get("days_of_week"):
                    bits_days |= weekdays[weekday]
                trigger.DaysOfWeek = bits_days
            else:
                return 'Required parameter "days_of_week" not passed'
        elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLY:
            trigger.Id = "Monthly_ID1"
            if kwargs.get("months_of_year", False):
                bits_months = 0
                for month in kwargs.get("months_of_year"):
                    bits_months |= months[month]
                trigger.MonthsOfYear = bits_months
            else:
                return 'Required parameter "months_of_year" not passed'
            if kwargs.get("days_of_month", False) or kwargs.get(
                "last_day_of_month", False
            ):
                if kwargs.get("days_of_month", False):
                    bits_days = 0
                    for day in kwargs.get("days_of_month"):
                        bits_days |= days[day]
                    trigger.DaysOfMonth = bits_days
                trigger.RunOnLastDayOfMonth = kwargs.get("last_day_of_month", False)
            else:
                return (
                    'Monthly trigger requires "days_of_month" or "last_day_of_'
                    'month" parameters'
                )
        elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLYDOW:
            trigger.Id = "Monthly_DOW_ID1"
            if kwargs.get("months_of_year", False):
                bits_months = 0
                for month in kwargs.get("months_of_year"):
                    bits_months |= months[month]
                trigger.MonthsOfYear = bits_months
            else:
                return 'Required parameter "months_of_year" not passed'
            if kwargs.get("weeks_of_month", False) or kwargs.get(
                "last_week_of_month", False
            ):
                if kwargs.get("weeks_of_month", False):
                    bits_weeks = 0
                    for week in kwargs.get("weeks_of_month"):
                        bits_weeks |= weeks[week]
                    trigger.WeeksOfMonth = bits_weeks
                trigger.RunOnLastWeekOfMonth = kwargs.get("last_week_of_month", False)
            else:
                return (
                    'Monthly DOW trigger requires "weeks_of_month" or "last_'
                    'week_of_month" parameters'
                )
            if kwargs.get("days_of_week", False):
                bits_days = 0
                for weekday in kwargs.get("days_of_week"):
                    bits_days |= weekdays[weekday]
                trigger.DaysOfWeek = bits_days
            else:
                return 'Required parameter "days_of_week" not passed'
        elif trigger_types[trigger_type] == TASK_TRIGGER_IDLE:
            trigger.Id = "OnIdle_ID1"
        elif trigger_types[trigger_type] == TASK_TRIGGER_REGISTRATION:
            trigger.Id = "OnTaskCreation_ID1"
        elif trigger_types[trigger_type] == TASK_TRIGGER_BOOT:
            trigger.Id = "OnBoot_ID1"
        elif trigger_types[trigger_type] == TASK_TRIGGER_LOGON:
            trigger.Id = "OnLogon_ID1"
        elif trigger_types[trigger_type] == TASK_TRIGGER_SESSION_STATE_CHANGE:
            trigger.Id = "OnSessionStateChange_ID1"
            if kwargs.get("session_user_name", False):
                trigger.UserId = kwargs.get("session_user_name")
            if kwargs.get("state_change", False):
                trigger.StateChange = state_changes[kwargs.get("state_change")]
            else:
                return 'Required parameter "state_change" not passed'
        if save_definition:
            return _save_task_definition(
                name=name,
                task_folder=task_folder,
                task_definition=task_definition,
                user_name=task_definition.Principal.UserID,
                password=None,
                logon_type=task_definition.Principal.LogonType,
            )
def clear_triggers(name, location="\\"):
    r"""
    Remove all triggers from the task.
    Args:
        name (str):
            The name of the task from which to clear all triggers.
        location (str):
            A string value representing the location of the task. Default is
            ``\`` which is the root for the task scheduler
            (``C:\Windows\System32\tasks``).
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt 'minion-id' task.clear_trigger &lt;task_name&gt;
    """
    if name not in list_tasks(location):
        return "{} not found in {}".format(name, location)
    with salt.utils.winapi.Com():
        task_service = win32com.client.Dispatch("Schedule.Service")
        task_service.Connect()
        task_folder = task_service.GetFolder(location)
        task_definition = task_folder.GetTask(name).Definition
        triggers = task_definition.Triggers
        triggers.Clear()
        return _save_task_definition(
            name=name,
            task_folder=task_folder,
            task_definition=task_definition,
            user_name=task_definition.Principal.UserID,
            password=None,
            logon_type=task_definition.Principal.LogonType,
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
