<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_autoruns.py &amp; saltcheck_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_autoruns.py &amp; saltcheck_1.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_autoruns.py (14.772727%)<th>saltcheck_1.py (0.94545454%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-28)<td><a href="#" name="0">(324-339)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_autoruns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import salt.utils.platform
3 __virtualname__ <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "autoruns"
4 def __virtual__():
5     if salt.utils.platform.is_windows():
6         return __virtualname__
7     return (False, "Module win_autoruns: module only works on Windows systems")
8 def</b></font> _get_dirs(user_dir, startup_dir):
9     try:
10         users = os.listdir(user_dir)
11     except OSError:  # pylint: disable=E0602
12         users = []
13     full_dirs = []
14     for user in users:
15         full_dir = os.path.join(user_dir, user, startup_dir)
16         if os.path.exists(full_dir):
17             full_dirs.append(full_dir)
18     return full_dirs
19 def list_():
20     autoruns = {}
21     keys = [
22         "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
23         "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /reg:64",
24         "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
25     ]
26     for key in keys:
27         autoruns[key] = []
28         cmd = ["reg", "query", key]
29         for line in __salt__["cmd.run"](cmd, python_shell=False).splitlines():
30             if (
31                 line and line[0:4] != "HKEY" and line[0:5] != "ERROR"
32             ):  # Remove junk lines
33                 autoruns[key].append(line)
34     user_dir = "C:\\Documents and Settings\\"
35     startup_dir = "\\Start Menu\\Programs\\Startup"
36     full_dirs = _get_dirs(user_dir, startup_dir)
37     if not full_dirs:
38         user_dir = "C:\\Users\\"
39         startup_dir = (
40             "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
41         )
42         full_dirs = _get_dirs(user_dir, startup_dir)
43     for full_dir in full_dirs:
44         files = os.listdir(full_dir)
45         autoruns[full_dir] = []
46         for single_file in files:
47             autoruns[full_dir].append(single_file)
48     return autoruns
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltcheck_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import multiprocessing
4 import os
5 import time
6 import salt.client
7 import salt.exceptions
8 import salt.utils.data
9 import salt.utils.files
10 import salt.utils.functools
11 import salt.utils.path
12 import salt.utils.platform
13 import salt.utils.yaml
14 from salt.defaults import DEFAULT_TARGET_DELIM
15 from salt.utils.decorators import memoize
16 from salt.utils.json import dumps, loads
17 from salt.utils.odict import OrderedDict
18 log = logging.getLogger(__name__)
19 global_scheck = None
20 __virtualname__ <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "saltcheck"
21 def __virtual__():
22     if not salt.utils.platform.is_proxy():
23         return __virtualname__
24     return (
25         False,
26         "The saltcheck execution module failed to load: only available on minions.",
27     )
28 def</b></font> run_test(**kwargs):
29     scheck = SaltCheck()
30     test = kwargs.get("test", None)
31     if test and isinstance(test, dict):
32         return scheck.run_test(test)
33     else:
34         return "Test argument must be a dictionary"
35 def state_apply(state_name, **kwargs):
36     conf_file = copy.deepcopy(__opts__["conf_file"])
37     local_opts = salt.config.minion_config(conf_file)
38     if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
39         local_opts["file_client"] = "local"
40         log.debug("Detected salt-ssh, running as local")
41     caller = salt.client.Caller(mopts=local_opts)
42     if kwargs:
43         return caller.cmd("state.apply", state_name, **kwargs)
44     else:
45         return caller.cmd("state.apply", state_name)
46 def report_highstate_tests(saltenv=None):
47     if not saltenv:
48         if "saltenv" in __opts__ and __opts__["saltenv"]:
49             saltenv = __opts__["saltenv"]
50         else:
51             saltenv = "base"
52     sls_list = []
53     sls_list = _get_top_states(saltenv)
54     stl = StateTestLoader(saltenv)
55     missing_tests = 0
56     states_missing_tests = []
57     for state_name in sls_list:
58         stl.add_test_files_for_sls(state_name, False)
59         if state_name not in stl.found_states:
60             missing_tests = missing_tests + 1
61             states_missing_tests.append(state_name)
62     __context__["retcode"] = missing_tests
63     return {
64         "TEST REPORT RESULTS": {
65             "Missing Tests": missing_tests,
66             "States missing tests": states_missing_tests,
67             "States with tests": stl.found_states,
68         }
69     }
70 def run_state_tests(state, saltenv=None, check_all=False, only_fails=False):
71     if not saltenv:
72         if "saltenv" in __opts__ and __opts__["saltenv"]:
73             saltenv = __opts__["saltenv"]
74         else:
75             saltenv = "base"
76     global global_scheck
77     global_scheck = SaltCheck(saltenv)
78     parallel = __salt__["config.get"]("saltcheck_parallel")
79     num_proc = __salt__["config.get"]("saltcheck_processes")
80     stl = StateTestLoader(saltenv)
81     results = OrderedDict()
82     sls_list = salt.utils.args.split_input(state)
83     for state_name in sls_list:
84         stl.add_test_files_for_sls(state_name, check_all)
85         stl.load_test_suite()
86         results_dict = OrderedDict()
87         if parallel:
88             if type(num_proc) == float:
89                 num_proc = int(num_proc)
90             if multiprocessing.cpu_count() &lt; 2:
91                 parallel = False
92                 log.debug("Only 1 CPU. Disabling parallization.")
93             elif num_proc == 1:
94                 parallel = False
95                 log.debug("Configuration limited to 1 CPU. Disabling parallization.")
96             else:
97                 for items in stl.test_dict.values():
98                     if "state.apply" in items.get("module_and_function", []):
99                         parallel = False
100                         log.warning(
101                             "Tests include state.apply. Disabling parallization."
102                         )
103         if parallel:
104             if num_proc:
105                 pool_size = num_proc
106             else:
107                 pool_size = min(len(stl.test_dict), multiprocessing.cpu_count())
108             log.debug("Running tests in parallel with %s processes", pool_size)
109             presults = multiprocessing.Pool(pool_size).map(
110                 func=parallel_scheck, iterable=stl.test_dict.items()
111             )
112             for item in presults:
113                 for key, value in item.items():
114                     results_dict[key] = value
115         else:
116             for key, value in stl.test_dict.items():
117                 result = global_scheck.run_test(value)
118                 results_dict[key] = result
119         if not results.get(state_name):
120             results[state_name] = results_dict
121     return _generate_out_list(results, only_fails=only_fails)
122 def parallel_scheck(data):
123     key = data[0]
124     value = data[1]
125     results = {}
126     results[key] = global_scheck.run_test(value)
127     return results
128 run_state_tests_ssh = salt.utils.functools.alias_function(
129     run_state_tests, "run_state_tests_ssh"
130 )
131 def run_highstate_tests(saltenv=None, only_fails=False):
132     if not saltenv:
133         if "saltenv" in __opts__ and __opts__["saltenv"]:
134             saltenv = __opts__["saltenv"]
135         else:
136             saltenv = "base"
137     sls_list = []
138     sls_list = _get_top_states(saltenv)
139     all_states = ",".join(sls_list)
140     return run_state_tests(all_states, saltenv=saltenv, only_fails=only_fails)
141 def _eval_failure_only_print(state_name, results, only_fails):
142     if only_fails:
143         failed_tests = {}
144         for test in results[state_name]:
145             if results[state_name][test]["status"].startswith("Fail"):
146                 if failed_tests.get(state_name):
147                     failed_tests[state_name].update({test: results[state_name][test]})
148                 else:
149                     failed_tests[state_name] = {test: results[state_name][test]}
150         return failed_tests
151     else:
152         return {state_name: results[state_name]}
153 def _generate_out_list(results, only_fails=False):
154     passed = 0
155     failed = 0
156     skipped = 0
157     missing_tests = 0
158     total_time = 0.0
159     out_list = []
160     for state in results:
161         if not results[state].items():
162             missing_tests = missing_tests + 1
163         else:
164             for _, val in results[state].items():
165                 if val["status"].startswith("Pass"):
166                     passed = passed + 1
167                 if val["status"].startswith("Fail"):
168                     failed = failed + 1
169                 if val["status"].startswith("Skip"):
170                     skipped = skipped + 1
171                 total_time = total_time + float(val["duration"])
172         out_list.append(_eval_failure_only_print(state, results, only_fails))
173     out_list = sorted(out_list, key=lambda x: sorted(x.keys()))
174     out_list.append(
175         {
176             "TEST RESULTS": {
177                 "Execution Time": round(total_time, 4),
178                 "Passed": passed,
179                 "Failed": failed,
180                 "Skipped": skipped,
181                 "Missing Tests": missing_tests,
182             }
183         }
184     )
185     __context__["retcode"] = 1 if failed else 0
186     return out_list
187 def _render_file(file_path):
188     rendered = __salt__["slsutil.renderer"](file_path, saltenv=global_scheck.saltenv)
189     log.info("rendered: %s", rendered)
190     return rendered
191 @memoize
192 def _is_valid_module(module):
193     modules = __salt__["sys.list_modules"]()
194     return bool(module in modules)
195 @memoize
196 def _is_valid_function(module_name, function):
197     try:
198         functions = __salt__["sys.list_functions"](module_name)
199     except salt.exceptions.SaltException:
200         functions = ["unable to look up functions"]
201     return "{}.{}".format(module_name, function) in functions
202 def _get_top_states(saltenv="base"):
203     top_states = []
204     top_states = __salt__["state.show_top"]()[saltenv]
205     log.debug("saltcheck for saltenv: %s found top states: %s", saltenv, top_states)
206     return top_states
207 class SaltCheck:
208     def __init__(self, saltenv="base"):
209         self.sls_list_state = []
210         self.modules = []
211         self.results_dict = {}
212         self.results_dict_summary = {}
213         self.saltenv = saltenv
214         self.assertions_list = """assertEqual assertNotEqual
215                                   assertTrue assertFalse
216                                   assertIn assertNotIn
217                                   assertGreater
218                                   assertGreaterEqual
219                                   assertLess assertLessEqual
220                                   assertEmpty assertNotEmpty""".split()
221     def _check_assertions(self, dict):
222         is_valid = True
223         assertion = dict.get("assertion", None)
224         exp_ret_key = any(
225             key in dict.keys() for key in ["expected_return", "expected-return"]
226         )
227         exp_ret_val = dict.get("expected_return", dict.get("expected-return", None))
228         if assertion not in self.assertions_list:
229             log.error("Saltcheck: %s is not in the assertions list", assertion)
230             is_valid = False
231         if assertion not in [
232             "assertEmpty",
233             "assertNotEmpty",
234             "assertTrue",
235             "assertFalse",
236         ]:
237             if exp_ret_key is None:
238                 log.error("Saltcheck: missing expected_return")
239                 is_valid = False
240             if exp_ret_val is None:
241                 log.error("Saltcheck: expected_return missing a value")
242                 is_valid = False
243         return is_valid
244     def __is_valid_test(self, test_dict):
245         log.info("Saltcheck: validating data: %s", test_dict)
246         is_valid = True
247         skip = test_dict.get("skip", False)
248         m_and_f = test_dict.get("module_and_function", None)
249         if m_and_f == "saltcheck.state_apply":
250             return is_valid
251         if test_dict.get("assertions"):
252             for assertion_group in test_dict.get("assertions"):
253                 is_valid = self._check_assertions(assertion_group)
254         else:
255             is_valid = self._check_assertions(test_dict)
256         if m_and_f:
257             module, function = m_and_f.split(".")
258             if not _is_valid_module(module):
259                 is_valid = False
260                 log.error("Saltcheck: %s is not a valid module", module)
261             if not _is_valid_function(module, function):
262                 is_valid = False
263                 log.error("Saltcheck: %s is not a valid function", function)
264         else:
265             log.error("Saltcheck: missing module_and_function")
266             is_valid = False
267         return is_valid
268     def _call_salt_command(self, fun, args, kwargs):
269         conf_file = __opts__["conf_file"]
270         local_opts = salt.config.minion_config(conf_file)
271         orig_file_client = local_opts["file_client"]
272         mlocal_opts = copy.deepcopy(local_opts)
273         mlocal_opts["file_client"] = "local"
274         value = False
275         if args and kwargs:
276             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args, **kwargs)
277         elif args and not kwargs:
278             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args)
279         elif not args and kwargs:
280             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, **kwargs)
281         else:
282             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun)
283         __opts__["file_client"] = orig_file_client
284         return value
285     def _run_assertions(
286         self,
287         mod_and_func,
288         args,
289         data,
290         module_output,
291         output_details,
292         assert_print_result,
293     ):
294         value = {}
295         assertion_section = data.get("assertion_section", None)
296         assertion_section_delimiter = data.get(
297             "assertion_section_delimiter", DEFAULT_TARGET_DELIM
298         )
299         if assertion_section:
300             module_output = salt.utils.data.traverse_dict_and_list(
301                 module_output,
302                 assertion_section,
303                 default=False,
304                 delimiter=assertion_section_delimiter,
305             )
306         if mod_and_func in ["saltcheck.state_apply"]:
307             assertion = "assertNotEmpty"
308         else:
309             assertion = data["assertion"]
310         expected_return = data.get("expected_return", data.get("expected-return", None))
311         if assertion not in [
312             "assertIn",
313             "assertNotIn",
314             "assertEmpty",
315             "assertNotEmpty",
316             "assertTrue",
317             "assertFalse",
318         ]:
319             expected_return = self._cast_expected_to_returned_type(
320                 expected_return, module_output
321             )
322         if assertion == "assertEqual":
323             assertion_desc = "=="
324             value["status"] = self.__assert_equal(
325                 expected_return, module_output, assert_print_result
326             )
327         elif assertion == "assertNotEqual":
328             assertion_desc = "!="
329             value["status"] = self.__assert_not_equal(
330                 expected_return, module_output, assert_print_result
331             )
332         elif assertion == "assertTrue":
333             assertion_desc = "True is"
334             value["status"] = self.__assert_true(module_output)
335         elif assertion == "assertFalse":
336             assertion_desc = "False is"
337             value["status"] = self.__assert_false(module_output)
338         elif assertion == "assertIn":
339             assertion_desc = "IN"
340             value["status"] = self.__assert_in(
341                 expected_return, module_output, assert_print_result
342             )
343         elif assertion == "assertNotIn":
344             assertion_desc = "NOT IN"
345             value["status"] = self.__assert_not_in(
346                 expected_return, module_output, assert_print_result
347             )
348         elif assertion == "assertGreater":
349             assertion_desc = "&gt;"
350             value["status"] = self.__assert_greater(expected_return, module_output)
351         elif assertion == "assertGreaterEqual":
352             assertion_desc = "&gt;="
353             value["status"] = self.__assert_greater_equal(
354                 expected_return, module_output
355             )
356         elif assertion == "assertLess":
357             assertion_desc = "&lt;"
358             value["status"] = self.__assert_less(expected_return, module_output)
359         elif assertion == "assertLessEqual":
360             assertion_desc = "&lt;="
361             value["status"] = self.__assert_less_equal(expected_return, module_output)
362         elif assertion == "assertEmpty":
363             assertion_desc = "IS EMPTY"
364             value["status"] = self.__assert_empty(module_output)
365         elif assertion == "assertNotEmpty":
366             assertion_desc = "IS NOT EMPTY"
367             value["status"] = self.__assert_not_empty(module_output)
368         else:
369             value["status"] = "Fail - bad assertion"
370         if output_details:
371             if assertion_section:
372                 assertion_section_repr_title = " {}".format("assertion_section")
373                 assertion_section_repr_value = " {}".format(assertion_section)
374             else:
375                 assertion_section_repr_title = ""
376                 assertion_section_repr_value = ""
377             value[
378                 "module.function [args]{}".format(assertion_section_repr_title)
379             ] = "{} {}{}".format(
380                 mod_and_func,
381                 dumps(args),
382                 assertion_section_repr_value,
383             )
384             value["saltcheck assertion"] = "{}{} {}".format(
385                 ("" if expected_return is None else "{} ".format(expected_return)),
386                 assertion_desc,
387                 ("hidden" if not assert_print_result else module_output),
388             )
389         return value
390     def run_test(self, test_dict):
391         result = {}
392         start = time.time()
393         global_output_details = __salt__["config.get"](
394             "saltcheck_output_details", False
395         )
396         output_details = test_dict.get("output_details", global_output_details)
397         if self.__is_valid_test(test_dict):
398             skip = test_dict.get("skip", False)
399             if skip:
400                 return {"status": "Skip", "duration": 0.0}
401             mod_and_func = test_dict["module_and_function"]
402             args = test_dict.get("args", None)
403             kwargs = test_dict.get("kwargs", None)
404             pillar_data = test_dict.get(
405                 "pillar_data", test_dict.get("pillar-data", None)
406             )
407             if pillar_data:
408                 if not kwargs:
409                     kwargs = {}
410                 kwargs["pillar"] = pillar_data
411             else:
412                 if kwargs:
413                     kwargs.pop("pillar", None)
414             assert_print_result = test_dict.get("print_result", True)
415             actual_return = self._call_salt_command(mod_and_func, args, kwargs)
416             if test_dict.get("assertions"):
417                 for num, assert_group in enumerate(
418                     test_dict.get("assertions"), start=1
419                 ):
420                     result["assertion{}".format(num)] = self._run_assertions(
421                         mod_and_func,
422                         args,
423                         assert_group,
424                         actual_return,
425                         output_details,
426                         assert_print_result,
427                     )
428                 for k, v in copy.deepcopy(result).items():
429                     if k.startswith("assertion"):
430                         for assert_k, assert_v in result[k].items():
431                             if assert_k.startswith("status"):
432                                 if result[k][assert_k] != "Pass":
433                                     result["status"] = "Fail"
434                 if not result.get("status"):
435                     result["status"] = "Pass"
436             else:
437                 result.update(
438                     self._run_assertions(
439                         mod_and_func,
440                         args,
441                         test_dict,
442                         actual_return,
443                         output_details,
444                         assert_print_result,
445                     )
446                 )
447         else:
448             result["status"] = "Fail - invalid test"
449         end = time.time()
450         result["duration"] = round(end - start, 4)
451         return result
452     @staticmethod
453     def _cast_expected_to_returned_type(expected, returned):
454         new_expected = expected
455         if returned is not None:
456             ret_type = type(returned)
457             if expected == "False" and ret_type == bool:
458                 expected = False
459             try:
460                 new_expected = ret_type(expected)
461             except ValueError:
462                 log.info("Unable to cast expected into type of returned")
463                 log.info("returned = %s", returned)
464                 log.info("type of returned = %s", type(returned))
465                 log.info("expected = %s", expected)
466                 log.info("type of expected = %s", type(expected))
467         return new_expected
468     @staticmethod
469     def __assert_equal(expected, returned, assert_print_result=True):
470         result = "Pass"
471         try:
472             if assert_print_result:
473                 assert expected == returned, "{} is not equal to {}".format(
474                     expected, returned
475                 )
476             else:
477                 assert expected == returned, "Result is not equal"
478         except AssertionError as err:
479             result = "Fail: " + str(err)
480         return result
481     @staticmethod
482     def __assert_not_equal(expected, returned, assert_print_result=True):
483         result = "Pass"
484         try:
485             if assert_print_result:
486                 assert expected != returned, "{} is equal to {}".format(
487                     expected, returned
488                 )
489             else:
490                 assert expected != returned, "Result is equal"
491         except AssertionError as err:
492             result = "Fail: " + str(err)
493         return result
494     @staticmethod
495     def __assert_true(returned):
496         result = "Pass"
497         try:
498             assert returned is True, "{} not True".format(returned)
499         except AssertionError as err:
500             result = "Fail: " + str(err)
501         return result
502     @staticmethod
503     def __assert_false(returned):
504         result = "Pass"
505         if isinstance(returned, str):
506             returned = bool(returned)
507         try:
508             assert returned is False, "{} not False".format(returned)
509         except AssertionError as err:
510             result = "Fail: " + str(err)
511         return result
512     @staticmethod
513     def __assert_in(expected, returned, assert_print_result=True):
514         result = "Pass"
515         try:
516             if assert_print_result:
517                 assert expected in returned, "{} not found in {}".format(
518                     expected, returned
519                 )
520             else:
521                 assert expected in returned, "Result not found"
522         except AssertionError as err:
523             result = "Fail: " + str(err)
524         return result
525     @staticmethod
526     def __assert_not_in(expected, returned, assert_print_result=True):
527         result = "Pass"
528         try:
529             if assert_print_result:
530                 assert expected not in returned, "{} was found in {}".format(
531                     expected, returned
532                 )
533             else:
534                 assert expected not in returned, "Result was found"
535         except AssertionError as err:
536             result = "Fail: " + str(err)
537         return result
538     @staticmethod
539     def __assert_greater(expected, returned):
540         result = "Pass"
541         try:
542             assert expected &gt; returned, "{} not False".format(returned)
543         except AssertionError as err:
544             result = "Fail: " + str(err)
545         return result
546     @staticmethod
547     def __assert_greater_equal(expected, returned):
548         result = "Pass"
549         try:
550             assert expected &gt;= returned, "{} not False".format(returned)
551         except AssertionError as err:
552             result = "Fail: " + str(err)
553         return result
554     @staticmethod
555     def __assert_less(expected, returned):
556         result = "Pass"
557         try:
558             assert expected &lt; returned, "{} not False".format(returned)
559         except AssertionError as err:
560             result = "Fail: " + str(err)
561         return result
562     @staticmethod
563     def __assert_less_equal(expected, returned):
564         result = "Pass"
565         try:
566             assert expected &lt;= returned, "{} not False".format(returned)
567         except AssertionError as err:
568             result = "Fail: " + str(err)
569         return result
570     @staticmethod
571     def __assert_empty(returned):
572         result = "Pass"
573         try:
574             assert not returned, "{} is not empty".format(returned)
575         except AssertionError as err:
576             result = "Fail: " + str(err)
577         return result
578     @staticmethod
579     def __assert_not_empty(returned):
580         result = "Pass"
581         try:
582             assert returned, "value is empty"
583         except AssertionError as err:
584             result = "Fail: " + str(err)
585         return result
586 class StateTestLoader:
587     def __init__(self, saltenv="base"):
588         self.path_type = None
589         self.test_files = set()  # list of file paths
590         self.test_dict = OrderedDict()
591         self.saltenv = saltenv
592         self.saltcheck_test_location = __salt__["config.get"](
593             "saltcheck_test_location", "saltcheck-tests"
594         )
595         self.found_states = []
596     def load_test_suite(self):
597         self.test_dict = OrderedDict()
598         for myfile in self.test_files:
599             self._load_file_salt_rendered(myfile)
600         self.test_files = set()
601     def _load_file_salt_rendered(self, filepath):
602         tests = _render_file(filepath)
603         mydict = loads(dumps(tests), object_pairs_hook=OrderedDict)
604         for key, value in mydict.items():
605             self.test_dict[key] = value
606         return
607     def _copy_state_files(self, sls_path, state_name, check_all):
608         cache_ret = []
609         if state_name not in self.found_states:
610             log.debug("looking in %s to cache tests", sls_path)
611             cache_ret = __salt__["cp.cache_dir"](
612                 sls_path, saltenv=self.saltenv, include_pat="*.tst"
613             )
614             if cache_ret:
615                 if check_all:
616                     log.debug("Adding all found test files: %s", cache_ret)
617                     self.test_files.update(cache_ret)
618                 else:
619                     log.debug("Marking found_state: %s", state_name)
620                     self.found_states.append(state_name)
621         else:
622             log.debug("Not copying already found_state: %s", self.found_states)
623         return cache_ret
624     def _generate_sls_path(self, state_name):
625         all_sls_paths = []
626         test_path = "salt://{}/{}".format(
627             state_name.replace(".", "/"), self.saltcheck_test_location
628         )
629         all_sls_paths.append(test_path)
630         sls_split = state_name.split(".")
631         sls_split.pop()
632         test_path = "salt://{}/{}".format(
633             "/".join(sls_split), self.saltcheck_test_location
634         )
635         all_sls_paths.append(test_path)
636         state_name_base = state_name.split(".")[0]
637         test_path = "salt://{}/{}".format(state_name_base, self.saltcheck_test_location)
638         all_sls_paths.append(test_path)
639         unique_paths = set(all_sls_paths)
640         return list(sorted(unique_paths, key=len, reverse=True))
641     @memoize
642     def _get_states(self):
643         return __salt__["cp.list_states"](saltenv=self.saltenv)
644     def add_test_files_for_sls(self, sls_name, check_all=False):
645         salt_ssh = False
646         if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
647             salt_ssh = True
648             log.debug("Running on salt-ssh minion. Reading file %s", sls_name)
649             cp_output_file = os.path.join(
650                 __opts__["cachedir"], "files", self.saltenv, "cp_output.txt"
651             )
652             with salt.utils.files.fopen(cp_output_file, "r") as fp:
653                 all_states = loads(salt.utils.stringutils.to_unicode(fp.read()))
654         else:
655             all_states = self._get_states()
656         ret = []
657         cached_copied_files = []
658         if salt_ssh:
659             log.debug("Running on salt-ssh minion. Populating test file results")
660             state_copy_file = os.path.join(
661                 __opts__["cachedir"], "files", self.saltenv, sls_name + ".copy"
662             )
663             try:
664                 with salt.utils.files.fopen(state_copy_file, "r") as fp:
665                     cached_copied_files.extend(
666                         loads(salt.utils.stringutils.to_unicode(fp.read()))
667                     )
668             except OSError:
669                 sls_name_list = sls_name.split(".")
670                 sls_root_name = ".".join(sls_name_list[:-1])
671                 state_copy_file = os.path.join(
672                     __opts__["cachedir"], "files", self.saltenv, sls_root_name + ".copy"
673                 )
674                 with salt.utils.files.fopen(state_copy_file, "r") as fp:
675                     cached_copied_files.extend(
676                         loads(salt.utils.stringutils.to_unicode(fp.read()))
677                     )
678         if sls_name in all_states:
679             if salt_ssh:
680                 log.debug(
681                     "Running on salt-ssh minion. Reading file %s", sls_name + ".low"
682                 )
683                 state_low_file = os.path.join(
684                     __opts__["cachedir"], "files", self.saltenv, sls_name + ".low"
685                 )
686                 with salt.utils.files.fopen(state_low_file, "r") as fp:
687                     ret = loads(salt.utils.stringutils.to_unicode(fp.read()))
688             else:
689                 ret = __salt__["state.show_low_sls"](
690                     sls_name, saltenv=self.saltenv, test=True
691                 )
692         else:
693             ret = [{"__sls__": sls_name}]
694         for low_data in ret:
695             if not isinstance(low_data, dict):
696                 log.error(
697                     "low data from show_low_sls is not formed as a dict: %s", low_data
698                 )
699                 return
700             this_cache_ret = None
701             if "__sls__" in low_data:
702                 state_name = low_data["__sls__"]
703                 for sls_path in self._generate_sls_path(state_name):
704                     this_cache_ret = self._copy_state_files(
705                         sls_path, state_name, check_all
706                     )
707                     if this_cache_ret:
708                         log.debug("found tests: %s", this_cache_ret)
709                         cached_copied_files.extend(this_cache_ret)
710                 if salt_ssh:
711                     if check_all:
712                         tst_files = [
713                             file_string
714                             for file_string in cached_copied_files
715                             if file_string.endswith(".tst")
716                         ]
717                         self.test_files.update(tst_files)
718                 if not check_all:
719                     split_sls = low_data["__sls__"].split(".")
720                     sls_path_names = {
721                         os.path.join(
722                             os.sep.join(split_sls),
723                             os.path.normpath(self.saltcheck_test_location),
724                             "init.tst",
725                         ),
726                         os.path.join(
727                             os.sep.join(split_sls[: len(split_sls) - 1]),
728                             os.path.normpath(self.saltcheck_test_location),
729                             "{}.tst".format(split_sls[-1]),
730                         ),
731                         os.path.join(
732                             split_sls[0],
733                             os.path.normpath(self.saltcheck_test_location),
734                             os.sep.join(split_sls[1:-1]),
735                             "{}.tst".format(split_sls[-1]),
736                         ),
737                     }
738                     cached_copied_files = list(set(cached_copied_files))
739                     for this_cached_test_file in cached_copied_files:
740                         if this_cached_test_file.endswith(tuple(sls_path_names)):
741                             self.test_files.add(this_cached_test_file)
742                             cached_copied_files.remove(this_cached_test_file)
743                             log.debug("Adding .tst file: %s", this_cached_test_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
