<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_autoruns.py &amp; saltcheck_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_autoruns.py &amp; saltcheck_1.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_autoruns.py (14.772727%)<th>saltcheck_1.py (0.94545454%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-28)<td><a href="#" name="0">(324-339)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_autoruns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import salt.utils.platform
3 <a name="0"></a>__func_alias__ = {"list_": "list"}
4 __virtualname__ <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "autoruns"
5 def __virtual__():
6     if salt.utils.platform.is_windows():
7         return __virtualname__
8     return (False, "Module win_autoruns: module only works on Windows systems")
9 def</b></font> _get_dirs(user_dir, startup_dir):
10     try:
11         users = os.listdir(user_dir)
12     except OSError:  # pylint: disable=E0602
13         users = []
14     full_dirs = []
15     for user in users:
16         full_dir = os.path.join(user_dir, user, startup_dir)
17         if os.path.exists(full_dir):
18             full_dirs.append(full_dir)
19     return full_dirs
20 def list_():
21     autoruns = {}
22     keys = [
23         "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
24         "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /reg:64",
25         "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
26     ]
27     for key in keys:
28         autoruns[key] = []
29         cmd = ["reg", "query", key]
30         for line in __salt__["cmd.run"](cmd, python_shell=False).splitlines():
31             if (
32                 line and line[0:4] != "HKEY" and line[0:5] != "ERROR"
33             ):  # Remove junk lines
34                 autoruns[key].append(line)
35     user_dir = "C:\\Documents and Settings\\"
36     startup_dir = "\\Start Menu\\Programs\\Startup"
37     full_dirs = _get_dirs(user_dir, startup_dir)
38     if not full_dirs:
39         user_dir = "C:\\Users\\"
40         startup_dir = (
41             "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
42         )
43         full_dirs = _get_dirs(user_dir, startup_dir)
44     for full_dir in full_dirs:
45         files = os.listdir(full_dir)
46         autoruns[full_dir] = []
47         for single_file in files:
48             autoruns[full_dir].append(single_file)
49     return autoruns
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltcheck_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import multiprocessing
4 import os
5 import time
6 import salt.client
7 import salt.exceptions
8 import salt.utils.data
9 import salt.utils.files
10 import salt.utils.functools
11 import salt.utils.path
12 import salt.utils.platform
13 import salt.utils.yaml
14 from salt.defaults import DEFAULT_TARGET_DELIM
15 from salt.utils.decorators import memoize
16 from salt.utils.json import dumps, loads
17 from salt.utils.odict import OrderedDict
18 log = logging.getLogger(__name__)
19 <a name="0"></a>
20 global_scheck = None
21 __virtualname__ <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "saltcheck"
22 def __virtual__():
23     if not salt.utils.platform.is_proxy():
24         return __virtualname__
25     return (
26         False,
27         "The saltcheck execution module failed to load: only available on minions.",
28     )
29 def</b></font> run_test(**kwargs):
30     scheck = SaltCheck()
31     test = kwargs.get("test", None)
32     if test and isinstance(test, dict):
33         return scheck.run_test(test)
34     else:
35         return "Test argument must be a dictionary"
36 def state_apply(state_name, **kwargs):
37     conf_file = copy.deepcopy(__opts__["conf_file"])
38     local_opts = salt.config.minion_config(conf_file)
39     if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
40         local_opts["file_client"] = "local"
41         log.debug("Detected salt-ssh, running as local")
42     caller = salt.client.Caller(mopts=local_opts)
43     if kwargs:
44         return caller.cmd("state.apply", state_name, **kwargs)
45     else:
46         return caller.cmd("state.apply", state_name)
47 def report_highstate_tests(saltenv=None):
48     if not saltenv:
49         if "saltenv" in __opts__ and __opts__["saltenv"]:
50             saltenv = __opts__["saltenv"]
51         else:
52             saltenv = "base"
53     sls_list = []
54     sls_list = _get_top_states(saltenv)
55     stl = StateTestLoader(saltenv)
56     missing_tests = 0
57     states_missing_tests = []
58     for state_name in sls_list:
59         stl.add_test_files_for_sls(state_name, False)
60         if state_name not in stl.found_states:
61             missing_tests = missing_tests + 1
62             states_missing_tests.append(state_name)
63     __context__["retcode"] = missing_tests
64     return {
65         "TEST REPORT RESULTS": {
66             "Missing Tests": missing_tests,
67             "States missing tests": states_missing_tests,
68             "States with tests": stl.found_states,
69         }
70     }
71 def run_state_tests(state, saltenv=None, check_all=False, only_fails=False):
72     if not saltenv:
73         if "saltenv" in __opts__ and __opts__["saltenv"]:
74             saltenv = __opts__["saltenv"]
75         else:
76             saltenv = "base"
77     global global_scheck
78     global_scheck = SaltCheck(saltenv)
79     parallel = __salt__["config.get"]("saltcheck_parallel")
80     num_proc = __salt__["config.get"]("saltcheck_processes")
81     stl = StateTestLoader(saltenv)
82     results = OrderedDict()
83     sls_list = salt.utils.args.split_input(state)
84     for state_name in sls_list:
85         stl.add_test_files_for_sls(state_name, check_all)
86         stl.load_test_suite()
87         results_dict = OrderedDict()
88         if parallel:
89             if type(num_proc) == float:
90                 num_proc = int(num_proc)
91             if multiprocessing.cpu_count() &lt; 2:
92                 parallel = False
93                 log.debug("Only 1 CPU. Disabling parallization.")
94             elif num_proc == 1:
95                 parallel = False
96                 log.debug("Configuration limited to 1 CPU. Disabling parallization.")
97             else:
98                 for items in stl.test_dict.values():
99                     if "state.apply" in items.get("module_and_function", []):
100                         parallel = False
101                         log.warning(
102                             "Tests include state.apply. Disabling parallization."
103                         )
104         if parallel:
105             if num_proc:
106                 pool_size = num_proc
107             else:
108                 pool_size = min(len(stl.test_dict), multiprocessing.cpu_count())
109             log.debug("Running tests in parallel with %s processes", pool_size)
110             presults = multiprocessing.Pool(pool_size).map(
111                 func=parallel_scheck, iterable=stl.test_dict.items()
112             )
113             for item in presults:
114                 for key, value in item.items():
115                     results_dict[key] = value
116         else:
117             for key, value in stl.test_dict.items():
118                 result = global_scheck.run_test(value)
119                 results_dict[key] = result
120         if not results.get(state_name):
121             results[state_name] = results_dict
122     return _generate_out_list(results, only_fails=only_fails)
123 def parallel_scheck(data):
124     key = data[0]
125     value = data[1]
126     results = {}
127     results[key] = global_scheck.run_test(value)
128     return results
129 run_state_tests_ssh = salt.utils.functools.alias_function(
130     run_state_tests, "run_state_tests_ssh"
131 )
132 def run_highstate_tests(saltenv=None, only_fails=False):
133     if not saltenv:
134         if "saltenv" in __opts__ and __opts__["saltenv"]:
135             saltenv = __opts__["saltenv"]
136         else:
137             saltenv = "base"
138     sls_list = []
139     sls_list = _get_top_states(saltenv)
140     all_states = ",".join(sls_list)
141     return run_state_tests(all_states, saltenv=saltenv, only_fails=only_fails)
142 def _eval_failure_only_print(state_name, results, only_fails):
143     if only_fails:
144         failed_tests = {}
145         for test in results[state_name]:
146             if results[state_name][test]["status"].startswith("Fail"):
147                 if failed_tests.get(state_name):
148                     failed_tests[state_name].update({test: results[state_name][test]})
149                 else:
150                     failed_tests[state_name] = {test: results[state_name][test]}
151         return failed_tests
152     else:
153         return {state_name: results[state_name]}
154 def _generate_out_list(results, only_fails=False):
155     passed = 0
156     failed = 0
157     skipped = 0
158     missing_tests = 0
159     total_time = 0.0
160     out_list = []
161     for state in results:
162         if not results[state].items():
163             missing_tests = missing_tests + 1
164         else:
165             for _, val in results[state].items():
166                 if val["status"].startswith("Pass"):
167                     passed = passed + 1
168                 if val["status"].startswith("Fail"):
169                     failed = failed + 1
170                 if val["status"].startswith("Skip"):
171                     skipped = skipped + 1
172                 total_time = total_time + float(val["duration"])
173         out_list.append(_eval_failure_only_print(state, results, only_fails))
174     out_list = sorted(out_list, key=lambda x: sorted(x.keys()))
175     out_list.append(
176         {
177             "TEST RESULTS": {
178                 "Execution Time": round(total_time, 4),
179                 "Passed": passed,
180                 "Failed": failed,
181                 "Skipped": skipped,
182                 "Missing Tests": missing_tests,
183             }
184         }
185     )
186     __context__["retcode"] = 1 if failed else 0
187     return out_list
188 def _render_file(file_path):
189     rendered = __salt__["slsutil.renderer"](file_path, saltenv=global_scheck.saltenv)
190     log.info("rendered: %s", rendered)
191     return rendered
192 @memoize
193 def _is_valid_module(module):
194     modules = __salt__["sys.list_modules"]()
195     return bool(module in modules)
196 @memoize
197 def _is_valid_function(module_name, function):
198     try:
199         functions = __salt__["sys.list_functions"](module_name)
200     except salt.exceptions.SaltException:
201         functions = ["unable to look up functions"]
202     return "{}.{}".format(module_name, function) in functions
203 def _get_top_states(saltenv="base"):
204     top_states = []
205     top_states = __salt__["state.show_top"]()[saltenv]
206     log.debug("saltcheck for saltenv: %s found top states: %s", saltenv, top_states)
207     return top_states
208 class SaltCheck:
209     def __init__(self, saltenv="base"):
210         self.sls_list_state = []
211         self.modules = []
212         self.results_dict = {}
213         self.results_dict_summary = {}
214         self.saltenv = saltenv
215         self.assertions_list = """assertEqual assertNotEqual
216                                   assertTrue assertFalse
217                                   assertIn assertNotIn
218                                   assertGreater
219                                   assertGreaterEqual
220                                   assertLess assertLessEqual
221                                   assertEmpty assertNotEmpty""".split()
222     def _check_assertions(self, dict):
223         is_valid = True
224         assertion = dict.get("assertion", None)
225         exp_ret_key = any(
226             key in dict.keys() for key in ["expected_return", "expected-return"]
227         )
228         exp_ret_val = dict.get("expected_return", dict.get("expected-return", None))
229         if assertion not in self.assertions_list:
230             log.error("Saltcheck: %s is not in the assertions list", assertion)
231             is_valid = False
232         if assertion not in [
233             "assertEmpty",
234             "assertNotEmpty",
235             "assertTrue",
236             "assertFalse",
237         ]:
238             if exp_ret_key is None:
239                 log.error("Saltcheck: missing expected_return")
240                 is_valid = False
241             if exp_ret_val is None:
242                 log.error("Saltcheck: expected_return missing a value")
243                 is_valid = False
244         return is_valid
245     def __is_valid_test(self, test_dict):
246         log.info("Saltcheck: validating data: %s", test_dict)
247         is_valid = True
248         skip = test_dict.get("skip", False)
249         m_and_f = test_dict.get("module_and_function", None)
250         if m_and_f == "saltcheck.state_apply":
251             return is_valid
252         if test_dict.get("assertions"):
253             for assertion_group in test_dict.get("assertions"):
254                 is_valid = self._check_assertions(assertion_group)
255         else:
256             is_valid = self._check_assertions(test_dict)
257         if m_and_f:
258             module, function = m_and_f.split(".")
259             if not _is_valid_module(module):
260                 is_valid = False
261                 log.error("Saltcheck: %s is not a valid module", module)
262             if not _is_valid_function(module, function):
263                 is_valid = False
264                 log.error("Saltcheck: %s is not a valid function", function)
265         else:
266             log.error("Saltcheck: missing module_and_function")
267             is_valid = False
268         return is_valid
269     def _call_salt_command(self, fun, args, kwargs):
270         conf_file = __opts__["conf_file"]
271         local_opts = salt.config.minion_config(conf_file)
272         orig_file_client = local_opts["file_client"]
273         mlocal_opts = copy.deepcopy(local_opts)
274         mlocal_opts["file_client"] = "local"
275         value = False
276         if args and kwargs:
277             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args, **kwargs)
278         elif args and not kwargs:
279             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args)
280         elif not args and kwargs:
281             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, **kwargs)
282         else:
283             value = salt.client.Caller(mopts=mlocal_opts).cmd(fun)
284         __opts__["file_client"] = orig_file_client
285         return value
286     def _run_assertions(
287         self,
288         mod_and_func,
289         args,
290         data,
291         module_output,
292         output_details,
293         assert_print_result,
294     ):
295         value = {}
296         assertion_section = data.get("assertion_section", None)
297         assertion_section_delimiter = data.get(
298             "assertion_section_delimiter", DEFAULT_TARGET_DELIM
299         )
300         if assertion_section:
301             module_output = salt.utils.data.traverse_dict_and_list(
302                 module_output,
303                 assertion_section,
304                 default=False,
305                 delimiter=assertion_section_delimiter,
306             )
307         if mod_and_func in ["saltcheck.state_apply"]:
308             assertion = "assertNotEmpty"
309         else:
310             assertion = data["assertion"]
311         expected_return = data.get("expected_return", data.get("expected-return", None))
312         if assertion not in [
313             "assertIn",
314             "assertNotIn",
315             "assertEmpty",
316             "assertNotEmpty",
317             "assertTrue",
318             "assertFalse",
319         ]:
320             expected_return = self._cast_expected_to_returned_type(
321                 expected_return, module_output
322             )
323         if assertion == "assertEqual":
324             assertion_desc = "=="
325             value["status"] = self.__assert_equal(
326                 expected_return, module_output, assert_print_result
327             )
328         elif assertion == "assertNotEqual":
329             assertion_desc = "!="
330             value["status"] = self.__assert_not_equal(
331                 expected_return, module_output, assert_print_result
332             )
333         elif assertion == "assertTrue":
334             assertion_desc = "True is"
335             value["status"] = self.__assert_true(module_output)
336         elif assertion == "assertFalse":
337             assertion_desc = "False is"
338             value["status"] = self.__assert_false(module_output)
339         elif assertion == "assertIn":
340             assertion_desc = "IN"
341             value["status"] = self.__assert_in(
342                 expected_return, module_output, assert_print_result
343             )
344         elif assertion == "assertNotIn":
345             assertion_desc = "NOT IN"
346             value["status"] = self.__assert_not_in(
347                 expected_return, module_output, assert_print_result
348             )
349         elif assertion == "assertGreater":
350             assertion_desc = "&gt;"
351             value["status"] = self.__assert_greater(expected_return, module_output)
352         elif assertion == "assertGreaterEqual":
353             assertion_desc = "&gt;="
354             value["status"] = self.__assert_greater_equal(
355                 expected_return, module_output
356             )
357         elif assertion == "assertLess":
358             assertion_desc = "&lt;"
359             value["status"] = self.__assert_less(expected_return, module_output)
360         elif assertion == "assertLessEqual":
361             assertion_desc = "&lt;="
362             value["status"] = self.__assert_less_equal(expected_return, module_output)
363         elif assertion == "assertEmpty":
364             assertion_desc = "IS EMPTY"
365             value["status"] = self.__assert_empty(module_output)
366         elif assertion == "assertNotEmpty":
367             assertion_desc = "IS NOT EMPTY"
368             value["status"] = self.__assert_not_empty(module_output)
369         else:
370             value["status"] = "Fail - bad assertion"
371         if output_details:
372             if assertion_section:
373                 assertion_section_repr_title = " {}".format("assertion_section")
374                 assertion_section_repr_value = " {}".format(assertion_section)
375             else:
376                 assertion_section_repr_title = ""
377                 assertion_section_repr_value = ""
378             value[
379                 "module.function [args]{}".format(assertion_section_repr_title)
380             ] = "{} {}{}".format(
381                 mod_and_func,
382                 dumps(args),
383                 assertion_section_repr_value,
384             )
385             value["saltcheck assertion"] = "{}{} {}".format(
386                 ("" if expected_return is None else "{} ".format(expected_return)),
387                 assertion_desc,
388                 ("hidden" if not assert_print_result else module_output),
389             )
390         return value
391     def run_test(self, test_dict):
392         result = {}
393         start = time.time()
394         global_output_details = __salt__["config.get"](
395             "saltcheck_output_details", False
396         )
397         output_details = test_dict.get("output_details", global_output_details)
398         if self.__is_valid_test(test_dict):
399             skip = test_dict.get("skip", False)
400             if skip:
401                 return {"status": "Skip", "duration": 0.0}
402             mod_and_func = test_dict["module_and_function"]
403             args = test_dict.get("args", None)
404             kwargs = test_dict.get("kwargs", None)
405             pillar_data = test_dict.get(
406                 "pillar_data", test_dict.get("pillar-data", None)
407             )
408             if pillar_data:
409                 if not kwargs:
410                     kwargs = {}
411                 kwargs["pillar"] = pillar_data
412             else:
413                 if kwargs:
414                     kwargs.pop("pillar", None)
415             assert_print_result = test_dict.get("print_result", True)
416             actual_return = self._call_salt_command(mod_and_func, args, kwargs)
417             if test_dict.get("assertions"):
418                 for num, assert_group in enumerate(
419                     test_dict.get("assertions"), start=1
420                 ):
421                     result["assertion{}".format(num)] = self._run_assertions(
422                         mod_and_func,
423                         args,
424                         assert_group,
425                         actual_return,
426                         output_details,
427                         assert_print_result,
428                     )
429                 for k, v in copy.deepcopy(result).items():
430                     if k.startswith("assertion"):
431                         for assert_k, assert_v in result[k].items():
432                             if assert_k.startswith("status"):
433                                 if result[k][assert_k] != "Pass":
434                                     result["status"] = "Fail"
435                 if not result.get("status"):
436                     result["status"] = "Pass"
437             else:
438                 result.update(
439                     self._run_assertions(
440                         mod_and_func,
441                         args,
442                         test_dict,
443                         actual_return,
444                         output_details,
445                         assert_print_result,
446                     )
447                 )
448         else:
449             result["status"] = "Fail - invalid test"
450         end = time.time()
451         result["duration"] = round(end - start, 4)
452         return result
453     @staticmethod
454     def _cast_expected_to_returned_type(expected, returned):
455         new_expected = expected
456         if returned is not None:
457             ret_type = type(returned)
458             if expected == "False" and ret_type == bool:
459                 expected = False
460             try:
461                 new_expected = ret_type(expected)
462             except ValueError:
463                 log.info("Unable to cast expected into type of returned")
464                 log.info("returned = %s", returned)
465                 log.info("type of returned = %s", type(returned))
466                 log.info("expected = %s", expected)
467                 log.info("type of expected = %s", type(expected))
468         return new_expected
469     @staticmethod
470     def __assert_equal(expected, returned, assert_print_result=True):
471         result = "Pass"
472         try:
473             if assert_print_result:
474                 assert expected == returned, "{} is not equal to {}".format(
475                     expected, returned
476                 )
477             else:
478                 assert expected == returned, "Result is not equal"
479         except AssertionError as err:
480             result = "Fail: " + str(err)
481         return result
482     @staticmethod
483     def __assert_not_equal(expected, returned, assert_print_result=True):
484         result = "Pass"
485         try:
486             if assert_print_result:
487                 assert expected != returned, "{} is equal to {}".format(
488                     expected, returned
489                 )
490             else:
491                 assert expected != returned, "Result is equal"
492         except AssertionError as err:
493             result = "Fail: " + str(err)
494         return result
495     @staticmethod
496     def __assert_true(returned):
497         result = "Pass"
498         try:
499             assert returned is True, "{} not True".format(returned)
500         except AssertionError as err:
501             result = "Fail: " + str(err)
502         return result
503     @staticmethod
504     def __assert_false(returned):
505         result = "Pass"
506         if isinstance(returned, str):
507             returned = bool(returned)
508         try:
509             assert returned is False, "{} not False".format(returned)
510         except AssertionError as err:
511             result = "Fail: " + str(err)
512         return result
513     @staticmethod
514     def __assert_in(expected, returned, assert_print_result=True):
515         result = "Pass"
516         try:
517             if assert_print_result:
518                 assert expected in returned, "{} not found in {}".format(
519                     expected, returned
520                 )
521             else:
522                 assert expected in returned, "Result not found"
523         except AssertionError as err:
524             result = "Fail: " + str(err)
525         return result
526     @staticmethod
527     def __assert_not_in(expected, returned, assert_print_result=True):
528         result = "Pass"
529         try:
530             if assert_print_result:
531                 assert expected not in returned, "{} was found in {}".format(
532                     expected, returned
533                 )
534             else:
535                 assert expected not in returned, "Result was found"
536         except AssertionError as err:
537             result = "Fail: " + str(err)
538         return result
539     @staticmethod
540     def __assert_greater(expected, returned):
541         result = "Pass"
542         try:
543             assert expected &gt; returned, "{} not False".format(returned)
544         except AssertionError as err:
545             result = "Fail: " + str(err)
546         return result
547     @staticmethod
548     def __assert_greater_equal(expected, returned):
549         result = "Pass"
550         try:
551             assert expected &gt;= returned, "{} not False".format(returned)
552         except AssertionError as err:
553             result = "Fail: " + str(err)
554         return result
555     @staticmethod
556     def __assert_less(expected, returned):
557         result = "Pass"
558         try:
559             assert expected &lt; returned, "{} not False".format(returned)
560         except AssertionError as err:
561             result = "Fail: " + str(err)
562         return result
563     @staticmethod
564     def __assert_less_equal(expected, returned):
565         result = "Pass"
566         try:
567             assert expected &lt;= returned, "{} not False".format(returned)
568         except AssertionError as err:
569             result = "Fail: " + str(err)
570         return result
571     @staticmethod
572     def __assert_empty(returned):
573         result = "Pass"
574         try:
575             assert not returned, "{} is not empty".format(returned)
576         except AssertionError as err:
577             result = "Fail: " + str(err)
578         return result
579     @staticmethod
580     def __assert_not_empty(returned):
581         result = "Pass"
582         try:
583             assert returned, "value is empty"
584         except AssertionError as err:
585             result = "Fail: " + str(err)
586         return result
587 class StateTestLoader:
588     def __init__(self, saltenv="base"):
589         self.path_type = None
590         self.test_files = set()  # list of file paths
591         self.test_dict = OrderedDict()
592         self.saltenv = saltenv
593         self.saltcheck_test_location = __salt__["config.get"](
594             "saltcheck_test_location", "saltcheck-tests"
595         )
596         self.found_states = []
597     def load_test_suite(self):
598         self.test_dict = OrderedDict()
599         for myfile in self.test_files:
600             self._load_file_salt_rendered(myfile)
601         self.test_files = set()
602     def _load_file_salt_rendered(self, filepath):
603         tests = _render_file(filepath)
604         mydict = loads(dumps(tests), object_pairs_hook=OrderedDict)
605         for key, value in mydict.items():
606             self.test_dict[key] = value
607         return
608     def _copy_state_files(self, sls_path, state_name, check_all):
609         cache_ret = []
610         if state_name not in self.found_states:
611             log.debug("looking in %s to cache tests", sls_path)
612             cache_ret = __salt__["cp.cache_dir"](
613                 sls_path, saltenv=self.saltenv, include_pat="*.tst"
614             )
615             if cache_ret:
616                 if check_all:
617                     log.debug("Adding all found test files: %s", cache_ret)
618                     self.test_files.update(cache_ret)
619                 else:
620                     log.debug("Marking found_state: %s", state_name)
621                     self.found_states.append(state_name)
622         else:
623             log.debug("Not copying already found_state: %s", self.found_states)
624         return cache_ret
625     def _generate_sls_path(self, state_name):
626         all_sls_paths = []
627         test_path = "salt://{}/{}".format(
628             state_name.replace(".", "/"), self.saltcheck_test_location
629         )
630         all_sls_paths.append(test_path)
631         sls_split = state_name.split(".")
632         sls_split.pop()
633         test_path = "salt://{}/{}".format(
634             "/".join(sls_split), self.saltcheck_test_location
635         )
636         all_sls_paths.append(test_path)
637         state_name_base = state_name.split(".")[0]
638         test_path = "salt://{}/{}".format(state_name_base, self.saltcheck_test_location)
639         all_sls_paths.append(test_path)
640         unique_paths = set(all_sls_paths)
641         return list(sorted(unique_paths, key=len, reverse=True))
642     @memoize
643     def _get_states(self):
644         return __salt__["cp.list_states"](saltenv=self.saltenv)
645     def add_test_files_for_sls(self, sls_name, check_all=False):
646         salt_ssh = False
647         if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
648             salt_ssh = True
649             log.debug("Running on salt-ssh minion. Reading file %s", sls_name)
650             cp_output_file = os.path.join(
651                 __opts__["cachedir"], "files", self.saltenv, "cp_output.txt"
652             )
653             with salt.utils.files.fopen(cp_output_file, "r") as fp:
654                 all_states = loads(salt.utils.stringutils.to_unicode(fp.read()))
655         else:
656             all_states = self._get_states()
657         ret = []
658         cached_copied_files = []
659         if salt_ssh:
660             log.debug("Running on salt-ssh minion. Populating test file results")
661             state_copy_file = os.path.join(
662                 __opts__["cachedir"], "files", self.saltenv, sls_name + ".copy"
663             )
664             try:
665                 with salt.utils.files.fopen(state_copy_file, "r") as fp:
666                     cached_copied_files.extend(
667                         loads(salt.utils.stringutils.to_unicode(fp.read()))
668                     )
669             except OSError:
670                 sls_name_list = sls_name.split(".")
671                 sls_root_name = ".".join(sls_name_list[:-1])
672                 state_copy_file = os.path.join(
673                     __opts__["cachedir"], "files", self.saltenv, sls_root_name + ".copy"
674                 )
675                 with salt.utils.files.fopen(state_copy_file, "r") as fp:
676                     cached_copied_files.extend(
677                         loads(salt.utils.stringutils.to_unicode(fp.read()))
678                     )
679         if sls_name in all_states:
680             if salt_ssh:
681                 log.debug(
682                     "Running on salt-ssh minion. Reading file %s", sls_name + ".low"
683                 )
684                 state_low_file = os.path.join(
685                     __opts__["cachedir"], "files", self.saltenv, sls_name + ".low"
686                 )
687                 with salt.utils.files.fopen(state_low_file, "r") as fp:
688                     ret = loads(salt.utils.stringutils.to_unicode(fp.read()))
689             else:
690                 ret = __salt__["state.show_low_sls"](
691                     sls_name, saltenv=self.saltenv, test=True
692                 )
693         else:
694             ret = [{"__sls__": sls_name}]
695         for low_data in ret:
696             if not isinstance(low_data, dict):
697                 log.error(
698                     "low data from show_low_sls is not formed as a dict: %s", low_data
699                 )
700                 return
701             this_cache_ret = None
702             if "__sls__" in low_data:
703                 state_name = low_data["__sls__"]
704                 for sls_path in self._generate_sls_path(state_name):
705                     this_cache_ret = self._copy_state_files(
706                         sls_path, state_name, check_all
707                     )
708                     if this_cache_ret:
709                         log.debug("found tests: %s", this_cache_ret)
710                         cached_copied_files.extend(this_cache_ret)
711                 if salt_ssh:
712                     if check_all:
713                         tst_files = [
714                             file_string
715                             for file_string in cached_copied_files
716                             if file_string.endswith(".tst")
717                         ]
718                         self.test_files.update(tst_files)
719                 if not check_all:
720                     split_sls = low_data["__sls__"].split(".")
721                     sls_path_names = {
722                         os.path.join(
723                             os.sep.join(split_sls),
724                             os.path.normpath(self.saltcheck_test_location),
725                             "init.tst",
726                         ),
727                         os.path.join(
728                             os.sep.join(split_sls[: len(split_sls) - 1]),
729                             os.path.normpath(self.saltcheck_test_location),
730                             "{}.tst".format(split_sls[-1]),
731                         ),
732                         os.path.join(
733                             split_sls[0],
734                             os.path.normpath(self.saltcheck_test_location),
735                             os.sep.join(split_sls[1:-1]),
736                             "{}.tst".format(split_sls[-1]),
737                         ),
738                     }
739                     cached_copied_files = list(set(cached_copied_files))
740                     for this_cached_test_file in cached_copied_files:
741                         if this_cached_test_file.endswith(tuple(sls_path_names)):
742                             self.test_files.add(this_cached_test_file)
743                             cached_copied_files.remove(this_cached_test_file)
744                             log.debug("Adding .tst file: %s", this_cached_test_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
