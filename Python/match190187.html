<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_autoruns.py &amp; saltcheck_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_autoruns.py &amp; saltcheck_1.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_autoruns.py (14.772727%)<th>saltcheck_1.py (0.94545454%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-28)<td><a href="#" name="0">(324-339)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_autoruns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import salt.utils.platform
<a name="0"></a>__func_alias__ = {"list_": "list"}
__virtualname__ <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "autoruns"
def __virtual__():
    if salt.utils.platform.is_windows():
        return __virtualname__
    return (False, "Module win_autoruns: module only works on Windows systems")
def</b></font> _get_dirs(user_dir, startup_dir):
    try:
        users = os.listdir(user_dir)
    except OSError:  # pylint: disable=E0602
        users = []
    full_dirs = []
    for user in users:
        full_dir = os.path.join(user_dir, user, startup_dir)
        if os.path.exists(full_dir):
            full_dirs.append(full_dir)
    return full_dirs
def list_():
    autoruns = {}
    keys = [
        "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /reg:64",
        "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    ]
    for key in keys:
        autoruns[key] = []
        cmd = ["reg", "query", key]
        for line in __salt__["cmd.run"](cmd, python_shell=False).splitlines():
            if (
                line and line[0:4] != "HKEY" and line[0:5] != "ERROR"
            ):  # Remove junk lines
                autoruns[key].append(line)
    user_dir = "C:\\Documents and Settings\\"
    startup_dir = "\\Start Menu\\Programs\\Startup"
    full_dirs = _get_dirs(user_dir, startup_dir)
    if not full_dirs:
        user_dir = "C:\\Users\\"
        startup_dir = (
            "\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
        )
        full_dirs = _get_dirs(user_dir, startup_dir)
    for full_dir in full_dirs:
        files = os.listdir(full_dir)
        autoruns[full_dir] = []
        for single_file in files:
            autoruns[full_dir].append(single_file)
    return autoruns
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltcheck_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import logging
import multiprocessing
import os
import time
import salt.client
import salt.exceptions
import salt.utils.data
import salt.utils.files
import salt.utils.functools
import salt.utils.path
import salt.utils.platform
import salt.utils.yaml
from salt.defaults import DEFAULT_TARGET_DELIM
from salt.utils.decorators import memoize
from salt.utils.json import dumps, loads
from salt.utils.odict import OrderedDict
log = logging.getLogger(__name__)
<a name="0"></a>
global_scheck = None
__virtualname__ <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "saltcheck"
def __virtual__():
    if not salt.utils.platform.is_proxy():
        return __virtualname__
    return (
        False,
        "The saltcheck execution module failed to load: only available on minions.",
    )
def</b></font> run_test(**kwargs):
    scheck = SaltCheck()
    test = kwargs.get("test", None)
    if test and isinstance(test, dict):
        return scheck.run_test(test)
    else:
        return "Test argument must be a dictionary"
def state_apply(state_name, **kwargs):
    conf_file = copy.deepcopy(__opts__["conf_file"])
    local_opts = salt.config.minion_config(conf_file)
    if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
        local_opts["file_client"] = "local"
        log.debug("Detected salt-ssh, running as local")
    caller = salt.client.Caller(mopts=local_opts)
    if kwargs:
        return caller.cmd("state.apply", state_name, **kwargs)
    else:
        return caller.cmd("state.apply", state_name)
def report_highstate_tests(saltenv=None):
    if not saltenv:
        if "saltenv" in __opts__ and __opts__["saltenv"]:
            saltenv = __opts__["saltenv"]
        else:
            saltenv = "base"
    sls_list = []
    sls_list = _get_top_states(saltenv)
    stl = StateTestLoader(saltenv)
    missing_tests = 0
    states_missing_tests = []
    for state_name in sls_list:
        stl.add_test_files_for_sls(state_name, False)
        if state_name not in stl.found_states:
            missing_tests = missing_tests + 1
            states_missing_tests.append(state_name)
    __context__["retcode"] = missing_tests
    return {
        "TEST REPORT RESULTS": {
            "Missing Tests": missing_tests,
            "States missing tests": states_missing_tests,
            "States with tests": stl.found_states,
        }
    }
def run_state_tests(state, saltenv=None, check_all=False, only_fails=False):
    if not saltenv:
        if "saltenv" in __opts__ and __opts__["saltenv"]:
            saltenv = __opts__["saltenv"]
        else:
            saltenv = "base"
    global global_scheck
    global_scheck = SaltCheck(saltenv)
    parallel = __salt__["config.get"]("saltcheck_parallel")
    num_proc = __salt__["config.get"]("saltcheck_processes")
    stl = StateTestLoader(saltenv)
    results = OrderedDict()
    sls_list = salt.utils.args.split_input(state)
    for state_name in sls_list:
        stl.add_test_files_for_sls(state_name, check_all)
        stl.load_test_suite()
        results_dict = OrderedDict()
        if parallel:
            if type(num_proc) == float:
                num_proc = int(num_proc)
            if multiprocessing.cpu_count() &lt; 2:
                parallel = False
                log.debug("Only 1 CPU. Disabling parallization.")
            elif num_proc == 1:
                parallel = False
                log.debug("Configuration limited to 1 CPU. Disabling parallization.")
            else:
                for items in stl.test_dict.values():
                    if "state.apply" in items.get("module_and_function", []):
                        parallel = False
                        log.warning(
                            "Tests include state.apply. Disabling parallization."
                        )
        if parallel:
            if num_proc:
                pool_size = num_proc
            else:
                pool_size = min(len(stl.test_dict), multiprocessing.cpu_count())
            log.debug("Running tests in parallel with %s processes", pool_size)
            presults = multiprocessing.Pool(pool_size).map(
                func=parallel_scheck, iterable=stl.test_dict.items()
            )
            for item in presults:
                for key, value in item.items():
                    results_dict[key] = value
        else:
            for key, value in stl.test_dict.items():
                result = global_scheck.run_test(value)
                results_dict[key] = result
        if not results.get(state_name):
            results[state_name] = results_dict
    return _generate_out_list(results, only_fails=only_fails)
def parallel_scheck(data):
    key = data[0]
    value = data[1]
    results = {}
    results[key] = global_scheck.run_test(value)
    return results
run_state_tests_ssh = salt.utils.functools.alias_function(
    run_state_tests, "run_state_tests_ssh"
)
def run_highstate_tests(saltenv=None, only_fails=False):
    if not saltenv:
        if "saltenv" in __opts__ and __opts__["saltenv"]:
            saltenv = __opts__["saltenv"]
        else:
            saltenv = "base"
    sls_list = []
    sls_list = _get_top_states(saltenv)
    all_states = ",".join(sls_list)
    return run_state_tests(all_states, saltenv=saltenv, only_fails=only_fails)
def _eval_failure_only_print(state_name, results, only_fails):
    if only_fails:
        failed_tests = {}
        for test in results[state_name]:
            if results[state_name][test]["status"].startswith("Fail"):
                if failed_tests.get(state_name):
                    failed_tests[state_name].update({test: results[state_name][test]})
                else:
                    failed_tests[state_name] = {test: results[state_name][test]}
        return failed_tests
    else:
        return {state_name: results[state_name]}
def _generate_out_list(results, only_fails=False):
    passed = 0
    failed = 0
    skipped = 0
    missing_tests = 0
    total_time = 0.0
    out_list = []
    for state in results:
        if not results[state].items():
            missing_tests = missing_tests + 1
        else:
            for _, val in results[state].items():
                if val["status"].startswith("Pass"):
                    passed = passed + 1
                if val["status"].startswith("Fail"):
                    failed = failed + 1
                if val["status"].startswith("Skip"):
                    skipped = skipped + 1
                total_time = total_time + float(val["duration"])
        out_list.append(_eval_failure_only_print(state, results, only_fails))
    out_list = sorted(out_list, key=lambda x: sorted(x.keys()))
    out_list.append(
        {
            "TEST RESULTS": {
                "Execution Time": round(total_time, 4),
                "Passed": passed,
                "Failed": failed,
                "Skipped": skipped,
                "Missing Tests": missing_tests,
            }
        }
    )
    __context__["retcode"] = 1 if failed else 0
    return out_list
def _render_file(file_path):
    rendered = __salt__["slsutil.renderer"](file_path, saltenv=global_scheck.saltenv)
    log.info("rendered: %s", rendered)
    return rendered
@memoize
def _is_valid_module(module):
    modules = __salt__["sys.list_modules"]()
    return bool(module in modules)
@memoize
def _is_valid_function(module_name, function):
    try:
        functions = __salt__["sys.list_functions"](module_name)
    except salt.exceptions.SaltException:
        functions = ["unable to look up functions"]
    return "{}.{}".format(module_name, function) in functions
def _get_top_states(saltenv="base"):
    top_states = []
    top_states = __salt__["state.show_top"]()[saltenv]
    log.debug("saltcheck for saltenv: %s found top states: %s", saltenv, top_states)
    return top_states
class SaltCheck:
    def __init__(self, saltenv="base"):
        self.sls_list_state = []
        self.modules = []
        self.results_dict = {}
        self.results_dict_summary = {}
        self.saltenv = saltenv
        self.assertions_list = """assertEqual assertNotEqual
                                  assertTrue assertFalse
                                  assertIn assertNotIn
                                  assertGreater
                                  assertGreaterEqual
                                  assertLess assertLessEqual
                                  assertEmpty assertNotEmpty""".split()
    def _check_assertions(self, dict):
        is_valid = True
        assertion = dict.get("assertion", None)
        exp_ret_key = any(
            key in dict.keys() for key in ["expected_return", "expected-return"]
        )
        exp_ret_val = dict.get("expected_return", dict.get("expected-return", None))
        if assertion not in self.assertions_list:
            log.error("Saltcheck: %s is not in the assertions list", assertion)
            is_valid = False
        if assertion not in [
            "assertEmpty",
            "assertNotEmpty",
            "assertTrue",
            "assertFalse",
        ]:
            if exp_ret_key is None:
                log.error("Saltcheck: missing expected_return")
                is_valid = False
            if exp_ret_val is None:
                log.error("Saltcheck: expected_return missing a value")
                is_valid = False
        return is_valid
    def __is_valid_test(self, test_dict):
        log.info("Saltcheck: validating data: %s", test_dict)
        is_valid = True
        skip = test_dict.get("skip", False)
        m_and_f = test_dict.get("module_and_function", None)
        if m_and_f == "saltcheck.state_apply":
            return is_valid
        if test_dict.get("assertions"):
            for assertion_group in test_dict.get("assertions"):
                is_valid = self._check_assertions(assertion_group)
        else:
            is_valid = self._check_assertions(test_dict)
        if m_and_f:
            module, function = m_and_f.split(".")
            if not _is_valid_module(module):
                is_valid = False
                log.error("Saltcheck: %s is not a valid module", module)
            if not _is_valid_function(module, function):
                is_valid = False
                log.error("Saltcheck: %s is not a valid function", function)
        else:
            log.error("Saltcheck: missing module_and_function")
            is_valid = False
        return is_valid
    def _call_salt_command(self, fun, args, kwargs):
        conf_file = __opts__["conf_file"]
        local_opts = salt.config.minion_config(conf_file)
        orig_file_client = local_opts["file_client"]
        mlocal_opts = copy.deepcopy(local_opts)
        mlocal_opts["file_client"] = "local"
        value = False
        if args and kwargs:
            value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args, **kwargs)
        elif args and not kwargs:
            value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, *args)
        elif not args and kwargs:
            value = salt.client.Caller(mopts=mlocal_opts).cmd(fun, **kwargs)
        else:
            value = salt.client.Caller(mopts=mlocal_opts).cmd(fun)
        __opts__["file_client"] = orig_file_client
        return value
    def _run_assertions(
        self,
        mod_and_func,
        args,
        data,
        module_output,
        output_details,
        assert_print_result,
    ):
        value = {}
        assertion_section = data.get("assertion_section", None)
        assertion_section_delimiter = data.get(
            "assertion_section_delimiter", DEFAULT_TARGET_DELIM
        )
        if assertion_section:
            module_output = salt.utils.data.traverse_dict_and_list(
                module_output,
                assertion_section,
                default=False,
                delimiter=assertion_section_delimiter,
            )
        if mod_and_func in ["saltcheck.state_apply"]:
            assertion = "assertNotEmpty"
        else:
            assertion = data["assertion"]
        expected_return = data.get("expected_return", data.get("expected-return", None))
        if assertion not in [
            "assertIn",
            "assertNotIn",
            "assertEmpty",
            "assertNotEmpty",
            "assertTrue",
            "assertFalse",
        ]:
            expected_return = self._cast_expected_to_returned_type(
                expected_return, module_output
            )
        if assertion == "assertEqual":
            assertion_desc = "=="
            value["status"] = self.__assert_equal(
                expected_return, module_output, assert_print_result
            )
        elif assertion == "assertNotEqual":
            assertion_desc = "!="
            value["status"] = self.__assert_not_equal(
                expected_return, module_output, assert_print_result
            )
        elif assertion == "assertTrue":
            assertion_desc = "True is"
            value["status"] = self.__assert_true(module_output)
        elif assertion == "assertFalse":
            assertion_desc = "False is"
            value["status"] = self.__assert_false(module_output)
        elif assertion == "assertIn":
            assertion_desc = "IN"
            value["status"] = self.__assert_in(
                expected_return, module_output, assert_print_result
            )
        elif assertion == "assertNotIn":
            assertion_desc = "NOT IN"
            value["status"] = self.__assert_not_in(
                expected_return, module_output, assert_print_result
            )
        elif assertion == "assertGreater":
            assertion_desc = "&gt;"
            value["status"] = self.__assert_greater(expected_return, module_output)
        elif assertion == "assertGreaterEqual":
            assertion_desc = "&gt;="
            value["status"] = self.__assert_greater_equal(
                expected_return, module_output
            )
        elif assertion == "assertLess":
            assertion_desc = "&lt;"
            value["status"] = self.__assert_less(expected_return, module_output)
        elif assertion == "assertLessEqual":
            assertion_desc = "&lt;="
            value["status"] = self.__assert_less_equal(expected_return, module_output)
        elif assertion == "assertEmpty":
            assertion_desc = "IS EMPTY"
            value["status"] = self.__assert_empty(module_output)
        elif assertion == "assertNotEmpty":
            assertion_desc = "IS NOT EMPTY"
            value["status"] = self.__assert_not_empty(module_output)
        else:
            value["status"] = "Fail - bad assertion"
        if output_details:
            if assertion_section:
                assertion_section_repr_title = " {}".format("assertion_section")
                assertion_section_repr_value = " {}".format(assertion_section)
            else:
                assertion_section_repr_title = ""
                assertion_section_repr_value = ""
            value[
                "module.function [args]{}".format(assertion_section_repr_title)
            ] = "{} {}{}".format(
                mod_and_func,
                dumps(args),
                assertion_section_repr_value,
            )
            value["saltcheck assertion"] = "{}{} {}".format(
                ("" if expected_return is None else "{} ".format(expected_return)),
                assertion_desc,
                ("hidden" if not assert_print_result else module_output),
            )
        return value
    def run_test(self, test_dict):
        result = {}
        start = time.time()
        global_output_details = __salt__["config.get"](
            "saltcheck_output_details", False
        )
        output_details = test_dict.get("output_details", global_output_details)
        if self.__is_valid_test(test_dict):
            skip = test_dict.get("skip", False)
            if skip:
                return {"status": "Skip", "duration": 0.0}
            mod_and_func = test_dict["module_and_function"]
            args = test_dict.get("args", None)
            kwargs = test_dict.get("kwargs", None)
            pillar_data = test_dict.get(
                "pillar_data", test_dict.get("pillar-data", None)
            )
            if pillar_data:
                if not kwargs:
                    kwargs = {}
                kwargs["pillar"] = pillar_data
            else:
                if kwargs:
                    kwargs.pop("pillar", None)
            assert_print_result = test_dict.get("print_result", True)
            actual_return = self._call_salt_command(mod_and_func, args, kwargs)
            if test_dict.get("assertions"):
                for num, assert_group in enumerate(
                    test_dict.get("assertions"), start=1
                ):
                    result["assertion{}".format(num)] = self._run_assertions(
                        mod_and_func,
                        args,
                        assert_group,
                        actual_return,
                        output_details,
                        assert_print_result,
                    )
                for k, v in copy.deepcopy(result).items():
                    if k.startswith("assertion"):
                        for assert_k, assert_v in result[k].items():
                            if assert_k.startswith("status"):
                                if result[k][assert_k] != "Pass":
                                    result["status"] = "Fail"
                if not result.get("status"):
                    result["status"] = "Pass"
            else:
                result.update(
                    self._run_assertions(
                        mod_and_func,
                        args,
                        test_dict,
                        actual_return,
                        output_details,
                        assert_print_result,
                    )
                )
        else:
            result["status"] = "Fail - invalid test"
        end = time.time()
        result["duration"] = round(end - start, 4)
        return result
    @staticmethod
    def _cast_expected_to_returned_type(expected, returned):
        new_expected = expected
        if returned is not None:
            ret_type = type(returned)
            if expected == "False" and ret_type == bool:
                expected = False
            try:
                new_expected = ret_type(expected)
            except ValueError:
                log.info("Unable to cast expected into type of returned")
                log.info("returned = %s", returned)
                log.info("type of returned = %s", type(returned))
                log.info("expected = %s", expected)
                log.info("type of expected = %s", type(expected))
        return new_expected
    @staticmethod
    def __assert_equal(expected, returned, assert_print_result=True):
        result = "Pass"
        try:
            if assert_print_result:
                assert expected == returned, "{} is not equal to {}".format(
                    expected, returned
                )
            else:
                assert expected == returned, "Result is not equal"
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_not_equal(expected, returned, assert_print_result=True):
        result = "Pass"
        try:
            if assert_print_result:
                assert expected != returned, "{} is equal to {}".format(
                    expected, returned
                )
            else:
                assert expected != returned, "Result is equal"
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_true(returned):
        result = "Pass"
        try:
            assert returned is True, "{} not True".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_false(returned):
        result = "Pass"
        if isinstance(returned, str):
            returned = bool(returned)
        try:
            assert returned is False, "{} not False".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_in(expected, returned, assert_print_result=True):
        result = "Pass"
        try:
            if assert_print_result:
                assert expected in returned, "{} not found in {}".format(
                    expected, returned
                )
            else:
                assert expected in returned, "Result not found"
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_not_in(expected, returned, assert_print_result=True):
        result = "Pass"
        try:
            if assert_print_result:
                assert expected not in returned, "{} was found in {}".format(
                    expected, returned
                )
            else:
                assert expected not in returned, "Result was found"
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_greater(expected, returned):
        result = "Pass"
        try:
            assert expected &gt; returned, "{} not False".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_greater_equal(expected, returned):
        result = "Pass"
        try:
            assert expected &gt;= returned, "{} not False".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_less(expected, returned):
        result = "Pass"
        try:
            assert expected &lt; returned, "{} not False".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_less_equal(expected, returned):
        result = "Pass"
        try:
            assert expected &lt;= returned, "{} not False".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_empty(returned):
        result = "Pass"
        try:
            assert not returned, "{} is not empty".format(returned)
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
    @staticmethod
    def __assert_not_empty(returned):
        result = "Pass"
        try:
            assert returned, "value is empty"
        except AssertionError as err:
            result = "Fail: " + str(err)
        return result
class StateTestLoader:
    def __init__(self, saltenv="base"):
        self.path_type = None
        self.test_files = set()  # list of file paths
        self.test_dict = OrderedDict()
        self.saltenv = saltenv
        self.saltcheck_test_location = __salt__["config.get"](
            "saltcheck_test_location", "saltcheck-tests"
        )
        self.found_states = []
    def load_test_suite(self):
        self.test_dict = OrderedDict()
        for myfile in self.test_files:
            self._load_file_salt_rendered(myfile)
        self.test_files = set()
    def _load_file_salt_rendered(self, filepath):
        tests = _render_file(filepath)
        mydict = loads(dumps(tests), object_pairs_hook=OrderedDict)
        for key, value in mydict.items():
            self.test_dict[key] = value
        return
    def _copy_state_files(self, sls_path, state_name, check_all):
        cache_ret = []
        if state_name not in self.found_states:
            log.debug("looking in %s to cache tests", sls_path)
            cache_ret = __salt__["cp.cache_dir"](
                sls_path, saltenv=self.saltenv, include_pat="*.tst"
            )
            if cache_ret:
                if check_all:
                    log.debug("Adding all found test files: %s", cache_ret)
                    self.test_files.update(cache_ret)
                else:
                    log.debug("Marking found_state: %s", state_name)
                    self.found_states.append(state_name)
        else:
            log.debug("Not copying already found_state: %s", self.found_states)
        return cache_ret
    def _generate_sls_path(self, state_name):
        all_sls_paths = []
        test_path = "salt://{}/{}".format(
            state_name.replace(".", "/"), self.saltcheck_test_location
        )
        all_sls_paths.append(test_path)
        sls_split = state_name.split(".")
        sls_split.pop()
        test_path = "salt://{}/{}".format(
            "/".join(sls_split), self.saltcheck_test_location
        )
        all_sls_paths.append(test_path)
        state_name_base = state_name.split(".")[0]
        test_path = "salt://{}/{}".format(state_name_base, self.saltcheck_test_location)
        all_sls_paths.append(test_path)
        unique_paths = set(all_sls_paths)
        return list(sorted(unique_paths, key=len, reverse=True))
    @memoize
    def _get_states(self):
        return __salt__["cp.list_states"](saltenv=self.saltenv)
    def add_test_files_for_sls(self, sls_name, check_all=False):
        salt_ssh = False
        if "running_data/var/run/salt-minion.pid" in __opts__.get("pidfile", False):
            salt_ssh = True
            log.debug("Running on salt-ssh minion. Reading file %s", sls_name)
            cp_output_file = os.path.join(
                __opts__["cachedir"], "files", self.saltenv, "cp_output.txt"
            )
            with salt.utils.files.fopen(cp_output_file, "r") as fp:
                all_states = loads(salt.utils.stringutils.to_unicode(fp.read()))
        else:
            all_states = self._get_states()
        ret = []
        cached_copied_files = []
        if salt_ssh:
            log.debug("Running on salt-ssh minion. Populating test file results")
            state_copy_file = os.path.join(
                __opts__["cachedir"], "files", self.saltenv, sls_name + ".copy"
            )
            try:
                with salt.utils.files.fopen(state_copy_file, "r") as fp:
                    cached_copied_files.extend(
                        loads(salt.utils.stringutils.to_unicode(fp.read()))
                    )
            except OSError:
                sls_name_list = sls_name.split(".")
                sls_root_name = ".".join(sls_name_list[:-1])
                state_copy_file = os.path.join(
                    __opts__["cachedir"], "files", self.saltenv, sls_root_name + ".copy"
                )
                with salt.utils.files.fopen(state_copy_file, "r") as fp:
                    cached_copied_files.extend(
                        loads(salt.utils.stringutils.to_unicode(fp.read()))
                    )
        if sls_name in all_states:
            if salt_ssh:
                log.debug(
                    "Running on salt-ssh minion. Reading file %s", sls_name + ".low"
                )
                state_low_file = os.path.join(
                    __opts__["cachedir"], "files", self.saltenv, sls_name + ".low"
                )
                with salt.utils.files.fopen(state_low_file, "r") as fp:
                    ret = loads(salt.utils.stringutils.to_unicode(fp.read()))
            else:
                ret = __salt__["state.show_low_sls"](
                    sls_name, saltenv=self.saltenv, test=True
                )
        else:
            ret = [{"__sls__": sls_name}]
        for low_data in ret:
            if not isinstance(low_data, dict):
                log.error(
                    "low data from show_low_sls is not formed as a dict: %s", low_data
                )
                return
            this_cache_ret = None
            if "__sls__" in low_data:
                state_name = low_data["__sls__"]
                for sls_path in self._generate_sls_path(state_name):
                    this_cache_ret = self._copy_state_files(
                        sls_path, state_name, check_all
                    )
                    if this_cache_ret:
                        log.debug("found tests: %s", this_cache_ret)
                        cached_copied_files.extend(this_cache_ret)
                if salt_ssh:
                    if check_all:
                        tst_files = [
                            file_string
                            for file_string in cached_copied_files
                            if file_string.endswith(".tst")
                        ]
                        self.test_files.update(tst_files)
                if not check_all:
                    split_sls = low_data["__sls__"].split(".")
                    sls_path_names = {
                        os.path.join(
                            os.sep.join(split_sls),
                            os.path.normpath(self.saltcheck_test_location),
                            "init.tst",
                        ),
                        os.path.join(
                            os.sep.join(split_sls[: len(split_sls) - 1]),
                            os.path.normpath(self.saltcheck_test_location),
                            "{}.tst".format(split_sls[-1]),
                        ),
                        os.path.join(
                            split_sls[0],
                            os.path.normpath(self.saltcheck_test_location),
                            os.sep.join(split_sls[1:-1]),
                            "{}.tst".format(split_sls[-1]),
                        ),
                    }
                    cached_copied_files = list(set(cached_copied_files))
                    for this_cached_test_file in cached_copied_files:
                        if this_cached_test_file.endswith(tuple(sls_path_names)):
                            self.test_files.add(this_cached_test_file)
                            cached_copied_files.remove(this_cached_test_file)
                            log.debug("Adding .tst file: %s", this_cached_test_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
