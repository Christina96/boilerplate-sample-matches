<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_path.py &amp; httpserver_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_path.py &amp; httpserver_test.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_path.py (5.949657%)<th>httpserver_test.py (1.2398665%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(143-151)<td><a href="#" name="0">(755-761)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(6-18)<td><a href="#" name="1">(5-16)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_path.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import ntpath
3 import os
4 import platform
5 import posixpath
6 import sys
7 import tempfile
8 import salt.utils.compat
9 import salt.utils.path
10 import salt.utils.platform
11 from salt.exceptions import CommandNotFoundError
12 from tests.support.mock import patch
13 from</b></font> tests.support.unit import TestCase, skipIf
14 class PathJoinTestCase(TestCase):
15     PLATFORM_FUNC = platform.system
16     BUILTIN_MODULES = sys.builtin_module_names
17     NIX_PATHS = (
18         (("/", "key"), "/key"),
19         (("/etc/salt", "/etc/salt/pki"), "/etc/salt/etc/salt/pki"),
20         (("/usr/local", "/etc/salt/pki"), "/usr/local/etc/salt/pki"),
21     )
22     WIN_PATHS = (
23         (("c:", "temp", "foo"), "c:\\temp\\foo"),
24         (("c:", r"\temp", r"\foo"), "c:\\temp\\foo"),
25         (("c:\\", r"\temp", r"\foo"), "c:\\temp\\foo"),
26         ((r"c:\\", r"\temp", r"\foo"), "c:\\temp\\foo"),
27         (("c:", r"\temp", r"\foo", "bar"), "c:\\temp\\foo\\bar"),
28         (("c:", r"\temp", r"\foo\bar"), "c:\\temp\\foo\\bar"),
29     )
30     @skipIf(True, "Skipped until properly mocked")
31     def test_nix_paths(self):
32         if platform.system().lower() == "windows":
33             self.skipTest(
34                 "Windows platform found. not running *nix salt.utils.path.join tests"
35             )
36         for idx, (parts, expected) in enumerate(self.NIX_PATHS):
37             path = salt.utils.path.join(*parts)
38             self.assertEqual("{}: {}".format(idx, path), "{}: {}".format(idx, expected))
39     @skipIf(True, "Skipped until properly mocked")
40     def test_windows_paths(self):
41         if platform.system().lower() != "windows":
42             self.skipTest(
43                 "Non windows platform found. not running non patched os.path "
44                 "salt.utils.path.join tests"
45             )
46         for idx, (parts, expected) in enumerate(self.WIN_PATHS):
47             path = salt.utils.path.join(*parts)
48             self.assertEqual("{}: {}".format(idx, path), "{}: {}".format(idx, expected))
49     @skipIf(True, "Skipped until properly mocked")
50     def test_windows_paths_patched_path_module(self):
51         if platform.system().lower() == "windows":
52             self.skipTest(
53                 "Windows platform found. not running patched os.path "
54                 "salt.utils.path.join tests"
55             )
56         self.__patch_path()
57         for idx, (parts, expected) in enumerate(self.WIN_PATHS):
58             path = salt.utils.path.join(*parts)
59             self.assertEqual("{}: {}".format(idx, path), "{}: {}".format(idx, expected))
60         self.__unpatch_path()
61     @skipIf(salt.utils.platform.is_windows(), "*nix-only test")
62     def test_mixed_unicode_and_binary(self):
63         """
64         This tests joining paths that contain a mix of components with unicode
65         strings and non-unicode strings with the unicode characters as binary.
66         This is no longer something we need to concern ourselves with in
67         Python 3, but the test should nonetheless pass on Python 3. Really what
68         we're testing here is that we don't get a UnicodeDecodeError when
69         running on Python 2.
70         """
71         a = "/foo/bar"
72         b = "Ð”"
73         expected = "/foo/bar/\u0414"
74         actual = salt.utils.path.join(a, b)
75         self.assertEqual(actual, expected)
76     def __patch_path(self):
77         import imp
78         modules = list(self.BUILTIN_MODULES[:])
79         modules.pop(modules.index("posix"))
80         modules.append("nt")
81         code = """'''Salt unittest loaded NT module'''"""
82         module = imp.new_module("nt")
83         exec(code, module.__dict__)
84         sys.modules["nt"] = module
85         sys.builtin_module_names = modules
86         platform.system = lambda: "windows"
87         for module in (ntpath, os, os.path, tempfile):
88             salt.utils.compat.reload(module)
89     def __unpatch_path(self):
90         del sys.modules["nt"]
91         sys.builtin_module_names = self.BUILTIN_MODULES[:]
92         platform.system = self.PLATFORM_FUNC
93         for module in (posixpath, os, os.path, tempfile, platform):
94             salt.utils.compat.reload(module)
95 class PathTestCase(TestCase):
96     def test_which_bin(self):
97         ret = salt.utils.path.which_bin("str")
98         self.assertIs(None, ret)
99         test_exes = ["ls", "echo"]
100         with patch("salt.utils.path.which", return_value="/tmp/dummy_path"):
101             ret = salt.utils.path.which_bin(test_exes)
102             self.assertEqual(ret, "/tmp/dummy_path")
103             ret = salt.utils.path.which_bin([])
104             self.assertIs(None, ret)
105         with patch("salt.utils.path.which", return_value=""):
106             ret = salt.utils.path.which_bin(test_exes)
107             self.assertIs(None, ret)
108         p = "\\windows\\system"
109         self.assertEqual(
110             salt.utils.path<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.sanitize_win_path("\\windows\\system"), "\\windows\\system"
111         )
112         self.assertEqual(
113             salt.utils.path.sanitize_win_path("\\bo:g|us\\p?at*h&gt;"),
114             "\\bo_g_us\\p_at_h_",
115         )
116     def test_check_or_die(self):
117         self.assertRaises(CommandNotFoundError, salt.utils.</b></font>path.check_or_die, None)
118         with patch("salt.utils.path.which", return_value=False):
119             self.assertRaises(
120                 CommandNotFoundError, salt.utils.path.check_or_die, "FAKE COMMAND"
121             )
122     def test_join(self):
123         with patch(
124             "salt.utils.platform.is_windows", return_value=False
125         ) as is_windows_mock:
126             self.assertFalse(is_windows_mock.return_value)
127             expected_path = os.path.join(os.sep + "a", "b", "c", "d")
128             ret = salt.utils.path.join("/a/b/c", "d")
129             self.assertEqual(ret, expected_path)
130 class TestWhich(TestCase):
131     """
132     Tests salt.utils.path.which function to ensure that it returns True as
133     expected.
134     """
135     def test_missing_binary_in_linux(self):
136         with patch("salt.utils.platform.is_windows", lambda: False):
137             with patch("salt.utils.path.which", lambda exe: None):
138                 self.assertTrue(
139                     salt.utils.path.which("this-binary-does-not-exist") is None
140                 )
141     def test_existing_binary_in_linux(self):
142         with patch("salt.utils.platform.is_windows", lambda: False):
143             with patch("salt.utils.path.which", lambda exe: exe):
144                 self.assertTrue(salt.utils.path.which("this-binary-exists-under-linux"))
145     def test_existing_binary_in_windows(self):
146         with patch("os.path.isfile") as isfile:
147             isfile.side_effect = [
148                 False,
149                 False,
150                 True,
151             ]
152             with patch("os.access", lambda path, mode: True):
153                 with patch("os.path.islink", lambda path: False):
154                     with patch("os.pathsep", ";"):
155                         with patch.dict(
156                             os.environ,
157                             {"PATH": os.sep + "bin", "PATHEXT": ".COM;.EXE;.BAT;.CMD"},
158                         ):
159                             with patch("salt.utils.platform.is_windows", lambda: True):
160                                 self.assertEqual(
161                                     salt.utils.path.which(
162                                         "this-binary-exists-under-windows"
163                                     ),
164                                     os.path.join(
165                                         os.sep + "bin",
166                                         "this-binary-exists-under-windows.EXE",
167                                     ),
168                                 )
169     def test_missing_binary_in_windows(self):
170         with patch("os.access") as osaccess:
171             osaccess.side_effect = [
172                 False,
173                 False,
174                 False,
175                 False,
176                 False,
177                 False,
178             ]
179             with patch("os.pathsep", ";"):
180                 with patch.dict(os.environ, {"PATH": os.sep + "bin"}):
181                     with patch("salt.utils.platform.is_windows", lambda: True):
182                         self.assertEqual(
183                             salt.utils.path.which(
184                                 "this-binary-is-missing-in-windows.exe"
185                             ),
186                             None,
187                         )
188     def test_existing_binary_in_windows_pathext(self):
189         with patch("os.path.isfile") as isfile:
190             isfile.side_effect = [
191                 False,
192                 False,
193                 False,
194                 False,
195                 True,
196             ]
197             with patch("os.access", lambda path, mode: True):
198                 with patch("os.path.islink", lambda path: False):
199                     with patch("os.pathsep", ";"):
200                         with patch.dict(
201                             os.environ,
202                             {
203                                 "PATH": os.sep + "bin",
204                                 "PATHEXT": (
205                                     ".COM;.EXE;.BAT;.CMD;.VBS;"
206                                     ".VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY"
207                                 ),
208                             },
209                         ):
210                             with patch("salt.utils.platform.is_windows", lambda: True):
211                                 self.assertEqual(
212                                     salt.utils.path.which(
213                                         "this-binary-exists-under-windows"
214                                     ),
215                                     os.path.join(
216                                         os.sep + "bin",
217                                         "this-binary-exists-under-windows.CMD",
218                                     ),
219                                 )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado import netutil
3 from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
4 from salt.ext.tornado import gen
5 from salt.ext.tornado.http1connection import HTTP1Connection
6 from salt.ext.tornado.httpserver import HTTPServer
7 from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
8 from salt.ext.tornado.iostream import IOStream
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado.netutil import ssl_options_to_context
11 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
12 from</b></font> salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipOnTravis
14 from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
15 from contextlib import closing
16 import datetime
17 import gzip
18 import os
19 import shutil
20 import socket
21 import ssl
22 import sys
23 import tempfile
24 from io import BytesIO
25 def read_stream_body(stream, callback):
26     """Reads an HTTP response from `stream` and runs callback with its
27     headers and body."""
28     chunks = []
29     class Delegate(HTTPMessageDelegate):
30         def headers_received(self, start_line, headers):
31             self.headers = headers
32         def data_received(self, chunk):
33             chunks.append(chunk)
34         def finish(self):
35             callback((self.headers, b''.join(chunks)))
36     conn = HTTP1Connection(stream, True)
37     conn.read_response(Delegate())
38 class HandlerBaseTestCase(AsyncHTTPTestCase):
39     def get_app(self):
40         return Application([('/', self.__class__.Handler)])
41     def fetch_json(self, *args, **kwargs):
42         response = self.fetch(*args, **kwargs)
43         response.rethrow()
44         return json_decode(response.body)
45 class HelloWorldRequestHandler(RequestHandler):
46     def initialize(self, protocol="http"):
47         self.expected_protocol = protocol
48     def get(self):
49         if self.request.protocol != self.expected_protocol:
50             raise Exception("unexpected protocol")
51         self.finish("Hello world")
52     def post(self):
53         self.finish("Got %d bytes in POST" % len(self.request.body))
54 skipIfOldSSL = unittest.skipIf(
55     getattr(ssl, 'OPENSSL_VERSION_INFO', (0, 0)) &lt; (1, 0),
56     "old version of ssl module and/or openssl")
57 class BaseSSLTest(AsyncHTTPSTestCase):
58     def get_app(self):
59         return Application([('/', HelloWorldRequestHandler,
60                              dict(protocol="https"))])
61 class SSLTestMixin(object):
62     def get_ssl_options(self):
63         return dict(ssl_version=self.get_ssl_version(),  # type: ignore
64                     **AsyncHTTPSTestCase.get_ssl_options())
65     def get_ssl_version(self):
66         raise NotImplementedError()
67     def test_ssl(self):
68         response = self.fetch('/')
69         self.assertEqual(response.body, b"Hello world")
70     def test_large_post(self):
71         response = self.fetch('/',
72                               method='POST',
73                               body='A' * 5000)
74         self.assertEqual(response.body, b"Got 5000 bytes in POST")
75     def test_non_ssl_request(self):
76         with ExpectLog(gen_log, '(SSL Error|uncaught exception)'):
77             with ExpectLog(gen_log, 'Uncaught exception', required=False):
78                 self.http_client.fetch(
79                     self.get_url("/").replace('https:', 'http:'),
80                     self.stop,
81                     request_timeout=3600,
82                     connect_timeout=3600)
83                 response = self.wait()
84         self.assertEqual(response.code, 599)
85     def test_error_logging(self):
86         with ExpectLog(gen_log, 'SSL Error') as expect_log:
87             self.http_client.fetch(
88                 self.get_url("/").replace("https:", "http:"),
89                 self.stop)
90             response = self.wait()
91             self.assertEqual(response.code, 599)
92         self.assertFalse(expect_log.logged_stack)
93 class SSLv23Test(BaseSSLTest, SSLTestMixin):
94     def get_ssl_version(self):
95         return ssl.PROTOCOL_SSLv23
96 @skipIfOldSSL
97 class SSLv3Test(BaseSSLTest, SSLTestMixin):
98     def get_ssl_version(self):
99         return ssl.PROTOCOL_SSLv3
100 @skipIfOldSSL
101 class TLSv1Test(BaseSSLTest, SSLTestMixin):
102     def get_ssl_version(self):
103         return ssl.PROTOCOL_TLSv1
104 @unittest.skipIf(not hasattr(ssl, 'SSLContext'), 'ssl.SSLContext not present')
105 class SSLContextTest(BaseSSLTest, SSLTestMixin):
106     def get_ssl_options(self):
107         context = ssl_options_to_context(
108             AsyncHTTPSTestCase.get_ssl_options(self))
109         assert isinstance(context, ssl.SSLContext)
110         return context
111 class BadSSLOptionsTest(unittest.TestCase):
112     def test_missing_arguments(self):
113         application = Application()
114         self.assertRaises(KeyError, HTTPServer, application, ssl_options={
115             "keyfile": "/__missing__.crt",
116         })
117     def test_missing_key(self):
118         application = Application()
119         module_dir = os.path.dirname(__file__)
120         existing_certificate = os.path.join(module_dir, 'test.crt')
121         existing_key = os.path.join(module_dir, 'test.key')
122         self.assertRaises((ValueError, IOError),
123                           HTTPServer, application, ssl_options={
124                               "certfile": "/__mising__.crt",
125         })
126         self.assertRaises((ValueError, IOError),
127                           HTTPServer, application, ssl_options={
128                               "certfile": existing_certificate,
129                               "keyfile": "/__missing__.key"
130         })
131         HTTPServer(application, ssl_options={
132                    "certfile": existing_certificate,
133                    "keyfile": existing_key,
134                    })
135 class MultipartTestHandler(RequestHandler):
136     def post(self):
137         self.finish({"header": self.request.headers["X-Header-Encoding-Test"],
138                      "argument": self.get_argument("argument"),
139                      "filename": self.request.files["files"][0].filename,
140                      "filebody": _unicode(self.request.files["files"][0]["body"]),
141                      })
142 class HTTPConnectionTest(AsyncHTTPTestCase):
143     def get_handlers(self):
144         return [("/multipart", MultipartTestHandler),
145                 ("/hello", HelloWorldRequestHandler)]
146     def get_app(self):
147         return Application(self.get_handlers())
148     def raw_fetch(self, headers, body, newline=b"\r\n"):
149         with closing(IOStream(socket.socket())) as stream:
150             stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
151             self.wait()
152             stream.write(
153                 newline.join(headers +
154                              [utf8("Content-Length: %d" % len(body))]) +
155                 newline + newline + body)
156             read_stream_body(stream, self.stop)
157             headers, body = self.wait()
158             return body
159     def test_multipart_form(self):
160         response = self.raw_fetch([
161             b"POST /multipart HTTP/1.0",
162             b"Content-Type: multipart/form-data; boundary=1234567890",
163             b"X-Header-encoding-test: \xe9",
164         ],
165             b"\r\n".join([
166                 b"Content-Disposition: form-data; name=argument",
167                 b"",
168                 u"\u00e1".encode("utf-8"),
169                 b"--1234567890",
170                 u'Content-Disposition: form-data; name="files"; filename="\u00f3"'.encode("utf8"),
171                 b"",
172                 u"\u00fa".encode("utf-8"),
173                 b"--1234567890--",
174                 b"",
175             ]))
176         data = json_decode(response)
177         self.assertEqual(u"\u00e9", data["header"])
178         self.assertEqual(u"\u00e1", data["argument"])
179         self.assertEqual(u"\u00f3", data["filename"])
180         self.assertEqual(u"\u00fa", data["filebody"])
181     def test_newlines(self):
182         for newline in (b"\r\n", b"\n"):
183             response = self.raw_fetch([b"GET /hello HTTP/1.0"], b"",
184                                       newline=newline)
185             self.assertEqual(response, b'Hello world')
186     def test_100_continue(self):
187         stream = IOStream(socket.socket(), io_loop=self.io_loop)
188         stream.connect(("127.0.0.1", self.get_http_port()), callback=self.stop)
189         self.wait()
190         stream.write(b"\r\n".join([b"POST /hello HTTP/1.1",
191                                    b"Content-Length: 1024",
192                                    b"Expect: 100-continue",
193                                    b"Connection: close",
194                                    b"\r\n"]), callback=self.stop)
195         self.wait()
196         stream.read_until(b"\r\n\r\n", self.stop)
197         data = self.wait()
198         self.assertTrue(data.startswith(b"HTTP/1.1 100 "), data)
199         stream.write(b"a" * 1024)
200         stream.read_until(b"\r\n", self.stop)
201         first_line = self.wait()
202         self.assertTrue(first_line.startswith(b"HTTP/1.1 200"), first_line)
203         stream.read_until(b"\r\n\r\n", self.stop)
204         header_data = self.wait()
205         headers = HTTPHeaders.parse(native_str(header_data.decode('latin1')))
206         stream.read_bytes(int(headers["Content-Length"]), self.stop)
207         body = self.wait()
208         self.assertEqual(body, b"Got 1024 bytes in POST")
209         stream.close()
210 class EchoHandler(RequestHandler):
211     def get(self):
212         self.write(recursive_unicode(self.request.arguments))
213     def post(self):
214         self.write(recursive_unicode(self.request.arguments))
215 class TypeCheckHandler(RequestHandler):
216     def prepare(self):
217         self.errors = {}
218         fields = [
219             ('method', str),
220             ('uri', str),
221             ('version', str),
222             ('remote_ip', str),
223             ('protocol', str),
224             ('host', str),
225             ('path', str),
226             ('query', str),
227         ]
228         for field, expected_type in fields:
229             self.check_type(field, getattr(self.request, field), expected_type)
230         self.check_type('header_key', list(self.request.headers.keys())[0], str)
231         self.check_type('header_value', list(self.request.headers.values())[0], str)
232         self.check_type('cookie_key', list(self.request.cookies.keys())[0], str)
233         self.check_type('cookie_value', list(self.request.cookies.values())[0].value, str)
234         self.check_type('arg_key', list(self.request.arguments.keys())[0], str)
235         self.check_type('arg_value', list(self.request.arguments.values())[0][0], bytes)
236     def post(self):
237         self.check_type('body', self.request.body, bytes)
238         self.write(self.errors)
239     def get(self):
240         self.write(self.errors)
241     def check_type(self, name, obj, expected_type):
242         actual_type = type(obj)
243         if expected_type != actual_type:
244             self.errors[name] = "expected %s, got %s" % (expected_type,
245                                                          actual_type)
246 class HTTPServerTest(AsyncHTTPTestCase):
247     def get_app(self):
248         return Application([("/echo", EchoHandler),
249                             ("/typecheck", TypeCheckHandler),
250                             ("//doubleslash", EchoHandler),
251                             ])
252     def test_query_string_encoding(self):
253         response = self.fetch("/echo?foo=%C3%A9")
254         data = json_decode(response.body)
255         self.assertEqual(data, {u"foo": [u"\u00e9"]})
256     def test_empty_query_string(self):
257         response = self.fetch("/echo?foo=&amp;foo=")
258         data = json_decode(response.body)
259         self.assertEqual(data, {u"foo": [u"", u""]})
260     def test_empty_post_parameters(self):
261         response = self.fetch("/echo", method="POST", body="foo=&amp;bar=")
262         data = json_decode(response.body)
263         self.assertEqual(data, {u"foo": [u""], u"bar": [u""]})
264     def test_types(self):
265         headers = {"Cookie": "foo=bar"}
266         response = self.fetch("/typecheck?foo=bar", headers=headers)
267         data = json_decode(response.body)
268         self.assertEqual(data, {})
269         response = self.fetch("/typecheck", method="POST", body="foo=bar", headers=headers)
270         data = json_decode(response.body)
271         self.assertEqual(data, {})
272     def test_double_slash(self):
273         response = self.fetch("//doubleslash")
274         self.assertEqual(200, response.code)
275         self.assertEqual(json_decode(response.body), {})
276     def test_malformed_body(self):
277         if str is bytes:
278             return
279         with ExpectLog(gen_log, 'Invalid x-www-form-urlencoded body'):
280             response = self.fetch(
281                 '/echo', method="POST",
282                 headers={'Content-Type': 'application/x-www-form-urlencoded'},
283                 body=b'\xe9')
284         self.assertEqual(200, response.code)
285         self.assertEqual(b'{}', response.body)
286 class HTTPServerRawTest(AsyncHTTPTestCase):
287     def get_app(self):
288         return Application([
289             ('/echo', EchoHandler),
290         ])
291     def setUp(self):
292         super(HTTPServerRawTest, self).setUp()
293         self.stream = IOStream(socket.socket())
294         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
295         self.wait()
296     def tearDown(self):
297         self.stream.close()
298         super(HTTPServerRawTest, self).tearDown()
299     def test_empty_request(self):
300         self.stream.close()
301         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
302         self.wait()
303     def test_malformed_first_line(self):
304         with ExpectLog(gen_log, '.*Malformed HTTP request line'):
305             self.stream.write(b'asdf\r\n\r\n')
306             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
307                                      self.stop)
308             self.wait()
309     def test_malformed_headers(self):
310         with ExpectLog(gen_log, '.*Malformed HTTP headers'):
311             self.stream.write(b'GET / HTTP/1.0\r\nasdf\r\n\r\n')
312             self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
313                                      self.stop)
314             self.wait()
315     def test_chunked_request_body(self):
316         self.stream.write(b"""\
317 POST /echo HTTP/1.1
318 Transfer-Encoding: chunked
319 Content-Type: application/x-www-form-urlencoded
320 4
321 foo=
322 3
323 bar
324 0
325 """.replace(b"\n", b"\r\n"))
326         read_stream_body(self.stream, self.stop)
327         headers, response = self.wait()
328         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
329     def test_chunked_request_uppercase(self):
330         self.stream.write(b"""\
331 POST /echo HTTP/1.1
332 Transfer-Encoding: Chunked
333 Content-Type: application/x-www-form-urlencoded
334 4
335 foo=
336 3
337 bar
338 0
339 """.replace(b"\n", b"\r\n"))
340         read_stream_body(self.stream, self.stop)
341         headers, response = self.wait()
342         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
343     def test_invalid_content_length(self):
344         with ExpectLog(gen_log, '.*Only integer Content-Length is allowed'):
345             self.stream.write(b"""\
346 POST /echo HTTP/1.1
347 Content-Length: foo
348 bar
349 """.replace(b"\n", b"\r\n"))
350             self.stream.read_until_close(self.stop)
351             self.wait()
352 class XHeaderTest(HandlerBaseTestCase):
353     class Handler(RequestHandler):
354         def get(self):
355             self.write(dict(remote_ip=self.request.remote_ip,
356                             remote_protocol=self.request.protocol))
357     def get_httpserver_options(self):
358         return dict(xheaders=True, trusted_downstream=['5.5.5.5'])
359     def test_ip_headers(self):
360         self.assertEqual(self.fetch_json("/")["remote_ip"], "127.0.0.1")
361         valid_ipv4 = {"X-Real-IP": "4.4.4.4"}
362         self.assertEqual(
363             self.fetch_json("/", headers=valid_ipv4)["remote_ip"],
364             "4.4.4.4")
365         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4"}
366         self.assertEqual(
367             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
368             "4.4.4.4")
369         valid_ipv6 = {"X-Real-IP": "2620:0:1cfe:face:b00c::3"}
370         self.assertEqual(
371             self.fetch_json("/", headers=valid_ipv6)["remote_ip"],
372             "2620:0:1cfe:face:b00c::3")
373         valid_ipv6_list = {"X-Forwarded-For": "::1, 2620:0:1cfe:face:b00c::3"}
374         self.assertEqual(
375             self.fetch_json("/", headers=valid_ipv6_list)["remote_ip"],
376             "2620:0:1cfe:face:b00c::3")
377         invalid_chars = {"X-Real-IP": "4.4.4.4&lt;script&gt;"}
378         self.assertEqual(
379             self.fetch_json("/", headers=invalid_chars)["remote_ip"],
380             "127.0.0.1")
381         invalid_chars_list = {"X-Forwarded-For": "4.4.4.4, 5.5.5.5&lt;script&gt;"}
382         self.assertEqual(
383             self.fetch_json("/", headers=invalid_chars_list)["remote_ip"],
384             "127.0.0.1")
385         invalid_host = {"X-Real-IP": "www.google.com"}
386         self.assertEqual(
387             self.fetch_json("/", headers=invalid_host)["remote_ip"],
388             "127.0.0.1")
389     def test_trusted_downstream(self):
390         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4, 5.5.5.5"}
391         self.assertEqual(
392             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
393             "4.4.4.4")
394     def test_scheme_headers(self):
395         self.assertEqual(self.fetch_json("/")["remote_protocol"], "http")
396         https_scheme = {"X-Scheme": "https"}
397         self.assertEqual(
398             self.fetch_json("/", headers=https_scheme)["remote_protocol"],
399             "https")
400         https_forwarded = {"X-Forwarded-Proto": "https"}
401         self.assertEqual(
402             self.fetch_json("/", headers=https_forwarded)["remote_protocol"],
403             "https")
404         bad_forwarded = {"X-Forwarded-Proto": "unknown"}
405         self.assertEqual(
406             self.fetch_json("/", headers=bad_forwarded)["remote_protocol"],
407             "http")
408 class SSLXHeaderTest(AsyncHTTPSTestCase, HandlerBaseTestCase):
409     def get_app(self):
410         return Application([('/', XHeaderTest.Handler)])
411     def get_httpserver_options(self):
412         output = super(SSLXHeaderTest, self).get_httpserver_options()
413         output['xheaders'] = True
414         return output
415     def test_request_without_xprotocol(self):
416         self.assertEqual(self.fetch_json("/")["remote_protocol"], "https")
417         http_scheme = {"X-Scheme": "http"}
418         self.assertEqual(
419             self.fetch_json("/", headers=http_scheme)["remote_protocol"], "http")
420         bad_scheme = {"X-Scheme": "unknown"}
421         self.assertEqual(
422             self.fetch_json("/", headers=bad_scheme)["remote_protocol"], "https")
423 class ManualProtocolTest(HandlerBaseTestCase):
424     class Handler(RequestHandler):
425         def get(self):
426             self.write(dict(protocol=self.request.protocol))
427     def get_httpserver_options(self):
428         return dict(protocol='https')
429     def test_manual_protocol(self):
430         self.assertEqual(self.fetch_json('/')['protocol'], 'https')
431 @unittest.skipIf(not hasattr(socket, 'AF_UNIX') or sys.platform == 'cygwin',
432                  "unix sockets not supported on this platform")
433 class UnixSocketTest(AsyncTestCase):
434     """HTTPServers can listen on Unix sockets too.
435     Why would you want to do this?  Nginx can proxy to backends listening
436     on unix sockets, for one thing (and managing a namespace for unix
437     sockets can be easier than managing a bunch of TCP port numbers).
438     Unfortunately, there's no way to specify a unix socket in a url for
439     an HTTP client, so we have to test this by hand.
440     """
441     def setUp(self):
442         super(UnixSocketTest, self).setUp()
443         self.tmpdir = tempfile.mkdtemp()
444         self.sockfile = os.path.join(self.tmpdir, "test.sock")
445         sock = netutil.bind_unix_socket(self.sockfile)
446         app = Application([("/hello", HelloWorldRequestHandler)])
447         self.server = HTTPServer(app, io_loop=self.io_loop)
448         self.server.add_socket(sock)
449         self.stream = IOStream(socket.socket(socket.AF_UNIX), io_loop=self.io_loop)
450         self.stream.connect(self.sockfile, self.stop)
451         self.wait()
452     def tearDown(self):
453         self.stream.close()
454         self.server.stop()
455         shutil.rmtree(self.tmpdir)
456         super(UnixSocketTest, self).tearDown()
457     def test_unix_socket(self):
458         self.stream.write(b"GET /hello HTTP/1.0\r\n\r\n")
459         self.stream.read_until(b"\r\n", self.stop)
460         response = self.wait()
461         self.assertEqual(response, b"HTTP/1.1 200 OK\r\n")
462         self.stream.read_until(b"\r\n\r\n", self.stop)
463         headers = HTTPHeaders.parse(self.wait().decode('latin1'))
464         self.stream.read_bytes(int(headers["Content-Length"]), self.stop)
465         body = self.wait()
466         self.assertEqual(body, b"Hello world")
467     def test_unix_socket_bad_request(self):
468         with ExpectLog(gen_log, "Malformed HTTP message from"):
469             self.stream.write(b"garbage\r\n\r\n")
470             self.stream.read_until_close(self.stop)
471             response = self.wait()
472         self.assertEqual(response, b"")
473 class KeepAliveTest(AsyncHTTPTestCase):
474     """Tests various scenarios for HTTP 1.1 keep-alive support.
475     These tests don't use AsyncHTTPClient because we want to control
476     connection reuse and closing.
477     """
478     def get_app(self):
479         class HelloHandler(RequestHandler):
480             def get(self):
481                 self.finish('Hello world')
482             def post(self):
483                 self.finish('Hello world')
484         class LargeHandler(RequestHandler):
485             def get(self):
486                 self.write(''.join(chr(i % 256) * 1024 for i in range(512)))
487         class FinishOnCloseHandler(RequestHandler):
488             @asynchronous
489             def get(self):
490                 self.flush()
491             def on_connection_close(self):
492                 self.finish('closed')
493         return Application([('/', HelloHandler),
494                             ('/large', LargeHandler),
495                             ('/finish_on_close', FinishOnCloseHandler)])
496     def setUp(self):
497         super(KeepAliveTest, self).setUp()
498         self.http_version = b'HTTP/1.1'
499     def tearDown(self):
500         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
501         self.wait()
502         if hasattr(self, 'stream'):
503             self.stream.close()
504         super(KeepAliveTest, self).tearDown()
505     def connect(self):
506         self.stream = IOStream(socket.socket(), io_loop=self.io_loop)
507         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
508         self.wait()
509     def read_headers(self):
510         self.stream.read_until(b'\r\n', self.stop)
511         first_line = self.wait()
512         self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
513         self.stream.read_until(b'\r\n\r\n', self.stop)
514         header_bytes = self.wait()
515         headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
516         return headers
517     def read_response(self):
518         self.headers = self.read_headers()
519         self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
520         body = self.wait()
521         self.assertEqual(b'Hello world', body)
522     def close(self):
523         self.stream.close()
524         del self.stream
525     def test_two_requests(self):
526         self.connect()
527         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
528         self.read_response()
529         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
530         self.read_response()
531         self.close()
532     def test_request_close(self):
533         self.connect()
534         self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
535         self.read_response()
536         self.stream.read_until_close(callback=self.stop)
537         data = self.wait()
538         self.assertTrue(not data)
539         self.close()
540     def test_http10(self):
541         self.http_version = b'HTTP/1.0'
542         self.connect()
543         self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
544         self.read_response()
545         self.stream.read_until_close(callback=self.stop)
546         data = self.wait()
547         self.assertTrue(not data)
548         self.assertTrue('Connection' not in self.headers)
549         self.close()
550     def test_http10_keepalive(self):
551         self.http_version = b'HTTP/1.0'
552         self.connect()
553         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
554         self.read_response()
555         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
556         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
557         self.read_response()
558         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
559         self.close()
560     def test_http10_keepalive_extra_crlf(self):
561         self.http_version = b'HTTP/1.0'
562         self.connect()
563         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
564         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
565         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
566         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.read_response()
567         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
568         self.close()
569     def test_pipelined_requests(self):
570         self.connect()
571         self.stream.</b></font>write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
572         self.read_response()
573         self.read_response()
574         self.close()
575     def test_pipelined_cancel(self):
576         self.connect()
577         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
578         self.read_response()
579         self.close()
580     def test_cancel_during_download(self):
581         self.connect()
582         self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
583         self.read_headers()
584         self.stream.read_bytes(1024, self.stop)
585         self.wait()
586         self.close()
587     def test_finish_while_closed(self):
588         self.connect()
589         self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
590         self.read_headers()
591         self.close()
592     def test_keepalive_chunked(self):
593         self.http_version = b'HTTP/1.0'
594         self.connect()
595         self.stream.write(b'POST / HTTP/1.0\r\n'
596                           b'Connection: keep-alive\r\n'
597                           b'Transfer-Encoding: chunked\r\n'
598                           b'\r\n'
599                           b'0\r\n'
600                           b'\r\n')
601         self.read_response()
602         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
603         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
604         self.read_response()
605         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
606         self.close()
607 class GzipBaseTest(object):
608     def get_app(self):
609         return Application([('/', EchoHandler)])
610     def post_gzip(self, body):
611         bytesio = BytesIO()
612         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
613         gzip_file.write(utf8(body))
614         gzip_file.close()
615         compressed_body = bytesio.getvalue()
616         return self.fetch('/', method='POST', body=compressed_body,
617                           headers={'Content-Encoding': 'gzip'})
618     def test_uncompressed(self):
619         response = self.fetch('/', method='POST', body='foo=bar')
620         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
621 class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
622     def get_httpserver_options(self):
623         return dict(decompress_request=True)
624     def test_gzip(self):
625         response = self.post_gzip('foo=bar')
626         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
627 class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
628     def test_gzip_unsupported(self):
629         with ExpectLog(gen_log, "Unsupported Content-Encoding"):
630             response = self.post_gzip('foo=bar')
631         self.assertEquals(json_decode(response.body), {})
632 class StreamingChunkSizeTest(AsyncHTTPTestCase):
633     BODY = b'01234567890123456789012345678901234567890123456789'
634     CHUNK_SIZE = 16
635     def get_http_client(self):
636         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
637     def get_httpserver_options(self):
638         return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)
639     class MessageDelegate(HTTPMessageDelegate):
640         def __init__(self, connection):
641             self.connection = connection
642         def headers_received(self, start_line, headers):
643             self.chunk_lengths = []
644         def data_received(self, chunk):
645             self.chunk_lengths.append(len(chunk))
646         def finish(self):
647             response_body = utf8(json_encode(self.chunk_lengths))
648             self.connection.write_headers(
649                 ResponseStartLine('HTTP/1.1', 200, 'OK'),
650                 HTTPHeaders({'Content-Length': str(len(response_body))}))
651             self.connection.write(response_body)
652             self.connection.finish()
653     def get_app(self):
654         class App(HTTPServerConnectionDelegate):
655             def start_request(self, server_conn, request_conn):
656                 return StreamingChunkSizeTest.MessageDelegate(request_conn)
657         return App()
658     def fetch_chunk_sizes(self, **kwargs):
659         response = self.fetch('/', method='POST', **kwargs)
660         response.rethrow()
661         chunks = json_decode(response.body)
662         self.assertEqual(len(self.BODY), sum(chunks))
663         for chunk_size in chunks:
664             self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
665                                  'oversized chunk: ' + str(chunks))
666             self.assertGreater(chunk_size, 0,
667                                'empty chunk: ' + str(chunks))
668         return chunks
669     def compress(self, body):
670         bytesio = BytesIO()
671         gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
672         gzfile.write(body)
673         gzfile.close()
674         compressed = bytesio.getvalue()
675         if len(compressed) &gt;= len(body):
676             raise Exception("body did not shrink when compressed")
677         return compressed
678     def test_regular_body(self):
679         chunks = self.fetch_chunk_sizes(body=self.BODY)
680         self.assertEqual([16, 16, 16, 2], chunks)
681     def test_compressed_body(self):
682         self.fetch_chunk_sizes(body=self.compress(self.BODY),
683                                headers={'Content-Encoding': 'gzip'})
684     def test_chunked_body(self):
685         def body_producer(write):
686             write(self.BODY[:20])
687             write(self.BODY[20:])
688         chunks = self.fetch_chunk_sizes(body_producer=body_producer)
689         self.assertEqual([16, 4, 16, 14], chunks)
690     def test_chunked_compressed(self):
691         compressed = self.compress(self.BODY)
692         self.assertGreater(len(compressed), 20)
693         def body_producer(write):
694             write(compressed[:20])
695             write(compressed[20:])
696         self.fetch_chunk_sizes(body_producer=body_producer,
697                                headers={'Content-Encoding': 'gzip'})
698 class MaxHeaderSizeTest(AsyncHTTPTestCase):
699     def get_app(self):
700         return Application([('/', HelloWorldRequestHandler)])
701     def get_httpserver_options(self):
702         return dict(max_header_size=1024)
703     def test_small_headers(self):
704         response = self.fetch("/", headers={'X-Filler': 'a' * 100})
705         response.rethrow()
706         self.assertEqual(response.body, b"Hello world")
707     def test_large_headers(self):
708         with ExpectLog(gen_log, "Unsatisfiable read", required=False):
709             response = self.fetch("/", headers={'X-Filler': 'a' * 1000})
710         self.assertIn(response.code, (431, 599))
711 @skipOnTravis
712 class IdleTimeoutTest(AsyncHTTPTestCase):
713     def get_app(self):
714         return Application([('/', HelloWorldRequestHandler)])
715     def get_httpserver_options(self):
716         return dict(idle_connection_timeout=0.1)
717     def setUp(self):
718         super(IdleTimeoutTest, self).setUp()
719         self.streams = []
720     def tearDown(self):
721         super(IdleTimeoutTest, self).tearDown()
722         for stream in self.streams:
723             stream.close()
724     def connect(self):
725         stream = IOStream(socket.socket())
726         stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
727         self.wait()
728         self.streams.append(stream)
729         return stream
730     def test_unused_connection(self):
731         stream = self.connect()
732         stream.set_close_callback(self.stop)
733         self.wait()
734     def test_idle_after_use(self):
735         stream = self.connect()
736         stream.set_close_callback(lambda: self.stop("closed"))
737         for i in range(2):
738             stream.write(b"GET / HTTP/1.1\r\n\r\n")
739             stream.read_until(b"\r\n\r\n", self.stop)
740             self.wait()
741             stream.read_bytes(11, self.stop)
742             data = self.wait()
743             self.assertEqual(data, b"Hello world")
744         data = self.wait()
745         self.assertEqual(data, "closed")
746 class BodyLimitsTest(AsyncHTTPTestCase):
747     def get_app(self):
748         class BufferedHandler(RequestHandler):
749             def put(self):
750                 self.write(str(len(self.request.body)))
751         @stream_request_body
752         class StreamingHandler(RequestHandler):
753             def initialize(self):
754                 self.bytes_read = 0
755             def prepare(self):
756                 if 'expected_size' in self.request.arguments:
757                     self.request.connection.set_max_body_size(
758                         int(self.get_argument('expected_size')))
759                 if 'body_timeout' in self.request.arguments:
760                     self.request.connection.set_body_timeout(
761                         float(self.get_argument('body_timeout')))
762             def data_received(self, data):
763                 self.bytes_read += len(data)
764             def put(self):
765                 self.write(str(self.bytes_read))
766         return Application([('/buffered', BufferedHandler),
767                             ('/streaming', StreamingHandler)])
768     def get_httpserver_options(self):
769         return dict(body_timeout=3600, max_body_size=4096)
770     def get_http_client(self):
771         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
772     def test_small_body(self):
773         response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
774         self.assertEqual(response.body, b'4096')
775         response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
776         self.assertEqual(response.body, b'4096')
777     def test_large_body_buffered(self):
778         with ExpectLog(gen_log, '.*Content-Length too long'):
779             response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
780         self.assertEqual(response.code, 599)
781     def test_large_body_buffered_chunked(self):
782         with ExpectLog(gen_log, '.*chunked body too large'):
783             response = self.fetch('/buffered', method='PUT',
784                                   body_producer=lambda write: write(b'a' * 10240))
785         self.assertEqual(response.code, 599)
786     def test_large_body_streaming(self):
787         with ExpectLog(gen_log, '.*Content-Length too long'):
788             response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
789         self.assertEqual(response.code, 599)
790     def test_large_body_streaming_chunked(self):
791         with ExpectLog(gen_log, '.*chunked body too large'):
792             response = self.fetch('/streaming', method='PUT',
793                                   body_producer=lambda write: write(b'a' * 10240))
794         self.assertEqual(response.code, 599)
795     def test_large_body_streaming_override(self):
796         response = self.fetch('/streaming?expected_size=10240', method='PUT',
797                               body=b'a' * 10240)
798         self.assertEqual(response.body, b'10240')
799     def test_large_body_streaming_chunked_override(self):
800         response = self.fetch('/streaming?expected_size=10240', method='PUT',
801                               body_producer=lambda write: write(b'a' * 10240))
802         self.assertEqual(response.body, b'10240')
803     @gen_test
804     def test_timeout(self):
805         stream = IOStream(socket.socket())
806         try:
807             yield stream.connect(('127.0.0.1', self.get_http_port()))
808             stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
809                          b'Content-Length: 42\r\n\r\n')
810             with ExpectLog(gen_log, 'Timeout reading body'):
811                 response = yield stream.read_until_close()
812             self.assertEqual(response, b'')
813         finally:
814             stream.close()
815     @gen_test
816     def test_body_size_override_reset(self):
817         stream = IOStream(socket.socket())
818         try:
819             yield stream.connect(('127.0.0.1', self.get_http_port()))
820             stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
821                          b'Content-Length: 10240\r\n\r\n')
822             stream.write(b'a' * 10240)
823             headers, response = yield gen.Task(read_stream_body, stream)
824             self.assertEqual(response, b'10240')
825             stream.write(b'PUT /streaming HTTP/1.1\r\n'
826                          b'Content-Length: 10240\r\n\r\n')
827             with ExpectLog(gen_log, '.*Content-Length too long'):
828                 data = yield stream.read_until_close()
829             self.assertEqual(data, b'')
830         finally:
831             stream.close()
832 class LegacyInterfaceTest(AsyncHTTPTestCase):
833     def get_app(self):
834         def handle_request(request):
835             self.http1 = request.version.startswith("HTTP/1.")
836             if not self.http1:
837                 request.connection.write_headers(
838                     ResponseStartLine('', 200, 'OK'),
839                     HTTPHeaders())
840                 request.connection.finish()
841                 return
842             message = b"Hello world"
843             request.write(utf8("HTTP/1.1 200 OK\r\n"
844                                "Content-Length: %d\r\n\r\n" % len(message)))
845             request.write(message)
846             request.finish()
847         return handle_request
848     def test_legacy_interface(self):
849         response = self.fetch('/')
850         if not self.http1:
851             self.skipTest("requires HTTP/1.x")
852         self.assertEqual(response.body, b"Hello world")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
