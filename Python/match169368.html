<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_path.py & httpserver_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_path.py & httpserver_test.py
      </h3>
      <h1 align="center">
        2.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_path.py (5.949657%)<TH>httpserver_test.py (1.2398665%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match169368-0.html#0',2,'match169368-1.html#0',3)" NAME="0">(143-151)<TD><A HREF="javascript:ZweiFrames('match169368-0.html#0',2,'match169368-1.html#0',3)" NAME="0">(755-761)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match169368-0.html#1',2,'match169368-1.html#1',3)" NAME="1">(6-18)<TD><A HREF="javascript:ZweiFrames('match169368-0.html#1',2,'match169368-1.html#1',3)" NAME="1">(5-16)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_path.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Tests for salt.utils.path
<A NAME="1"></A>&quot;&quot;&quot;


<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match169368-1.html#1',3,'match169368-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import ntpath
import os
import platform
import posixpath
import sys
import tempfile

import salt.utils.compat
import salt.utils.path
import salt.utils.platform
from salt.exceptions import CommandNotFoundError
from tests.support.mock import patch
from</B></FONT> tests.support.unit import TestCase, skipIf


class PathJoinTestCase(TestCase):

    PLATFORM_FUNC = platform.system
    BUILTIN_MODULES = sys.builtin_module_names

    NIX_PATHS = (
        ((&quot;/&quot;, &quot;key&quot;), &quot;/key&quot;),
        ((&quot;/etc/salt&quot;, &quot;/etc/salt/pki&quot;), &quot;/etc/salt/etc/salt/pki&quot;),
        ((&quot;/usr/local&quot;, &quot;/etc/salt/pki&quot;), &quot;/usr/local/etc/salt/pki&quot;),
    )

    WIN_PATHS = (
        ((&quot;c:&quot;, &quot;temp&quot;, &quot;foo&quot;), &quot;c:\\temp\\foo&quot;),
        ((&quot;c:&quot;, r&quot;\temp&quot;, r&quot;\foo&quot;), &quot;c:\\temp\\foo&quot;),
        ((&quot;c:\\&quot;, r&quot;\temp&quot;, r&quot;\foo&quot;), &quot;c:\\temp\\foo&quot;),
        ((r&quot;c:\\&quot;, r&quot;\temp&quot;, r&quot;\foo&quot;), &quot;c:\\temp\\foo&quot;),
        ((&quot;c:&quot;, r&quot;\temp&quot;, r&quot;\foo&quot;, &quot;bar&quot;), &quot;c:\\temp\\foo\\bar&quot;),
        ((&quot;c:&quot;, r&quot;\temp&quot;, r&quot;\foo\bar&quot;), &quot;c:\\temp\\foo\\bar&quot;),
    )

    @skipIf(True, &quot;Skipped until properly mocked&quot;)
    def test_nix_paths(self):
        if platform.system().lower() == &quot;windows&quot;:
            self.skipTest(
                &quot;Windows platform found. not running *nix salt.utils.path.join tests&quot;
            )
        for idx, (parts, expected) in enumerate(self.NIX_PATHS):
            path = salt.utils.path.join(*parts)
            self.assertEqual(&quot;{}: {}&quot;.format(idx, path), &quot;{}: {}&quot;.format(idx, expected))

    @skipIf(True, &quot;Skipped until properly mocked&quot;)
    def test_windows_paths(self):
        if platform.system().lower() != &quot;windows&quot;:
            self.skipTest(
                &quot;Non windows platform found. not running non patched os.path &quot;
                &quot;salt.utils.path.join tests&quot;
            )

        for idx, (parts, expected) in enumerate(self.WIN_PATHS):
            path = salt.utils.path.join(*parts)
            self.assertEqual(&quot;{}: {}&quot;.format(idx, path), &quot;{}: {}&quot;.format(idx, expected))

    @skipIf(True, &quot;Skipped until properly mocked&quot;)
    def test_windows_paths_patched_path_module(self):
        if platform.system().lower() == &quot;windows&quot;:
            self.skipTest(
                &quot;Windows platform found. not running patched os.path &quot;
                &quot;salt.utils.path.join tests&quot;
            )

        self.__patch_path()

        for idx, (parts, expected) in enumerate(self.WIN_PATHS):
            path = salt.utils.path.join(*parts)
            self.assertEqual(&quot;{}: {}&quot;.format(idx, path), &quot;{}: {}&quot;.format(idx, expected))

        self.__unpatch_path()

    @skipIf(salt.utils.platform.is_windows(), &quot;*nix-only test&quot;)
    def test_mixed_unicode_and_binary(self):
        &quot;&quot;&quot;
        This tests joining paths that contain a mix of components with unicode
        strings and non-unicode strings with the unicode characters as binary.

        This is no longer something we need to concern ourselves with in
        Python 3, but the test should nonetheless pass on Python 3. Really what
        we're testing here is that we don't get a UnicodeDecodeError when
        running on Python 2.
        &quot;&quot;&quot;
        a = &quot;/foo/bar&quot;
        b = &quot;Ð”&quot;
        expected = &quot;/foo/bar/\u0414&quot;
        actual = salt.utils.path.join(a, b)
        self.assertEqual(actual, expected)

    def __patch_path(self):
        import imp

        modules = list(self.BUILTIN_MODULES[:])
        modules.pop(modules.index(&quot;posix&quot;))
        modules.append(&quot;nt&quot;)

        code = &quot;&quot;&quot;'''Salt unittest loaded NT module'''&quot;&quot;&quot;
        module = imp.new_module(&quot;nt&quot;)
        exec(code, module.__dict__)
        sys.modules[&quot;nt&quot;] = module

        sys.builtin_module_names = modules
        platform.system = lambda: &quot;windows&quot;

        for module in (ntpath, os, os.path, tempfile):
            salt.utils.compat.reload(module)

    def __unpatch_path(self):
        del sys.modules[&quot;nt&quot;]
        sys.builtin_module_names = self.BUILTIN_MODULES[:]
        platform.system = self.PLATFORM_FUNC

        for module in (posixpath, os, os.path, tempfile, platform):
            salt.utils.compat.reload(module)


class PathTestCase(TestCase):
    def test_which_bin(self):
        ret = salt.utils.path.which_bin(&quot;str&quot;)
        self.assertIs(None, ret)

        test_exes = [&quot;ls&quot;, &quot;echo&quot;]
        with patch(&quot;salt.utils.path.which&quot;, return_value=&quot;/tmp/dummy_path&quot;):
            ret = salt.utils.path.which_bin(test_exes)
            self.assertEqual(ret, &quot;/tmp/dummy_path&quot;)

            ret = salt.utils.path.which_bin([])
            self.assertIs(None, ret)

        with patch(&quot;salt.utils.path.which&quot;, return_value=&quot;&quot;):
            ret = salt.utils.path.which_bin(test_exes)
            self.assertIs(None, ret)

<A NAME="0"></A>    def test_sanitize_win_path(self):
        p = &quot;\\windows\\system&quot;
        self.assertEqual(
            salt.utils.path<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match169368-1.html#0',3,'match169368-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.sanitize_win_path(&quot;\\windows\\system&quot;), &quot;\\windows\\system&quot;
        )
        self.assertEqual(
            salt.utils.path.sanitize_win_path(&quot;\\bo:g|us\\p?at*h&gt;&quot;),
            &quot;\\bo_g_us\\p_at_h_&quot;,
        )

    def test_check_or_die(self):
        self.assertRaises(CommandNotFoundError, salt.utils.</B></FONT>path.check_or_die, None)

        with patch(&quot;salt.utils.path.which&quot;, return_value=False):
            self.assertRaises(
                CommandNotFoundError, salt.utils.path.check_or_die, &quot;FAKE COMMAND&quot;
            )

    def test_join(self):
        with patch(
            &quot;salt.utils.platform.is_windows&quot;, return_value=False
        ) as is_windows_mock:
            self.assertFalse(is_windows_mock.return_value)
            expected_path = os.path.join(os.sep + &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
            ret = salt.utils.path.join(&quot;/a/b/c&quot;, &quot;d&quot;)
            self.assertEqual(ret, expected_path)


class TestWhich(TestCase):
    &quot;&quot;&quot;
    Tests salt.utils.path.which function to ensure that it returns True as
    expected.
    &quot;&quot;&quot;

    # The mock patch below will make sure that ALL calls to the which function
    # returns None
    def test_missing_binary_in_linux(self):
        # salt.utils.path.which uses platform.is_windows to determine the platform, so we're using linux here
        with patch(&quot;salt.utils.platform.is_windows&quot;, lambda: False):
            with patch(&quot;salt.utils.path.which&quot;, lambda exe: None):
                self.assertTrue(
                    salt.utils.path.which(&quot;this-binary-does-not-exist&quot;) is None
                )

    # The mock patch below will make sure that ALL calls to the which function
    # return whatever is sent to it
    def test_existing_binary_in_linux(self):
        # salt.utils.path.which uses platform.is_windows to determine the platform, so we're using linux here
        with patch(&quot;salt.utils.platform.is_windows&quot;, lambda: False):
            with patch(&quot;salt.utils.path.which&quot;, lambda exe: exe):
                self.assertTrue(salt.utils.path.which(&quot;this-binary-exists-under-linux&quot;))

    def test_existing_binary_in_windows(self):
        with patch(&quot;os.path.isfile&quot;) as isfile:
            # We define the side_effect attribute on the mocked object in order to
            # specify which calls return which values. First call to os.path.isfile
            # returns X, the second Y, the third Z, etc...
            isfile.side_effect = [
                # The first os.path.isfile should return False due to checking the explicit path (first is_executable)
                False,
                # We will now also return False once so we get a .EXE back from
                # the function, see PATHEXT below.
                False,
                # Lastly return True, this is the windows check.
                True,
            ]

            # Patch os.access so that it always returns True
            with patch(&quot;os.access&quot;, lambda path, mode: True):
                # Disable os.path.islink
                with patch(&quot;os.path.islink&quot;, lambda path: False):
                    # we're using ';' as os.pathsep in this test
                    with patch(&quot;os.pathsep&quot;, &quot;;&quot;):
                        # Let's patch os.environ to provide a custom PATH variable
                        with patch.dict(
                            os.environ,
                            {&quot;PATH&quot;: os.sep + &quot;bin&quot;, &quot;PATHEXT&quot;: &quot;.COM;.EXE;.BAT;.CMD&quot;},
                        ):
                            # Let's also patch is_windows to return True
                            with patch(&quot;salt.utils.platform.is_windows&quot;, lambda: True):
                                self.assertEqual(
                                    salt.utils.path.which(
                                        &quot;this-binary-exists-under-windows&quot;
                                    ),
                                    os.path.join(
                                        os.sep + &quot;bin&quot;,
                                        &quot;this-binary-exists-under-windows.EXE&quot;,
                                    ),
                                )

    def test_missing_binary_in_windows(self):
        with patch(&quot;os.access&quot;) as osaccess:
            osaccess.side_effect = [
                # The first os.access should return False due to checking the explicit path (first is_executable)
                False,
                # The second, iterating through $PATH, should also return False,
                # still checking for Linux
                # which() will add 4 extra paths to the given one, os.access will
                # be called 5 times
                False,
                False,
                False,
                False,
                False,
            ]
            # we're using ';' as os.pathsep in this test
            with patch(&quot;os.pathsep&quot;, &quot;;&quot;):
                # Let's patch os.environ to provide a custom PATH variable
                with patch.dict(os.environ, {&quot;PATH&quot;: os.sep + &quot;bin&quot;}):
                    # Let's also patch is_widows to return True
                    with patch(&quot;salt.utils.platform.is_windows&quot;, lambda: True):
                        self.assertEqual(
                            # Since we're passing the .exe suffix, the last True above
                            # will not matter. The result will be None
                            salt.utils.path.which(
                                &quot;this-binary-is-missing-in-windows.exe&quot;
                            ),
                            None,
                        )

    def test_existing_binary_in_windows_pathext(self):
        with patch(&quot;os.path.isfile&quot;) as isfile:
            # We define the side_effect attribute on the mocked object in order to
            # specify which calls return which values. First call to os.path.isfile
            # returns X, the second Y, the third Z, etc...
            isfile.side_effect = [
                # The first os.path.isfile should return False due to checking the explicit path (first is_executable)
                False,
                # We will now also return False 3 times so we get a .CMD back from
                # the function, see PATHEXT below.
                # Lastly return True, this is the windows check.
                False,
                False,
                False,
                True,
            ]

            # Patch os.access so that it always returns True
            with patch(&quot;os.access&quot;, lambda path, mode: True):

                # Disable os.path.islink
                with patch(&quot;os.path.islink&quot;, lambda path: False):

                    # we're using ';' as os.pathsep in this test
                    with patch(&quot;os.pathsep&quot;, &quot;;&quot;):

                        # Let's patch os.environ to provide a custom PATH variable
                        with patch.dict(
                            os.environ,
                            {
                                &quot;PATH&quot;: os.sep + &quot;bin&quot;,
                                &quot;PATHEXT&quot;: (
                                    &quot;.COM;.EXE;.BAT;.CMD;.VBS;&quot;
                                    &quot;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY&quot;
                                ),
                            },
                        ):

                            # Let's also patch is_windows to return True
                            with patch(&quot;salt.utils.platform.is_windows&quot;, lambda: True):
                                self.assertEqual(
                                    salt.utils.path.which(
                                        &quot;this-binary-exists-under-windows&quot;
                                    ),
                                    os.path.join(
                                        os.sep + &quot;bin&quot;,
                                        &quot;this-binary-exists-under-windows.CMD&quot;,
                                    ),
                                )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#!/usr/bin/env python
<A NAME="1"></A># pylint: skip-file


<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match169368-0.html#1',2,'match169368-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>from __future__ import absolute_import, division, print_function
from salt.ext.tornado import netutil
from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
from salt.ext.tornado import gen
from salt.ext.tornado.http1connection import HTTP1Connection
from salt.ext.tornado.httpserver import HTTPServer
from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
from salt.ext.tornado.iostream import IOStream
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.netutil import ssl_options_to_context
from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
from</B></FONT> salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
from salt.ext.tornado.test.util import unittest, skipOnTravis
from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
from contextlib import closing
import datetime
import gzip
import os
import shutil
import socket
import ssl
import sys
import tempfile
from io import BytesIO


def read_stream_body(stream, callback):
    &quot;&quot;&quot;Reads an HTTP response from `stream` and runs callback with its
    headers and body.&quot;&quot;&quot;
    chunks = []

    class Delegate(HTTPMessageDelegate):
        def headers_received(self, start_line, headers):
            self.headers = headers

        def data_received(self, chunk):
            chunks.append(chunk)

        def finish(self):
            callback((self.headers, b''.join(chunks)))
    conn = HTTP1Connection(stream, True)
    conn.read_response(Delegate())


class HandlerBaseTestCase(AsyncHTTPTestCase):
    def get_app(self):
        return Application([('/', self.__class__.Handler)])

    def fetch_json(self, *args, **kwargs):
        response = self.fetch(*args, **kwargs)
        response.rethrow()
        return json_decode(response.body)


class HelloWorldRequestHandler(RequestHandler):
    def initialize(self, protocol=&quot;http&quot;):
        self.expected_protocol = protocol

    def get(self):
        if self.request.protocol != self.expected_protocol:
            raise Exception(&quot;unexpected protocol&quot;)
        self.finish(&quot;Hello world&quot;)

    def post(self):
        self.finish(&quot;Got %d bytes in POST&quot; % len(self.request.body))


# In pre-1.0 versions of openssl, SSLv23 clients always send SSLv2
# ClientHello messages, which are rejected by SSLv3 and TLSv1
# servers.  Note that while the OPENSSL_VERSION_INFO was formally
# introduced in python3.2, it was present but undocumented in
# python 2.7
skipIfOldSSL = unittest.skipIf(
    getattr(ssl, 'OPENSSL_VERSION_INFO', (0, 0)) &lt; (1, 0),
    &quot;old version of ssl module and/or openssl&quot;)


class BaseSSLTest(AsyncHTTPSTestCase):
    def get_app(self):
        return Application([('/', HelloWorldRequestHandler,
                             dict(protocol=&quot;https&quot;))])


class SSLTestMixin(object):
    def get_ssl_options(self):
        return dict(ssl_version=self.get_ssl_version(),  # type: ignore
                    **AsyncHTTPSTestCase.get_ssl_options())

    def get_ssl_version(self):
        raise NotImplementedError()

    def test_ssl(self):
        response = self.fetch('/')
        self.assertEqual(response.body, b&quot;Hello world&quot;)

    def test_large_post(self):
        response = self.fetch('/',
                              method='POST',
                              body='A' * 5000)
        self.assertEqual(response.body, b&quot;Got 5000 bytes in POST&quot;)

    def test_non_ssl_request(self):
        # Make sure the server closes the connection when it gets a non-ssl
        # connection, rather than waiting for a timeout or otherwise
        # misbehaving.
        with ExpectLog(gen_log, '(SSL Error|uncaught exception)'):
            with ExpectLog(gen_log, 'Uncaught exception', required=False):
                self.http_client.fetch(
                    self.get_url(&quot;/&quot;).replace('https:', 'http:'),
                    self.stop,
                    request_timeout=3600,
                    connect_timeout=3600)
                response = self.wait()
        self.assertEqual(response.code, 599)

    def test_error_logging(self):
        # No stack traces are logged for SSL errors.
        with ExpectLog(gen_log, 'SSL Error') as expect_log:
            self.http_client.fetch(
                self.get_url(&quot;/&quot;).replace(&quot;https:&quot;, &quot;http:&quot;),
                self.stop)
            response = self.wait()
            self.assertEqual(response.code, 599)
        self.assertFalse(expect_log.logged_stack)

# Python's SSL implementation differs significantly between versions.
# For example, SSLv3 and TLSv1 throw an exception if you try to read
# from the socket before the handshake is complete, but the default
# of SSLv23 allows it.


class SSLv23Test(BaseSSLTest, SSLTestMixin):
    def get_ssl_version(self):
        return ssl.PROTOCOL_SSLv23


@skipIfOldSSL
class SSLv3Test(BaseSSLTest, SSLTestMixin):
    def get_ssl_version(self):
        return ssl.PROTOCOL_SSLv3


@skipIfOldSSL
class TLSv1Test(BaseSSLTest, SSLTestMixin):
    def get_ssl_version(self):
        return ssl.PROTOCOL_TLSv1


@unittest.skipIf(not hasattr(ssl, 'SSLContext'), 'ssl.SSLContext not present')
class SSLContextTest(BaseSSLTest, SSLTestMixin):
    def get_ssl_options(self):
        context = ssl_options_to_context(
            AsyncHTTPSTestCase.get_ssl_options(self))
        assert isinstance(context, ssl.SSLContext)
        return context


class BadSSLOptionsTest(unittest.TestCase):
    def test_missing_arguments(self):
        application = Application()
        self.assertRaises(KeyError, HTTPServer, application, ssl_options={
            &quot;keyfile&quot;: &quot;/__missing__.crt&quot;,
        })

    def test_missing_key(self):
        &quot;&quot;&quot;A missing SSL key should cause an immediate exception.&quot;&quot;&quot;

        application = Application()
        module_dir = os.path.dirname(__file__)
        existing_certificate = os.path.join(module_dir, 'test.crt')
        existing_key = os.path.join(module_dir, 'test.key')

        self.assertRaises((ValueError, IOError),
                          HTTPServer, application, ssl_options={
                              &quot;certfile&quot;: &quot;/__mising__.crt&quot;,
        })
        self.assertRaises((ValueError, IOError),
                          HTTPServer, application, ssl_options={
                              &quot;certfile&quot;: existing_certificate,
                              &quot;keyfile&quot;: &quot;/__missing__.key&quot;
        })

        # This actually works because both files exist
        HTTPServer(application, ssl_options={
                   &quot;certfile&quot;: existing_certificate,
                   &quot;keyfile&quot;: existing_key,
                   })


class MultipartTestHandler(RequestHandler):
    def post(self):
        self.finish({&quot;header&quot;: self.request.headers[&quot;X-Header-Encoding-Test&quot;],
                     &quot;argument&quot;: self.get_argument(&quot;argument&quot;),
                     &quot;filename&quot;: self.request.files[&quot;files&quot;][0].filename,
                     &quot;filebody&quot;: _unicode(self.request.files[&quot;files&quot;][0][&quot;body&quot;]),
                     })


# This test is also called from wsgi_test
class HTTPConnectionTest(AsyncHTTPTestCase):
    def get_handlers(self):
        return [(&quot;/multipart&quot;, MultipartTestHandler),
                (&quot;/hello&quot;, HelloWorldRequestHandler)]

    def get_app(self):
        return Application(self.get_handlers())

    def raw_fetch(self, headers, body, newline=b&quot;\r\n&quot;):
        with closing(IOStream(socket.socket())) as stream:
            stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
            self.wait()
            stream.write(
                newline.join(headers +
                             [utf8(&quot;Content-Length: %d&quot; % len(body))]) +
                newline + newline + body)
            read_stream_body(stream, self.stop)
            headers, body = self.wait()
            return body

    def test_multipart_form(self):
        # Encodings here are tricky:  Headers are latin1, bodies can be
        # anything (we use utf8 by default).
        response = self.raw_fetch([
            b&quot;POST /multipart HTTP/1.0&quot;,
            b&quot;Content-Type: multipart/form-data; boundary=1234567890&quot;,
            b&quot;X-Header-encoding-test: \xe9&quot;,
        ],
            b&quot;\r\n&quot;.join([
                b&quot;Content-Disposition: form-data; name=argument&quot;,
                b&quot;&quot;,
                u&quot;\u00e1&quot;.encode(&quot;utf-8&quot;),
                b&quot;--1234567890&quot;,
                u'Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;\u00f3&quot;'.encode(&quot;utf8&quot;),
                b&quot;&quot;,
                u&quot;\u00fa&quot;.encode(&quot;utf-8&quot;),
                b&quot;--1234567890--&quot;,
                b&quot;&quot;,
            ]))
        data = json_decode(response)
        self.assertEqual(u&quot;\u00e9&quot;, data[&quot;header&quot;])
        self.assertEqual(u&quot;\u00e1&quot;, data[&quot;argument&quot;])
        self.assertEqual(u&quot;\u00f3&quot;, data[&quot;filename&quot;])
        self.assertEqual(u&quot;\u00fa&quot;, data[&quot;filebody&quot;])

    def test_newlines(self):
        # We support both CRLF and bare LF as line separators.
        for newline in (b&quot;\r\n&quot;, b&quot;\n&quot;):
            response = self.raw_fetch([b&quot;GET /hello HTTP/1.0&quot;], b&quot;&quot;,
                                      newline=newline)
            self.assertEqual(response, b'Hello world')

    def test_100_continue(self):
        # Run through a 100-continue interaction by hand:
        # When given Expect: 100-continue, we get a 100 response after the
        # headers, and then the real response after the body.
        stream = IOStream(socket.socket(), io_loop=self.io_loop)
        stream.connect((&quot;127.0.0.1&quot;, self.get_http_port()), callback=self.stop)
        self.wait()
        stream.write(b&quot;\r\n&quot;.join([b&quot;POST /hello HTTP/1.1&quot;,
                                   b&quot;Content-Length: 1024&quot;,
                                   b&quot;Expect: 100-continue&quot;,
                                   b&quot;Connection: close&quot;,
                                   b&quot;\r\n&quot;]), callback=self.stop)
        self.wait()
        stream.read_until(b&quot;\r\n\r\n&quot;, self.stop)
        data = self.wait()
        self.assertTrue(data.startswith(b&quot;HTTP/1.1 100 &quot;), data)
        stream.write(b&quot;a&quot; * 1024)
        stream.read_until(b&quot;\r\n&quot;, self.stop)
        first_line = self.wait()
        self.assertTrue(first_line.startswith(b&quot;HTTP/1.1 200&quot;), first_line)
        stream.read_until(b&quot;\r\n\r\n&quot;, self.stop)
        header_data = self.wait()
        headers = HTTPHeaders.parse(native_str(header_data.decode('latin1')))
        stream.read_bytes(int(headers[&quot;Content-Length&quot;]), self.stop)
        body = self.wait()
        self.assertEqual(body, b&quot;Got 1024 bytes in POST&quot;)
        stream.close()


class EchoHandler(RequestHandler):
    def get(self):
        self.write(recursive_unicode(self.request.arguments))

    def post(self):
        self.write(recursive_unicode(self.request.arguments))


class TypeCheckHandler(RequestHandler):
    def prepare(self):
        self.errors = {}
        fields = [
            ('method', str),
            ('uri', str),
            ('version', str),
            ('remote_ip', str),
            ('protocol', str),
            ('host', str),
            ('path', str),
            ('query', str),
        ]
        for field, expected_type in fields:
            self.check_type(field, getattr(self.request, field), expected_type)

        self.check_type('header_key', list(self.request.headers.keys())[0], str)
        self.check_type('header_value', list(self.request.headers.values())[0], str)

        self.check_type('cookie_key', list(self.request.cookies.keys())[0], str)
        self.check_type('cookie_value', list(self.request.cookies.values())[0].value, str)
        # secure cookies

        self.check_type('arg_key', list(self.request.arguments.keys())[0], str)
        self.check_type('arg_value', list(self.request.arguments.values())[0][0], bytes)

    def post(self):
        self.check_type('body', self.request.body, bytes)
        self.write(self.errors)

    def get(self):
        self.write(self.errors)

    def check_type(self, name, obj, expected_type):
        actual_type = type(obj)
        if expected_type != actual_type:
            self.errors[name] = &quot;expected %s, got %s&quot; % (expected_type,
                                                         actual_type)


class HTTPServerTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application([(&quot;/echo&quot;, EchoHandler),
                            (&quot;/typecheck&quot;, TypeCheckHandler),
                            (&quot;//doubleslash&quot;, EchoHandler),
                            ])

    def test_query_string_encoding(self):
        response = self.fetch(&quot;/echo?foo=%C3%A9&quot;)
        data = json_decode(response.body)
        self.assertEqual(data, {u&quot;foo&quot;: [u&quot;\u00e9&quot;]})

    def test_empty_query_string(self):
        response = self.fetch(&quot;/echo?foo=&amp;foo=&quot;)
        data = json_decode(response.body)
        self.assertEqual(data, {u&quot;foo&quot;: [u&quot;&quot;, u&quot;&quot;]})

    def test_empty_post_parameters(self):
        response = self.fetch(&quot;/echo&quot;, method=&quot;POST&quot;, body=&quot;foo=&amp;bar=&quot;)
        data = json_decode(response.body)
        self.assertEqual(data, {u&quot;foo&quot;: [u&quot;&quot;], u&quot;bar&quot;: [u&quot;&quot;]})

    def test_types(self):
        headers = {&quot;Cookie&quot;: &quot;foo=bar&quot;}
        response = self.fetch(&quot;/typecheck?foo=bar&quot;, headers=headers)
        data = json_decode(response.body)
        self.assertEqual(data, {})

        response = self.fetch(&quot;/typecheck&quot;, method=&quot;POST&quot;, body=&quot;foo=bar&quot;, headers=headers)
        data = json_decode(response.body)
        self.assertEqual(data, {})

    def test_double_slash(self):
        # urlparse.urlsplit (which tornado.httpserver used to use
        # incorrectly) would parse paths beginning with &quot;//&quot; as
        # protocol-relative urls.
        response = self.fetch(&quot;//doubleslash&quot;)
        self.assertEqual(200, response.code)
        self.assertEqual(json_decode(response.body), {})

    def test_malformed_body(self):
        # parse_qs is pretty forgiving, but it will fail on python 3
        # if the data is not utf8.  On python 2 parse_qs will work,
        # but then the recursive_unicode call in EchoHandler will
        # fail.
        if str is bytes:
            return
        with ExpectLog(gen_log, 'Invalid x-www-form-urlencoded body'):
            response = self.fetch(
                '/echo', method=&quot;POST&quot;,
                headers={'Content-Type': 'application/x-www-form-urlencoded'},
                body=b'\xe9')
        self.assertEqual(200, response.code)
        self.assertEqual(b'{}', response.body)


class HTTPServerRawTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application([
            ('/echo', EchoHandler),
        ])

    def setUp(self):
        super(HTTPServerRawTest, self).setUp()
        self.stream = IOStream(socket.socket())
        self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
        self.wait()

    def tearDown(self):
        self.stream.close()
        super(HTTPServerRawTest, self).tearDown()

    def test_empty_request(self):
        self.stream.close()
        self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
        self.wait()

    def test_malformed_first_line(self):
        with ExpectLog(gen_log, '.*Malformed HTTP request line'):
            self.stream.write(b'asdf\r\n\r\n')
            # TODO: need an async version of ExpectLog so we don't need
            # hard-coded timeouts here.
            self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
                                     self.stop)
            self.wait()

    def test_malformed_headers(self):
        with ExpectLog(gen_log, '.*Malformed HTTP headers'):
            self.stream.write(b'GET / HTTP/1.0\r\nasdf\r\n\r\n')
            self.io_loop.add_timeout(datetime.timedelta(seconds=0.05),
                                     self.stop)
            self.wait()

    def test_chunked_request_body(self):
        # Chunked requests are not widely supported and we don't have a way
        # to generate them in AsyncHTTPClient, but HTTPServer will read them.
        self.stream.write(b&quot;&quot;&quot;\
POST /echo HTTP/1.1
Transfer-Encoding: chunked
Content-Type: application/x-www-form-urlencoded

4
foo=
3
bar
0

&quot;&quot;&quot;.replace(b&quot;\n&quot;, b&quot;\r\n&quot;))
        read_stream_body(self.stream, self.stop)
        headers, response = self.wait()
        self.assertEqual(json_decode(response), {u'foo': [u'bar']})

    def test_chunked_request_uppercase(self):
        # As per RFC 2616 section 3.6, &quot;Transfer-Encoding&quot; header's value is
        # case-insensitive.
        self.stream.write(b&quot;&quot;&quot;\
POST /echo HTTP/1.1
Transfer-Encoding: Chunked
Content-Type: application/x-www-form-urlencoded

4
foo=
3
bar
0

&quot;&quot;&quot;.replace(b&quot;\n&quot;, b&quot;\r\n&quot;))
        read_stream_body(self.stream, self.stop)
        headers, response = self.wait()
        self.assertEqual(json_decode(response), {u'foo': [u'bar']})

    def test_invalid_content_length(self):
        with ExpectLog(gen_log, '.*Only integer Content-Length is allowed'):
            self.stream.write(b&quot;&quot;&quot;\
POST /echo HTTP/1.1
Content-Length: foo

bar

&quot;&quot;&quot;.replace(b&quot;\n&quot;, b&quot;\r\n&quot;))
            self.stream.read_until_close(self.stop)
            self.wait()


class XHeaderTest(HandlerBaseTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.write(dict(remote_ip=self.request.remote_ip,
                            remote_protocol=self.request.protocol))

    def get_httpserver_options(self):
        return dict(xheaders=True, trusted_downstream=['5.5.5.5'])

    def test_ip_headers(self):
        self.assertEqual(self.fetch_json(&quot;/&quot;)[&quot;remote_ip&quot;], &quot;127.0.0.1&quot;)

        valid_ipv4 = {&quot;X-Real-IP&quot;: &quot;4.4.4.4&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=valid_ipv4)[&quot;remote_ip&quot;],
            &quot;4.4.4.4&quot;)

        valid_ipv4_list = {&quot;X-Forwarded-For&quot;: &quot;127.0.0.1, 4.4.4.4&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=valid_ipv4_list)[&quot;remote_ip&quot;],
            &quot;4.4.4.4&quot;)

        valid_ipv6 = {&quot;X-Real-IP&quot;: &quot;2620:0:1cfe:face:b00c::3&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=valid_ipv6)[&quot;remote_ip&quot;],
            &quot;2620:0:1cfe:face:b00c::3&quot;)

        valid_ipv6_list = {&quot;X-Forwarded-For&quot;: &quot;::1, 2620:0:1cfe:face:b00c::3&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=valid_ipv6_list)[&quot;remote_ip&quot;],
            &quot;2620:0:1cfe:face:b00c::3&quot;)

        invalid_chars = {&quot;X-Real-IP&quot;: &quot;4.4.4.4&lt;script&gt;&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=invalid_chars)[&quot;remote_ip&quot;],
            &quot;127.0.0.1&quot;)

        invalid_chars_list = {&quot;X-Forwarded-For&quot;: &quot;4.4.4.4, 5.5.5.5&lt;script&gt;&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=invalid_chars_list)[&quot;remote_ip&quot;],
            &quot;127.0.0.1&quot;)

        invalid_host = {&quot;X-Real-IP&quot;: &quot;www.google.com&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=invalid_host)[&quot;remote_ip&quot;],
            &quot;127.0.0.1&quot;)

    def test_trusted_downstream(self):

        valid_ipv4_list = {&quot;X-Forwarded-For&quot;: &quot;127.0.0.1, 4.4.4.4, 5.5.5.5&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=valid_ipv4_list)[&quot;remote_ip&quot;],
            &quot;4.4.4.4&quot;)

    def test_scheme_headers(self):
        self.assertEqual(self.fetch_json(&quot;/&quot;)[&quot;remote_protocol&quot;], &quot;http&quot;)

        https_scheme = {&quot;X-Scheme&quot;: &quot;https&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=https_scheme)[&quot;remote_protocol&quot;],
            &quot;https&quot;)

        https_forwarded = {&quot;X-Forwarded-Proto&quot;: &quot;https&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=https_forwarded)[&quot;remote_protocol&quot;],
            &quot;https&quot;)

        bad_forwarded = {&quot;X-Forwarded-Proto&quot;: &quot;unknown&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=bad_forwarded)[&quot;remote_protocol&quot;],
            &quot;http&quot;)


class SSLXHeaderTest(AsyncHTTPSTestCase, HandlerBaseTestCase):
    def get_app(self):
        return Application([('/', XHeaderTest.Handler)])

    def get_httpserver_options(self):
        output = super(SSLXHeaderTest, self).get_httpserver_options()
        output['xheaders'] = True
        return output

    def test_request_without_xprotocol(self):
        self.assertEqual(self.fetch_json(&quot;/&quot;)[&quot;remote_protocol&quot;], &quot;https&quot;)

        http_scheme = {&quot;X-Scheme&quot;: &quot;http&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=http_scheme)[&quot;remote_protocol&quot;], &quot;http&quot;)

        bad_scheme = {&quot;X-Scheme&quot;: &quot;unknown&quot;}
        self.assertEqual(
            self.fetch_json(&quot;/&quot;, headers=bad_scheme)[&quot;remote_protocol&quot;], &quot;https&quot;)


class ManualProtocolTest(HandlerBaseTestCase):
    class Handler(RequestHandler):
        def get(self):
            self.write(dict(protocol=self.request.protocol))

    def get_httpserver_options(self):
        return dict(protocol='https')

    def test_manual_protocol(self):
        self.assertEqual(self.fetch_json('/')['protocol'], 'https')


@unittest.skipIf(not hasattr(socket, 'AF_UNIX') or sys.platform == 'cygwin',
                 &quot;unix sockets not supported on this platform&quot;)
class UnixSocketTest(AsyncTestCase):
    &quot;&quot;&quot;HTTPServers can listen on Unix sockets too.

    Why would you want to do this?  Nginx can proxy to backends listening
    on unix sockets, for one thing (and managing a namespace for unix
    sockets can be easier than managing a bunch of TCP port numbers).

    Unfortunately, there's no way to specify a unix socket in a url for
    an HTTP client, so we have to test this by hand.
    &quot;&quot;&quot;
    def setUp(self):
        super(UnixSocketTest, self).setUp()
        self.tmpdir = tempfile.mkdtemp()
        self.sockfile = os.path.join(self.tmpdir, &quot;test.sock&quot;)
        sock = netutil.bind_unix_socket(self.sockfile)
        app = Application([(&quot;/hello&quot;, HelloWorldRequestHandler)])
        self.server = HTTPServer(app, io_loop=self.io_loop)
        self.server.add_socket(sock)
        self.stream = IOStream(socket.socket(socket.AF_UNIX), io_loop=self.io_loop)
        self.stream.connect(self.sockfile, self.stop)
        self.wait()

    def tearDown(self):
        self.stream.close()
        self.server.stop()
        shutil.rmtree(self.tmpdir)
        super(UnixSocketTest, self).tearDown()

    def test_unix_socket(self):
        self.stream.write(b&quot;GET /hello HTTP/1.0\r\n\r\n&quot;)
        self.stream.read_until(b&quot;\r\n&quot;, self.stop)
        response = self.wait()
        self.assertEqual(response, b&quot;HTTP/1.1 200 OK\r\n&quot;)
        self.stream.read_until(b&quot;\r\n\r\n&quot;, self.stop)
        headers = HTTPHeaders.parse(self.wait().decode('latin1'))
        self.stream.read_bytes(int(headers[&quot;Content-Length&quot;]), self.stop)
        body = self.wait()
        self.assertEqual(body, b&quot;Hello world&quot;)

    def test_unix_socket_bad_request(self):
        # Unix sockets don't have remote addresses so they just return an
        # empty string.
        with ExpectLog(gen_log, &quot;Malformed HTTP message from&quot;):
            self.stream.write(b&quot;garbage\r\n\r\n&quot;)
            self.stream.read_until_close(self.stop)
            response = self.wait()
        self.assertEqual(response, b&quot;&quot;)


class KeepAliveTest(AsyncHTTPTestCase):
    &quot;&quot;&quot;Tests various scenarios for HTTP 1.1 keep-alive support.

    These tests don't use AsyncHTTPClient because we want to control
    connection reuse and closing.
    &quot;&quot;&quot;
    def get_app(self):
        class HelloHandler(RequestHandler):
            def get(self):
                self.finish('Hello world')

            def post(self):
                self.finish('Hello world')

        class LargeHandler(RequestHandler):
            def get(self):
                # 512KB should be bigger than the socket buffers so it will
                # be written out in chunks.
                self.write(''.join(chr(i % 256) * 1024 for i in range(512)))

        class FinishOnCloseHandler(RequestHandler):
            @asynchronous
            def get(self):
                self.flush()

            def on_connection_close(self):
                # This is not very realistic, but finishing the request
                # from the close callback has the right timing to mimic
                # some errors seen in the wild.
                self.finish('closed')

        return Application([('/', HelloHandler),
                            ('/large', LargeHandler),
                            ('/finish_on_close', FinishOnCloseHandler)])

    def setUp(self):
        super(KeepAliveTest, self).setUp()
        self.http_version = b'HTTP/1.1'

    def tearDown(self):
        # We just closed the client side of the socket; let the IOLoop run
        # once to make sure the server side got the message.
        self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
        self.wait()

        if hasattr(self, 'stream'):
            self.stream.close()
        super(KeepAliveTest, self).tearDown()

    # The next few methods are a crude manual http client
    def connect(self):
        self.stream = IOStream(socket.socket(), io_loop=self.io_loop)
        self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
        self.wait()

    def read_headers(self):
        self.stream.read_until(b'\r\n', self.stop)
        first_line = self.wait()
        self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
        self.stream.read_until(b'\r\n\r\n', self.stop)
        header_bytes = self.wait()
        headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
        return headers

    def read_response(self):
        self.headers = self.read_headers()
        self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
        body = self.wait()
        self.assertEqual(b'Hello world', body)

    def close(self):
        self.stream.close()
        del self.stream

    def test_two_requests(self):
        self.connect()
        self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
        self.read_response()
        self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
        self.read_response()
        self.close()

    def test_request_close(self):
        self.connect()
        self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
        self.read_response()
        self.stream.read_until_close(callback=self.stop)
        data = self.wait()
        self.assertTrue(not data)
        self.close()

    # keepalive is supported for http 1.0 too, but it's opt-in
    def test_http10(self):
        self.http_version = b'HTTP/1.0'
        self.connect()
        self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
        self.read_response()
        self.stream.read_until_close(callback=self.stop)
        data = self.wait()
        self.assertTrue(not data)
        self.assertTrue('Connection' not in self.headers)
        self.close()

    def test_http10_keepalive(self):
        self.http_version = b'HTTP/1.0'
        self.connect()
        self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
        self.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
        self.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.close()

    def test_http10_keepalive_extra_crlf(self):
        self.http_version = b'HTTP/1.0'
        self.connect()
        self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
<A NAME="0"></A>        self.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match169368-0.html#0',2,'match169368-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.close()

    def test_pipelined_requests(self):
        self.connect()
        self.stream.</B></FONT>write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
        self.read_response()
        self.read_response()
        self.close()

    def test_pipelined_cancel(self):
        self.connect()
        self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
        # only read once
        self.read_response()
        self.close()

    def test_cancel_during_download(self):
        self.connect()
        self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
        self.read_headers()
        self.stream.read_bytes(1024, self.stop)
        self.wait()
        self.close()

    def test_finish_while_closed(self):
        self.connect()
        self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
        self.read_headers()
        self.close()

    def test_keepalive_chunked(self):
        self.http_version = b'HTTP/1.0'
        self.connect()
        self.stream.write(b'POST / HTTP/1.0\r\n'
                          b'Connection: keep-alive\r\n'
                          b'Transfer-Encoding: chunked\r\n'
                          b'\r\n'
                          b'0\r\n'
                          b'\r\n')
        self.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
        self.read_response()
        self.assertEqual(self.headers['Connection'], 'Keep-Alive')
        self.close()


class GzipBaseTest(object):
    def get_app(self):
        return Application([('/', EchoHandler)])

    def post_gzip(self, body):
        bytesio = BytesIO()
        gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
        gzip_file.write(utf8(body))
        gzip_file.close()
        compressed_body = bytesio.getvalue()
        return self.fetch('/', method='POST', body=compressed_body,
                          headers={'Content-Encoding': 'gzip'})

    def test_uncompressed(self):
        response = self.fetch('/', method='POST', body='foo=bar')
        self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})


class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
    def get_httpserver_options(self):
        return dict(decompress_request=True)

    def test_gzip(self):
        response = self.post_gzip('foo=bar')
        self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})


class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
    def test_gzip_unsupported(self):
        # Gzip support is opt-in; without it the server fails to parse
        # the body (but parsing form bodies is currently just a log message,
        # not a fatal error).
        with ExpectLog(gen_log, &quot;Unsupported Content-Encoding&quot;):
            response = self.post_gzip('foo=bar')
        self.assertEquals(json_decode(response.body), {})


class StreamingChunkSizeTest(AsyncHTTPTestCase):
    # 50 characters long, and repetitive so it can be compressed.
    BODY = b'01234567890123456789012345678901234567890123456789'
    CHUNK_SIZE = 16

    def get_http_client(self):
        # body_producer doesn't work on curl_httpclient, so override the
        # configured AsyncHTTPClient implementation.
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)

    def get_httpserver_options(self):
        return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)

    class MessageDelegate(HTTPMessageDelegate):
        def __init__(self, connection):
            self.connection = connection

        def headers_received(self, start_line, headers):
            self.chunk_lengths = []

        def data_received(self, chunk):
            self.chunk_lengths.append(len(chunk))

        def finish(self):
            response_body = utf8(json_encode(self.chunk_lengths))
            self.connection.write_headers(
                ResponseStartLine('HTTP/1.1', 200, 'OK'),
                HTTPHeaders({'Content-Length': str(len(response_body))}))
            self.connection.write(response_body)
            self.connection.finish()

    def get_app(self):
        class App(HTTPServerConnectionDelegate):
            def start_request(self, server_conn, request_conn):
                return StreamingChunkSizeTest.MessageDelegate(request_conn)
        return App()

    def fetch_chunk_sizes(self, **kwargs):
        response = self.fetch('/', method='POST', **kwargs)
        response.rethrow()
        chunks = json_decode(response.body)
        self.assertEqual(len(self.BODY), sum(chunks))
        for chunk_size in chunks:
            self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
                                 'oversized chunk: ' + str(chunks))
            self.assertGreater(chunk_size, 0,
                               'empty chunk: ' + str(chunks))
        return chunks

    def compress(self, body):
        bytesio = BytesIO()
        gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
        gzfile.write(body)
        gzfile.close()
        compressed = bytesio.getvalue()
        if len(compressed) &gt;= len(body):
            raise Exception(&quot;body did not shrink when compressed&quot;)
        return compressed

    def test_regular_body(self):
        chunks = self.fetch_chunk_sizes(body=self.BODY)
        # Without compression we know exactly what to expect.
        self.assertEqual([16, 16, 16, 2], chunks)

    def test_compressed_body(self):
        self.fetch_chunk_sizes(body=self.compress(self.BODY),
                               headers={'Content-Encoding': 'gzip'})
        # Compression creates irregular boundaries so the assertions
        # in fetch_chunk_sizes are as specific as we can get.

    def test_chunked_body(self):
        def body_producer(write):
            write(self.BODY[:20])
            write(self.BODY[20:])
        chunks = self.fetch_chunk_sizes(body_producer=body_producer)
        # HTTP chunk boundaries translate to application-visible breaks
        self.assertEqual([16, 4, 16, 14], chunks)

    def test_chunked_compressed(self):
        compressed = self.compress(self.BODY)
        self.assertGreater(len(compressed), 20)

        def body_producer(write):
            write(compressed[:20])
            write(compressed[20:])
        self.fetch_chunk_sizes(body_producer=body_producer,
                               headers={'Content-Encoding': 'gzip'})


class MaxHeaderSizeTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application([('/', HelloWorldRequestHandler)])

    def get_httpserver_options(self):
        return dict(max_header_size=1024)

    def test_small_headers(self):
        response = self.fetch(&quot;/&quot;, headers={'X-Filler': 'a' * 100})
        response.rethrow()
        self.assertEqual(response.body, b&quot;Hello world&quot;)

    def test_large_headers(self):
        with ExpectLog(gen_log, &quot;Unsatisfiable read&quot;, required=False):
            response = self.fetch(&quot;/&quot;, headers={'X-Filler': 'a' * 1000})
        # 431 is &quot;Request Header Fields Too Large&quot;, defined in RFC
        # 6585. However, many implementations just close the
        # connection in this case, resulting in a 599.
        self.assertIn(response.code, (431, 599))


@skipOnTravis
class IdleTimeoutTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application([('/', HelloWorldRequestHandler)])

    def get_httpserver_options(self):
        return dict(idle_connection_timeout=0.1)

    def setUp(self):
        super(IdleTimeoutTest, self).setUp()
        self.streams = []

    def tearDown(self):
        super(IdleTimeoutTest, self).tearDown()
        for stream in self.streams:
            stream.close()

    def connect(self):
        stream = IOStream(socket.socket())
        stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
        self.wait()
        self.streams.append(stream)
        return stream

    def test_unused_connection(self):
        stream = self.connect()
        stream.set_close_callback(self.stop)
        self.wait()

    def test_idle_after_use(self):
        stream = self.connect()
        stream.set_close_callback(lambda: self.stop(&quot;closed&quot;))

        # Use the connection twice to make sure keep-alives are working
        for i in range(2):
            stream.write(b&quot;GET / HTTP/1.1\r\n\r\n&quot;)
            stream.read_until(b&quot;\r\n\r\n&quot;, self.stop)
            self.wait()
            stream.read_bytes(11, self.stop)
            data = self.wait()
            self.assertEqual(data, b&quot;Hello world&quot;)

        # Now let the timeout trigger and close the connection.
        data = self.wait()
        self.assertEqual(data, &quot;closed&quot;)


class BodyLimitsTest(AsyncHTTPTestCase):
    def get_app(self):
        class BufferedHandler(RequestHandler):
            def put(self):
                self.write(str(len(self.request.body)))

        @stream_request_body
        class StreamingHandler(RequestHandler):
            def initialize(self):
                self.bytes_read = 0

            def prepare(self):
                if 'expected_size' in self.request.arguments:
                    self.request.connection.set_max_body_size(
                        int(self.get_argument('expected_size')))
                if 'body_timeout' in self.request.arguments:
                    self.request.connection.set_body_timeout(
                        float(self.get_argument('body_timeout')))

            def data_received(self, data):
                self.bytes_read += len(data)

            def put(self):
                self.write(str(self.bytes_read))

        return Application([('/buffered', BufferedHandler),
                            ('/streaming', StreamingHandler)])

    def get_httpserver_options(self):
        return dict(body_timeout=3600, max_body_size=4096)

    def get_http_client(self):
        # body_producer doesn't work on curl_httpclient, so override the
        # configured AsyncHTTPClient implementation.
        return SimpleAsyncHTTPClient(io_loop=self.io_loop)

    def test_small_body(self):
        response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
        self.assertEqual(response.body, b'4096')
        response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
        self.assertEqual(response.body, b'4096')

    def test_large_body_buffered(self):
        with ExpectLog(gen_log, '.*Content-Length too long'):
            response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
        self.assertEqual(response.code, 599)

    def test_large_body_buffered_chunked(self):
        with ExpectLog(gen_log, '.*chunked body too large'):
            response = self.fetch('/buffered', method='PUT',
                                  body_producer=lambda write: write(b'a' * 10240))
        self.assertEqual(response.code, 599)

    def test_large_body_streaming(self):
        with ExpectLog(gen_log, '.*Content-Length too long'):
            response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
        self.assertEqual(response.code, 599)

    def test_large_body_streaming_chunked(self):
        with ExpectLog(gen_log, '.*chunked body too large'):
            response = self.fetch('/streaming', method='PUT',
                                  body_producer=lambda write: write(b'a' * 10240))
        self.assertEqual(response.code, 599)

    def test_large_body_streaming_override(self):
        response = self.fetch('/streaming?expected_size=10240', method='PUT',
                              body=b'a' * 10240)
        self.assertEqual(response.body, b'10240')

    def test_large_body_streaming_chunked_override(self):
        response = self.fetch('/streaming?expected_size=10240', method='PUT',
                              body_producer=lambda write: write(b'a' * 10240))
        self.assertEqual(response.body, b'10240')

    @gen_test
    def test_timeout(self):
        stream = IOStream(socket.socket())
        try:
            yield stream.connect(('127.0.0.1', self.get_http_port()))
            # Use a raw stream because AsyncHTTPClient won't let us read a
            # response without finishing a body.
            stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
                         b'Content-Length: 42\r\n\r\n')
            with ExpectLog(gen_log, 'Timeout reading body'):
                response = yield stream.read_until_close()
            self.assertEqual(response, b'')
        finally:
            stream.close()

    @gen_test
    def test_body_size_override_reset(self):
        # The max_body_size override is reset between requests.
        stream = IOStream(socket.socket())
        try:
            yield stream.connect(('127.0.0.1', self.get_http_port()))
            # Use a raw stream so we can make sure it's all on one connection.
            stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
                         b'Content-Length: 10240\r\n\r\n')
            stream.write(b'a' * 10240)
            headers, response = yield gen.Task(read_stream_body, stream)
            self.assertEqual(response, b'10240')
            # Without the ?expected_size parameter, we get the old default value
            stream.write(b'PUT /streaming HTTP/1.1\r\n'
                         b'Content-Length: 10240\r\n\r\n')
            with ExpectLog(gen_log, '.*Content-Length too long'):
                data = yield stream.read_until_close()
            self.assertEqual(data, b'')
        finally:
            stream.close()


class LegacyInterfaceTest(AsyncHTTPTestCase):
    def get_app(self):
        # The old request_callback interface does not implement the
        # delegate interface, and writes its response via request.write
        # instead of request.connection.write_headers.
        def handle_request(request):
            self.http1 = request.version.startswith(&quot;HTTP/1.&quot;)
            if not self.http1:
                # This test will be skipped if we're using HTTP/2,
                # so just close it out cleanly using the modern interface.
                request.connection.write_headers(
                    ResponseStartLine('', 200, 'OK'),
                    HTTPHeaders())
                request.connection.finish()
                return
            message = b&quot;Hello world&quot;
            request.write(utf8(&quot;HTTP/1.1 200 OK\r\n&quot;
                               &quot;Content-Length: %d\r\n\r\n&quot; % len(message)))
            request.write(message)
            request.finish()
        return handle_request

    def test_legacy_interface(self):
        response = self.fetch('/')
        if not self.http1:
            self.skipTest(&quot;requires HTTP/1.x&quot;)
        self.assertEqual(response.body, b&quot;Hello world&quot;)
</PRE>
</div>
  </div>
</body>
</html>
