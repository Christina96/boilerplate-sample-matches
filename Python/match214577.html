<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for chroot.py &amp; test_boto_lambda_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for chroot.py &amp; test_boto_lambda_1.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>chroot.py (2.7777777%)<th>test_boto_lambda_1.py (1.0230179%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>chroot.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import logging
3 import os
4 import sys
5 import tempfile
6 import salt
7 import salt.client.ssh.state
8 import salt.client.ssh.wrapper.state
9 import salt.defaults.exitcodes
10 import salt.exceptions
11 import salt.utils.args
12 import</b></font> salt.utils.files
13 __func_alias__ = {"apply_": "apply"}
14 log = logging.getLogger(__name__)
15 def __virtual__():
16     if __utils__["path.which"]("chroot") is not None:
17         return True
18     else:
19         return (False, "Module chroot requires the command chroot")
20 def exist(root):
21     dev = os.path.join(root, "dev")
22     proc = os.path.join(root, "proc")
23     sys = os.path.join(root, "sys")
24     return all(os.path.isdir(i) for i in (root, dev, proc, sys))
25 def create(root):
26     if not exist(root):
27         dev = os.path.join(root, "dev")
28         proc = os.path.join(root, "proc")
29         sys = os.path.join(root, "sys")
30         try:
31             os.makedirs(dev, mode=0o755)
32             os.makedirs(proc, mode=0o555)
33             os.makedirs(sys, mode=0o555)
34         except OSError as e:
35             log.error("Error when trying to create chroot directories: %s", e)
36             return False
37     return True
38 def in_chroot():
39     result = False
40     try:
41         with salt.utils.files.fopen(
42             "/proc/1/mountinfo"
43         ) as root_fd, salt.utils.files.fopen("/proc/self/mountinfo") as self_fd:
44             root_mountinfo = root_fd.read()
45             self_mountinfo = self_fd.read()
46         result = root_mountinfo != self_mountinfo
47     except OSError:
48         pass
49     return result
50 def call(root, function, *args, **kwargs):
51     if not function:
52         raise salt.exceptions.CommandExecutionError("Missing function parameter")
53     if not exist(root):
54         raise salt.exceptions.CommandExecutionError("Chroot environment not found")
55     thin_dest_path = tempfile.mkdtemp(dir=root)
56     thin_path = __utils__["thin.gen_thin"](
57         __opts__["cachedir"],
58         extra_mods=__salt__["config.option"]("thin_extra_mods", ""),
59         so_mods=__salt__["config.option"]("thin_so_mods", ""),
60     )
61     stdout = __salt__["cmd.run"](["tar", "xzf", thin_path, "-C", thin_dest_path])
62     if stdout:
63         __utils__["files.rm_rf"](thin_dest_path)
64         return {"result": False, "comment": stdout}
65     chroot_path = os.path.join(os.path.sep, os.path.relpath(thin_dest_path, root))
66     try:
67         safe_kwargs = salt.utils.args.clean_kwargs(**kwargs)
68         salt_argv = (
69             [
70                 "python{}".format(sys.version_info[0]),
71                 os.path.join(chroot_path, "salt-call"),
72                 "--metadata",
73                 "--local",
74                 "--log-file",
75                 os.path.join(chroot_path, "log"),
76                 "--cachedir",
77                 os.path.join(chroot_path, "cache"),
78                 "--out",
79                 "json",
80                 "-l",
81                 "quiet",
82                 "--",
83                 function,
84             ]
85             + list(args)
86             + ["{}={}".format(k, v) for (k, v) in safe_kwargs.items()]
87         )
88         ret = __salt__["cmd.run_chroot"](root, [str(x) for x in salt_argv])
89         try:
90             data = __utils__["json.find_json"](ret["stdout"])
91             local = data.get("local", data)
92             if isinstance(local, dict) and "retcode" in local:
93                 __context__["retcode"] = local["retcode"]
94             return local.get("return", data)
95         except ValueError:
96             return {
97                 "result": False,
98                 "retcode": ret["retcode"],
99                 "comment": {"stdout": ret["stdout"], "stderr": ret["stderr"]},
100             }
101     finally:
102         __utils__["files.rm_rf"](thin_dest_path)
103 def apply_(root, mods=None, **kwargs):
104     if mods:
105         return sls(root, mods, **kwargs)
106     return highstate(root, **kwargs)
107 def _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type):
108     salt.client.ssh.wrapper.state._cleanup_slsmod_low_data(chunks)
109     trans_tar = salt.client.ssh.state.prep_trans_tar(
110         salt.fileclient.get_file_client(__opts__),
111         chunks,
112         file_refs,
113         __pillar__.value(),
114         root,
115     )
116     trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, hash_type)
117     ret = None
118     salt_state_path = tempfile.mkdtemp(dir=root)
119     salt_state_path = os.path.join(salt_state_path, "salt_state.tgz")
120     salt_state_path_in_chroot = salt_state_path.replace(root, "", 1)
121     try:
122         salt.utils.files.copyfile(trans_tar, salt_state_path)
123         ret = call(
124             root,
125             "state.pkg",
126             salt_state_path_in_chroot,
127             test=test,
128             pkg_sum=trans_tar_sum,
129             hash_type=hash_type,
130         )
131     finally:
132         __utils__["files.rm_rf"](salt_state_path)
133     return ret
134 def sls(root, mods, saltenv="base", test=None, exclude=None, **kwargs):
135     pillar = copy.deepcopy(__pillar__.value())
136     pillar.update(kwargs.get("pillar", {}))
137     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
138     st_ = salt.client.ssh.state.SSHHighState(
139         opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
140     )
141     if isinstance(mods, str):
142         mods = mods.split(",")
143     high_data, errors = st_.render_highstate({saltenv: mods})
144     if exclude:
145         if isinstance(exclude, str):
146             exclude = exclude.split(",")
147         if "__exclude__" in high_data:
148             high_data["__exclude__"].extend(exclude)
149         else:
150             high_data["__exclude__"] = exclude
151     high_data, ext_errors = st_.state.reconcile_extend(high_data)
152     errors += ext_errors
153     errors += st_.state.verify_high(high_data)
154     if errors:
155         return errors
156     high_data, req_in_errors = st_.state.requisite_in(high_data)
157     errors += req_in_errors
158     if errors:
159         return errors
160     high_data = st_.state.apply_exclude(high_data)
161     chunks = st_.state.compile_high_data(high_data)
162     file_refs = salt.client.ssh.state.lowstate_file_refs(
163         chunks,
164         salt.client.ssh.wrapper.state._merge_extra_filerefs(
165             kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
166         ),
167     )
168     hash_type = opts["hash_type"]
169     return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
170 def highstate(root, **kwargs):
171     pillar = copy.deepcopy(__pillar__.value())
172     pillar.update(kwargs.get("pillar", {}))
173     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
174     with salt.client.ssh.state.SSHHighState(
175         opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
176     ) as st_:
177         chunks = st_.compile_low_chunks()
178         file_refs = salt.client.ssh.state.lowstate_file_refs(
179             chunks,
180             salt.client.ssh.wrapper.state._merge_extra_filerefs(
181                 kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
182             ),
183         )
184         for chunk in chunks:
185             if not isinstance(chunk, dict):
186                 __context__["retcode"] = 1
187                 return chunks
188         test = kwargs.pop("test", False)
189         hash_type = opts["hash_type"]
190         return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_lambda_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import os
3 import random
4 import string
5 from tempfile import NamedTemporaryFile
6 import salt.config
7 import salt.loader
8 import salt.modules.boto_lambda as boto_lambda
9 import salt.utils.stringutils
10 from salt.exceptions import SaltInvocationError
11 from salt.utils.versions import LooseVersion
12 from</b></font> tests.support.mixins import LoaderModuleMockMixin
13 from tests.support.mock import MagicMock, patch
14 from tests.support.unit import TestCase, skipIf
15 try:
16     import boto3
17     from botocore.exceptions import ClientError
18     from botocore import __version__ as found_botocore_version
19     HAS_BOTO = True
20 except ImportError:
21     HAS_BOTO = False
22 required_boto3_version = "1.2.1"
23 required_botocore_version = "1.5.2"
24 region = "us-east-1"
25 access_key = "GKTADJGHEIQSXMKKRBJ08H"
26 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
27 conn_parameters = {
28     "region": region,
29     "key": access_key,
30     "keyid": secret_key,
31     "profile": {},
32 }
33 error_message = (
34     "An error occurred (101) when calling the {0} operation: Test-defined error"
35 )
36 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
37 function_ret = dict(
38     FunctionName="testfunction",
39     Runtime="python2.7",
40     Role=None,
41     Handler="handler",
42     Description="abcdefg",
43     Timeout=5,
44     MemorySize=128,
45     CodeSha256="abcdef",
46     CodeSize=199,
47     FunctionArn="arn:lambda:us-east-1:1234:Something",
48     LastModified="yes",
49     VpcConfig=None,
50     Environment=None,
51 )
52 alias_ret = dict(
53     AliasArn="arn:lambda:us-east-1:1234:Something",
54     Name="testalias",
55     FunctionVersion="3",
56     Description="Alias description",
57 )
58 event_source_mapping_ret = dict(
59     UUID="1234-1-123",
60     BatchSize=123,
61     EventSourceArn="arn:lambda:us-east-1:1234:Something",
62     FunctionArn="arn:lambda:us-east-1:1234:Something",
63     LastModified="yes",
64     LastProcessingResult="SUCCESS",
65     State="Enabled",
66     StateTransitionReason="Random",
67 )
68 log = logging.getLogger(__name__)
69 def _has_required_boto():
70     if not HAS_BOTO:
71         return False
72     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
73         return False
74     elif LooseVersion(found_botocore_version) &lt; LooseVersion(required_botocore_version):
75         return False
76     else:
77         return True
78 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
79 @skipIf(
80     _has_required_boto() is False,
81     "The boto3 module must be greater than or equal to version {}, "
82     "and botocore must be greater than or equal to {}".format(
83         required_boto3_version, required_botocore_version
84     ),
85 )
86 class BotoLambdaTestCaseBase(TestCase, LoaderModuleMockMixin):
87     conn = None
88     def setup_loader_modules(self):
89         self.opts = opts = salt.config.DEFAULT_MINION_OPTS.copy()
90         utils = salt.loader.utils(
91             opts, whitelist=["boto3", "args", "systemd", "path", "platform"], context={}
92         )
93         return {boto_lambda: {"__utils__": utils}}
94     def setUp(self):
95         super().setUp()
96         boto_lambda.__init__(self.opts)
97         del self.opts
98         conn_parameters["key"] = "".join(
99             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
100         )
101         self.patcher = patch("boto3.session.Session")
102         self.addCleanup(self.patcher.stop)
103         self.addCleanup(delattr, self, "patcher")
104         mock_session = self.patcher.start()
105         session_instance = mock_session.return_value
106         self.conn = MagicMock()
107         session_instance.client.return_value = self.conn
108         self.addCleanup(delattr, self, "conn")
109 class TempZipFile:
110     def __enter__(self):
111         with NamedTemporaryFile(
112             suffix=".zip", prefix="salt_test_", delete=False
113         ) as tmp:
114             to_write = "###\n"
115             to_write = salt.utils.stringutils.to_bytes(to_write)
116             tmp.write(to_write)
117             self.zipfile = tmp.name
118         return self.zipfile
119     def __exit__(self, type, value, traceback):
120         os.remove(self.zipfile)
121 class BotoLambdaTestCaseMixin:
122     pass
123 class BotoLambdaFunctionTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
124     def test_that_when_checking_if_a_function_exists_and_a_function_exists_the_function_exists_method_returns_true(
125         self,
126     ):
127         self.conn.list_functions.return_value = {"Functions": [function_ret]}
128         func_exists_result = boto_lambda.function_exists(
129             FunctionName=function_ret["FunctionName"], **conn_parameters
130         )
131         self.assertTrue(func_exists_result["exists"])
132     def test_that_when_checking_if_a_function_exists_and_a_function_does_not_exist_the_function_exists_method_returns_false(
133         self,
134     ):
135         self.conn.list_functions.return_value = {"Functions": [function_ret]}
136         func_exists_result = boto_lambda.function_exists(
137             FunctionName="myfunc", **conn_parameters
138         )
139         self.assertFalse(func_exists_result["exists"])
140     def test_that_when_checking_if_a_function_exists_and_boto3_returns_an_error_the_function_exists_method_returns_error(
141         self,
142     ):
143         self.conn.list_functions.side_effect = ClientError(
144             error_content, "list_functions"
145         )
146         func_exists_result = boto_lambda.function_exists(
147             FunctionName="myfunc", **conn_parameters
148         )
149         self.assertEqual(
150             func_exists_result.get("error", {}).get("message"),
151             error_message.format("list_functions"),
152         )
153     def test_that_when_creating_a_function_from_zipfile_succeeds_the_create_function_method_returns_true(
154         self,
155     ):
156         with patch.dict(
157             boto_lambda.__salt__,
158             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
159         ):
160             with TempZipFile() as zipfile:
161                 self.conn.create_function.return_value = function_ret
162                 lambda_creation_result = boto_lambda.create_function(
163                     FunctionName="testfunction",
164                     Runtime="python2.7",
165                     Role="myrole",
166                     Handler="file.method",
167                     ZipFile=zipfile,
168                     **conn_parameters
169                 )
170         self.assertTrue(lambda_creation_result["created"])
171     def test_that_when_creating_a_function_from_s3_succeeds_the_create_function_method_returns_true(
172         self,
173     ):
174         with patch.dict(
175             boto_lambda.__salt__,
176             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
177         ):
178             self.conn.create_function.return_value = function_ret
179             lambda_creation_result = boto_lambda.create_function(
180                 FunctionName="testfunction",
181                 Runtime="python2.7",
182                 Role="myrole",
183                 Handler="file.method",
184                 S3Bucket="bucket",
185                 S3Key="key",
186                 **conn_parameters
187             )
188         self.assertTrue(lambda_creation_result["created"])
189     def test_that_when_creating_a_function_without_code_raises_a_salt_invocation_error(
190         self,
191     ):
192         with patch.dict(
193             boto_lambda.__salt__,
194             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
195         ):
196             with self.assertRaisesRegex(
197                 SaltInvocationError,
198                 "Either ZipFile must be specified, or S3Bucket and S3Key must be"
199                 " provided.",
200             ):
201                 lambda_creation_result = boto_lambda.create_function(
202                     FunctionName="testfunction",
203                     Runtime="python2.7",
204                     Role="myrole",
205                     Handler="file.method",
206                     **conn_parameters
207                 )
208     def test_that_when_creating_a_function_with_zipfile_and_s3_raises_a_salt_invocation_error(
209         self,
210     ):
211         with patch.dict(
212             boto_lambda.__salt__,
213             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
214         ):
215             with self.assertRaisesRegex(
216                 SaltInvocationError,
217                 "Either ZipFile must be specified, or S3Bucket and S3Key must be"
218                 " provided.",
219             ):
220                 with TempZipFile() as zipfile:
221                     lambda_creation_result = boto_lambda.create_function(
222                         FunctionName="testfunction",
223                         Runtime="python2.7",
224                         Role="myrole",
225                         Handler="file.method",
226                         ZipFile=zipfile,
227                         S3Bucket="bucket",
228                         S3Key="key",
229                         **conn_parameters
230                     )
231     def test_that_when_creating_a_function_fails_the_create_function_method_returns_error(
232         self,
233     ):
234         with patch.dict(
235             boto_lambda.__salt__,
236             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
237         ):
238             self.conn.create_function.side_effect = ClientError(
239                 error_content, "create_function"
240             )
241             with TempZipFile() as zipfile:
242                 lambda_creation_result = boto_lambda.create_function(
243                     FunctionName="testfunction",
244                     Runtime="python2.7",
245                     Role="myrole",
246                     Handler="file.method",
247                     ZipFile=zipfile,
248                     **conn_parameters
249                 )
250         self.assertEqual(
251             lambda_creation_result.get("error", {}).get("message"),
252             error_message.format("create_function"),
253         )
254     def test_that_when_deleting_a_function_succeeds_the_delete_function_method_returns_true(
255         self,
256     ):
257         with patch.dict(
258             boto_lambda.__salt__,
259             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
260         ):
261             result = boto_lambda.delete_function(
262                 FunctionName="testfunction", Qualifier=1, **conn_parameters
263             )
264         self.assertTrue(result["deleted"])
265     def test_that_when_deleting_a_function_fails_the_delete_function_method_returns_false(
266         self,
267     ):
268         with patch.dict(
269             boto_lambda.__salt__,
270             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
271         ):
272             self.conn.delete_function.side_effect = ClientError(
273                 error_content, "delete_function"
274             )
275             result = boto_lambda.delete_function(
276                 FunctionName="testfunction", **conn_parameters
277             )
278         self.assertFalse(result["deleted"])
279     def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_true(
280         self,
281     ):
282         self.conn.list_functions.return_value = {"Functions": [function_ret]}
283         with patch.dict(
284             boto_lambda.__salt__,
285             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
286         ):
287             result = boto_lambda.describe_function(
288                 FunctionName=function_ret["FunctionName"], **conn_parameters
289             )
290         self.assertEqual(result, {"function": function_ret})
291     def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_false(
292         self,
293     ):
294         self.conn.list_functions.return_value = {"Functions": []}
295         with patch.dict(
296             boto_lambda.__salt__,
297             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
298         ):
299             result = boto_lambda.describe_function(
300                 FunctionName="testfunction", **conn_parameters
301             )
302         self.assertFalse(result["function"])
303     def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
304         self.conn.list_functions.side_effect = ClientError(
305             error_content, "list_functions"
306         )
307         result = boto_lambda.describe_function(
308             FunctionName="testfunction", **conn_parameters
309         )
310         self.assertTrue("error" in result)
311     def test_that_when_updating_a_function_succeeds_the_update_function_method_returns_true(
312         self,
313     ):
314         with patch.dict(
315             boto_lambda.__salt__,
316             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
317         ):
318             self.conn.update_function_config.return_value = function_ret
319             result = boto_lambda.update_function_config(
320                 FunctionName=function_ret["FunctionName"],
321                 Role="myrole",
322                 **conn_parameters
323             )
324         self.assertTrue(result["updated"])
325     def test_that_when_updating_a_function_fails_the_update_function_method_returns_error(
326         self,
327     ):
328         with patch.dict(
329             boto_lambda.__salt__,
330             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
331         ):
332             self.conn.update_function_configuration.side_effect = ClientError(
333                 error_content, "update_function"
334             )
335             result = boto_lambda.update_function_config(
336                 FunctionName="testfunction", Role="myrole", **conn_parameters
337             )
338         self.assertEqual(
339             result.get("error", {}).get("message"),
340             error_message.format("update_function"),
341         )
342     def test_that_when_updating_function_code_from_zipfile_succeeds_the_update_function_method_returns_true(
343         self,
344     ):
345         with patch.dict(
346             boto_lambda.__salt__,
347             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
348         ):
349             with TempZipFile() as zipfile:
350                 self.conn.update_function_code.return_value = function_ret
351                 result = boto_lambda.update_function_code(
352                     FunctionName=function_ret["FunctionName"],
353                     ZipFile=zipfile,
354                     **conn_parameters
355                 )
356         self.assertTrue(result["updated"])
357     def test_that_when_updating_function_code_from_s3_succeeds_the_update_function_method_returns_true(
358         self,
359     ):
360         with patch.dict(
361             boto_lambda.__salt__,
362             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
363         ):
364             self.conn.update_function_code.return_value = function_ret
365             result = boto_lambda.update_function_code(
366                 FunctionName="testfunction",
367                 S3Bucket="bucket",
368                 S3Key="key",
369                 **conn_parameters
370             )
371         self.assertTrue(result["updated"])
372     def test_that_when_updating_function_code_without_code_raises_a_salt_invocation_error(
373         self,
374     ):
375         with patch.dict(
376             boto_lambda.__salt__,
377             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
378         ):
379             with self.assertRaisesRegex(
380                 SaltInvocationError,
381                 "Either ZipFile must be specified, or S3Bucket "
382                 "and S3Key must be provided.",
383             ):
384                 result = boto_lambda.update_function_code(
385                     FunctionName="testfunction", **conn_parameters
386                 )
387     def test_that_when_updating_function_code_fails_the_update_function_method_returns_error(
388         self,
389     ):
390         with patch.dict(
391             boto_lambda.__salt__,
392             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
393         ):
394             self.conn.update_function_code.side_effect = ClientError(
395                 error_content, "update_function_code"
396             )
397             result = boto_lambda.update_function_code(
398                 FunctionName="testfunction",
399                 S3Bucket="bucket",
400                 S3Key="key",
401                 **conn_parameters
402             )
403         self.assertEqual(
404             result.get("error", {}).get("message"),
405             error_message.format("update_function_code"),
406         )
407     def test_that_when_listing_function_versions_succeeds_the_list_function_versions_method_returns_true(
408         self,
409     ):
410         with patch.dict(
411             boto_lambda.__salt__,
412             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
413         ):
414             self.conn.list_versions_by_function.return_value = {
415                 "Versions": [function_ret]
416             }
417             result = boto_lambda.list_function_versions(
418                 FunctionName="testfunction", **conn_parameters
419             )
420         self.assertTrue(result["Versions"])
421     def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_false(
422         self,
423     ):
424         with patch.dict(
425             boto_lambda.__salt__,
426             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
427         ):
428             self.conn.list_versions_by_function.return_value = {"Versions": []}
429             result = boto_lambda.list_function_versions(
430                 FunctionName="testfunction", **conn_parameters
431             )
432         self.assertFalse(result["Versions"])
433     def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_error(
434         self,
435     ):
436         with patch.dict(
437             boto_lambda.__salt__,
438             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
439         ):
440             self.conn.list_versions_by_function.side_effect = ClientError(
441                 error_content, "list_versions_by_function"
442             )
443             result = boto_lambda.list_function_versions(
444                 FunctionName="testfunction", **conn_parameters
445             )
446         self.assertEqual(
447             result.get("error", {}).get("message"),
448             error_message.format("list_versions_by_function"),
449         )
450 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
451 @skipIf(
452     _has_required_boto() is False,
453     "The boto3 module must be greater than or equal to version {}".format(
454         required_boto3_version
455     ),
456 )
457 class BotoLambdaAliasTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
458     def test_that_when_creating_an_alias_succeeds_the_create_alias_method_returns_true(
459         self,
460     ):
461         self.conn.create_alias.return_value = alias_ret
462         result = boto_lambda.create_alias(
463             FunctionName="testfunction",
464             Name=alias_ret["Name"],
465             FunctionVersion=alias_ret["FunctionVersion"],
466             **conn_parameters
467         )
468         self.assertTrue(result["created"])
469     def test_that_when_creating_an_alias_fails_the_create_alias_method_returns_error(
470         self,
471     ):
472         self.conn.create_alias.side_effect = ClientError(error_content, "create_alias")
473         result = boto_lambda.create_alias(
474             FunctionName="testfunction",
475             Name=alias_ret["Name"],
476             FunctionVersion=alias_ret["FunctionVersion"],
477             **conn_parameters
478         )
479         self.assertEqual(
480             result.get("error", {}).get("message"), error_message.format("create_alias")
481         )
482     def test_that_when_deleting_an_alias_succeeds_the_delete_alias_method_returns_true(
483         self,
484     ):
485         result = boto_lambda.delete_alias(
486             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
487         )
488         self.assertTrue(result["deleted"])
489     def test_that_when_deleting_an_alias_fails_the_delete_alias_method_returns_false(
490         self,
491     ):
492         self.conn.delete_alias.side_effect = ClientError(error_content, "delete_alias")
493         result = boto_lambda.delete_alias(
494             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
495         )
496         self.assertFalse(result["deleted"])
497     def test_that_when_checking_if_an_alias_exists_and_the_alias_exists_the_alias_exists_method_returns_true(
498         self,
499     ):
500         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
501         result = boto_lambda.alias_exists(
502             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
503         )
504         self.assertTrue(result["exists"])
505     def test_that_when_checking_if_an_alias_exists_and_the_alias_does_not_exist_the_alias_exists_method_returns_false(
506         self,
507     ):
508         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
509         result = boto_lambda.alias_exists(
510             FunctionName="testfunction", Name="otheralias", **conn_parameters
511         )
512         self.assertFalse(result["exists"])
513     def test_that_when_checking_if_an_alias_exists_and_boto3_returns_an_error_the_alias_exists_method_returns_error(
514         self,
515     ):
516         self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
517         result = boto_lambda.alias_exists(
518             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
519         )
520         self.assertEqual(
521             result.get("error", {}).get("message"), error_message.format("list_aliases")
522         )
523     def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_true(
524         self,
525     ):
526         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
527         result = boto_lambda.describe_alias(
528             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
529         )
530         self.assertEqual(result, {"alias": alias_ret})
531     def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_false(
532         self,
533     ):
534         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
535         result = boto_lambda.describe_alias(
536             FunctionName="testfunction", Name="othername", **conn_parameters
537         )
538         self.assertFalse(result["alias"])
539     def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
540         self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
541         result = boto_lambda.describe_alias(
542             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
543         )
544         self.assertTrue("error" in result)
545     def test_that_when_updating_an_alias_succeeds_the_update_alias_method_returns_true(
546         self,
547     ):
548         self.conn.update_alias.return_value = alias_ret
549         result = boto_lambda.update_alias(
550             FunctionName="testfunctoin",
551             Name=alias_ret["Name"],
552             Description=alias_ret["Description"],
553             **conn_parameters
554         )
555         self.assertTrue(result["updated"])
556     def test_that_when_updating_an_alias_fails_the_update_alias_method_returns_error(
557         self,
558     ):
559         self.conn.update_alias.side_effect = ClientError(error_content, "update_alias")
560         result = boto_lambda.update_alias(
561             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
562         )
563         self.assertEqual(
564             result.get("error", {}).get("message"), error_message.format("update_alias")
565         )
566 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
567 @skipIf(
568     _has_required_boto() is False,
569     "The boto3 module must be greater than or equal to version {}".format(
570         required_boto3_version
571     ),
572 )
573 class BotoLambdaEventSourceMappingTestCase(
574     BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin
575 ):
576     def test_that_when_creating_a_mapping_succeeds_the_create_event_source_mapping_method_returns_true(
577         self,
578     ):
579         self.conn.create_event_source_mapping.return_value = event_source_mapping_ret
580         result = boto_lambda.create_event_source_mapping(
581             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
582             FunctionName=event_source_mapping_ret["FunctionArn"],
583             StartingPosition="LATEST",
584             **conn_parameters
585         )
586         self.assertTrue(result["created"])
587     def test_that_when_creating_an_event_source_mapping_fails_the_create_event_source_mapping_method_returns_error(
588         self,
589     ):
590         self.conn.create_event_source_mapping.side_effect = ClientError(
591             error_content, "create_event_source_mapping"
592         )
593         result = boto_lambda.create_event_source_mapping(
594             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
595             FunctionName=event_source_mapping_ret["FunctionArn"],
596             StartingPosition="LATEST",
597             **conn_parameters
598         )
599         self.assertEqual(
600             result.get("error", {}).get("message"),
601             error_message.format("create_event_source_mapping"),
602         )
603     def test_that_when_listing_mapping_ids_succeeds_the_get_event_source_mapping_ids_method_returns_true(
604         self,
605     ):
606         self.conn.list_event_source_mappings.return_value = {
607             "EventSourceMappings": [event_source_mapping_ret]
608         }
609         result = boto_lambda.get_event_source_mapping_ids(
610             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
611             FunctionName=event_source_mapping_ret["FunctionArn"],
612             **conn_parameters
613         )
614         self.assertTrue(result)
615     def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_versions_method_returns_false(
616         self,
617     ):
618         self.conn.list_event_source_mappings.return_value = {"EventSourceMappings": []}
619         result = boto_lambda.get_event_source_mapping_ids(
620             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
621             FunctionName=event_source_mapping_ret["FunctionArn"],
622             **conn_parameters
623         )
624         self.assertFalse(result)
625     def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_method_returns_error(
626         self,
627     ):
628         self.conn.list_event_source_mappings.side_effect = ClientError(
629             error_content, "list_event_source_mappings"
630         )
631         result = boto_lambda.get_event_source_mapping_ids(
632             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
633             FunctionName=event_source_mapping_ret["FunctionArn"],
634             **conn_parameters
635         )
636         self.assertEqual(
637             result.get("error", {}).get("message"),
638             error_message.format("list_event_source_mappings"),
639         )
640     def test_that_when_deleting_an_event_source_mapping_by_UUID_succeeds_the_delete_event_source_mapping_method_returns_true(
641         self,
642     ):
643         result = boto_lambda.delete_event_source_mapping(
644             UUID=event_source_mapping_ret["UUID"], **conn_parameters
645         )
646         self.assertTrue(result["deleted"])
647     @skipIf(True, "This appears to leak memory and crash the unit test suite")
648     def test_that_when_deleting_an_event_source_mapping_by_name_succeeds_the_delete_event_source_mapping_method_returns_true(
649         self,
650     ):
651         self.conn.list_event_source_mappings.return_value = {
652             "EventSourceMappings": [event_source_mapping_ret]
653         }
654         result = boto_lambda.delete_event_source_mapping(
655             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
656             FunctionName=event_source_mapping_ret["FunctionArn"],
657             **conn_parameters
658         )
659         self.assertTrue(result["deleted"])
660     def test_that_when_deleting_an_event_source_mapping_without_identifier_the_delete_event_source_mapping_method_raises_saltinvocationexception(
661         self,
662     ):
663         with self.assertRaisesRegex(
664             SaltInvocationError,
665             "Either UUID must be specified, or EventSourceArn "
666             "and FunctionName must be provided.",
667         ):
668             result = boto_lambda.delete_event_source_mapping(**conn_parameters)
669     def test_that_when_deleting_an_event_source_mapping_fails_the_delete_event_source_mapping_method_returns_false(
670         self,
671     ):
672         self.conn.delete_event_source_mapping.side_effect = ClientError(
673             error_content, "delete_event_source_mapping"
674         )
675         result = boto_lambda.delete_event_source_mapping(
676             UUID=event_source_mapping_ret["UUID"], **conn_parameters
677         )
678         self.assertFalse(result["deleted"])
679     def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_exists_the_event_source_mapping_exists_method_returns_true(
680         self,
681     ):
682         self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
683         result = boto_lambda.event_source_mapping_exists(
684             UUID=event_source_mapping_ret["UUID"], **conn_parameters
685         )
686         self.assertTrue(result["exists"])
687     def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_does_not_exist_the_event_source_mapping_exists_method_returns_false(
688         self,
689     ):
690         self.conn.get_event_source_mapping.return_value = None
691         result = boto_lambda.event_source_mapping_exists(
692             UUID="other_UUID", **conn_parameters
693         )
694         self.assertFalse(result["exists"])
695     def test_that_when_checking_if_an_event_source_mapping_exists_and_boto3_returns_an_error_the_event_source_mapping_exists_method_returns_error(
696         self,
697     ):
698         self.conn.get_event_source_mapping.side_effect = ClientError(
699             error_content, "list_event_source_mappings"
700         )
701         result = boto_lambda.event_source_mapping_exists(
702             UUID=event_source_mapping_ret["UUID"], **conn_parameters
703         )
704         self.assertEqual(
705             result.get("error", {}).get("message"),
706             error_message.format("list_event_source_mappings"),
707         )
708     def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_true(
709         self,
710     ):
711         self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
712         result = boto_lambda.describe_event_source_mapping(
713             UUID=event_source_mapping_ret["UUID"], **conn_parameters
714         )
715         self.assertEqual(result, {"event_source_mapping": event_source_mapping_ret})
716     def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_false(
717         self,
718     ):
719         self.conn.get_event_source_mapping.return_value = None
720         result = boto_lambda.describe_event_source_mapping(
721             UUID=event_source_mapping_ret["UUID"], **conn_parameters
722         )
723         self.assertFalse(result["event_source_mapping"])
724     def test_that_when_describing_event_source_mapping_on_client_error_it_returns_error(
725         self,
726     ):
727         self.conn.get_event_source_mapping.side_effect = ClientError(
728             error_content, "get_event_source_mapping"
729         )
730         result = boto_lambda.describe_event_source_mapping(
731             UUID=event_source_mapping_ret["UUID"], **conn_parameters
732         )
733         self.assertTrue("error" in result)
734     def test_that_when_updating_an_event_source_mapping_succeeds_the_update_event_source_mapping_method_returns_true(
735         self,
736     ):
737         self.conn.update_event_source_mapping.return_value = event_source_mapping_ret
738         result = boto_lambda.update_event_source_mapping(
739             UUID=event_source_mapping_ret["UUID"],
740             FunctionName=event_source_mapping_ret["FunctionArn"],
741             **conn_parameters
742         )
743         self.assertTrue(result["updated"])
744     def test_that_when_updating_an_event_source_mapping_fails_the_update_event_source_mapping_method_returns_error(
745         self,
746     ):
747         self.conn.update_event_source_mapping.side_effect = ClientError(
748             error_content, "update_event_source_mapping"
749         )
750         result = boto_lambda.update_event_source_mapping(
751             UUID=event_source_mapping_ret["UUID"],
752             FunctionName=event_source_mapping_ret["FunctionArn"],
753             **conn_parameters
754         )
755         self.assertEqual(
756             result.get("error", {}).get("message"),
757             error_message.format("update_event_source_mapping"),
758         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
