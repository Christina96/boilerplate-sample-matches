<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for chroot.py & test_boto_lambda_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for chroot.py & test_boto_lambda_1.py
      </h3>
      <h1 align="center">
        1.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>chroot.py (2.7777777%)<TH>test_boto_lambda_1.py (1.0230179%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match214577-0.html#0',2,'match214577-1.html#0',3)" NAME="0">(8-20)<TD><A HREF="javascript:ZweiFrames('match214577-0.html#0',2,'match214577-1.html#0',3)" NAME="0">(1-13)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>chroot.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
:maintainer:    Alberto Planas &lt;aplanas@suse.com&gt;
:maturity:      new
:depends:       None
<A NAME="0"></A>:platform:      Linux
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match214577-1.html#0',3,'match214577-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import copy
import logging
import os
import sys
import tempfile

import salt
import salt.client.ssh.state
import salt.client.ssh.wrapper.state
import salt.defaults.exitcodes
import salt.exceptions
import salt.utils.args
import</B></FONT> salt.utils.files

__func_alias__ = {&quot;apply_&quot;: &quot;apply&quot;}

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Chroot command is required.
    &quot;&quot;&quot;
    if __utils__[&quot;path.which&quot;](&quot;chroot&quot;) is not None:
        return True
    else:
        return (False, &quot;Module chroot requires the command chroot&quot;)


def exist(root):
    &quot;&quot;&quot;
    Return True if the chroot environment is present.

    root
        Path to the chroot environment

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.exist /chroot

    &quot;&quot;&quot;
    dev = os.path.join(root, &quot;dev&quot;)
    proc = os.path.join(root, &quot;proc&quot;)
    sys = os.path.join(root, &quot;sys&quot;)
    return all(os.path.isdir(i) for i in (root, dev, proc, sys))


def create(root):
    &quot;&quot;&quot;
    Create a basic chroot environment.

    Note that this environment is not functional. The caller needs to
    install the minimal required binaries, including Python if
    chroot.call is called.

    root
        Path to the chroot environment

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.create /chroot

    &quot;&quot;&quot;
    if not exist(root):
        dev = os.path.join(root, &quot;dev&quot;)
        proc = os.path.join(root, &quot;proc&quot;)
        sys = os.path.join(root, &quot;sys&quot;)
        try:
            os.makedirs(dev, mode=0o755)
            os.makedirs(proc, mode=0o555)
            os.makedirs(sys, mode=0o555)
        except OSError as e:
            log.error(&quot;Error when trying to create chroot directories: %s&quot;, e)
            return False
    return True


def in_chroot():
    &quot;&quot;&quot;
    Return True if the process is inside a chroot jail

    .. versionadded:: 3004

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.in_chroot

    &quot;&quot;&quot;
    result = False

    try:
        # We cannot assume that we are &quot;root&quot;, so we cannot read
        # '/proc/1/root', that is required for the usual way of
        # detecting that we are in a chroot jail.  We use the debian
        # ischroot method.
        with salt.utils.files.fopen(
            &quot;/proc/1/mountinfo&quot;
        ) as root_fd, salt.utils.files.fopen(&quot;/proc/self/mountinfo&quot;) as self_fd:
            root_mountinfo = root_fd.read()
            self_mountinfo = self_fd.read()
        result = root_mountinfo != self_mountinfo
    except OSError:
        pass

    return result


def call(root, function, *args, **kwargs):
    &quot;&quot;&quot;
    Executes a Salt function inside a chroot environment.

    The chroot does not need to have Salt installed, but Python is
    required.

    root
        Path to the chroot environment

    function
        Salt execution module function

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.call /chroot test.ping
        salt myminion chroot.call /chroot ssh.set_auth_key user key=mykey

    &quot;&quot;&quot;

    if not function:
        raise salt.exceptions.CommandExecutionError(&quot;Missing function parameter&quot;)

    if not exist(root):
        raise salt.exceptions.CommandExecutionError(&quot;Chroot environment not found&quot;)

    # Create a temporary directory inside the chroot where we can
    # untar salt-thin
    thin_dest_path = tempfile.mkdtemp(dir=root)
    thin_path = __utils__[&quot;thin.gen_thin&quot;](
        __opts__[&quot;cachedir&quot;],
        extra_mods=__salt__[&quot;config.option&quot;](&quot;thin_extra_mods&quot;, &quot;&quot;),
        so_mods=__salt__[&quot;config.option&quot;](&quot;thin_so_mods&quot;, &quot;&quot;),
    )
    # Some bug in Salt is preventing us to use `archive.tar` here. A
    # AsyncZeroMQReqChannel is not closed at the end of the salt-call,
    # and makes the client never exit.
    #
    # stdout = __salt__['archive.tar']('xzf', thin_path, dest=thin_dest_path)
    #
    stdout = __salt__[&quot;cmd.run&quot;]([&quot;tar&quot;, &quot;xzf&quot;, thin_path, &quot;-C&quot;, thin_dest_path])
    if stdout:
        __utils__[&quot;files.rm_rf&quot;](thin_dest_path)
        return {&quot;result&quot;: False, &quot;comment&quot;: stdout}

    chroot_path = os.path.join(os.path.sep, os.path.relpath(thin_dest_path, root))
    try:
        safe_kwargs = salt.utils.args.clean_kwargs(**kwargs)
        salt_argv = (
            [
                &quot;python{}&quot;.format(sys.version_info[0]),
                os.path.join(chroot_path, &quot;salt-call&quot;),
                &quot;--metadata&quot;,
                &quot;--local&quot;,
                &quot;--log-file&quot;,
                os.path.join(chroot_path, &quot;log&quot;),
                &quot;--cachedir&quot;,
                os.path.join(chroot_path, &quot;cache&quot;),
                &quot;--out&quot;,
                &quot;json&quot;,
                &quot;-l&quot;,
                &quot;quiet&quot;,
                &quot;--&quot;,
                function,
            ]
            + list(args)
            + [&quot;{}={}&quot;.format(k, v) for (k, v) in safe_kwargs.items()]
        )
        ret = __salt__[&quot;cmd.run_chroot&quot;](root, [str(x) for x in salt_argv])

        # Process &quot;real&quot; result in stdout
        try:
            data = __utils__[&quot;json.find_json&quot;](ret[&quot;stdout&quot;])
            local = data.get(&quot;local&quot;, data)
            if isinstance(local, dict) and &quot;retcode&quot; in local:
                __context__[&quot;retcode&quot;] = local[&quot;retcode&quot;]
            return local.get(&quot;return&quot;, data)
        except ValueError:
            return {
                &quot;result&quot;: False,
                &quot;retcode&quot;: ret[&quot;retcode&quot;],
                &quot;comment&quot;: {&quot;stdout&quot;: ret[&quot;stdout&quot;], &quot;stderr&quot;: ret[&quot;stderr&quot;]},
            }
    finally:
        __utils__[&quot;files.rm_rf&quot;](thin_dest_path)


def apply_(root, mods=None, **kwargs):
    &quot;&quot;&quot;
    Apply an state inside a chroot.

    This function will call `chroot.highstate` or `chroot.sls` based
    on the arguments passed to this function. It exists as a more
    intuitive way of applying states.

    root
        Path to the chroot environment

    For a formal description of the possible parameters accepted in
    this function, check `state.apply_` documentation.

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.apply /chroot
        salt myminion chroot.apply /chroot stuff
        salt myminion chroot.apply /chroot stuff pillar='{&quot;foo&quot;: &quot;bar&quot;}'

    &quot;&quot;&quot;
    if mods:
        return sls(root, mods, **kwargs)
    return highstate(root, **kwargs)


def _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type):
    &quot;&quot;&quot;
    Create the salt_state tarball, and execute in the chroot
    &quot;&quot;&quot;
    # Create the tar containing the state pkg and relevant files.
    salt.client.ssh.wrapper.state._cleanup_slsmod_low_data(chunks)
    trans_tar = salt.client.ssh.state.prep_trans_tar(
        salt.fileclient.get_file_client(__opts__),
        chunks,
        file_refs,
        __pillar__.value(),
        root,
    )
    trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, hash_type)

    ret = None

    # Create a temporary directory inside the chroot where we can move
    # the salt_state.tgz
    salt_state_path = tempfile.mkdtemp(dir=root)
    salt_state_path = os.path.join(salt_state_path, &quot;salt_state.tgz&quot;)
    salt_state_path_in_chroot = salt_state_path.replace(root, &quot;&quot;, 1)
    try:
        salt.utils.files.copyfile(trans_tar, salt_state_path)
        ret = call(
            root,
            &quot;state.pkg&quot;,
            salt_state_path_in_chroot,
            test=test,
            pkg_sum=trans_tar_sum,
            hash_type=hash_type,
        )
    finally:
        __utils__[&quot;files.rm_rf&quot;](salt_state_path)

    return ret


def sls(root, mods, saltenv=&quot;base&quot;, test=None, exclude=None, **kwargs):
    &quot;&quot;&quot;
    Execute the states in one or more SLS files inside the chroot.

    root
        Path to the chroot environment

    saltenv
        Specify a salt fileserver environment to be used when applying
        states

    mods
        List of states to execute

    test
        Run states in test-only (dry-run) mode

    exclude
        Exclude specific states from execution. Accepts a list of sls
        names, a comma-separated string of sls names, or a list of
        dictionaries containing ``sls`` or ``id`` keys. Glob-patterns
        may be used to match multiple states.

    For a formal description of the possible parameters accepted in
    this function, check `state.sls` documentation.

    CLI Example:

    .. code-block:: bash

        salt '*' chroot.sls /chroot stuff pillar='{&quot;foo&quot;: &quot;bar&quot;}'
    &quot;&quot;&quot;
    # Get a copy of the pillar data, to avoid overwriting the current
    # pillar, instead the one delegated
    pillar = copy.deepcopy(__pillar__.value())
    pillar.update(kwargs.get(&quot;pillar&quot;, {}))

    # Clone the options data and apply some default values. May not be
    # needed, as this module just delegate
    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
    st_ = salt.client.ssh.state.SSHHighState(
        opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
    )

    if isinstance(mods, str):
        mods = mods.split(&quot;,&quot;)

    high_data, errors = st_.render_highstate({saltenv: mods})
    if exclude:
        if isinstance(exclude, str):
            exclude = exclude.split(&quot;,&quot;)
        if &quot;__exclude__&quot; in high_data:
            high_data[&quot;__exclude__&quot;].extend(exclude)
        else:
            high_data[&quot;__exclude__&quot;] = exclude

    high_data, ext_errors = st_.state.reconcile_extend(high_data)
    errors += ext_errors
    errors += st_.state.verify_high(high_data)
    if errors:
        return errors

    high_data, req_in_errors = st_.state.requisite_in(high_data)
    errors += req_in_errors
    if errors:
        return errors

    high_data = st_.state.apply_exclude(high_data)

    # Compile and verify the raw chunks
    chunks = st_.state.compile_high_data(high_data)
    file_refs = salt.client.ssh.state.lowstate_file_refs(
        chunks,
        salt.client.ssh.wrapper.state._merge_extra_filerefs(
            kwargs.get(&quot;extra_filerefs&quot;, &quot;&quot;), opts.get(&quot;extra_filerefs&quot;, &quot;&quot;)
        ),
    )

    hash_type = opts[&quot;hash_type&quot;]
    return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)


def highstate(root, **kwargs):
    &quot;&quot;&quot;
    Retrieve the state data from the salt master for this minion and
    execute it inside the chroot.

    root
        Path to the chroot environment

    For a formal description of the possible parameters accepted in
    this function, check `state.highstate` documentation.

    CLI Example:

    .. code-block:: bash

        salt myminion chroot.highstate /chroot
        salt myminion chroot.highstate /chroot pillar='{&quot;foo&quot;: &quot;bar&quot;}'

    &quot;&quot;&quot;
    # Get a copy of the pillar data, to avoid overwriting the current
    # pillar, instead the one delegated
    pillar = copy.deepcopy(__pillar__.value())
    pillar.update(kwargs.get(&quot;pillar&quot;, {}))

    # Clone the options data and apply some default values. May not be
    # needed, as this module just delegate
    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
    with salt.client.ssh.state.SSHHighState(
        opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
    ) as st_:

        # Compile and verify the raw chunks
        chunks = st_.compile_low_chunks()
        file_refs = salt.client.ssh.state.lowstate_file_refs(
            chunks,
            salt.client.ssh.wrapper.state._merge_extra_filerefs(
                kwargs.get(&quot;extra_filerefs&quot;, &quot;&quot;), opts.get(&quot;extra_filerefs&quot;, &quot;&quot;)
            ),
        )
        # Check for errors
        for chunk in chunks:
            if not isinstance(chunk, dict):
                __context__[&quot;retcode&quot;] = 1
                return chunks

        test = kwargs.pop(&quot;test&quot;, False)
        hash_type = opts[&quot;hash_type&quot;]
        return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_lambda_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match214577-0.html#0',2,'match214577-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import os
import random
import string
from tempfile import NamedTemporaryFile

import salt.config
import salt.loader
import salt.modules.boto_lambda as boto_lambda
import salt.utils.stringutils
from salt.exceptions import SaltInvocationError
from salt.utils.versions import LooseVersion
from</B></FONT> tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

# pylint: disable=import-error,no-name-in-module
try:
    import boto3
    from botocore.exceptions import ClientError
    from botocore import __version__ as found_botocore_version

    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False

# pylint: enable=import-error,no-name-in-module

# the boto_lambda module relies on the connect_to_region() method
# which was added in boto 2.8.0
# https://github.com/boto/boto/commit/33ac26b416fbb48a60602542b4ce15dcc7029f12
required_boto3_version = &quot;1.2.1&quot;
required_botocore_version = &quot;1.5.2&quot;

region = &quot;us-east-1&quot;
access_key = &quot;GKTADJGHEIQSXMKKRBJ08H&quot;
secret_key = &quot;askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs&quot;
conn_parameters = {
    &quot;region&quot;: region,
    &quot;key&quot;: access_key,
    &quot;keyid&quot;: secret_key,
    &quot;profile&quot;: {},
}
error_message = (
    &quot;An error occurred (101) when calling the {0} operation: Test-defined error&quot;
)
error_content = {&quot;Error&quot;: {&quot;Code&quot;: 101, &quot;Message&quot;: &quot;Test-defined error&quot;}}
function_ret = dict(
    FunctionName=&quot;testfunction&quot;,
    Runtime=&quot;python2.7&quot;,
    Role=None,
    Handler=&quot;handler&quot;,
    Description=&quot;abcdefg&quot;,
    Timeout=5,
    MemorySize=128,
    CodeSha256=&quot;abcdef&quot;,
    CodeSize=199,
    FunctionArn=&quot;arn:lambda:us-east-1:1234:Something&quot;,
    LastModified=&quot;yes&quot;,
    VpcConfig=None,
    Environment=None,
)
alias_ret = dict(
    AliasArn=&quot;arn:lambda:us-east-1:1234:Something&quot;,
    Name=&quot;testalias&quot;,
    FunctionVersion=&quot;3&quot;,
    Description=&quot;Alias description&quot;,
)
event_source_mapping_ret = dict(
    UUID=&quot;1234-1-123&quot;,
    BatchSize=123,
    EventSourceArn=&quot;arn:lambda:us-east-1:1234:Something&quot;,
    FunctionArn=&quot;arn:lambda:us-east-1:1234:Something&quot;,
    LastModified=&quot;yes&quot;,
    LastProcessingResult=&quot;SUCCESS&quot;,
    State=&quot;Enabled&quot;,
    StateTransitionReason=&quot;Random&quot;,
)

log = logging.getLogger(__name__)


def _has_required_boto():
    &quot;&quot;&quot;
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    &quot;&quot;&quot;
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    elif LooseVersion(found_botocore_version) &lt; LooseVersion(required_botocore_version):
        return False
    else:
        return True


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto3 module must be greater than or equal to version {}, &quot;
    &quot;and botocore must be greater than or equal to {}&quot;.format(
        required_boto3_version, required_botocore_version
    ),
)
class BotoLambdaTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None

    def setup_loader_modules(self):
        self.opts = opts = salt.config.DEFAULT_MINION_OPTS.copy()
        utils = salt.loader.utils(
            opts, whitelist=[&quot;boto3&quot;, &quot;args&quot;, &quot;systemd&quot;, &quot;path&quot;, &quot;platform&quot;], context={}
        )
        return {boto_lambda: {&quot;__utils__&quot;: utils}}

    def setUp(self):
        super().setUp()
        boto_lambda.__init__(self.opts)
        del self.opts
        # Set up MagicMock to replace the boto3 session
        # connections keep getting cached from prior tests, can't find the
        # correct context object to clear it. So randomize the cache key, to prevent any
        # cache hits
        conn_parameters[&quot;key&quot;] = &quot;&quot;.join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )

        self.patcher = patch(&quot;boto3.session.Session&quot;)
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, &quot;patcher&quot;)
        mock_session = self.patcher.start()

        session_instance = mock_session.return_value
        self.conn = MagicMock()
        session_instance.client.return_value = self.conn
        self.addCleanup(delattr, self, &quot;conn&quot;)


class TempZipFile:
    def __enter__(self):
        with NamedTemporaryFile(
            suffix=&quot;.zip&quot;, prefix=&quot;salt_test_&quot;, delete=False
        ) as tmp:
            to_write = &quot;###\n&quot;
            to_write = salt.utils.stringutils.to_bytes(to_write)
            tmp.write(to_write)
            self.zipfile = tmp.name
        return self.zipfile

    def __exit__(self, type, value, traceback):
        os.remove(self.zipfile)


class BotoLambdaTestCaseMixin:
    pass


class BotoLambdaFunctionTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
    &quot;&quot;&quot;
    TestCase for salt.modules.boto_lambda module
    &quot;&quot;&quot;

    def test_that_when_checking_if_a_function_exists_and_a_function_exists_the_function_exists_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda function existence when the lambda function already exists
        &quot;&quot;&quot;
        self.conn.list_functions.return_value = {&quot;Functions&quot;: [function_ret]}
        func_exists_result = boto_lambda.function_exists(
            FunctionName=function_ret[&quot;FunctionName&quot;], **conn_parameters
        )

        self.assertTrue(func_exists_result[&quot;exists&quot;])

    def test_that_when_checking_if_a_function_exists_and_a_function_does_not_exist_the_function_exists_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda function existence when the lambda function does not exist
        &quot;&quot;&quot;
        self.conn.list_functions.return_value = {&quot;Functions&quot;: [function_ret]}
        func_exists_result = boto_lambda.function_exists(
            FunctionName=&quot;myfunc&quot;, **conn_parameters
        )

        self.assertFalse(func_exists_result[&quot;exists&quot;])

    def test_that_when_checking_if_a_function_exists_and_boto3_returns_an_error_the_function_exists_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda function existence when boto returns an error
        &quot;&quot;&quot;
        self.conn.list_functions.side_effect = ClientError(
            error_content, &quot;list_functions&quot;
        )
        func_exists_result = boto_lambda.function_exists(
            FunctionName=&quot;myfunc&quot;, **conn_parameters
        )

        self.assertEqual(
            func_exists_result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;list_functions&quot;),
        )

    def test_that_when_creating_a_function_from_zipfile_succeeds_the_create_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function created.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            with TempZipFile() as zipfile:
                self.conn.create_function.return_value = function_ret
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName=&quot;testfunction&quot;,
                    Runtime=&quot;python2.7&quot;,
                    Role=&quot;myrole&quot;,
                    Handler=&quot;file.method&quot;,
                    ZipFile=zipfile,
                    **conn_parameters
                )

        self.assertTrue(lambda_creation_result[&quot;created&quot;])

    def test_that_when_creating_a_function_from_s3_succeeds_the_create_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function created.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.create_function.return_value = function_ret
            lambda_creation_result = boto_lambda.create_function(
                FunctionName=&quot;testfunction&quot;,
                Runtime=&quot;python2.7&quot;,
                Role=&quot;myrole&quot;,
                Handler=&quot;file.method&quot;,
                S3Bucket=&quot;bucket&quot;,
                S3Key=&quot;key&quot;,
                **conn_parameters
            )

        self.assertTrue(lambda_creation_result[&quot;created&quot;])

    def test_that_when_creating_a_function_without_code_raises_a_salt_invocation_error(
        self,
    ):
        &quot;&quot;&quot;
        tests Creating a function without code
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                &quot;Either ZipFile must be specified, or S3Bucket and S3Key must be&quot;
                &quot; provided.&quot;,
            ):
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName=&quot;testfunction&quot;,
                    Runtime=&quot;python2.7&quot;,
                    Role=&quot;myrole&quot;,
                    Handler=&quot;file.method&quot;,
                    **conn_parameters
                )

    def test_that_when_creating_a_function_with_zipfile_and_s3_raises_a_salt_invocation_error(
        self,
    ):
        &quot;&quot;&quot;
        tests Creating a function without code
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                &quot;Either ZipFile must be specified, or S3Bucket and S3Key must be&quot;
                &quot; provided.&quot;,
            ):
                with TempZipFile() as zipfile:
                    lambda_creation_result = boto_lambda.create_function(
                        FunctionName=&quot;testfunction&quot;,
                        Runtime=&quot;python2.7&quot;,
                        Role=&quot;myrole&quot;,
                        Handler=&quot;file.method&quot;,
                        ZipFile=zipfile,
                        S3Bucket=&quot;bucket&quot;,
                        S3Key=&quot;key&quot;,
                        **conn_parameters
                    )

    def test_that_when_creating_a_function_fails_the_create_function_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False function not created.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.create_function.side_effect = ClientError(
                error_content, &quot;create_function&quot;
            )
            with TempZipFile() as zipfile:
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName=&quot;testfunction&quot;,
                    Runtime=&quot;python2.7&quot;,
                    Role=&quot;myrole&quot;,
                    Handler=&quot;file.method&quot;,
                    ZipFile=zipfile,
                    **conn_parameters
                )
        self.assertEqual(
            lambda_creation_result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;create_function&quot;),
        )

    def test_that_when_deleting_a_function_succeeds_the_delete_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function deleted.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            result = boto_lambda.delete_function(
                FunctionName=&quot;testfunction&quot;, Qualifier=1, **conn_parameters
            )

        self.assertTrue(result[&quot;deleted&quot;])

    def test_that_when_deleting_a_function_fails_the_delete_function_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        tests False function not deleted.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.delete_function.side_effect = ClientError(
                error_content, &quot;delete_function&quot;
            )
            result = boto_lambda.delete_function(
                FunctionName=&quot;testfunction&quot;, **conn_parameters
            )
        self.assertFalse(result[&quot;deleted&quot;])

    def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if function exists
        &quot;&quot;&quot;
        self.conn.list_functions.return_value = {&quot;Functions&quot;: [function_ret]}

        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            result = boto_lambda.describe_function(
                FunctionName=function_ret[&quot;FunctionName&quot;], **conn_parameters
            )

        self.assertEqual(result, {&quot;function&quot;: function_ret})

    def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if function does not exist
        &quot;&quot;&quot;
        self.conn.list_functions.return_value = {&quot;Functions&quot;: []}
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            result = boto_lambda.describe_function(
                FunctionName=&quot;testfunction&quot;, **conn_parameters
            )

        self.assertFalse(result[&quot;function&quot;])

    def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
        &quot;&quot;&quot;
        Tests describing parameters failure
        &quot;&quot;&quot;
        self.conn.list_functions.side_effect = ClientError(
            error_content, &quot;list_functions&quot;
        )
        result = boto_lambda.describe_function(
            FunctionName=&quot;testfunction&quot;, **conn_parameters
        )
        self.assertTrue(&quot;error&quot; in result)

    def test_that_when_updating_a_function_succeeds_the_update_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function updated.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.update_function_config.return_value = function_ret
            result = boto_lambda.update_function_config(
                FunctionName=function_ret[&quot;FunctionName&quot;],
                Role=&quot;myrole&quot;,
                **conn_parameters
            )

        self.assertTrue(result[&quot;updated&quot;])

    def test_that_when_updating_a_function_fails_the_update_function_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False function not updated.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.update_function_configuration.side_effect = ClientError(
                error_content, &quot;update_function&quot;
            )
            result = boto_lambda.update_function_config(
                FunctionName=&quot;testfunction&quot;, Role=&quot;myrole&quot;, **conn_parameters
            )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;update_function&quot;),
        )

    def test_that_when_updating_function_code_from_zipfile_succeeds_the_update_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function updated.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            with TempZipFile() as zipfile:
                self.conn.update_function_code.return_value = function_ret
                result = boto_lambda.update_function_code(
                    FunctionName=function_ret[&quot;FunctionName&quot;],
                    ZipFile=zipfile,
                    **conn_parameters
                )

        self.assertTrue(result[&quot;updated&quot;])

    def test_that_when_updating_function_code_from_s3_succeeds_the_update_function_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function updated.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.update_function_code.return_value = function_ret
            result = boto_lambda.update_function_code(
                FunctionName=&quot;testfunction&quot;,
                S3Bucket=&quot;bucket&quot;,
                S3Key=&quot;key&quot;,
                **conn_parameters
            )

        self.assertTrue(result[&quot;updated&quot;])

    def test_that_when_updating_function_code_without_code_raises_a_salt_invocation_error(
        self,
    ):
        &quot;&quot;&quot;
        tests Creating a function without code
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                &quot;Either ZipFile must be specified, or S3Bucket &quot;
                &quot;and S3Key must be provided.&quot;,
            ):
                result = boto_lambda.update_function_code(
                    FunctionName=&quot;testfunction&quot;, **conn_parameters
                )

    def test_that_when_updating_function_code_fails_the_update_function_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False function not updated.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.update_function_code.side_effect = ClientError(
                error_content, &quot;update_function_code&quot;
            )
            result = boto_lambda.update_function_code(
                FunctionName=&quot;testfunction&quot;,
                S3Bucket=&quot;bucket&quot;,
                S3Key=&quot;key&quot;,
                **conn_parameters
            )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;update_function_code&quot;),
        )

    def test_that_when_listing_function_versions_succeeds_the_list_function_versions_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True function versions listed.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.list_versions_by_function.return_value = {
                &quot;Versions&quot;: [function_ret]
            }
            result = boto_lambda.list_function_versions(
                FunctionName=&quot;testfunction&quot;, **conn_parameters
            )

        self.assertTrue(result[&quot;Versions&quot;])

    def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        tests False no function versions listed.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.list_versions_by_function.return_value = {&quot;Versions&quot;: []}
            result = boto_lambda.list_function_versions(
                FunctionName=&quot;testfunction&quot;, **conn_parameters
            )
        self.assertFalse(result[&quot;Versions&quot;])

    def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False function versions error.
        &quot;&quot;&quot;
        with patch.dict(
            boto_lambda.__salt__,
            {&quot;boto_iam.get_account_id&quot;: MagicMock(return_value=&quot;1234&quot;)},
        ):
            self.conn.list_versions_by_function.side_effect = ClientError(
                error_content, &quot;list_versions_by_function&quot;
            )
            result = boto_lambda.list_function_versions(
                FunctionName=&quot;testfunction&quot;, **conn_parameters
            )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;list_versions_by_function&quot;),
        )


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto3 module must be greater than or equal to version {}&quot;.format(
        required_boto3_version
    ),
)
class BotoLambdaAliasTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
    &quot;&quot;&quot;
    TestCase for salt.modules.boto_lambda module aliases
    &quot;&quot;&quot;

    def test_that_when_creating_an_alias_succeeds_the_create_alias_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True alias created.
        &quot;&quot;&quot;
        self.conn.create_alias.return_value = alias_ret
        result = boto_lambda.create_alias(
            FunctionName=&quot;testfunction&quot;,
            Name=alias_ret[&quot;Name&quot;],
            FunctionVersion=alias_ret[&quot;FunctionVersion&quot;],
            **conn_parameters
        )

        self.assertTrue(result[&quot;created&quot;])

    def test_that_when_creating_an_alias_fails_the_create_alias_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False alias not created.
        &quot;&quot;&quot;
        self.conn.create_alias.side_effect = ClientError(error_content, &quot;create_alias&quot;)
        result = boto_lambda.create_alias(
            FunctionName=&quot;testfunction&quot;,
            Name=alias_ret[&quot;Name&quot;],
            FunctionVersion=alias_ret[&quot;FunctionVersion&quot;],
            **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;), error_message.format(&quot;create_alias&quot;)
        )

    def test_that_when_deleting_an_alias_succeeds_the_delete_alias_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True alias deleted.
        &quot;&quot;&quot;
        result = boto_lambda.delete_alias(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )

        self.assertTrue(result[&quot;deleted&quot;])

    def test_that_when_deleting_an_alias_fails_the_delete_alias_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        tests False alias not deleted.
        &quot;&quot;&quot;
        self.conn.delete_alias.side_effect = ClientError(error_content, &quot;delete_alias&quot;)
        result = boto_lambda.delete_alias(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )
        self.assertFalse(result[&quot;deleted&quot;])

    def test_that_when_checking_if_an_alias_exists_and_the_alias_exists_the_alias_exists_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda alias existence when the lambda alias already exists
        &quot;&quot;&quot;
        self.conn.list_aliases.return_value = {&quot;Aliases&quot;: [alias_ret]}
        result = boto_lambda.alias_exists(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )
        self.assertTrue(result[&quot;exists&quot;])

    def test_that_when_checking_if_an_alias_exists_and_the_alias_does_not_exist_the_alias_exists_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda alias existence when the lambda alias does not exist
        &quot;&quot;&quot;
        self.conn.list_aliases.return_value = {&quot;Aliases&quot;: [alias_ret]}
        result = boto_lambda.alias_exists(
            FunctionName=&quot;testfunction&quot;, Name=&quot;otheralias&quot;, **conn_parameters
        )

        self.assertFalse(result[&quot;exists&quot;])

    def test_that_when_checking_if_an_alias_exists_and_boto3_returns_an_error_the_alias_exists_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda alias existence when boto returns an error
        &quot;&quot;&quot;
        self.conn.list_aliases.side_effect = ClientError(error_content, &quot;list_aliases&quot;)
        result = boto_lambda.alias_exists(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )

        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;), error_message.format(&quot;list_aliases&quot;)
        )

    def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if alias exists
        &quot;&quot;&quot;
        self.conn.list_aliases.return_value = {&quot;Aliases&quot;: [alias_ret]}

        result = boto_lambda.describe_alias(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )

        self.assertEqual(result, {&quot;alias&quot;: alias_ret})

    def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if alias does not exist
        &quot;&quot;&quot;
        self.conn.list_aliases.return_value = {&quot;Aliases&quot;: [alias_ret]}
        result = boto_lambda.describe_alias(
            FunctionName=&quot;testfunction&quot;, Name=&quot;othername&quot;, **conn_parameters
        )

        self.assertFalse(result[&quot;alias&quot;])

    def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
        &quot;&quot;&quot;
        Tests describing parameters failure
        &quot;&quot;&quot;
        self.conn.list_aliases.side_effect = ClientError(error_content, &quot;list_aliases&quot;)
        result = boto_lambda.describe_alias(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )
        self.assertTrue(&quot;error&quot; in result)

    def test_that_when_updating_an_alias_succeeds_the_update_alias_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True alias updated.
        &quot;&quot;&quot;
        self.conn.update_alias.return_value = alias_ret
        result = boto_lambda.update_alias(
            FunctionName=&quot;testfunctoin&quot;,
            Name=alias_ret[&quot;Name&quot;],
            Description=alias_ret[&quot;Description&quot;],
            **conn_parameters
        )

        self.assertTrue(result[&quot;updated&quot;])

    def test_that_when_updating_an_alias_fails_the_update_alias_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False alias not updated.
        &quot;&quot;&quot;
        self.conn.update_alias.side_effect = ClientError(error_content, &quot;update_alias&quot;)
        result = boto_lambda.update_alias(
            FunctionName=&quot;testfunction&quot;, Name=alias_ret[&quot;Name&quot;], **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;), error_message.format(&quot;update_alias&quot;)
        )


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(
    _has_required_boto() is False,
    &quot;The boto3 module must be greater than or equal to version {}&quot;.format(
        required_boto3_version
    ),
)
class BotoLambdaEventSourceMappingTestCase(
    BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin
):
    &quot;&quot;&quot;
    TestCase for salt.modules.boto_lambda module mappings
    &quot;&quot;&quot;

    def test_that_when_creating_a_mapping_succeeds_the_create_event_source_mapping_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True mapping created.
        &quot;&quot;&quot;
        self.conn.create_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.create_event_source_mapping(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            StartingPosition=&quot;LATEST&quot;,
            **conn_parameters
        )

        self.assertTrue(result[&quot;created&quot;])

    def test_that_when_creating_an_event_source_mapping_fails_the_create_event_source_mapping_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False mapping not created.
        &quot;&quot;&quot;
        self.conn.create_event_source_mapping.side_effect = ClientError(
            error_content, &quot;create_event_source_mapping&quot;
        )
        result = boto_lambda.create_event_source_mapping(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            StartingPosition=&quot;LATEST&quot;,
            **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;create_event_source_mapping&quot;),
        )

    def test_that_when_listing_mapping_ids_succeeds_the_get_event_source_mapping_ids_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True mapping ids listed.
        &quot;&quot;&quot;
        self.conn.list_event_source_mappings.return_value = {
            &quot;EventSourceMappings&quot;: [event_source_mapping_ret]
        }
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )

        self.assertTrue(result)

    def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_versions_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        tests False no mapping ids listed.
        &quot;&quot;&quot;
        self.conn.list_event_source_mappings.return_value = {&quot;EventSourceMappings&quot;: []}
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )
        self.assertFalse(result)

    def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False mapping ids error.
        &quot;&quot;&quot;
        self.conn.list_event_source_mappings.side_effect = ClientError(
            error_content, &quot;list_event_source_mappings&quot;
        )
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;list_event_source_mappings&quot;),
        )

    def test_that_when_deleting_an_event_source_mapping_by_UUID_succeeds_the_delete_event_source_mapping_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True mapping deleted.
        &quot;&quot;&quot;
        result = boto_lambda.delete_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertTrue(result[&quot;deleted&quot;])

    @skipIf(True, &quot;This appears to leak memory and crash the unit test suite&quot;)
    def test_that_when_deleting_an_event_source_mapping_by_name_succeeds_the_delete_event_source_mapping_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True mapping deleted.
        &quot;&quot;&quot;
        self.conn.list_event_source_mappings.return_value = {
            &quot;EventSourceMappings&quot;: [event_source_mapping_ret]
        }
        result = boto_lambda.delete_event_source_mapping(
            EventSourceArn=event_source_mapping_ret[&quot;EventSourceArn&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )
        self.assertTrue(result[&quot;deleted&quot;])

    def test_that_when_deleting_an_event_source_mapping_without_identifier_the_delete_event_source_mapping_method_raises_saltinvocationexception(
        self,
    ):
        &quot;&quot;&quot;
        tests Deleting a mapping without identifier
        &quot;&quot;&quot;
        with self.assertRaisesRegex(
            SaltInvocationError,
            &quot;Either UUID must be specified, or EventSourceArn &quot;
            &quot;and FunctionName must be provided.&quot;,
        ):
            result = boto_lambda.delete_event_source_mapping(**conn_parameters)

    def test_that_when_deleting_an_event_source_mapping_fails_the_delete_event_source_mapping_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        tests False mapping not deleted.
        &quot;&quot;&quot;
        self.conn.delete_event_source_mapping.side_effect = ClientError(
            error_content, &quot;delete_event_source_mapping&quot;
        )
        result = boto_lambda.delete_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertFalse(result[&quot;deleted&quot;])

    def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_exists_the_event_source_mapping_exists_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda event_source_mapping existence when the lambda
        event_source_mapping already exists
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.event_source_mapping_exists(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertTrue(result[&quot;exists&quot;])

    def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_does_not_exist_the_event_source_mapping_exists_method_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda event_source_mapping existence when the lambda
        event_source_mapping does not exist
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.return_value = None
        result = boto_lambda.event_source_mapping_exists(
            UUID=&quot;other_UUID&quot;, **conn_parameters
        )
        self.assertFalse(result[&quot;exists&quot;])

    def test_that_when_checking_if_an_event_source_mapping_exists_and_boto3_returns_an_error_the_event_source_mapping_exists_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        Tests checking lambda event_source_mapping existence when boto returns an error
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.side_effect = ClientError(
            error_content, &quot;list_event_source_mappings&quot;
        )
        result = boto_lambda.event_source_mapping_exists(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;list_event_source_mappings&quot;),
        )

    def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if event_source_mapping exists
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertEqual(result, {&quot;event_source_mapping&quot;: event_source_mapping_ret})

    def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters if event_source_mapping does not exist
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.return_value = None
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertFalse(result[&quot;event_source_mapping&quot;])

    def test_that_when_describing_event_source_mapping_on_client_error_it_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        Tests describing parameters failure
        &quot;&quot;&quot;
        self.conn.get_event_source_mapping.side_effect = ClientError(
            error_content, &quot;get_event_source_mapping&quot;
        )
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;], **conn_parameters
        )
        self.assertTrue(&quot;error&quot; in result)

    def test_that_when_updating_an_event_source_mapping_succeeds_the_update_event_source_mapping_method_returns_true(
        self,
    ):
        &quot;&quot;&quot;
        tests True event_source_mapping updated.
        &quot;&quot;&quot;
        self.conn.update_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.update_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )

        self.assertTrue(result[&quot;updated&quot;])

    def test_that_when_updating_an_event_source_mapping_fails_the_update_event_source_mapping_method_returns_error(
        self,
    ):
        &quot;&quot;&quot;
        tests False event_source_mapping not updated.
        &quot;&quot;&quot;
        self.conn.update_event_source_mapping.side_effect = ClientError(
            error_content, &quot;update_event_source_mapping&quot;
        )
        result = boto_lambda.update_event_source_mapping(
            UUID=event_source_mapping_ret[&quot;UUID&quot;],
            FunctionName=event_source_mapping_ret[&quot;FunctionArn&quot;],
            **conn_parameters
        )
        self.assertEqual(
            result.get(&quot;error&quot;, {}).get(&quot;message&quot;),
            error_message.format(&quot;update_event_source_mapping&quot;),
        )
</PRE>
</div>
  </div>
</body>
</html>
