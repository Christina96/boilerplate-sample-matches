<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for chroot.py &amp; test_boto_lambda_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for chroot.py &amp; test_boto_lambda_1.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>chroot.py (2.7777777%)<th>test_boto_lambda_1.py (1.0230179%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>chroot.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import logging
3 import os
4 import sys
5 import tempfile
6 import salt
7 import salt.client.ssh.state
8 import salt.client.ssh.wrapper.state
9 import salt.defaults.exitcodes
10 import salt.exceptions
11 import salt.utils.args
12 import</b></font> salt.utils.files
13 __func_alias__ = {"apply_": "apply"}
14 log = logging.getLogger(__name__)
15 def __virtual__():
16     if __utils__["path.which"]("chroot") is not None:
17         return True
18     else:
19         return (False, "Module chroot requires the command chroot")
20 def exist(root):
21     dev = os.path.join(root, "dev")
22     proc = os.path.join(root, "proc")
23     sys = os.path.join(root, "sys")
24     return all(os.path.isdir(i) for i in (root, dev, proc, sys))
25 def create(root):
26     if not exist(root):
27         dev = os.path.join(root, "dev")
28         proc = os.path.join(root, "proc")
29         sys = os.path.join(root, "sys")
30         try:
31             os.makedirs(dev, mode=0o755)
32             os.makedirs(proc, mode=0o555)
33             os.makedirs(sys, mode=0o555)
34         except OSError as e:
35             log.error("Error when trying to create chroot directories: %s", e)
36             return False
37     return True
38 def in_chroot():
39     result = False
40     try:
41         with salt.utils.files.fopen(
42             "/proc/1/mountinfo"
43         ) as root_fd, salt.utils.files.fopen("/proc/self/mountinfo") as self_fd:
44             root_mountinfo = root_fd.read()
45             self_mountinfo = self_fd.read()
46         result = root_mountinfo != self_mountinfo
47     except OSError:
48         pass
49     return result
50 def call(root, function, *args, **kwargs):
51     if not function:
52         raise salt.exceptions.CommandExecutionError("Missing function parameter")
53     if not exist(root):
54         raise salt.exceptions.CommandExecutionError("Chroot environment not found")
55     thin_dest_path = tempfile.mkdtemp(dir=root)
56     thin_path = __utils__["thin.gen_thin"](
57         __opts__["cachedir"],
58         extra_mods=__salt__["config.option"]("thin_extra_mods", ""),
59         so_mods=__salt__["config.option"]("thin_so_mods", ""),
60     )
61     stdout = __salt__["cmd.run"](["tar", "xzf", thin_path, "-C", thin_dest_path])
62     if stdout:
63         __utils__["files.rm_rf"](thin_dest_path)
64         return {"result": False, "comment": stdout}
65     chroot_path = os.path.join(os.path.sep, os.path.relpath(thin_dest_path, root))
66     try:
67         safe_kwargs = salt.utils.args.clean_kwargs(**kwargs)
68         salt_argv = (
69             [
70                 "python{}".format(sys.version_info[0]),
71                 os.path.join(chroot_path, "salt-call"),
72                 "--metadata",
73                 "--local",
74                 "--log-file",
75                 os.path.join(chroot_path, "log"),
76                 "--cachedir",
77                 os.path.join(chroot_path, "cache"),
78                 "--out",
79                 "json",
80                 "-l",
81                 "quiet",
82                 "--",
83                 function,
84             ]
85             + list(args)
86             + ["{}={}".format(k, v) for (k, v) in safe_kwargs.items()]
87         )
88         ret = __salt__["cmd.run_chroot"](root, [str(x) for x in salt_argv])
89         try:
90             data = __utils__["json.find_json"](ret["stdout"])
91             local = data.get("local", data)
92             if isinstance(local, dict) and "retcode" in local:
93                 __context__["retcode"] = local["retcode"]
94             return local.get("return", data)
95         except ValueError:
96             return {
97                 "result": False,
98                 "retcode": ret["retcode"],
99                 "comment": {"stdout": ret["stdout"], "stderr": ret["stderr"]},
100             }
101     finally:
102         __utils__["files.rm_rf"](thin_dest_path)
103 def apply_(root, mods=None, **kwargs):
104     if mods:
105         return sls(root, mods, **kwargs)
106     return highstate(root, **kwargs)
107 def _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type):
108     salt.client.ssh.wrapper.state._cleanup_slsmod_low_data(chunks)
109     trans_tar = salt.client.ssh.state.prep_trans_tar(
110         salt.fileclient.get_file_client(__opts__),
111         chunks,
112         file_refs,
113         __pillar__.value(),
114         root,
115     )
116     trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, hash_type)
117     ret = None
118     salt_state_path = tempfile.mkdtemp(dir=root)
119     salt_state_path = os.path.join(salt_state_path, "salt_state.tgz")
120     salt_state_path_in_chroot = salt_state_path.replace(root, "", 1)
121     try:
122         salt.utils.files.copyfile(trans_tar, salt_state_path)
123         ret = call(
124             root,
125             "state.pkg",
126             salt_state_path_in_chroot,
127             test=test,
128             pkg_sum=trans_tar_sum,
129             hash_type=hash_type,
130         )
131     finally:
132         __utils__["files.rm_rf"](salt_state_path)
133     return ret
134 def sls(root, mods, saltenv="base", test=None, exclude=None, **kwargs):
135     pillar = copy.deepcopy(__pillar__.value())
136     pillar.update(kwargs.get("pillar", {}))
137     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
138     st_ = salt.client.ssh.state.SSHHighState(
139         opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
140     )
141     if isinstance(mods, str):
142         mods = mods.split(",")
143     high_data, errors = st_.render_highstate({saltenv: mods})
144     if exclude:
145         if isinstance(exclude, str):
146             exclude = exclude.split(",")
147         if "__exclude__" in high_data:
148             high_data["__exclude__"].extend(exclude)
149         else:
150             high_data["__exclude__"] = exclude
151     high_data, ext_errors = st_.state.reconcile_extend(high_data)
152     errors += ext_errors
153     errors += st_.state.verify_high(high_data)
154     if errors:
155         return errors
156     high_data, req_in_errors = st_.state.requisite_in(high_data)
157     errors += req_in_errors
158     if errors:
159         return errors
160     high_data = st_.state.apply_exclude(high_data)
161     chunks = st_.state.compile_high_data(high_data)
162     file_refs = salt.client.ssh.state.lowstate_file_refs(
163         chunks,
164         salt.client.ssh.wrapper.state._merge_extra_filerefs(
165             kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
166         ),
167     )
168     hash_type = opts["hash_type"]
169     return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
170 def highstate(root, **kwargs):
171     pillar = copy.deepcopy(__pillar__.value())
172     pillar.update(kwargs.get("pillar", {}))
173     opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
174     with salt.client.ssh.state.SSHHighState(
175         opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
176     ) as st_:
177         chunks = st_.compile_low_chunks()
178         file_refs = salt.client.ssh.state.lowstate_file_refs(
179             chunks,
180             salt.client.ssh.wrapper.state._merge_extra_filerefs(
181                 kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
182             ),
183         )
184         for chunk in chunks:
185             if not isinstance(chunk, dict):
186                 __context__["retcode"] = 1
187                 return chunks
188         test = kwargs.pop("test", False)
189         hash_type = opts["hash_type"]
190         return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_lambda_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import random
3 import string
4 from tempfile import NamedTemporaryFile
5 import salt.config
6 import salt.loader
7 import salt.modules.boto_lambda as boto_lambda
8 import salt.utils.stringutils
9 from salt.exceptions import SaltInvocationError
10 from salt.utils.versions import LooseVersion
11 from</b></font> tests.support.mixins import LoaderModuleMockMixin
12 from tests.support.mock import MagicMock, patch
13 from tests.support.unit import TestCase, skipIf
14 try:
15     import boto3
16     from botocore.exceptions import ClientError
17     from botocore import __version__ as found_botocore_version
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 required_boto3_version = "1.2.1"
22 required_botocore_version = "1.5.2"
23 region = "us-east-1"
24 access_key = "GKTADJGHEIQSXMKKRBJ08H"
25 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
26 conn_parameters = {
27     "region": region,
28     "key": access_key,
29     "keyid": secret_key,
30     "profile": {},
31 }
32 error_message = (
33     "An error occurred (101) when calling the {0} operation: Test-defined error"
34 )
35 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
36 function_ret = dict(
37     FunctionName="testfunction",
38     Runtime="python2.7",
39     Role=None,
40     Handler="handler",
41     Description="abcdefg",
42     Timeout=5,
43     MemorySize=128,
44     CodeSha256="abcdef",
45     CodeSize=199,
46     FunctionArn="arn:lambda:us-east-1:1234:Something",
47     LastModified="yes",
48     VpcConfig=None,
49     Environment=None,
50 )
51 alias_ret = dict(
52     AliasArn="arn:lambda:us-east-1:1234:Something",
53     Name="testalias",
54     FunctionVersion="3",
55     Description="Alias description",
56 )
57 event_source_mapping_ret = dict(
58     UUID="1234-1-123",
59     BatchSize=123,
60     EventSourceArn="arn:lambda:us-east-1:1234:Something",
61     FunctionArn="arn:lambda:us-east-1:1234:Something",
62     LastModified="yes",
63     LastProcessingResult="SUCCESS",
64     State="Enabled",
65     StateTransitionReason="Random",
66 )
67 log = logging.getLogger(__name__)
68 def _has_required_boto():
69     if not HAS_BOTO:
70         return False
71     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
72         return False
73     elif LooseVersion(found_botocore_version) &lt; LooseVersion(required_botocore_version):
74         return False
75     else:
76         return True
77 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
78 @skipIf(
79     _has_required_boto() is False,
80     "The boto3 module must be greater than or equal to version {}, "
81     "and botocore must be greater than or equal to {}".format(
82         required_boto3_version, required_botocore_version
83     ),
84 )
85 class BotoLambdaTestCaseBase(TestCase, LoaderModuleMockMixin):
86     conn = None
87     def setup_loader_modules(self):
88         self.opts = opts = salt.config.DEFAULT_MINION_OPTS.copy()
89         utils = salt.loader.utils(
90             opts, whitelist=["boto3", "args", "systemd", "path", "platform"], context={}
91         )
92         return {boto_lambda: {"__utils__": utils}}
93     def setUp(self):
94         super().setUp()
95         boto_lambda.__init__(self.opts)
96         del self.opts
97         conn_parameters["key"] = "".join(
98             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
99         )
100         self.patcher = patch("boto3.session.Session")
101         self.addCleanup(self.patcher.stop)
102         self.addCleanup(delattr, self, "patcher")
103         mock_session = self.patcher.start()
104         session_instance = mock_session.return_value
105         self.conn = MagicMock()
106         session_instance.client.return_value = self.conn
107         self.addCleanup(delattr, self, "conn")
108 class TempZipFile:
109     def __enter__(self):
110         with NamedTemporaryFile(
111             suffix=".zip", prefix="salt_test_", delete=False
112         ) as tmp:
113             to_write = "###\n"
114             to_write = salt.utils.stringutils.to_bytes(to_write)
115             tmp.write(to_write)
116             self.zipfile = tmp.name
117         return self.zipfile
118     def __exit__(self, type, value, traceback):
119         os.remove(self.zipfile)
120 class BotoLambdaTestCaseMixin:
121     pass
122 class BotoLambdaFunctionTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
123     def test_that_when_checking_if_a_function_exists_and_a_function_exists_the_function_exists_method_returns_true(
124         self,
125     ):
126         self.conn.list_functions.return_value = {"Functions": [function_ret]}
127         func_exists_result = boto_lambda.function_exists(
128             FunctionName=function_ret["FunctionName"], **conn_parameters
129         )
130         self.assertTrue(func_exists_result["exists"])
131     def test_that_when_checking_if_a_function_exists_and_a_function_does_not_exist_the_function_exists_method_returns_false(
132         self,
133     ):
134         self.conn.list_functions.return_value = {"Functions": [function_ret]}
135         func_exists_result = boto_lambda.function_exists(
136             FunctionName="myfunc", **conn_parameters
137         )
138         self.assertFalse(func_exists_result["exists"])
139     def test_that_when_checking_if_a_function_exists_and_boto3_returns_an_error_the_function_exists_method_returns_error(
140         self,
141     ):
142         self.conn.list_functions.side_effect = ClientError(
143             error_content, "list_functions"
144         )
145         func_exists_result = boto_lambda.function_exists(
146             FunctionName="myfunc", **conn_parameters
147         )
148         self.assertEqual(
149             func_exists_result.get("error", {}).get("message"),
150             error_message.format("list_functions"),
151         )
152     def test_that_when_creating_a_function_from_zipfile_succeeds_the_create_function_method_returns_true(
153         self,
154     ):
155         with patch.dict(
156             boto_lambda.__salt__,
157             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
158         ):
159             with TempZipFile() as zipfile:
160                 self.conn.create_function.return_value = function_ret
161                 lambda_creation_result = boto_lambda.create_function(
162                     FunctionName="testfunction",
163                     Runtime="python2.7",
164                     Role="myrole",
165                     Handler="file.method",
166                     ZipFile=zipfile,
167                     **conn_parameters
168                 )
169         self.assertTrue(lambda_creation_result["created"])
170     def test_that_when_creating_a_function_from_s3_succeeds_the_create_function_method_returns_true(
171         self,
172     ):
173         with patch.dict(
174             boto_lambda.__salt__,
175             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
176         ):
177             self.conn.create_function.return_value = function_ret
178             lambda_creation_result = boto_lambda.create_function(
179                 FunctionName="testfunction",
180                 Runtime="python2.7",
181                 Role="myrole",
182                 Handler="file.method",
183                 S3Bucket="bucket",
184                 S3Key="key",
185                 **conn_parameters
186             )
187         self.assertTrue(lambda_creation_result["created"])
188     def test_that_when_creating_a_function_without_code_raises_a_salt_invocation_error(
189         self,
190     ):
191         with patch.dict(
192             boto_lambda.__salt__,
193             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
194         ):
195             with self.assertRaisesRegex(
196                 SaltInvocationError,
197                 "Either ZipFile must be specified, or S3Bucket and S3Key must be"
198                 " provided.",
199             ):
200                 lambda_creation_result = boto_lambda.create_function(
201                     FunctionName="testfunction",
202                     Runtime="python2.7",
203                     Role="myrole",
204                     Handler="file.method",
205                     **conn_parameters
206                 )
207     def test_that_when_creating_a_function_with_zipfile_and_s3_raises_a_salt_invocation_error(
208         self,
209     ):
210         with patch.dict(
211             boto_lambda.__salt__,
212             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
213         ):
214             with self.assertRaisesRegex(
215                 SaltInvocationError,
216                 "Either ZipFile must be specified, or S3Bucket and S3Key must be"
217                 " provided.",
218             ):
219                 with TempZipFile() as zipfile:
220                     lambda_creation_result = boto_lambda.create_function(
221                         FunctionName="testfunction",
222                         Runtime="python2.7",
223                         Role="myrole",
224                         Handler="file.method",
225                         ZipFile=zipfile,
226                         S3Bucket="bucket",
227                         S3Key="key",
228                         **conn_parameters
229                     )
230     def test_that_when_creating_a_function_fails_the_create_function_method_returns_error(
231         self,
232     ):
233         with patch.dict(
234             boto_lambda.__salt__,
235             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
236         ):
237             self.conn.create_function.side_effect = ClientError(
238                 error_content, "create_function"
239             )
240             with TempZipFile() as zipfile:
241                 lambda_creation_result = boto_lambda.create_function(
242                     FunctionName="testfunction",
243                     Runtime="python2.7",
244                     Role="myrole",
245                     Handler="file.method",
246                     ZipFile=zipfile,
247                     **conn_parameters
248                 )
249         self.assertEqual(
250             lambda_creation_result.get("error", {}).get("message"),
251             error_message.format("create_function"),
252         )
253     def test_that_when_deleting_a_function_succeeds_the_delete_function_method_returns_true(
254         self,
255     ):
256         with patch.dict(
257             boto_lambda.__salt__,
258             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
259         ):
260             result = boto_lambda.delete_function(
261                 FunctionName="testfunction", Qualifier=1, **conn_parameters
262             )
263         self.assertTrue(result["deleted"])
264     def test_that_when_deleting_a_function_fails_the_delete_function_method_returns_false(
265         self,
266     ):
267         with patch.dict(
268             boto_lambda.__salt__,
269             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
270         ):
271             self.conn.delete_function.side_effect = ClientError(
272                 error_content, "delete_function"
273             )
274             result = boto_lambda.delete_function(
275                 FunctionName="testfunction", **conn_parameters
276             )
277         self.assertFalse(result["deleted"])
278     def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_true(
279         self,
280     ):
281         self.conn.list_functions.return_value = {"Functions": [function_ret]}
282         with patch.dict(
283             boto_lambda.__salt__,
284             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
285         ):
286             result = boto_lambda.describe_function(
287                 FunctionName=function_ret["FunctionName"], **conn_parameters
288             )
289         self.assertEqual(result, {"function": function_ret})
290     def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_false(
291         self,
292     ):
293         self.conn.list_functions.return_value = {"Functions": []}
294         with patch.dict(
295             boto_lambda.__salt__,
296             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
297         ):
298             result = boto_lambda.describe_function(
299                 FunctionName="testfunction", **conn_parameters
300             )
301         self.assertFalse(result["function"])
302     def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
303         self.conn.list_functions.side_effect = ClientError(
304             error_content, "list_functions"
305         )
306         result = boto_lambda.describe_function(
307             FunctionName="testfunction", **conn_parameters
308         )
309         self.assertTrue("error" in result)
310     def test_that_when_updating_a_function_succeeds_the_update_function_method_returns_true(
311         self,
312     ):
313         with patch.dict(
314             boto_lambda.__salt__,
315             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
316         ):
317             self.conn.update_function_config.return_value = function_ret
318             result = boto_lambda.update_function_config(
319                 FunctionName=function_ret["FunctionName"],
320                 Role="myrole",
321                 **conn_parameters
322             )
323         self.assertTrue(result["updated"])
324     def test_that_when_updating_a_function_fails_the_update_function_method_returns_error(
325         self,
326     ):
327         with patch.dict(
328             boto_lambda.__salt__,
329             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
330         ):
331             self.conn.update_function_configuration.side_effect = ClientError(
332                 error_content, "update_function"
333             )
334             result = boto_lambda.update_function_config(
335                 FunctionName="testfunction", Role="myrole", **conn_parameters
336             )
337         self.assertEqual(
338             result.get("error", {}).get("message"),
339             error_message.format("update_function"),
340         )
341     def test_that_when_updating_function_code_from_zipfile_succeeds_the_update_function_method_returns_true(
342         self,
343     ):
344         with patch.dict(
345             boto_lambda.__salt__,
346             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
347         ):
348             with TempZipFile() as zipfile:
349                 self.conn.update_function_code.return_value = function_ret
350                 result = boto_lambda.update_function_code(
351                     FunctionName=function_ret["FunctionName"],
352                     ZipFile=zipfile,
353                     **conn_parameters
354                 )
355         self.assertTrue(result["updated"])
356     def test_that_when_updating_function_code_from_s3_succeeds_the_update_function_method_returns_true(
357         self,
358     ):
359         with patch.dict(
360             boto_lambda.__salt__,
361             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
362         ):
363             self.conn.update_function_code.return_value = function_ret
364             result = boto_lambda.update_function_code(
365                 FunctionName="testfunction",
366                 S3Bucket="bucket",
367                 S3Key="key",
368                 **conn_parameters
369             )
370         self.assertTrue(result["updated"])
371     def test_that_when_updating_function_code_without_code_raises_a_salt_invocation_error(
372         self,
373     ):
374         with patch.dict(
375             boto_lambda.__salt__,
376             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
377         ):
378             with self.assertRaisesRegex(
379                 SaltInvocationError,
380                 "Either ZipFile must be specified, or S3Bucket "
381                 "and S3Key must be provided.",
382             ):
383                 result = boto_lambda.update_function_code(
384                     FunctionName="testfunction", **conn_parameters
385                 )
386     def test_that_when_updating_function_code_fails_the_update_function_method_returns_error(
387         self,
388     ):
389         with patch.dict(
390             boto_lambda.__salt__,
391             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
392         ):
393             self.conn.update_function_code.side_effect = ClientError(
394                 error_content, "update_function_code"
395             )
396             result = boto_lambda.update_function_code(
397                 FunctionName="testfunction",
398                 S3Bucket="bucket",
399                 S3Key="key",
400                 **conn_parameters
401             )
402         self.assertEqual(
403             result.get("error", {}).get("message"),
404             error_message.format("update_function_code"),
405         )
406     def test_that_when_listing_function_versions_succeeds_the_list_function_versions_method_returns_true(
407         self,
408     ):
409         with patch.dict(
410             boto_lambda.__salt__,
411             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
412         ):
413             self.conn.list_versions_by_function.return_value = {
414                 "Versions": [function_ret]
415             }
416             result = boto_lambda.list_function_versions(
417                 FunctionName="testfunction", **conn_parameters
418             )
419         self.assertTrue(result["Versions"])
420     def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_false(
421         self,
422     ):
423         with patch.dict(
424             boto_lambda.__salt__,
425             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
426         ):
427             self.conn.list_versions_by_function.return_value = {"Versions": []}
428             result = boto_lambda.list_function_versions(
429                 FunctionName="testfunction", **conn_parameters
430             )
431         self.assertFalse(result["Versions"])
432     def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_error(
433         self,
434     ):
435         with patch.dict(
436             boto_lambda.__salt__,
437             {"boto_iam.get_account_id": MagicMock(return_value="1234")},
438         ):
439             self.conn.list_versions_by_function.side_effect = ClientError(
440                 error_content, "list_versions_by_function"
441             )
442             result = boto_lambda.list_function_versions(
443                 FunctionName="testfunction", **conn_parameters
444             )
445         self.assertEqual(
446             result.get("error", {}).get("message"),
447             error_message.format("list_versions_by_function"),
448         )
449 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
450 @skipIf(
451     _has_required_boto() is False,
452     "The boto3 module must be greater than or equal to version {}".format(
453         required_boto3_version
454     ),
455 )
456 class BotoLambdaAliasTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
457     def test_that_when_creating_an_alias_succeeds_the_create_alias_method_returns_true(
458         self,
459     ):
460         self.conn.create_alias.return_value = alias_ret
461         result = boto_lambda.create_alias(
462             FunctionName="testfunction",
463             Name=alias_ret["Name"],
464             FunctionVersion=alias_ret["FunctionVersion"],
465             **conn_parameters
466         )
467         self.assertTrue(result["created"])
468     def test_that_when_creating_an_alias_fails_the_create_alias_method_returns_error(
469         self,
470     ):
471         self.conn.create_alias.side_effect = ClientError(error_content, "create_alias")
472         result = boto_lambda.create_alias(
473             FunctionName="testfunction",
474             Name=alias_ret["Name"],
475             FunctionVersion=alias_ret["FunctionVersion"],
476             **conn_parameters
477         )
478         self.assertEqual(
479             result.get("error", {}).get("message"), error_message.format("create_alias")
480         )
481     def test_that_when_deleting_an_alias_succeeds_the_delete_alias_method_returns_true(
482         self,
483     ):
484         result = boto_lambda.delete_alias(
485             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
486         )
487         self.assertTrue(result["deleted"])
488     def test_that_when_deleting_an_alias_fails_the_delete_alias_method_returns_false(
489         self,
490     ):
491         self.conn.delete_alias.side_effect = ClientError(error_content, "delete_alias")
492         result = boto_lambda.delete_alias(
493             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
494         )
495         self.assertFalse(result["deleted"])
496     def test_that_when_checking_if_an_alias_exists_and_the_alias_exists_the_alias_exists_method_returns_true(
497         self,
498     ):
499         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
500         result = boto_lambda.alias_exists(
501             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
502         )
503         self.assertTrue(result["exists"])
504     def test_that_when_checking_if_an_alias_exists_and_the_alias_does_not_exist_the_alias_exists_method_returns_false(
505         self,
506     ):
507         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
508         result = boto_lambda.alias_exists(
509             FunctionName="testfunction", Name="otheralias", **conn_parameters
510         )
511         self.assertFalse(result["exists"])
512     def test_that_when_checking_if_an_alias_exists_and_boto3_returns_an_error_the_alias_exists_method_returns_error(
513         self,
514     ):
515         self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
516         result = boto_lambda.alias_exists(
517             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
518         )
519         self.assertEqual(
520             result.get("error", {}).get("message"), error_message.format("list_aliases")
521         )
522     def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_true(
523         self,
524     ):
525         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
526         result = boto_lambda.describe_alias(
527             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
528         )
529         self.assertEqual(result, {"alias": alias_ret})
530     def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_false(
531         self,
532     ):
533         self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
534         result = boto_lambda.describe_alias(
535             FunctionName="testfunction", Name="othername", **conn_parameters
536         )
537         self.assertFalse(result["alias"])
538     def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
539         self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
540         result = boto_lambda.describe_alias(
541             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
542         )
543         self.assertTrue("error" in result)
544     def test_that_when_updating_an_alias_succeeds_the_update_alias_method_returns_true(
545         self,
546     ):
547         self.conn.update_alias.return_value = alias_ret
548         result = boto_lambda.update_alias(
549             FunctionName="testfunctoin",
550             Name=alias_ret["Name"],
551             Description=alias_ret["Description"],
552             **conn_parameters
553         )
554         self.assertTrue(result["updated"])
555     def test_that_when_updating_an_alias_fails_the_update_alias_method_returns_error(
556         self,
557     ):
558         self.conn.update_alias.side_effect = ClientError(error_content, "update_alias")
559         result = boto_lambda.update_alias(
560             FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
561         )
562         self.assertEqual(
563             result.get("error", {}).get("message"), error_message.format("update_alias")
564         )
565 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
566 @skipIf(
567     _has_required_boto() is False,
568     "The boto3 module must be greater than or equal to version {}".format(
569         required_boto3_version
570     ),
571 )
572 class BotoLambdaEventSourceMappingTestCase(
573     BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin
574 ):
575     def test_that_when_creating_a_mapping_succeeds_the_create_event_source_mapping_method_returns_true(
576         self,
577     ):
578         self.conn.create_event_source_mapping.return_value = event_source_mapping_ret
579         result = boto_lambda.create_event_source_mapping(
580             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
581             FunctionName=event_source_mapping_ret["FunctionArn"],
582             StartingPosition="LATEST",
583             **conn_parameters
584         )
585         self.assertTrue(result["created"])
586     def test_that_when_creating_an_event_source_mapping_fails_the_create_event_source_mapping_method_returns_error(
587         self,
588     ):
589         self.conn.create_event_source_mapping.side_effect = ClientError(
590             error_content, "create_event_source_mapping"
591         )
592         result = boto_lambda.create_event_source_mapping(
593             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
594             FunctionName=event_source_mapping_ret["FunctionArn"],
595             StartingPosition="LATEST",
596             **conn_parameters
597         )
598         self.assertEqual(
599             result.get("error", {}).get("message"),
600             error_message.format("create_event_source_mapping"),
601         )
602     def test_that_when_listing_mapping_ids_succeeds_the_get_event_source_mapping_ids_method_returns_true(
603         self,
604     ):
605         self.conn.list_event_source_mappings.return_value = {
606             "EventSourceMappings": [event_source_mapping_ret]
607         }
608         result = boto_lambda.get_event_source_mapping_ids(
609             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
610             FunctionName=event_source_mapping_ret["FunctionArn"],
611             **conn_parameters
612         )
613         self.assertTrue(result)
614     def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_versions_method_returns_false(
615         self,
616     ):
617         self.conn.list_event_source_mappings.return_value = {"EventSourceMappings": []}
618         result = boto_lambda.get_event_source_mapping_ids(
619             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
620             FunctionName=event_source_mapping_ret["FunctionArn"],
621             **conn_parameters
622         )
623         self.assertFalse(result)
624     def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_method_returns_error(
625         self,
626     ):
627         self.conn.list_event_source_mappings.side_effect = ClientError(
628             error_content, "list_event_source_mappings"
629         )
630         result = boto_lambda.get_event_source_mapping_ids(
631             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
632             FunctionName=event_source_mapping_ret["FunctionArn"],
633             **conn_parameters
634         )
635         self.assertEqual(
636             result.get("error", {}).get("message"),
637             error_message.format("list_event_source_mappings"),
638         )
639     def test_that_when_deleting_an_event_source_mapping_by_UUID_succeeds_the_delete_event_source_mapping_method_returns_true(
640         self,
641     ):
642         result = boto_lambda.delete_event_source_mapping(
643             UUID=event_source_mapping_ret["UUID"], **conn_parameters
644         )
645         self.assertTrue(result["deleted"])
646     @skipIf(True, "This appears to leak memory and crash the unit test suite")
647     def test_that_when_deleting_an_event_source_mapping_by_name_succeeds_the_delete_event_source_mapping_method_returns_true(
648         self,
649     ):
650         self.conn.list_event_source_mappings.return_value = {
651             "EventSourceMappings": [event_source_mapping_ret]
652         }
653         result = boto_lambda.delete_event_source_mapping(
654             EventSourceArn=event_source_mapping_ret["EventSourceArn"],
655             FunctionName=event_source_mapping_ret["FunctionArn"],
656             **conn_parameters
657         )
658         self.assertTrue(result["deleted"])
659     def test_that_when_deleting_an_event_source_mapping_without_identifier_the_delete_event_source_mapping_method_raises_saltinvocationexception(
660         self,
661     ):
662         with self.assertRaisesRegex(
663             SaltInvocationError,
664             "Either UUID must be specified, or EventSourceArn "
665             "and FunctionName must be provided.",
666         ):
667             result = boto_lambda.delete_event_source_mapping(**conn_parameters)
668     def test_that_when_deleting_an_event_source_mapping_fails_the_delete_event_source_mapping_method_returns_false(
669         self,
670     ):
671         self.conn.delete_event_source_mapping.side_effect = ClientError(
672             error_content, "delete_event_source_mapping"
673         )
674         result = boto_lambda.delete_event_source_mapping(
675             UUID=event_source_mapping_ret["UUID"], **conn_parameters
676         )
677         self.assertFalse(result["deleted"])
678     def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_exists_the_event_source_mapping_exists_method_returns_true(
679         self,
680     ):
681         self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
682         result = boto_lambda.event_source_mapping_exists(
683             UUID=event_source_mapping_ret["UUID"], **conn_parameters
684         )
685         self.assertTrue(result["exists"])
686     def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_does_not_exist_the_event_source_mapping_exists_method_returns_false(
687         self,
688     ):
689         self.conn.get_event_source_mapping.return_value = None
690         result = boto_lambda.event_source_mapping_exists(
691             UUID="other_UUID", **conn_parameters
692         )
693         self.assertFalse(result["exists"])
694     def test_that_when_checking_if_an_event_source_mapping_exists_and_boto3_returns_an_error_the_event_source_mapping_exists_method_returns_error(
695         self,
696     ):
697         self.conn.get_event_source_mapping.side_effect = ClientError(
698             error_content, "list_event_source_mappings"
699         )
700         result = boto_lambda.event_source_mapping_exists(
701             UUID=event_source_mapping_ret["UUID"], **conn_parameters
702         )
703         self.assertEqual(
704             result.get("error", {}).get("message"),
705             error_message.format("list_event_source_mappings"),
706         )
707     def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_true(
708         self,
709     ):
710         self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
711         result = boto_lambda.describe_event_source_mapping(
712             UUID=event_source_mapping_ret["UUID"], **conn_parameters
713         )
714         self.assertEqual(result, {"event_source_mapping": event_source_mapping_ret})
715     def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_false(
716         self,
717     ):
718         self.conn.get_event_source_mapping.return_value = None
719         result = boto_lambda.describe_event_source_mapping(
720             UUID=event_source_mapping_ret["UUID"], **conn_parameters
721         )
722         self.assertFalse(result["event_source_mapping"])
723     def test_that_when_describing_event_source_mapping_on_client_error_it_returns_error(
724         self,
725     ):
726         self.conn.get_event_source_mapping.side_effect = ClientError(
727             error_content, "get_event_source_mapping"
728         )
729         result = boto_lambda.describe_event_source_mapping(
730             UUID=event_source_mapping_ret["UUID"], **conn_parameters
731         )
732         self.assertTrue("error" in result)
733     def test_that_when_updating_an_event_source_mapping_succeeds_the_update_event_source_mapping_method_returns_true(
734         self,
735     ):
736         self.conn.update_event_source_mapping.return_value = event_source_mapping_ret
737         result = boto_lambda.update_event_source_mapping(
738             UUID=event_source_mapping_ret["UUID"],
739             FunctionName=event_source_mapping_ret["FunctionArn"],
740             **conn_parameters
741         )
742         self.assertTrue(result["updated"])
743     def test_that_when_updating_an_event_source_mapping_fails_the_update_event_source_mapping_method_returns_error(
744         self,
745     ):
746         self.conn.update_event_source_mapping.side_effect = ClientError(
747             error_content, "update_event_source_mapping"
748         )
749         result = boto_lambda.update_event_source_mapping(
750             UUID=event_source_mapping_ret["UUID"],
751             FunctionName=event_source_mapping_ret["FunctionArn"],
752             **conn_parameters
753         )
754         self.assertEqual(
755             result.get("error", {}).get("message"),
756             error_message.format("update_event_source_mapping"),
757         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
