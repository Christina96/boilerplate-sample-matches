<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for chroot.py &amp; test_boto_lambda_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for chroot.py &amp; test_boto_lambda_1.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>chroot.py (2.7777777%)<th>test_boto_lambda_1.py (1.0230179%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(1-13)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>chroot.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
:maintainer:    Alberto Planas &lt;aplanas@suse.com&gt;
:maturity:      new
:depends:       None
"""
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import os
import sys
import tempfile
import salt
import salt.client.ssh.state
import salt.client.ssh.wrapper.state
import salt.defaults.exitcodes
import salt.exceptions
import salt.utils.args
import</b></font> salt.utils.files
__func_alias__ = {"apply_": "apply"}
log = logging.getLogger(__name__)
def __virtual__():
    """
    Chroot command is required.
    """
    if __utils__["path.which"]("chroot") is not None:
        return True
    else:
        return (False, "Module chroot requires the command chroot")
def exist(root):
    """
    Return True if the chroot environment is present.
    root
        Path to the chroot environment
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.exist /chroot
    """
    dev = os.path.join(root, "dev")
    proc = os.path.join(root, "proc")
    sys = os.path.join(root, "sys")
    return all(os.path.isdir(i) for i in (root, dev, proc, sys))
def create(root):
    """
    Create a basic chroot environment.
    Note that this environment is not functional. The caller needs to
    install the minimal required binaries, including Python if
    chroot.call is called.
    root
        Path to the chroot environment
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.create /chroot
    """
    if not exist(root):
        dev = os.path.join(root, "dev")
        proc = os.path.join(root, "proc")
        sys = os.path.join(root, "sys")
        try:
            os.makedirs(dev, mode=0o755)
            os.makedirs(proc, mode=0o555)
            os.makedirs(sys, mode=0o555)
        except OSError as e:
            log.error("Error when trying to create chroot directories: %s", e)
            return False
    return True
def in_chroot():
    """
    Return True if the process is inside a chroot jail
    .. versionadded:: 3004
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.in_chroot
    """
    result = False
    try:
        with salt.utils.files.fopen(
            "/proc/1/mountinfo"
        ) as root_fd, salt.utils.files.fopen("/proc/self/mountinfo") as self_fd:
            root_mountinfo = root_fd.read()
            self_mountinfo = self_fd.read()
        result = root_mountinfo != self_mountinfo
    except OSError:
        pass
    return result
def call(root, function, *args, **kwargs):
    """
    Executes a Salt function inside a chroot environment.
    The chroot does not need to have Salt installed, but Python is
    required.
    root
        Path to the chroot environment
    function
        Salt execution module function
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.call /chroot test.ping
        salt myminion chroot.call /chroot ssh.set_auth_key user key=mykey
    """
    if not function:
        raise salt.exceptions.CommandExecutionError("Missing function parameter")
    if not exist(root):
        raise salt.exceptions.CommandExecutionError("Chroot environment not found")
    thin_dest_path = tempfile.mkdtemp(dir=root)
    thin_path = __utils__["thin.gen_thin"](
        __opts__["cachedir"],
        extra_mods=__salt__["config.option"]("thin_extra_mods", ""),
        so_mods=__salt__["config.option"]("thin_so_mods", ""),
    )
    stdout = __salt__["cmd.run"](["tar", "xzf", thin_path, "-C", thin_dest_path])
    if stdout:
        __utils__["files.rm_rf"](thin_dest_path)
        return {"result": False, "comment": stdout}
    chroot_path = os.path.join(os.path.sep, os.path.relpath(thin_dest_path, root))
    try:
        safe_kwargs = salt.utils.args.clean_kwargs(**kwargs)
        salt_argv = (
            [
                "python{}".format(sys.version_info[0]),
                os.path.join(chroot_path, "salt-call"),
                "--metadata",
                "--local",
                "--log-file",
                os.path.join(chroot_path, "log"),
                "--cachedir",
                os.path.join(chroot_path, "cache"),
                "--out",
                "json",
                "-l",
                "quiet",
                "--",
                function,
            ]
            + list(args)
            + ["{}={}".format(k, v) for (k, v) in safe_kwargs.items()]
        )
        ret = __salt__["cmd.run_chroot"](root, [str(x) for x in salt_argv])
        try:
            data = __utils__["json.find_json"](ret["stdout"])
            local = data.get("local", data)
            if isinstance(local, dict) and "retcode" in local:
                __context__["retcode"] = local["retcode"]
            return local.get("return", data)
        except ValueError:
            return {
                "result": False,
                "retcode": ret["retcode"],
                "comment": {"stdout": ret["stdout"], "stderr": ret["stderr"]},
            }
    finally:
        __utils__["files.rm_rf"](thin_dest_path)
def apply_(root, mods=None, **kwargs):
    """
    Apply an state inside a chroot.
    This function will call `chroot.highstate` or `chroot.sls` based
    on the arguments passed to this function. It exists as a more
    intuitive way of applying states.
    root
        Path to the chroot environment
    For a formal description of the possible parameters accepted in
    this function, check `state.apply_` documentation.
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.apply /chroot
        salt myminion chroot.apply /chroot stuff
        salt myminion chroot.apply /chroot stuff pillar='{"foo": "bar"}'
    """
    if mods:
        return sls(root, mods, **kwargs)
    return highstate(root, **kwargs)
def _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type):
    """
    Create the salt_state tarball, and execute in the chroot
    """
    salt.client.ssh.wrapper.state._cleanup_slsmod_low_data(chunks)
    trans_tar = salt.client.ssh.state.prep_trans_tar(
        salt.fileclient.get_file_client(__opts__),
        chunks,
        file_refs,
        __pillar__.value(),
        root,
    )
    trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, hash_type)
    ret = None
    salt_state_path = tempfile.mkdtemp(dir=root)
    salt_state_path = os.path.join(salt_state_path, "salt_state.tgz")
    salt_state_path_in_chroot = salt_state_path.replace(root, "", 1)
    try:
        salt.utils.files.copyfile(trans_tar, salt_state_path)
        ret = call(
            root,
            "state.pkg",
            salt_state_path_in_chroot,
            test=test,
            pkg_sum=trans_tar_sum,
            hash_type=hash_type,
        )
    finally:
        __utils__["files.rm_rf"](salt_state_path)
    return ret
def sls(root, mods, saltenv="base", test=None, exclude=None, **kwargs):
    """
    Execute the states in one or more SLS files inside the chroot.
    root
        Path to the chroot environment
    saltenv
        Specify a salt fileserver environment to be used when applying
        states
    mods
        List of states to execute
    test
        Run states in test-only (dry-run) mode
    exclude
        Exclude specific states from execution. Accepts a list of sls
        names, a comma-separated string of sls names, or a list of
        dictionaries containing ``sls`` or ``id`` keys. Glob-patterns
        may be used to match multiple states.
    For a formal description of the possible parameters accepted in
    this function, check `state.sls` documentation.
    CLI Example:
    .. code-block:: bash
        salt '*' chroot.sls /chroot stuff pillar='{"foo": "bar"}'
    """
    pillar = copy.deepcopy(__pillar__.value())
    pillar.update(kwargs.get("pillar", {}))
    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
    st_ = salt.client.ssh.state.SSHHighState(
        opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
    )
    if isinstance(mods, str):
        mods = mods.split(",")
    high_data, errors = st_.render_highstate({saltenv: mods})
    if exclude:
        if isinstance(exclude, str):
            exclude = exclude.split(",")
        if "__exclude__" in high_data:
            high_data["__exclude__"].extend(exclude)
        else:
            high_data["__exclude__"] = exclude
    high_data, ext_errors = st_.state.reconcile_extend(high_data)
    errors += ext_errors
    errors += st_.state.verify_high(high_data)
    if errors:
        return errors
    high_data, req_in_errors = st_.state.requisite_in(high_data)
    errors += req_in_errors
    if errors:
        return errors
    high_data = st_.state.apply_exclude(high_data)
    chunks = st_.state.compile_high_data(high_data)
    file_refs = salt.client.ssh.state.lowstate_file_refs(
        chunks,
        salt.client.ssh.wrapper.state._merge_extra_filerefs(
            kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
        ),
    )
    hash_type = opts["hash_type"]
    return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
def highstate(root, **kwargs):
    """
    Retrieve the state data from the salt master for this minion and
    execute it inside the chroot.
    root
        Path to the chroot environment
    For a formal description of the possible parameters accepted in
    this function, check `state.highstate` documentation.
    CLI Example:
    .. code-block:: bash
        salt myminion chroot.highstate /chroot
        salt myminion chroot.highstate /chroot pillar='{"foo": "bar"}'
    """
    pillar = copy.deepcopy(__pillar__.value())
    pillar.update(kwargs.get("pillar", {}))
    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
    with salt.client.ssh.state.SSHHighState(
        opts, pillar, __salt__, salt.fileclient.get_file_client(__opts__)
    ) as st_:
        chunks = st_.compile_low_chunks()
        file_refs = salt.client.ssh.state.lowstate_file_refs(
            chunks,
            salt.client.ssh.wrapper.state._merge_extra_filerefs(
                kwargs.get("extra_filerefs", ""), opts.get("extra_filerefs", "")
            ),
        )
        for chunk in chunks:
            if not isinstance(chunk, dict):
                __context__["retcode"] = 1
                return chunks
        test = kwargs.pop("test", False)
        hash_type = opts["hash_type"]
        return _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_lambda_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import random
import string
from tempfile import NamedTemporaryFile
import salt.config
import salt.loader
import salt.modules.boto_lambda as boto_lambda
import salt.utils.stringutils
from salt.exceptions import SaltInvocationError
from salt.utils.versions import LooseVersion
from</b></font> tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf
try:
    import boto3
    from botocore.exceptions import ClientError
    from botocore import __version__ as found_botocore_version
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
required_boto3_version = "1.2.1"
required_botocore_version = "1.5.2"
region = "us-east-1"
access_key = "GKTADJGHEIQSXMKKRBJ08H"
secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
conn_parameters = {
    "region": region,
    "key": access_key,
    "keyid": secret_key,
    "profile": {},
}
error_message = (
    "An error occurred (101) when calling the {0} operation: Test-defined error"
)
error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
function_ret = dict(
    FunctionName="testfunction",
    Runtime="python2.7",
    Role=None,
    Handler="handler",
    Description="abcdefg",
    Timeout=5,
    MemorySize=128,
    CodeSha256="abcdef",
    CodeSize=199,
    FunctionArn="arn:lambda:us-east-1:1234:Something",
    LastModified="yes",
    VpcConfig=None,
    Environment=None,
)
alias_ret = dict(
    AliasArn="arn:lambda:us-east-1:1234:Something",
    Name="testalias",
    FunctionVersion="3",
    Description="Alias description",
)
event_source_mapping_ret = dict(
    UUID="1234-1-123",
    BatchSize=123,
    EventSourceArn="arn:lambda:us-east-1:1234:Something",
    FunctionArn="arn:lambda:us-east-1:1234:Something",
    LastModified="yes",
    LastProcessingResult="SUCCESS",
    State="Enabled",
    StateTransitionReason="Random",
)
log = logging.getLogger(__name__)
def _has_required_boto():
    """
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    """
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    elif LooseVersion(found_botocore_version) &lt; LooseVersion(required_botocore_version):
        return False
    else:
        return True
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}, "
    "and botocore must be greater than or equal to {}".format(
        required_boto3_version, required_botocore_version
    ),
)
class BotoLambdaTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None
    def setup_loader_modules(self):
        self.opts = opts = salt.config.DEFAULT_MINION_OPTS.copy()
        utils = salt.loader.utils(
            opts, whitelist=["boto3", "args", "systemd", "path", "platform"], context={}
        )
        return {boto_lambda: {"__utils__": utils}}
    def setUp(self):
        super().setUp()
        boto_lambda.__init__(self.opts)
        del self.opts
        conn_parameters["key"] = "".join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )
        self.patcher = patch("boto3.session.Session")
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, "patcher")
        mock_session = self.patcher.start()
        session_instance = mock_session.return_value
        self.conn = MagicMock()
        session_instance.client.return_value = self.conn
        self.addCleanup(delattr, self, "conn")
class TempZipFile:
    def __enter__(self):
        with NamedTemporaryFile(
            suffix=".zip", prefix="salt_test_", delete=False
        ) as tmp:
            to_write = "###\n"
            to_write = salt.utils.stringutils.to_bytes(to_write)
            tmp.write(to_write)
            self.zipfile = tmp.name
        return self.zipfile
    def __exit__(self, type, value, traceback):
        os.remove(self.zipfile)
class BotoLambdaTestCaseMixin:
    pass
class BotoLambdaFunctionTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
    """
    TestCase for salt.modules.boto_lambda module
    """
    def test_that_when_checking_if_a_function_exists_and_a_function_exists_the_function_exists_method_returns_true(
        self,
    ):
        """
        Tests checking lambda function existence when the lambda function already exists
        """
        self.conn.list_functions.return_value = {"Functions": [function_ret]}
        func_exists_result = boto_lambda.function_exists(
            FunctionName=function_ret["FunctionName"], **conn_parameters
        )
        self.assertTrue(func_exists_result["exists"])
    def test_that_when_checking_if_a_function_exists_and_a_function_does_not_exist_the_function_exists_method_returns_false(
        self,
    ):
        """
        Tests checking lambda function existence when the lambda function does not exist
        """
        self.conn.list_functions.return_value = {"Functions": [function_ret]}
        func_exists_result = boto_lambda.function_exists(
            FunctionName="myfunc", **conn_parameters
        )
        self.assertFalse(func_exists_result["exists"])
    def test_that_when_checking_if_a_function_exists_and_boto3_returns_an_error_the_function_exists_method_returns_error(
        self,
    ):
        """
        Tests checking lambda function existence when boto returns an error
        """
        self.conn.list_functions.side_effect = ClientError(
            error_content, "list_functions"
        )
        func_exists_result = boto_lambda.function_exists(
            FunctionName="myfunc", **conn_parameters
        )
        self.assertEqual(
            func_exists_result.get("error", {}).get("message"),
            error_message.format("list_functions"),
        )
    def test_that_when_creating_a_function_from_zipfile_succeeds_the_create_function_method_returns_true(
        self,
    ):
        """
        tests True function created.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            with TempZipFile() as zipfile:
                self.conn.create_function.return_value = function_ret
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName="testfunction",
                    Runtime="python2.7",
                    Role="myrole",
                    Handler="file.method",
                    ZipFile=zipfile,
                    **conn_parameters
                )
        self.assertTrue(lambda_creation_result["created"])
    def test_that_when_creating_a_function_from_s3_succeeds_the_create_function_method_returns_true(
        self,
    ):
        """
        tests True function created.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.create_function.return_value = function_ret
            lambda_creation_result = boto_lambda.create_function(
                FunctionName="testfunction",
                Runtime="python2.7",
                Role="myrole",
                Handler="file.method",
                S3Bucket="bucket",
                S3Key="key",
                **conn_parameters
            )
        self.assertTrue(lambda_creation_result["created"])
    def test_that_when_creating_a_function_without_code_raises_a_salt_invocation_error(
        self,
    ):
        """
        tests Creating a function without code
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                "Either ZipFile must be specified, or S3Bucket and S3Key must be"
                " provided.",
            ):
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName="testfunction",
                    Runtime="python2.7",
                    Role="myrole",
                    Handler="file.method",
                    **conn_parameters
                )
    def test_that_when_creating_a_function_with_zipfile_and_s3_raises_a_salt_invocation_error(
        self,
    ):
        """
        tests Creating a function without code
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                "Either ZipFile must be specified, or S3Bucket and S3Key must be"
                " provided.",
            ):
                with TempZipFile() as zipfile:
                    lambda_creation_result = boto_lambda.create_function(
                        FunctionName="testfunction",
                        Runtime="python2.7",
                        Role="myrole",
                        Handler="file.method",
                        ZipFile=zipfile,
                        S3Bucket="bucket",
                        S3Key="key",
                        **conn_parameters
                    )
    def test_that_when_creating_a_function_fails_the_create_function_method_returns_error(
        self,
    ):
        """
        tests False function not created.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.create_function.side_effect = ClientError(
                error_content, "create_function"
            )
            with TempZipFile() as zipfile:
                lambda_creation_result = boto_lambda.create_function(
                    FunctionName="testfunction",
                    Runtime="python2.7",
                    Role="myrole",
                    Handler="file.method",
                    ZipFile=zipfile,
                    **conn_parameters
                )
        self.assertEqual(
            lambda_creation_result.get("error", {}).get("message"),
            error_message.format("create_function"),
        )
    def test_that_when_deleting_a_function_succeeds_the_delete_function_method_returns_true(
        self,
    ):
        """
        tests True function deleted.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            result = boto_lambda.delete_function(
                FunctionName="testfunction", Qualifier=1, **conn_parameters
            )
        self.assertTrue(result["deleted"])
    def test_that_when_deleting_a_function_fails_the_delete_function_method_returns_false(
        self,
    ):
        """
        tests False function not deleted.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.delete_function.side_effect = ClientError(
                error_content, "delete_function"
            )
            result = boto_lambda.delete_function(
                FunctionName="testfunction", **conn_parameters
            )
        self.assertFalse(result["deleted"])
    def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        """
        Tests describing parameters if function exists
        """
        self.conn.list_functions.return_value = {"Functions": [function_ret]}
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            result = boto_lambda.describe_function(
                FunctionName=function_ret["FunctionName"], **conn_parameters
            )
        self.assertEqual(result, {"function": function_ret})
    def test_that_when_describing_function_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        """
        Tests describing parameters if function does not exist
        """
        self.conn.list_functions.return_value = {"Functions": []}
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            result = boto_lambda.describe_function(
                FunctionName="testfunction", **conn_parameters
            )
        self.assertFalse(result["function"])
    def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
        """
        Tests describing parameters failure
        """
        self.conn.list_functions.side_effect = ClientError(
            error_content, "list_functions"
        )
        result = boto_lambda.describe_function(
            FunctionName="testfunction", **conn_parameters
        )
        self.assertTrue("error" in result)
    def test_that_when_updating_a_function_succeeds_the_update_function_method_returns_true(
        self,
    ):
        """
        tests True function updated.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.update_function_config.return_value = function_ret
            result = boto_lambda.update_function_config(
                FunctionName=function_ret["FunctionName"],
                Role="myrole",
                **conn_parameters
            )
        self.assertTrue(result["updated"])
    def test_that_when_updating_a_function_fails_the_update_function_method_returns_error(
        self,
    ):
        """
        tests False function not updated.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.update_function_configuration.side_effect = ClientError(
                error_content, "update_function"
            )
            result = boto_lambda.update_function_config(
                FunctionName="testfunction", Role="myrole", **conn_parameters
            )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("update_function"),
        )
    def test_that_when_updating_function_code_from_zipfile_succeeds_the_update_function_method_returns_true(
        self,
    ):
        """
        tests True function updated.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            with TempZipFile() as zipfile:
                self.conn.update_function_code.return_value = function_ret
                result = boto_lambda.update_function_code(
                    FunctionName=function_ret["FunctionName"],
                    ZipFile=zipfile,
                    **conn_parameters
                )
        self.assertTrue(result["updated"])
    def test_that_when_updating_function_code_from_s3_succeeds_the_update_function_method_returns_true(
        self,
    ):
        """
        tests True function updated.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.update_function_code.return_value = function_ret
            result = boto_lambda.update_function_code(
                FunctionName="testfunction",
                S3Bucket="bucket",
                S3Key="key",
                **conn_parameters
            )
        self.assertTrue(result["updated"])
    def test_that_when_updating_function_code_without_code_raises_a_salt_invocation_error(
        self,
    ):
        """
        tests Creating a function without code
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            with self.assertRaisesRegex(
                SaltInvocationError,
                "Either ZipFile must be specified, or S3Bucket "
                "and S3Key must be provided.",
            ):
                result = boto_lambda.update_function_code(
                    FunctionName="testfunction", **conn_parameters
                )
    def test_that_when_updating_function_code_fails_the_update_function_method_returns_error(
        self,
    ):
        """
        tests False function not updated.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.update_function_code.side_effect = ClientError(
                error_content, "update_function_code"
            )
            result = boto_lambda.update_function_code(
                FunctionName="testfunction",
                S3Bucket="bucket",
                S3Key="key",
                **conn_parameters
            )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("update_function_code"),
        )
    def test_that_when_listing_function_versions_succeeds_the_list_function_versions_method_returns_true(
        self,
    ):
        """
        tests True function versions listed.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.list_versions_by_function.return_value = {
                "Versions": [function_ret]
            }
            result = boto_lambda.list_function_versions(
                FunctionName="testfunction", **conn_parameters
            )
        self.assertTrue(result["Versions"])
    def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_false(
        self,
    ):
        """
        tests False no function versions listed.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.list_versions_by_function.return_value = {"Versions": []}
            result = boto_lambda.list_function_versions(
                FunctionName="testfunction", **conn_parameters
            )
        self.assertFalse(result["Versions"])
    def test_that_when_listing_function_versions_fails_the_list_function_versions_method_returns_error(
        self,
    ):
        """
        tests False function versions error.
        """
        with patch.dict(
            boto_lambda.__salt__,
            {"boto_iam.get_account_id": MagicMock(return_value="1234")},
        ):
            self.conn.list_versions_by_function.side_effect = ClientError(
                error_content, "list_versions_by_function"
            )
            result = boto_lambda.list_function_versions(
                FunctionName="testfunction", **conn_parameters
            )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("list_versions_by_function"),
        )
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
class BotoLambdaAliasTestCase(BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin):
    """
    TestCase for salt.modules.boto_lambda module aliases
    """
    def test_that_when_creating_an_alias_succeeds_the_create_alias_method_returns_true(
        self,
    ):
        """
        tests True alias created.
        """
        self.conn.create_alias.return_value = alias_ret
        result = boto_lambda.create_alias(
            FunctionName="testfunction",
            Name=alias_ret["Name"],
            FunctionVersion=alias_ret["FunctionVersion"],
            **conn_parameters
        )
        self.assertTrue(result["created"])
    def test_that_when_creating_an_alias_fails_the_create_alias_method_returns_error(
        self,
    ):
        """
        tests False alias not created.
        """
        self.conn.create_alias.side_effect = ClientError(error_content, "create_alias")
        result = boto_lambda.create_alias(
            FunctionName="testfunction",
            Name=alias_ret["Name"],
            FunctionVersion=alias_ret["FunctionVersion"],
            **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"), error_message.format("create_alias")
        )
    def test_that_when_deleting_an_alias_succeeds_the_delete_alias_method_returns_true(
        self,
    ):
        """
        tests True alias deleted.
        """
        result = boto_lambda.delete_alias(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertTrue(result["deleted"])
    def test_that_when_deleting_an_alias_fails_the_delete_alias_method_returns_false(
        self,
    ):
        """
        tests False alias not deleted.
        """
        self.conn.delete_alias.side_effect = ClientError(error_content, "delete_alias")
        result = boto_lambda.delete_alias(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertFalse(result["deleted"])
    def test_that_when_checking_if_an_alias_exists_and_the_alias_exists_the_alias_exists_method_returns_true(
        self,
    ):
        """
        Tests checking lambda alias existence when the lambda alias already exists
        """
        self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
        result = boto_lambda.alias_exists(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertTrue(result["exists"])
    def test_that_when_checking_if_an_alias_exists_and_the_alias_does_not_exist_the_alias_exists_method_returns_false(
        self,
    ):
        """
        Tests checking lambda alias existence when the lambda alias does not exist
        """
        self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
        result = boto_lambda.alias_exists(
            FunctionName="testfunction", Name="otheralias", **conn_parameters
        )
        self.assertFalse(result["exists"])
    def test_that_when_checking_if_an_alias_exists_and_boto3_returns_an_error_the_alias_exists_method_returns_error(
        self,
    ):
        """
        Tests checking lambda alias existence when boto returns an error
        """
        self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
        result = boto_lambda.alias_exists(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"), error_message.format("list_aliases")
        )
    def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        """
        Tests describing parameters if alias exists
        """
        self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
        result = boto_lambda.describe_alias(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertEqual(result, {"alias": alias_ret})
    def test_that_when_describing_alias_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        """
        Tests describing parameters if alias does not exist
        """
        self.conn.list_aliases.return_value = {"Aliases": [alias_ret]}
        result = boto_lambda.describe_alias(
            FunctionName="testfunction", Name="othername", **conn_parameters
        )
        self.assertFalse(result["alias"])
    def test_that_when_describing_lambda_on_client_error_it_returns_error(self):
        """
        Tests describing parameters failure
        """
        self.conn.list_aliases.side_effect = ClientError(error_content, "list_aliases")
        result = boto_lambda.describe_alias(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertTrue("error" in result)
    def test_that_when_updating_an_alias_succeeds_the_update_alias_method_returns_true(
        self,
    ):
        """
        tests True alias updated.
        """
        self.conn.update_alias.return_value = alias_ret
        result = boto_lambda.update_alias(
            FunctionName="testfunctoin",
            Name=alias_ret["Name"],
            Description=alias_ret["Description"],
            **conn_parameters
        )
        self.assertTrue(result["updated"])
    def test_that_when_updating_an_alias_fails_the_update_alias_method_returns_error(
        self,
    ):
        """
        tests False alias not updated.
        """
        self.conn.update_alias.side_effect = ClientError(error_content, "update_alias")
        result = boto_lambda.update_alias(
            FunctionName="testfunction", Name=alias_ret["Name"], **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"), error_message.format("update_alias")
        )
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
class BotoLambdaEventSourceMappingTestCase(
    BotoLambdaTestCaseBase, BotoLambdaTestCaseMixin
):
    """
    TestCase for salt.modules.boto_lambda module mappings
    """
    def test_that_when_creating_a_mapping_succeeds_the_create_event_source_mapping_method_returns_true(
        self,
    ):
        """
        tests True mapping created.
        """
        self.conn.create_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.create_event_source_mapping(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            StartingPosition="LATEST",
            **conn_parameters
        )
        self.assertTrue(result["created"])
    def test_that_when_creating_an_event_source_mapping_fails_the_create_event_source_mapping_method_returns_error(
        self,
    ):
        """
        tests False mapping not created.
        """
        self.conn.create_event_source_mapping.side_effect = ClientError(
            error_content, "create_event_source_mapping"
        )
        result = boto_lambda.create_event_source_mapping(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            StartingPosition="LATEST",
            **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("create_event_source_mapping"),
        )
    def test_that_when_listing_mapping_ids_succeeds_the_get_event_source_mapping_ids_method_returns_true(
        self,
    ):
        """
        tests True mapping ids listed.
        """
        self.conn.list_event_source_mappings.return_value = {
            "EventSourceMappings": [event_source_mapping_ret]
        }
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertTrue(result)
    def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_versions_method_returns_false(
        self,
    ):
        """
        tests False no mapping ids listed.
        """
        self.conn.list_event_source_mappings.return_value = {"EventSourceMappings": []}
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertFalse(result)
    def test_that_when_listing_event_source_mapping_ids_fails_the_get_event_source_mapping_ids_method_returns_error(
        self,
    ):
        """
        tests False mapping ids error.
        """
        self.conn.list_event_source_mappings.side_effect = ClientError(
            error_content, "list_event_source_mappings"
        )
        result = boto_lambda.get_event_source_mapping_ids(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("list_event_source_mappings"),
        )
    def test_that_when_deleting_an_event_source_mapping_by_UUID_succeeds_the_delete_event_source_mapping_method_returns_true(
        self,
    ):
        """
        tests True mapping deleted.
        """
        result = boto_lambda.delete_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertTrue(result["deleted"])
    @skipIf(True, "This appears to leak memory and crash the unit test suite")
    def test_that_when_deleting_an_event_source_mapping_by_name_succeeds_the_delete_event_source_mapping_method_returns_true(
        self,
    ):
        """
        tests True mapping deleted.
        """
        self.conn.list_event_source_mappings.return_value = {
            "EventSourceMappings": [event_source_mapping_ret]
        }
        result = boto_lambda.delete_event_source_mapping(
            EventSourceArn=event_source_mapping_ret["EventSourceArn"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertTrue(result["deleted"])
    def test_that_when_deleting_an_event_source_mapping_without_identifier_the_delete_event_source_mapping_method_raises_saltinvocationexception(
        self,
    ):
        """
        tests Deleting a mapping without identifier
        """
        with self.assertRaisesRegex(
            SaltInvocationError,
            "Either UUID must be specified, or EventSourceArn "
            "and FunctionName must be provided.",
        ):
            result = boto_lambda.delete_event_source_mapping(**conn_parameters)
    def test_that_when_deleting_an_event_source_mapping_fails_the_delete_event_source_mapping_method_returns_false(
        self,
    ):
        """
        tests False mapping not deleted.
        """
        self.conn.delete_event_source_mapping.side_effect = ClientError(
            error_content, "delete_event_source_mapping"
        )
        result = boto_lambda.delete_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertFalse(result["deleted"])
    def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_exists_the_event_source_mapping_exists_method_returns_true(
        self,
    ):
        """
        Tests checking lambda event_source_mapping existence when the lambda
        event_source_mapping already exists
        """
        self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.event_source_mapping_exists(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertTrue(result["exists"])
    def test_that_when_checking_if_an_event_source_mapping_exists_and_the_event_source_mapping_does_not_exist_the_event_source_mapping_exists_method_returns_false(
        self,
    ):
        """
        Tests checking lambda event_source_mapping existence when the lambda
        event_source_mapping does not exist
        """
        self.conn.get_event_source_mapping.return_value = None
        result = boto_lambda.event_source_mapping_exists(
            UUID="other_UUID", **conn_parameters
        )
        self.assertFalse(result["exists"])
    def test_that_when_checking_if_an_event_source_mapping_exists_and_boto3_returns_an_error_the_event_source_mapping_exists_method_returns_error(
        self,
    ):
        """
        Tests checking lambda event_source_mapping existence when boto returns an error
        """
        self.conn.get_event_source_mapping.side_effect = ClientError(
            error_content, "list_event_source_mappings"
        )
        result = boto_lambda.event_source_mapping_exists(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("list_event_source_mappings"),
        )
    def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        """
        Tests describing parameters if event_source_mapping exists
        """
        self.conn.get_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertEqual(result, {"event_source_mapping": event_source_mapping_ret})
    def test_that_when_describing_event_source_mapping_it_returns_the_dict_of_properties_returns_false(
        self,
    ):
        """
        Tests describing parameters if event_source_mapping does not exist
        """
        self.conn.get_event_source_mapping.return_value = None
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertFalse(result["event_source_mapping"])
    def test_that_when_describing_event_source_mapping_on_client_error_it_returns_error(
        self,
    ):
        """
        Tests describing parameters failure
        """
        self.conn.get_event_source_mapping.side_effect = ClientError(
            error_content, "get_event_source_mapping"
        )
        result = boto_lambda.describe_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"], **conn_parameters
        )
        self.assertTrue("error" in result)
    def test_that_when_updating_an_event_source_mapping_succeeds_the_update_event_source_mapping_method_returns_true(
        self,
    ):
        """
        tests True event_source_mapping updated.
        """
        self.conn.update_event_source_mapping.return_value = event_source_mapping_ret
        result = boto_lambda.update_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertTrue(result["updated"])
    def test_that_when_updating_an_event_source_mapping_fails_the_update_event_source_mapping_method_returns_error(
        self,
    ):
        """
        tests False event_source_mapping not updated.
        """
        self.conn.update_event_source_mapping.side_effect = ClientError(
            error_content, "update_event_source_mapping"
        )
        result = boto_lambda.update_event_source_mapping(
            UUID=event_source_mapping_ret["UUID"],
            FunctionName=event_source_mapping_ret["FunctionArn"],
            **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("update_event_source_mapping"),
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
