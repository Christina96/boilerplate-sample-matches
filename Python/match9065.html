<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_sudoku.py &amp; test_isomorphvf2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_sudoku.py &amp; test_isomorphvf2.py
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_sudoku.py (23.076923%)<th>test_isomorphvf2.py (1.7167382%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-22)<td><a href="#" name="0">(356-359)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_sudoku.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 def test_sudoku_negative():
4     pytest.raises(nx.NetworkXError, nx.sudoku_graph, n=-1)
5 @pytest.mark.parametrize("n", [0, 1, 2, 3, 4])
6 def test_sudoku_generator(n):
7     G = nx.sudoku_graph(n)
8 <a name="0"></a>    expected_nodes = n ** 4
9     expected_degree = (n - 1) * (3 * n + 1)
10     expected_edges = expected_nodes * expected_degree // 2
11     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>assert not G.is_directed()
12     assert not G.is_multigraph()
13     assert G.number_of_nodes() == expected_nodes
14     assert G.number_of_edges(</b></font>) == expected_edges
15     assert all(d == expected_degree for _, d in G.degree)
16     if n == 2:
17         assert sorted(G.neighbors(6)) == [2, 3, 4, 5, 7, 10, 14]
18     elif n == 3:
19         assert sorted(G.neighbors(42)) == [
20             6,
21             15,
22             24,
23             33,
24             34,
25             35,
26             36,
27             37,
28             38,
29             39,
30             40,
31             41,
32             43,
33             44,
34             51,
35             52,
36             53,
37             60,
38             69,
39             78,
40         ]
41     elif n == 4:
42         assert sorted(G.neighbors(0)) == [
43             1,
44             2,
45             3,
46             4,
47             5,
48             6,
49             7,
50             8,
51             9,
52             10,
53             11,
54             12,
55             13,
56             14,
57             15,
58             16,
59             17,
60             18,
61             19,
62             32,
63             33,
64             34,
65             35,
66             48,
67             49,
68             50,
69             51,
70             64,
71             80,
72             96,
73             112,
74             128,
75             144,
76             160,
77             176,
78             192,
79             208,
80             224,
81             240,
82         ]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_isomorphvf2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import struct
3 import random
4 import networkx as nx
5 from networkx.algorithms import isomorphism as iso
6 class TestWikipediaExample:
7     g1edges = [
8         ["a", "g"],
9         ["a", "h"],
10         ["a", "i"],
11         ["b", "g"],
12         ["b", "h"],
13         ["b", "j"],
14         ["c", "g"],
15         ["c", "i"],
16         ["c", "j"],
17         ["d", "h"],
18         ["d", "i"],
19         ["d", "j"],
20     ]
21     g2edges = [
22         [1, 2],
23         [2, 3],
24         [3, 4],
25         [4, 1],
26         [5, 6],
27         [6, 7],
28         [7, 8],
29         [8, 5],
30         [1, 5],
31         [2, 6],
32         [3, 7],
33         [4, 8],
34     ]
35     def test_graph(self):
36         g1 = nx.Graph()
37         g2 = nx.Graph()
38         g1.add_edges_from(self.g1edges)
39         g2.add_edges_from(self.g2edges)
40         gm = iso.GraphMatcher(g1, g2)
41         assert gm.is_isomorphic()
42         assert gm.subgraph_is_monomorphic()
43         mapping = sorted(gm.mapping.items())
44     def test_subgraph(self):
45         g1 = nx.Graph()
46         g2 = nx.Graph()
47         g1.add_edges_from(self.g1edges)
48         g2.add_edges_from(self.g2edges)
49         g3 = g2.subgraph([1, 2, 3, 4])
50         gm = iso.GraphMatcher(g1, g3)
51         assert gm.subgraph_is_isomorphic()
52     def test_subgraph_mono(self):
53         g1 = nx.Graph()
54         g2 = nx.Graph()
55         g1.add_edges_from(self.g1edges)
56         g2.add_edges_from([[1, 2], [2, 3], [3, 4]])
57         gm = iso.GraphMatcher(g1, g2)
58         assert gm.subgraph_is_monomorphic()
59 class TestVF2GraphDB:
60     @staticmethod
61     def create_graph(filename):
62         fh = open(filename, mode="rb")
63         nodes = struct.unpack("&lt;H", fh.read(2))[0]
64         graph = nx.Graph()
65         for from_node in range(nodes):
66             edges = struct.unpack("&lt;H", fh.read(2))[0]
67             for edge in range(edges):
68                 to_node = struct.unpack("&lt;H", fh.read(2))[0]
69                 graph.add_edge(from_node, to_node)
70         fh.close()
71         return graph
72     def test_graph(self):
73         head, tail = os.path.split(__file__)
74         g1 = self.create_graph(os.path.join(head, "iso_r01_s80.A99"))
75         g2 = self.create_graph(os.path.join(head, "iso_r01_s80.B99"))
76         gm = iso.GraphMatcher(g1, g2)
77         assert gm.is_isomorphic()
78     def test_subgraph(self):
79         head, tail = os.path.split(__file__)
80         subgraph = self.create_graph(os.path.join(head, "si2_b06_m200.A99"))
81         graph = self.create_graph(os.path.join(head, "si2_b06_m200.B99"))
82         gm = iso.GraphMatcher(graph, subgraph)
83         assert gm.subgraph_is_isomorphic()
84         assert gm.subgraph_is_monomorphic()
85 class TestAtlas:
86     @classmethod
87     def setup_class(cls):
88         global atlas
89         import networkx.generators.atlas as atlas
90         cls.GAG = atlas.graph_atlas_g()
91     def test_graph_atlas(self):
92         Atlas = self.GAG[0:100]
93         alphabet = list(range(26))
94         for graph in Atlas:
95             nlist = list(graph)
96             labels = alphabet[: len(nlist)]
97             for s in range(10):
98                 random.shuffle(labels)
99                 d = dict(zip(nlist, labels))
100                 relabel = nx.relabel_nodes(graph, d)
101                 gm = iso.GraphMatcher(graph, relabel)
102                 assert gm.is_isomorphic()
103 def test_multiedge():
104     edges = [
105         (0, 1),
106         (1, 2),
107         (2, 3),
108         (3, 4),
109         (4, 5),
110         (5, 6),
111         (6, 7),
112         (7, 8),
113         (8, 9),
114         (9, 10),
115         (10, 11),
116         (10, 11),
117         (11, 12),
118         (11, 12),
119         (12, 13),
120         (12, 13),
121         (13, 14),
122         (13, 14),
123         (14, 15),
124         (14, 15),
125         (15, 16),
126         (15, 16),
127         (16, 17),
128         (16, 17),
129         (17, 18),
130         (17, 18),
131         (18, 19),
132         (18, 19),
133         (19, 0),
134         (19, 0),
135     ]
136     nodes = list(range(20))
137     for g1 in [nx.MultiGraph(), nx.MultiDiGraph()]:
138         g1.add_edges_from(edges)
139         for _ in range(10):
140             new_nodes = list(nodes)
141             random.shuffle(new_nodes)
142             d = dict(zip(nodes, new_nodes))
143             g2 = nx.relabel_nodes(g1, d)
144             if not g1.is_directed():
145                 gm = iso.GraphMatcher(g1, g2)
146             else:
147                 gm = iso.DiGraphMatcher(g1, g2)
148             assert gm.is_isomorphic()
149             assert gm.subgraph_is_monomorphic()
150 def test_selfloop():
151     edges = [
152         (0, 1),
153         (0, 2),
154         (1, 2),
155         (1, 3),
156         (2, 2),
157         (2, 4),
158         (3, 1),
159         (3, 2),
160         (4, 2),
161         (4, 5),
162         (5, 4),
163     ]
164     nodes = list(range(6))
165     for g1 in [nx.Graph(), nx.DiGraph()]:
166         g1.add_edges_from(edges)
167         for _ in range(100):
168             new_nodes = list(nodes)
169             random.shuffle(new_nodes)
170             d = dict(zip(nodes, new_nodes))
171             g2 = nx.relabel_nodes(g1, d)
172             if not g1.is_directed():
173                 gm = iso.GraphMatcher(g1, g2)
174             else:
175                 gm = iso.DiGraphMatcher(g1, g2)
176             assert gm.is_isomorphic()
177 def test_selfloop_mono():
178     edges0 = [
179         (0, 1),
180         (0, 2),
181         (1, 2),
182         (1, 3),
183         (2, 4),
184         (3, 1),
185         (3, 2),
186         (4, 2),
187         (4, 5),
188         (5, 4),
189     ]
190     edges = edges0 + [(2, 2)]
191     nodes = list(range(6))
192     for g1 in [nx.Graph(), nx.DiGraph()]:
193         g1.add_edges_from(edges)
194         for _ in range(100):
195             new_nodes = list(nodes)
196             random.shuffle(new_nodes)
197             d = dict(zip(nodes, new_nodes))
198             g2 = nx.relabel_nodes(g1, d)
199             g2.remove_edges_from(nx.selfloop_edges(g2))
200             if not g1.is_directed():
201                 gm = iso.GraphMatcher(g2, g1)
202             else:
203                 gm = iso.DiGraphMatcher(g2, g1)
204             assert not gm.subgraph_is_monomorphic()
205 def test_isomorphism_iter1():
206     g1 = nx.DiGraph()
207     g2 = nx.DiGraph()
208     g3 = nx.DiGraph()
209     g1.add_edge("A", "B")
210     g1.add_edge("B", "C")
211     g2.add_edge("Y", "Z")
212     g3.add_edge("Z", "Y")
213     gm12 = iso.DiGraphMatcher(g1, g2)
214     gm13 = iso.DiGraphMatcher(g1, g3)
215     x = list(gm12.subgraph_isomorphisms_iter())
216     y = list(gm13.subgraph_isomorphisms_iter())
217     assert {"A": "Y", "B": "Z"} in x
218     assert {"B": "Y", "C": "Z"} in x
219     assert {"A": "Z", "B": "Y"} in y
220     assert {"B": "Z", "C": "Y"} in y
221     assert len(x) == len(y)
222     assert len(x) == 2
223 def test_monomorphism_iter1():
224     g1 = nx.DiGraph()
225     g2 = nx.DiGraph()
226     g1.add_edge("A", "B")
227     g1.add_edge("B", "C")
228     g1.add_edge("C", "A")
229     g2.add_edge("X", "Y")
230     g2.add_edge("Y", "Z")
231     gm12 = iso.DiGraphMatcher(g1, g2)
232     x = list(gm12.subgraph_monomorphisms_iter())
233     assert {"A": "X", "B": "Y", "C": "Z"} in x
234     assert {"A": "Y", "B": "Z", "C": "X"} in x
235     assert {"A": "Z", "B": "X", "C": "Y"} in x
236     assert len(x) == 3
237     gm21 = iso.DiGraphMatcher(g2, g1)
238     assert not gm21.subgraph_is_monomorphic()
239 def test_isomorphism_iter2():
240     for L in range(2, 10):
241         g1 = nx.path_graph(L)
242         gm = iso.GraphMatcher(g1, g1)
243         s = len(list(gm.isomorphisms_iter()))
244         assert s == 2
245     for L in range(3, 10):
246         g1 = nx.cycle_graph(L)
247         gm = iso.GraphMatcher(g1, g1)
248         s = len(list(gm.isomorphisms_iter()))
249         assert s == 2 * L
250 def test_multiple():
251     edges = [("A", "B"), ("B", "A"), ("B", "C")]
252     for g1, g2 in [(nx.Graph(), nx.Graph()), (nx.DiGraph(), nx.DiGraph())]:
253         g1.add_edges_from(edges)
254         g2.add_edges_from(edges)
255         g3 = nx.subgraph(g2, ["A", "B"])
256         if not g1.is_directed():
257             gmA = iso.GraphMatcher(g1, g2)
258             gmB = iso.GraphMatcher(g1, g3)
259         else:
260             gmA = iso.DiGraphMatcher(g1, g2)
261             gmB = iso.DiGraphMatcher(g1, g3)
262         assert gmA.is_isomorphic()
263         g2.remove_node("C")
264         if not g1.is_directed():
265 <a name="0"></a>            gmA = iso.GraphMatcher(g1, g2)
266         else:
267             gmA = iso.DiGraphMatcher(g1, g2)
268         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>assert gmA.subgraph_is_isomorphic()
269         assert gmB.subgraph_is_isomorphic()
270         assert gmA.subgraph_is_monomorphic()
271         assert gmB.subgraph_is_monomorphic(</b></font>)
272 def test_noncomparable_nodes():
273     node1 = object()
274     node2 = object()
275     node3 = object()
276     G = nx.path_graph([node1, node2, node3])
277     gm = iso.GraphMatcher(G, G)
278     assert gm.is_isomorphic()
279     assert gm.subgraph_is_monomorphic()
280     G = nx.path_graph([node1, node2, node3], create_using=nx.DiGraph)
281     H = nx.path_graph([node3, node2, node1], create_using=nx.DiGraph)
282     dgm = iso.DiGraphMatcher(G, H)
283     assert dgm.is_isomorphic()
284     assert gm.subgraph_is_monomorphic()
285 def test_monomorphism_edge_match():
286     G = nx.DiGraph()
287     G.add_node(1)
288     G.add_node(2)
289     G.add_edge(1, 2, label="A")
290     G.add_edge(2, 1, label="B")
291     G.add_edge(2, 2, label="C")
292     SG = nx.DiGraph()
293     SG.add_node(5)
294     SG.add_node(6)
295     SG.add_edge(5, 6, label="A")
296     gm = iso.DiGraphMatcher(G, SG, edge_match=iso.categorical_edge_match("label", None))
297     assert gm.subgraph_is_monomorphic()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
