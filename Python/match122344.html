<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___57.py &amp; templates.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___57.py &amp; templates.py
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___57.py (1.8250134%)<th>templates.py (6.621227%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-35)<td><a href="#" name="0">(4-29)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1898-1902)<td><a href="#" name="1">(163-171)</a><td align="center"><font color="#990000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(163-168)<td><a href="#" name="2">(565-572)</a><td align="center"><font color="#990000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2062-2065)<td><a href="#" name="3">(383-385)</a><td align="center"><font color="#840000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___57.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import glob
3 import logging
4 import multiprocessing
5 import os
6 import signal
7 import time
8 import traceback
9 from itertools import groupby
10 import salt.client
11 import salt.config
12 import salt.loader
13 import salt.syspaths
14 import salt.utils.args
15 import salt.utils.cloud
16 import salt.utils.context
17 import salt.utils.crypt
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.user
22 import salt.utils.verify
23 import salt.utils.yaml
24 from salt.exceptions import (
25     SaltCloudConfigError,
26     SaltCloudException,
27     SaltCloudNotFound,
28     SaltCloudSystemExit,
29 )
30 from</b></font> salt.template import compile_template
31 try:
32     import Cryptodome.Random
33 except ImportError:
34     try:
35         import Crypto.Random  # nosec
36     except ImportError:
37         pass  # pycrypto &lt; 2.1
38 log = logging.getLogger(__name__)
39 def communicator(func):
40     def _call(queue, args, kwargs):
41         kwargs["queue"] = queue
42         ret = None
43         try:
44             ret = func(*args, **kwargs)
45             queue.put("END")
46         except KeyboardInterrupt as ex:
47             trace = traceback.format_exc()
48             queue.put("KEYBOARDINT")
49             queue.put("Keyboard interrupt")
50             queue.put("{}\n{}\n".format(ex, trace))
51         except Exception as ex:  # pylint: disable=broad-except
52             trace = traceback.format_exc()
53             queue.put("ERROR")
54             queue.put("Exception")
55             queue.put("{}\n{}\n".format(ex, trace))
56         except SystemExit as ex:
57             trace = traceback.format_exc()
58             queue.put("ERROR")
59             queue.put("System exit")
60             queue.put("{}\n{}\n".format(ex, trace))
61         return ret
62     return _call
63 def enter_mainloop(
64     target,
65     mapped_args=None,
66     args=None,
67     kwargs=None,
68     pool=None,
69     pool_size=None,
70     callback=None,
71     queue=None,
72 ):
73     if not kwargs:
74         kwargs = {}
75     if not pool_size:
76         pool_size = 1
77     if not pool:
78         pool = multiprocessing.Pool(pool_size)
79     if not queue:
80         manager = multiprocessing.Manager()
81         queue = manager.Queue()
82     if mapped_args is not None and not mapped_args:
83         msg = (
84             "We are called to asynchronously execute {}"
85             " but we do no have anything to execute, weird,"
86             " we bail out".format(target)
87         )
88         log.error(msg)
89         raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
90     elif mapped_args is not None:
91         iterable = [[queue, [arg], kwargs] for arg in mapped_args]
92         ret = pool.map(func=target, iterable=iterable)
93     else:
94         ret = pool.apply(target, [queue, args, kwargs])
95     while True:
96         test = queue.get()
97             type_ = queue.get()
98             trace = queue.get()
99             msg = "Caught {}, terminating workers\n"<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(type_)
100             msg += "TRACE: {}\n".format(trace)
101             log.error(msg)
102             pool.terminate()
103             pool.join()
104             raise SaltCloudSystemExit("Exception caught\n{}".format(</b></font>msg))
105         elif test in ["END"] or (callback and callback(test)):
106             pool.close()
107             pool.join()
108             break
109         else:
110             time.sleep(0.125)
111     return ret
112 class CloudClient:
113     def __init__(self, path=None, opts=None, config_dir=None, pillars=None):
114         if opts:
115             self.opts = opts
116         else:
117             self.opts = salt.config.cloud_config(path)
118         v_dirs = [self.opts["cachedir"]]
119         salt.utils.verify.verify_env(v_dirs, salt.utils.user.get_user())
120         if pillars:
121             for name, provider in pillars.pop("providers", {}).items():
122                 driver = provider["driver"]
123                 provider["profiles"] = {}
124                 self.opts["providers"].update({name: {driver: provider}})
125             for name, profile in pillars.pop("profiles", {}).items():
126                 provider = profile["provider"].split(":")[0]
127                 driver = next(iter(self.opts["providers"][provider].keys()))
128                 profile["provider"] = "{}:{}".format(provider, driver)
129                 profile["profile"] = name
130                 self.opts["profiles"].update({name: profile})
131                 self.opts["providers"][provider][driver]["profiles"].update(
132                     {name: profile}
133                 )
134             for name, map_dct in pillars.pop("maps", {}).items():
135                 if "maps" not in self.opts:
136                     self.opts["maps"] = {}
137                 self.opts["maps"][name] = map_dct
138             self.opts.update(pillars)
139     def _opts_defaults(self, **kwargs):
140         opts = salt.config.DEFAULT_CLOUD_OPTS.copy()
141         opts.update(self.opts.copy())
142         opts["parallel"] = False
143         opts["keep_tmp"] = False
144         opts["deploy"] = True
145         opts["update_bootstrap"] = False
146         opts["show_deploy_args"] = False
147         opts["script_args"] = ""
148         if "kwargs" in kwargs:
149             opts.update(kwargs["kwargs"])
150         opts.update(kwargs)
151         profile = opts.get("profile", None)
152         if profile:
153             tmp_profiles = opts.get("profiles", {}).copy()
154             for _profile in [a for a in tmp_profiles]:
155                 if not _profile == profile:
156                     tmp_profiles.pop(_profile)
157             providers = [
158                 a.get("provider", "").split(":")[0]
159                 for a in tmp_profiles.values()
160                 if a.get("provider", "")
161             ]
162             if providers:
163                 _providers = opts.get("providers", {})
164                 for provider in _providers.copy():
165                     if provider not in providers:
166                         _providers.pop(provider)
167         return opts
168     def low(self, fun, low):
169         l_fun = getattr(self, fun)
170         f_call = salt.utils.args.format_call(l_fun, low)
171         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
172     def list_sizes(self, provider=None):
173         mapper = salt.cloud.Map(self._opts_defaults())
174         return salt.utils.data.simple_types_filter(mapper.size_list(provider))
175     def list_images(self, provider=None):
176         mapper = salt.cloud.Map(self._opts_defaults())
177         return salt.utils.data.simple_types_filter(mapper.image_list(provider))
178     def list_locations(self, provider=None):
179         mapper = salt.cloud.Map(self._opts_defaults())
180         return salt.utils.data.simple_types_filter(mapper.location_list(provider))
181     def query(self, query_type="list_nodes"):
182         mapper = salt.cloud.Map(self._opts_defaults())
183         mapper.opts["selected_query_option"] = "list_nodes"
184         return mapper.map_providers_parallel(query_type)
185     def full_query(self, query_type="list_nodes_full"):
186         mapper = salt.cloud.Map(self._opts_defaults())
187         mapper.opts["selected_query_option"] = "list_nodes_full"
188         return mapper.map_providers_parallel(query_type)
189     def select_query(self, query_type="list_nodes_select"):
190         mapper = salt.cloud.Map(self._opts_defaults())
191         mapper.opts["selected_query_option"] = "list_nodes_select"
192         return mapper.map_providers_parallel(query_type)
193     def min_query(self, query_type="list_nodes_min"):
194         mapper = salt.cloud.Map(self._opts_defaults())
195         mapper.opts["selected_query_option"] = "list_nodes_min"
196         return mapper.map_providers_parallel(query_type)
197     def profile(self, profile, names, vm_overrides=None, **kwargs):
198         if not vm_overrides:
199             vm_overrides = {}
200         kwargs["profile"] = profile
201         mapper = salt.cloud.Map(self._opts_defaults(**kwargs))
202         if isinstance(names, str):
203             names = names.split(",")
204         return salt.utils.data.simple_types_filter(
205             mapper.run_profile(profile, names, vm_overrides=vm_overrides)
206         )
207     def map_run(self, path=None, **kwargs):
208         kwarg = {}
209         if path:
210             kwarg["map"] = path
211         kwarg.update(kwargs)
212         mapper = salt.cloud.Map(self._opts_defaults(**kwarg))
213         dmap = mapper.map_data()
214         return salt.utils.data.simple_types_filter(mapper.run_map(dmap))
215     def destroy(self, names):
216         mapper = salt.cloud.Map(self._opts_defaults(destroy=True))
217         if isinstance(names, str):
218             names = names.split(",")
219         return salt.utils.data.simple_types_filter(mapper.destroy(names))
220     def create(self, provider, names, **kwargs):
221         mapper = salt.cloud.Map(self._opts_defaults())
222         providers = self.opts["providers"]
223         if provider in providers:
224             provider += ":{}".format(next(iter(providers[provider].keys())))
225         else:
226             return False
227         if isinstance(names, str):
228             names = names.split(",")
229         ret = {}
230         for name in names:
231             vm_ = kwargs.copy()
232             vm_["name"] = name
233             vm_["driver"] = provider
234             vm_["profile"] = None
235             vm_["provider"] = provider
236             ret[name] = salt.utils.data.simple_types_filter(mapper.create(vm_))
237         return ret
238     def extra_action(self, names, provider, action, **kwargs):
239         mapper = salt.cloud.Map(self._opts_defaults())
240         providers = mapper.map_providers_parallel()
241         if provider in providers:
242             provider += ":{}".format(next(iter(providers[provider].keys())))
243         else:
244             return False
245         if isinstance(names, str):
246             names = names.split(",")
247         ret = {}
248         for name in names:
249             extra_ = kwargs.copy()
250             extra_["name"] = name
251             extra_["provider"] = provider
252             extra_["profile"] = None
253             extra_["action"] = action
254             ret[name] = salt.utils.data.simple_types_filter(mapper.extras(extra_))
255         return ret
256     def action(
257         self,
258         fun=None,
259         cloudmap=None,
260         names=None,
261         provider=None,
262         instance=None,
263         kwargs=None,
264     ):
265         if kwargs is None:
266             kwargs = {}
267         mapper = salt.cloud.Map(self._opts_defaults(action=fun, names=names, **kwargs))
268         if instance:
269             if names:
270                 raise SaltCloudConfigError(
271                     "Please specify either a list of 'names' or a single "
272                     "'instance', but not both."
273                 )
274             names = [instance]
275         if names and not provider:
276             self.opts["action"] = fun
277             return mapper.do_action(names, kwargs)
278         if provider and not names:
279             return mapper.do_function(provider, fun, kwargs)
280         else:
281             raise SaltCloudConfigError(
282                 "Either an instance (or list of names) or a provider must be "
283                 "specified, but not both."
284             )
285 class Cloud:
286     def __init__(self, opts):
287         self.opts = opts
288         self.clouds = salt.loader.clouds(self.opts)
289         self.__filter_non_working_providers()
290         self.__cached_provider_queries = {}
291     def get_configured_providers(self):
292         providers = set()
293         for alias, drivers in self.opts["providers"].items():
294             if len(drivers) &gt; 1:
295                 for driver in drivers:
296                     providers.add("{}:{}".format(alias, driver))
297                 continue
298             providers.add(alias)
299         return providers
300     def lookup_providers(self, lookup):
301         if lookup is None:
302             lookup = "all"
303         if lookup == "all":
304             providers = set()
305             for alias, drivers in self.opts["providers"].items():
306                 for driver in drivers:
307                     providers.add((alias, driver))
308             if not providers:
309                 raise SaltCloudSystemExit("There are no cloud providers configured.")
310             return providers
311         if ":" in lookup:
312             alias, driver = lookup.split(":")
313             if (
314                 alias not in self.opts["providers"]
315                 or driver not in self.opts["providers"][alias]
316             ):
317                 raise SaltCloudSystemExit(
318                     "No cloud providers matched '{}'. Available: {}".format(
319                         lookup, ", ".join(self.get_configured_providers())
320                     )
321                 )
322         providers = set()
323         for alias, drivers in self.opts["providers"].items():
324             for driver in drivers:
325                 if lookup in (alias, driver):
326                     providers.add((alias, driver))
327         if not providers:
328             raise SaltCloudSystemExit(
329                 "No cloud providers matched '{}'. Available selections: {}".format(
330                     lookup, ", ".join(self.get_configured_providers())
331                 )
332             )
333         return providers
334     def lookup_profiles(self, provider, lookup):
335         if provider is None:
336             provider = "all"
337         if lookup is None:
338             lookup = "all"
339         if lookup == "all":
340             profiles = set()
341             provider_profiles = set()
342             for alias, info in self.opts["profiles"].items():
343                 providers = info.get("provider")
344                 if providers:
345                     given_prov_name = providers.split(":")[0]
346                     salt_prov_name = providers.split(":")[1]
347                     if given_prov_name == provider:
348                         provider_profiles.add((alias, given_prov_name))
349                     elif salt_prov_name == provider:
350                         provider_profiles.add((alias, salt_prov_name))
351                     profiles.add((alias, given_prov_name))
352             if not profiles:
353                 raise SaltCloudSystemExit("There are no cloud profiles configured.")
354             if provider != "all":
355                 return provider_profiles
356             return profiles
357     def map_providers(self, query="list_nodes", cached=False):
358         if cached is True and query in self.__cached_provider_queries:
359             return self.__cached_provider_queries[query]
360         pmap = {}
361         for alias, drivers in self.opts["providers"].items():
362             for driver, details in drivers.items():
363                 fun = "{}.{}".format(driver, query)
364                 if fun not in self.clouds:
365                     log.error("Public cloud provider %s is not available", driver)
366                     continue
367                 if alias not in pmap:
368                     pmap[alias] = {}
369                 try:
370                     with salt.utils.context.func_globals_inject(
371                         self.clouds[fun],
372                         __active_provider_name__=":".join([alias, driver]),
373                     ):
374                         pmap[alias][driver] = self.clouds[fun]()
375                 except Exception as err:  # pylint: disable=broad-except
376                     log.debug(
377                         "Failed to execute '%s()' while querying for running nodes: %s",
378                         fun,
379                         err,
380                         exc_info_on_loglevel=logging.DEBUG,
381                     )
382                     pmap[alias][driver] = []
383         self.__cached_provider_queries[query] = pmap
384         return pmap
385     def map_providers_parallel(self, query="list_nodes", cached=False):
386         if cached is True and query in self.__cached_provider_queries:
387             return self.__cached_provider_queries[query]
388         opts = self.opts.copy()
389         multiprocessing_data = []
390         opts["providers"] = self._optimize_providers(opts["providers"])
391         for alias, drivers in opts["providers"].items():
392             this_query = query
393             for driver, details in drivers.items():
394                 if (
395                     opts.get("selected_query_option") is None
396                     and "{}.list_nodes_min".format(driver) in self.clouds
397                 ):
398                     this_query = "list_nodes_min"
399                 fun = "{}.{}".format(driver, this_query)
400                 if fun not in self.clouds:
401                     log.error("Public cloud provider %s is not available", driver)
402                     continue
403                 multiprocessing_data.append(
404                     {
405                         "fun": fun,
406                         "opts": opts,
407                         "query": this_query,
408                         "alias": alias,
409                         "driver": driver,
410                     }
411                 )
412         output = {}
413         if not multiprocessing_data:
414             return output
415         data_count = len(multiprocessing_data)
416         pool = multiprocessing.Pool(
417             data_count &lt; 10 and data_count or 10, init_pool_worker
418         )
419         parallel_pmap = enter_mainloop(
420             _run_parallel_map_providers_query, multiprocessing_data, pool=pool
421         )
422         for alias, driver, details in parallel_pmap:
423             if not details:
424                 continue
425             if alias not in output:
426                 output[alias] = {}
427             output[alias][driver] = details
428         self.__cached_provider_queries[query] = output
429         return output
430     def get_running_by_names(
431         self, names, query="list_nodes", cached=False, profile=None
432     ):
433         if isinstance(names, str):
434             names = [names]
435         matches = {}
436         handled_drivers = {}
437         mapped_providers = self.map_providers_parallel(query, cached=cached)
438         for alias, drivers in mapped_providers.items():
439             for driver, vms in drivers.items():
440                 if driver not in handled_drivers:
441                     handled_drivers[driver] = alias
442                 if (
443                     profile
444                     and alias
445                     not in self.opts["profiles"][profile]["provider"].split(":")[0]
446                 ):
447                     continue
448                 for vm_name, details in vms.items():
449                     if vm_name not in names:
450                         continue
451                     elif (
452                         driver == "ec2"
453                         and "aws" in handled_drivers
454                         and "aws" in matches[handled_drivers["aws"]]
455                         and vm_name in matches[handled_drivers["aws"]]["aws"]
456                     ):
457                         continue
458                     elif (
459                         driver == "aws"
460                         and "ec2" in handled_drivers
461                         and "ec2" in matches[handled_drivers["ec2"]]
462                         and vm_name in matches[handled_drivers["ec2"]]["ec2"]
463                     ):
464                         continue
465                     if alias not in matches:
466                         matches[alias] = {}
467                     if driver not in matches[alias]:
468                         matches[alias][driver] = {}
469                     matches[alias][driver][vm_name] = details
470         return matches
471     def _optimize_providers(self, providers):
472         new_providers = {}
473         provider_by_driver = {}
474         for alias, driver in providers.items():
475             for name, data in driver.items():
476                 if name not in provider_by_driver:
477                     provider_by_driver[name] = {}
478                 provider_by_driver[name][alias] = data
479         for driver, providers_data in provider_by_driver.items():
480             fun = "{}.optimize_providers".format(driver)
481             if fun not in self.clouds:
482                 log.debug("The '%s' cloud driver is unable to be optimized.", driver)
483                 for name, prov_data in providers_data.items():
484                     if name not in new_providers:
485                         new_providers[name] = {}
486                     new_providers[name][driver] = prov_data
487                 continue
488             new_data = self.clouds[fun](providers_data)
489             if new_data:
490                 for name, prov_data in new_data.items():
491                     if name not in new_providers:
492                         new_providers[name] = {}
493                     new_providers[name][driver] = prov_data
494         return new_providers
495     def location_list(self, lookup="all"):
496         data = {}
497         lookups = self.lookup_providers(lookup)
498         if not lookups:
499             return data
500         for alias, driver in lookups:
501             fun = "{}.avail_locations".format(driver)
502             if fun not in self.clouds:
503                 log.debug(
504                     "The '%s' cloud driver defined under '%s' provider "
505                     "alias is unable to get the locations information",
506                     driver,
507                     alias,
508                 )
509                 continue
510             if alias not in data:
511                 data[alias] = {}
512             try:
513                 with salt.utils.context.func_globals_inject(
514                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
515                 ):
516                     data[alias][driver] = self.clouds[fun]()
517             except Exception as err:  # pylint: disable=broad-except
518                 log.error(
519                     "Failed to get the output of '%s()': %s",
520                     fun,
521                     err,
522                     exc_info_on_loglevel=logging.DEBUG,
523                 )
524         return data
525     def image_list(self, lookup="all"):
526         data = {}
527         lookups = self.lookup_providers(lookup)
528         if not lookups:
529             return data
530         for alias, driver in lookups:
531             fun = "{}.avail_images".format(driver)
532             if fun not in self.clouds:
533                 log.debug(
534                     "The '%s' cloud driver defined under '%s' provider "
535                     "alias is unable to get the images information",
536                     driver,
537                     alias,
538                 )
539                 continue
540             if alias not in data:
541                 data[alias] = {}
542             try:
543                 with salt.utils.context.func_globals_inject(
544                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
545                 ):
546                     data[alias][driver] = self.clouds[fun]()
547             except Exception as err:  # pylint: disable=broad-except
548                 log.error(
549                     "Failed to get the output of '%s()': %s",
550                     fun,
551                     err,
552                     exc_info_on_loglevel=logging.DEBUG,
553                 )
554         return data
555     def size_list(self, lookup="all"):
556         data = {}
557         lookups = self.lookup_providers(lookup)
558         if not lookups:
559             return data
560         for alias, driver in lookups:
561             fun = "{}.avail_sizes".format(driver)
562             if fun not in self.clouds:
563                 log.debug(
564                     "The '%s' cloud driver defined under '%s' provider "
565                     "alias is unable to get the sizes information",
566                     driver,
567                     alias,
568                 )
569                 continue
570             if alias not in data:
571                 data[alias] = {}
572             try:
573                 with salt.utils.context.func_globals_inject(
574                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
575                 ):
576                     data[alias][driver] = self.clouds[fun]()
577             except Exception as err:  # pylint: disable=broad-except
578                 log.error(
579                     "Failed to get the output of '%s()': %s",
580                     fun,
581                     err,
582                     exc_info_on_loglevel=logging.DEBUG,
583                 )
584         return data
585     def provider_list(self, lookup="all"):
586         data = {}
587         lookups = self.lookup_providers(lookup)
588         if not lookups:
589             return data
590         for alias, driver in lookups:
591             if alias not in data:
592                 data[alias] = {}
593             if driver not in data[alias]:
594                 data[alias][driver] = {}
595         return data
596     def profile_list(self, provider, lookup="all"):
597         data = {}
598         lookups = self.lookup_profiles(provider, lookup)
599         if not lookups:
600             return data
601         for alias, driver in lookups:
602             if alias not in data:
603                 data[alias] = {}
604             if driver not in data[alias]:
605                 data[alias][driver] = {}
606         return data
607     def create_all(self):
608         ret = []
609         for vm_name, vm_details in self.opts["profiles"].items():
610             ret.append({vm_name: self.create(vm_details)})
611         return ret
612     def destroy(self, names, cached=False):
613         processed = {}
614         names = set(names)
615         matching = self.get_running_by_names(names, cached=cached)
616         vms_to_destroy = set()
617         parallel_data = []
618         for alias, drivers in matching.items():
619             for driver, vms in drivers.items():
620                 for name in vms:
621                     if name in names:
622                         vms_to_destroy.add((alias, driver, name))
623                         if self.opts["parallel"]:
624                             parallel_data.append(
625                                 {
626                                     "opts": self.opts,
627                                     "name": name,
628                                     "alias": alias,
629                                     "driver": driver,
630                                 }
631                             )
632         if self.opts["parallel"] and parallel_data:
633             if "pool_size" in self.opts:
634                 pool_size = self.opts["pool_size"]
635             else:
636                 pool_size = len(parallel_data)
637             log.info("Destroying in parallel mode; Cloud pool size: %s", pool_size)
638             output_multip = enter_mainloop(
639                 _destroy_multiprocessing, parallel_data, pool_size=pool_size
640             )
641             ret_multip = {}
642             for obj in output_multip:
643                 ret_multip.update(obj)
644             for obj in parallel_data:
645                 alias = obj["alias"]
646                 driver = obj["driver"]
647                 name = obj["name"]
648                 if alias not in processed:
649                     processed[alias] = {}
650                 if driver not in processed[alias]:
651                     processed[alias][driver] = {}
652                 processed[alias][driver][name] = ret_multip[name]
653                 if name in names:
654                     names.remove(name)
655         else:
656             log.info("Destroying in non-parallel mode.")
657             for alias, driver, name in vms_to_destroy:
658                 fun = "{}.destroy".format(driver)
659                 with salt.utils.context.func_globals_inject(
660                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
661                 ):
662                     ret = self.clouds[fun](name)
663                 if alias not in processed:
664                     processed[alias] = {}
665                 if driver not in processed[alias]:
666                     processed[alias][driver] = {}
667                 processed[alias][driver][name] = ret
668                 if name in names:
669                     names.remove(name)
670         for alias, driver, name in vms_to_destroy:
671             ret = processed[alias][driver][name]
672             if not ret:
673                 continue
674             vm_ = {
675                 "name": name,
676                 "profile": None,
677                 "provider": ":".join([alias, driver]),
678                 "driver": driver,
679             }
680             minion_dict = salt.config.get_cloud_config_value(
681                 "minion", vm_, self.opts, default={}
682             )
683             key_file = os.path.join(
684                 self.opts["pki_dir"], "minions", minion_dict.get("id", name)
685             )
686             globbed_key_file = glob.glob("{}.*".format(key_file))
687             if not os.path.isfile(key_file) and not globbed_key_file:
688                 if isinstance(ret, dict) and "newname" in ret:
689                     salt.utils.cloud.remove_key(self.opts["pki_dir"], ret["newname"])
690                 continue
691             if os.path.isfile(key_file) and not globbed_key_file:
692                 salt.utils.cloud.remove_key(
693                     self.opts["pki_dir"], os.path.basename(key_file)
694                 )
695                 continue
696             if (
697                 not os.path.isfile(key_file)
698                 and globbed_key_file
699                 and len(globbed_key_file) == 1
700             ):
701                 salt.utils.cloud.remove_key(
702                     self.opts["pki_dir"], os.path.basename(globbed_key_file[0])
703                 )
704                 continue
705             print(
706                 "There are several minion keys who's name starts "
707                 "with '{}'. We need to ask you which one should be "
708                 "deleted:".format(name)
709             )
710             while True:
711                 for idx, filename in enumerate(globbed_key_file):
712                     print(" {}: {}".format(idx, os.path.basename(filename)))
713                 selection = input("Which minion key should be deleted(number)? ")
714                 try:
715                     selection = int(selection)
716                 except ValueError:
717                     print("'{}' is not a valid selection.".format(selection))
718                 try:
719                     filename = os.path.basename(globbed_key_file.pop(selection))
720                 except Exception:  # pylint: disable=broad-except
721                     continue
722                 delete = input("Delete '{}'? [Y/n]? ".format(filename))
723                 if delete == "" or delete.lower().startswith("y"):
724                     salt.utils.cloud.remove_key(self.opts["pki_dir"], filename)
725                     print("Deleted '{}'".format(filename))
726                     break
727                 print("Did not delete '{}'".format(filename))
728                 break
729         if names and not processed:
730             raise SaltCloudSystemExit(
731                 "The following VM's were not found: {}".format(", ".join(names))
732             )
733         elif names and processed:
734             processed["Not Found"] = names
735         elif not processed:
736             raise SaltCloudSystemExit("No machines were destroyed!")
737         return processed
738     def reboot(self, names):
739         ret = []
740         pmap = self.map_providers_parallel()
741         acts = {}
742         for prov, nodes in pmap.items():
743             acts[prov] = []
744             for node in nodes:
745                 if node in names:
746                     acts[prov].append(node)
747         for prov, names_ in acts.items():
748             fun = "{}.reboot".format(prov)
749             for name in names_:
750                 ret.append({name: self.clouds[fun](name)})
751         return ret
752     def create(self, vm_, local_master=True):
753         output = {}
754         minion_dict = salt.config.get_cloud_config_value(
755             "minion", vm_, self.opts, default={}
756         )
757         alias, driver = vm_["provider"].split(":")
758         fun = "{}.create".format(driver)
759         if fun not in self.clouds:
760             log.error(
761                 "Creating '%s' using '%s' as the provider "
762                 "cannot complete since '%s' is not available",
763                 vm_["name"],
764                 vm_["provider"],
765                 driver,
766             )
767             return
768         deploy = salt.config.get_cloud_config_value("deploy", vm_, self.opts)
769         make_master = salt.config.get_cloud_config_value("make_master", vm_, self.opts)
770         if deploy:
771             if not make_master and "master" not in minion_dict:
772                 log.warning(
773                     "There's no master defined on the '%s' VM settings.", vm_["name"]
774                 )
775             if "pub_key" not in vm_ and "priv_key" not in vm_:
776                 log.debug("Generating minion keys for '%s'", vm_["name"])
777                 priv, pub = salt.utils.cloud.gen_keys(
778                     salt.config.get_cloud_config_value("keysize", vm_, self.opts)
779                 )
780                 vm_["pub_key"] = pub
781                 vm_["priv_key"] = priv
782         else:
783             vm_["pub_key"] = None
784             vm_["priv_key"] = None
785         key_id = minion_dict.get("id", vm_["name"])
786         domain = vm_.get("domain")
787         if vm_.get("use_fqdn") and domain:
788             minion_dict["append_domain"] = domain
789         if "append_domain" in minion_dict:
790             key_id = ".".join([key_id, minion_dict["append_domain"]])
791         if make_master is True and "master_pub" not in vm_ and "master_pem" not in vm_:
792             log.debug("Generating the master keys for '%s'", vm_["name"])
793             master_priv, master_pub = salt.utils.cloud.gen_keys(
794                 salt.config.get_cloud_config_value("keysize", vm_, self.opts)
795             )
796             vm_["master_pub"] = master_pub
797             vm_["master_pem"] = master_priv
798         if local_master is True and deploy is True:
799             salt.utils.cloud.accept_key(self.opts["pki_dir"], vm_["pub_key"], key_id)
800         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, self.opts)
801         try:
802             vm_["inline_script"] = salt.config.get_cloud_config_value(
803                 "inline_script", vm_, self.opts
804             )
805         except KeyError:
806             pass
807         try:
808             alias, driver = vm_["provider"].split(":")
809             func = "{}.create".format(driver)
810             with salt.utils.context.func_globals_inject(
811                 self.clouds[fun], __active_provider_name__=":".join([alias, driver])
812             ):
813                 output = self.clouds[func](vm_)
814             if output is not False and "sync_after_install" in self.opts:
815                 if self.opts["sync_after_install"] not in (
816                     "all",
817                     "modules",
818                     "states",
819                     "grains",
820                 ):
821                     log.error("Bad option for sync_after_install")
822                     return output
823                 time.sleep(3)
824                 start = int(time.time())
825                 while int(time.time()) &lt; start + 60:
826                     mopts_ = salt.config.DEFAULT_MASTER_OPTS
827                     conf_path = "/".join(self.opts["conf_file"].split("/")[:-1])
828                     mopts_.update(
829                         salt.config.master_config(os.path.join(conf_path, "master"))
830                     )
831                     with salt.client.get_local_client(mopts=mopts_) as client:
832                         ret = client.cmd(
833                             vm_["name"],
834                             "saltutil.sync_{}".format(self.opts["sync_after_install"]),
835                             timeout=self.opts["timeout"],
836                         )
837                         if ret:
838                             log.info(
839                                 "Synchronized the following dynamic modules: %s", ret
840                             )
841                             break
842         except KeyError as exc:
843             log.exception(
844                 "Failed to create VM %s. Configuration value %s needs to be set",
845                 vm_["name"],
846                 exc,
847             )
848         try:
849             opt_map = self.opts["map"]
850         except KeyError:
851             opt_map = False
852         if self.opts["parallel"] and self.opts["start_action"] and not opt_map:
853             log.info("Running %s on %s", self.opts["start_action"], vm_["name"])
854             with salt.client.get_local_client(mopts=self.opts) as client:
855                 action_out = client.cmd(
856                     vm_["name"],
857                     self.opts["start_action"],
858                     timeout=self.opts["timeout"] * 60,
859                 )
860             output["ret"] = action_out
861         return output
862     @staticmethod
863     def vm_config(name, main, provider, profile, overrides):
864         vm = main.copy()
865         vm = salt.utils.dictupdate.update(vm, provider)
866         vm = salt.utils.dictupdate.update(vm, profile)
867         vm.update(overrides)
868         vm["name"] = name
869         return vm
870     def extras(self, extra_):
871         output = {}
872         alias, driver = extra_["provider"].split(":")
873         fun = "{}.{}".format(driver, extra_["action"])
874         if fun not in self.clouds:
875             log.error(
876                 "Creating '%s' using '%s' as the provider "
877                 "cannot complete since '%s' is not available",
878                 extra_["name"],
879                 extra_["provider"],
880                 driver,
881             )
882             return
883         try:
884             with salt.utils.context.func_globals_inject(
885                 self.clouds[fun], __active_provider_name__=extra_["provider"]
886             ):
887                 output = self.clouds[fun](**extra_)
888         except KeyError as exc:
889             log.exception(
890                 "Failed to perform %s.%s on %s. Configuration value %s needs to be set",
891                 extra_["provider"],
892                 extra_["action"],
893                 extra_["name"],
894                 exc,
895             )
896         return output
897     def run_profile(self, profile, names, vm_overrides=None):
898         if profile not in self.opts["profiles"]:
899             msg = "Profile {} is not defined".format(profile)
900             log.error(msg)
901             return {"Error": msg}
902         ret = {}
903         if not vm_overrides:
904             vm_overrides = {}
905         try:
906             with salt.utils.files.fopen(self.opts["conf_file"], "r") as mcc:
907                 main_cloud_config = salt.utils.yaml.safe_load(mcc)
908             if not main_cloud_config:
909                 main_cloud_config = {}
910         except KeyError:
911             main_cloud_config = {}
912         except OSError:
913             main_cloud_config = {}
914         if main_cloud_config is None:
915             main_cloud_config = {}
916         mapped_providers = self.map_providers_parallel()
917         profile_details = self.opts["profiles"][profile]
918         vms = {}
919         for prov, val in mapped_providers.items():
920             prov_name = next(iter(val))
921             for node in mapped_providers[prov][prov_name]:
922                 vms[node] = mapped_providers[prov][prov_name][node]
923                 vms[node]["provider"] = prov
924                 vms[node]["driver"] = prov_name
925         alias, driver = profile_details["provider"].split(":")
926         provider_details = self.opts["providers"][alias][driver].copy()
927         del provider_details["profiles"]
928         for name in names:
929             if name in vms:
930                 prov = vms[name]["provider"]
931                 driv = vms[name]["driver"]
932                 msg = "{} already exists under {}:{}".format(name, prov, driv)
933                 log.error(msg)
934                 ret[name] = {"Error": msg}
935                 continue
936             vm_ = self.vm_config(
937                 name,
938                 main_cloud_config,
939                 provider_details,
940                 profile_details,
941                 vm_overrides,
942             )
943             if self.opts["parallel"]:
944                 process = multiprocessing.Process(target=self.create, args=(vm_,))
945                 process.start()
946                 ret[name] = {
947                     "Provisioning": "VM being provisioned in parallel. PID: {}".format(
948                         process.pid
949                     )
950                 }
951                 continue
952             try:
953                 ret[name] = self.create(vm_)
954                 if not ret[name]:
955                     ret[name] = {"Error": "Failed to deploy VM"}
956                     if len(names) == 1:
957                         raise SaltCloudSystemExit("Failed to deploy VM")
958                     continue
959                 if self.opts.get("show_deploy_args", False) is False:
960                     ret[name].pop("deploy_kwargs", None)
961             except (SaltCloudSystemExit, SaltCloudConfigError) as exc:
962                 if len(names) == 1:
963                     raise
964                 ret[name] = {"Error": str(exc)}
965         return ret
966     def do_action(self, names, kwargs):
967         ret = {}
968         invalid_functions = {}
969         names = set(names)
970         for alias, drivers in self.map_providers_parallel().items():
971             if not names:
972                 break
973             for driver, vms in drivers.items():
974                 if not names:
975                     break
976                 valid_function = True
977                 fun = "{}.{}".format(driver, self.opts["action"])
978                 if fun not in self.clouds:
979                     log.info("'%s()' is not available. Not actioning...", fun)
980                     valid_function = False
981                 for vm_name, vm_details in vms.items():
982                     if not names:
983                         break
984                     if vm_name not in names:
985                         if not isinstance(vm_details, dict):
986                             vm_details = {}
987                         if "id" in vm_details and vm_details["id"] in names:
988                             vm_name = vm_details["id"]
989                         else:
990                             log.debug(
991                                 "vm:%s in provider:%s is not in name list:'%s'",
992                                 vm_name,
993                                 driver,
994                                 names,
995                             )
996                             continue
997                     if valid_function is False:
998                         if invalid_functions.get(fun) is None:
999                             invalid_functions.update({fun: []})
1000                         invalid_functions[fun].append(vm_name)
1001                         continue
1002                     with salt.utils.context.func_globals_inject(
1003                         self.clouds[fun],
1004                         __active_provider_name__=":".join([alias, driver]),
1005                     ):
1006                         if alias not in ret:
1007                             ret[alias] = {}
1008                         if driver not in ret[alias]:
1009                             ret[alias][driver] = {}
1010                         kwargs = salt.utils.args.clean_kwargs(**kwargs)
1011                         if kwargs:
1012                             ret[alias][driver][vm_name] = self.clouds[fun](
1013                                 vm_name, kwargs, call="action"
1014                             )
1015                         else:
1016                             ret[alias][driver][vm_name] = self.clouds[fun](
1017                                 vm_name, call="action"
1018                             )
1019                         names.remove(vm_name)
1020         missing_vms = set()
1021         if invalid_functions:
1022             ret["Invalid Actions"] = invalid_functions
1023             invalid_func_vms = set()
1024             for key, val in invalid_functions.items():
1025                 invalid_func_vms = invalid_func_vms.union(set(val))
1026             missing_vms = names.difference(invalid_func_vms)
1027             if missing_vms:
1028                 ret["Not Found"] = list(missing_vms)
1029                 ret["Not Actioned/Not Running"] = list(names)
1030         if not names:
1031             return ret
1032         if missing_vms:
1033             return ret
1034         ret["Not Actioned/Not Running"] = list(names)
1035         ret["Not Found"] = list(names)
1036         return ret
1037     def do_function(self, prov, func, kwargs):
1038         matches = self.lookup_providers(prov)
1039         if len(matches) &gt; 1:
1040             raise SaltCloudSystemExit(
1041                 "More than one results matched '{}'. Please specify one of: {}".format(
1042                     prov,
1043                     ", ".join(
1044                         ["{}:{}".format(alias, driver) for (alias, driver) in matches]
1045                     ),
1046                 )
1047             )
1048         alias, driver = matches.pop()
1049         fun = "{}.{}".format(driver, func)
1050         if fun not in self.clouds:
1051             raise SaltCloudSystemExit(
1052                 "The '{}' cloud provider alias, for the '{}' driver, does "
1053                 "not define the function '{}'".format(alias, driver, func)
1054             )
1055         log.debug("Trying to execute '%s' with the following kwargs: %s", fun, kwargs)
1056         with salt.utils.context.func_globals_inject(
1057             self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1058         ):
1059             if kwargs:
1060                 return {
1061                     alias: {driver: self.clouds[fun](call="function", kwargs=kwargs)}
1062                 }
1063             return {alias: {driver: self.clouds[fun](call="function")}}
1064     def __filter_non_working_providers(self):
1065         for alias, drivers in self.opts["providers"].copy().items():
1066             for driver in drivers.copy():
1067                 fun = "{}.get_configured_provider".format(driver)
1068                 if fun not in self.clouds:
1069                     log.warning(
1070                         "The cloud driver, '%s', configured under the "
1071                         "'%s' cloud provider alias, could not be loaded. "
1072                         "Please check your provider configuration files and "
1073                         "ensure all required dependencies are installed "
1074                         "for the '%s' driver.\n"
1075                         "In rare cases, this could indicate the '%s()' "
1076                         "function could not be found.\nRemoving '%s' from "
1077                         "the available providers list",
1078                         driver,
1079                         alias,
1080                         driver,
1081                         fun,
1082                         driver,
1083                     )
1084                     self.opts["providers"][alias].pop(driver)
1085                     if alias not in self.opts["providers"]:
1086                         continue
1087                     if not self.opts["providers"][alias]:
1088                         self.opts["providers"].pop(alias)
1089                     continue
1090                 with salt.utils.context.func_globals_inject(
1091                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1092                 ):
1093                     if self.clouds[fun]() is False:
1094                         log.warning(
1095                             "The cloud driver, '%s', configured under the "
1096                             "'%s' cloud provider alias is not properly "
1097                             "configured. Removing it from the available "
1098                             "providers list.",
1099                             driver,
1100                             alias,
1101                         )
1102                         self.opts["providers"][alias].pop(driver)
1103             if alias not in self.opts["providers"]:
1104                 continue
1105             if not self.opts["providers"][alias]:
1106                 self.opts["providers"].pop(alias)
1107 class Map(Cloud):
1108     def __init__(self, opts):
1109         Cloud.__init__(self, opts)
1110         self.rendered_map = self.read()
1111     def interpolated_map(self, query="list_nodes", cached=False):
1112         rendered_map = self.read().copy()
1113         interpolated_map = {}
1114         for profile, mapped_vms in rendered_map.items():
1115             names = set(mapped_vms)
1116             if profile not in self.opts["profiles"]:
1117                 if "Errors" not in interpolated_map:
1118                     interpolated_map["Errors"] = {}
1119                 msg = (
1120                     "No provider for the mapped '{}' profile was found. "
1121                     "Skipped VMS: {}".format(profile, ", ".join(names))
1122                 )
1123                 log.info(msg)
1124                 interpolated_map["Errors"][profile] = msg
1125                 continue
1126             matching = self.get_running_by_names(names, query, cached)
1127             for alias, drivers in matching.items():
1128                 for driver, vms in drivers.items():
1129                     for vm_name, vm_details in vms.items():
1130                         if alias not in interpolated_map:
1131                             interpolated_map[alias] = {}
1132                         if driver not in interpolated_map[alias]:
1133                             interpolated_map[alias][driver] = {}
1134                         interpolated_map[alias][driver][vm_name] = vm_details
1135                         try:
1136                             names.remove(vm_name)
1137                         except KeyError:
1138                             pass
1139             if not names:
1140                 continue
1141             profile_details = self.opts["profiles"][profile]
1142             alias, driver = profile_details["provider"].split(":")
1143             for vm_name in names:
1144                 if alias not in interpolated_map:
1145                     interpolated_map[alias] = {}
1146                 if driver not in interpolated_map[alias]:
1147                     interpolated_map[alias][driver] = {}
1148                 interpolated_map[alias][driver][vm_name] = "Absent"
1149         return interpolated_map
1150     def delete_map(self, query=None):
1151         query_map = self.interpolated_map(query=query)
1152         for alias, drivers in query_map.copy().items():
1153             if alias == "Errors":
1154                 continue
1155             for driver, vms in drivers.copy().items():
1156                 for vm_name, vm_details in vms.copy().items():
1157                     if vm_details == "Absent":
1158                         query_map[alias][driver].pop(vm_name)
1159                 if not query_map[alias][driver]:
1160                     query_map[alias].pop(driver)
1161             if not query_map[alias]:
1162                 query_map.pop(alias)
1163         return query_map
1164     def get_vmnames_by_action(self, action):
1165         query_map = self.interpolated_map("list_nodes")
1166         matching_states = {
1167             "start": ["stopped"],
1168             "stop": ["running", "active"],
1169             "reboot": ["running", "active"],
1170         }
1171         vm_names = []
1172         for alias, drivers in query_map.items():
1173             for driver, vms in drivers.items():
1174                 for vm_name, vm_details in vms.items():
1175                     try:
1176                         state_action = matching_states[action]
1177                     except KeyError:
1178                         log.error(
1179                             "The use of '%s' as an action is not supported "
1180                             "in this context. Only 'start', 'stop', and "
1181                             "'reboot' are supported options.",
1182                             action,
1183                         )
1184                         raise SaltCloudException()
1185                     if (
1186                         vm_details != "Absent"
1187                         and vm_details["state"].lower() in state_action
1188                     ):
1189                         vm_names.append(vm_name)
1190         return vm_names
1191     def read(self):
1192         map_ = None
1193         if self.opts.get("map", None) is None:
1194             if self.opts.get("map_data", None) is None:
1195                 if self.opts.get("map_pillar", None) is None:
1196                     pass
1197                 elif self.opts.get("map_pillar") not in self.opts.get("maps"):
1198                     log.error(
1199                         "The specified map not found in pillar at 'cloud:maps:%s'",
1200                         self.opts["map_pillar"],
1201                     )
1202                     raise SaltCloudNotFound()
1203                 else:
1204                     map_ = self.opts["maps"][self.opts.get("map_pillar")]
1205             else:
1206                 map_ = self.opts["map_data"]
1207         else:
1208             local_minion_opts = copy.deepcopy(self.opts)
1209             local_minion_opts["file_client"] = "local"
1210             self.minion = salt.minion.MasterMinion(local_minion_opts)
1211             if not os.path.isfile(self.opts["map"]):
1212                 if not (self.opts["map"]).startswith("salt://"):
1213                     log.error(
1214                         "The specified map file does not exist: '%s'", self.opts["map"]
1215                     )
1216                     raise SaltCloudNotFound()
1217             if (self.opts["map"]).startswith("salt://"):
1218                 cached_map = self.minion.functions["cp.cache_file"](self.opts["map"])
1219             else:
1220                 cached_map = self.opts["map"]
1221             try:
1222                 renderer = self.opts.get("renderer", "jinja|yaml")
1223                 rend = salt.loader.render(self.opts, {})
1224                 blacklist = self.opts.get("renderer_blacklist")
1225                 whitelist = self.opts.get("renderer_whitelist")
1226                 map_ = compile_template(
1227                     cached_map, rend, renderer, blacklist, whitelist
1228                 )
1229             except Exception as exc:  # pylint: disable=broad-except
1230                 log.error(
1231                     "Rendering map %s failed, render error:\n%s",
1232                     self.opts["map"],
1233                     exc,
1234                     exc_info_on_loglevel=logging.DEBUG,
1235                 )
1236                 return {}
1237             if "include" in map_:
1238                 map_ = salt.config.include_config(map_, self.opts["map"], verbose=False)
1239         if not map_:
1240             return {}
1241         for profile, mapped in map_.copy().items():
1242             if isinstance(mapped, (list, tuple)):
1243                 entries = {}
1244                 for mapping in mapped:
1245                     if isinstance(mapping, str):
1246                         mapping = {mapping: None}
1247                     for name, overrides in mapping.items():
1248                         if overrides is None or isinstance(overrides, bool):
1249                             overrides = {}
1250                         try:
1251                             overrides.setdefault("name", name)
1252                         except AttributeError:
1253                             log.error(
1254                                 "Cannot use 'name' as a minion id in a cloud map as it"
1255                                 " is a reserved word. Please change 'name' to a"
1256                                 " different minion id reference."
1257                             )
1258                             return {}
1259                         entries[name] = overrides
1260                 map_[profile] = entries
1261                 continue
1262             if isinstance(mapped, dict):
1263                 entries = {}
1264                 for name, overrides in mapped.items():
1265                     overrides.setdefault("name", name)
1266                     entries[name] = overrides
1267                 map_[profile] = entries
1268                 continue
1269             if isinstance(mapped, str):
1270                 mapped = [mapped]
1271             map_[profile] = {}
1272             for name in mapped:
1273                 map_[profile][name] = {"name": name}
1274         return map_
1275     def _has_loop(self, dmap, seen=None, val=None):
1276         if seen is None:
1277             for values in dmap["create"].values():
1278                 seen = []
1279                 try:
1280                     machines = values["requires"]
1281                 except KeyError:
1282                     machines = []
1283                 for machine in machines:
1284                     if self._has_loop(dmap, seen=list(seen), val=machine):
1285                         return True
1286         else:
1287             if val in seen:
1288                 return True
1289             seen.append(val)
1290             try:
1291                 machines = dmap["create"][val]["requires"]
1292             except KeyError:
1293                 machines = []
1294             for machine in machines:
1295                 if self._has_loop(dmap, seen=list(seen), val=machine):
1296                     return True
1297         return False
1298     def _calcdep(self, dmap, machine, data, level):
1299         try:
1300             deplist = data["requires"]
1301         except KeyError:
1302             return level
1303         levels = []
1304         for name in deplist:
1305             try:
1306                 data = dmap["create"][name]
1307             except KeyError:
1308                 try:
1309                     data = dmap["existing"][name]
1310                 except KeyError:
1311                     msg = "Missing dependency in cloud map"
1312                     log.error(msg)
1313                     raise SaltCloudException(msg)
1314             levels.append(self._calcdep(dmap, name, data, level))
1315         level = max(levels) + 1
1316         return level
1317     def map_data(self, cached=False):
1318         ret = {"create": {}}
1319         pmap = self.map_providers_parallel(cached=cached)
1320         exist = set()
1321         defined = set()
1322         rendered_map = copy.deepcopy(self.rendered_map)
1323         for profile_name, nodes in rendered_map.items():
1324             if profile_name not in self.opts["profiles"]:
1325                 msg = (
1326                     "The required profile, '{}', defined in the map "
1327                     "does not exist. The defined nodes, {}, will not "
1328                     "be created.".format(
1329                         profile_name, ", ".join("'{}'".format(node) for node in nodes)
1330                     )
1331                 )
1332                 log.error(msg)
1333                 if "errors" not in ret:
1334                     ret["errors"] = {}
1335                 ret["errors"][profile_name] = msg
1336                 continue
1337             profile_data = self.opts["profiles"].get(profile_name)
1338             for nodename, overrides in nodes.items():
1339                 if (
1340                     and overrides["provider"] != profile_data["provider"]
1341                 ):
1342                     alias, driver = overrides<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("provider").split(":")
1343                 else:
1344                     alias, driver = profile_data.get("provider").split(":")
1345                 provider_details = copy.deepcopy(self.opts[</b></font>"providers"][alias][driver])
1346                 del provider_details["profiles"]
1347                 salt.utils.dictupdate.update(provider_details, profile_data)
1348                 nodedata = copy.deepcopy(provider_details)
1349                 for setting in ("grains", "master", "minion", "volumes", "requires"):
1350                     deprecated = "map_{}".format(setting)
1351                     if deprecated in overrides:
1352                         log.warning(
1353                             "The use of '%s' on the '%s' mapping has "
1354                             "been deprecated. The preferred way now is to "
1355                             "just define '%s'. For now, salt-cloud will do "
1356                             "the proper thing and convert the deprecated "
1357                             "mapping into the preferred one.",
1358                             deprecated,
1359                             nodename,
1360                             setting,
1361                         )
1362                         overrides[setting] = overrides.pop(deprecated)
1363                 if (
1364                     "minion" in overrides
1365                     and "minion" in nodedata
1366                     and "grains" in overrides["minion"]
1367                     and "grains" in nodedata["minion"]
1368                 ):
1369                     nodedata["minion"]["grains"].update(overrides["minion"]["grains"])
1370                     del overrides["minion"]["grains"]
1371                     if not overrides["minion"]:
1372                         del overrides["minion"]
1373                 nodedata = salt.utils.dictupdate.update(nodedata, overrides)
1374                 ret["create"][nodename] = nodedata
1375                 alias, driver = nodedata["provider"].split(":")
1376                 defined.add((alias, driver, nodename))
1377         def get_matching_by_name(name):
1378             matches = {}
1379             for alias, drivers in pmap.items():
1380                 for driver, vms in drivers.items():
1381                     for vm_name, details in vms.items():
1382                         if vm_name == name and driver not in matches:
1383                             matches[driver] = details["state"]
1384             return matches
1385         for alias, drivers in pmap.items():
1386             for driver, vms in drivers.items():
1387                 for name, details in vms.items():
1388                     exist.add((alias, driver, name))
1389                     if name not in ret["create"]:
1390                         continue
1391                     matching = get_matching_by_name(name)
1392                     if not matching:
1393                         continue
1394                     for item in matching:
1395                         if name not in ret["create"]:
1396                             break
1397                         log.warning(
1398                             "%r already exists, removing from the create map.", name
1399                         )
1400                         if "existing" not in ret:
1401                             ret["existing"] = {}
1402                         ret["existing"][name] = ret["create"].pop(name)
1403         if "hard" in self.opts and self.opts["hard"]:
1404             if self.opts["enable_hard_maps"] is False:
1405                 raise SaltCloudSystemExit(
1406                     "The --hard map can be extremely dangerous to use, "
1407                     "and therefore must explicitly be enabled in the main "
1408                     "configuration file, by setting 'enable_hard_maps' "
1409                     "to True"
1410                 )
1411             ret["destroy"] = exist.difference(defined)
1412         return ret
1413     def run_map(self, dmap):
1414         if self._has_loop(dmap):
1415             msg = "Uh-oh, that cloud map has a dependency loop!"
1416             log.error(msg)
1417             raise SaltCloudException(msg)
1418         for key, val in dmap["create"].items():
1419             log.info("Calculating dependencies for %s", key)
1420             level = 0
1421             level = self._calcdep(dmap, key, val, level)
1422             log.debug("Got execution order %s for %s", level, key)
1423             dmap["create"][key]["level"] = level
1424         try:
1425             existing_list = dmap["existing"].items()
1426         except KeyError:
1427             existing_list = {}.items()
1428         for key, val in existing_list:
1429             log.info("Calculating dependencies for %s", key)
1430             level = 0
1431             level = self._calcdep(dmap, key, val, level)
1432             log.debug("Got execution order %s for %s", level, key)
1433             dmap["existing"][key]["level"] = level
1434         create_list = sorted(dmap["create"].items(), key=lambda x: x[1]["level"])
1435         output = {}
1436         if self.opts["parallel"]:
1437             parallel_data = []
1438         master_name = None
1439         master_minion_name = None
1440         master_host = None
1441         master_finger = None
1442         try:
1443             master_name, master_profile = next(
1444                 (
1445                     (name, profile)
1446                     for name, profile in create_list
1447                     if profile.get("make_master", False) is True
1448                 )
1449             )
1450             master_minion_name = master_name
1451             log.debug("Creating new master '%s'", master_name)
1452             if (
1453                 salt.config.get_cloud_config_value("deploy", master_profile, self.opts)
1454                 is False
1455             ):
1456                 raise SaltCloudSystemExit(
1457                     "Cannot proceed with 'make_master' when salt deployment "
1458                     "is disabled(ex: --no-deploy)."
1459                 )
1460             log.debug("Generating master keys for '%s'", master_profile["name"])
1461             priv, pub = salt.utils.cloud.gen_keys(
1462                 salt.config.get_cloud_config_value("keysize", master_profile, self.opts)
1463             )
1464             master_profile["master_pub"] = pub
1465             master_profile["master_pem"] = priv
1466             master_temp_pub = salt.utils.files.mkstemp()
1467             with salt<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.files.fopen(master_temp_pub, "w") as mtp:
1468                 mtp.write(pub)
1469             master_finger = salt.utils.crypt.pem_finger(
1470                 master_temp_pub, sum_type=</b></font>self.opts["hash_type"]
1471             )
1472             os.unlink(master_temp_pub)
1473             if master_profile.get("make_minion", True) is True:
1474                 master_profile.setdefault("minion", {})
1475                 if "id" in master_profile["minion"]:
1476                     master_minion_name = master_profile["minion"]["id"]
1477                 if "master" not in master_profile["minion"]:
1478                     master_profile["minion"]["master"] = "127.0.0.1"
1479                     if master_finger is not None:
1480                         master_profile["master_finger"] = master_finger
1481             for name, profile in create_list:
1482                 make_minion = salt.config.get_cloud_config_value(
1483                     "make_minion", profile, self.opts, default=True
1484                 )
1485                 if make_minion is False:
1486                     continue
1487                 log.debug("Generating minion keys for '%s'", profile["name"])
1488                 priv, pub = salt.utils.cloud.gen_keys(
1489                     salt.config.get_cloud_config_value("keysize", profile, self.opts)
1490                 )
1491                 profile["pub_key"] = pub
1492                 profile["priv_key"] = priv
1493                 master_profile.setdefault("preseed_minion_keys", {})
1494                 master_profile["preseed_minion_keys"].update({name: pub})
1495             local_master = False
1496             if (
1497                 master_profile["minion"].get("local_master", False)
1498                 and master_profile["minion"].get("master", None) is not None
1499             ):
1500                 local_master = True
1501             out = self.create(master_profile, local_master=local_master)
1502             if not isinstance(out, dict):
1503                 log.debug("Master creation details is not a dictionary: %s", out)
1504             elif "Errors" in out:
1505                 raise SaltCloudSystemExit(
1506                     "An error occurred while creating the master, not "
1507                     "continuing: {}".format(out["Errors"])
1508                 )
1509             deploy_kwargs = (
1510                 self.opts.get("show_deploy_args", False) is True
1511                 and
1512                 out.get("deploy_kwargs", {})
1513                 or
1514                 out.pop("deploy_kwargs", {})
1515             )
1516             master_host = deploy_kwargs.get(
1517                 "salt_host", deploy_kwargs.get("host", None)
1518             )
1519             if master_host is None:
1520                 raise SaltCloudSystemExit(
1521                     "Host for new master {} was not found, aborting map".format(
1522                         master_name
1523                     )
1524                 )
1525             output[master_name] = out
1526         except StopIteration:
1527             log.debug("No make_master found in map")
1528             master_pub = os.path.join(self.opts["pki_dir"], "master.pub")
1529             if os.path.isfile(master_pub):
1530                 master_finger = salt.utils.crypt.pem_finger(
1531                     master_pub, sum_type=self.opts["hash_type"]
1532                 )
1533         opts = self.opts.copy()
1534         if self.opts["parallel"]:
1535             log.info(
1536                 "Since parallel deployment is in use, ssh console output "
1537                 "is disabled. All ssh output will be logged though"
1538             )
1539             opts["display_ssh_output"] = False
1540         local_master = master_name is None
1541         for name, profile in create_list:
1542             if name in (master_name, master_minion_name):
1543                 continue
1544             if (
1545                 "minion" in profile
1546                 and profile["minion"].get("local_master", False)
1547                 and profile["minion"].get("master", None) is not None
1548             ):
1549                 local_master = True
1550             if master_finger is not None and local_master is False:
1551                 profile["master_finger"] = master_finger
1552             if master_host is not None:
1553                 profile.setdefault("minion", {})
1554                 profile["minion"].setdefault("master", master_host)
1555             if self.opts["parallel"]:
1556                 parallel_data.append(
1557                     {
1558                         "opts": opts,
1559                         "name": name,
1560                         "profile": profile,
1561                         "local_master": local_master,
1562                     }
1563                 )
1564                 continue
1565             try:
1566                 output[name] = self.create(profile, local_master=local_master)
1567                 if (
1568                     self.opts.get("show_deploy_args", False) is False
1569                     and "deploy_kwargs" in output
1570                     and isinstance(output[name], dict)
1571                 ):
1572                     output[name].pop("deploy_kwargs", None)
1573             except SaltCloudException as exc:
1574                 log.error(
1575                     "Failed to deploy '%s'. Error: %s",
1576                     name,
1577                     exc,
1578                     exc_info_on_loglevel=logging.DEBUG,
1579                 )
1580                 output[name] = {"Error": str(exc)}
1581         for name in dmap.get("destroy", ()):
1582             output[name] = self.destroy(name)
1583         if self.opts["parallel"] and parallel_data:
1584             if "pool_size" in self.opts:
1585                 pool_size = self.opts["pool_size"]
1586             else:
1587                 pool_size = len(parallel_data)
1588             log.info("Cloud pool size: %s", pool_size)
1589             output_multip = enter_mainloop(
1590                 _create_multiprocessing, parallel_data, pool_size=pool_size
1591             )
1592             if self.opts["start_action"]:
1593                 actionlist = []
1594                 grp = -1
1595                 for key, val in groupby(dmap["create"].values(), lambda x: x["level"]):
1596                     actionlist.append([])
1597                     grp += 1
1598                     for item in val:
1599                         actionlist[grp].append(item["name"])
1600                 out = {}
1601                 for group in actionlist:
1602                     log.info(
1603                         "Running %s on %s", self.opts["start_action"], ", ".join(group)
1604                     )
1605                     with salt.client.get_local_client() as client:
1606                         out.update(
1607                             client.cmd(
1608                                 ",".join(group),
1609                                 self.opts["start_action"],
1610                                 timeout=self.opts["timeout"] * 60,
1611                                 tgt_type="list",
1612                             )
1613                         )
1614                 for obj in output_multip:
1615                     next(iter(obj.values()))["ret"] = out[next(iter(obj.keys()))]
1616                     output.update(obj)
1617             else:
1618                 for obj in output_multip:
1619                     output.update(obj)
1620         return output
1621 def init_pool_worker():
1622     signal.signal(signal.SIGINT, signal.SIG_IGN)
1623 def create_multiprocessing(parallel_data, queue=None):
1624     salt.utils.crypt.reinit_crypto()
1625     parallel_data["opts"]["output"] = "json"
1626     cloud = Cloud(parallel_data["opts"])
1627     try:
1628         output = cloud.create(
1629             parallel_data["profile"], local_master=parallel_data["local_master"]
1630         )
1631     except SaltCloudException as exc:
1632         log.error(
1633             "Failed to deploy '%s'. Error: %s",
1634             parallel_data["name"],
1635             exc,
1636             exc_info_on_loglevel=logging.DEBUG,
1637         )
1638         return {parallel_data["name"]: {"Error": str(exc)}}
1639     if parallel_data["opts"].get("show_deploy_args", False) is False and isinstance(
1640         output, dict
1641     ):
1642         output.pop("deploy_kwargs", None)
1643     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1644 def destroy_multiprocessing(parallel_data, queue=None):
1645     salt.utils.crypt.reinit_crypto()
1646     parallel_data["opts"]["output"] = "json"
1647     clouds = salt.loader.clouds(parallel_data["opts"])
1648     try:
1649         fun = clouds["{}.destroy".format(parallel_data["driver"])]
1650         with salt.utils.context.func_globals_inject(
1651             fun,
1652             __active_provider_name__=":".join(
1653                 [parallel_data["alias"], parallel_data["driver"]]
1654             ),
1655         ):
1656             output = fun(parallel_data["name"])
1657     except SaltCloudException as exc:
1658         log.error(
1659             "Failed to destroy %s. Error: %s",
1660             parallel_data["name"],
1661             exc,
1662             exc_info_on_loglevel=logging.DEBUG,
1663         )
1664         return {parallel_data["name"]: {"Error": str(exc)}}
1665     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1666 def run_parallel_map_providers_query(data, queue=None):
1667     salt.utils.crypt.reinit_crypto()
1668     cloud = Cloud(data["opts"])
1669     try:
1670         with salt.utils.context.func_globals_inject(
1671             cloud.clouds[data["fun"]],
1672             __active_provider_name__=":".join([data["alias"], data["driver"]]),
1673         ):
1674             return (
1675                 data["alias"],
1676                 data["driver"],
1677                 salt.utils.data.simple_types_filter(cloud.clouds[data["fun"]]()),
1678             )
1679     except Exception as err:  # pylint: disable=broad-except
1680         log.debug(
1681             "Failed to execute '%s()' while querying for running nodes: %s",
1682             data["fun"],
1683             err,
1684             exc_info_on_loglevel=logging.DEBUG,
1685         )
1686         return data["alias"], data["driver"], ()
1687 def _run_parallel_map_providers_query(*args, **kw):
1688     return communicator(run_parallel_map_providers_query)(*args[0], **kw)
1689 def _destroy_multiprocessing(*args, **kw):
1690     return communicator(destroy_multiprocessing)(*args[0], **kw)
1691 def _create_multiprocessing(*args, **kw):
1692     return communicator(create_multiprocessing)(*args[0], **kw)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>templates.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 Template render systems
2 """
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import codecs
4 import logging
5 import os
6 import sys
7 import tempfile
8 import traceback
9 from pathlib import Path
10 import jinja2
11 import jinja2.ext
12 import jinja2.sandbox
13 import salt.utils.data
14 import salt.utils.dateutils
15 import salt.utils.files
16 import salt.utils.hashutils
17 import salt.utils.http
18 import salt.utils.jinja
19 import salt.utils.network
20 import salt.utils.platform
21 import salt.utils.stringutils
22 import salt.utils.yamlencoding
23 from salt import __path__ as saltpath
24 from salt.exceptions import CommandExecutionError, SaltInvocationError, SaltRenderError
25 from salt.features import features
26 from salt.loader.context import NamedLoaderContext
27 from</b></font> salt.utils.decorators.jinja import JinjaFilter, JinjaGlobal, JinjaTest
28 from salt.utils.odict import OrderedDict
29 from salt.utils.versions import LooseVersion
30 if sys.version_info[:2] &gt;= (3, 5):
31     import importlib.machinery  # pylint: disable=no-name-in-module,import-error
32     import importlib.util  # pylint: disable=no-name-in-module,import-error
33     USE_IMPORTLIB = True
34 else:
35     import imp
36     USE_IMPORTLIB = False
37 log = logging.getLogger(__name__)
38 TEMPLATE_DIRNAME = os.path.join(saltpath[0], "templates")
39 SLS_ENCODING = "utf-8"  # this one has no BOM.
40 SLS_ENCODER = codecs.getencoder(SLS_ENCODING)
41 class AliasedLoader:
42     """
43     Light wrapper around the LazyLoader to redirect 'cmd.run' calls to
44     'cmd.shell', for easy use of shellisms during templating calls
45     Dotted aliases ('cmd.run') must resolve to another dotted alias
46     (e.g. 'cmd.shell')
47     Non-dotted aliases ('cmd') must resolve to a dictionary of function
48     aliases for that module (e.g. {'run': 'shell'})
49     """
50     def __init__(self, wrapped):
51         self.wrapped = wrapped
52     def __getitem__(self, name):
53         return self.wrapped[name]
54     def __getattr__(self, name):
55         return getattr(self.wrapped, name)
56     def __contains__(self, name):
57         return name in self.wrapped
58 class AliasedModule:
59     """
60     Light wrapper around module objects returned by the LazyLoader's getattr
61     for the purposes of `salt.cmd.run()` syntax in templates
62     Allows for aliasing specific functions, such as `run` to `shell` for easy
63     use of shellisms during templating calls
64     """
65     def __init__(self, wrapped, aliases):
66         self.aliases = aliases
67         self.wrapped = wrapped
68     def __getattr__(self, name):
69         return getattr(self.wrapped, name)
70 def _generate_sls_context_legacy(tmplpath, sls):
71     """
72     Legacy version of generate_sls_context, this method should be remove in the
73     Phosphorus release.
74     """
75     salt.utils.versions.warn_until(
76         "Phosphorus",
77         "There have been significant improvement to template variables. "
78         "To enable these improvements set features.enable_slsvars_fixes "
79         "to True in your config file. This feature will become the default "
80         "in the Phoshorus release.",
81     )
82     context = {}
83     slspath = sls.replace(".", "/")
84     if tmplpath is not None:
85         context["tplpath"] = tmplpath
86         if not tmplpath.lower().replace("\\", "/").endswith("/init.sls"):
87             slspath = os.path.dirname(slspath)
88         template = tmplpath.replace("\\", "/")
89         i = template.rfind(slspath.replace(".", "/"))
90         if i != -1:
91             template = template[i:]
92         tpldir = os.path.dirname(template).replace("\\", "/")
93         tpldata = {
94             "tplfile": template,
95             "tpldir": "." if tpldir == "" else tpldir,
96             "tpldot": tpldir.replace("/", "."),
97         }
98         context.update(tpldata)
99     context["slsdotpath"] = slspath.replace("/", ".")
100     context["slscolonpath"] = slspath.replace("/", ":")
101     context["sls_path"] = slspath.replace("/", "_")
102     context["slspath"] = slspath
103     return context
104 def _generate_sls_context(tmplpath, sls):
105     """
106     Generate SLS/Template Context Items
107     Return values:
108     tplpath - full path to template on filesystem including filename
109     tplfile - relative path to template -- relative to file roots
110     tpldir - directory of the template relative to file roots. If none, "."
111     tpldot - tpldir using dots instead of slashes, if none, ""
112     slspath - directory containing current sls - (same as tpldir), if none, ""
113     sls_path - slspath with underscores separating parts, if none, ""
114     slsdotpath - slspath with dots separating parts, if none, ""
115     slscolonpath- slspath with colons separating parts, if none, ""
116     """
117     sls_context = {}
118     slspath = sls.replace(".", "/")
119     if tmplpath:
120         template = str(Path(tmplpath).as_posix())
121         if not sls:
122         elif template.endswith("{}.sls".format(slspath)):
123             template = template[-(4 + len(slspath)) :]
124         elif template<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.endswith("{}/init.sls".format(slspath)):
125             template = template[-(9 + len(slspath)) :]
126         else:
127             log.warning("Failed to determine proper template path")
128         slspath = template.rsplit("/", 1)[0] if "/" in template else ""
129         sls_context.</b></font>update(
130             dict(
131                 tplpath=tmplpath,
132                 tplfile=template,
133                 tpldir=slspath if slspath else ".",
134                 tpldot=slspath.replace("/", "."),
135             )
136         )
137     sls_context.update(
138         dict(
139             slspath=slspath,
140             slsdotpath=slspath.replace("/", "."),
141             slscolonpath=slspath.replace("/", ":"),
142             sls_path=slspath.replace("/", "_"),
143         )
144     )
145     return sls_context
146 def generate_sls_context(tmplpath, sls):
147     """
148     Generate SLS/Template Context Items
149     Return values:
150     tplpath - full path to template on filesystem including filename
151     tplfile - relative path to template -- relative to file roots
152     tpldir - directory of the template relative to file roots. If none, "."
153     tpldot - tpldir using dots instead of slashes, if none, ""
154     slspath - directory containing current sls - (same as tpldir), if none, ""
155     sls_path - slspath with underscores separating parts, if none, ""
156     slsdotpath - slspath with dots separating parts, if none, ""
157     slscolonpath- slspath with colons separating parts, if none, ""
158     """
159     if not features.get("enable_slsvars_fixes", False):
160         return _generate_sls_context_legacy(tmplpath, sls)
161     return _generate_sls_context(tmplpath, sls)
162 def wrap_tmpl_func(render_str):
163     """
164     Each template processing function below, ``render_*_tmpl``, is wrapped by
165     ``render_tmpl`` before being inserted into the ``TEMPLATE_REGISTRY``.  Some
166     actions are taken here that are common to all renderers.  Perhaps a
167     standard decorator construct would have been more legible.
168     :param function render_str: Template rendering function to be wrapped.
169         Each function is responsible for rendering the source data for its
170         repective template language.
171     :returns function render_tmpl: The wrapper function
172     """
173     def render_tmpl(
174         tmplsrc, from_str=False, to_str=False, context=None, tmplpath=None, **kws
175     ):
176         if context is None:
177             context = {}
178         if "salt" in kws:
179             kws["salt"] = AliasedLoader(kws["salt"])
180         kws.update(context)
181         context = kws
182         assert "opts" in context
183         assert "saltenv" in context
184         if "sls" in context:
185             sls_context = generate_sls_context(tmplpath, context["sls"])
186             context.update(sls_context)
187         if isinstance(tmplsrc, str):
188             if from_str:
189                 tmplstr = tmplsrc
190             else:
191                 try:
192                     if tmplpath is not None:
193                         tmplsrc = os.path.join(tmplpath, tmplsrc)
194                     with codecs.open(tmplsrc, "r", SLS_ENCODING) as _tmplsrc:
195                         tmplstr = _tmplsrc.read()
196                 except (UnicodeDecodeError, ValueError, OSError) as exc:
197                     if salt.utils.files.is_binary(tmplsrc):
198                         return dict(result=True, data=tmplsrc)
199                     log.error(
200                         "Exception occurred while reading file %s: %s",
201                         tmplsrc,
202                         exc,
203                         exc_info_on_loglevel=logging.DEBUG,
204                     )
205                     raise
206         else:  # assume tmplsrc is file-like.
207             tmplstr = tmplsrc.read()
208             tmplsrc.close()
209         try:
210             output = render_str(tmplstr, context, tmplpath)
211             if salt.utils.platform.is_windows():
212                 newline = False
213                 if salt.utils.stringutils.to_unicode(
214                     output, encoding=SLS_ENCODING
215                 ).endswith(("\n", os.linesep)):
216                     newline = True
217                 output = os.linesep.join(output.splitlines())
218                 if newline:
219                     output += os.linesep
220         except SaltRenderError as exc:
221             log.exception("Rendering exception occurred")
222             raise
223         except Exception:  # pylint: disable=broad-except
224             return dict(result=False, data=traceback.format_exc())
225         else:
226             if to_str:  # then render as string
227                 return dict(result=True, data=output)
228             with tempfile.NamedTemporaryFile(
229                 "wb", delete=False, prefix=salt.utils.files.TEMPFILE_PREFIX
230             ) as outf:
231                 outf.write(
232                     salt.utils.stringutils.to_bytes(output, encoding=SLS_ENCODING)
233                 )
234             return dict(result=True, data=outf.name)
235     render_tmpl.render_str = render_str
236     return render_tmpl
237 def _get_jinja_error_slug(tb_data):
238     """
239     Return the line number where the template error was found
240     """
241     try:
242         return [
243             x
244             for x in tb_data
245             if x[2] in ("top-level template code", "template", "&lt;module&gt;")
246         ][-1]
247     except IndexError:
248         pass
249 def _get_jinja_error_message(tb_data):
250     """
251     Return an understandable message from jinja error output
252     """
253     try:
254         line = _get_jinja_error_slug(tb_data)
255         return "{0}({1}):\n{3}".format(*line)
256     except IndexError:
257         pass
258     return None
259 def _get_jinja_error_line(tb_data):
260     """
261     Return the line number where the template error was found
262     """
263     try:
264         return _get_jinja_error_slug(tb_data)[1]
265     except IndexError:
266         pass
267     return None
268 def _get_jinja_error(trace, context=None):
269     """
270     Return the error line and error message output from
271     a stacktrace.
272     If we are in a macro, also output inside the message the
273     exact location of the error in the macro
274     """
275     if not context:
276         context = {}
277     out = ""
278     error = _get_jinja_error_slug(trace)
279     line = _get_jinja_error_line(trace)
280     msg = _get_jinja_error_message(trace)
281     add_log = False
282     template_path = None
283     if "sls" not in context:
284         if (error[0] != "&lt;unknown&gt;") and os.path.exists(error[0]):
285             template_path = error[0]
286             add_log = True
287     else:
288         filen = context["sls"].replace(".", "/")
289         if not error[0].endswith(filen) and os.path.exists(error[0]):
290             add_log = True
291             template_path = error[0]
292     if add_log:
293             out = "\n{}\n".format(msg.splitlines()[0])
294             with salt.utils.files.fopen(template_path) as fp_:
295                 template_contents = salt<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.stringutils.to_unicode(fp_.read())
296             out += salt.utils.stringutils.get_context(
297                 template_contents, line, marker=</b></font>"    &lt;======================"
298             )
299         else:
300             out = "\n{}\n".format(msg)
301         line = 0
302     return line, out
303 def render_jinja_tmpl(tmplstr, context, tmplpath=None):
304     """
305     Render a Jinja template.
306     :param str tmplstr: A string containing the source to be rendered.
307     :param dict context: Any additional context data used by the renderer.
308     :param str tmplpath: Base path from which ``tmplstr`` may load additional
309         template files.
310     :returns str: The string rendered by the template.
311     """
312     opts = context["opts"]
313     saltenv = context["saltenv"]
314     loader = None
315     newline = False
316     file_client = context.get("fileclient", None)
317     if tmplstr and not isinstance(tmplstr, str):
318         tmplstr = tmplstr.decode(SLS_ENCODING)
319     if tmplstr.endswith(os.linesep):
320         newline = os.linesep
321     elif tmplstr.endswith("\n"):
322         newline = "\n"
323     if not saltenv:
324         if tmplpath:
325             loader = jinja2.FileSystemLoader(os.path.dirname(tmplpath))
326     else:
327         loader = salt.utils.jinja.SaltCacheLoader(
328             opts,
329             saltenv,
330             pillar_rend=context.get("_pillar_rend", False),
331             _file_client=file_client,
332         )
333     env_args = {"extensions": [], "loader": loader}
334     if hasattr(jinja2.ext, "with_"):
335         env_args["extensions"].append("jinja2.ext.with_")
336     if hasattr(jinja2.ext, "do"):
337         env_args["extensions"].append("jinja2.ext.do")
338     if hasattr(jinja2.ext, "loopcontrols"):
339         env_args["extensions"].append("jinja2.ext.loopcontrols")
340     env_args["extensions"].append(salt.utils.jinja.SerializerExtension)
341     opt_jinja_env = opts.get("jinja_env", {})
342     opt_jinja_sls_env = opts.get("jinja_sls_env", {})
343     opt_jinja_env = opt_jinja_env if isinstance(opt_jinja_env, dict) else {}
344     opt_jinja_sls_env = opt_jinja_sls_env if isinstance(opt_jinja_sls_env, dict) else {}
345     if opts.get("jinja_trim_blocks", False):
346         log.debug("Jinja2 trim_blocks is enabled")
347         log.warning(
348             "jinja_trim_blocks is deprecated and will be removed in a future release,"
349             " please use jinja_env and/or jinja_sls_env instead"
350         )
351         opt_jinja_env["trim_blocks"] = True
352         opt_jinja_sls_env["trim_blocks"] = True
353     if opts.get("jinja_lstrip_blocks", False):
354         log.debug("Jinja2 lstrip_blocks is enabled")
355         log.warning(
356             "jinja_lstrip_blocks is deprecated and will be removed in a future release,"
357             " please use jinja_env and/or jinja_sls_env instead"
358         )
359         opt_jinja_env["lstrip_blocks"] = True
360         opt_jinja_sls_env["lstrip_blocks"] = True
361     def opt_jinja_env_helper(opts, optname):
362         for k, v in opts.items():
363             k = k.lower()
364             if hasattr(jinja2.defaults, k.upper()):
365                 log.debug("Jinja2 environment %s was set to %s by %s", k, v, optname)
366                 env_args[k] = v
367             else:
368                 log.warning("Jinja2 environment %s is not recognized", k)
369     if "sls" in context and context["sls"] != "":
370         opt_jinja_env_helper(opt_jinja_sls_env, "jinja_sls_env")
371     else:
372         opt_jinja_env_helper(opt_jinja_env, "jinja_env")
373     if opts.get("allow_undefined", False):
374         jinja_env = jinja2.sandbox.SandboxedEnvironment(**env_args)
375     else:
376         jinja_env = jinja2.sandbox.SandboxedEnvironment(
377             undefined=jinja2.StrictUndefined, **env_args
378         )
379     indent_filter = jinja_env.filters.get("indent")
380     jinja_env.tests.update(JinjaTest.salt_jinja_tests)
381     jinja_env.filters.update(JinjaFilter.salt_jinja_filters)
382     if salt.utils.jinja.JINJA_VERSION &gt;= LooseVersion("2.11"):
383         jinja_env.filters["indent"] = indent_filter
384     jinja_env.globals.update(JinjaGlobal.salt_jinja_globals)
385     jinja_env.globals["odict"] = OrderedDict
386     jinja_env.globals["show_full_context"] = salt.utils.jinja.show_full_context
387     jinja_env.tests["list"] = salt.utils.data.is_list
388     decoded_context = {}
389     for key, value in context.items():
390         if not isinstance(value, str):
391             if isinstance(value, NamedLoaderContext):
392                 decoded_context[key] = value.value()
393             else:
394                 decoded_context[key] = value
395             continue
396         try:
397             decoded_context[key] = salt.utils.stringutils.to_unicode(
398                 value, encoding=SLS_ENCODING
399             )
400         except UnicodeDecodeError as ex:
401             log.debug(
402                 "Failed to decode using default encoding (%s), trying system encoding",
403                 SLS_ENCODING,
404             )
405             decoded_context[key] = salt.utils.data.decode(value)
406     jinja_env.globals.update(decoded_context)
407     try:
408         template = jinja_env.from_string(tmplstr)
409         output = template.render(**decoded_context)
410     except jinja2.exceptions.UndefinedError as exc:
411         trace = traceback.extract_tb(sys.exc_info()[2])
412         line, out = _get_jinja_error(trace, context=decoded_context)
413         if not line:
414             tmplstr = ""
415         raise SaltRenderError("Jinja variable {}{}".format(exc, out), line, tmplstr)
416     except (
417         jinja2.exceptions.TemplateRuntimeError,
418         jinja2.exceptions.TemplateSyntaxError,
419         jinja2.exceptions.SecurityError,
420     ) as exc:
421         trace = traceback.extract_tb(sys.exc_info()[2])
422         line, out = _get_jinja_error(trace, context=decoded_context)
423         if not line:
424             tmplstr = ""
425         raise SaltRenderError(
426             "Jinja syntax error: {}{}".format(exc, out), line, tmplstr
427         )
428     except (SaltInvocationError, CommandExecutionError) as exc:
429         trace = traceback.extract_tb(sys.exc_info()[2])
430         line, out = _get_jinja_error(trace, context=decoded_context)
431         if not line:
432             tmplstr = ""
433         raise SaltRenderError(
434             "Problem running salt function in Jinja template: {}{}".format(exc, out),
435             line,
436             tmplstr,
437         )
438     except Exception as exc:  # pylint: disable=broad-except
439         tracestr = traceback.format_exc()
440         trace = traceback.extract_tb(sys.exc_info()[2])
441         line, out = _get_jinja_error(trace, context=decoded_context)
442         if not line:
443             tmplstr = ""
444             tmplstr += "\n{}".format(tracestr)
445         log.debug("Jinja Error")
446         log<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.debug("Exception:", exc_info=True)
447         log.debug("Out: %s", out)
448         log.debug("Line: %s", line)
449         log.debug("TmplStr: %s", tmplstr)
450         log.debug("TraceStr: %s", tracestr)
451         raise SaltRenderError(
452             "Jinja error: {}{}".format(</b></font>exc, out), line, tmplstr, trace=tracestr
453         )
454     if newline:
455         output += newline
456     return output
457 def render_mako_tmpl(tmplstr, context, tmplpath=None):
458     """
459     Render a Mako template.
460     :param str tmplstr: A string containing the source to be rendered.
461     :param dict context: Any additional context data used by the renderer.
462     :param str tmplpath: Base path from which ``tmplstr`` may load additional
463         template files.
464     :returns str: The string rendered by the template.
465     """
466     import mako.exceptions  # pylint: disable=no-name-in-module
467     from mako.template import Template  # pylint: disable=no-name-in-module
468     from salt.utils.mako import SaltMakoTemplateLookup
469     saltenv = context["saltenv"]
470     lookup = None
471     if not saltenv:
472         if tmplpath:
473             from mako.lookup import TemplateLookup  # pylint: disable=no-name-in-module
474             lookup = TemplateLookup(directories=[os.path.dirname(tmplpath)])
475     else:
476         lookup = SaltMakoTemplateLookup(
477             context["opts"], saltenv, pillar_rend=context.get("_pillar_rend", False)
478         )
479     try:
480         return Template(
481             tmplstr,
482             strict_undefined=True,
483             uri=context["sls"].replace(".", "/") if "sls" in context else None,
484             lookup=lookup,
485         ).render(**context)
486     except Exception:  # pylint: disable=broad-except
487         raise SaltRenderError(mako.exceptions.text_error_template().render())
488 def render_wempy_tmpl(tmplstr, context, tmplpath=None):
489     """
490     Render a Wempy template.
491     :param str tmplstr: A string containing the source to be rendered.
492     :param dict context: Any additional context data used by the renderer.
493     :param str tmplpath: Unused.
494     :returns str: The string rendered by the template.
495     """
496     from wemplate.wemplate import TemplateParser as Template
497     return Template(tmplstr).render(**context)
498 def render_genshi_tmpl(tmplstr, context, tmplpath=None):
499     """
500     Render a Genshi template. A method should be passed in as part of the
501     context. If no method is passed in, xml is assumed. Valid methods are:
502     .. code-block:
503         - xml
504         - xhtml
505         - html
506         - text
507         - newtext
508         - oldtext
509     Note that the ``text`` method will call ``NewTextTemplate``. If ``oldtext``
510     is desired, it must be called explicitly
511     """
512     method = context.get("method", "xml")
513     if method == "text" or method == "newtext":
514         from genshi.template import NewTextTemplate  # pylint: disable=no-name-in-module
515         tmpl = NewTextTemplate(tmplstr)
516     elif method == "oldtext":
517         from genshi.template import OldTextTemplate  # pylint: disable=no-name-in-module
518         tmpl = OldTextTemplate(tmplstr)
519     else:
520         from genshi.template import MarkupTemplate  # pylint: disable=no-name-in-module
521         tmpl = MarkupTemplate(tmplstr)
522     return tmpl.generate(**context).render(method)
523 def render_cheetah_tmpl(tmplstr, context, tmplpath=None):
524     """
525     Render a Cheetah template.
526     """
527     from Cheetah.Template import Template
528     tclass = Template.compile(tmplstr)
529     data = tclass(namespaces=[context])
530     if isinstance(tmplstr, str):
531         res = str(data)
532     elif isinstance(tmplstr, bytes):
533         res = str(data)
534     else:
535         raise SaltRenderError(
536             "Unknown type {!s} for Cheetah template while trying to render.".format(
537                 type(tmplstr)
538             )
539         )
540     return salt.utils.data.decode(res)
541 def py(sfn, string=False, **kwargs):  # pylint: disable=C0103
542     """
543     Render a template from a python source file
544     Returns::
545         {'result': bool,
546          'data': &lt;Error data or rendered file path&gt;}
547     """
548     if not os.path.isfile(sfn):
549         return {}
550     base_fname = os.path.basename(sfn)
551     name = base_fname.split(".")[0]
552     if USE_IMPORTLIB:
553         loader = importlib.machinery.SourceFileLoader(name, sfn)
554         spec = importlib.util.spec_from_file_location(name, sfn, loader=loader)
555         if spec is None:
556             raise ImportError()
557         mod = importlib.util.module_from_spec(spec)
558         spec.loader.exec_module(mod)
559         sys.modules[name] = mod
560     else:
561         mod = imp.load_source(name, sfn)
562     if "__env__" not in kwargs and "saltenv" in kwargs:
563         setattr(mod, "__env__", kwargs["saltenv"])
564         builtins = ["salt", "grains", "pillar", "opts"]
565         for builtin in builtins:
566             arg = "__{}__".format(builtin)
567             setattr(mod, arg, kwargs[builtin])
568     for kwarg in kwargs:
569         setattr(mod, kwarg, kwargs[kwarg])
570     try:
571         data = mod.run()
572         if string:
573             return {"result": True, "data": data}
574         tgt = salt.utils.files.mkstemp()
575         with salt.utils.files.fopen(tgt, "w+") as target:
576             target.write(salt.utils.stringutils.to_str(data))
577         return {"result": True, "data": tgt}
578     except Exception:  # pylint: disable=broad-except
579         trb = traceback.format_exc()
580         return {"result": False, "data": trb}
581 JINJA = wrap_tmpl_func(render_jinja_tmpl)
582 MAKO = wrap_tmpl_func(render_mako_tmpl)
583 WEMPY = wrap_tmpl_func(render_wempy_tmpl)
584 GENSHI = wrap_tmpl_func(render_genshi_tmpl)
585 CHEETAH = wrap_tmpl_func(render_cheetah_tmpl)
586 TEMPLATE_REGISTRY = {
587     "jinja": JINJA,
588     "mako": MAKO,
589     "py": py,
590     "wempy": WEMPY,
591     "genshi": GENSHI,
592     "cheetah": CHEETAH,
593 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
