<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for __init___57.py & templates.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for __init___57.py & templates.py
      </h3>
      <h1 align="center">
        2.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>__init___57.py (1.8250134%)<TH>templates.py (6.621227%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match122344-0.html#0',2,'match122344-1.html#0',3)" NAME="0">(5-35)<TD><A HREF="javascript:ZweiFrames('match122344-0.html#0',2,'match122344-1.html#0',3)" NAME="0">(4-29)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match122344-0.html#1',2,'match122344-1.html#1',3)" NAME="1">(1898-1902)<TD><A HREF="javascript:ZweiFrames('match122344-0.html#1',2,'match122344-1.html#1',3)" NAME="1">(163-171)</A><TD ALIGN=center><FONT COLOR="#990000">15</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match122344-0.html#2',2,'match122344-1.html#2',3)" NAME="2">(163-168)<TD><A HREF="javascript:ZweiFrames('match122344-0.html#2',2,'match122344-1.html#2',3)" NAME="2">(565-572)</A><TD ALIGN=center><FONT COLOR="#990000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match122344-0.html#3',2,'match122344-1.html#3',3)" NAME="3">(2062-2065)<TD><A HREF="javascript:ZweiFrames('match122344-0.html#3',2,'match122344-1.html#3',3)" NAME="3">(383-385)</A><TD ALIGN=center><FONT COLOR="#840000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___57.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>The top level interface used to translate configuration data back to the
correct cloud modules
&quot;&quot;&quot;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match122344-1.html#0',3,'match122344-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import copy
import glob
import logging
import multiprocessing
import os
import signal
import time
import traceback
from itertools import groupby

import salt.client
import salt.config
import salt.loader
import salt.syspaths
import salt.utils.args
import salt.utils.cloud
import salt.utils.context
import salt.utils.crypt
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.user
import salt.utils.verify
import salt.utils.yaml
from salt.exceptions import (
    SaltCloudConfigError,
    SaltCloudException,
    SaltCloudNotFound,
    SaltCloudSystemExit,
)
from</B></FONT> salt.template import compile_template

try:
    import Cryptodome.Random
except ImportError:
    try:
        import Crypto.Random  # nosec
    except ImportError:
        pass  # pycrypto &lt; 2.1

log = logging.getLogger(__name__)


def communicator(func):
    &quot;&quot;&quot;Warning, this is a picklable decorator !&quot;&quot;&quot;

    def _call(queue, args, kwargs):
        &quot;&quot;&quot;called with [queue, args, kwargs] as first optional arg&quot;&quot;&quot;
        kwargs[&quot;queue&quot;] = queue
        ret = None
        try:
            ret = func(*args, **kwargs)
            queue.put(&quot;END&quot;)
        except KeyboardInterrupt as ex:
            trace = traceback.format_exc()
            queue.put(&quot;KEYBOARDINT&quot;)
            queue.put(&quot;Keyboard interrupt&quot;)
            queue.put(&quot;{}\n{}\n&quot;.format(ex, trace))
        except Exception as ex:  # pylint: disable=broad-except
            trace = traceback.format_exc()
            queue.put(&quot;ERROR&quot;)
            queue.put(&quot;Exception&quot;)
            queue.put(&quot;{}\n{}\n&quot;.format(ex, trace))
        except SystemExit as ex:
            trace = traceback.format_exc()
            queue.put(&quot;ERROR&quot;)
            queue.put(&quot;System exit&quot;)
            queue.put(&quot;{}\n{}\n&quot;.format(ex, trace))
        return ret

    return _call


def enter_mainloop(
    target,
    mapped_args=None,
    args=None,
    kwargs=None,
    pool=None,
    pool_size=None,
    callback=None,
    queue=None,
):
    &quot;&quot;&quot;
    Manage a multiprocessing pool

    - If the queue does not output anything, the pool runs indefinitely

    - If the queue returns KEYBOARDINT or ERROR, this will kill the pool
      totally calling terminate &amp; join and ands with a SaltCloudSystemExit
      exception notifying callers from the abnormal termination

    - If the queue returns END or callback is defined and returns True,
      it just join the process and return the data.

    target
        the function you want to execute in multiprocessing
    pool
        pool object can be None if you want a default pool, but you ll
        have then to define pool_size instead
    pool_size
        pool size if you did not provide yourself a pool
    callback
        a boolean taking a string in argument which returns True to
        signal that 'target' is finished and we need to join
        the pool
    queue
        A custom multiprocessing queue in case you want to do
        extra stuff and need it later in your program
    args
        positional arguments to call the function with
        if you don't want to use pool.map

    mapped_args
        a list of one or more arguments combinations to call the function with
        e.g. (foo, [[1], [2]]) will call::

                foo([1])
                foo([2])

    kwargs
        kwargs to give to the function in case of process

    Attention, the function must have the following signature:

            target(queue, *args, **kw)

    You may use the 'communicator' decorator to generate such a function
    (see end of this file)
    &quot;&quot;&quot;
    if not kwargs:
        kwargs = {}
    if not pool_size:
        pool_size = 1
    if not pool:
        pool = multiprocessing.Pool(pool_size)
    if not queue:
        manager = multiprocessing.Manager()
        queue = manager.Queue()

    if mapped_args is not None and not mapped_args:
        msg = (
            &quot;We are called to asynchronously execute {}&quot;
            &quot; but we do no have anything to execute, weird,&quot;
            &quot; we bail out&quot;.format(target)
        )
        log.error(msg)
        raise SaltCloudSystemExit(&quot;Exception caught\n{}&quot;.format(msg))
    elif mapped_args is not None:
        iterable = [[queue, [arg], kwargs] for arg in mapped_args]
        ret = pool.map(func=target, iterable=iterable)
    else:
        ret = pool.apply(target, [queue, args, kwargs])
    while True:
        test = queue.get()
<A NAME="2"></A>        if test in [&quot;ERROR&quot;, &quot;KEYBOARDINT&quot;]:
            type_ = queue.get()
            trace = queue.get()
            msg = &quot;Caught {}, terminating workers\n&quot;<FONT color="#980517"><A HREF="javascript:ZweiFrames('match122344-1.html#2',3,'match122344-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.format(type_)
            msg += &quot;TRACE: {}\n&quot;.format(trace)
            log.error(msg)
            pool.terminate()
            pool.join()
            raise SaltCloudSystemExit(&quot;Exception caught\n{}&quot;.format(</B></FONT>msg))
        elif test in [&quot;END&quot;] or (callback and callback(test)):
            pool.close()
            pool.join()
            break
        else:
            time.sleep(0.125)
    return ret


class CloudClient:
    &quot;&quot;&quot;
    The client class to wrap cloud interactions
    &quot;&quot;&quot;

    def __init__(self, path=None, opts=None, config_dir=None, pillars=None):
        if opts:
            self.opts = opts
        else:
            self.opts = salt.config.cloud_config(path)

        # Check the cache-dir exists. If not, create it.
        v_dirs = [self.opts[&quot;cachedir&quot;]]
        salt.utils.verify.verify_env(v_dirs, salt.utils.user.get_user())

        if pillars:
            for name, provider in pillars.pop(&quot;providers&quot;, {}).items():
                driver = provider[&quot;driver&quot;]
                provider[&quot;profiles&quot;] = {}
                self.opts[&quot;providers&quot;].update({name: {driver: provider}})
            for name, profile in pillars.pop(&quot;profiles&quot;, {}).items():
                provider = profile[&quot;provider&quot;].split(&quot;:&quot;)[0]
                driver = next(iter(self.opts[&quot;providers&quot;][provider].keys()))
                profile[&quot;provider&quot;] = &quot;{}:{}&quot;.format(provider, driver)
                profile[&quot;profile&quot;] = name
                self.opts[&quot;profiles&quot;].update({name: profile})
                self.opts[&quot;providers&quot;][provider][driver][&quot;profiles&quot;].update(
                    {name: profile}
                )
            for name, map_dct in pillars.pop(&quot;maps&quot;, {}).items():
                if &quot;maps&quot; not in self.opts:
                    self.opts[&quot;maps&quot;] = {}
                self.opts[&quot;maps&quot;][name] = map_dct
            self.opts.update(pillars)

    def _opts_defaults(self, **kwargs):
        &quot;&quot;&quot;
        Set the opts dict to defaults and allow for opts to be overridden in
        the kwargs
        &quot;&quot;&quot;
        # Let's start with the default salt cloud configuration
        opts = salt.config.DEFAULT_CLOUD_OPTS.copy()
        # Update it with the loaded configuration
        opts.update(self.opts.copy())
        # Reset some of the settings to sane values
        opts[&quot;parallel&quot;] = False
        opts[&quot;keep_tmp&quot;] = False
        opts[&quot;deploy&quot;] = True
        opts[&quot;update_bootstrap&quot;] = False
        opts[&quot;show_deploy_args&quot;] = False
        opts[&quot;script_args&quot;] = &quot;&quot;
        # Update it with the passed kwargs
        if &quot;kwargs&quot; in kwargs:
            opts.update(kwargs[&quot;kwargs&quot;])
        opts.update(kwargs)
        profile = opts.get(&quot;profile&quot;, None)
        # filter other profiles if one is specified
        if profile:
            tmp_profiles = opts.get(&quot;profiles&quot;, {}).copy()
            for _profile in [a for a in tmp_profiles]:
                if not _profile == profile:
                    tmp_profiles.pop(_profile)
            # if profile is specified and we have enough info about providers
            # also filter them to speedup methods like
            # __filter_non_working_providers
            providers = [
                a.get(&quot;provider&quot;, &quot;&quot;).split(&quot;:&quot;)[0]
                for a in tmp_profiles.values()
                if a.get(&quot;provider&quot;, &quot;&quot;)
            ]
            if providers:
                _providers = opts.get(&quot;providers&quot;, {})
                for provider in _providers.copy():
                    if provider not in providers:
                        _providers.pop(provider)
        return opts

    def low(self, fun, low):
        &quot;&quot;&quot;
        Pass the cloud function and low data structure to run
        &quot;&quot;&quot;
        l_fun = getattr(self, fun)
        f_call = salt.utils.args.format_call(l_fun, low)
        return l_fun(*f_call.get(&quot;args&quot;, ()), **f_call.get(&quot;kwargs&quot;, {}))

    def list_sizes(self, provider=None):
        &quot;&quot;&quot;
        List all available sizes in configured cloud systems
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        return salt.utils.data.simple_types_filter(mapper.size_list(provider))

    def list_images(self, provider=None):
        &quot;&quot;&quot;
        List all available images in configured cloud systems
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        return salt.utils.data.simple_types_filter(mapper.image_list(provider))

    def list_locations(self, provider=None):
        &quot;&quot;&quot;
        List all available locations in configured cloud systems
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        return salt.utils.data.simple_types_filter(mapper.location_list(provider))

    def query(self, query_type=&quot;list_nodes&quot;):
        &quot;&quot;&quot;
        Query basic instance information
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        mapper.opts[&quot;selected_query_option&quot;] = &quot;list_nodes&quot;
        return mapper.map_providers_parallel(query_type)

    def full_query(self, query_type=&quot;list_nodes_full&quot;):
        &quot;&quot;&quot;
        Query all instance information
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        mapper.opts[&quot;selected_query_option&quot;] = &quot;list_nodes_full&quot;
        return mapper.map_providers_parallel(query_type)

    def select_query(self, query_type=&quot;list_nodes_select&quot;):
        &quot;&quot;&quot;
        Query select instance information
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        mapper.opts[&quot;selected_query_option&quot;] = &quot;list_nodes_select&quot;
        return mapper.map_providers_parallel(query_type)

    def min_query(self, query_type=&quot;list_nodes_min&quot;):
        &quot;&quot;&quot;
        Query select instance information
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        mapper.opts[&quot;selected_query_option&quot;] = &quot;list_nodes_min&quot;
        return mapper.map_providers_parallel(query_type)

    def profile(self, profile, names, vm_overrides=None, **kwargs):
        &quot;&quot;&quot;
        Pass in a profile to create, names is a list of vm names to allocate

            vm_overrides is a special dict that will be per node options
            overrides

        Example:

        .. code-block:: python

            &gt;&gt;&gt; client= salt.cloud.CloudClient(path='/etc/salt/cloud')
            &gt;&gt;&gt; client.profile('do_512_git', names=['minion01',])
            {'minion01': {'backups_active': 'False',
                    'created_at': '2014-09-04T18:10:15Z',
                    'droplet': {'event_id': 31000502,
                                 'id': 2530006,
                                 'image_id': 5140006,
                                 'name': 'minion01',
                                 'size_id': 66},
                    'id': '2530006',
                    'image_id': '5140006',
                    'ip_address': '107.XXX.XXX.XXX',
                    'locked': 'True',
                    'name': 'minion01',
                    'private_ip_address': None,
                    'region_id': '4',
                    'size_id': '66',
                    'status': 'new'}}


        &quot;&quot;&quot;
        if not vm_overrides:
            vm_overrides = {}
        kwargs[&quot;profile&quot;] = profile
        mapper = salt.cloud.Map(self._opts_defaults(**kwargs))
        if isinstance(names, str):
            names = names.split(&quot;,&quot;)
        return salt.utils.data.simple_types_filter(
            mapper.run_profile(profile, names, vm_overrides=vm_overrides)
        )

    def map_run(self, path=None, **kwargs):
        &quot;&quot;&quot;
        To execute a map
        &quot;&quot;&quot;
        kwarg = {}
        if path:
            kwarg[&quot;map&quot;] = path
        kwarg.update(kwargs)
        mapper = salt.cloud.Map(self._opts_defaults(**kwarg))
        dmap = mapper.map_data()
        return salt.utils.data.simple_types_filter(mapper.run_map(dmap))

    def destroy(self, names):
        &quot;&quot;&quot;
        Destroy the named VMs
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults(destroy=True))
        if isinstance(names, str):
            names = names.split(&quot;,&quot;)
        return salt.utils.data.simple_types_filter(mapper.destroy(names))

    def create(self, provider, names, **kwargs):
        &quot;&quot;&quot;
        Create the named VMs, without using a profile

        Example:

        .. code-block:: python

            client.create(provider='my-ec2-config', names=['myinstance'],
                image='ami-1624987f', size='t1.micro', ssh_username='ec2-user',
                securitygroup='default', delvol_on_destroy=True)
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        providers = self.opts[&quot;providers&quot;]
        if provider in providers:
            provider += &quot;:{}&quot;.format(next(iter(providers[provider].keys())))
        else:
            return False
        if isinstance(names, str):
            names = names.split(&quot;,&quot;)
        ret = {}
        for name in names:
            vm_ = kwargs.copy()
            vm_[&quot;name&quot;] = name
            vm_[&quot;driver&quot;] = provider

            # This function doesn't require a profile, but many cloud drivers
            # check for profile information (which includes the provider key) to
            # help with config file debugging and setting up instances. Setting
            # the profile and provider defaults here avoids errors in other
            # cloud functions relying on these keys. See SaltStack Issue #41971
            # and PR #38166 for more information.
            vm_[&quot;profile&quot;] = None
            vm_[&quot;provider&quot;] = provider

            ret[name] = salt.utils.data.simple_types_filter(mapper.create(vm_))
        return ret

    def extra_action(self, names, provider, action, **kwargs):
        &quot;&quot;&quot;
        Perform actions with block storage devices

        Example:

        .. code-block:: python

            client.extra_action(names=['myblock'], action='volume_create',
                provider='my-nova', kwargs={'voltype': 'SSD', 'size': 1000}
            )
            client.extra_action(names=['salt-net'], action='network_create',
                provider='my-nova', kwargs={'cidr': '192.168.100.0/24'}
            )
        &quot;&quot;&quot;
        mapper = salt.cloud.Map(self._opts_defaults())
        providers = mapper.map_providers_parallel()
        if provider in providers:
            provider += &quot;:{}&quot;.format(next(iter(providers[provider].keys())))
        else:
            return False
        if isinstance(names, str):
            names = names.split(&quot;,&quot;)

        ret = {}
        for name in names:
            extra_ = kwargs.copy()
            extra_[&quot;name&quot;] = name
            extra_[&quot;provider&quot;] = provider
            extra_[&quot;profile&quot;] = None
            extra_[&quot;action&quot;] = action
            ret[name] = salt.utils.data.simple_types_filter(mapper.extras(extra_))
        return ret

    def action(
        self,
        fun=None,
        cloudmap=None,
        names=None,
        provider=None,
        instance=None,
        kwargs=None,
    ):
        &quot;&quot;&quot;
        Execute a single action via the cloud plugin backend

        Examples:

        .. code-block:: python

            client.action(fun='show_instance', names=['myinstance'])
            client.action(fun='show_image', provider='my-ec2-config',
                kwargs={'image': 'ami-10314d79'}
            )
        &quot;&quot;&quot;
        if kwargs is None:
            kwargs = {}

        mapper = salt.cloud.Map(self._opts_defaults(action=fun, names=names, **kwargs))
        if instance:
            if names:
                raise SaltCloudConfigError(
                    &quot;Please specify either a list of 'names' or a single &quot;
                    &quot;'instance', but not both.&quot;
                )
            names = [instance]

        if names and not provider:
            self.opts[&quot;action&quot;] = fun
            return mapper.do_action(names, kwargs)

        if provider and not names:
            return mapper.do_function(provider, fun, kwargs)
        else:
            # This should not be called without either an instance or a
            # provider. If both an instance/list of names and a provider
            # are given, then we also need to exit. We can only have one
            # or the other.
            raise SaltCloudConfigError(
                &quot;Either an instance (or list of names) or a provider must be &quot;
                &quot;specified, but not both.&quot;
            )


class Cloud:
    &quot;&quot;&quot;
    An object for the creation of new VMs
    &quot;&quot;&quot;

    def __init__(self, opts):
        self.opts = opts
        self.clouds = salt.loader.clouds(self.opts)
        self.__filter_non_working_providers()
        self.__cached_provider_queries = {}

    def get_configured_providers(self):
        &quot;&quot;&quot;
        Return the configured providers
        &quot;&quot;&quot;
        providers = set()
        for alias, drivers in self.opts[&quot;providers&quot;].items():
            if len(drivers) &gt; 1:
                for driver in drivers:
                    providers.add(&quot;{}:{}&quot;.format(alias, driver))
                continue
            providers.add(alias)
        return providers

    def lookup_providers(self, lookup):
        &quot;&quot;&quot;
        Get a dict describing the configured providers
        &quot;&quot;&quot;
        if lookup is None:
            lookup = &quot;all&quot;
        if lookup == &quot;all&quot;:
            providers = set()
            for alias, drivers in self.opts[&quot;providers&quot;].items():
                for driver in drivers:
                    providers.add((alias, driver))

            if not providers:
                raise SaltCloudSystemExit(&quot;There are no cloud providers configured.&quot;)

            return providers

        if &quot;:&quot; in lookup:
            alias, driver = lookup.split(&quot;:&quot;)
            if (
                alias not in self.opts[&quot;providers&quot;]
                or driver not in self.opts[&quot;providers&quot;][alias]
            ):
                raise SaltCloudSystemExit(
                    &quot;No cloud providers matched '{}'. Available: {}&quot;.format(
                        lookup, &quot;, &quot;.join(self.get_configured_providers())
                    )
                )

        providers = set()
        for alias, drivers in self.opts[&quot;providers&quot;].items():
            for driver in drivers:
                if lookup in (alias, driver):
                    providers.add((alias, driver))

        if not providers:
            raise SaltCloudSystemExit(
                &quot;No cloud providers matched '{}'. Available selections: {}&quot;.format(
                    lookup, &quot;, &quot;.join(self.get_configured_providers())
                )
            )
        return providers

    def lookup_profiles(self, provider, lookup):
        &quot;&quot;&quot;
        Return a dictionary describing the configured profiles
        &quot;&quot;&quot;
        if provider is None:
            provider = &quot;all&quot;
        if lookup is None:
            lookup = &quot;all&quot;

        if lookup == &quot;all&quot;:
            profiles = set()
            provider_profiles = set()
            for alias, info in self.opts[&quot;profiles&quot;].items():
                providers = info.get(&quot;provider&quot;)

                if providers:
                    given_prov_name = providers.split(&quot;:&quot;)[0]
                    salt_prov_name = providers.split(&quot;:&quot;)[1]
                    if given_prov_name == provider:
                        provider_profiles.add((alias, given_prov_name))
                    elif salt_prov_name == provider:
                        provider_profiles.add((alias, salt_prov_name))
                    profiles.add((alias, given_prov_name))

            if not profiles:
                raise SaltCloudSystemExit(&quot;There are no cloud profiles configured.&quot;)

            if provider != &quot;all&quot;:
                return provider_profiles

            return profiles

    def map_providers(self, query=&quot;list_nodes&quot;, cached=False):
        &quot;&quot;&quot;
        Return a mapping of what named VMs are running on what VM providers
        based on what providers are defined in the configuration and VMs
        &quot;&quot;&quot;
        if cached is True and query in self.__cached_provider_queries:
            return self.__cached_provider_queries[query]

        pmap = {}
        for alias, drivers in self.opts[&quot;providers&quot;].items():
            for driver, details in drivers.items():
                fun = &quot;{}.{}&quot;.format(driver, query)
                if fun not in self.clouds:
                    log.error(&quot;Public cloud provider %s is not available&quot;, driver)
                    continue
                if alias not in pmap:
                    pmap[alias] = {}

                try:
                    with salt.utils.context.func_globals_inject(
                        self.clouds[fun],
                        __active_provider_name__=&quot;:&quot;.join([alias, driver]),
                    ):
                        pmap[alias][driver] = self.clouds[fun]()
                except Exception as err:  # pylint: disable=broad-except
                    log.debug(
                        &quot;Failed to execute '%s()' while querying for running nodes: %s&quot;,
                        fun,
                        err,
                        exc_info_on_loglevel=logging.DEBUG,
                    )
                    # Failed to communicate with the provider, don't list any
                    # nodes
                    pmap[alias][driver] = []
        self.__cached_provider_queries[query] = pmap
        return pmap

    def map_providers_parallel(self, query=&quot;list_nodes&quot;, cached=False):
        &quot;&quot;&quot;
        Return a mapping of what named VMs are running on what VM providers
        based on what providers are defined in the configuration and VMs

        Same as map_providers but query in parallel.
        &quot;&quot;&quot;
        if cached is True and query in self.__cached_provider_queries:
            return self.__cached_provider_queries[query]

        opts = self.opts.copy()
        multiprocessing_data = []

        # Optimize Providers
        opts[&quot;providers&quot;] = self._optimize_providers(opts[&quot;providers&quot;])
        for alias, drivers in opts[&quot;providers&quot;].items():
            # Make temp query for this driver to avoid overwrite next
            this_query = query
            for driver, details in drivers.items():
                # If driver has function list_nodes_min, just replace it
                # with query param to check existing vms on this driver
                # for minimum information, Otherwise still use query param.
                if (
                    opts.get(&quot;selected_query_option&quot;) is None
                    and &quot;{}.list_nodes_min&quot;.format(driver) in self.clouds
                ):
                    this_query = &quot;list_nodes_min&quot;

                fun = &quot;{}.{}&quot;.format(driver, this_query)
                if fun not in self.clouds:
                    log.error(&quot;Public cloud provider %s is not available&quot;, driver)
                    continue

                multiprocessing_data.append(
                    {
                        &quot;fun&quot;: fun,
                        &quot;opts&quot;: opts,
                        &quot;query&quot;: this_query,
                        &quot;alias&quot;: alias,
                        &quot;driver&quot;: driver,
                    }
                )
        output = {}
        if not multiprocessing_data:
            return output

        data_count = len(multiprocessing_data)
        pool = multiprocessing.Pool(
            data_count &lt; 10 and data_count or 10, init_pool_worker
        )
        parallel_pmap = enter_mainloop(
            _run_parallel_map_providers_query, multiprocessing_data, pool=pool
        )
        for alias, driver, details in parallel_pmap:
            if not details:
                # There's no providers details?! Skip it!
                continue
            if alias not in output:
                output[alias] = {}
            output[alias][driver] = details

        self.__cached_provider_queries[query] = output
        return output

    def get_running_by_names(
        self, names, query=&quot;list_nodes&quot;, cached=False, profile=None
    ):
        if isinstance(names, str):
            names = [names]

        matches = {}
        handled_drivers = {}
        mapped_providers = self.map_providers_parallel(query, cached=cached)
        for alias, drivers in mapped_providers.items():
            for driver, vms in drivers.items():
                if driver not in handled_drivers:
                    handled_drivers[driver] = alias
                # When a profile is specified, only return an instance
                # that matches the provider specified in the profile.
                # This solves the issues when many providers return the
                # same instance. For example there may be one provider for
                # each availability zone in amazon in the same region, but
                # the search returns the same instance for each provider
                # because amazon returns all instances in a region, not
                # availability zone.
                if (
                    profile
                    and alias
                    not in self.opts[&quot;profiles&quot;][profile][&quot;provider&quot;].split(&quot;:&quot;)[0]
                ):
                    continue

                for vm_name, details in vms.items():
                    # XXX: The logic below can be removed once the aws driver
                    # is removed
                    if vm_name not in names:
                        continue

                    elif (
                        driver == &quot;ec2&quot;
                        and &quot;aws&quot; in handled_drivers
                        and &quot;aws&quot; in matches[handled_drivers[&quot;aws&quot;]]
                        and vm_name in matches[handled_drivers[&quot;aws&quot;]][&quot;aws&quot;]
                    ):
                        continue
                    elif (
                        driver == &quot;aws&quot;
                        and &quot;ec2&quot; in handled_drivers
                        and &quot;ec2&quot; in matches[handled_drivers[&quot;ec2&quot;]]
                        and vm_name in matches[handled_drivers[&quot;ec2&quot;]][&quot;ec2&quot;]
                    ):
                        continue

                    if alias not in matches:
                        matches[alias] = {}
                    if driver not in matches[alias]:
                        matches[alias][driver] = {}
                    matches[alias][driver][vm_name] = details

        return matches

    def _optimize_providers(self, providers):
        &quot;&quot;&quot;
        Return an optimized mapping of available providers
        &quot;&quot;&quot;
        new_providers = {}
        provider_by_driver = {}

        for alias, driver in providers.items():
            for name, data in driver.items():
                if name not in provider_by_driver:
                    provider_by_driver[name] = {}

                provider_by_driver[name][alias] = data

        for driver, providers_data in provider_by_driver.items():
            fun = &quot;{}.optimize_providers&quot;.format(driver)
            if fun not in self.clouds:
                log.debug(&quot;The '%s' cloud driver is unable to be optimized.&quot;, driver)

                for name, prov_data in providers_data.items():
                    if name not in new_providers:
                        new_providers[name] = {}
                    new_providers[name][driver] = prov_data
                continue

            new_data = self.clouds[fun](providers_data)
            if new_data:
                for name, prov_data in new_data.items():
                    if name not in new_providers:
                        new_providers[name] = {}
                    new_providers[name][driver] = prov_data

        return new_providers

    def location_list(self, lookup=&quot;all&quot;):
        &quot;&quot;&quot;
        Return a mapping of all location data for available providers
        &quot;&quot;&quot;
        data = {}

        lookups = self.lookup_providers(lookup)
        if not lookups:
            return data

        for alias, driver in lookups:
            fun = &quot;{}.avail_locations&quot;.format(driver)
            if fun not in self.clouds:
                # The capability to gather locations is not supported by this
                # cloud module
                log.debug(
                    &quot;The '%s' cloud driver defined under '%s' provider &quot;
                    &quot;alias is unable to get the locations information&quot;,
                    driver,
                    alias,
                )
                continue

            if alias not in data:
                data[alias] = {}

            try:

                with salt.utils.context.func_globals_inject(
                    self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
                ):
                    data[alias][driver] = self.clouds[fun]()
            except Exception as err:  # pylint: disable=broad-except
                log.error(
                    &quot;Failed to get the output of '%s()': %s&quot;,
                    fun,
                    err,
                    exc_info_on_loglevel=logging.DEBUG,
                )
        return data

    def image_list(self, lookup=&quot;all&quot;):
        &quot;&quot;&quot;
        Return a mapping of all image data for available providers
        &quot;&quot;&quot;
        data = {}

        lookups = self.lookup_providers(lookup)
        if not lookups:
            return data

        for alias, driver in lookups:
            fun = &quot;{}.avail_images&quot;.format(driver)
            if fun not in self.clouds:
                # The capability to gather images is not supported by this
                # cloud module
                log.debug(
                    &quot;The '%s' cloud driver defined under '%s' provider &quot;
                    &quot;alias is unable to get the images information&quot;,
                    driver,
                    alias,
                )
                continue

            if alias not in data:
                data[alias] = {}

            try:
                with salt.utils.context.func_globals_inject(
                    self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
                ):
                    data[alias][driver] = self.clouds[fun]()
            except Exception as err:  # pylint: disable=broad-except
                log.error(
                    &quot;Failed to get the output of '%s()': %s&quot;,
                    fun,
                    err,
                    exc_info_on_loglevel=logging.DEBUG,
                )
        return data

    def size_list(self, lookup=&quot;all&quot;):
        &quot;&quot;&quot;
        Return a mapping of all image data for available providers
        &quot;&quot;&quot;
        data = {}

        lookups = self.lookup_providers(lookup)
        if not lookups:
            return data

        for alias, driver in lookups:
            fun = &quot;{}.avail_sizes&quot;.format(driver)
            if fun not in self.clouds:
                # The capability to gather sizes is not supported by this
                # cloud module
                log.debug(
                    &quot;The '%s' cloud driver defined under '%s' provider &quot;
                    &quot;alias is unable to get the sizes information&quot;,
                    driver,
                    alias,
                )
                continue

            if alias not in data:
                data[alias] = {}

            try:
                with salt.utils.context.func_globals_inject(
                    self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
                ):
                    data[alias][driver] = self.clouds[fun]()
            except Exception as err:  # pylint: disable=broad-except
                log.error(
                    &quot;Failed to get the output of '%s()': %s&quot;,
                    fun,
                    err,
                    exc_info_on_loglevel=logging.DEBUG,
                )
        return data

    def provider_list(self, lookup=&quot;all&quot;):
        &quot;&quot;&quot;
        Return a mapping of all image data for available providers
        &quot;&quot;&quot;
        data = {}
        lookups = self.lookup_providers(lookup)
        if not lookups:
            return data

        for alias, driver in lookups:
            if alias not in data:
                data[alias] = {}
            if driver not in data[alias]:
                data[alias][driver] = {}
        return data

    def profile_list(self, provider, lookup=&quot;all&quot;):
        &quot;&quot;&quot;
        Return a mapping of all configured profiles
        &quot;&quot;&quot;
        data = {}
        lookups = self.lookup_profiles(provider, lookup)

        if not lookups:
            return data

        for alias, driver in lookups:
            if alias not in data:
                data[alias] = {}
            if driver not in data[alias]:
                data[alias][driver] = {}
        return data

    def create_all(self):
        &quot;&quot;&quot;
        Create/Verify the VMs in the VM data
        &quot;&quot;&quot;
        ret = []

        for vm_name, vm_details in self.opts[&quot;profiles&quot;].items():
            ret.append({vm_name: self.create(vm_details)})

        return ret

    def destroy(self, names, cached=False):
        &quot;&quot;&quot;
        Destroy the named VMs
        &quot;&quot;&quot;
        processed = {}
        names = set(names)
        matching = self.get_running_by_names(names, cached=cached)
        vms_to_destroy = set()
        parallel_data = []
        for alias, drivers in matching.items():
            for driver, vms in drivers.items():
                for name in vms:
                    if name in names:
                        vms_to_destroy.add((alias, driver, name))
                        if self.opts[&quot;parallel&quot;]:
                            parallel_data.append(
                                {
                                    &quot;opts&quot;: self.opts,
                                    &quot;name&quot;: name,
                                    &quot;alias&quot;: alias,
                                    &quot;driver&quot;: driver,
                                }
                            )

        # destroying in parallel
        if self.opts[&quot;parallel&quot;] and parallel_data:
            # set the pool size based on configuration or default to
            # the number of machines we're destroying
            if &quot;pool_size&quot; in self.opts:
                pool_size = self.opts[&quot;pool_size&quot;]
            else:
                pool_size = len(parallel_data)
            log.info(&quot;Destroying in parallel mode; Cloud pool size: %s&quot;, pool_size)

            # kick off the parallel destroy
            output_multip = enter_mainloop(
                _destroy_multiprocessing, parallel_data, pool_size=pool_size
            )

            # massage the multiprocessing output a bit
            ret_multip = {}
            for obj in output_multip:
                ret_multip.update(obj)

            # build up a data structure similar to what the non-parallel
            # destroy uses
            for obj in parallel_data:
                alias = obj[&quot;alias&quot;]
                driver = obj[&quot;driver&quot;]
                name = obj[&quot;name&quot;]
                if alias not in processed:
                    processed[alias] = {}
                if driver not in processed[alias]:
                    processed[alias][driver] = {}
                processed[alias][driver][name] = ret_multip[name]
                if name in names:
                    names.remove(name)

        # not destroying in parallel
        else:
            log.info(&quot;Destroying in non-parallel mode.&quot;)
            for alias, driver, name in vms_to_destroy:
                fun = &quot;{}.destroy&quot;.format(driver)
                with salt.utils.context.func_globals_inject(
                    self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
                ):
                    ret = self.clouds[fun](name)
                if alias not in processed:
                    processed[alias] = {}
                if driver not in processed[alias]:
                    processed[alias][driver] = {}
                processed[alias][driver][name] = ret
                if name in names:
                    names.remove(name)

        # now the processed data structure contains the output from either
        # the parallel or non-parallel destroy and we should finish up
        # with removing minion keys if necessary
        for alias, driver, name in vms_to_destroy:
            ret = processed[alias][driver][name]
            if not ret:
                continue

            vm_ = {
                &quot;name&quot;: name,
                &quot;profile&quot;: None,
                &quot;provider&quot;: &quot;:&quot;.join([alias, driver]),
                &quot;driver&quot;: driver,
            }
            minion_dict = salt.config.get_cloud_config_value(
                &quot;minion&quot;, vm_, self.opts, default={}
            )
            key_file = os.path.join(
                self.opts[&quot;pki_dir&quot;], &quot;minions&quot;, minion_dict.get(&quot;id&quot;, name)
            )
            globbed_key_file = glob.glob(&quot;{}.*&quot;.format(key_file))

            if not os.path.isfile(key_file) and not globbed_key_file:
                # There's no such key file!? It might have been renamed
                if isinstance(ret, dict) and &quot;newname&quot; in ret:
                    salt.utils.cloud.remove_key(self.opts[&quot;pki_dir&quot;], ret[&quot;newname&quot;])
                continue

            if os.path.isfile(key_file) and not globbed_key_file:
                # Single key entry. Remove it!
                salt.utils.cloud.remove_key(
                    self.opts[&quot;pki_dir&quot;], os.path.basename(key_file)
                )
                continue

            # Since we have globbed matches, there are probably some keys for which their minion
            # configuration has append_domain set.
            if (
                not os.path.isfile(key_file)
                and globbed_key_file
                and len(globbed_key_file) == 1
            ):
                # Single entry, let's remove it!
                salt.utils.cloud.remove_key(
                    self.opts[&quot;pki_dir&quot;], os.path.basename(globbed_key_file[0])
                )
                continue

            # Since we can't get the profile or map entry used to create
            # the VM, we can't also get the append_domain setting.
            # And if we reached this point, we have several minion keys
            # who's name starts with the machine name we're deleting.
            # We need to ask one by one!?
            print(
                &quot;There are several minion keys who's name starts &quot;
                &quot;with '{}'. We need to ask you which one should be &quot;
                &quot;deleted:&quot;.format(name)
            )
            while True:
                for idx, filename in enumerate(globbed_key_file):
                    print(&quot; {}: {}&quot;.format(idx, os.path.basename(filename)))
                selection = input(&quot;Which minion key should be deleted(number)? &quot;)
                try:
                    selection = int(selection)
                except ValueError:
                    print(&quot;'{}' is not a valid selection.&quot;.format(selection))

                try:
                    filename = os.path.basename(globbed_key_file.pop(selection))
                except Exception:  # pylint: disable=broad-except
                    continue

                delete = input(&quot;Delete '{}'? [Y/n]? &quot;.format(filename))
                if delete == &quot;&quot; or delete.lower().startswith(&quot;y&quot;):
                    salt.utils.cloud.remove_key(self.opts[&quot;pki_dir&quot;], filename)
                    print(&quot;Deleted '{}'&quot;.format(filename))
                    break

                print(&quot;Did not delete '{}'&quot;.format(filename))
                break

        if names and not processed:
            # These machines were asked to be destroyed but could not be found
            raise SaltCloudSystemExit(
                &quot;The following VM's were not found: {}&quot;.format(&quot;, &quot;.join(names))
            )

        elif names and processed:
            processed[&quot;Not Found&quot;] = names

        elif not processed:
            raise SaltCloudSystemExit(&quot;No machines were destroyed!&quot;)

        return processed

    def reboot(self, names):
        &quot;&quot;&quot;
        Reboot the named VMs
        &quot;&quot;&quot;
        ret = []
        pmap = self.map_providers_parallel()
        acts = {}
        for prov, nodes in pmap.items():
            acts[prov] = []
            for node in nodes:
                if node in names:
                    acts[prov].append(node)
        for prov, names_ in acts.items():
            fun = &quot;{}.reboot&quot;.format(prov)
            for name in names_:
                ret.append({name: self.clouds[fun](name)})

        return ret

    def create(self, vm_, local_master=True):
        &quot;&quot;&quot;
        Create a single VM
        &quot;&quot;&quot;
        output = {}

        minion_dict = salt.config.get_cloud_config_value(
            &quot;minion&quot;, vm_, self.opts, default={}
        )

        alias, driver = vm_[&quot;provider&quot;].split(&quot;:&quot;)
        fun = &quot;{}.create&quot;.format(driver)
        if fun not in self.clouds:
            log.error(
                &quot;Creating '%s' using '%s' as the provider &quot;
                &quot;cannot complete since '%s' is not available&quot;,
                vm_[&quot;name&quot;],
                vm_[&quot;provider&quot;],
                driver,
            )
            return

        deploy = salt.config.get_cloud_config_value(&quot;deploy&quot;, vm_, self.opts)
        make_master = salt.config.get_cloud_config_value(&quot;make_master&quot;, vm_, self.opts)

        if deploy:
            if not make_master and &quot;master&quot; not in minion_dict:
                log.warning(
                    &quot;There's no master defined on the '%s' VM settings.&quot;, vm_[&quot;name&quot;]
                )

            if &quot;pub_key&quot; not in vm_ and &quot;priv_key&quot; not in vm_:
                log.debug(&quot;Generating minion keys for '%s'&quot;, vm_[&quot;name&quot;])
                priv, pub = salt.utils.cloud.gen_keys(
                    salt.config.get_cloud_config_value(&quot;keysize&quot;, vm_, self.opts)
                )
                vm_[&quot;pub_key&quot;] = pub
                vm_[&quot;priv_key&quot;] = priv
        else:
            # Note(pabelanger): We still reference pub_key and priv_key when
            # deploy is disabled.
            vm_[&quot;pub_key&quot;] = None
            vm_[&quot;priv_key&quot;] = None

        key_id = minion_dict.get(&quot;id&quot;, vm_[&quot;name&quot;])

        domain = vm_.get(&quot;domain&quot;)
        if vm_.get(&quot;use_fqdn&quot;) and domain:
            minion_dict[&quot;append_domain&quot;] = domain

        if &quot;append_domain&quot; in minion_dict:
            key_id = &quot;.&quot;.join([key_id, minion_dict[&quot;append_domain&quot;]])

        if make_master is True and &quot;master_pub&quot; not in vm_ and &quot;master_pem&quot; not in vm_:
            log.debug(&quot;Generating the master keys for '%s'&quot;, vm_[&quot;name&quot;])
            master_priv, master_pub = salt.utils.cloud.gen_keys(
                salt.config.get_cloud_config_value(&quot;keysize&quot;, vm_, self.opts)
            )
            vm_[&quot;master_pub&quot;] = master_pub
            vm_[&quot;master_pem&quot;] = master_priv

        if local_master is True and deploy is True:
            # Accept the key on the local master
            salt.utils.cloud.accept_key(self.opts[&quot;pki_dir&quot;], vm_[&quot;pub_key&quot;], key_id)

        vm_[&quot;os&quot;] = salt.config.get_cloud_config_value(&quot;script&quot;, vm_, self.opts)

        try:
            vm_[&quot;inline_script&quot;] = salt.config.get_cloud_config_value(
                &quot;inline_script&quot;, vm_, self.opts
            )
        except KeyError:
            pass

        try:
            alias, driver = vm_[&quot;provider&quot;].split(&quot;:&quot;)
            func = &quot;{}.create&quot;.format(driver)
            with salt.utils.context.func_globals_inject(
                self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
            ):
                output = self.clouds[func](vm_)
            if output is not False and &quot;sync_after_install&quot; in self.opts:
                if self.opts[&quot;sync_after_install&quot;] not in (
                    &quot;all&quot;,
                    &quot;modules&quot;,
                    &quot;states&quot;,
                    &quot;grains&quot;,
                ):
                    log.error(&quot;Bad option for sync_after_install&quot;)
                    return output

                # A small pause helps the sync work more reliably
                time.sleep(3)

                start = int(time.time())
                while int(time.time()) &lt; start + 60:
                    # We'll try every &lt;timeout&gt; seconds, up to a minute
                    mopts_ = salt.config.DEFAULT_MASTER_OPTS
                    conf_path = &quot;/&quot;.join(self.opts[&quot;conf_file&quot;].split(&quot;/&quot;)[:-1])
                    mopts_.update(
                        salt.config.master_config(os.path.join(conf_path, &quot;master&quot;))
                    )

                    with salt.client.get_local_client(mopts=mopts_) as client:
                        ret = client.cmd(
                            vm_[&quot;name&quot;],
                            &quot;saltutil.sync_{}&quot;.format(self.opts[&quot;sync_after_install&quot;]),
                            timeout=self.opts[&quot;timeout&quot;],
                        )
                        if ret:
                            log.info(
                                &quot;Synchronized the following dynamic modules: %s&quot;, ret
                            )
                            break
        except KeyError as exc:
            log.exception(
                &quot;Failed to create VM %s. Configuration value %s needs to be set&quot;,
                vm_[&quot;name&quot;],
                exc,
            )
        # If it's a map then we need to respect the 'requires'
        # so we do it later
        try:
            opt_map = self.opts[&quot;map&quot;]
        except KeyError:
            opt_map = False
        if self.opts[&quot;parallel&quot;] and self.opts[&quot;start_action&quot;] and not opt_map:
            log.info(&quot;Running %s on %s&quot;, self.opts[&quot;start_action&quot;], vm_[&quot;name&quot;])
            with salt.client.get_local_client(mopts=self.opts) as client:
                action_out = client.cmd(
                    vm_[&quot;name&quot;],
                    self.opts[&quot;start_action&quot;],
                    timeout=self.opts[&quot;timeout&quot;] * 60,
                )
            output[&quot;ret&quot;] = action_out
        return output

    @staticmethod
    def vm_config(name, main, provider, profile, overrides):
        &quot;&quot;&quot;
        Create vm config.

        :param str name: The name of the vm
        :param dict main: The main cloud config
        :param dict provider: The provider config
        :param dict profile: The profile config
        :param dict overrides: The vm's config overrides
        &quot;&quot;&quot;
        vm = main.copy()
        vm = salt.utils.dictupdate.update(vm, provider)
        vm = salt.utils.dictupdate.update(vm, profile)
        vm.update(overrides)
        vm[&quot;name&quot;] = name
        return vm

    def extras(self, extra_):
        &quot;&quot;&quot;
        Extra actions
        &quot;&quot;&quot;
        output = {}

        alias, driver = extra_[&quot;provider&quot;].split(&quot;:&quot;)
        fun = &quot;{}.{}&quot;.format(driver, extra_[&quot;action&quot;])
        if fun not in self.clouds:
            log.error(
                &quot;Creating '%s' using '%s' as the provider &quot;
                &quot;cannot complete since '%s' is not available&quot;,
                extra_[&quot;name&quot;],
                extra_[&quot;provider&quot;],
                driver,
            )
            return

        try:
            with salt.utils.context.func_globals_inject(
                self.clouds[fun], __active_provider_name__=extra_[&quot;provider&quot;]
            ):
                output = self.clouds[fun](**extra_)
        except KeyError as exc:
            log.exception(
                &quot;Failed to perform %s.%s on %s. Configuration value %s needs to be set&quot;,
                extra_[&quot;provider&quot;],
                extra_[&quot;action&quot;],
                extra_[&quot;name&quot;],
                exc,
            )
        return output

    def run_profile(self, profile, names, vm_overrides=None):
        &quot;&quot;&quot;
        Parse over the options passed on the command line and determine how to
        handle them
        &quot;&quot;&quot;
        if profile not in self.opts[&quot;profiles&quot;]:
            msg = &quot;Profile {} is not defined&quot;.format(profile)
            log.error(msg)
            return {&quot;Error&quot;: msg}

        ret = {}
        if not vm_overrides:
            vm_overrides = {}

        try:
            with salt.utils.files.fopen(self.opts[&quot;conf_file&quot;], &quot;r&quot;) as mcc:
                main_cloud_config = salt.utils.yaml.safe_load(mcc)
            if not main_cloud_config:
                main_cloud_config = {}
        except KeyError:
            main_cloud_config = {}
        except OSError:
            main_cloud_config = {}

        if main_cloud_config is None:
            main_cloud_config = {}

        mapped_providers = self.map_providers_parallel()
        profile_details = self.opts[&quot;profiles&quot;][profile]
        vms = {}
        for prov, val in mapped_providers.items():
            prov_name = next(iter(val))
            for node in mapped_providers[prov][prov_name]:
                vms[node] = mapped_providers[prov][prov_name][node]
                vms[node][&quot;provider&quot;] = prov
                vms[node][&quot;driver&quot;] = prov_name
        alias, driver = profile_details[&quot;provider&quot;].split(&quot;:&quot;)

        provider_details = self.opts[&quot;providers&quot;][alias][driver].copy()
        del provider_details[&quot;profiles&quot;]

        for name in names:
            if name in vms:
                prov = vms[name][&quot;provider&quot;]
                driv = vms[name][&quot;driver&quot;]
                msg = &quot;{} already exists under {}:{}&quot;.format(name, prov, driv)
                log.error(msg)
                ret[name] = {&quot;Error&quot;: msg}
                continue

            vm_ = self.vm_config(
                name,
                main_cloud_config,
                provider_details,
                profile_details,
                vm_overrides,
            )
            if self.opts[&quot;parallel&quot;]:
                process = multiprocessing.Process(target=self.create, args=(vm_,))
                process.start()
                ret[name] = {
                    &quot;Provisioning&quot;: &quot;VM being provisioned in parallel. PID: {}&quot;.format(
                        process.pid
                    )
                }
                continue

            try:
                # No need to inject __active_provider_name__ into the context
                # here because self.create takes care of that
                ret[name] = self.create(vm_)
                if not ret[name]:
                    ret[name] = {&quot;Error&quot;: &quot;Failed to deploy VM&quot;}
                    if len(names) == 1:
                        raise SaltCloudSystemExit(&quot;Failed to deploy VM&quot;)
                    continue
                if self.opts.get(&quot;show_deploy_args&quot;, False) is False:
                    ret[name].pop(&quot;deploy_kwargs&quot;, None)
            except (SaltCloudSystemExit, SaltCloudConfigError) as exc:
                if len(names) == 1:
                    raise
                ret[name] = {&quot;Error&quot;: str(exc)}

        return ret

    def do_action(self, names, kwargs):
        &quot;&quot;&quot;
        Perform an action on a VM which may be specific to this cloud provider
        &quot;&quot;&quot;
        ret = {}
        invalid_functions = {}
        names = set(names)

        for alias, drivers in self.map_providers_parallel().items():
            if not names:
                break
            for driver, vms in drivers.items():
                if not names:
                    break
                valid_function = True
                fun = &quot;{}.{}&quot;.format(driver, self.opts[&quot;action&quot;])
                if fun not in self.clouds:
                    log.info(&quot;'%s()' is not available. Not actioning...&quot;, fun)
                    valid_function = False
                for vm_name, vm_details in vms.items():
                    if not names:
                        break
                    if vm_name not in names:
                        if not isinstance(vm_details, dict):
                            vm_details = {}
                        if &quot;id&quot; in vm_details and vm_details[&quot;id&quot;] in names:
                            vm_name = vm_details[&quot;id&quot;]
                        else:
                            log.debug(
                                &quot;vm:%s in provider:%s is not in name list:'%s'&quot;,
                                vm_name,
                                driver,
                                names,
                            )
                            continue

                    # Build the dictionary of invalid functions with their associated VMs.
                    if valid_function is False:
                        if invalid_functions.get(fun) is None:
                            invalid_functions.update({fun: []})
                        invalid_functions[fun].append(vm_name)
                        continue

                    with salt.utils.context.func_globals_inject(
                        self.clouds[fun],
                        __active_provider_name__=&quot;:&quot;.join([alias, driver]),
                    ):
                        if alias not in ret:
                            ret[alias] = {}
                        if driver not in ret[alias]:
                            ret[alias][driver] = {}

                        # Clean kwargs of &quot;__pub_*&quot; data before running the cloud action call.
                        # Prevents calling positional &quot;kwarg&quot; arg before &quot;call&quot; when no kwarg
                        # argument is present in the cloud driver function's arg spec.
                        kwargs = salt.utils.args.clean_kwargs(**kwargs)

                        if kwargs:
                            ret[alias][driver][vm_name] = self.clouds[fun](
                                vm_name, kwargs, call=&quot;action&quot;
                            )
                        else:
                            ret[alias][driver][vm_name] = self.clouds[fun](
                                vm_name, call=&quot;action&quot;
                            )
                        names.remove(vm_name)

        # Set the return information for the VMs listed in the invalid_functions dict.
        missing_vms = set()
        if invalid_functions:
            ret[&quot;Invalid Actions&quot;] = invalid_functions
            invalid_func_vms = set()
            for key, val in invalid_functions.items():
                invalid_func_vms = invalid_func_vms.union(set(val))

            # Find the VMs that are in names, but not in set of invalid functions.
            missing_vms = names.difference(invalid_func_vms)
            if missing_vms:
                ret[&quot;Not Found&quot;] = list(missing_vms)
                ret[&quot;Not Actioned/Not Running&quot;] = list(names)

        if not names:
            return ret

        # Don't return missing VM information for invalid functions until after we've had a
        # Chance to return successful actions. If a function is valid for one driver, but
        # Not another, we want to make sure the successful action is returned properly.
        if missing_vms:
            return ret

        # If we reach this point, the Not Actioned and Not Found lists will be the same,
        # But we want to list both for clarity/consistency with the invalid functions lists.
        ret[&quot;Not Actioned/Not Running&quot;] = list(names)
        ret[&quot;Not Found&quot;] = list(names)
        return ret

    def do_function(self, prov, func, kwargs):
        &quot;&quot;&quot;
        Perform a function against a cloud provider
        &quot;&quot;&quot;
        matches = self.lookup_providers(prov)
        if len(matches) &gt; 1:
            raise SaltCloudSystemExit(
                &quot;More than one results matched '{}'. Please specify one of: {}&quot;.format(
                    prov,
                    &quot;, &quot;.join(
                        [&quot;{}:{}&quot;.format(alias, driver) for (alias, driver) in matches]
                    ),
                )
            )

        alias, driver = matches.pop()
        fun = &quot;{}.{}&quot;.format(driver, func)
        if fun not in self.clouds:
            raise SaltCloudSystemExit(
                &quot;The '{}' cloud provider alias, for the '{}' driver, does &quot;
                &quot;not define the function '{}'&quot;.format(alias, driver, func)
            )

        log.debug(&quot;Trying to execute '%s' with the following kwargs: %s&quot;, fun, kwargs)

        with salt.utils.context.func_globals_inject(
            self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
        ):
            if kwargs:
                return {
                    alias: {driver: self.clouds[fun](call=&quot;function&quot;, kwargs=kwargs)}
                }
            return {alias: {driver: self.clouds[fun](call=&quot;function&quot;)}}

    def __filter_non_working_providers(self):
        &quot;&quot;&quot;
        Remove any mis-configured cloud providers from the available listing
        &quot;&quot;&quot;
        for alias, drivers in self.opts[&quot;providers&quot;].copy().items():
            for driver in drivers.copy():
                fun = &quot;{}.get_configured_provider&quot;.format(driver)
                if fun not in self.clouds:
                    # Mis-configured provider that got removed?
                    log.warning(
                        &quot;The cloud driver, '%s', configured under the &quot;
                        &quot;'%s' cloud provider alias, could not be loaded. &quot;
                        &quot;Please check your provider configuration files and &quot;
                        &quot;ensure all required dependencies are installed &quot;
                        &quot;for the '%s' driver.\n&quot;
                        &quot;In rare cases, this could indicate the '%s()' &quot;
                        &quot;function could not be found.\nRemoving '%s' from &quot;
                        &quot;the available providers list&quot;,
                        driver,
                        alias,
                        driver,
                        fun,
                        driver,
                    )
                    self.opts[&quot;providers&quot;][alias].pop(driver)

                    if alias not in self.opts[&quot;providers&quot;]:
                        continue

                    if not self.opts[&quot;providers&quot;][alias]:
                        self.opts[&quot;providers&quot;].pop(alias)
                    continue

                with salt.utils.context.func_globals_inject(
                    self.clouds[fun], __active_provider_name__=&quot;:&quot;.join([alias, driver])
                ):
                    if self.clouds[fun]() is False:
                        log.warning(
                            &quot;The cloud driver, '%s', configured under the &quot;
                            &quot;'%s' cloud provider alias is not properly &quot;
                            &quot;configured. Removing it from the available &quot;
                            &quot;providers list.&quot;,
                            driver,
                            alias,
                        )
                        self.opts[&quot;providers&quot;][alias].pop(driver)

            if alias not in self.opts[&quot;providers&quot;]:
                continue

            if not self.opts[&quot;providers&quot;][alias]:
                self.opts[&quot;providers&quot;].pop(alias)


class Map(Cloud):
    &quot;&quot;&quot;
    Create a VM stateful map execution object
    &quot;&quot;&quot;

    def __init__(self, opts):
        Cloud.__init__(self, opts)
        self.rendered_map = self.read()

    def interpolated_map(self, query=&quot;list_nodes&quot;, cached=False):
        rendered_map = self.read().copy()
        interpolated_map = {}

        for profile, mapped_vms in rendered_map.items():
            names = set(mapped_vms)
            if profile not in self.opts[&quot;profiles&quot;]:
                if &quot;Errors&quot; not in interpolated_map:
                    interpolated_map[&quot;Errors&quot;] = {}
                msg = (
                    &quot;No provider for the mapped '{}' profile was found. &quot;
                    &quot;Skipped VMS: {}&quot;.format(profile, &quot;, &quot;.join(names))
                )
                log.info(msg)
                interpolated_map[&quot;Errors&quot;][profile] = msg
                continue

            matching = self.get_running_by_names(names, query, cached)
            for alias, drivers in matching.items():
                for driver, vms in drivers.items():
                    for vm_name, vm_details in vms.items():
                        if alias not in interpolated_map:
                            interpolated_map[alias] = {}
                        if driver not in interpolated_map[alias]:
                            interpolated_map[alias][driver] = {}
                        interpolated_map[alias][driver][vm_name] = vm_details
                        try:
                            names.remove(vm_name)
                        except KeyError:
                            # If it's not there, then our job is already done
                            pass

            if not names:
                continue

            profile_details = self.opts[&quot;profiles&quot;][profile]
            alias, driver = profile_details[&quot;provider&quot;].split(&quot;:&quot;)
            for vm_name in names:
                if alias not in interpolated_map:
                    interpolated_map[alias] = {}
                if driver not in interpolated_map[alias]:
                    interpolated_map[alias][driver] = {}
                interpolated_map[alias][driver][vm_name] = &quot;Absent&quot;

        return interpolated_map

    def delete_map(self, query=None):
        query_map = self.interpolated_map(query=query)
        for alias, drivers in query_map.copy().items():
            if alias == &quot;Errors&quot;:
                continue
            for driver, vms in drivers.copy().items():
                for vm_name, vm_details in vms.copy().items():
                    if vm_details == &quot;Absent&quot;:
                        query_map[alias][driver].pop(vm_name)
                if not query_map[alias][driver]:
                    query_map[alias].pop(driver)
            if not query_map[alias]:
                query_map.pop(alias)
        return query_map

    def get_vmnames_by_action(self, action):
        query_map = self.interpolated_map(&quot;list_nodes&quot;)
        matching_states = {
            &quot;start&quot;: [&quot;stopped&quot;],
            &quot;stop&quot;: [&quot;running&quot;, &quot;active&quot;],
            &quot;reboot&quot;: [&quot;running&quot;, &quot;active&quot;],
        }
        vm_names = []
        for alias, drivers in query_map.items():
            for driver, vms in drivers.items():
                for vm_name, vm_details in vms.items():
                    # Only certain actions are support in to use in this case. Those actions are the
                    # &quot;Global&quot; salt-cloud actions defined in the &quot;matching_states&quot; dictionary above.
                    # If a more specific action is passed in, we shouldn't stack-trace - exit gracefully.
                    try:
                        state_action = matching_states[action]
                    except KeyError:
                        log.error(
                            &quot;The use of '%s' as an action is not supported &quot;
                            &quot;in this context. Only 'start', 'stop', and &quot;
                            &quot;'reboot' are supported options.&quot;,
                            action,
                        )
                        raise SaltCloudException()
                    if (
                        vm_details != &quot;Absent&quot;
                        and vm_details[&quot;state&quot;].lower() in state_action
                    ):
                        vm_names.append(vm_name)
        return vm_names

    def read(self):
        &quot;&quot;&quot;
        Read in the specified map and return the map structure
        &quot;&quot;&quot;
        map_ = None
        if self.opts.get(&quot;map&quot;, None) is None:
            if self.opts.get(&quot;map_data&quot;, None) is None:
                if self.opts.get(&quot;map_pillar&quot;, None) is None:
                    pass
                elif self.opts.get(&quot;map_pillar&quot;) not in self.opts.get(&quot;maps&quot;):
                    log.error(
                        &quot;The specified map not found in pillar at 'cloud:maps:%s'&quot;,
                        self.opts[&quot;map_pillar&quot;],
                    )
                    raise SaltCloudNotFound()
                else:
                    # 'map_pillar' is provided, try to use it
                    map_ = self.opts[&quot;maps&quot;][self.opts.get(&quot;map_pillar&quot;)]
            else:
                # 'map_data' is provided, try to use it
                map_ = self.opts[&quot;map_data&quot;]
        else:
            # 'map' is provided, try to use it
            local_minion_opts = copy.deepcopy(self.opts)
            local_minion_opts[&quot;file_client&quot;] = &quot;local&quot;
            self.minion = salt.minion.MasterMinion(local_minion_opts)

            if not os.path.isfile(self.opts[&quot;map&quot;]):
                if not (self.opts[&quot;map&quot;]).startswith(&quot;salt://&quot;):
                    log.error(
                        &quot;The specified map file does not exist: '%s'&quot;, self.opts[&quot;map&quot;]
                    )
                    raise SaltCloudNotFound()
            if (self.opts[&quot;map&quot;]).startswith(&quot;salt://&quot;):
                cached_map = self.minion.functions[&quot;cp.cache_file&quot;](self.opts[&quot;map&quot;])
            else:
                cached_map = self.opts[&quot;map&quot;]
            try:
                renderer = self.opts.get(&quot;renderer&quot;, &quot;jinja|yaml&quot;)
                rend = salt.loader.render(self.opts, {})
                blacklist = self.opts.get(&quot;renderer_blacklist&quot;)
                whitelist = self.opts.get(&quot;renderer_whitelist&quot;)
                map_ = compile_template(
                    cached_map, rend, renderer, blacklist, whitelist
                )
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Rendering map %s failed, render error:\n%s&quot;,
                    self.opts[&quot;map&quot;],
                    exc,
                    exc_info_on_loglevel=logging.DEBUG,
                )
                return {}

            if &quot;include&quot; in map_:
                map_ = salt.config.include_config(map_, self.opts[&quot;map&quot;], verbose=False)

        if not map_:
            return {}

        # Create expected data format if needed
        for profile, mapped in map_.copy().items():
            if isinstance(mapped, (list, tuple)):
                entries = {}
                for mapping in mapped:
                    if isinstance(mapping, str):
                        # Foo:
                        #   - bar1
                        #   - bar2
                        mapping = {mapping: None}
                    for name, overrides in mapping.items():
                        if overrides is None or isinstance(overrides, bool):
                            # Foo:
                            #   - bar1:
                            #   - bar2:
                            overrides = {}
                        try:
                            overrides.setdefault(&quot;name&quot;, name)
                        except AttributeError:
                            log.error(
                                &quot;Cannot use 'name' as a minion id in a cloud map as it&quot;
                                &quot; is a reserved word. Please change 'name' to a&quot;
                                &quot; different minion id reference.&quot;
                            )
                            return {}
                        entries[name] = overrides
                map_[profile] = entries
                continue

            if isinstance(mapped, dict):
                # Convert the dictionary mapping to a list of dictionaries
                # Foo:
                #  bar1:
                #    grains:
                #      foo: bar
                #  bar2:
                #    grains:
                #      foo: bar
                entries = {}
                for name, overrides in mapped.items():
                    overrides.setdefault(&quot;name&quot;, name)
                    entries[name] = overrides
                map_[profile] = entries
                continue

            if isinstance(mapped, str):
                # If it's a single string entry, let's make iterable because of
                # the next step
                mapped = [mapped]

            map_[profile] = {}
            for name in mapped:
                map_[profile][name] = {&quot;name&quot;: name}
        return map_

    def _has_loop(self, dmap, seen=None, val=None):
        if seen is None:
            for values in dmap[&quot;create&quot;].values():
                seen = []
                try:
                    machines = values[&quot;requires&quot;]
                except KeyError:
                    machines = []
                for machine in machines:
                    if self._has_loop(dmap, seen=list(seen), val=machine):
                        return True
        else:
            if val in seen:
                return True

            seen.append(val)
            try:
                machines = dmap[&quot;create&quot;][val][&quot;requires&quot;]
            except KeyError:
                machines = []

            for machine in machines:
                if self._has_loop(dmap, seen=list(seen), val=machine):
                    return True
        return False

    def _calcdep(self, dmap, machine, data, level):
        try:
            deplist = data[&quot;requires&quot;]
        except KeyError:
            return level
        levels = []
        for name in deplist:
            try:
                data = dmap[&quot;create&quot;][name]
            except KeyError:
                try:
                    data = dmap[&quot;existing&quot;][name]
                except KeyError:
                    msg = &quot;Missing dependency in cloud map&quot;
                    log.error(msg)
                    raise SaltCloudException(msg)
            levels.append(self._calcdep(dmap, name, data, level))
        level = max(levels) + 1
        return level

    def map_data(self, cached=False):
        &quot;&quot;&quot;
        Create a data map of what to execute on
        &quot;&quot;&quot;
        ret = {&quot;create&quot;: {}}
        pmap = self.map_providers_parallel(cached=cached)
        exist = set()
        defined = set()
        rendered_map = copy.deepcopy(self.rendered_map)
        for profile_name, nodes in rendered_map.items():
            if profile_name not in self.opts[&quot;profiles&quot;]:
                msg = (
                    &quot;The required profile, '{}', defined in the map &quot;
                    &quot;does not exist. The defined nodes, {}, will not &quot;
                    &quot;be created.&quot;.format(
                        profile_name, &quot;, &quot;.join(&quot;'{}'&quot;.format(node) for node in nodes)
                    )
                )
                log.error(msg)
                if &quot;errors&quot; not in ret:
                    ret[&quot;errors&quot;] = {}
                ret[&quot;errors&quot;][profile_name] = msg
                continue

            profile_data = self.opts[&quot;profiles&quot;].get(profile_name)

            for nodename, overrides in nodes.items():
                # Get associated provider data, in case something like size
                # or image is specified in the provider file. See issue #32510.
                if (
<A NAME="1"></A>                    &quot;provider&quot; in overrides
                    and overrides[&quot;provider&quot;] != profile_data[&quot;provider&quot;]
                ):
                    alias, driver = overrides<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match122344-1.html#1',3,'match122344-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get(&quot;provider&quot;).split(&quot;:&quot;)
                else:
                    alias, driver = profile_data.get(&quot;provider&quot;).split(&quot;:&quot;)

                provider_details = copy.deepcopy(self.opts[</B></FONT>&quot;providers&quot;][alias][driver])
                del provider_details[&quot;profiles&quot;]

                # Update the provider details information with profile data
                # Profile data and node overrides should override provider data, if defined.
                # This keeps map file data definitions consistent with -p usage.
                salt.utils.dictupdate.update(provider_details, profile_data)
                nodedata = copy.deepcopy(provider_details)

                # Update profile data with the map overrides
                for setting in (&quot;grains&quot;, &quot;master&quot;, &quot;minion&quot;, &quot;volumes&quot;, &quot;requires&quot;):
                    deprecated = &quot;map_{}&quot;.format(setting)
                    if deprecated in overrides:
                        log.warning(
                            &quot;The use of '%s' on the '%s' mapping has &quot;
                            &quot;been deprecated. The preferred way now is to &quot;
                            &quot;just define '%s'. For now, salt-cloud will do &quot;
                            &quot;the proper thing and convert the deprecated &quot;
                            &quot;mapping into the preferred one.&quot;,
                            deprecated,
                            nodename,
                            setting,
                        )
                        overrides[setting] = overrides.pop(deprecated)

                # merge minion grains from map file
                if (
                    &quot;minion&quot; in overrides
                    and &quot;minion&quot; in nodedata
                    and &quot;grains&quot; in overrides[&quot;minion&quot;]
                    and &quot;grains&quot; in nodedata[&quot;minion&quot;]
                ):
                    nodedata[&quot;minion&quot;][&quot;grains&quot;].update(overrides[&quot;minion&quot;][&quot;grains&quot;])
                    del overrides[&quot;minion&quot;][&quot;grains&quot;]
                    # remove minion key if now is empty dict
                    if not overrides[&quot;minion&quot;]:
                        del overrides[&quot;minion&quot;]

                nodedata = salt.utils.dictupdate.update(nodedata, overrides)
                # Add the computed information to the return data
                ret[&quot;create&quot;][nodename] = nodedata
                # Add the node name to the defined set
                alias, driver = nodedata[&quot;provider&quot;].split(&quot;:&quot;)
                defined.add((alias, driver, nodename))

        def get_matching_by_name(name):
            matches = {}
            for alias, drivers in pmap.items():
                for driver, vms in drivers.items():
                    for vm_name, details in vms.items():
                        if vm_name == name and driver not in matches:
                            matches[driver] = details[&quot;state&quot;]
            return matches

        for alias, drivers in pmap.items():
            for driver, vms in drivers.items():
                for name, details in vms.items():
                    exist.add((alias, driver, name))
                    if name not in ret[&quot;create&quot;]:
                        continue

                    # The machine is set to be created. Does it already exist?
                    matching = get_matching_by_name(name)
                    if not matching:
                        continue

                    # A machine by the same name exists
                    for item in matching:
                        if name not in ret[&quot;create&quot;]:
                            # Machine already removed
                            break

                        log.warning(
                            &quot;%r already exists, removing from the create map.&quot;, name
                        )

                        if &quot;existing&quot; not in ret:
                            ret[&quot;existing&quot;] = {}
                        ret[&quot;existing&quot;][name] = ret[&quot;create&quot;].pop(name)

        if &quot;hard&quot; in self.opts and self.opts[&quot;hard&quot;]:
            if self.opts[&quot;enable_hard_maps&quot;] is False:
                raise SaltCloudSystemExit(
                    &quot;The --hard map can be extremely dangerous to use, &quot;
                    &quot;and therefore must explicitly be enabled in the main &quot;
                    &quot;configuration file, by setting 'enable_hard_maps' &quot;
                    &quot;to True&quot;
                )

            # Hard maps are enabled, Look for the items to delete.
            ret[&quot;destroy&quot;] = exist.difference(defined)
        return ret

    def run_map(self, dmap):
        &quot;&quot;&quot;
        Execute the contents of the VM map
        &quot;&quot;&quot;
        if self._has_loop(dmap):
            msg = &quot;Uh-oh, that cloud map has a dependency loop!&quot;
            log.error(msg)
            raise SaltCloudException(msg)
        # Go through the create list and calc dependencies
        for key, val in dmap[&quot;create&quot;].items():
            log.info(&quot;Calculating dependencies for %s&quot;, key)
            level = 0
            level = self._calcdep(dmap, key, val, level)
            log.debug(&quot;Got execution order %s for %s&quot;, level, key)
            dmap[&quot;create&quot;][key][&quot;level&quot;] = level

        try:
            existing_list = dmap[&quot;existing&quot;].items()
        except KeyError:
            existing_list = {}.items()

        for key, val in existing_list:
            log.info(&quot;Calculating dependencies for %s&quot;, key)
            level = 0
            level = self._calcdep(dmap, key, val, level)
            log.debug(&quot;Got execution order %s for %s&quot;, level, key)
            dmap[&quot;existing&quot;][key][&quot;level&quot;] = level

        # Now sort the create list based on dependencies
        create_list = sorted(dmap[&quot;create&quot;].items(), key=lambda x: x[1][&quot;level&quot;])
        output = {}
        if self.opts[&quot;parallel&quot;]:
            parallel_data = []
        master_name = None
        master_minion_name = None
        master_host = None
        master_finger = None
        try:
            master_name, master_profile = next(
                (
                    (name, profile)
                    for name, profile in create_list
                    if profile.get(&quot;make_master&quot;, False) is True
                )
            )
            master_minion_name = master_name
            log.debug(&quot;Creating new master '%s'&quot;, master_name)
            if (
                salt.config.get_cloud_config_value(&quot;deploy&quot;, master_profile, self.opts)
                is False
            ):
                raise SaltCloudSystemExit(
                    &quot;Cannot proceed with 'make_master' when salt deployment &quot;
                    &quot;is disabled(ex: --no-deploy).&quot;
                )

            # Generate the master keys
            log.debug(&quot;Generating master keys for '%s'&quot;, master_profile[&quot;name&quot;])
            priv, pub = salt.utils.cloud.gen_keys(
                salt.config.get_cloud_config_value(&quot;keysize&quot;, master_profile, self.opts)
            )
            master_profile[&quot;master_pub&quot;] = pub
            master_profile[&quot;master_pem&quot;] = priv

<A NAME="3"></A>            # Generate the fingerprint of the master pubkey in order to
            # mitigate man-in-the-middle attacks
            master_temp_pub = salt.utils.files.mkstemp()
            with salt<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match122344-1.html#3',3,'match122344-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.files.fopen(master_temp_pub, &quot;w&quot;) as mtp:
                mtp.write(pub)
            master_finger = salt.utils.crypt.pem_finger(
                master_temp_pub, sum_type=</B></FONT>self.opts[&quot;hash_type&quot;]
            )
            os.unlink(master_temp_pub)

            if master_profile.get(&quot;make_minion&quot;, True) is True:
                master_profile.setdefault(&quot;minion&quot;, {})
                if &quot;id&quot; in master_profile[&quot;minion&quot;]:
                    master_minion_name = master_profile[&quot;minion&quot;][&quot;id&quot;]
                # Set this minion's master as local if the user has not set it
                if &quot;master&quot; not in master_profile[&quot;minion&quot;]:
                    master_profile[&quot;minion&quot;][&quot;master&quot;] = &quot;127.0.0.1&quot;
                    if master_finger is not None:
                        master_profile[&quot;master_finger&quot;] = master_finger

            # Generate the minion keys to pre-seed the master:
            for name, profile in create_list:
                make_minion = salt.config.get_cloud_config_value(
                    &quot;make_minion&quot;, profile, self.opts, default=True
                )
                if make_minion is False:
                    continue

                log.debug(&quot;Generating minion keys for '%s'&quot;, profile[&quot;name&quot;])
                priv, pub = salt.utils.cloud.gen_keys(
                    salt.config.get_cloud_config_value(&quot;keysize&quot;, profile, self.opts)
                )
                profile[&quot;pub_key&quot;] = pub
                profile[&quot;priv_key&quot;] = priv
                # Store the minion's public key in order to be pre-seeded in
                # the master
                master_profile.setdefault(&quot;preseed_minion_keys&quot;, {})
                master_profile[&quot;preseed_minion_keys&quot;].update({name: pub})

            local_master = False
            if (
                master_profile[&quot;minion&quot;].get(&quot;local_master&quot;, False)
                and master_profile[&quot;minion&quot;].get(&quot;master&quot;, None) is not None
            ):
                # The minion is explicitly defining a master and it's
                # explicitly saying it's the local one
                local_master = True

            out = self.create(master_profile, local_master=local_master)

            if not isinstance(out, dict):
                log.debug(&quot;Master creation details is not a dictionary: %s&quot;, out)

            elif &quot;Errors&quot; in out:
                raise SaltCloudSystemExit(
                    &quot;An error occurred while creating the master, not &quot;
                    &quot;continuing: {}&quot;.format(out[&quot;Errors&quot;])
                )

            deploy_kwargs = (
                self.opts.get(&quot;show_deploy_args&quot;, False) is True
                and
                # Get the needed data
                out.get(&quot;deploy_kwargs&quot;, {})
                or
                # Strip the deploy_kwargs from the returned data since we don't
                # want it shown in the console.
                out.pop(&quot;deploy_kwargs&quot;, {})
            )

            master_host = deploy_kwargs.get(
                &quot;salt_host&quot;, deploy_kwargs.get(&quot;host&quot;, None)
            )
            if master_host is None:
                raise SaltCloudSystemExit(
                    &quot;Host for new master {} was not found, aborting map&quot;.format(
                        master_name
                    )
                )
            output[master_name] = out
        except StopIteration:
            log.debug(&quot;No make_master found in map&quot;)
            # Local master?
            # Generate the fingerprint of the master pubkey in order to
            # mitigate man-in-the-middle attacks
            master_pub = os.path.join(self.opts[&quot;pki_dir&quot;], &quot;master.pub&quot;)
            if os.path.isfile(master_pub):
                master_finger = salt.utils.crypt.pem_finger(
                    master_pub, sum_type=self.opts[&quot;hash_type&quot;]
                )

        opts = self.opts.copy()
        if self.opts[&quot;parallel&quot;]:
            # Force display_ssh_output to be False since the console will
            # need to be reset afterwards
            log.info(
                &quot;Since parallel deployment is in use, ssh console output &quot;
                &quot;is disabled. All ssh output will be logged though&quot;
            )
            opts[&quot;display_ssh_output&quot;] = False

        local_master = master_name is None

        for name, profile in create_list:
            if name in (master_name, master_minion_name):
                # Already deployed, it's the master's minion
                continue

            if (
                &quot;minion&quot; in profile
                and profile[&quot;minion&quot;].get(&quot;local_master&quot;, False)
                and profile[&quot;minion&quot;].get(&quot;master&quot;, None) is not None
            ):
                # The minion is explicitly defining a master and it's
                # explicitly saying it's the local one
                local_master = True

            if master_finger is not None and local_master is False:
                profile[&quot;master_finger&quot;] = master_finger

            if master_host is not None:
                profile.setdefault(&quot;minion&quot;, {})
                profile[&quot;minion&quot;].setdefault(&quot;master&quot;, master_host)

            if self.opts[&quot;parallel&quot;]:
                parallel_data.append(
                    {
                        &quot;opts&quot;: opts,
                        &quot;name&quot;: name,
                        &quot;profile&quot;: profile,
                        &quot;local_master&quot;: local_master,
                    }
                )
                continue

            # Not deploying in parallel
            try:
                output[name] = self.create(profile, local_master=local_master)
                if (
                    self.opts.get(&quot;show_deploy_args&quot;, False) is False
                    and &quot;deploy_kwargs&quot; in output
                    and isinstance(output[name], dict)
                ):
                    output[name].pop(&quot;deploy_kwargs&quot;, None)
            except SaltCloudException as exc:
                log.error(
                    &quot;Failed to deploy '%s'. Error: %s&quot;,
                    name,
                    exc,
                    exc_info_on_loglevel=logging.DEBUG,
                )
                output[name] = {&quot;Error&quot;: str(exc)}

        for name in dmap.get(&quot;destroy&quot;, ()):
            output[name] = self.destroy(name)

        if self.opts[&quot;parallel&quot;] and parallel_data:
            if &quot;pool_size&quot; in self.opts:
                pool_size = self.opts[&quot;pool_size&quot;]
            else:
                pool_size = len(parallel_data)
            log.info(&quot;Cloud pool size: %s&quot;, pool_size)
            output_multip = enter_mainloop(
                _create_multiprocessing, parallel_data, pool_size=pool_size
            )
            # We have deployed in parallel, now do start action in
            # correct order based on dependencies.
            if self.opts[&quot;start_action&quot;]:
                actionlist = []
                grp = -1
                for key, val in groupby(dmap[&quot;create&quot;].values(), lambda x: x[&quot;level&quot;]):
                    actionlist.append([])
                    grp += 1
                    for item in val:
                        actionlist[grp].append(item[&quot;name&quot;])

                out = {}
                for group in actionlist:
                    log.info(
                        &quot;Running %s on %s&quot;, self.opts[&quot;start_action&quot;], &quot;, &quot;.join(group)
                    )
                    with salt.client.get_local_client() as client:
                        out.update(
                            client.cmd(
                                &quot;,&quot;.join(group),
                                self.opts[&quot;start_action&quot;],
                                timeout=self.opts[&quot;timeout&quot;] * 60,
                                tgt_type=&quot;list&quot;,
                            )
                        )
                for obj in output_multip:
                    next(iter(obj.values()))[&quot;ret&quot;] = out[next(iter(obj.keys()))]
                    output.update(obj)
            else:
                for obj in output_multip:
                    output.update(obj)

        return output


def init_pool_worker():
    &quot;&quot;&quot;
    Make every worker ignore KeyboarInterrup's since it will be handled by the
    parent process.
    &quot;&quot;&quot;
    signal.signal(signal.SIGINT, signal.SIG_IGN)


def create_multiprocessing(parallel_data, queue=None):
    &quot;&quot;&quot;
    This function will be called from another process when running a map in
    parallel mode. The result from the create is always a json object.
    &quot;&quot;&quot;
    salt.utils.crypt.reinit_crypto()

    parallel_data[&quot;opts&quot;][&quot;output&quot;] = &quot;json&quot;
    cloud = Cloud(parallel_data[&quot;opts&quot;])
    try:
        output = cloud.create(
            parallel_data[&quot;profile&quot;], local_master=parallel_data[&quot;local_master&quot;]
        )
    except SaltCloudException as exc:
        log.error(
            &quot;Failed to deploy '%s'. Error: %s&quot;,
            parallel_data[&quot;name&quot;],
            exc,
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {parallel_data[&quot;name&quot;]: {&quot;Error&quot;: str(exc)}}

    if parallel_data[&quot;opts&quot;].get(&quot;show_deploy_args&quot;, False) is False and isinstance(
        output, dict
    ):
        output.pop(&quot;deploy_kwargs&quot;, None)

    return {parallel_data[&quot;name&quot;]: salt.utils.data.simple_types_filter(output)}


def destroy_multiprocessing(parallel_data, queue=None):
    &quot;&quot;&quot;
    This function will be called from another process when running a map in
    parallel mode. The result from the destroy is always a json object.
    &quot;&quot;&quot;
    salt.utils.crypt.reinit_crypto()

    parallel_data[&quot;opts&quot;][&quot;output&quot;] = &quot;json&quot;
    clouds = salt.loader.clouds(parallel_data[&quot;opts&quot;])

    try:
        fun = clouds[&quot;{}.destroy&quot;.format(parallel_data[&quot;driver&quot;])]
        with salt.utils.context.func_globals_inject(
            fun,
            __active_provider_name__=&quot;:&quot;.join(
                [parallel_data[&quot;alias&quot;], parallel_data[&quot;driver&quot;]]
            ),
        ):
            output = fun(parallel_data[&quot;name&quot;])

    except SaltCloudException as exc:
        log.error(
            &quot;Failed to destroy %s. Error: %s&quot;,
            parallel_data[&quot;name&quot;],
            exc,
            exc_info_on_loglevel=logging.DEBUG,
        )
        return {parallel_data[&quot;name&quot;]: {&quot;Error&quot;: str(exc)}}

    return {parallel_data[&quot;name&quot;]: salt.utils.data.simple_types_filter(output)}


def run_parallel_map_providers_query(data, queue=None):
    &quot;&quot;&quot;
    This function will be called from another process when building the
    providers map.
    &quot;&quot;&quot;
    salt.utils.crypt.reinit_crypto()

    cloud = Cloud(data[&quot;opts&quot;])
    try:
        with salt.utils.context.func_globals_inject(
            cloud.clouds[data[&quot;fun&quot;]],
            __active_provider_name__=&quot;:&quot;.join([data[&quot;alias&quot;], data[&quot;driver&quot;]]),
        ):
            return (
                data[&quot;alias&quot;],
                data[&quot;driver&quot;],
                salt.utils.data.simple_types_filter(cloud.clouds[data[&quot;fun&quot;]]()),
            )
    except Exception as err:  # pylint: disable=broad-except
        log.debug(
            &quot;Failed to execute '%s()' while querying for running nodes: %s&quot;,
            data[&quot;fun&quot;],
            err,
            exc_info_on_loglevel=logging.DEBUG,
        )
        # Failed to communicate with the provider, don't list any nodes
        return data[&quot;alias&quot;], data[&quot;driver&quot;], ()


# for pickle and multiprocessing, we can't use directly decorators
def _run_parallel_map_providers_query(*args, **kw):
    return communicator(run_parallel_map_providers_query)(*args[0], **kw)


def _destroy_multiprocessing(*args, **kw):
    return communicator(destroy_multiprocessing)(*args[0], **kw)


def _create_multiprocessing(*args, **kw):
    return communicator(create_multiprocessing)(*args[0], **kw)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>templates.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A>&quot;&quot;&quot;
Template render systems
&quot;&quot;&quot;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match122344-0.html#0',2,'match122344-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import codecs
import logging
import os
import sys
import tempfile
import traceback
from pathlib import Path

import jinja2
import jinja2.ext
import jinja2.sandbox
import salt.utils.data
import salt.utils.dateutils
import salt.utils.files
import salt.utils.hashutils
import salt.utils.http
import salt.utils.jinja
import salt.utils.network
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.yamlencoding
from salt import __path__ as saltpath
from salt.exceptions import CommandExecutionError, SaltInvocationError, SaltRenderError
from salt.features import features
from salt.loader.context import NamedLoaderContext
from</B></FONT> salt.utils.decorators.jinja import JinjaFilter, JinjaGlobal, JinjaTest
from salt.utils.odict import OrderedDict
from salt.utils.versions import LooseVersion

if sys.version_info[:2] &gt;= (3, 5):
    import importlib.machinery  # pylint: disable=no-name-in-module,import-error
    import importlib.util  # pylint: disable=no-name-in-module,import-error

    USE_IMPORTLIB = True
else:
    import imp

    USE_IMPORTLIB = False


log = logging.getLogger(__name__)


TEMPLATE_DIRNAME = os.path.join(saltpath[0], &quot;templates&quot;)

# FIXME: also in salt/template.py
SLS_ENCODING = &quot;utf-8&quot;  # this one has no BOM.
SLS_ENCODER = codecs.getencoder(SLS_ENCODING)


class AliasedLoader:
    &quot;&quot;&quot;
    Light wrapper around the LazyLoader to redirect 'cmd.run' calls to
    'cmd.shell', for easy use of shellisms during templating calls

    Dotted aliases ('cmd.run') must resolve to another dotted alias
    (e.g. 'cmd.shell')

    Non-dotted aliases ('cmd') must resolve to a dictionary of function
    aliases for that module (e.g. {'run': 'shell'})
    &quot;&quot;&quot;

    def __init__(self, wrapped):
        self.wrapped = wrapped

    def __getitem__(self, name):
        return self.wrapped[name]

    def __getattr__(self, name):
        return getattr(self.wrapped, name)

    def __contains__(self, name):
        return name in self.wrapped


class AliasedModule:
    &quot;&quot;&quot;
    Light wrapper around module objects returned by the LazyLoader's getattr
    for the purposes of `salt.cmd.run()` syntax in templates

    Allows for aliasing specific functions, such as `run` to `shell` for easy
    use of shellisms during templating calls
    &quot;&quot;&quot;

    def __init__(self, wrapped, aliases):
        self.aliases = aliases
        self.wrapped = wrapped

    def __getattr__(self, name):
        return getattr(self.wrapped, name)


def _generate_sls_context_legacy(tmplpath, sls):
    &quot;&quot;&quot;
    Legacy version of generate_sls_context, this method should be remove in the
    Phosphorus release.
    &quot;&quot;&quot;
    salt.utils.versions.warn_until(
        &quot;Phosphorus&quot;,
        &quot;There have been significant improvement to template variables. &quot;
        &quot;To enable these improvements set features.enable_slsvars_fixes &quot;
        &quot;to True in your config file. This feature will become the default &quot;
        &quot;in the Phoshorus release.&quot;,
    )
    context = {}
    slspath = sls.replace(&quot;.&quot;, &quot;/&quot;)
    if tmplpath is not None:
        context[&quot;tplpath&quot;] = tmplpath
        if not tmplpath.lower().replace(&quot;\\&quot;, &quot;/&quot;).endswith(&quot;/init.sls&quot;):
            slspath = os.path.dirname(slspath)
        template = tmplpath.replace(&quot;\\&quot;, &quot;/&quot;)
        i = template.rfind(slspath.replace(&quot;.&quot;, &quot;/&quot;))
        if i != -1:
            template = template[i:]
        tpldir = os.path.dirname(template).replace(&quot;\\&quot;, &quot;/&quot;)
        tpldata = {
            &quot;tplfile&quot;: template,
            &quot;tpldir&quot;: &quot;.&quot; if tpldir == &quot;&quot; else tpldir,
            &quot;tpldot&quot;: tpldir.replace(&quot;/&quot;, &quot;.&quot;),
        }
        context.update(tpldata)
    context[&quot;slsdotpath&quot;] = slspath.replace(&quot;/&quot;, &quot;.&quot;)
    context[&quot;slscolonpath&quot;] = slspath.replace(&quot;/&quot;, &quot;:&quot;)
    context[&quot;sls_path&quot;] = slspath.replace(&quot;/&quot;, &quot;_&quot;)
    context[&quot;slspath&quot;] = slspath
    return context


def _generate_sls_context(tmplpath, sls):
    &quot;&quot;&quot;
    Generate SLS/Template Context Items

    Return values:

    tplpath - full path to template on filesystem including filename
    tplfile - relative path to template -- relative to file roots
    tpldir - directory of the template relative to file roots. If none, &quot;.&quot;
    tpldot - tpldir using dots instead of slashes, if none, &quot;&quot;
    slspath - directory containing current sls - (same as tpldir), if none, &quot;&quot;
    sls_path - slspath with underscores separating parts, if none, &quot;&quot;
    slsdotpath - slspath with dots separating parts, if none, &quot;&quot;
    slscolonpath- slspath with colons separating parts, if none, &quot;&quot;

    &quot;&quot;&quot;

    sls_context = {}

    # Normalize SLS as path.
    slspath = sls.replace(&quot;.&quot;, &quot;/&quot;)

    if tmplpath:
        # Normalize template path
        template = str(Path(tmplpath).as_posix())

        # Determine proper template name without root
        if not sls:
<A NAME="1"></A>            template = template.rsplit(&quot;/&quot;, 1)[-1]
        elif template.endswith(&quot;{}.sls&quot;.format(slspath)):
            template = template[-(4 + len(slspath)) :]
        elif template<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match122344-0.html#1',2,'match122344-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.endswith(&quot;{}/init.sls&quot;.format(slspath)):
            template = template[-(9 + len(slspath)) :]
        else:
            # Something went wrong
            log.warning(&quot;Failed to determine proper template path&quot;)

        slspath = template.rsplit(&quot;/&quot;, 1)[0] if &quot;/&quot; in template else &quot;&quot;

        sls_context.</B></FONT>update(
            dict(
                tplpath=tmplpath,
                tplfile=template,
                tpldir=slspath if slspath else &quot;.&quot;,
                tpldot=slspath.replace(&quot;/&quot;, &quot;.&quot;),
            )
        )

    # Should this be normalized?
    sls_context.update(
        dict(
            slspath=slspath,
            slsdotpath=slspath.replace(&quot;/&quot;, &quot;.&quot;),
            slscolonpath=slspath.replace(&quot;/&quot;, &quot;:&quot;),
            sls_path=slspath.replace(&quot;/&quot;, &quot;_&quot;),
        )
    )

    return sls_context


def generate_sls_context(tmplpath, sls):
    &quot;&quot;&quot;
    Generate SLS/Template Context Items

    Return values:

    tplpath - full path to template on filesystem including filename
    tplfile - relative path to template -- relative to file roots
    tpldir - directory of the template relative to file roots. If none, &quot;.&quot;
    tpldot - tpldir using dots instead of slashes, if none, &quot;&quot;
    slspath - directory containing current sls - (same as tpldir), if none, &quot;&quot;
    sls_path - slspath with underscores separating parts, if none, &quot;&quot;
    slsdotpath - slspath with dots separating parts, if none, &quot;&quot;
    slscolonpath- slspath with colons separating parts, if none, &quot;&quot;

    &quot;&quot;&quot;
    if not features.get(&quot;enable_slsvars_fixes&quot;, False):
        return _generate_sls_context_legacy(tmplpath, sls)
    return _generate_sls_context(tmplpath, sls)


def wrap_tmpl_func(render_str):
    &quot;&quot;&quot;
    Each template processing function below, ``render_*_tmpl``, is wrapped by
    ``render_tmpl`` before being inserted into the ``TEMPLATE_REGISTRY``.  Some
    actions are taken here that are common to all renderers.  Perhaps a
    standard decorator construct would have been more legible.

    :param function render_str: Template rendering function to be wrapped.
        Each function is responsible for rendering the source data for its
        repective template language.

    :returns function render_tmpl: The wrapper function
    &quot;&quot;&quot;

    def render_tmpl(
        tmplsrc, from_str=False, to_str=False, context=None, tmplpath=None, **kws
    ):

        if context is None:
            context = {}

        # Alias cmd.run to cmd.shell to make python_shell=True the default for
        # templated calls
        if &quot;salt&quot; in kws:
            kws[&quot;salt&quot;] = AliasedLoader(kws[&quot;salt&quot;])

        # We want explicit context to overwrite the **kws
        kws.update(context)
        context = kws
        assert &quot;opts&quot; in context
        assert &quot;saltenv&quot; in context

        if &quot;sls&quot; in context:
            sls_context = generate_sls_context(tmplpath, context[&quot;sls&quot;])
            context.update(sls_context)

        if isinstance(tmplsrc, str):
            if from_str:
                tmplstr = tmplsrc
            else:
                try:
                    if tmplpath is not None:
                        tmplsrc = os.path.join(tmplpath, tmplsrc)
                    with codecs.open(tmplsrc, &quot;r&quot;, SLS_ENCODING) as _tmplsrc:
                        tmplstr = _tmplsrc.read()
                except (UnicodeDecodeError, ValueError, OSError) as exc:
                    if salt.utils.files.is_binary(tmplsrc):
                        # Template is a bin file, return the raw file
                        return dict(result=True, data=tmplsrc)
                    log.error(
                        &quot;Exception occurred while reading file %s: %s&quot;,
                        tmplsrc,
                        exc,
                        exc_info_on_loglevel=logging.DEBUG,
                    )
                    raise
        else:  # assume tmplsrc is file-like.
            tmplstr = tmplsrc.read()
            tmplsrc.close()
        try:
            output = render_str(tmplstr, context, tmplpath)
            if salt.utils.platform.is_windows():
                newline = False
                if salt.utils.stringutils.to_unicode(
                    output, encoding=SLS_ENCODING
                ).endswith((&quot;\n&quot;, os.linesep)):
                    newline = True
                # Write out with Windows newlines
                output = os.linesep.join(output.splitlines())
                if newline:
                    output += os.linesep

        except SaltRenderError as exc:
            log.exception(&quot;Rendering exception occurred&quot;)
            # return dict(result=False, data=str(exc))
            raise
        except Exception:  # pylint: disable=broad-except
            return dict(result=False, data=traceback.format_exc())
        else:
            if to_str:  # then render as string
                return dict(result=True, data=output)
            with tempfile.NamedTemporaryFile(
                &quot;wb&quot;, delete=False, prefix=salt.utils.files.TEMPFILE_PREFIX
            ) as outf:
                outf.write(
                    salt.utils.stringutils.to_bytes(output, encoding=SLS_ENCODING)
                )
                # Note: If nothing is replaced or added by the rendering
                #       function, then the contents of the output file will
                #       be exactly the same as the input.
            return dict(result=True, data=outf.name)

    render_tmpl.render_str = render_str
    return render_tmpl


def _get_jinja_error_slug(tb_data):
    &quot;&quot;&quot;
    Return the line number where the template error was found
    &quot;&quot;&quot;
    try:
        return [
            x
            for x in tb_data
            if x[2] in (&quot;top-level template code&quot;, &quot;template&quot;, &quot;&lt;module&gt;&quot;)
        ][-1]
    except IndexError:
        pass


def _get_jinja_error_message(tb_data):
    &quot;&quot;&quot;
    Return an understandable message from jinja error output
    &quot;&quot;&quot;
    try:
        line = _get_jinja_error_slug(tb_data)
        return &quot;{0}({1}):\n{3}&quot;.format(*line)
    except IndexError:
        pass
    return None


def _get_jinja_error_line(tb_data):
    &quot;&quot;&quot;
    Return the line number where the template error was found
    &quot;&quot;&quot;
    try:
        return _get_jinja_error_slug(tb_data)[1]
    except IndexError:
        pass
    return None


def _get_jinja_error(trace, context=None):
    &quot;&quot;&quot;
    Return the error line and error message output from
    a stacktrace.
    If we are in a macro, also output inside the message the
    exact location of the error in the macro
    &quot;&quot;&quot;
    if not context:
        context = {}
    out = &quot;&quot;
    error = _get_jinja_error_slug(trace)
    line = _get_jinja_error_line(trace)
    msg = _get_jinja_error_message(trace)
    # if we failed on a nested macro, output a little more info
    # to help debugging
    # if sls is not found in context, add output only if we can
    # resolve the filename
    add_log = False
    template_path = None
    if &quot;sls&quot; not in context:
        if (error[0] != &quot;&lt;unknown&gt;&quot;) and os.path.exists(error[0]):
            template_path = error[0]
            add_log = True
    else:
        # the offender error is not from the called sls
        filen = context[&quot;sls&quot;].replace(&quot;.&quot;, &quot;/&quot;)
        if not error[0].endswith(filen) and os.path.exists(error[0]):
            add_log = True
            template_path = error[0]
    # if we add a log, format explicitly the exception here
    # by telling to output the macro context after the macro
    # error log place at the beginning
    if add_log:
<A NAME="3"></A>        if template_path:
            out = &quot;\n{}\n&quot;.format(msg.splitlines()[0])
            with salt.utils.files.fopen(template_path) as fp_:
                template_contents = salt<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match122344-0.html#3',2,'match122344-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.utils.stringutils.to_unicode(fp_.read())
            out += salt.utils.stringutils.get_context(
                template_contents, line, marker=</B></FONT>&quot;    &lt;======================&quot;
            )
        else:
            out = &quot;\n{}\n&quot;.format(msg)
        line = 0
    return line, out


def render_jinja_tmpl(tmplstr, context, tmplpath=None):
    &quot;&quot;&quot;
    Render a Jinja template.

    :param str tmplstr: A string containing the source to be rendered.

    :param dict context: Any additional context data used by the renderer.

    :param str tmplpath: Base path from which ``tmplstr`` may load additional
        template files.

    :returns str: The string rendered by the template.
    &quot;&quot;&quot;
    opts = context[&quot;opts&quot;]
    saltenv = context[&quot;saltenv&quot;]
    loader = None
    newline = False
    file_client = context.get(&quot;fileclient&quot;, None)

    if tmplstr and not isinstance(tmplstr, str):
        # https://jinja.palletsprojects.com/en/2.11.x/api/#unicode
        tmplstr = tmplstr.decode(SLS_ENCODING)

    if tmplstr.endswith(os.linesep):
        newline = os.linesep
    elif tmplstr.endswith(&quot;\n&quot;):
        newline = &quot;\n&quot;

    if not saltenv:
        if tmplpath:
            loader = jinja2.FileSystemLoader(os.path.dirname(tmplpath))
    else:
        loader = salt.utils.jinja.SaltCacheLoader(
            opts,
            saltenv,
            pillar_rend=context.get(&quot;_pillar_rend&quot;, False),
            _file_client=file_client,
        )

    env_args = {&quot;extensions&quot;: [], &quot;loader&quot;: loader}

    if hasattr(jinja2.ext, &quot;with_&quot;):
        env_args[&quot;extensions&quot;].append(&quot;jinja2.ext.with_&quot;)
    if hasattr(jinja2.ext, &quot;do&quot;):
        env_args[&quot;extensions&quot;].append(&quot;jinja2.ext.do&quot;)
    if hasattr(jinja2.ext, &quot;loopcontrols&quot;):
        env_args[&quot;extensions&quot;].append(&quot;jinja2.ext.loopcontrols&quot;)
    env_args[&quot;extensions&quot;].append(salt.utils.jinja.SerializerExtension)

    opt_jinja_env = opts.get(&quot;jinja_env&quot;, {})
    opt_jinja_sls_env = opts.get(&quot;jinja_sls_env&quot;, {})

    opt_jinja_env = opt_jinja_env if isinstance(opt_jinja_env, dict) else {}
    opt_jinja_sls_env = opt_jinja_sls_env if isinstance(opt_jinja_sls_env, dict) else {}

    # Pass through trim_blocks and lstrip_blocks Jinja parameters
    # trim_blocks removes newlines around Jinja blocks
    # lstrip_blocks strips tabs and spaces from the beginning of
    # line to the start of a block.
    if opts.get(&quot;jinja_trim_blocks&quot;, False):
        log.debug(&quot;Jinja2 trim_blocks is enabled&quot;)
        log.warning(
            &quot;jinja_trim_blocks is deprecated and will be removed in a future release,&quot;
            &quot; please use jinja_env and/or jinja_sls_env instead&quot;
        )
        opt_jinja_env[&quot;trim_blocks&quot;] = True
        opt_jinja_sls_env[&quot;trim_blocks&quot;] = True
    if opts.get(&quot;jinja_lstrip_blocks&quot;, False):
        log.debug(&quot;Jinja2 lstrip_blocks is enabled&quot;)
        log.warning(
            &quot;jinja_lstrip_blocks is deprecated and will be removed in a future release,&quot;
            &quot; please use jinja_env and/or jinja_sls_env instead&quot;
        )
        opt_jinja_env[&quot;lstrip_blocks&quot;] = True
        opt_jinja_sls_env[&quot;lstrip_blocks&quot;] = True

    def opt_jinja_env_helper(opts, optname):
        for k, v in opts.items():
            k = k.lower()
            if hasattr(jinja2.defaults, k.upper()):
                log.debug(&quot;Jinja2 environment %s was set to %s by %s&quot;, k, v, optname)
                env_args[k] = v
            else:
                log.warning(&quot;Jinja2 environment %s is not recognized&quot;, k)

    if &quot;sls&quot; in context and context[&quot;sls&quot;] != &quot;&quot;:
        opt_jinja_env_helper(opt_jinja_sls_env, &quot;jinja_sls_env&quot;)
    else:
        opt_jinja_env_helper(opt_jinja_env, &quot;jinja_env&quot;)

    if opts.get(&quot;allow_undefined&quot;, False):
        jinja_env = jinja2.sandbox.SandboxedEnvironment(**env_args)
    else:
        jinja_env = jinja2.sandbox.SandboxedEnvironment(
            undefined=jinja2.StrictUndefined, **env_args
        )

    indent_filter = jinja_env.filters.get(&quot;indent&quot;)
    jinja_env.tests.update(JinjaTest.salt_jinja_tests)
    jinja_env.filters.update(JinjaFilter.salt_jinja_filters)
    if salt.utils.jinja.JINJA_VERSION &gt;= LooseVersion(&quot;2.11&quot;):
        # Use the existing indent filter on Jinja versions where it's not broken
        jinja_env.filters[&quot;indent&quot;] = indent_filter
    jinja_env.globals.update(JinjaGlobal.salt_jinja_globals)

    # globals
    jinja_env.globals[&quot;odict&quot;] = OrderedDict
    jinja_env.globals[&quot;show_full_context&quot;] = salt.utils.jinja.show_full_context

    jinja_env.tests[&quot;list&quot;] = salt.utils.data.is_list

    decoded_context = {}
    for key, value in context.items():
        if not isinstance(value, str):
            if isinstance(value, NamedLoaderContext):
                decoded_context[key] = value.value()
            else:
                decoded_context[key] = value
            continue

        try:
            decoded_context[key] = salt.utils.stringutils.to_unicode(
                value, encoding=SLS_ENCODING
            )
        except UnicodeDecodeError as ex:
            log.debug(
                &quot;Failed to decode using default encoding (%s), trying system encoding&quot;,
                SLS_ENCODING,
            )
            decoded_context[key] = salt.utils.data.decode(value)

    jinja_env.globals.update(decoded_context)
    try:
        template = jinja_env.from_string(tmplstr)
        output = template.render(**decoded_context)
    except jinja2.exceptions.UndefinedError as exc:
        trace = traceback.extract_tb(sys.exc_info()[2])
        line, out = _get_jinja_error(trace, context=decoded_context)
        if not line:
            tmplstr = &quot;&quot;
        raise SaltRenderError(&quot;Jinja variable {}{}&quot;.format(exc, out), line, tmplstr)
    except (
        jinja2.exceptions.TemplateRuntimeError,
        jinja2.exceptions.TemplateSyntaxError,
        jinja2.exceptions.SecurityError,
    ) as exc:
        trace = traceback.extract_tb(sys.exc_info()[2])
        line, out = _get_jinja_error(trace, context=decoded_context)
        if not line:
            tmplstr = &quot;&quot;
        raise SaltRenderError(
            &quot;Jinja syntax error: {}{}&quot;.format(exc, out), line, tmplstr
        )
    except (SaltInvocationError, CommandExecutionError) as exc:
        trace = traceback.extract_tb(sys.exc_info()[2])
        line, out = _get_jinja_error(trace, context=decoded_context)
        if not line:
            tmplstr = &quot;&quot;
        raise SaltRenderError(
            &quot;Problem running salt function in Jinja template: {}{}&quot;.format(exc, out),
            line,
            tmplstr,
        )
    except Exception as exc:  # pylint: disable=broad-except
        tracestr = traceback.format_exc()
        trace = traceback.extract_tb(sys.exc_info()[2])
        line, out = _get_jinja_error(trace, context=decoded_context)
        if not line:
            tmplstr = &quot;&quot;
<A NAME="2"></A>        else:
            tmplstr += &quot;\n{}&quot;.format(tracestr)
        log.debug(&quot;Jinja Error&quot;)
        log<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match122344-0.html#2',2,'match122344-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.debug(&quot;Exception:&quot;, exc_info=True)
        log.debug(&quot;Out: %s&quot;, out)
        log.debug(&quot;Line: %s&quot;, line)
        log.debug(&quot;TmplStr: %s&quot;, tmplstr)
        log.debug(&quot;TraceStr: %s&quot;, tracestr)

        raise SaltRenderError(
            &quot;Jinja error: {}{}&quot;.format(</B></FONT>exc, out), line, tmplstr, trace=tracestr
        )

    # Workaround a bug in Jinja that removes the final newline
    # (https://github.com/mitsuhiko/jinja2/issues/75)
    if newline:
        output += newline

    return output


# pylint: disable=3rd-party-module-not-gated
def render_mako_tmpl(tmplstr, context, tmplpath=None):
    &quot;&quot;&quot;
    Render a Mako template.

    :param str tmplstr: A string containing the source to be rendered.

    :param dict context: Any additional context data used by the renderer.

    :param str tmplpath: Base path from which ``tmplstr`` may load additional
        template files.

    :returns str: The string rendered by the template.
    &quot;&quot;&quot;
    import mako.exceptions  # pylint: disable=no-name-in-module
    from mako.template import Template  # pylint: disable=no-name-in-module
    from salt.utils.mako import SaltMakoTemplateLookup

    saltenv = context[&quot;saltenv&quot;]
    lookup = None
    if not saltenv:
        if tmplpath:
            # i.e., the template is from a file outside the state tree
            from mako.lookup import TemplateLookup  # pylint: disable=no-name-in-module

            lookup = TemplateLookup(directories=[os.path.dirname(tmplpath)])
    else:
        lookup = SaltMakoTemplateLookup(
            context[&quot;opts&quot;], saltenv, pillar_rend=context.get(&quot;_pillar_rend&quot;, False)
        )
    try:
        return Template(
            tmplstr,
            strict_undefined=True,
            uri=context[&quot;sls&quot;].replace(&quot;.&quot;, &quot;/&quot;) if &quot;sls&quot; in context else None,
            lookup=lookup,
        ).render(**context)
    except Exception:  # pylint: disable=broad-except
        raise SaltRenderError(mako.exceptions.text_error_template().render())


def render_wempy_tmpl(tmplstr, context, tmplpath=None):
    &quot;&quot;&quot;
    Render a Wempy template.

    :param str tmplstr: A string containing the source to be rendered.

    :param dict context: Any additional context data used by the renderer.

    :param str tmplpath: Unused.

    :returns str: The string rendered by the template.
    &quot;&quot;&quot;
    from wemplate.wemplate import TemplateParser as Template

    return Template(tmplstr).render(**context)


def render_genshi_tmpl(tmplstr, context, tmplpath=None):
    &quot;&quot;&quot;
    Render a Genshi template. A method should be passed in as part of the
    context. If no method is passed in, xml is assumed. Valid methods are:

    .. code-block:

        - xml
        - xhtml
        - html
        - text
        - newtext
        - oldtext

    Note that the ``text`` method will call ``NewTextTemplate``. If ``oldtext``
    is desired, it must be called explicitly
    &quot;&quot;&quot;
    method = context.get(&quot;method&quot;, &quot;xml&quot;)
    if method == &quot;text&quot; or method == &quot;newtext&quot;:
        from genshi.template import NewTextTemplate  # pylint: disable=no-name-in-module

        tmpl = NewTextTemplate(tmplstr)
    elif method == &quot;oldtext&quot;:
        from genshi.template import OldTextTemplate  # pylint: disable=no-name-in-module

        tmpl = OldTextTemplate(tmplstr)
    else:
        from genshi.template import MarkupTemplate  # pylint: disable=no-name-in-module

        tmpl = MarkupTemplate(tmplstr)

    return tmpl.generate(**context).render(method)


def render_cheetah_tmpl(tmplstr, context, tmplpath=None):
    &quot;&quot;&quot;
    Render a Cheetah template.
    &quot;&quot;&quot;
    from Cheetah.Template import Template

    # Compile the template and render it into the class
    tclass = Template.compile(tmplstr)
    data = tclass(namespaces=[context])

    # Figure out which method to call based on the type of tmplstr
    if isinstance(tmplstr, str):
        # This should call .__unicode__()
        res = str(data)
    elif isinstance(tmplstr, bytes):
        # This should call .__str()
        res = str(data)
    else:
        raise SaltRenderError(
            &quot;Unknown type {!s} for Cheetah template while trying to render.&quot;.format(
                type(tmplstr)
            )
        )

    # Now we can decode it to the correct encoding
    return salt.utils.data.decode(res)


# pylint: enable=3rd-party-module-not-gated


def py(sfn, string=False, **kwargs):  # pylint: disable=C0103
    &quot;&quot;&quot;
    Render a template from a python source file

    Returns::

        {'result': bool,
         'data': &lt;Error data or rendered file path&gt;}
    &quot;&quot;&quot;
    if not os.path.isfile(sfn):
        return {}

    base_fname = os.path.basename(sfn)
    name = base_fname.split(&quot;.&quot;)[0]

    if USE_IMPORTLIB:
        # pylint: disable=no-member
        loader = importlib.machinery.SourceFileLoader(name, sfn)
        spec = importlib.util.spec_from_file_location(name, sfn, loader=loader)
        if spec is None:
            raise ImportError()
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        # pylint: enable=no-member
        sys.modules[name] = mod
    else:
        mod = imp.load_source(name, sfn)

    # File templates need these set as __var__
    if &quot;__env__&quot; not in kwargs and &quot;saltenv&quot; in kwargs:
        setattr(mod, &quot;__env__&quot;, kwargs[&quot;saltenv&quot;])
        builtins = [&quot;salt&quot;, &quot;grains&quot;, &quot;pillar&quot;, &quot;opts&quot;]
        for builtin in builtins:
            arg = &quot;__{}__&quot;.format(builtin)
            setattr(mod, arg, kwargs[builtin])

    for kwarg in kwargs:
        setattr(mod, kwarg, kwargs[kwarg])

    try:
        data = mod.run()
        if string:
            return {&quot;result&quot;: True, &quot;data&quot;: data}
        tgt = salt.utils.files.mkstemp()
        with salt.utils.files.fopen(tgt, &quot;w+&quot;) as target:
            target.write(salt.utils.stringutils.to_str(data))
        return {&quot;result&quot;: True, &quot;data&quot;: tgt}
    except Exception:  # pylint: disable=broad-except
        trb = traceback.format_exc()
        return {&quot;result&quot;: False, &quot;data&quot;: trb}


JINJA = wrap_tmpl_func(render_jinja_tmpl)
MAKO = wrap_tmpl_func(render_mako_tmpl)
WEMPY = wrap_tmpl_func(render_wempy_tmpl)
GENSHI = wrap_tmpl_func(render_genshi_tmpl)
CHEETAH = wrap_tmpl_func(render_cheetah_tmpl)

TEMPLATE_REGISTRY = {
    &quot;jinja&quot;: JINJA,
    &quot;mako&quot;: MAKO,
    &quot;py&quot;: py,
    &quot;wempy&quot;: WEMPY,
    &quot;genshi&quot;: GENSHI,
    &quot;cheetah&quot;: CHEETAH,
}
</PRE>
</div>
  </div>
</body>
</html>
