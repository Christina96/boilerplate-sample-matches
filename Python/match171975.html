<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_ldap.py & test_zypperpkg_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_ldap.py & test_zypperpkg_1.py
      </h3>
      <h1 align="center">
        2.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_ldap.py (4.784689%)<TH>test_zypperpkg_1.py (1.2760527%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match171975-0.html#0',2,'match171975-1.html#0',3)" NAME="0">(328-341)<TD><A HREF="javascript:ZweiFrames('match171975-0.html#0',2,'match171975-1.html#0',3)" NAME="0">(178-187)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match171975-0.html#1',2,'match171975-1.html#1',3)" NAME="1">(243-257)<TD><A HREF="javascript:ZweiFrames('match171975-0.html#1',2,'match171975-1.html#1',3)" NAME="1">(169-178)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ldap.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;Test cases for the ``ldap`` state module

This code is gross.  I started out trying to remove some of the
duplicate code in the test cases, and before I knew it the test code
was an ugly second implementation.

I'm leaving it for now, but this should really be gutted and replaced
with something sensible.
&quot;&quot;&quot;
import copy
import logging

import attr
import pytest
import salt.states.ldap
from salt.utils.oset import OrderedSet
from salt.utils.stringutils import to_bytes

log = logging.getLogger(__name__)


# emulates the LDAP database.  each key is the DN of an entry and it
# maps to a dict which maps attribute names to sets of values.
@attr.s
class LdapDB:
    db = attr.ib(init=False, default=attr.Factory(dict))

    def dummy_connect(self, connect_spec):
        return _dummy_ctx()

    def dummy_search(self, connect_spec, base, scope):
        if base not in self.db:
            return {}
        return {
            base: {
                attr: list(self.db[base][attr])
                for attr in self.db[base]
                if len(self.db[base][attr])
            }
        }

    def dummy_add(self, connect_spec, dn, attributes):
        assert dn not in self.db
        assert attributes
        self.db[dn] = {}
        for attr, vals in attributes.items():
            assert vals
            self.db[dn][attr] = OrderedSet(vals)
        return True

    def dummy_delete(self, connect_spec, dn):
        assert dn in self.db
        del self.db[dn]
        return True

    def dummy_change(self, connect_spec, dn, before, after):
        assert before != after
        assert before
        assert after
        assert dn in self.db
        e = self.db[dn]
        assert e == before
        all_attrs = OrderedSet()
        all_attrs.update(before)
        all_attrs.update(after)
        directives = []
        for attr in all_attrs:
            if attr not in before:
                assert attr in after
                assert after[attr]
                directives.append((&quot;add&quot;, attr, after[attr]))
            elif attr not in after:
                assert attr in before
                assert before[attr]
                directives.append((&quot;delete&quot;, attr, ()))
            else:
                assert before[attr]
                assert after[attr]
                to_del = before[attr] - after[attr]
                if to_del:
                    directives.append((&quot;delete&quot;, attr, to_del))
                to_add = after[attr] - before[attr]
                if to_add:
                    directives.append((&quot;add&quot;, attr, to_add))
        return self.dummy_modify(connect_spec, dn, directives)

    def dummy_modify(self, connect_spec, dn, directives):
        assert dn in self.db
        e = self.db[dn]
        for op, attr, vals in directives:
            if op == &quot;add&quot;:
                assert vals
                existing_vals = e.setdefault(attr, OrderedSet())
                for val in vals:
                    assert val not in existing_vals
                    existing_vals.add(val)
            elif op == &quot;delete&quot;:
                assert attr in e
                existing_vals = e[attr]
                assert existing_vals
                if not vals:
                    del e[attr]
                    continue
                for val in vals:
                    assert val in existing_vals
                    existing_vals.remove(val)
                if not existing_vals:
                    del e[attr]
            elif op == &quot;replace&quot;:
                e.pop(attr, None)
                e[attr] = OrderedSet(vals)
            else:
                raise ValueError()
        return True

    def dump_db(self, d=None):
        if d is None:
            d = self.db
        return {dn: {attr: list(d[dn][attr]) for attr in d[dn]} for dn in d}


@pytest.fixture
def db():
    return LdapDB()


@pytest.fixture
def complex_db(db):
    db.db = {
        &quot;dnfoo&quot;: {
            &quot;attrfoo1&quot;: OrderedSet(
                (
                    b&quot;valfoo1.1&quot;,
                    b&quot;valfoo1.2&quot;,
                )
            ),
            &quot;attrfoo2&quot;: OrderedSet((b&quot;valfoo2.1&quot;,)),
        },
        &quot;dnbar&quot;: {
            &quot;attrbar1&quot;: OrderedSet(
                (
                    b&quot;valbar1.1&quot;,
                    b&quot;valbar1.2&quot;,
                )
            ),
            &quot;attrbar2&quot;: OrderedSet((b&quot;valbar2.1&quot;,)),
        },
    }
    return db


@pytest.fixture
def no_change_complex_db(db):
    db.db = {
        &quot;dnfoo&quot;: {
            &quot;attrfoo1&quot;: OrderedSet(
                (
                    b&quot;valfoo1.1&quot;,
                    b&quot;valfoo1.2&quot;,
                )
            ),
            &quot;attrfoo2&quot;: OrderedSet((b&quot;valfoo2.1&quot;,)),
        },
        &quot;dnbar&quot;: {
            &quot;attrbar1&quot;: OrderedSet(
                (
                    b&quot;valbar1.1&quot;,
                    b&quot;valbar1.2&quot;,
                )
            ),
            &quot;attrbar2&quot;: OrderedSet((b&quot;valbar2.1&quot;,)),
        },
    }
    return db


class _dummy_ctx:
    def __init__(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        pass


@pytest.fixture
def configure_loader_modules(db):
    salt_dunder = {
        &quot;ldap3.connect&quot;: db.dummy_connect,
        &quot;ldap3.search&quot;: db.dummy_search,
        &quot;ldap3.add&quot;: db.dummy_add,
        &quot;ldap3.delete&quot;: db.dummy_delete,
        &quot;ldap3.change&quot;: db.dummy_change,
        &quot;ldap3.modify&quot;: db.dummy_modify,
    }
    return {salt.states.ldap: {&quot;__opts__&quot;: {&quot;test&quot;: False}, &quot;__salt__&quot;: salt_dunder}}


def _test_helper(init_db, expected_ret, replace, delete_others=False):
    old = init_db.dump_db()
    new = init_db.dump_db()
    expected_db = copy.deepcopy(init_db.db)
    for dn, attrs in replace.items():
        for attr, vals in attrs.items():
            vals = [to_bytes(val) for val in vals]
            if vals:
                new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
                expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
            elif dn in expected_db:
                new[dn].pop(attr, None)
                expected_db[dn].pop(attr, None)
        if not expected_db.get(dn, {}):
            new.pop(dn, None)
            expected_db.pop(dn, None)
    if delete_others:
        dn_to_delete = OrderedSet()
        for dn, attrs in expected_db.items():
            if dn in replace:
                to_delete = OrderedSet()
                for attr, vals in attrs.items():
                    if attr not in replace[dn]:
                        to_delete.add(attr)
                for attr in to_delete:
                    del attrs[attr]
                    del new[dn][attr]
                if not attrs:
                    dn_to_delete.add(dn)
        for dn in dn_to_delete:
            del new[dn]
            del expected_db[dn]
    name = &quot;ldapi:///&quot;
    expected_ret[&quot;name&quot;] = name
    expected_ret.setdefault(&quot;result&quot;, True)
    expected_ret.setdefault(&quot;comment&quot;, &quot;Successfully updated LDAP entries&quot;)
    expected_ret.setdefault(
        &quot;changes&quot;,
        {
<A NAME="1"></A>            dn: {
                &quot;old&quot;: {
                    attr: vals
                    for attr, vals in old[dn]<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match171975-1.html#1',3,'match171975-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.items()
                    if vals != new.get(dn, {}).get(attr, ())
                }
                if dn in old
                else None,
                &quot;new&quot;: {
                    attr: vals
                    for attr, vals in new[dn].items()
                    if vals != old.get(dn, {}).get(attr, ())
                }
                if dn in new
                else None,
            }
            for dn in replace
            if old.</B></FONT>get(dn, {}) != new.get(dn, {})
        },
    )
    entries = [
        {dn: [{&quot;replace&quot;: attrs}, {&quot;delete_others&quot;: delete_others}]}
        for dn, attrs in replace.items()
    ]
    actual = salt.states.ldap.managed(name, entries)
    assert expected_ret == actual
    assert expected_db == init_db.db


def _test_helper_success(db, replace, delete_others=False):
    _test_helper(db, {}, replace, delete_others)


def _test_helper_nochange(db, replace, delete_others=False):
    expected = {
        &quot;changes&quot;: {},
        &quot;comment&quot;: &quot;LDAP entries already set&quot;,
    }
    _test_helper(db, expected, replace, delete_others)


def _test_helper_add(db, expected_ret, add_items, delete_others=False):
    old = db.dump_db()
    new = db.dump_db()
    expected_db = copy.deepcopy(db.db)
    for dn, attrs in add_items.items():
        for attr, vals in attrs.items():
            vals = [to_bytes(val) for val in vals]

            vals.extend(old.get(dn, {}).get(attr, OrderedSet()))
            vals.sort()

            if vals:
                new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
                expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
            elif dn in expected_db:
                new[dn].pop(attr, None)
                expected_db[dn].pop(attr, None)
        if not expected_db.get(dn, {}):
            new.pop(dn, None)
            expected_db.pop(dn, None)
    if delete_others:
        dn_to_delete = OrderedSet()
        for dn, attrs in expected_db.items():
            if dn in add_items:
                to_delete = OrderedSet()
                for attr, vals in attrs.items():
                    if attr not in add_items[dn]:
                        to_delete.add(attr)
                for attr in to_delete:
                    del attrs[attr]
                    del new[dn][attr]
                if not attrs:
                    dn_to_delete.add(dn)
        for dn in dn_to_delete:
            del new[dn]
            del expected_db[dn]
    name = &quot;ldapi:///&quot;
    expected_ret[&quot;name&quot;] = name
    expected_ret.setdefault(&quot;result&quot;, True)
    expected_ret.setdefault(&quot;comment&quot;, &quot;Successfully updated LDAP entries&quot;)
    expected_ret.setdefault(
        &quot;changes&quot;,
        {
            dn: {
<A NAME="0"></A>                &quot;old&quot;: {
                    attr: vals
                    for attr, vals in old[dn].items()
                    if vals != new<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match171975-1.html#0',3,'match171975-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get(dn, {}).get(attr, ())
                }
                if dn in old
                else None,
                &quot;new&quot;: {
                    attr: vals
                    for attr, vals in new[dn].items()
                    if vals != old.get(dn, {}).get(attr, ())
                }
                if dn in new
                else None,
            }
            for dn in add_items
            if old.get(dn, {}) != new.</B></FONT>get(dn, {})
        },
    )
    entries = [
        {dn: [{&quot;add&quot;: attrs}, {&quot;delete_others&quot;: delete_others}]}
        for dn, attrs in add_items.items()
    ]
    actual = salt.states.ldap.managed(name, entries)
    assert expected_ret == actual
    assert expected_db == db.db


def _test_helper_success_add(db, add_items, delete_others=False):
    _test_helper_add(db, {}, add_items, delete_others)


def test_managed_empty(db):
    name = &quot;ldapi:///&quot;
    expected = {
        &quot;name&quot;: name,
        &quot;changes&quot;: {},
        &quot;result&quot;: True,
        &quot;comment&quot;: &quot;LDAP entries already set&quot;,
    }
    actual = salt.states.ldap.managed(name, {})
    assert expected == actual


def test_managed_add_entry(db):
    _test_helper_success_add(db, {&quot;dummydn&quot;: {&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}})


def test_managed_add_attr(complex_db):
    _test_helper_success_add(complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo1&quot;: [&quot;valfoo1.3&quot;]}})
    _test_helper_success_add(complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo4&quot;: [&quot;valfoo4.1&quot;]}})


def test_managed_replace_attr(complex_db):
    _test_helper_success(complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo3&quot;: [&quot;valfoo3.1&quot;]}})


def test_managed_simplereplace(complex_db):
    _test_helper_success(complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo1&quot;: [&quot;valfoo1.3&quot;]}})


def test_managed_deleteattr(complex_db):
    _test_helper_success(complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo1&quot;: []}})


def test_managed_deletenonexistattr(no_change_complex_db):
    _test_helper_nochange(no_change_complex_db, {&quot;dnfoo&quot;: {&quot;dummyattr&quot;: []}})


def test_managed_deleteentry(complex_db):
    _test_helper_success(complex_db, {&quot;dnfoo&quot;: {}}, True)


def test_managed_deletenonexistentry(no_change_complex_db):
    _test_helper_nochange(no_change_complex_db, {&quot;dummydn&quot;: {}}, True)


def test_managed_deletenonexistattrinnonexistentry(no_change_complex_db):
    _test_helper_nochange(no_change_complex_db, {&quot;dummydn&quot;: {&quot;dummyattr&quot;: []}})


def test_managed_add_attr_delete_others(complex_db):
    _test_helper_success(complex_db, {&quot;dnfoo&quot;: {&quot;dummyattr&quot;: [&quot;dummyval&quot;]}}, True)


def test_managed_no_net_change(no_change_complex_db):
    _test_helper_nochange(
        no_change_complex_db, {&quot;dnfoo&quot;: {&quot;attrfoo1&quot;: [&quot;valfoo1.1&quot;, &quot;valfoo1.2&quot;]}}
    )


def test_managed_repeated_values(db):
    _test_helper_success(db, {&quot;dummydn&quot;: {&quot;dummyattr&quot;: [&quot;dummyval&quot;, &quot;dummyval&quot;]}})
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zypperpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Bo Maryniuk &lt;bo@suse.de&gt;
&quot;&quot;&quot;


import configparser
import io
import os
from xml.dom import minidom

import salt.modules.pkg_resource as pkg_resource
import salt.modules.zypperpkg as zypper
import salt.utils.files
import salt.utils.pkg
from salt.exceptions import CommandExecutionError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, Mock, call, patch
from tests.support.unit import TestCase


class ZyppCallMock:
    def __init__(self, return_value=None):
        self.__return_value = return_value

    def __getattr__(self, item):
        return self

    def __call__(self, *args, **kwargs):
        # If the call is for a configuration modifier, we return self
        if any(i in kwargs for i in (&quot;no_repo_failure&quot;, &quot;systemd_scope&quot;, &quot;root&quot;)):
            return self
        return MagicMock(return_value=self.__return_value)()


def get_test_data(filename):
    &quot;&quot;&quot;
    Return static test data
    &quot;&quot;&quot;
    with salt.utils.files.fopen(
        os.path.join(
            os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;zypp&quot;), filename
        )
    ) as rfh:
        return rfh.read()


class ZypperTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.zypper
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {zypper: {&quot;rpm&quot;: None}, pkg_resource: {}}

    def setUp(self):
        self.new_repo_config = dict(
            name=&quot;mock-repo-name&quot;, url=&quot;http://repo.url/some/path&quot;
        )
        side_effect = [
            Mock(**{&quot;sections.return_value&quot;: []}),
            Mock(**{&quot;sections.return_value&quot;: [self.new_repo_config[&quot;name&quot;]]}),
        ]
        self.zypper_patcher_config = {
            &quot;_get_configured_repos&quot;: Mock(side_effect=side_effect),
            &quot;__zypper__&quot;: Mock(),
            &quot;_get_repo_info&quot;: Mock(
                return_value={
                    &quot;keeppackages&quot;: False,
                    &quot;autorefresh&quot;: True,
                    &quot;enabled&quot;: False,
                    &quot;baseurl&quot;: self.new_repo_config[&quot;url&quot;],
                    &quot;alias&quot;: self.new_repo_config[&quot;name&quot;],
                    &quot;priority&quot;: 1,
                    &quot;type&quot;: &quot;rpm-md&quot;,
                }
            ),
            &quot;del_repo&quot;: Mock(),
            &quot;mod_repo&quot;: Mock(wraps=zypper.mod_repo),
        }

    def tearDown(self):
        del self.new_repo_config
        del self.zypper_patcher_config

    def test_list_upgrades(self):
        &quot;&quot;&quot;
        List package upgrades
        :return:
        &quot;&quot;&quot;
        ref_out = {
            &quot;stdout&quot;: get_test_data(&quot;zypper-updates.xml&quot;),
            &quot;stderr&quot;: None,
            &quot;retcode&quot;: 0,
        }
        with patch.dict(
            zypper.__salt__, {&quot;cmd.run_all&quot;: MagicMock(return_value=ref_out)}
        ):
            upgrades = zypper.list_upgrades(refresh=False)
            self.assertEqual(len(upgrades), 3)
            for pkg, version in {
                &quot;SUSEConnect&quot;: &quot;0.2.33-7.1&quot;,
                &quot;bind-utils&quot;: &quot;9.9.6P1-35.1&quot;,
                &quot;bind-libs&quot;: &quot;9.9.6P1-35.1&quot;,
            }.items():
                self.assertIn(pkg, upgrades)
                self.assertEqual(upgrades[pkg], version)

    @patch(
        &quot;salt.utils.environment.get_module_environment&quot;,
        MagicMock(return_value={&quot;SALT_RUNNING&quot;: &quot;1&quot;}),
    )
    def test_zypper_caller(self):
        &quot;&quot;&quot;
        Test Zypper caller.
        :return:
        &quot;&quot;&quot;

        class RunSniffer:
            def __init__(self, stdout=None, stderr=None, retcode=None):
                self.calls = list()
                self._stdout = stdout or &quot;&quot;
                self._stderr = stderr or &quot;&quot;
                self._retcode = retcode or 0

            def __call__(self, *args, **kwargs):
                self.calls.append({&quot;args&quot;: args, &quot;kwargs&quot;: kwargs})
                return {
                    &quot;stdout&quot;: self._stdout,
                    &quot;stderr&quot;: self._stderr,
                    &quot;retcode&quot;: self._retcode,
                }

        stdout_xml_snippet = '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;test foo=&quot;bar&quot;/&gt;'
        sniffer = RunSniffer(stdout=stdout_xml_snippet)
        with patch.dict(&quot;salt.modules.zypperpkg.__salt__&quot;, {&quot;cmd.run_all&quot;: sniffer}):
            self.assertEqual(zypper.__zypper__.call(&quot;foo&quot;), stdout_xml_snippet)
            self.assertEqual(len(sniffer.calls), 1)

            zypper.__zypper__.call(&quot;--no-refresh&quot;, &quot;bar&quot;)
            self.assertEqual(len(sniffer.calls), 2)
            self.assertEqual(
                sniffer.calls[0][&quot;args&quot;][0],
                [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;--no-refresh&quot;, &quot;foo&quot;],
            )
            self.assertEqual(
                sniffer.calls[1][&quot;args&quot;][0],
                [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;--no-refresh&quot;, &quot;bar&quot;],
            )

            dom = zypper.__zypper__.xml.call(&quot;xml-test&quot;)
            self.assertEqual(
                sniffer.calls[2][&quot;args&quot;][0],
                [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;--xmlout&quot;, &quot;--no-refresh&quot;, &quot;xml-test&quot;],
            )
            self.assertEqual(
                dom.getElementsByTagName(&quot;test&quot;)[0].getAttribute(&quot;foo&quot;), &quot;bar&quot;
            )

            zypper.__zypper__.refreshable.call(&quot;refresh-test&quot;)
            self.assertEqual(
                sniffer.calls[3][&quot;args&quot;][0],
                [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;refresh-test&quot;],
            )

            zypper.__zypper__.nolock.call(&quot;no-locking-test&quot;)
<A NAME="1"></A>            self.assertEqual(
                sniffer.calls[4]
                .get(&quot;kwargs&quot;, {})
                <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match171975-0.html#1',2,'match171975-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.get(&quot;env&quot;, {})
                .get(&quot;ZYPP_READONLY_HACK&quot;),
                &quot;1&quot;,
            )
            self.assertEqual(
                sniffer.calls[4].get(&quot;kwargs&quot;, {}).get(&quot;env&quot;, {}).get(&quot;SALT_RUNNING&quot;),
<A NAME="0"></A>                &quot;1&quot;,
            )

            zypper.</B></FONT>__zypper__<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match171975-0.html#0',2,'match171975-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.call(&quot;locking-test&quot;)
            self.assertEqual(
                sniffer.calls[5]
                .get(&quot;kwargs&quot;, {})
                .get(&quot;env&quot;, {})
                .get(&quot;ZYPP_READONLY_HACK&quot;),
                None,
            )
            self.assertEqual(
                sniffer.</B></FONT>calls[5].get(&quot;kwargs&quot;, {}).get(&quot;env&quot;, {}).get(&quot;SALT_RUNNING&quot;),
                &quot;1&quot;,
            )

        # Test exceptions
        stdout_xml_snippet = (
            '&lt;?xml version=&quot;1.0&quot;?&gt;&lt;stream&gt;&lt;message'
            ' type=&quot;error&quot;&gt;Booya!&lt;/message&gt;&lt;/stream&gt;'
        )
        sniffer = RunSniffer(stdout=stdout_xml_snippet, retcode=1)
        with patch.dict(&quot;salt.modules.zypperpkg.__salt__&quot;, {&quot;cmd.run_all&quot;: sniffer}):
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;^Zypper command failure: Booya!$&quot;
            ):
                zypper.__zypper__.xml.call(&quot;crashme&quot;)

            with self.assertRaisesRegex(
                CommandExecutionError, &quot;^Zypper command failure: Check Zypper's logs.$&quot;
            ):
                zypper.__zypper__.call(&quot;crashme again&quot;)

            zypper.__zypper__.noraise.call(&quot;stay quiet&quot;)
            self.assertEqual(zypper.__zypper__.error_msg, &quot;Check Zypper's logs.&quot;)

    def test_list_upgrades_error_handling(self):
        &quot;&quot;&quot;
        Test error handling in the list package upgrades.
        :return:
        &quot;&quot;&quot;
        # Test handled errors
        ref_out = {
            &quot;stdout&quot;: &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;
&lt;stream&gt;
 &lt;message type=&quot;info&quot;&gt;Refreshing service &amp;apos;container-suseconnect&amp;apos;.&lt;/message&gt;
 &lt;message type=&quot;error&quot;&gt;Some handled zypper internal error&lt;/message&gt;
 &lt;message type=&quot;error&quot;&gt;Another zypper internal error&lt;/message&gt;
&lt;/stream&gt;
            &quot;&quot;&quot;,
            &quot;stderr&quot;: &quot;&quot;,
            &quot;retcode&quot;: 1,
        }
        with patch.dict(
            &quot;salt.modules.zypperpkg.__salt__&quot;,
            {&quot;cmd.run_all&quot;: MagicMock(return_value=ref_out)},
        ):
            with self.assertRaisesRegex(
                CommandExecutionError,
                &quot;^Zypper command failure: Some handled zypper internal error{}Another&quot;
                &quot; zypper internal error$&quot;.format(os.linesep),
            ):
                zypper.list_upgrades(refresh=False)

        # Test unhandled error
        ref_out = {&quot;retcode&quot;: 1, &quot;stdout&quot;: &quot;&quot;, &quot;stderr&quot;: &quot;&quot;}
        with patch.dict(
            &quot;salt.modules.zypperpkg.__salt__&quot;,
            {&quot;cmd.run_all&quot;: MagicMock(return_value=ref_out)},
        ):
            with self.assertRaisesRegex(
                CommandExecutionError, &quot;^Zypper command failure: Check Zypper's logs.$&quot;
            ):
                zypper.list_upgrades(refresh=False)

    def test_list_products(self):
        &quot;&quot;&quot;
        List products test.
        &quot;&quot;&quot;
        for filename, test_data in {
            &quot;zypper-products-sle12sp1.xml&quot;: {
                &quot;name&quot;: [
                    &quot;SLES&quot;,
                    &quot;SLES&quot;,
                    &quot;SUSE-Manager-Proxy&quot;,
                    &quot;SUSE-Manager-Server&quot;,
                    &quot;sle-manager-tools-beta&quot;,
                    &quot;sle-manager-tools-beta-broken-eol&quot;,
                    &quot;sle-manager-tools-beta-no-eol&quot;,
                ],
                &quot;vendor&quot;: &quot;SUSE LLC &lt;https://www.suse.com/&gt;&quot;,
                &quot;release&quot;: [&quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;],
                &quot;productline&quot;: [None, None, None, None, None, None, &quot;sles&quot;],
                &quot;eol_t&quot;: [
                    None,
                    0,
                    1509408000,
                    1522454400,
                    1522454400,
                    1730332800,
                    1730332800,
                ],
                &quot;isbase&quot;: [False, False, False, False, False, False, True],
                &quot;installed&quot;: [False, False, False, False, False, False, True],
                &quot;registerrelease&quot;: [None, None, None, None, None, None, &quot;123&quot;],
            },
            &quot;zypper-products-sle11sp3.xml&quot;: {
                &quot;name&quot;: [
                    &quot;SUSE-Manager-Server&quot;,
                    &quot;SUSE-Manager-Server&quot;,
                    &quot;SUSE-Manager-Server-Broken-EOL&quot;,
                    &quot;SUSE_SLES&quot;,
                    &quot;SUSE_SLES&quot;,
                    &quot;SUSE_SLES&quot;,
                    &quot;SUSE_SLES-SP4-migration&quot;,
                ],
                &quot;vendor&quot;: &quot;SUSE LINUX Products GmbH, Nuernberg, Germany&quot;,
                &quot;release&quot;: [&quot;1.138&quot;, &quot;1.2&quot;, &quot;1.2&quot;, &quot;1.2&quot;, &quot;1.201&quot;, &quot;1.201&quot;, &quot;1.4&quot;],
                &quot;productline&quot;: [None, None, None, None, None, &quot;manager&quot;, &quot;manager&quot;],
                &quot;eol_t&quot;: [None, 0, 0, 0, 0, 0, 0],
                &quot;isbase&quot;: [False, False, False, False, False, True, True],
                &quot;installed&quot;: [False, False, False, False, False, True, True],
                &quot;registerrelease&quot;: [None, None, None, None, None, None, &quot;42&quot;],
            },
        }.items():

            ref_out = {&quot;retcode&quot;: 0, &quot;stdout&quot;: get_test_data(filename)}

            cmd_run_all = MagicMock(return_value=ref_out)
            mock_call = call(
                [
                    &quot;zypper&quot;,
                    &quot;--non-interactive&quot;,
                    &quot;--xmlout&quot;,
                    &quot;--no-refresh&quot;,
                    &quot;--disable-repositories&quot;,
                    &quot;products&quot;,
                    &quot;-i&quot;,
                ],
                env={&quot;ZYPP_READONLY_HACK&quot;: &quot;1&quot;},
                output_loglevel=&quot;trace&quot;,
                python_shell=False,
            )

            with patch.dict(zypper.__salt__, {&quot;cmd.run_all&quot;: cmd_run_all}):
                products = zypper.list_products()
                self.assertEqual(len(products), 7)
                self.assertIn(
                    test_data[&quot;vendor&quot;], [product[&quot;vendor&quot;] for product in products]
                )
                for kwd in [
                    &quot;name&quot;,
                    &quot;isbase&quot;,
                    &quot;installed&quot;,
                    &quot;release&quot;,
                    &quot;productline&quot;,
                    &quot;eol_t&quot;,
                    &quot;registerrelease&quot;,
                ]:
                    self.assertCountEqual(
                        test_data[kwd], [prod.get(kwd) for prod in products]
                    )
                cmd_run_all.assert_has_calls([mock_call])

    def test_refresh_db(self):
        &quot;&quot;&quot;
        Test if refresh DB handled correctly
        &quot;&quot;&quot;
        ref_out = [
            &quot;Repository 'openSUSE-Leap-42.1-LATEST' is up to date.&quot;,
            &quot;Repository 'openSUSE-Leap-42.1-Update' is up to date.&quot;,
            &quot;Retrieving repository 'openSUSE-Leap-42.1-Update-Non-Oss' metadata&quot;,
            &quot;Forcing building of repository cache&quot;,
            &quot;Building repository 'openSUSE-Leap-42.1-Update-Non-Oss' cache&quot;
            &quot; ..........[done]&quot;,
            &quot;Building repository 'salt-dev' cache&quot;,
            &quot;All repositories have been refreshed.&quot;,
        ]

        run_out = {&quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;\n&quot;.join(ref_out), &quot;retcode&quot;: 0}

        zypper_mock = MagicMock(return_value=run_out)
        call_kwargs = {&quot;output_loglevel&quot;: &quot;trace&quot;, &quot;python_shell&quot;: False, &quot;env&quot;: {}}
        with patch.dict(zypper.__salt__, {&quot;cmd.run_all&quot;: zypper_mock}):
            with patch.object(salt.utils.pkg, &quot;clear_rtag&quot;, Mock()):
                result = zypper.refresh_db()
                self.assertEqual(result.get(&quot;openSUSE-Leap-42.1-LATEST&quot;), False)
                self.assertEqual(result.get(&quot;openSUSE-Leap-42.1-Update&quot;), False)
                self.assertEqual(result.get(&quot;openSUSE-Leap-42.1-Update-Non-Oss&quot;), True)
                zypper_mock.assert_called_with(
                    [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;refresh&quot;, &quot;--force&quot;], **call_kwargs
                )
                zypper.refresh_db(force=False)
                zypper_mock.assert_called_with(
                    [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;refresh&quot;], **call_kwargs
                )
                zypper.refresh_db(force=True)
                zypper_mock.assert_called_with(
                    [&quot;zypper&quot;, &quot;--non-interactive&quot;, &quot;refresh&quot;, &quot;--force&quot;], **call_kwargs
                )

    def test_info_installed(self):
        &quot;&quot;&quot;
        Test the return information of the named package(s), installed on the system.

        :return:
        &quot;&quot;&quot;
        run_out = {
            &quot;virgo-dummy&quot;: {
                &quot;build_date&quot;: &quot;2015-07-09T10:55:19Z&quot;,
                &quot;vendor&quot;: &quot;openSUSE Build Service&quot;,
                &quot;description&quot;: (
                    &quot;This is the Virgo dummy package used for testing SUSE Manager&quot;
                ),
                &quot;license&quot;: &quot;GPL-2.0&quot;,
                &quot;build_host&quot;: &quot;sheep05&quot;,
                &quot;url&quot;: &quot;http://www.suse.com&quot;,
                &quot;build_date_time_t&quot;: 1436432119,
                &quot;relocations&quot;: &quot;(not relocatable)&quot;,
                &quot;source_rpm&quot;: &quot;virgo-dummy-1.0-1.1.src.rpm&quot;,
                &quot;install_date&quot;: &quot;2016-02-23T16:31:57Z&quot;,
                &quot;install_date_time_t&quot;: 1456241517,
                &quot;summary&quot;: &quot;Virgo dummy package&quot;,
                &quot;version&quot;: &quot;1.0&quot;,
                &quot;signature&quot;: (
                    &quot;DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9&quot;
                ),
                &quot;release&quot;: &quot;1.1&quot;,
                &quot;group&quot;: &quot;Applications/System&quot;,
                &quot;arch&quot;: &quot;noarch&quot;,
                &quot;size&quot;: &quot;17992&quot;,
            },
            &quot;libopenssl1_0_0&quot;: {
                &quot;build_date&quot;: &quot;2015-11-04T23:20:34Z&quot;,
                &quot;vendor&quot;: &quot;SUSE LLC &lt;https://www.suse.com/&gt;&quot;,
                &quot;description&quot;: &quot;The OpenSSL Project is a collaborative effort.&quot;,
                &quot;license&quot;: &quot;OpenSSL&quot;,
                &quot;build_host&quot;: &quot;sheep11&quot;,
                &quot;url&quot;: &quot;https://www.openssl.org/&quot;,
                &quot;build_date_time_t&quot;: 1446675634,
                &quot;relocations&quot;: &quot;(not relocatable)&quot;,
                &quot;source_rpm&quot;: &quot;openssl-1.0.1i-34.1.src.rpm&quot;,
                &quot;install_date&quot;: &quot;2016-02-23T16:31:35Z&quot;,
                &quot;install_date_time_t&quot;: 1456241495,
                &quot;summary&quot;: &quot;Secure Sockets and Transport Layer Security&quot;,
                &quot;version&quot;: &quot;1.0.1i&quot;,
                &quot;signature&quot;: (
                    &quot;RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82&quot;
                ),
                &quot;release&quot;: &quot;34.1&quot;,
                &quot;group&quot;: &quot;Productivity/Networking/Security&quot;,
                &quot;packager&quot;: &quot;https://www.suse.com/&quot;,
                &quot;arch&quot;: &quot;x86_64&quot;,
                &quot;size&quot;: &quot;2576912&quot;,
            },
        }
        with patch.dict(
            zypper.__salt__, {&quot;lowpkg.info&quot;: MagicMock(return_value=run_out)}
        ):
            installed = zypper.info_installed()
            # Test overall products length
            self.assertEqual(len(installed), 2)

            # Test translated fields
            for pkg_name, pkg_info in installed.items():
                self.assertEqual(
                    installed[pkg_name].get(&quot;source&quot;), run_out[pkg_name][&quot;source_rpm&quot;]
                )

            # Test keys transition from the lowpkg.info
            for pn_key, pn_val in run_out[&quot;virgo-dummy&quot;].items():
                if pn_key == &quot;source_rpm&quot;:
                    continue
                self.assertEqual(installed[&quot;virgo-dummy&quot;][pn_key], pn_val)

    def test_info_installed_with_non_ascii_char(self):
        &quot;&quot;&quot;
        Test the return information of the named package(s), installed on the system whith non-ascii chars

        :return:
        &quot;&quot;&quot;
        run_out = {&quot;vīrgô&quot;: {&quot;description&quot;: &quot;vīrgô d€šçripţiǫñ&quot;}}
        with patch.dict(
            zypper.__salt__, {&quot;lowpkg.info&quot;: MagicMock(return_value=run_out)}
        ):
            installed = zypper.info_installed()
            self.assertEqual(installed[&quot;vīrgô&quot;][&quot;description&quot;], &quot;vīrgô d€šçripţiǫñ&quot;)

    def test_info_installed_with_all_versions(self):
        &quot;&quot;&quot;
        Test the return information of all versions for the named package(s), installed on the system.

        :return:
        &quot;&quot;&quot;
        run_out = {
            &quot;virgo-dummy&quot;: [
                {
                    &quot;build_date&quot;: &quot;2015-07-09T10:55:19Z&quot;,
                    &quot;vendor&quot;: &quot;openSUSE Build Service&quot;,
                    &quot;description&quot;: (
                        &quot;This is the Virgo dummy package used for testing SUSE Manager&quot;
                    ),
                    &quot;license&quot;: &quot;GPL-2.0&quot;,
                    &quot;build_host&quot;: &quot;sheep05&quot;,
                    &quot;url&quot;: &quot;http://www.suse.com&quot;,
                    &quot;build_date_time_t&quot;: 1436432119,
                    &quot;relocations&quot;: &quot;(not relocatable)&quot;,
                    &quot;source_rpm&quot;: &quot;virgo-dummy-1.0-1.1.src.rpm&quot;,
                    &quot;install_date&quot;: &quot;2016-02-23T16:31:57Z&quot;,
                    &quot;install_date_time_t&quot;: 1456241517,
                    &quot;summary&quot;: &quot;Virgo dummy package&quot;,
                    &quot;version&quot;: &quot;1.0&quot;,
                    &quot;signature&quot;: (
                        &quot;DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9&quot;
                    ),
                    &quot;release&quot;: &quot;1.1&quot;,
                    &quot;group&quot;: &quot;Applications/System&quot;,
                    &quot;arch&quot;: &quot;i686&quot;,
                    &quot;size&quot;: &quot;17992&quot;,
                },
                {
                    &quot;build_date&quot;: &quot;2015-07-09T10:15:19Z&quot;,
                    &quot;vendor&quot;: &quot;openSUSE Build Service&quot;,
                    &quot;description&quot;: (
                        &quot;This is the Virgo dummy package used for testing SUSE Manager&quot;
                    ),
                    &quot;license&quot;: &quot;GPL-2.0&quot;,
                    &quot;build_host&quot;: &quot;sheep05&quot;,
                    &quot;url&quot;: &quot;http://www.suse.com&quot;,
                    &quot;build_date_time_t&quot;: 1436432119,
                    &quot;relocations&quot;: &quot;(not relocatable)&quot;,
                    &quot;source_rpm&quot;: &quot;virgo-dummy-1.0-1.1.src.rpm&quot;,
                    &quot;install_date&quot;: &quot;2016-02-23T16:31:57Z&quot;,
                    &quot;install_date_time_t&quot;: 14562415127,
                    &quot;summary&quot;: &quot;Virgo dummy package&quot;,
                    &quot;version&quot;: &quot;1.0&quot;,
                    &quot;signature&quot;: (
                        &quot;DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9&quot;
                    ),
                    &quot;release&quot;: &quot;1.1&quot;,
                    &quot;group&quot;: &quot;Applications/System&quot;,
                    &quot;arch&quot;: &quot;x86_64&quot;,
                    &quot;size&quot;: &quot;13124&quot;,
                },
            ],
            &quot;libopenssl1_0_0&quot;: [
                {
                    &quot;build_date&quot;: &quot;2015-11-04T23:20:34Z&quot;,
                    &quot;vendor&quot;: &quot;SUSE LLC &lt;https://www.suse.com/&gt;&quot;,
                    &quot;description&quot;: &quot;The OpenSSL Project is a collaborative effort.&quot;,
                    &quot;license&quot;: &quot;OpenSSL&quot;,
                    &quot;build_host&quot;: &quot;sheep11&quot;,
                    &quot;url&quot;: &quot;https://www.openssl.org/&quot;,
                    &quot;build_date_time_t&quot;: 1446675634,
                    &quot;relocations&quot;: &quot;(not relocatable)&quot;,
                    &quot;source_rpm&quot;: &quot;openssl-1.0.1i-34.1.src.rpm&quot;,
                    &quot;install_date&quot;: &quot;2016-02-23T16:31:35Z&quot;,
                    &quot;install_date_time_t&quot;: 1456241495,
                    &quot;summary&quot;: &quot;Secure Sockets and Transport Layer Security&quot;,
                    &quot;version&quot;: &quot;1.0.1i&quot;,
                    &quot;signature&quot;: (
                        &quot;RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82&quot;
                    ),
                    &quot;release&quot;: &quot;34.1&quot;,
                    &quot;group&quot;: &quot;Productivity/Networking/Security&quot;,
                    &quot;packager&quot;: &quot;https://www.suse.com/&quot;,
                    &quot;arch&quot;: &quot;x86_64&quot;,
                    &quot;size&quot;: &quot;2576912&quot;,
                }
            ],
        }
        with patch.dict(
            zypper.__salt__, {&quot;lowpkg.info&quot;: MagicMock(return_value=run_out)}
        ):
            installed = zypper.info_installed(all_versions=True)
            # Test overall products length
            self.assertEqual(len(installed), 2)

            # Test multiple versions for the same package
            for pkg_name, pkg_info_list in installed.items():
                self.assertEqual(
                    len(pkg_info_list), 2 if pkg_name == &quot;virgo-dummy&quot; else 1
                )
                for info in pkg_info_list:
                    self.assertTrue(info[&quot;arch&quot;] in (&quot;x86_64&quot;, &quot;i686&quot;))

    def test_info_available(self):
        &quot;&quot;&quot;
        Test return the information of the named package available for the system.

        :return:
        &quot;&quot;&quot;
        test_pkgs = [&quot;vim&quot;, &quot;emacs&quot;, &quot;python&quot;]
        with patch(
            &quot;salt.modules.zypperpkg.__zypper__&quot;,
            ZyppCallMock(return_value=get_test_data(&quot;zypper-available.txt&quot;)),
        ):
            available = zypper.info_available(*test_pkgs, refresh=False)
            self.assertEqual(len(available), 3)
            for pkg_name, pkg_info in available.items():
                self.assertIn(pkg_name, test_pkgs)

            self.assertEqual(available[&quot;emacs&quot;][&quot;status&quot;], &quot;up-to-date&quot;)
            self.assertTrue(available[&quot;emacs&quot;][&quot;installed&quot;])
            self.assertEqual(available[&quot;emacs&quot;][&quot;support level&quot;], &quot;Level 3&quot;)
            self.assertEqual(
                available[&quot;emacs&quot;][&quot;vendor&quot;], &quot;SUSE LLC &lt;https://www.suse.com/&gt;&quot;
            )
            self.assertEqual(available[&quot;emacs&quot;][&quot;summary&quot;], &quot;GNU Emacs Base Package&quot;)

            self.assertEqual(available[&quot;vim&quot;][&quot;status&quot;], &quot;not installed&quot;)
            self.assertFalse(available[&quot;vim&quot;][&quot;installed&quot;])
            self.assertEqual(available[&quot;vim&quot;][&quot;support level&quot;], &quot;Level 3&quot;)
            self.assertEqual(
                available[&quot;vim&quot;][&quot;vendor&quot;], &quot;SUSE LLC &lt;https://www.suse.com/&gt;&quot;
            )
            self.assertEqual(available[&quot;vim&quot;][&quot;summary&quot;], &quot;Vi IMproved&quot;)

    def test_latest_version(self):
        &quot;&quot;&quot;
        Test the latest version of the named package available for upgrade or installation.

        :return:
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.zypperpkg.__zypper__&quot;,
            ZyppCallMock(return_value=get_test_data(&quot;zypper-available.txt&quot;)),
        ), patch(&quot;salt.modules.zypperpkg.refresh_db&quot;, MagicMock(return_value=True)):
            self.assertEqual(zypper.latest_version(&quot;vim&quot;), &quot;7.4.326-2.62&quot;)
            self.assertDictEqual(
                zypper.latest_version(&quot;vim&quot;, &quot;fakepkg&quot;),
                {&quot;vim&quot;: &quot;7.4.326-2.62&quot;, &quot;fakepkg&quot;: &quot;&quot;},
            )

    def test_upgrade_success(self):
        &quot;&quot;&quot;
        Test system upgrade and dist-upgrade success.

        :return:
        &quot;&quot;&quot;
        with patch.dict(zypper.__grains__, {&quot;osrelease_info&quot;: [12, 1]}), patch(
            &quot;salt.modules.zypperpkg.refresh_db&quot;, MagicMock(return_value=True)
        ), patch(
            &quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False)
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.2&quot;}]),
                ):
                    ret = zypper.upgrade()
                    self.assertDictEqual(ret, {&quot;vim&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.2&quot;}})
                    zypper_mock.assert_any_call(&quot;update&quot;, &quot;--auto-agree-with-licenses&quot;)

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(
                        side_effect=[
                            {&quot;kernel-default&quot;: &quot;1.1&quot;},
                            {&quot;kernel-default&quot;: &quot;1.1,1.2&quot;},
                        ]
                    ),
                ):
                    ret = zypper.upgrade()
                    self.assertDictEqual(
                        ret, {&quot;kernel-default&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.1,1.2&quot;}}
                    )
                    zypper_mock.assert_any_call(&quot;update&quot;, &quot;--auto-agree-with-licenses&quot;)

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.1,1.2&quot;}]),
                ):
                    ret = zypper.upgrade()
                    self.assertDictEqual(ret, {&quot;vim&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.1,1.2&quot;}})
                    zypper_mock.assert_any_call(&quot;update&quot;, &quot;--auto-agree-with-licenses&quot;)

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.2&quot;}]),
                ):
                    ret = zypper.upgrade(dist_upgrade=True)
                    self.assertDictEqual(ret, {&quot;vim&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.2&quot;}})
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;, &quot;--auto-agree-with-licenses&quot;
                    )

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.1&quot;}]),
                ):
                    ret = zypper.upgrade(dist_upgrade=True, dryrun=True)
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;, &quot;--auto-agree-with-licenses&quot;, &quot;--dry-run&quot;
                    )
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;,
                        &quot;--auto-agree-with-licenses&quot;,
                        &quot;--dry-run&quot;,
                        &quot;--debug-solver&quot;,
                    )

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.1&quot;}]),
                ):
                    ret = zypper.upgrade(
                        dist_upgrade=True,
                        dryrun=True,
                        fromrepo=[&quot;Dummy&quot;, &quot;Dummy2&quot;],
                        novendorchange=True,
                    )
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;,
                        &quot;--auto-agree-with-licenses&quot;,
                        &quot;--dry-run&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy2&quot;,
                        &quot;--no-allow-vendor-change&quot;,
                    )
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;,
                        &quot;--auto-agree-with-licenses&quot;,
                        &quot;--dry-run&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy2&quot;,
                        &quot;--no-allow-vendor-change&quot;,
                        &quot;--debug-solver&quot;,
                    )

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.1&quot;}]),
                ):
                    ret = zypper.upgrade(
                        dist_upgrade=False, fromrepo=[&quot;Dummy&quot;, &quot;Dummy2&quot;], dryrun=False
                    )
                    zypper_mock.assert_any_call(
                        &quot;update&quot;,
                        &quot;--auto-agree-with-licenses&quot;,
                        &quot;--repo&quot;,
                        &quot;Dummy&quot;,
                        &quot;--repo&quot;,
                        &quot;Dummy2&quot;,
                    )

                with patch(
                    &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                    MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.2&quot;}]),
                ):
                    ret = zypper.upgrade(
                        dist_upgrade=True,
                        fromrepo=[&quot;Dummy&quot;, &quot;Dummy2&quot;],
                        novendorchange=True,
                    )
                    self.assertDictEqual(ret, {&quot;vim&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.2&quot;}})
                    zypper_mock.assert_any_call(
                        &quot;dist-upgrade&quot;,
                        &quot;--auto-agree-with-licenses&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy&quot;,
                        &quot;--from&quot;,
                        &quot;Dummy2&quot;,
                        &quot;--no-allow-vendor-change&quot;,
                    )

    def test_upgrade_kernel(self):
        &quot;&quot;&quot;
        Test kernel package upgrade success.

        :return:
        &quot;&quot;&quot;
        with patch.dict(zypper.__grains__, {&quot;osrelease_info&quot;: [12, 1]}), patch(
            &quot;salt.modules.zypperpkg.refresh_db&quot;, MagicMock(return_value=True)
        ), patch(
            &quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False)
        ):
            with patch.dict(
                zypper.__salt__,
                {
                    &quot;pkg_resource.parse_targets&quot;: MagicMock(
                        return_value=([&quot;kernel-default&quot;], None)
                    )
                },
            ):
                with patch(
                    &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
                ):
                    with patch(
                        &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                        MagicMock(
                            side_effect=[
                                {&quot;kernel-default&quot;: &quot;3.12.49-11.1&quot;},
                                {&quot;kernel-default&quot;: &quot;3.12.49-11.1,3.12.51-60.20.2&quot;},
                            ]
                        ),
                    ):
                        ret = zypper.install(
                            &quot;kernel-default&quot;, &quot;--auto-agree-with-licenses&quot;
                        )
                        self.assertDictEqual(
                            ret,
                            {
                                &quot;kernel-default&quot;: {
                                    &quot;old&quot;: &quot;3.12.49-11.1&quot;,
                                    &quot;new&quot;: &quot;3.12.49-11.1,3.12.51-60.20.2&quot;,
                                }
                            },
                        )

    def test_upgrade_failure(self):
        &quot;&quot;&quot;
        Test system upgrade failure.

        :return:
        &quot;&quot;&quot;
        zypper_out = &quot;&quot;&quot;
Loading repository data...
Reading installed packages...
Computing distribution upgrade...
Use 'zypper repos' to get the list of defined repositories.
Repository 'DUMMY' not found by its alias, number, or URI.
&quot;&quot;&quot;

        class FailingZypperDummy:
            def __init__(self):
                self.stdout = zypper_out
                self.stderr = &quot;&quot;
                self.pid = 1234
                self.exit_code = 555
                self.noraise = MagicMock()
                self.SUCCESS_EXIT_CODES = [0]

            def __call__(self, *args, **kwargs):
                return self

        with patch.dict(zypper.__grains__, {&quot;osrelease_info&quot;: [12, 1]}), patch(
            &quot;salt.modules.zypperpkg.__zypper__&quot;, FailingZypperDummy()
        ) as zypper_mock, patch(
            &quot;salt.modules.zypperpkg.refresh_db&quot;, MagicMock(return_value=True)
        ), patch(
            &quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False)
        ):
            zypper_mock.noraise.call = MagicMock()
            with patch(
                &quot;salt.modules.zypperpkg.list_pkgs&quot;,
                MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.1&quot;}]),
            ):
                with self.assertRaises(CommandExecutionError) as cmd_exc:
                    ret = zypper.upgrade(dist_upgrade=True, fromrepo=[&quot;DUMMY&quot;])
                self.assertEqual(cmd_exc.exception.info[&quot;changes&quot;], {})
                self.assertEqual(cmd_exc.exception.info[&quot;result&quot;][&quot;stdout&quot;], zypper_out)
                zypper_mock.noraise.call.assert_called_with(
                    &quot;dist-upgrade&quot;, &quot;--auto-agree-with-licenses&quot;, &quot;--from&quot;, &quot;DUMMY&quot;
                )

    def test_upgrade_available(self):
        &quot;&quot;&quot;
        Test whether or not an upgrade is available for a given package.

        :return:
        &quot;&quot;&quot;
        ref_out = get_test_data(&quot;zypper-available.txt&quot;)
        with patch(
            &quot;salt.modules.zypperpkg.__zypper__&quot;,
            ZyppCallMock(return_value=get_test_data(&quot;zypper-available.txt&quot;)),
        ), patch(&quot;salt.modules.zypperpkg.refresh_db&quot;, MagicMock(return_value=True)):
            for pkg_name in [&quot;emacs&quot;, &quot;python&quot;]:
                self.assertFalse(zypper.upgrade_available(pkg_name))
            self.assertTrue(zypper.upgrade_available(&quot;vim&quot;))

    def test_list_pkgs(self):
        &quot;&quot;&quot;
        Test packages listing.

        :return:
        &quot;&quot;&quot;

        def _add_data(data, key, value):
            data.setdefault(key, []).append(value)

        rpm_out = [
            &quot;protobuf-java_|-(none)_|-2.6.1_|-3.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;yast2-ftp-server_|-(none)_|-3.1.8_|-8.1_|-x86_64_|-(none)_|-1499257798&quot;,
            &quot;jose4j_|-(none)_|-0.4.4_|-2.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;apache-commons-cli_|-(none)_|-1.2_|-1.233_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;jakarta-commons-discovery_|-(none)_|-0.4_|-129.686_|-noarch_|-(none)_|-1498636511&quot;,
            &quot;susemanager-build-keys-web_|-(none)_|-12.0_|-5.1.develHead_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;gpg-pubkey_|-(none)_|-39db7c82_|-5847eb1f_|-(none)_|-(none)_|-1519203802&quot;,
            &quot;gpg-pubkey_|-(none)_|-8a7c64f9_|-5aaa93ca_|-(none)_|-(none)_|-1529925595&quot;,
            &quot;kernel-default_|-(none)_|-4.4.138_|-94.39.1_|-x86_64_|-(none)_|-1529936067&quot;,
            &quot;kernel-default_|-(none)_|-4.4.73_|-5.1_|-x86_64_|-(none)_|-1503572639&quot;,
            &quot;perseus-dummy_|-(none)_|-1.1_|-1.1_|-i586_|-(none)_|-1529936062&quot;,
        ]
        with patch.dict(zypper.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
            zypper.__salt__,
            {&quot;cmd.run&quot;: MagicMock(return_value=os.linesep.join(rpm_out))},
        ), patch.dict(zypper.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
            zypper.__salt__,
            {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
        ), patch.dict(
            zypper.__salt__, {&quot;pkg_resource.stringify&quot;: MagicMock()}
        ):
            pkgs = zypper.list_pkgs(versions_as_list=True)
            self.assertFalse(pkgs.get(&quot;gpg-pubkey&quot;, False))
            self.assertTrue(&quot;pkg.list_pkgs_None_[]&quot; in zypper.__context__)
            for pkg_name, pkg_version in {
                &quot;jakarta-commons-discovery&quot;: [&quot;0.4-129.686&quot;],
                &quot;yast2-ftp-server&quot;: [&quot;3.1.8-8.1&quot;],
                &quot;protobuf-java&quot;: [&quot;2.6.1-3.1.develHead&quot;],
                &quot;susemanager-build-keys-web&quot;: [&quot;12.0-5.1.develHead&quot;],
                &quot;apache-commons-cli&quot;: [&quot;1.2-1.233&quot;],
                &quot;kernel-default&quot;: [&quot;4.4.138-94.39.1&quot;, &quot;4.4.73-5.1&quot;],
                &quot;perseus-dummy.i586&quot;: [&quot;1.1-1.1&quot;],
                &quot;jose4j&quot;: [&quot;0.4.4-2.1.develHead&quot;],
            }.items():
                self.assertTrue(pkgs.get(pkg_name))
                self.assertEqual(pkgs[pkg_name], pkg_version)

    def test_list_pkgs_no_context(self):
        &quot;&quot;&quot;
        Test packages listing.

        :return:
        &quot;&quot;&quot;

        def _add_data(data, key, value):
            data.setdefault(key, []).append(value)

        rpm_out = [
            &quot;protobuf-java_|-(none)_|-2.6.1_|-3.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;yast2-ftp-server_|-(none)_|-3.1.8_|-8.1_|-x86_64_|-(none)_|-1499257798&quot;,
            &quot;jose4j_|-(none)_|-0.4.4_|-2.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;apache-commons-cli_|-(none)_|-1.2_|-1.233_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;jakarta-commons-discovery_|-(none)_|-0.4_|-129.686_|-noarch_|-(none)_|-1498636511&quot;,
            &quot;susemanager-build-keys-web_|-(none)_|-12.0_|-5.1.develHead_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;gpg-pubkey_|-(none)_|-39db7c82_|-5847eb1f_|-(none)_|-(none)_|-1519203802&quot;,
            &quot;gpg-pubkey_|-(none)_|-8a7c64f9_|-5aaa93ca_|-(none)_|-(none)_|-1529925595&quot;,
            &quot;kernel-default_|-(none)_|-4.4.138_|-94.39.1_|-x86_64_|-(none)_|-1529936067&quot;,
            &quot;kernel-default_|-(none)_|-4.4.73_|-5.1_|-x86_64_|-(none)_|-1503572639&quot;,
            &quot;perseus-dummy_|-(none)_|-1.1_|-1.1_|-i586_|-(none)_|-1529936062&quot;,
        ]
        with patch.dict(zypper.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
            zypper.__salt__,
            {&quot;cmd.run&quot;: MagicMock(return_value=os.linesep.join(rpm_out))},
        ), patch.dict(zypper.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
            zypper.__salt__,
            {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
        ), patch.dict(
            zypper.__salt__, {&quot;pkg_resource.stringify&quot;: MagicMock()}
        ), patch.object(
            zypper, &quot;_list_pkgs_from_context&quot;
        ) as list_pkgs_context_mock:
            pkgs = zypper.list_pkgs(versions_as_list=True, use_context=False)
            list_pkgs_context_mock.assert_not_called()
            list_pkgs_context_mock.reset_mock()

            pkgs = zypper.list_pkgs(versions_as_list=True, use_context=False)
            list_pkgs_context_mock.assert_not_called()
            list_pkgs_context_mock.reset_mock()

    def test_list_pkgs_with_attr(self):
        &quot;&quot;&quot;
        Test packages listing with the attr parameter

        :return:
        &quot;&quot;&quot;

        def _add_data(data, key, value):
            data.setdefault(key, []).append(value)

        rpm_out = [
            &quot;protobuf-java_|-(none)_|-2.6.1_|-3.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;yast2-ftp-server_|-(none)_|-3.1.8_|-8.1_|-x86_64_|-(none)_|-1499257798&quot;,
            &quot;jose4j_|-(none)_|-0.4.4_|-2.1.develHead_|-noarch_|-(none)_|-1499257756&quot;,
            &quot;apache-commons-cli_|-(none)_|-1.2_|-1.233_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;jakarta-commons-discovery_|-(none)_|-0.4_|-129.686_|-noarch_|-(none)_|-1498636511&quot;,
            &quot;susemanager-build-keys-web_|-(none)_|-12.0_|-5.1.develHead_|-noarch_|-(none)_|-1498636510&quot;,
            &quot;gpg-pubkey_|-(none)_|-39db7c82_|-5847eb1f_|-(none)_|-(none)_|-1519203802&quot;,
            &quot;gpg-pubkey_|-(none)_|-8a7c64f9_|-5aaa93ca_|-(none)_|-(none)_|-1529925595&quot;,
            &quot;kernel-default_|-(none)_|-4.4.138_|-94.39.1_|-x86_64_|-(none)_|-1529936067&quot;,
            &quot;kernel-default_|-(none)_|-4.4.73_|-5.1_|-x86_64_|-(none)_|-1503572639&quot;,
            &quot;perseus-dummy_|-(none)_|-1.1_|-1.1_|-i586_|-(none)_|-1529936062&quot;,
        ]
        with patch.dict(
            zypper.__salt__,
            {&quot;cmd.run&quot;: MagicMock(return_value=os.linesep.join(rpm_out))},
        ), patch.dict(zypper.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
            zypper.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}
        ), patch.dict(
            zypper.__salt__,
            {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
        ), patch.dict(
            zypper.__salt__, {&quot;pkg_resource.stringify&quot;: MagicMock()}
        ), patch.dict(
            pkg_resource.__salt__, {&quot;pkg.parse_arch&quot;: zypper.parse_arch}
        ):
            pkgs = zypper.list_pkgs(
                attr=[&quot;epoch&quot;, &quot;release&quot;, &quot;arch&quot;, &quot;install_date_time_t&quot;]
            )
            self.assertFalse(pkgs.get(&quot;gpg-pubkey&quot;, False))
            self.assertTrue(&quot;pkg.list_pkgs_None_[]&quot; in zypper.__context__)
            for pkg_name, pkg_attr in {
                &quot;jakarta-commons-discovery&quot;: [
                    {
                        &quot;version&quot;: &quot;0.4&quot;,
                        &quot;release&quot;: &quot;129.686&quot;,
                        &quot;arch&quot;: &quot;noarch&quot;,
                        &quot;install_date_time_t&quot;: 1498636511,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;yast2-ftp-server&quot;: [
                    {
                        &quot;version&quot;: &quot;3.1.8&quot;,
                        &quot;release&quot;: &quot;8.1&quot;,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;install_date_time_t&quot;: 1499257798,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;protobuf-java&quot;: [
                    {
                        &quot;version&quot;: &quot;2.6.1&quot;,
                        &quot;release&quot;: &quot;3.1.develHead&quot;,
                        &quot;install_date_time_t&quot;: 1499257756,
                        &quot;arch&quot;: &quot;noarch&quot;,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;susemanager-build-keys-web&quot;: [
                    {
                        &quot;version&quot;: &quot;12.0&quot;,
                        &quot;release&quot;: &quot;5.1.develHead&quot;,
                        &quot;arch&quot;: &quot;noarch&quot;,
                        &quot;install_date_time_t&quot;: 1498636510,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;apache-commons-cli&quot;: [
                    {
                        &quot;version&quot;: &quot;1.2&quot;,
                        &quot;release&quot;: &quot;1.233&quot;,
                        &quot;arch&quot;: &quot;noarch&quot;,
                        &quot;install_date_time_t&quot;: 1498636510,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;kernel-default&quot;: [
                    {
                        &quot;version&quot;: &quot;4.4.138&quot;,
                        &quot;release&quot;: &quot;94.39.1&quot;,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;install_date_time_t&quot;: 1529936067,
                        &quot;epoch&quot;: None,
                    },
                    {
                        &quot;version&quot;: &quot;4.4.73&quot;,
                        &quot;release&quot;: &quot;5.1&quot;,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;install_date_time_t&quot;: 1503572639,
                        &quot;epoch&quot;: None,
                    },
                ],
                &quot;perseus-dummy&quot;: [
                    {
                        &quot;version&quot;: &quot;1.1&quot;,
                        &quot;release&quot;: &quot;1.1&quot;,
                        &quot;arch&quot;: &quot;i586&quot;,
                        &quot;install_date_time_t&quot;: 1529936062,
                        &quot;epoch&quot;: None,
                    }
                ],
                &quot;jose4j&quot;: [
                    {
                        &quot;arch&quot;: &quot;noarch&quot;,
                        &quot;version&quot;: &quot;0.4.4&quot;,
                        &quot;release&quot;: &quot;2.1.develHead&quot;,
                        &quot;install_date_time_t&quot;: 1499257756,
                        &quot;epoch&quot;: None,
                    }
                ],
            }.items():
                self.assertTrue(pkgs.get(pkg_name))
                self.assertEqual(pkgs[pkg_name], pkg_attr)

    def test_list_pkgs_with_attr_multiple_versions(self):
        &quot;&quot;&quot;
        Test packages listing with the attr parameter reporting multiple version installed

        :return:
        &quot;&quot;&quot;

        def _add_data(data, key, value):
            data.setdefault(key, []).append(value)

        rpm_out = [
            &quot;glibc_|-2.12_|-1.212.el6_|-i686_|-_|-1542394210&quot;,
            &quot;glibc_|-2.12_|-1.212.el6_|-x86_64_|-_|-1542394204&quot;,
            &quot;virt-what_|-1.13_|-8.el7_|-x86_64_|-_|-1487838486&quot;,
            &quot;virt-what_|-1.10_|-2.el7_|-x86_64_|-_|-1387838486&quot;,
        ]

        with patch.dict(zypper.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
            zypper.__salt__,
            {&quot;cmd.run&quot;: MagicMock(return_value=os.linesep.join(rpm_out))},
        ), patch.dict(zypper.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
            zypper.__salt__,
            {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
        ), patch.dict(
            zypper.__salt__, {&quot;pkg_resource.stringify&quot;: MagicMock()}
        ), patch.dict(
            pkg_resource.__salt__, {&quot;pkg.parse_arch&quot;: zypper.parse_arch}
        ):
            pkgs = zypper.list_pkgs(
                attr=[&quot;epoch&quot;, &quot;release&quot;, &quot;arch&quot;, &quot;install_date_time_t&quot;]
            )
            expected_pkg_list = {
                &quot;glibc&quot;: [
                    {
                        &quot;version&quot;: &quot;2.12&quot;,
                        &quot;release&quot;: &quot;1.212.el6&quot;,
                        &quot;install_date_time_t&quot;: 1542394210,
                        &quot;arch&quot;: &quot;i686&quot;,
                        &quot;epoch&quot;: None,
                    },
                    {
                        &quot;version&quot;: &quot;2.12&quot;,
                        &quot;release&quot;: &quot;1.212.el6&quot;,
                        &quot;install_date_time_t&quot;: 1542394204,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;epoch&quot;: None,
                    },
                ],
                &quot;virt-what&quot;: [
                    {
                        &quot;version&quot;: &quot;1.10&quot;,
                        &quot;release&quot;: &quot;2.el7&quot;,
                        &quot;install_date_time_t&quot;: 1387838486,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;epoch&quot;: None,
                    },
                    {
                        &quot;version&quot;: &quot;1.13&quot;,
                        &quot;release&quot;: &quot;8.el7&quot;,
                        &quot;install_date_time_t&quot;: 1487838486,
                        &quot;arch&quot;: &quot;x86_64&quot;,
                        &quot;epoch&quot;: None,
                    },
                ],
            }
            for pkgname, pkginfo in pkgs.items():
                self.assertCountEqual(pkginfo, expected_pkg_list[pkgname])

    def test_list_patches(self):
        &quot;&quot;&quot;
        Test advisory patches listing.

        :return:
        &quot;&quot;&quot;

        ref_out = {
            &quot;stdout&quot;: get_test_data(&quot;zypper-patches.xml&quot;),
            &quot;stderr&quot;: None,
            &quot;retcode&quot;: 0,
        }

        PATCHES_RET = {
            &quot;SUSE-SLE-SERVER-12-SP2-2017-97&quot;: {
                &quot;installed&quot;: False,
                &quot;summary&quot;: &quot;Recommended update for ovmf&quot;,
            },
            &quot;SUSE-SLE-SERVER-12-SP2-2017-98&quot;: {
                &quot;installed&quot;: True,
                &quot;summary&quot;: &quot;Recommended update for kmod&quot;,
            },
            &quot;SUSE-SLE-SERVER-12-SP2-2017-99&quot;: {
                &quot;installed&quot;: False,
                &quot;summary&quot;: &quot;Security update for apache2&quot;,
            },
        }

        with patch.dict(
            zypper.__salt__, {&quot;cmd.run_all&quot;: MagicMock(return_value=ref_out)}
        ):
            list_patches = zypper.list_patches(refresh=False)
            self.assertEqual(len(list_patches), 3)
            self.assertDictEqual(list_patches, PATCHES_RET)

    @patch(
        &quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;)])
    )
    @patch(&quot;os.path.getsize&quot;, MagicMock(return_value=123456))
    @patch(&quot;os.path.getctime&quot;, MagicMock(return_value=1234567890.123456))
    @patch(
        &quot;fnmatch.filter&quot;,
        MagicMock(return_value=[&quot;/var/cache/zypper/packages/foo/bar/test_package.rpm&quot;]),
    )
    def test_list_downloaded_with_kwargs(self):
        &quot;&quot;&quot;
        Test downloaded packages listing.

        :return:
        &quot;&quot;&quot;
        DOWNLOADED_RET = {
            &quot;test-package&quot;: {
                &quot;1.0&quot;: {
                    &quot;path&quot;: &quot;/var/cache/zypper/packages/foo/bar/test_package.rpm&quot;,
                    &quot;size&quot;: 123456,
                    &quot;creation_date_time_t&quot;: 1234567890,
                    &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
                }
            }
        }

        with patch.dict(
            zypper.__salt__,
            {
                &quot;lowpkg.bin_pkg_info&quot;: MagicMock(
                    return_value={&quot;name&quot;: &quot;test-package&quot;, &quot;version&quot;: &quot;1.0&quot;}
                )
            },
        ):
            list_downloaded = zypper.list_downloaded(kw1=True, kw2=False)
            self.assertEqual(len(list_downloaded), 1)
            self.assertDictEqual(list_downloaded, DOWNLOADED_RET)

    @patch(
        &quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;)])
    )
    @patch(&quot;os.path.getsize&quot;, MagicMock(return_value=123456))
    @patch(&quot;os.path.getctime&quot;, MagicMock(return_value=1234567890.123456))
    @patch(
        &quot;fnmatch.filter&quot;,
        MagicMock(return_value=[&quot;/var/cache/zypper/packages/foo/bar/test_package.rpm&quot;]),
    )
    def test_list_downloaded(self):
        &quot;&quot;&quot;
        Test downloaded packages listing.

        :return:
        &quot;&quot;&quot;
        DOWNLOADED_RET = {
            &quot;test-package&quot;: {
                &quot;1.0&quot;: {
                    &quot;path&quot;: &quot;/var/cache/zypper/packages/foo/bar/test_package.rpm&quot;,
                    &quot;size&quot;: 123456,
                    &quot;creation_date_time_t&quot;: 1234567890,
                    &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
                }
            }
        }

        with patch.dict(
            zypper.__salt__,
            {
                &quot;lowpkg.bin_pkg_info&quot;: MagicMock(
                    return_value={&quot;name&quot;: &quot;test-package&quot;, &quot;version&quot;: &quot;1.0&quot;}
                )
            },
        ):
            list_downloaded = zypper.list_downloaded()
            self.assertEqual(len(list_downloaded), 1)
            self.assertDictEqual(list_downloaded, DOWNLOADED_RET)

    def test_download(self):
        &quot;&quot;&quot;
        Test package download
        :return:
        &quot;&quot;&quot;
        download_out = {
            &quot;stdout&quot;: get_test_data(&quot;zypper-download.xml&quot;),
            &quot;stderr&quot;: None,
            &quot;retcode&quot;: 0,
        }

        test_out = {
            &quot;nmap&quot;: {
                &quot;path&quot;: &quot;/var/cache/zypp/packages/SLE-12-x86_64-Pool/x86_64/nmap-6.46-1.72.x86_64.rpm&quot;,
                &quot;repository-alias&quot;: &quot;SLE-12-x86_64-Pool&quot;,
                &quot;repository-name&quot;: &quot;SLE-12-x86_64-Pool&quot;,
            }
        }

        with patch.dict(
            zypper.__salt__, {&quot;cmd.run_all&quot;: MagicMock(return_value=download_out)}
        ):
            with patch.dict(
                zypper.__salt__, {&quot;lowpkg.checksum&quot;: MagicMock(return_value=True)}
            ):
                self.assertEqual(zypper.download(&quot;nmap&quot;), test_out)
                test_out[&quot;_error&quot;] = &quot;The following package(s) failed to download: foo&quot;
                self.assertEqual(zypper.download(&quot;nmap&quot;, &quot;foo&quot;), test_out)

    @patch(&quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False))
    @patch(
        &quot;salt.modules.zypperpkg.list_downloaded&quot;,
        MagicMock(
            side_effect=[
                {},
                {
                    &quot;vim&quot;: {
                        &quot;1.1&quot;: {
                            &quot;path&quot;: &quot;/foo/bar/test.rpm&quot;,
                            &quot;size&quot;: 1234,
                            &quot;creation_date_time_t&quot;: 1234567890,
                            &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
                        }
                    }
                },
            ]
        ),
    )
    def test_install_with_downloadonly(self):
        &quot;&quot;&quot;
        Test a package installation with downloadonly=True.

        :return:
        &quot;&quot;&quot;
        with patch.dict(
            zypper.__salt__,
            {
                &quot;pkg_resource.parse_targets&quot;: MagicMock(
                    return_value=({&quot;vim&quot;: None}, &quot;repository&quot;)
                )
            },
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                ret = zypper.install(pkgs=[&quot;vim&quot;], downloadonly=True)
                zypper_mock.assert_called_once_with(
                    &quot;--no-refresh&quot;,
                    &quot;install&quot;,
                    &quot;--auto-agree-with-licenses&quot;,
                    &quot;--name&quot;,
                    &quot;--download-only&quot;,
                    &quot;vim&quot;,
                )
                self.assertDictEqual(
                    ret,
                    {
                        &quot;vim&quot;: {
                            &quot;new&quot;: {
                                &quot;1.1&quot;: {
                                    &quot;path&quot;: &quot;/foo/bar/test.rpm&quot;,
                                    &quot;size&quot;: 1234,
                                    &quot;creation_date_time_t&quot;: 1234567890,
                                    &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
                                }
                            },
                            &quot;old&quot;: &quot;&quot;,
                        }
                    },
                )

    @patch(&quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False))
    @patch(
        &quot;salt.modules.zypperpkg.list_downloaded&quot;,
        MagicMock(
            return_value={
                &quot;vim&quot;: {
                    &quot;1.1&quot;: {
                        &quot;path&quot;: &quot;/foo/bar/test.rpm&quot;,
                        &quot;size&quot;: 1234,
                        &quot;creation_date_time_t&quot;: 1234567890,
                        &quot;creation_date_time&quot;: &quot;2017-01-01T11:00:00&quot;,
                    }
                }
            }
        ),
    )
    def test_install_with_downloadonly_already_downloaded(self):
        &quot;&quot;&quot;
        Test a package installation with downloadonly=True when package is already downloaded.

        :return:
        &quot;&quot;&quot;
        with patch.dict(
            zypper.__salt__,
            {
                &quot;pkg_resource.parse_targets&quot;: MagicMock(
                    return_value=({&quot;vim&quot;: None}, &quot;repository&quot;)
                )
            },
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                ret = zypper.install(pkgs=[&quot;vim&quot;], downloadonly=True)
                zypper_mock.assert_called_once_with(
                    &quot;--no-refresh&quot;,
                    &quot;install&quot;,
                    &quot;--auto-agree-with-licenses&quot;,
                    &quot;--name&quot;,
                    &quot;--download-only&quot;,
                    &quot;vim&quot;,
                )
                self.assertDictEqual(ret, {})

    @patch(&quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False))
    @patch(
        &quot;salt.modules.zypperpkg._get_patches&quot;,
        MagicMock(
            return_value={&quot;SUSE-PATCH-1234&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;test&quot;}}
        ),
    )
    @patch(
        &quot;salt.modules.zypperpkg.list_pkgs&quot;,
        MagicMock(side_effect=[{&quot;vim&quot;: &quot;1.1&quot;}, {&quot;vim&quot;: &quot;1.2&quot;}]),
    )
    def test_install_advisory_patch_ok(self):
        &quot;&quot;&quot;
        Test successfully advisory patch installation.

        :return:
        &quot;&quot;&quot;
        with patch.dict(
            zypper.__salt__,
            {
                &quot;pkg_resource.parse_targets&quot;: MagicMock(
                    return_value=({&quot;SUSE-PATCH-1234&quot;: None}, &quot;advisory&quot;)
                )
            },
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                ret = zypper.install(advisory_ids=[&quot;SUSE-PATCH-1234&quot;])
                zypper_mock.assert_called_once_with(
                    &quot;--no-refresh&quot;,
                    &quot;install&quot;,
                    &quot;--auto-agree-with-licenses&quot;,
                    &quot;--name&quot;,
                    &quot;patch:SUSE-PATCH-1234&quot;,
                )
                self.assertDictEqual(ret, {&quot;vim&quot;: {&quot;old&quot;: &quot;1.1&quot;, &quot;new&quot;: &quot;1.2&quot;}})

    @patch(&quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False))
    @patch(
        &quot;salt.modules.zypperpkg._get_patches&quot;,
        MagicMock(
            return_value={&quot;SUSE-PATCH-1234&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;test&quot;}}
        ),
    )
    @patch(&quot;salt.modules.zypperpkg.list_pkgs&quot;, MagicMock(return_value={&quot;vim&quot;: &quot;1.1&quot;}))
    def test_install_advisory_patch_failure(self):
        &quot;&quot;&quot;
        Test failing advisory patch installation because patch does not exist.

        :return:
        &quot;&quot;&quot;
        with patch.dict(
            zypper.__salt__,
            {
                &quot;pkg_resource.parse_targets&quot;: MagicMock(
                    return_value=({&quot;SUSE-PATCH-XXX&quot;: None}, &quot;advisory&quot;)
                )
            },
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                with self.assertRaisesRegex(
                    CommandExecutionError, '^Advisory id &quot;SUSE-PATCH-XXX&quot; not found$'
                ):
                    zypper.install(advisory_ids=[&quot;SUSE-PATCH-XXX&quot;])

    @patch(&quot;salt.modules.zypperpkg._systemd_scope&quot;, MagicMock(return_value=False))
    @patch(
        &quot;salt.modules.zypperpkg.list_products&quot;,
        MagicMock(return_value={&quot;openSUSE&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;test&quot;}}),
    )
    @patch(
        &quot;salt.modules.zypperpkg.list_pkgs&quot;,
        MagicMock(
            side_effect=[{&quot;product:openSUSE&quot;: &quot;15.2&quot;}, {&quot;product:openSUSE&quot;: &quot;15.3&quot;}]
        ),
    )
    def test_install_product_ok(self):
        &quot;&quot;&quot;
        Test successfully product installation.
        &quot;&quot;&quot;
        with patch.dict(
            zypper.__salt__,
            {
                &quot;pkg_resource.parse_targets&quot;: MagicMock(
                    return_value=([&quot;product:openSUSE&quot;], None)
                )
            },
        ):
            with patch(
                &quot;salt.modules.zypperpkg.__zypper__.noraise.call&quot;, MagicMock()
            ) as zypper_mock:
                ret = zypper.install(&quot;product:openSUSE&quot;, includes=[&quot;product&quot;])
                zypper_mock.assert_called_once_with(
                    &quot;--no-refresh&quot;,
                    &quot;install&quot;,
                    &quot;--auto-agree-with-licenses&quot;,
                    &quot;--name&quot;,
                    &quot;product:openSUSE&quot;,
                )
                self.assertDictEqual(
                    ret, {&quot;product:openSUSE&quot;: {&quot;old&quot;: &quot;15.2&quot;, &quot;new&quot;: &quot;15.3&quot;}}
                )

    def test_remove_purge(self):
        &quot;&quot;&quot;
        Test package removal
        :return:
        &quot;&quot;&quot;

        class ListPackages:
            def __init__(self):
                self._packages = [&quot;vim&quot;, &quot;pico&quot;]
                self._pkgs = {
                    &quot;vim&quot;: &quot;0.18.0&quot;,
                    &quot;emacs&quot;: &quot;24.0.1&quot;,
                    &quot;pico&quot;: &quot;0.1.1&quot;,
                }

            def __call__(self, root=None, includes=None):
                pkgs = self._pkgs.copy()
                for target in self._packages:
                    if self._pkgs.get(target):
                        del self._pkgs[target]

                return pkgs

        parsed_targets = [{&quot;vim&quot;: None, &quot;pico&quot;: None}, None]
        cmd_out = {&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;, &quot;stderr&quot;: &quot;&quot;}

        # If config.get starts being used elsewhere, we'll need to write a
        # side_effect function.
        patches = {
            &quot;cmd.run_all&quot;: MagicMock(return_value=cmd_out),
            &quot;pkg_resource.parse_targets&quot;: MagicMock(return_value=parsed_targets),
            &quot;pkg_resource.stringify&quot;: MagicMock(),
            &quot;config.get&quot;: MagicMock(return_value=True),
        }

        with patch.dict(zypper.__salt__, patches):
            with patch(&quot;salt.modules.zypperpkg.list_pkgs&quot;, ListPackages()):
                diff = zypper.remove(name=&quot;vim,pico&quot;)
                for pkg_name in [&quot;vim&quot;, &quot;pico&quot;]:
                    self.assertTrue(diff.get(pkg_name))
                    self.assertTrue(diff[pkg_name][&quot;old&quot;])
                    self.assertFalse(diff[pkg_name][&quot;new&quot;])

    def test_repo_value_info(self):
        &quot;&quot;&quot;
        Tests if repo info is properly parsed.

        :return:
        &quot;&quot;&quot;
        repos_cfg = configparser.ConfigParser()
        for cfg in [&quot;zypper-repo-1.cfg&quot;, &quot;zypper-repo-2.cfg&quot;]:
            repos_cfg.readfp(io.StringIO(get_test_data(cfg)))

        for alias in repos_cfg.sections():
            r_info = zypper._get_repo_info(alias, repos_cfg=repos_cfg)
            self.assertEqual(type(r_info[&quot;type&quot;]), type(None))
            self.assertEqual(type(r_info[&quot;enabled&quot;]), bool)
            self.assertEqual(type(r_info[&quot;autorefresh&quot;]), bool)
            self.assertEqual(type(r_info[&quot;baseurl&quot;]), str)
            self.assertEqual(r_info[&quot;type&quot;], None)
            self.assertEqual(r_info[&quot;enabled&quot;], alias == &quot;SLE12-SP1-x86_64-Update&quot;)
            self.assertEqual(r_info[&quot;autorefresh&quot;], alias == &quot;SLE12-SP1-x86_64-Update&quot;)

    def test_repo_add_nomod_noref(self):
        &quot;&quot;&quot;
        Test mod_repo adds the new repo and nothing else

        :return:
        &quot;&quot;&quot;
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        with zypper_patcher:
            zypper.mod_repo(name, **{&quot;url&quot;: url})
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [call(&quot;ar&quot;, url, name)],
            )
            self.assertTrue(
                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
            )

    def test_repo_noadd_nomod_noref(self):
        &quot;&quot;&quot;
        Test mod_repo detects the repo already exists,
        no modification was requested and no refresh requested either

        :return:
        &quot;&quot;&quot;
        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        self.zypper_patcher_config[&quot;_get_configured_repos&quot;] = Mock(
            **{&quot;return_value.sections.return_value&quot;: [name]}
        )
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        with zypper_patcher:
            out = zypper.mod_repo(name, alias=&quot;new-alias&quot;)
            self.assertEqual(
                out[&quot;comment&quot;],
                &quot;Specified arguments did not result in modification of repo&quot;,
            )
            self.assertTrue(zypper.__zypper__(root=None).xml.call.call_count == 0)
            self.assertTrue(
                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
            )

    def test_repo_noadd_modbaseurl_ref(self):
        &quot;&quot;&quot;
        Test mod_repo detects the repo already exists,
        no modification was requested and no refresh requested either

        :return:
        &quot;&quot;&quot;
        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        self.zypper_patcher_config[&quot;_get_configured_repos&quot;] = Mock(
            **{&quot;return_value.sections.side_effect&quot;: [[name], [], [], [name]]}
        )
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        with zypper_patcher:
            params = {&quot;baseurl&quot;: url + &quot;-changed&quot;, &quot;enabled&quot;: False}
            zypper.mod_repo(name, **params)
            expected_params = {
                &quot;alias&quot;: &quot;mock-repo-name&quot;,
                &quot;autorefresh&quot;: True,
                &quot;baseurl&quot;: &quot;http://repo.url/some/path-changed&quot;,
                &quot;enabled&quot;: False,
                &quot;priority&quot;: 1,
                &quot;cache&quot;: False,
                &quot;keeppackages&quot;: False,
                &quot;type&quot;: &quot;rpm-md&quot;,
                &quot;root&quot;: None,
            }
            self.assertEqual(zypper.mod_repo.call_count, 2)
            self.assertEqual(
                zypper.mod_repo.mock_calls[1], call(name, **expected_params)
            )

    def test_repo_add_mod_noref(self):
        &quot;&quot;&quot;
        Test mod_repo adds the new repo and call modify to update autorefresh

        :return:
        &quot;&quot;&quot;
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        with zypper_patcher:
            zypper.mod_repo(name, **{&quot;url&quot;: url, &quot;refresh&quot;: True})
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [call(&quot;ar&quot;, url, name)],
            )
            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                &quot;mr&quot;, &quot;--refresh&quot;, name
            )

    def test_repo_noadd_mod_noref(self):
        &quot;&quot;&quot;
        Test mod_repo detects the repository exists,
        calls modify to update 'autorefresh' but does not call refresh

        :return:
        &quot;&quot;&quot;
        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        self.zypper_patcher_config[&quot;_get_configured_repos&quot;] = Mock(
            **{&quot;return_value.sections.return_value&quot;: [name]}
        )
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )
        with zypper_patcher:
            zypper.mod_repo(name, **{&quot;url&quot;: url, &quot;refresh&quot;: True})
            self.assertTrue(zypper.__zypper__(root=None).xml.call.call_count == 0)
            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                &quot;mr&quot;, &quot;--refresh&quot;, name
            )

    def test_repo_add_nomod_ref(self):
        &quot;&quot;&quot;
        Test mod_repo adds the new repo and refreshes the repo with
            `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`

        :return:
        &quot;&quot;&quot;
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        with zypper_patcher:
            zypper.mod_repo(name, **{&quot;url&quot;: url, &quot;gpgautoimport&quot;: True})
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [
                    call(&quot;ar&quot;, url, name),
                    call(&quot;--gpg-auto-import-keys&quot;, &quot;refresh&quot;, name),
                ],
            )
            self.assertTrue(
                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
            )

    def test_repo_noadd_nomod_ref(self):
        &quot;&quot;&quot;
        Test mod_repo detects the repo already exists,
        has nothing to modify and refreshes the repo with
            `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`

        :return:
        &quot;&quot;&quot;
        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        self.zypper_patcher_config[&quot;_get_configured_repos&quot;] = Mock(
            **{&quot;return_value.sections.return_value&quot;: [name]}
        )
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        with zypper_patcher:
            zypper.mod_repo(name, **{&quot;url&quot;: url, &quot;gpgautoimport&quot;: True})
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [call(&quot;--gpg-auto-import-keys&quot;, &quot;refresh&quot;, name)],
            )
            self.assertTrue(
                zypper.__zypper__(root=None).refreshable.xml.call.call_count == 0
            )

    def test_repo_add_mod_ref(self):
        &quot;&quot;&quot;
        Test mod_repo adds the new repo,
        calls modify to update 'autorefresh' and refreshes the repo with
            `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`

        :return:
        &quot;&quot;&quot;
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        with zypper_patcher:
            zypper.mod_repo(
                name, **{&quot;url&quot;: url, &quot;refresh&quot;: True, &quot;gpgautoimport&quot;: True}
            )
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [
                    call(&quot;ar&quot;, url, name),
                    call(&quot;--gpg-auto-import-keys&quot;, &quot;refresh&quot;, name),
                ],
            )
            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                &quot;--gpg-auto-import-keys&quot;, &quot;mr&quot;, &quot;--refresh&quot;, name
            )

    def test_repo_noadd_mod_ref(self):
        &quot;&quot;&quot;
        Test mod_repo detects the repo already exists,
        calls modify to update 'autorefresh' and refreshes the repo with
            `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`

        :return:
        &quot;&quot;&quot;
        url = self.new_repo_config[&quot;url&quot;]
        name = self.new_repo_config[&quot;name&quot;]
        self.zypper_patcher_config[&quot;_get_configured_repos&quot;] = Mock(
            **{&quot;return_value.sections.return_value&quot;: [name]}
        )
        zypper_patcher = patch.multiple(
            &quot;salt.modules.zypperpkg&quot;, **self.zypper_patcher_config
        )

        with zypper_patcher:
            zypper.mod_repo(
                name, **{&quot;url&quot;: url, &quot;refresh&quot;: True, &quot;gpgautoimport&quot;: True}
            )
            self.assertEqual(
                zypper.__zypper__(root=None).xml.call.call_args_list,
                [call(&quot;--gpg-auto-import-keys&quot;, &quot;refresh&quot;, name)],
            )
            zypper.__zypper__(root=None).refreshable.xml.call.assert_called_once_with(
                &quot;--gpg-auto-import-keys&quot;, &quot;mr&quot;, &quot;--refresh&quot;, name
            )

    def test_wildcard_to_query_match_all(self):
        &quot;&quot;&quot;
        Test wildcard to query match all pattern
        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;SLE-12-SP2-x86_64-Pool&quot;/&gt;
        &lt;solvable status=&quot;not-installed&quot; name=&quot;libzypp&quot; kind=&quot;srcpackage&quot; edition=&quot;16.3.2-25.1&quot; arch=&quot;noarch&quot; repository=&quot;SLE-12-SP2-x86_64-Update&quot;/&gt;
        &lt;solvable status=&quot;not-installed&quot; name=&quot;libzypp&quot; kind=&quot;srcpackage&quot; edition=&quot;16.5.2-27.9.1&quot; arch=&quot;noarch&quot; repository=&quot;SLE-12-SP2-x86_64-Update&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.3.2-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;SLE-12-SP2-x86_64-Update&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.5.2-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;SLE-12-SP2-x86_64-Update&quot;/&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;(System Packages)&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
                &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        wcard = zypper.Wildcard(_zpr)
        wcard.name, wcard.version = &quot;libzypp&quot;, &quot;*&quot;
        assert wcard._get_scope_versions(wcard._get_available_versions()) == [
            &quot;16.2.4-19.5&quot;,
            &quot;16.3.2-25.1&quot;,
            &quot;16.5.2-27.9.1&quot;,
        ]

    def test_wildcard_to_query_multiple_asterisk(self):
        &quot;&quot;&quot;
        Test wildcard to query match multiple asterisk
        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;

        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        wcard = zypper.Wildcard(_zpr)
        wcard.name, wcard.version = &quot;libzypp&quot;, &quot;16.2.*-2*&quot;
        assert wcard._get_scope_versions(wcard._get_available_versions()) == [
            &quot;16.2.5-25.1&quot;,
            &quot;16.2.6-27.9.1&quot;,
        ]

    def test_wildcard_to_query_exact_match_at_end(self):
        &quot;&quot;&quot;
        Test wildcard to query match exact pattern at the end
        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;

        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        wcard = zypper.Wildcard(_zpr)
        wcard.name, wcard.version = &quot;libzypp&quot;, &quot;16.2.5*&quot;
        assert wcard._get_scope_versions(wcard._get_available_versions()) == [
            &quot;16.2.5-25.1&quot;
        ]

    def test_wildcard_to_query_exact_match_at_beginning(self):
        &quot;&quot;&quot;
        Test wildcard to query match exact pattern at the beginning
        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;

        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        wcard = zypper.Wildcard(_zpr)
        wcard.name, wcard.version = &quot;libzypp&quot;, &quot;*.1&quot;
        assert wcard._get_scope_versions(wcard._get_available_versions()) == [
            &quot;16.2.5-25.1&quot;,
            &quot;17.2.6-27.9.1&quot;,
        ]

    def test_wildcard_to_query_usage(self):
        &quot;&quot;&quot;
        Test wildcard to query usage.

        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        assert zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;16.2.4*&quot;) == &quot;16.2.4-19.5&quot;
        assert zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;16.2*&quot;) == &quot;16.2.5-25.1&quot;
        assert zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;*6-*&quot;) == &quot;17.2.6-27.9.1&quot;
        assert zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;*.1&quot;) == &quot;17.2.6-27.9.1&quot;

    def test_wildcard_to_query_noversion(self):
        &quot;&quot;&quot;
        Test wildcard to query when no version has been passed on.

        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        assert zypper.Wildcard(_zpr)(&quot;libzypp&quot;, None) is None

    def test_wildcard_to_query_typecheck(self):
        &quot;&quot;&quot;
        Test wildcard to query typecheck.

        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        assert isinstance(zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;*.1&quot;), str)

    def test_wildcard_to_query_condition_preservation(self):
        &quot;&quot;&quot;
        Test wildcard to query Zypper condition preservation.

        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))

        for op in zypper.Wildcard.Z_OP:
            assert zypper.Wildcard(_zpr)(
                &quot;libzypp&quot;, &quot;{}*.1&quot;.format(op)
            ) == &quot;{}17.2.6-27.9.1&quot;.format(op)

        # Auto-fix feature: moves operator from end to front
        for op in zypper.Wildcard.Z_OP:
            assert zypper.Wildcard(_zpr)(
                &quot;libzypp&quot;, &quot;16*{}&quot;.format(op)
            ) == &quot;{}16.2.5-25.1&quot;.format(op)

    def test_wildcard_to_query_unsupported_operators(self):
        &quot;&quot;&quot;
        Test wildcard to query unsupported operators.

        :return:
        &quot;&quot;&quot;
        xmldoc = &quot;&quot;&quot;&lt;?xml version='1.0'?&gt;&lt;stream&gt;
        &lt;search-result version=&quot;0.0&quot;&gt;&lt;solvable-list&gt;
        &lt;solvable status=&quot;installed&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.4-19.5&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;16.2.5-25.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;solvable status=&quot;other-version&quot; name=&quot;libzypp&quot; kind=&quot;package&quot; edition=&quot;17.2.6-27.9.1&quot; arch=&quot;x86_64&quot; repository=&quot;foo&quot;/&gt;
        &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
        &quot;&quot;&quot;
        _zpr = MagicMock()
        _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
        with self.assertRaises(CommandExecutionError):
            for op in [&quot;&gt;&gt;&quot;, &quot;==&quot;, &quot;&lt;&lt;&quot;, &quot;+&quot;]:
                zypper.Wildcard(_zpr)(&quot;libzypp&quot;, &quot;{}*.1&quot;.format(op))

    @patch(&quot;salt.modules.zypperpkg._get_visible_patterns&quot;)
    def test__get_installed_patterns(self, get_visible_patterns):
        &quot;&quot;&quot;Test installed patterns in the system&quot;&quot;&quot;
        get_visible_patterns.return_value = {
            &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
            &quot;package-b&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;description b&quot;},
        }

        salt_mock = {
            &quot;cmd.run&quot;: MagicMock(
                return_value=&quot;&quot;&quot;pattern() = package-a
pattern-visible()
pattern() = package-c&quot;&quot;&quot;
            ),
        }
        with patch.dict(&quot;salt.modules.zypperpkg.__salt__&quot;, salt_mock):
            assert zypper._get_installed_patterns() == {
                &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
                &quot;package-c&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;Non-visible pattern&quot;},
            }

    @patch(&quot;salt.modules.zypperpkg._get_visible_patterns&quot;)
    def test__get_installed_patterns_with_alias(self, get_visible_patterns):
        &quot;&quot;&quot;Test installed patterns in the system if they have alias&quot;&quot;&quot;
        get_visible_patterns.return_value = {
            &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
            &quot;package-b&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;description b&quot;},
        }

        salt_mock = {
            &quot;cmd.run&quot;: MagicMock(
                return_value=&quot;&quot;&quot;pattern() = .package-a-alias
pattern() = package-a
pattern-visible()
pattern() = package-c&quot;&quot;&quot;
            ),
        }
        with patch.dict(&quot;salt.modules.zypperpkg.__salt__&quot;, salt_mock):
            assert zypper._get_installed_patterns() == {
                &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
                &quot;package-c&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;Non-visible pattern&quot;},
            }

    @patch(&quot;salt.modules.zypperpkg._get_visible_patterns&quot;)
    def test_list_patterns(self, get_visible_patterns):
        &quot;&quot;&quot;Test available patterns in the repo&quot;&quot;&quot;
        get_visible_patterns.return_value = {
            &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
            &quot;package-b&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;description b&quot;},
        }
        assert zypper.list_patterns() == {
            &quot;package-a&quot;: {&quot;installed&quot;: True, &quot;summary&quot;: &quot;description a&quot;},
            &quot;package-b&quot;: {&quot;installed&quot;: False, &quot;summary&quot;: &quot;description b&quot;},
        }

    def test__clean_cache_empty(self):
        &quot;&quot;&quot;Test that an empty cached can be cleaned&quot;&quot;&quot;
        context = {}
        with patch.dict(zypper.__context__, context):
            zypper._clean_cache()
            assert context == {}

    def test__clean_cache_filled(self):
        &quot;&quot;&quot;Test that a filled cached can be cleaned&quot;&quot;&quot;
        context = {
            &quot;pkg.list_pkgs_/mnt_[]&quot;: None,
            &quot;pkg.list_pkgs_/mnt_[patterns]&quot;: None,
            &quot;pkg.list_provides&quot;: None,
            &quot;pkg.other_data&quot;: None,
        }
        with patch.dict(zypper.__context__, context):
            zypper._clean_cache()
            self.assertEqual(zypper.__context__, {&quot;pkg.other_data&quot;: None})

    def test_services_need_restart(self):
        &quot;&quot;&quot;
        Test that zypper ps is used correctly to list services that need to
        be restarted.
        &quot;&quot;&quot;
        expected = [&quot;salt-minion&quot;, &quot;firewalld&quot;]
        zypper_output = &quot;salt-minion\nfirewalld&quot;
        zypper_mock = Mock()
        zypper_mock(root=None).nolock.call = Mock(return_value=zypper_output)

        with patch(&quot;salt.modules.zypperpkg.__zypper__&quot;, zypper_mock):
            assert zypper.services_need_restart() == expected
            zypper_mock(root=None).nolock.call.assert_called_with(&quot;ps&quot;, &quot;-sss&quot;)
</PRE>
</div>
  </div>
</body>
</html>
