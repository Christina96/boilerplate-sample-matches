<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ldap.py &amp; test_zypperpkg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ldap.py &amp; test_zypperpkg_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ldap.py (4.784689%)<th>test_zypperpkg_1.py (1.2760527%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(328-341)<td><a href="#" name="0">(178-187)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(243-257)<td><a href="#" name="1">(169-178)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ldap.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import attr
4 import pytest
5 import salt.states.ldap
6 from salt.utils.oset import OrderedSet
7 from salt.utils.stringutils import to_bytes
8 log = logging.getLogger(__name__)
9 @attr.s
10 class LdapDB:
11     db = attr.ib(init=False, default=attr.Factory(dict))
12     def dummy_connect(self, connect_spec):
13         return _dummy_ctx()
14     def dummy_search(self, connect_spec, base, scope):
15         if base not in self.db:
16             return {}
17         return {
18             base: {
19                 attr: list(self.db[base][attr])
20                 for attr in self.db[base]
21                 if len(self.db[base][attr])
22             }
23         }
24     def dummy_add(self, connect_spec, dn, attributes):
25         assert dn not in self.db
26         assert attributes
27         self.db[dn] = {}
28         for attr, vals in attributes.items():
29             assert vals
30             self.db[dn][attr] = OrderedSet(vals)
31         return True
32     def dummy_delete(self, connect_spec, dn):
33         assert dn in self.db
34         del self.db[dn]
35         return True
36     def dummy_change(self, connect_spec, dn, before, after):
37         assert before != after
38         assert before
39         assert after
40         assert dn in self.db
41         e = self.db[dn]
42         assert e == before
43         all_attrs = OrderedSet()
44         all_attrs.update(before)
45         all_attrs.update(after)
46         directives = []
47         for attr in all_attrs:
48             if attr not in before:
49                 assert attr in after
50                 assert after[attr]
51                 directives.append(("add", attr, after[attr]))
52             elif attr not in after:
53                 assert attr in before
54                 assert before[attr]
55                 directives.append(("delete", attr, ()))
56             else:
57                 assert before[attr]
58                 assert after[attr]
59                 to_del = before[attr] - after[attr]
60                 if to_del:
61                     directives.append(("delete", attr, to_del))
62                 to_add = after[attr] - before[attr]
63                 if to_add:
64                     directives.append(("add", attr, to_add))
65         return self.dummy_modify(connect_spec, dn, directives)
66     def dummy_modify(self, connect_spec, dn, directives):
67         assert dn in self.db
68         e = self.db[dn]
69         for op, attr, vals in directives:
70             if op == "add":
71                 assert vals
72                 existing_vals = e.setdefault(attr, OrderedSet())
73                 for val in vals:
74                     assert val not in existing_vals
75                     existing_vals.add(val)
76             elif op == "delete":
77                 assert attr in e
78                 existing_vals = e[attr]
79                 assert existing_vals
80                 if not vals:
81                     del e[attr]
82                     continue
83                 for val in vals:
84                     assert val in existing_vals
85                     existing_vals.remove(val)
86                 if not existing_vals:
87                     del e[attr]
88             elif op == "replace":
89                 e.pop(attr, None)
90                 e[attr] = OrderedSet(vals)
91             else:
92                 raise ValueError()
93         return True
94     def dump_db(self, d=None):
95         if d is None:
96             d = self.db
97         return {dn: {attr: list(d[dn][attr]) for attr in d[dn]} for dn in d}
98 @pytest.fixture
99 def db():
100     return LdapDB()
101 @pytest.fixture
102 def complex_db(db):
103     db.db = {
104         "dnfoo": {
105             "attrfoo1": OrderedSet(
106                 (
107                     b"valfoo1.1",
108                     b"valfoo1.2",
109                 )
110             ),
111             "attrfoo2": OrderedSet((b"valfoo2.1",)),
112         },
113         "dnbar": {
114             "attrbar1": OrderedSet(
115                 (
116                     b"valbar1.1",
117                     b"valbar1.2",
118                 )
119             ),
120             "attrbar2": OrderedSet((b"valbar2.1",)),
121         },
122     }
123     return db
124 @pytest.fixture
125 def no_change_complex_db(db):
126     db.db = {
127         "dnfoo": {
128             "attrfoo1": OrderedSet(
129                 (
130                     b"valfoo1.1",
131                     b"valfoo1.2",
132                 )
133             ),
134             "attrfoo2": OrderedSet((b"valfoo2.1",)),
135         },
136         "dnbar": {
137             "attrbar1": OrderedSet(
138                 (
139                     b"valbar1.1",
140                     b"valbar1.2",
141                 )
142             ),
143             "attrbar2": OrderedSet((b"valbar2.1",)),
144         },
145     }
146     return db
147 class _dummy_ctx:
148     def __init__(self):
149         pass
150     def __enter__(self):
151         return self
152     def __exit__(self, *exc):
153         pass
154 @pytest.fixture
155 def configure_loader_modules(db):
156     salt_dunder = {
157         "ldap3.connect": db.dummy_connect,
158         "ldap3.search": db.dummy_search,
159         "ldap3.add": db.dummy_add,
160         "ldap3.delete": db.dummy_delete,
161         "ldap3.change": db.dummy_change,
162         "ldap3.modify": db.dummy_modify,
163     }
164     return {salt.states.ldap: {"__opts__": {"test": False}, "__salt__": salt_dunder}}
165 def _test_helper(init_db, expected_ret, replace, delete_others=False):
166     old = init_db.dump_db()
167     new = init_db.dump_db()
168     expected_db = copy.deepcopy(init_db.db)
169     for dn, attrs in replace.items():
170         for attr, vals in attrs.items():
171             vals = [to_bytes(val) for val in vals]
172             if vals:
173                 new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
174                 expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
175             elif dn in expected_db:
176                 new[dn].pop(attr, None)
177                 expected_db[dn].pop(attr, None)
178         if not expected_db.get(dn, {}):
179             new.pop(dn, None)
180             expected_db.pop(dn, None)
181     if delete_others:
182         dn_to_delete = OrderedSet()
183         for dn, attrs in expected_db.items():
184             if dn in replace:
185                 to_delete = OrderedSet()
186                 for attr, vals in attrs.items():
187                     if attr not in replace[dn]:
188                         to_delete.add(attr)
189                 for attr in to_delete:
190                     del attrs[attr]
191                     del new[dn][attr]
192                 if not attrs:
193                     dn_to_delete.add(dn)
194         for dn in dn_to_delete:
195             del new[dn]
196             del expected_db[dn]
197     name = "ldapi:///"
198     expected_ret["name"] = name
199     expected_ret.setdefault("result", True)
200     expected_ret.setdefault("comment", "Successfully updated LDAP entries")
201     expected_ret.setdefault(
202         "changes",
203         {
204                 "old": {
205                     attr: vals
206                     for attr, vals in old[dn]<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.items()
207                     if vals != new.get(dn, {}).get(attr, ())
208                 }
209                 if dn in old
210                 else None,
211                 "new": {
212                     attr: vals
213                     for attr, vals in new[dn].items()
214                     if vals != old.get(dn, {}).get(attr, ())
215                 }
216                 if dn in new
217                 else None,
218             }
219             for dn in replace
220             if old.</b></font>get(dn, {}) != new.get(dn, {})
221         },
222     )
223     entries = [
224         {dn: [{"replace": attrs}, {"delete_others": delete_others}]}
225         for dn, attrs in replace.items()
226     ]
227     actual = salt.states.ldap.managed(name, entries)
228     assert expected_ret == actual
229     assert expected_db == init_db.db
230 def _test_helper_success(db, replace, delete_others=False):
231     _test_helper(db, {}, replace, delete_others)
232 def _test_helper_nochange(db, replace, delete_others=False):
233     expected = {
234         "changes": {},
235         "comment": "LDAP entries already set",
236     }
237     _test_helper(db, expected, replace, delete_others)
238 def _test_helper_add(db, expected_ret, add_items, delete_others=False):
239     old = db.dump_db()
240     new = db.dump_db()
241     expected_db = copy.deepcopy(db.db)
242     for dn, attrs in add_items.items():
243         for attr, vals in attrs.items():
244             vals = [to_bytes(val) for val in vals]
245             vals.extend(old.get(dn, {}).get(attr, OrderedSet()))
246             vals.sort()
247             if vals:
248                 new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
249                 expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
250             elif dn in expected_db:
251                 new[dn].pop(attr, None)
252                 expected_db[dn].pop(attr, None)
253         if not expected_db.get(dn, {}):
254             new.pop(dn, None)
255             expected_db.pop(dn, None)
256     if delete_others:
257         dn_to_delete = OrderedSet()
258         for dn, attrs in expected_db.items():
259             if dn in add_items:
260                 to_delete = OrderedSet()
261                 for attr, vals in attrs.items():
262                     if attr not in add_items[dn]:
263                         to_delete.add(attr)
264                 for attr in to_delete:
265                     del attrs[attr]
266                     del new[dn][attr]
267                 if not attrs:
268                     dn_to_delete.add(dn)
269         for dn in dn_to_delete:
270             del new[dn]
271             del expected_db[dn]
272     name = "ldapi:///"
273     expected_ret["name"] = name
274     expected_ret.setdefault("result", True)
275     expected_ret.setdefault("comment", "Successfully updated LDAP entries")
276     expected_ret.setdefault(
277         "changes",
278         {
279             dn: {
280                     attr: vals
281                     for attr, vals in old[dn].items()
282                     if vals != new<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get(dn, {}).get(attr, ())
283                 }
284                 if dn in old
285                 else None,
286                 "new": {
287                     attr: vals
288                     for attr, vals in new[dn].items()
289                     if vals != old.get(dn, {}).get(attr, ())
290                 }
291                 if dn in new
292                 else None,
293             }
294             for dn in add_items
295             if old.get(dn, {}) != new.</b></font>get(dn, {})
296         },
297     )
298     entries = [
299         {dn: [{"add": attrs}, {"delete_others": delete_others}]}
300         for dn, attrs in add_items.items()
301     ]
302     actual = salt.states.ldap.managed(name, entries)
303     assert expected_ret == actual
304     assert expected_db == db.db
305 def _test_helper_success_add(db, add_items, delete_others=False):
306     _test_helper_add(db, {}, add_items, delete_others)
307 def test_managed_empty(db):
308     name = "ldapi:///"
309     expected = {
310         "name": name,
311         "changes": {},
312         "result": True,
313         "comment": "LDAP entries already set",
314     }
315     actual = salt.states.ldap.managed(name, {})
316     assert expected == actual
317 def test_managed_add_entry(db):
318     _test_helper_success_add(db, {"dummydn": {"foo": ["bar", "baz"]}})
319 def test_managed_add_attr(complex_db):
320     _test_helper_success_add(complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.3"]}})
321     _test_helper_success_add(complex_db, {"dnfoo": {"attrfoo4": ["valfoo4.1"]}})
322 def test_managed_replace_attr(complex_db):
323     _test_helper_success(complex_db, {"dnfoo": {"attrfoo3": ["valfoo3.1"]}})
324 def test_managed_simplereplace(complex_db):
325     _test_helper_success(complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.3"]}})
326 def test_managed_deleteattr(complex_db):
327     _test_helper_success(complex_db, {"dnfoo": {"attrfoo1": []}})
328 def test_managed_deletenonexistattr(no_change_complex_db):
329     _test_helper_nochange(no_change_complex_db, {"dnfoo": {"dummyattr": []}})
330 def test_managed_deleteentry(complex_db):
331     _test_helper_success(complex_db, {"dnfoo": {}}, True)
332 def test_managed_deletenonexistentry(no_change_complex_db):
333     _test_helper_nochange(no_change_complex_db, {"dummydn": {}}, True)
334 def test_managed_deletenonexistattrinnonexistentry(no_change_complex_db):
335     _test_helper_nochange(no_change_complex_db, {"dummydn": {"dummyattr": []}})
336 def test_managed_add_attr_delete_others(complex_db):
337     _test_helper_success(complex_db, {"dnfoo": {"dummyattr": ["dummyval"]}}, True)
338 def test_managed_no_net_change(no_change_complex_db):
339     _test_helper_nochange(
340         no_change_complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.1", "valfoo1.2"]}}
341     )
342 def test_managed_repeated_values(db):
343     _test_helper_success(db, {"dummydn": {"dummyattr": ["dummyval", "dummyval"]}})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zypperpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import io
3 import os
4 from xml.dom import minidom
5 import salt.modules.pkg_resource as pkg_resource
6 import salt.modules.zypperpkg as zypper
7 import salt.utils.files
8 import salt.utils.pkg
9 from salt.exceptions import CommandExecutionError
10 from tests.support.mixins import LoaderModuleMockMixin
11 from tests.support.mock import MagicMock, Mock, call, patch
12 from tests.support.unit import TestCase
13 class ZyppCallMock:
14     def __init__(self, return_value=None):
15         self.__return_value = return_value
16     def __getattr__(self, item):
17         return self
18     def __call__(self, *args, **kwargs):
19         if any(i in kwargs for i in ("no_repo_failure", "systemd_scope", "root")):
20             return self
21         return MagicMock(return_value=self.__return_value)()
22 def get_test_data(filename):
23     with salt.utils.files.fopen(
24         os.path.join(
25             os.path.join(os.path.dirname(os.path.abspath(__file__)), "zypp"), filename
26         )
27     ) as rfh:
28         return rfh.read()
29 class ZypperTestCase(TestCase, LoaderModuleMockMixin):
30     def setup_loader_modules(self):
31         return {zypper: {"rpm": None}, pkg_resource: {}}
32     def setUp(self):
33         self.new_repo_config = dict(
34             name="mock-repo-name", url="http://repo.url/some/path"
35         )
36         side_effect = [
37             Mock(**{"sections.return_value": []}),
38             Mock(**{"sections.return_value": [self.new_repo_config["name"]]}),
39         ]
40         self.zypper_patcher_config = {
41             "_get_configured_repos": Mock(side_effect=side_effect),
42             "__zypper__": Mock(),
43             "_get_repo_info": Mock(
44                 return_value={
45                     "keeppackages": False,
46                     "autorefresh": True,
47                     "enabled": False,
48                     "baseurl": self.new_repo_config["url"],
49                     "alias": self.new_repo_config["name"],
50                     "priority": 1,
51                     "type": "rpm-md",
52                 }
53             ),
54             "del_repo": Mock(),
55             "mod_repo": Mock(wraps=zypper.mod_repo),
56         }
57     def tearDown(self):
58         del self.new_repo_config
59         del self.zypper_patcher_config
60     def test_list_upgrades(self):
61         ref_out = {
62             "stdout": get_test_data("zypper-updates.xml"),
63             "stderr": None,
64             "retcode": 0,
65         }
66         with patch.dict(
67             zypper.__salt__, {"cmd.run_all": MagicMock(return_value=ref_out)}
68         ):
69             upgrades = zypper.list_upgrades(refresh=False)
70             self.assertEqual(len(upgrades), 3)
71             for pkg, version in {
72                 "SUSEConnect": "0.2.33-7.1",
73                 "bind-utils": "9.9.6P1-35.1",
74                 "bind-libs": "9.9.6P1-35.1",
75             }.items():
76                 self.assertIn(pkg, upgrades)
77                 self.assertEqual(upgrades[pkg], version)
78     @patch(
79         "salt.utils.environment.get_module_environment",
80         MagicMock(return_value={"SALT_RUNNING": "1"}),
81     )
82     def test_zypper_caller(self):
83         class RunSniffer:
84             def __init__(self, stdout=None, stderr=None, retcode=None):
85                 self.calls = list()
86                 self._stdout = stdout or ""
87                 self._stderr = stderr or ""
88                 self._retcode = retcode or 0
89             def __call__(self, *args, **kwargs):
90                 self.calls.append({"args": args, "kwargs": kwargs})
91                 return {
92                     "stdout": self._stdout,
93                     "stderr": self._stderr,
94                     "retcode": self._retcode,
95                 }
96         stdout_xml_snippet = '&lt;?xml version="1.0"?&gt;&lt;test foo="bar"/&gt;'
97         sniffer = RunSniffer(stdout=stdout_xml_snippet)
98         with patch.dict("salt.modules.zypperpkg.__salt__", {"cmd.run_all": sniffer}):
99             self.assertEqual(zypper.__zypper__.call("foo"), stdout_xml_snippet)
100             self.assertEqual(len(sniffer.calls), 1)
101             zypper.__zypper__.call("--no-refresh", "bar")
102             self.assertEqual(len(sniffer.calls), 2)
103             self.assertEqual(
104                 sniffer.calls[0]["args"][0],
105                 ["zypper", "--non-interactive", "--no-refresh", "foo"],
106             )
107             self.assertEqual(
108                 sniffer.calls[1]["args"][0],
109                 ["zypper", "--non-interactive", "--no-refresh", "bar"],
110             )
111             dom = zypper.__zypper__.xml.call("xml-test")
112             self.assertEqual(
113                 sniffer.calls[2]["args"][0],
114                 ["zypper", "--non-interactive", "--xmlout", "--no-refresh", "xml-test"],
115             )
116             self.assertEqual(
117                 dom.getElementsByTagName("test")[0].getAttribute("foo"), "bar"
118             )
119             zypper.__zypper__.refreshable.call("refresh-test")
120             self.assertEqual(
121                 sniffer.calls[3]["args"][0],
122                 ["zypper", "--non-interactive", "refresh-test"],
123             )
124             zypper.__zypper__.nolock.call("no-locking-test")
125                 sniffer.calls[4]
126                 .get("kwargs", {})
127                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("env", {})
128                 .get("ZYPP_READONLY_HACK"),
129                 "1",
130             )
131             self.assertEqual(
132                 sniffer.calls[4].get("kwargs", {}).get("env", {}).get("SALT_RUNNING"),
133             )
134             zypper.</b></font>__zypper__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call("locking-test")
135             self.assertEqual(
136                 sniffer.calls[5]
137                 .get("kwargs", {})
138                 .get("env", {})
139                 .get("ZYPP_READONLY_HACK"),
140                 None,
141             )
142             self.assertEqual(
143                 sniffer.</b></font>calls[5].get("kwargs", {}).get("env", {}).get("SALT_RUNNING"),
144                 "1",
145             )
146         stdout_xml_snippet = (
147             '&lt;?xml version="1.0"?&gt;&lt;stream&gt;&lt;message'
148             ' type="error"&gt;Booya!&lt;/message&gt;&lt;/stream&gt;'
149         )
150         sniffer = RunSniffer(stdout=stdout_xml_snippet, retcode=1)
151         with patch.dict("salt.modules.zypperpkg.__salt__", {"cmd.run_all": sniffer}):
152             with self.assertRaisesRegex(
153                 CommandExecutionError, "^Zypper command failure: Booya!$"
154             ):
155                 zypper.__zypper__.xml.call("crashme")
156             with self.assertRaisesRegex(
157                 CommandExecutionError, "^Zypper command failure: Check Zypper's logs.$"
158             ):
159                 zypper.__zypper__.call("crashme again")
160             zypper.__zypper__.noraise.call("stay quiet")
161             self.assertEqual(zypper.__zypper__.error_msg, "Check Zypper's logs.")
162     def test_list_upgrades_error_handling(self):
163         ref_out = {
164             "stdout": """&lt;?xml version='1.0'?&gt;
165 &lt;stream&gt;
166  &lt;message type="info"&gt;Refreshing service &amp;apos;container-suseconnect&amp;apos;.&lt;/message&gt;
167  &lt;message type="error"&gt;Some handled zypper internal error&lt;/message&gt;
168  &lt;message type="error"&gt;Another zypper internal error&lt;/message&gt;
169 &lt;/stream&gt;
170             """,
171             "stderr": "",
172             "retcode": 1,
173         }
174         with patch.dict(
175             "salt.modules.zypperpkg.__salt__",
176             {"cmd.run_all": MagicMock(return_value=ref_out)},
177         ):
178             with self.assertRaisesRegex(
179                 CommandExecutionError,
180                 "^Zypper command failure: Some handled zypper internal error{}Another"
181                 " zypper internal error$".format(os.linesep),
182             ):
183                 zypper.list_upgrades(refresh=False)
184         ref_out = {"retcode": 1, "stdout": "", "stderr": ""}
185         with patch.dict(
186             "salt.modules.zypperpkg.__salt__",
187             {"cmd.run_all": MagicMock(return_value=ref_out)},
188         ):
189             with self.assertRaisesRegex(
190                 CommandExecutionError, "^Zypper command failure: Check Zypper's logs.$"
191             ):
192                 zypper.list_upgrades(refresh=False)
193     def test_list_products(self):
194         for filename, test_data in {
195             "zypper-products-sle12sp1.xml": {
196                 "name": [
197                     "SLES",
198                     "SLES",
199                     "SUSE-Manager-Proxy",
200                     "SUSE-Manager-Server",
201                     "sle-manager-tools-beta",
202                     "sle-manager-tools-beta-broken-eol",
203                     "sle-manager-tools-beta-no-eol",
204                 ],
205                 "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
206                 "release": ["0", "0", "0", "0", "0", "0", "0"],
207                 "productline": [None, None, None, None, None, None, "sles"],
208                 "eol_t": [
209                     None,
210                     0,
211                     1509408000,
212                     1522454400,
213                     1522454400,
214                     1730332800,
215                     1730332800,
216                 ],
217                 "isbase": [False, False, False, False, False, False, True],
218                 "installed": [False, False, False, False, False, False, True],
219                 "registerrelease": [None, None, None, None, None, None, "123"],
220             },
221             "zypper-products-sle11sp3.xml": {
222                 "name": [
223                     "SUSE-Manager-Server",
224                     "SUSE-Manager-Server",
225                     "SUSE-Manager-Server-Broken-EOL",
226                     "SUSE_SLES",
227                     "SUSE_SLES",
228                     "SUSE_SLES",
229                     "SUSE_SLES-SP4-migration",
230                 ],
231                 "vendor": "SUSE LINUX Products GmbH, Nuernberg, Germany",
232                 "release": ["1.138", "1.2", "1.2", "1.2", "1.201", "1.201", "1.4"],
233                 "productline": [None, None, None, None, None, "manager", "manager"],
234                 "eol_t": [None, 0, 0, 0, 0, 0, 0],
235                 "isbase": [False, False, False, False, False, True, True],
236                 "installed": [False, False, False, False, False, True, True],
237                 "registerrelease": [None, None, None, None, None, None, "42"],
238             },
239         }.items():
240             ref_out = {"retcode": 0, "stdout": get_test_data(filename)}
241             cmd_run_all = MagicMock(return_value=ref_out)
242             mock_call = call(
243                 [
244                     "zypper",
245                     "--non-interactive",
246                     "--xmlout",
247                     "--no-refresh",
248                     "--disable-repositories",
249                     "products",
250                     "-i",
251                 ],
252                 env={"ZYPP_READONLY_HACK": "1"},
253                 output_loglevel="trace",
254                 python_shell=False,
255             )
256             with patch.dict(zypper.__salt__, {"cmd.run_all": cmd_run_all}):
257                 products = zypper.list_products()
258                 self.assertEqual(len(products), 7)
259                 self.assertIn(
260                     test_data["vendor"], [product["vendor"] for product in products]
261                 )
262                 for kwd in [
263                     "name",
264                     "isbase",
265                     "installed",
266                     "release",
267                     "productline",
268                     "eol_t",
269                     "registerrelease",
270                 ]:
271                     self.assertCountEqual(
272                         test_data[kwd], [prod.get(kwd) for prod in products]
273                     )
274                 cmd_run_all.assert_has_calls([mock_call])
275     def test_refresh_db(self):
276         ref_out = [
277             "Repository 'openSUSE-Leap-42.1-LATEST' is up to date.",
278             "Repository 'openSUSE-Leap-42.1-Update' is up to date.",
279             "Retrieving repository 'openSUSE-Leap-42.1-Update-Non-Oss' metadata",
280             "Forcing building of repository cache",
281             "Building repository 'openSUSE-Leap-42.1-Update-Non-Oss' cache"
282             " ..........[done]",
283             "Building repository 'salt-dev' cache",
284             "All repositories have been refreshed.",
285         ]
286         run_out = {"stderr": "", "stdout": "\n".join(ref_out), "retcode": 0}
287         zypper_mock = MagicMock(return_value=run_out)
288         call_kwargs = {"output_loglevel": "trace", "python_shell": False, "env": {}}
289         with patch.dict(zypper.__salt__, {"cmd.run_all": zypper_mock}):
290             with patch.object(salt.utils.pkg, "clear_rtag", Mock()):
291                 result = zypper.refresh_db()
292                 self.assertEqual(result.get("openSUSE-Leap-42.1-LATEST"), False)
293                 self.assertEqual(result.get("openSUSE-Leap-42.1-Update"), False)
294                 self.assertEqual(result.get("openSUSE-Leap-42.1-Update-Non-Oss"), True)
295                 zypper_mock.assert_called_with(
296                     ["zypper", "--non-interactive", "refresh", "--force"], **call_kwargs
297                 )
298                 zypper.refresh_db(force=False)
299                 zypper_mock.assert_called_with(
300                     ["zypper", "--non-interactive", "refresh"], **call_kwargs
301                 )
302                 zypper.refresh_db(force=True)
303                 zypper_mock.assert_called_with(
304                     ["zypper", "--non-interactive", "refresh", "--force"], **call_kwargs
305                 )
306     def test_info_installed(self):
307         run_out = {
308             "virgo-dummy": {
309                 "build_date": "2015-07-09T10:55:19Z",
310                 "vendor": "openSUSE Build Service",
311                 "description": (
312                     "This is the Virgo dummy package used for testing SUSE Manager"
313                 ),
314                 "license": "GPL-2.0",
315                 "build_host": "sheep05",
316                 "url": "http://www.suse.com",
317                 "build_date_time_t": 1436432119,
318                 "relocations": "(not relocatable)",
319                 "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
320                 "install_date": "2016-02-23T16:31:57Z",
321                 "install_date_time_t": 1456241517,
322                 "summary": "Virgo dummy package",
323                 "version": "1.0",
324                 "signature": (
325                     "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
326                 ),
327                 "release": "1.1",
328                 "group": "Applications/System",
329                 "arch": "noarch",
330                 "size": "17992",
331             },
332             "libopenssl1_0_0": {
333                 "build_date": "2015-11-04T23:20:34Z",
334                 "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
335                 "description": "The OpenSSL Project is a collaborative effort.",
336                 "license": "OpenSSL",
337                 "build_host": "sheep11",
338                 "url": "https://www.openssl.org/",
339                 "build_date_time_t": 1446675634,
340                 "relocations": "(not relocatable)",
341                 "source_rpm": "openssl-1.0.1i-34.1.src.rpm",
342                 "install_date": "2016-02-23T16:31:35Z",
343                 "install_date_time_t": 1456241495,
344                 "summary": "Secure Sockets and Transport Layer Security",
345                 "version": "1.0.1i",
346                 "signature": (
347                     "RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82"
348                 ),
349                 "release": "34.1",
350                 "group": "Productivity/Networking/Security",
351                 "packager": "https://www.suse.com/",
352                 "arch": "x86_64",
353                 "size": "2576912",
354             },
355         }
356         with patch.dict(
357             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
358         ):
359             installed = zypper.info_installed()
360             self.assertEqual(len(installed), 2)
361             for pkg_name, pkg_info in installed.items():
362                 self.assertEqual(
363                     installed[pkg_name].get("source"), run_out[pkg_name]["source_rpm"]
364                 )
365             for pn_key, pn_val in run_out["virgo-dummy"].items():
366                 if pn_key == "source_rpm":
367                     continue
368                 self.assertEqual(installed["virgo-dummy"][pn_key], pn_val)
369     def test_info_installed_with_non_ascii_char(self):
370         run_out = {"vīrgô": {"description": "vīrgô d€šçripţiǫñ"}}
371         with patch.dict(
372             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
373         ):
374             installed = zypper.info_installed()
375             self.assertEqual(installed["vīrgô"]["description"], "vīrgô d€šçripţiǫñ")
376     def test_info_installed_with_all_versions(self):
377         run_out = {
378             "virgo-dummy": [
379                 {
380                     "build_date": "2015-07-09T10:55:19Z",
381                     "vendor": "openSUSE Build Service",
382                     "description": (
383                         "This is the Virgo dummy package used for testing SUSE Manager"
384                     ),
385                     "license": "GPL-2.0",
386                     "build_host": "sheep05",
387                     "url": "http://www.suse.com",
388                     "build_date_time_t": 1436432119,
389                     "relocations": "(not relocatable)",
390                     "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
391                     "install_date": "2016-02-23T16:31:57Z",
392                     "install_date_time_t": 1456241517,
393                     "summary": "Virgo dummy package",
394                     "version": "1.0",
395                     "signature": (
396                         "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
397                     ),
398                     "release": "1.1",
399                     "group": "Applications/System",
400                     "arch": "i686",
401                     "size": "17992",
402                 },
403                 {
404                     "build_date": "2015-07-09T10:15:19Z",
405                     "vendor": "openSUSE Build Service",
406                     "description": (
407                         "This is the Virgo dummy package used for testing SUSE Manager"
408                     ),
409                     "license": "GPL-2.0",
410                     "build_host": "sheep05",
411                     "url": "http://www.suse.com",
412                     "build_date_time_t": 1436432119,
413                     "relocations": "(not relocatable)",
414                     "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
415                     "install_date": "2016-02-23T16:31:57Z",
416                     "install_date_time_t": 14562415127,
417                     "summary": "Virgo dummy package",
418                     "version": "1.0",
419                     "signature": (
420                         "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
421                     ),
422                     "release": "1.1",
423                     "group": "Applications/System",
424                     "arch": "x86_64",
425                     "size": "13124",
426                 },
427             ],
428             "libopenssl1_0_0": [
429                 {
430                     "build_date": "2015-11-04T23:20:34Z",
431                     "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
432                     "description": "The OpenSSL Project is a collaborative effort.",
433                     "license": "OpenSSL",
434                     "build_host": "sheep11",
435                     "url": "https://www.openssl.org/",
436                     "build_date_time_t": 1446675634,
437                     "relocations": "(not relocatable)",
438                     "source_rpm": "openssl-1.0.1i-34.1.src.rpm",
439                     "install_date": "2016-02-23T16:31:35Z",
440                     "install_date_time_t": 1456241495,
441                     "summary": "Secure Sockets and Transport Layer Security",
442                     "version": "1.0.1i",
443                     "signature": (
444                         "RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82"
445                     ),
446                     "release": "34.1",
447                     "group": "Productivity/Networking/Security",
448                     "packager": "https://www.suse.com/",
449                     "arch": "x86_64",
450                     "size": "2576912",
451                 }
452             ],
453         }
454         with patch.dict(
455             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
456         ):
457             installed = zypper.info_installed(all_versions=True)
458             self.assertEqual(len(installed), 2)
459             for pkg_name, pkg_info_list in installed.items():
460                 self.assertEqual(
461                     len(pkg_info_list), 2 if pkg_name == "virgo-dummy" else 1
462                 )
463                 for info in pkg_info_list:
464                     self.assertTrue(info["arch"] in ("x86_64", "i686"))
465     def test_info_available(self):
466         test_pkgs = ["vim", "emacs", "python"]
467         with patch(
468             "salt.modules.zypperpkg.__zypper__",
469             ZyppCallMock(return_value=get_test_data("zypper-available.txt")),
470         ):
471             available = zypper.info_available(*test_pkgs, refresh=False)
472             self.assertEqual(len(available), 3)
473             for pkg_name, pkg_info in available.items():
474                 self.assertIn(pkg_name, test_pkgs)
475             self.assertEqual(available["emacs"]["status"], "up-to-date")
476             self.assertTrue(available["emacs"]["installed"])
477             self.assertEqual(available["emacs"]["support level"], "Level 3")
478             self.assertEqual(
479                 available["emacs"]["vendor"], "SUSE LLC &lt;https://www.suse.com/&gt;"
480             )
481             self.assertEqual(available["emacs"]["summary"], "GNU Emacs Base Package")
482             self.assertEqual(available["vim"]["status"], "not installed")
483             self.assertFalse(available["vim"]["installed"])
484             self.assertEqual(available["vim"]["support level"], "Level 3")
485             self.assertEqual(
486                 available["vim"]["vendor"], "SUSE LLC &lt;https://www.suse.com/&gt;"
487             )
488             self.assertEqual(available["vim"]["summary"], "Vi IMproved")
489     def test_latest_version(self):
490         with patch(
491             "salt.modules.zypperpkg.__zypper__",
492             ZyppCallMock(return_value=get_test_data("zypper-available.txt")),
493         ), patch("salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)):
494             self.assertEqual(zypper.latest_version("vim"), "7.4.326-2.62")
495             self.assertDictEqual(
496                 zypper.latest_version("vim", "fakepkg"),
497                 {"vim": "7.4.326-2.62", "fakepkg": ""},
498             )
499     def test_upgrade_success(self):
500         with patch.dict(zypper.__grains__, {"osrelease_info": [12, 1]}), patch(
501             "salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)
502         ), patch(
503             "salt.modules.zypperpkg._systemd_scope", MagicMock(return_value=False)
504         ):
505             with patch(
506                 "salt.modules.zypperpkg.__zypper__.noraise.call", MagicMock()
507             ) as zypper_mock:
508                 with patch(
509                     "salt.modules.zypperpkg.list_pkgs",
510                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
511                 ):
512                     ret = zypper.upgrade()
513                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
514                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
515                 with patch(
516                     "salt.modules.zypperpkg.list_pkgs",
517                     MagicMock(
518                         side_effect=[
519                             {"kernel-default": "1.1"},
520                             {"kernel-default": "1.1,1.2"},
521                         ]
522                     ),
523                 ):
524                     ret = zypper.upgrade()
525                     self.assertDictEqual(
526                         ret, {"kernel-default": {"old": "1.1", "new": "1.1,1.2"}}
527                     )
528                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
529                 with patch(
530                     "salt.modules.zypperpkg.list_pkgs",
531                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1,1.2"}]),
532                 ):
533                     ret = zypper.upgrade()
534                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.1,1.2"}})
535                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
536                 with patch(
537                     "salt.modules.zypperpkg.list_pkgs",
538                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
539                 ):
540                     ret = zypper.upgrade(dist_upgrade=True)
541                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
542                     zypper_mock.assert_any_call(
543                         "dist-upgrade", "--auto-agree-with-licenses"
544                     )
545                 with patch(
546                     "salt.modules.zypperpkg.list_pkgs",
547                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
548                 ):
549                     ret = zypper.upgrade(dist_upgrade=True, dryrun=True)
550                     zypper_mock.assert_any_call(
551                         "dist-upgrade", "--auto-agree-with-licenses", "--dry-run"
552                     )
553                     zypper_mock.assert_any_call(
554                         "dist-upgrade",
555                         "--auto-agree-with-licenses",
556                         "--dry-run",
557                         "--debug-solver",
558                     )
559                 with patch(
560                     "salt.modules.zypperpkg.list_pkgs",
561                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
562                 ):
563                     ret = zypper.upgrade(
564                         dist_upgrade=True,
565                         dryrun=True,
566                         fromrepo=["Dummy", "Dummy2"],
567                         novendorchange=True,
568                     )
569                     zypper_mock.assert_any_call(
570                         "dist-upgrade",
571                         "--auto-agree-with-licenses",
572                         "--dry-run",
573                         "--from",
574                         "Dummy",
575                         "--from",
576                         "Dummy2",
577                         "--no-allow-vendor-change",
578                     )
579                     zypper_mock.assert_any_call(
580                         "dist-upgrade",
581                         "--auto-agree-with-licenses",
582                         "--dry-run",
583                         "--from",
584                         "Dummy",
585                         "--from",
586                         "Dummy2",
587                         "--no-allow-vendor-change",
588                         "--debug-solver",
589                     )
590                 with patch(
591                     "salt.modules.zypperpkg.list_pkgs",
592                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
593                 ):
594                     ret = zypper.upgrade(
595                         dist_upgrade=False, fromrepo=["Dummy", "Dummy2"], dryrun=False
596                     )
597                     zypper_mock.assert_any_call(
598                         "update",
599                         "--auto-agree-with-licenses",
600                         "--repo",
601                         "Dummy",
602                         "--repo",
603                         "Dummy2",
604                     )
605                 with patch(
606                     "salt.modules.zypperpkg.list_pkgs",
607                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
608                 ):
609                     ret = zypper.upgrade(
610                         dist_upgrade=True,
611                         fromrepo=["Dummy", "Dummy2"],
612                         novendorchange=True,
613                     )
614                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
615                     zypper_mock.assert_any_call(
616                         "dist-upgrade",
617                         "--auto-agree-with-licenses",
618                         "--from",
619                         "Dummy",
620                         "--from",
621                         "Dummy2",
622                         "--no-allow-vendor-change",
623                     )
624     def test_upgrade_kernel(self):
625         with patch.dict(zypper.__grains__, {"osrelease_info": [12, 1]}), patch(
626             "salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)
627         ), patch(
628             "salt.modules.zypperpkg._systemd_scope", MagicMock(return_value=False)
629         ):
630             with patch.dict(
631                 zypper.__salt__,
632                 {
633                     "pkg_resource.parse_targets": MagicMock(
634                         return_value=(["kernel-default"], None)
635                     )
636                 },
637             ):
638                 with patch(
639                     "salt.modules.zypperpkg.__zypper__.noraise.call", MagicMock()
640                 ):
641                     with patch(
642                         "salt.modules.zypperpkg.list_pkgs",
643                         MagicMock(
644                             side_effect=[
645                                 {"kernel-default": "3.12.49-11.1"},
646                                 {"kernel-default": "3.12.49-11.1,3.12.51-60.20.2"},
647                             ]
648                         ),
649                     ):
650                         ret = zypper.install(
651                             "kernel-default", "--auto-agree-with-licenses"
652                         )
653                         self.assertDictEqual(
654                             ret,
655                             {
656                                 "kernel-default": {
657                                     "old": "3.12.49-11.1",
658                                     "new": "3.12.49-11.1,3.12.51-60.20.2",
659                                 }
660                             },
661                         )
662     def test_upgrade_failure(self):
663         zypper_out = """
664 Loading repository data...
665 Reading installed packages...
666 Computing distribution upgrade...
667 Use 'zypper repos' to get the list of defined repositories.
668 Repository 'DUMMY' not found by its alias, number, or URI.
669         Test whether or not an upgrade is available for a given package.
670         :return:
671         Test packages listing.
672         :return:
673         Test packages listing.
674         :return:
675         Test packages listing with the attr parameter
676         :return:
677         Test packages listing with the attr parameter reporting multiple version installed
678         :return:
679         Test advisory patches listing.
680         :return:
681         Test downloaded packages listing.
682         :return:
683         Test downloaded packages listing.
684         :return:
685         Test package download
686         :return:
687         Test a package installation with downloadonly=True.
688         :return:
689         Test a package installation with downloadonly=True when package is already downloaded.
690         :return:
691         Test successfully advisory patch installation.
692         :return:
693         Test failing advisory patch installation because patch does not exist.
694         :return:
695         Test successfully product installation.
696         Test package removal
697         :return:
698         Tests if repo info is properly parsed.
699         :return:
700         Test mod_repo adds the new repo and nothing else
701         :return:
702         Test mod_repo detects the repo already exists,
703         no modification was requested and no refresh requested either
704         :return:
705         Test mod_repo detects the repo already exists,
706         no modification was requested and no refresh requested either
707         :return:
708         Test mod_repo adds the new repo and call modify to update autorefresh
709         :return:
710         Test mod_repo detects the repository exists,
711         calls modify to update 'autorefresh' but does not call refresh
712         :return:
713         Test mod_repo adds the new repo and refreshes the repo with
714             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
715         :return:
716         Test mod_repo detects the repo already exists,
717         has nothing to modify and refreshes the repo with
718             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
719         :return:
720         Test mod_repo adds the new repo,
721         calls modify to update 'autorefresh' and refreshes the repo with
722             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
723         :return:
724         Test mod_repo detects the repo already exists,
725         calls modify to update 'autorefresh' and refreshes the repo with
726             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
727         :return:
728         Test wildcard to query match all pattern
729         :return:
730         _zpr = MagicMock()
731         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
732         wcard = zypper.Wildcard(_zpr)
733         wcard.name, wcard.version = "libzypp", "*"
734         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
735             "16.2.4-19.5",
736             "16.3.2-25.1",
737             "16.5.2-27.9.1",
738         ]
739     def test_wildcard_to_query_multiple_asterisk(self):
740         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
741         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
742         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
743         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
744         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
745         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
746         """
747         _zpr = MagicMock()
748         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
749         wcard = zypper.Wildcard(_zpr)
750         wcard.name, wcard.version = "libzypp", "16.2.*-2*"
751         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
752             "16.2.5-25.1",
753             "16.2.6-27.9.1",
754         ]
755     def test_wildcard_to_query_exact_match_at_end(self):
756         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
757         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
758         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
759         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
760         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
761         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
762         """
763         _zpr = MagicMock()
764         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
765         wcard = zypper.Wildcard(_zpr)
766         wcard.name, wcard.version = "libzypp", "16.2.5*"
767         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
768             "16.2.5-25.1"
769         ]
770     def test_wildcard_to_query_exact_match_at_beginning(self):
771         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
772         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
773         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
774         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
775         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
776         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
777         """
778         _zpr = MagicMock()
779         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
780         wcard = zypper.Wildcard(_zpr)
781         wcard.name, wcard.version = "libzypp", "*.1"
782         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
783             "16.2.5-25.1",
784             "17.2.6-27.9.1",
785         ]
786     def test_wildcard_to_query_usage(self):
787         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
788         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
789         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
790         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
791         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
792         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
793         """
794         _zpr = MagicMock()
795         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
796         assert zypper.Wildcard(_zpr)("libzypp", "16.2.4*") == "16.2.4-19.5"
797         assert zypper.Wildcard(_zpr)("libzypp", "16.2*") == "16.2.5-25.1"
798         assert zypper.Wildcard(_zpr)("libzypp", "*6-*") == "17.2.6-27.9.1"
799         assert zypper.Wildcard(_zpr)("libzypp", "*.1") == "17.2.6-27.9.1"
800     def test_wildcard_to_query_noversion(self):
801         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
802         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
803         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
804         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
805         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
806         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
807         """
808         _zpr = MagicMock()
809         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
810         assert zypper.Wildcard(_zpr)("libzypp", None) is None
811     def test_wildcard_to_query_typecheck(self):
812         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
813         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
814         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
815         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
816         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
817         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
818         """
819         _zpr = MagicMock()
820         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
821         assert isinstance(zypper.Wildcard(_zpr)("libzypp", "*.1"), str)
822     def test_wildcard_to_query_condition_preservation(self):
823         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
824         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
825         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
826         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
827         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
828         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
829         """
830         _zpr = MagicMock()
831         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
832         for op in zypper.Wildcard.Z_OP:
833             assert zypper.Wildcard(_zpr)(
834                 "libzypp", "{}*.1".format(op)
835             ) == "{}17.2.6-27.9.1".format(op)
836         for op in zypper.Wildcard.Z_OP:
837             assert zypper.Wildcard(_zpr)(
838                 "libzypp", "16*{}".format(op)
839             ) == "{}16.2.5-25.1".format(op)
840     def test_wildcard_to_query_unsupported_operators(self):
841         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
842         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
843         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
844         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
845         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
846         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
847         """
848         _zpr = MagicMock()
849         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
850         with self.assertRaises(CommandExecutionError):
851             for op in ["&gt;&gt;", "==", "&lt;&lt;", "+"]:
852                 zypper.Wildcard(_zpr)("libzypp", "{}*.1".format(op))
853     @patch("salt.modules.zypperpkg._get_visible_patterns")
854     def test__get_installed_patterns(self, get_visible_patterns):
855         get_visible_patterns.return_value = {
856             "package-a": {"installed": True, "summary": "description a"},
857             "package-b": {"installed": False, "summary": "description b"},
858         }
859         salt_mock = {
860             "cmd.run": MagicMock(
861                 return_value="""pattern() = package-a
862 pattern-visible()
863 pattern() = package-c"""
864             ),
865         }
866         with patch.dict("salt.modules.zypperpkg.__salt__", salt_mock):
867             assert zypper._get_installed_patterns() == {
868                 "package-a": {"installed": True, "summary": "description a"},
869                 "package-c": {"installed": True, "summary": "Non-visible pattern"},
870             }
871     @patch("salt.modules.zypperpkg._get_visible_patterns")
872     def test__get_installed_patterns_with_alias(self, get_visible_patterns):
873         get_visible_patterns.return_value = {
874             "package-a": {"installed": True, "summary": "description a"},
875             "package-b": {"installed": False, "summary": "description b"},
876         }
877         salt_mock = {
878             "cmd.run": MagicMock(
879                 return_value="""pattern() = .package-a-alias
880 pattern() = package-a
881 pattern-visible()
882 pattern() = package-c"""
883             ),
884         }
885         with patch.dict("salt.modules.zypperpkg.__salt__", salt_mock):
886             assert zypper._get_installed_patterns() == {
887                 "package-a": {"installed": True, "summary": "description a"},
888                 "package-c": {"installed": True, "summary": "Non-visible pattern"},
889             }
890     @patch("salt.modules.zypperpkg._get_visible_patterns")
891     def test_list_patterns(self, get_visible_patterns):
892         get_visible_patterns.return_value = {
893             "package-a": {"installed": True, "summary": "description a"},
894             "package-b": {"installed": False, "summary": "description b"},
895         }
896         assert zypper.list_patterns() == {
897             "package-a": {"installed": True, "summary": "description a"},
898             "package-b": {"installed": False, "summary": "description b"},
899         }
900     def test__clean_cache_empty(self):
901         context = {}
902         with patch.dict(zypper.__context__, context):
903             zypper._clean_cache()
904             assert context == {}
905     def test__clean_cache_filled(self):
906         context = {
907             "pkg.list_pkgs_/mnt_[]": None,
908             "pkg.list_pkgs_/mnt_[patterns]": None,
909             "pkg.list_provides": None,
910             "pkg.other_data": None,
911         }
912         with patch.dict(zypper.__context__, context):
913             zypper._clean_cache()
914             self.assertEqual(zypper.__context__, {"pkg.other_data": None})
915     def test_services_need_restart(self):
916         expected = ["salt-minion", "firewalld"]
917         zypper_output = "salt-minion\nfirewalld"
918         zypper_mock = Mock()
919         zypper_mock(root=None).nolock.call = Mock(return_value=zypper_output)
920         with patch("salt.modules.zypperpkg.__zypper__", zypper_mock):
921             assert zypper.services_need_restart() == expected
922             zypper_mock(root=None).nolock.call.assert_called_with("ps", "-sss")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
