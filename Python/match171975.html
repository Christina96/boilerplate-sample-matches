<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ldap.py &amp; test_zypperpkg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ldap.py &amp; test_zypperpkg_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ldap.py (4.784689%)<th>test_zypperpkg_1.py (1.2760527%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(328-341)<td><a href="#" name="0">(178-187)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(243-257)<td><a href="#" name="1">(169-178)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ldap.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import attr
4 import pytest
5 import salt.states.ldap
6 from salt.utils.oset import OrderedSet
7 from salt.utils.stringutils import to_bytes
8 log = logging.getLogger(__name__)
9 @attr.s
10 class LdapDB:
11     db = attr.ib(init=False, default=attr.Factory(dict))
12     def dummy_connect(self, connect_spec):
13         return _dummy_ctx()
14     def dummy_search(self, connect_spec, base, scope):
15         if base not in self.db:
16             return {}
17         return {
18             base: {
19                 attr: list(self.db[base][attr])
20                 for attr in self.db[base]
21                 if len(self.db[base][attr])
22             }
23         }
24     def dummy_add(self, connect_spec, dn, attributes):
25         assert dn not in self.db
26         assert attributes
27         self.db[dn] = {}
28         for attr, vals in attributes.items():
29             assert vals
30             self.db[dn][attr] = OrderedSet(vals)
31         return True
32     def dummy_delete(self, connect_spec, dn):
33         assert dn in self.db
34         del self.db[dn]
35         return True
36     def dummy_change(self, connect_spec, dn, before, after):
37         assert before != after
38         assert before
39         assert after
40         assert dn in self.db
41         e = self.db[dn]
42         assert e == before
43         all_attrs = OrderedSet()
44         all_attrs.update(before)
45         all_attrs.update(after)
46         directives = []
47         for attr in all_attrs:
48             if attr not in before:
49                 assert attr in after
50                 assert after[attr]
51                 directives.append(("add", attr, after[attr]))
52             elif attr not in after:
53                 assert attr in before
54                 assert before[attr]
55                 directives.append(("delete", attr, ()))
56             else:
57                 assert before[attr]
58                 assert after[attr]
59                 to_del = before[attr] - after[attr]
60                 if to_del:
61                     directives.append(("delete", attr, to_del))
62                 to_add = after[attr] - before[attr]
63                 if to_add:
64                     directives.append(("add", attr, to_add))
65         return self.dummy_modify(connect_spec, dn, directives)
66     def dummy_modify(self, connect_spec, dn, directives):
67         assert dn in self.db
68         e = self.db[dn]
69         for op, attr, vals in directives:
70             if op == "add":
71                 assert vals
72                 existing_vals = e.setdefault(attr, OrderedSet())
73                 for val in vals:
74                     assert val not in existing_vals
75                     existing_vals.add(val)
76             elif op == "delete":
77                 assert attr in e
78                 existing_vals = e[attr]
79                 assert existing_vals
80                 if not vals:
81                     del e[attr]
82                     continue
83                 for val in vals:
84                     assert val in existing_vals
85                     existing_vals.remove(val)
86                 if not existing_vals:
87                     del e[attr]
88             elif op == "replace":
89                 e.pop(attr, None)
90                 e[attr] = OrderedSet(vals)
91             else:
92                 raise ValueError()
93         return True
94     def dump_db(self, d=None):
95         if d is None:
96             d = self.db
97         return {dn: {attr: list(d[dn][attr]) for attr in d[dn]} for dn in d}
98 @pytest.fixture
99 def db():
100     return LdapDB()
101 @pytest.fixture
102 def complex_db(db):
103     db.db = {
104         "dnfoo": {
105             "attrfoo1": OrderedSet(
106                 (
107                     b"valfoo1.1",
108                     b"valfoo1.2",
109                 )
110             ),
111             "attrfoo2": OrderedSet((b"valfoo2.1",)),
112         },
113         "dnbar": {
114             "attrbar1": OrderedSet(
115                 (
116                     b"valbar1.1",
117                     b"valbar1.2",
118                 )
119             ),
120             "attrbar2": OrderedSet((b"valbar2.1",)),
121         },
122     }
123     return db
124 @pytest.fixture
125 def no_change_complex_db(db):
126     db.db = {
127         "dnfoo": {
128             "attrfoo1": OrderedSet(
129                 (
130                     b"valfoo1.1",
131                     b"valfoo1.2",
132                 )
133             ),
134             "attrfoo2": OrderedSet((b"valfoo2.1",)),
135         },
136         "dnbar": {
137             "attrbar1": OrderedSet(
138                 (
139                     b"valbar1.1",
140                     b"valbar1.2",
141                 )
142             ),
143             "attrbar2": OrderedSet((b"valbar2.1",)),
144         },
145     }
146     return db
147 class _dummy_ctx:
148     def __init__(self):
149         pass
150     def __enter__(self):
151         return self
152     def __exit__(self, *exc):
153         pass
154 @pytest.fixture
155 def configure_loader_modules(db):
156     salt_dunder = {
157         "ldap3.connect": db.dummy_connect,
158         "ldap3.search": db.dummy_search,
159         "ldap3.add": db.dummy_add,
160         "ldap3.delete": db.dummy_delete,
161         "ldap3.change": db.dummy_change,
162         "ldap3.modify": db.dummy_modify,
163     }
164     return {salt.states.ldap: {"__opts__": {"test": False}, "__salt__": salt_dunder}}
165 def _test_helper(init_db, expected_ret, replace, delete_others=False):
166     old = init_db.dump_db()
167     new = init_db.dump_db()
168     expected_db = copy.deepcopy(init_db.db)
169     for dn, attrs in replace.items():
170         for attr, vals in attrs.items():
171             vals = [to_bytes(val) for val in vals]
172             if vals:
173                 new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
174                 expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
175             elif dn in expected_db:
176                 new[dn].pop(attr, None)
177                 expected_db[dn].pop(attr, None)
178         if not expected_db.get(dn, {}):
179             new.pop(dn, None)
180             expected_db.pop(dn, None)
181     if delete_others:
182         dn_to_delete = OrderedSet()
183         for dn, attrs in expected_db.items():
184             if dn in replace:
185                 to_delete = OrderedSet()
186                 for attr, vals in attrs.items():
187                     if attr not in replace[dn]:
188                         to_delete.add(attr)
189                 for attr in to_delete:
190                     del attrs[attr]
191                     del new[dn][attr]
192                 if not attrs:
193                     dn_to_delete.add(dn)
194         for dn in dn_to_delete:
195             del new[dn]
196             del expected_db[dn]
197     name = "ldapi:///"
198     expected_ret["name"] = name
199     expected_ret.setdefault("result", True)
200     expected_ret.setdefault("comment", "Successfully updated LDAP entries")
201     expected_ret.setdefault(
202         "changes",
203         {
204 <a name="1"></a>            dn: {
205                 "old": {
206                     attr: vals
207                     for attr, vals in old[dn]<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.items()
208                     if vals != new.get(dn, {}).get(attr, ())
209                 }
210                 if dn in old
211                 else None,
212                 "new": {
213                     attr: vals
214                     for attr, vals in new[dn].items()
215                     if vals != old.get(dn, {}).get(attr, ())
216                 }
217                 if dn in new
218                 else None,
219             }
220             for dn in replace
221             if old.</b></font>get(dn, {}) != new.get(dn, {})
222         },
223     )
224     entries = [
225         {dn: [{"replace": attrs}, {"delete_others": delete_others}]}
226         for dn, attrs in replace.items()
227     ]
228     actual = salt.states.ldap.managed(name, entries)
229     assert expected_ret == actual
230     assert expected_db == init_db.db
231 def _test_helper_success(db, replace, delete_others=False):
232     _test_helper(db, {}, replace, delete_others)
233 def _test_helper_nochange(db, replace, delete_others=False):
234     expected = {
235         "changes": {},
236         "comment": "LDAP entries already set",
237     }
238     _test_helper(db, expected, replace, delete_others)
239 def _test_helper_add(db, expected_ret, add_items, delete_others=False):
240     old = db.dump_db()
241     new = db.dump_db()
242     expected_db = copy.deepcopy(db.db)
243     for dn, attrs in add_items.items():
244         for attr, vals in attrs.items():
245             vals = [to_bytes(val) for val in vals]
246             vals.extend(old.get(dn, {}).get(attr, OrderedSet()))
247             vals.sort()
248             if vals:
249                 new.setdefault(dn, {})[attr] = list(OrderedSet(vals))
250                 expected_db.setdefault(dn, {})[attr] = OrderedSet(vals)
251             elif dn in expected_db:
252                 new[dn].pop(attr, None)
253                 expected_db[dn].pop(attr, None)
254         if not expected_db.get(dn, {}):
255             new.pop(dn, None)
256             expected_db.pop(dn, None)
257     if delete_others:
258         dn_to_delete = OrderedSet()
259         for dn, attrs in expected_db.items():
260             if dn in add_items:
261                 to_delete = OrderedSet()
262                 for attr, vals in attrs.items():
263                     if attr not in add_items[dn]:
264                         to_delete.add(attr)
265                 for attr in to_delete:
266                     del attrs[attr]
267                     del new[dn][attr]
268                 if not attrs:
269                     dn_to_delete.add(dn)
270         for dn in dn_to_delete:
271             del new[dn]
272             del expected_db[dn]
273     name = "ldapi:///"
274     expected_ret["name"] = name
275     expected_ret.setdefault("result", True)
276     expected_ret.setdefault("comment", "Successfully updated LDAP entries")
277     expected_ret.setdefault(
278         "changes",
279         {
280             dn: {
281 <a name="0"></a>                "old": {
282                     attr: vals
283                     for attr, vals in old[dn].items()
284                     if vals != new<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get(dn, {}).get(attr, ())
285                 }
286                 if dn in old
287                 else None,
288                 "new": {
289                     attr: vals
290                     for attr, vals in new[dn].items()
291                     if vals != old.get(dn, {}).get(attr, ())
292                 }
293                 if dn in new
294                 else None,
295             }
296             for dn in add_items
297             if old.get(dn, {}) != new.</b></font>get(dn, {})
298         },
299     )
300     entries = [
301         {dn: [{"add": attrs}, {"delete_others": delete_others}]}
302         for dn, attrs in add_items.items()
303     ]
304     actual = salt.states.ldap.managed(name, entries)
305     assert expected_ret == actual
306     assert expected_db == db.db
307 def _test_helper_success_add(db, add_items, delete_others=False):
308     _test_helper_add(db, {}, add_items, delete_others)
309 def test_managed_empty(db):
310     name = "ldapi:///"
311     expected = {
312         "name": name,
313         "changes": {},
314         "result": True,
315         "comment": "LDAP entries already set",
316     }
317     actual = salt.states.ldap.managed(name, {})
318     assert expected == actual
319 def test_managed_add_entry(db):
320     _test_helper_success_add(db, {"dummydn": {"foo": ["bar", "baz"]}})
321 def test_managed_add_attr(complex_db):
322     _test_helper_success_add(complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.3"]}})
323     _test_helper_success_add(complex_db, {"dnfoo": {"attrfoo4": ["valfoo4.1"]}})
324 def test_managed_replace_attr(complex_db):
325     _test_helper_success(complex_db, {"dnfoo": {"attrfoo3": ["valfoo3.1"]}})
326 def test_managed_simplereplace(complex_db):
327     _test_helper_success(complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.3"]}})
328 def test_managed_deleteattr(complex_db):
329     _test_helper_success(complex_db, {"dnfoo": {"attrfoo1": []}})
330 def test_managed_deletenonexistattr(no_change_complex_db):
331     _test_helper_nochange(no_change_complex_db, {"dnfoo": {"dummyattr": []}})
332 def test_managed_deleteentry(complex_db):
333     _test_helper_success(complex_db, {"dnfoo": {}}, True)
334 def test_managed_deletenonexistentry(no_change_complex_db):
335     _test_helper_nochange(no_change_complex_db, {"dummydn": {}}, True)
336 def test_managed_deletenonexistattrinnonexistentry(no_change_complex_db):
337     _test_helper_nochange(no_change_complex_db, {"dummydn": {"dummyattr": []}})
338 def test_managed_add_attr_delete_others(complex_db):
339     _test_helper_success(complex_db, {"dnfoo": {"dummyattr": ["dummyval"]}}, True)
340 def test_managed_no_net_change(no_change_complex_db):
341     _test_helper_nochange(
342         no_change_complex_db, {"dnfoo": {"attrfoo1": ["valfoo1.1", "valfoo1.2"]}}
343     )
344 def test_managed_repeated_values(db):
345     _test_helper_success(db, {"dummydn": {"dummyattr": ["dummyval", "dummyval"]}})
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_zypperpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import io
3 import os
4 from xml.dom import minidom
5 import salt.modules.pkg_resource as pkg_resource
6 import salt.modules.zypperpkg as zypper
7 import salt.utils.files
8 import salt.utils.pkg
9 from salt.exceptions import CommandExecutionError
10 from tests.support.mixins import LoaderModuleMockMixin
11 from tests.support.mock import MagicMock, Mock, call, patch
12 from tests.support.unit import TestCase
13 class ZyppCallMock:
14     def __init__(self, return_value=None):
15         self.__return_value = return_value
16     def __getattr__(self, item):
17         return self
18     def __call__(self, *args, **kwargs):
19         if any(i in kwargs for i in ("no_repo_failure", "systemd_scope", "root")):
20             return self
21         return MagicMock(return_value=self.__return_value)()
22 def get_test_data(filename):
23     with salt.utils.files.fopen(
24         os.path.join(
25             os.path.join(os.path.dirname(os.path.abspath(__file__)), "zypp"), filename
26         )
27     ) as rfh:
28         return rfh.read()
29 class ZypperTestCase(TestCase, LoaderModuleMockMixin):
30     def setup_loader_modules(self):
31         return {zypper: {"rpm": None}, pkg_resource: {}}
32     def setUp(self):
33         self.new_repo_config = dict(
34             name="mock-repo-name", url="http://repo.url/some/path"
35         )
36         side_effect = [
37             Mock(**{"sections.return_value": []}),
38             Mock(**{"sections.return_value": [self.new_repo_config["name"]]}),
39         ]
40         self.zypper_patcher_config = {
41             "_get_configured_repos": Mock(side_effect=side_effect),
42             "__zypper__": Mock(),
43             "_get_repo_info": Mock(
44                 return_value={
45                     "keeppackages": False,
46                     "autorefresh": True,
47                     "enabled": False,
48                     "baseurl": self.new_repo_config["url"],
49                     "alias": self.new_repo_config["name"],
50                     "priority": 1,
51                     "type": "rpm-md",
52                 }
53             ),
54             "del_repo": Mock(),
55             "mod_repo": Mock(wraps=zypper.mod_repo),
56         }
57     def tearDown(self):
58         del self.new_repo_config
59         del self.zypper_patcher_config
60     def test_list_upgrades(self):
61         ref_out = {
62             "stdout": get_test_data("zypper-updates.xml"),
63             "stderr": None,
64             "retcode": 0,
65         }
66         with patch.dict(
67             zypper.__salt__, {"cmd.run_all": MagicMock(return_value=ref_out)}
68         ):
69             upgrades = zypper.list_upgrades(refresh=False)
70             self.assertEqual(len(upgrades), 3)
71             for pkg, version in {
72                 "SUSEConnect": "0.2.33-7.1",
73                 "bind-utils": "9.9.6P1-35.1",
74                 "bind-libs": "9.9.6P1-35.1",
75             }.items():
76                 self.assertIn(pkg, upgrades)
77                 self.assertEqual(upgrades[pkg], version)
78     @patch(
79         "salt.utils.environment.get_module_environment",
80         MagicMock(return_value={"SALT_RUNNING": "1"}),
81     )
82     def test_zypper_caller(self):
83         class RunSniffer:
84             def __init__(self, stdout=None, stderr=None, retcode=None):
85                 self.calls = list()
86                 self._stdout = stdout or ""
87                 self._stderr = stderr or ""
88                 self._retcode = retcode or 0
89             def __call__(self, *args, **kwargs):
90                 self.calls.append({"args": args, "kwargs": kwargs})
91                 return {
92                     "stdout": self._stdout,
93                     "stderr": self._stderr,
94                     "retcode": self._retcode,
95                 }
96         stdout_xml_snippet = '&lt;?xml version="1.0"?&gt;&lt;test foo="bar"/&gt;'
97         sniffer = RunSniffer(stdout=stdout_xml_snippet)
98         with patch.dict("salt.modules.zypperpkg.__salt__", {"cmd.run_all": sniffer}):
99             self.assertEqual(zypper.__zypper__.call("foo"), stdout_xml_snippet)
100             self.assertEqual(len(sniffer.calls), 1)
101             zypper.__zypper__.call("--no-refresh", "bar")
102             self.assertEqual(len(sniffer.calls), 2)
103             self.assertEqual(
104                 sniffer.calls[0]["args"][0],
105                 ["zypper", "--non-interactive", "--no-refresh", "foo"],
106             )
107             self.assertEqual(
108                 sniffer.calls[1]["args"][0],
109                 ["zypper", "--non-interactive", "--no-refresh", "bar"],
110             )
111             dom = zypper.__zypper__.xml.call("xml-test")
112             self.assertEqual(
113                 sniffer.calls[2]["args"][0],
114                 ["zypper", "--non-interactive", "--xmlout", "--no-refresh", "xml-test"],
115             )
116             self.assertEqual(
117                 dom.getElementsByTagName("test")[0].getAttribute("foo"), "bar"
118             )
119             zypper.__zypper__.refreshable.call("refresh-test")
120             self.assertEqual(
121                 sniffer.calls[3]["args"][0],
122                 ["zypper", "--non-interactive", "refresh-test"],
123             )
124             zypper.__zypper__.nolock.call("no-locking-test")
125 <a name="1"></a>            self.assertEqual(
126                 sniffer.calls[4]
127                 .get("kwargs", {})
128                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("env", {})
129                 .get("ZYPP_READONLY_HACK"),
130                 "1",
131             )
132             self.assertEqual(
133                 sniffer.calls[4].get("kwargs", {}).get("env", {}).get("SALT_RUNNING"),
134 <a name="0"></a>                "1",
135             )
136             zypper.</b></font>__zypper__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call("locking-test")
137             self.assertEqual(
138                 sniffer.calls[5]
139                 .get("kwargs", {})
140                 .get("env", {})
141                 .get("ZYPP_READONLY_HACK"),
142                 None,
143             )
144             self.assertEqual(
145                 sniffer.</b></font>calls[5].get("kwargs", {}).get("env", {}).get("SALT_RUNNING"),
146                 "1",
147             )
148         stdout_xml_snippet = (
149             '&lt;?xml version="1.0"?&gt;&lt;stream&gt;&lt;message'
150             ' type="error"&gt;Booya!&lt;/message&gt;&lt;/stream&gt;'
151         )
152         sniffer = RunSniffer(stdout=stdout_xml_snippet, retcode=1)
153         with patch.dict("salt.modules.zypperpkg.__salt__", {"cmd.run_all": sniffer}):
154             with self.assertRaisesRegex(
155                 CommandExecutionError, "^Zypper command failure: Booya!$"
156             ):
157                 zypper.__zypper__.xml.call("crashme")
158             with self.assertRaisesRegex(
159                 CommandExecutionError, "^Zypper command failure: Check Zypper's logs.$"
160             ):
161                 zypper.__zypper__.call("crashme again")
162             zypper.__zypper__.noraise.call("stay quiet")
163             self.assertEqual(zypper.__zypper__.error_msg, "Check Zypper's logs.")
164     def test_list_upgrades_error_handling(self):
165         ref_out = {
166             "stdout": """&lt;?xml version='1.0'?&gt;
167 &lt;stream&gt;
168  &lt;message type="info"&gt;Refreshing service &amp;apos;container-suseconnect&amp;apos;.&lt;/message&gt;
169  &lt;message type="error"&gt;Some handled zypper internal error&lt;/message&gt;
170  &lt;message type="error"&gt;Another zypper internal error&lt;/message&gt;
171 &lt;/stream&gt;
172             """,
173             "stderr": "",
174             "retcode": 1,
175         }
176         with patch.dict(
177             "salt.modules.zypperpkg.__salt__",
178             {"cmd.run_all": MagicMock(return_value=ref_out)},
179         ):
180             with self.assertRaisesRegex(
181                 CommandExecutionError,
182                 "^Zypper command failure: Some handled zypper internal error{}Another"
183                 " zypper internal error$".format(os.linesep),
184             ):
185                 zypper.list_upgrades(refresh=False)
186         ref_out = {"retcode": 1, "stdout": "", "stderr": ""}
187         with patch.dict(
188             "salt.modules.zypperpkg.__salt__",
189             {"cmd.run_all": MagicMock(return_value=ref_out)},
190         ):
191             with self.assertRaisesRegex(
192                 CommandExecutionError, "^Zypper command failure: Check Zypper's logs.$"
193             ):
194                 zypper.list_upgrades(refresh=False)
195     def test_list_products(self):
196         for filename, test_data in {
197             "zypper-products-sle12sp1.xml": {
198                 "name": [
199                     "SLES",
200                     "SLES",
201                     "SUSE-Manager-Proxy",
202                     "SUSE-Manager-Server",
203                     "sle-manager-tools-beta",
204                     "sle-manager-tools-beta-broken-eol",
205                     "sle-manager-tools-beta-no-eol",
206                 ],
207                 "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
208                 "release": ["0", "0", "0", "0", "0", "0", "0"],
209                 "productline": [None, None, None, None, None, None, "sles"],
210                 "eol_t": [
211                     None,
212                     0,
213                     1509408000,
214                     1522454400,
215                     1522454400,
216                     1730332800,
217                     1730332800,
218                 ],
219                 "isbase": [False, False, False, False, False, False, True],
220                 "installed": [False, False, False, False, False, False, True],
221                 "registerrelease": [None, None, None, None, None, None, "123"],
222             },
223             "zypper-products-sle11sp3.xml": {
224                 "name": [
225                     "SUSE-Manager-Server",
226                     "SUSE-Manager-Server",
227                     "SUSE-Manager-Server-Broken-EOL",
228                     "SUSE_SLES",
229                     "SUSE_SLES",
230                     "SUSE_SLES",
231                     "SUSE_SLES-SP4-migration",
232                 ],
233                 "vendor": "SUSE LINUX Products GmbH, Nuernberg, Germany",
234                 "release": ["1.138", "1.2", "1.2", "1.2", "1.201", "1.201", "1.4"],
235                 "productline": [None, None, None, None, None, "manager", "manager"],
236                 "eol_t": [None, 0, 0, 0, 0, 0, 0],
237                 "isbase": [False, False, False, False, False, True, True],
238                 "installed": [False, False, False, False, False, True, True],
239                 "registerrelease": [None, None, None, None, None, None, "42"],
240             },
241         }.items():
242             ref_out = {"retcode": 0, "stdout": get_test_data(filename)}
243             cmd_run_all = MagicMock(return_value=ref_out)
244             mock_call = call(
245                 [
246                     "zypper",
247                     "--non-interactive",
248                     "--xmlout",
249                     "--no-refresh",
250                     "--disable-repositories",
251                     "products",
252                     "-i",
253                 ],
254                 env={"ZYPP_READONLY_HACK": "1"},
255                 output_loglevel="trace",
256                 python_shell=False,
257             )
258             with patch.dict(zypper.__salt__, {"cmd.run_all": cmd_run_all}):
259                 products = zypper.list_products()
260                 self.assertEqual(len(products), 7)
261                 self.assertIn(
262                     test_data["vendor"], [product["vendor"] for product in products]
263                 )
264                 for kwd in [
265                     "name",
266                     "isbase",
267                     "installed",
268                     "release",
269                     "productline",
270                     "eol_t",
271                     "registerrelease",
272                 ]:
273                     self.assertCountEqual(
274                         test_data[kwd], [prod.get(kwd) for prod in products]
275                     )
276                 cmd_run_all.assert_has_calls([mock_call])
277     def test_refresh_db(self):
278         ref_out = [
279             "Repository 'openSUSE-Leap-42.1-LATEST' is up to date.",
280             "Repository 'openSUSE-Leap-42.1-Update' is up to date.",
281             "Retrieving repository 'openSUSE-Leap-42.1-Update-Non-Oss' metadata",
282             "Forcing building of repository cache",
283             "Building repository 'openSUSE-Leap-42.1-Update-Non-Oss' cache"
284             " ..........[done]",
285             "Building repository 'salt-dev' cache",
286             "All repositories have been refreshed.",
287         ]
288         run_out = {"stderr": "", "stdout": "\n".join(ref_out), "retcode": 0}
289         zypper_mock = MagicMock(return_value=run_out)
290         call_kwargs = {"output_loglevel": "trace", "python_shell": False, "env": {}}
291         with patch.dict(zypper.__salt__, {"cmd.run_all": zypper_mock}):
292             with patch.object(salt.utils.pkg, "clear_rtag", Mock()):
293                 result = zypper.refresh_db()
294                 self.assertEqual(result.get("openSUSE-Leap-42.1-LATEST"), False)
295                 self.assertEqual(result.get("openSUSE-Leap-42.1-Update"), False)
296                 self.assertEqual(result.get("openSUSE-Leap-42.1-Update-Non-Oss"), True)
297                 zypper_mock.assert_called_with(
298                     ["zypper", "--non-interactive", "refresh", "--force"], **call_kwargs
299                 )
300                 zypper.refresh_db(force=False)
301                 zypper_mock.assert_called_with(
302                     ["zypper", "--non-interactive", "refresh"], **call_kwargs
303                 )
304                 zypper.refresh_db(force=True)
305                 zypper_mock.assert_called_with(
306                     ["zypper", "--non-interactive", "refresh", "--force"], **call_kwargs
307                 )
308     def test_info_installed(self):
309         run_out = {
310             "virgo-dummy": {
311                 "build_date": "2015-07-09T10:55:19Z",
312                 "vendor": "openSUSE Build Service",
313                 "description": (
314                     "This is the Virgo dummy package used for testing SUSE Manager"
315                 ),
316                 "license": "GPL-2.0",
317                 "build_host": "sheep05",
318                 "url": "http://www.suse.com",
319                 "build_date_time_t": 1436432119,
320                 "relocations": "(not relocatable)",
321                 "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
322                 "install_date": "2016-02-23T16:31:57Z",
323                 "install_date_time_t": 1456241517,
324                 "summary": "Virgo dummy package",
325                 "version": "1.0",
326                 "signature": (
327                     "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
328                 ),
329                 "release": "1.1",
330                 "group": "Applications/System",
331                 "arch": "noarch",
332                 "size": "17992",
333             },
334             "libopenssl1_0_0": {
335                 "build_date": "2015-11-04T23:20:34Z",
336                 "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
337                 "description": "The OpenSSL Project is a collaborative effort.",
338                 "license": "OpenSSL",
339                 "build_host": "sheep11",
340                 "url": "https://www.openssl.org/",
341                 "build_date_time_t": 1446675634,
342                 "relocations": "(not relocatable)",
343                 "source_rpm": "openssl-1.0.1i-34.1.src.rpm",
344                 "install_date": "2016-02-23T16:31:35Z",
345                 "install_date_time_t": 1456241495,
346                 "summary": "Secure Sockets and Transport Layer Security",
347                 "version": "1.0.1i",
348                 "signature": (
349                     "RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82"
350                 ),
351                 "release": "34.1",
352                 "group": "Productivity/Networking/Security",
353                 "packager": "https://www.suse.com/",
354                 "arch": "x86_64",
355                 "size": "2576912",
356             },
357         }
358         with patch.dict(
359             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
360         ):
361             installed = zypper.info_installed()
362             self.assertEqual(len(installed), 2)
363             for pkg_name, pkg_info in installed.items():
364                 self.assertEqual(
365                     installed[pkg_name].get("source"), run_out[pkg_name]["source_rpm"]
366                 )
367             for pn_key, pn_val in run_out["virgo-dummy"].items():
368                 if pn_key == "source_rpm":
369                     continue
370                 self.assertEqual(installed["virgo-dummy"][pn_key], pn_val)
371     def test_info_installed_with_non_ascii_char(self):
372         run_out = {"vīrgô": {"description": "vīrgô d€šçripţiǫñ"}}
373         with patch.dict(
374             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
375         ):
376             installed = zypper.info_installed()
377             self.assertEqual(installed["vīrgô"]["description"], "vīrgô d€šçripţiǫñ")
378     def test_info_installed_with_all_versions(self):
379         run_out = {
380             "virgo-dummy": [
381                 {
382                     "build_date": "2015-07-09T10:55:19Z",
383                     "vendor": "openSUSE Build Service",
384                     "description": (
385                         "This is the Virgo dummy package used for testing SUSE Manager"
386                     ),
387                     "license": "GPL-2.0",
388                     "build_host": "sheep05",
389                     "url": "http://www.suse.com",
390                     "build_date_time_t": 1436432119,
391                     "relocations": "(not relocatable)",
392                     "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
393                     "install_date": "2016-02-23T16:31:57Z",
394                     "install_date_time_t": 1456241517,
395                     "summary": "Virgo dummy package",
396                     "version": "1.0",
397                     "signature": (
398                         "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
399                     ),
400                     "release": "1.1",
401                     "group": "Applications/System",
402                     "arch": "i686",
403                     "size": "17992",
404                 },
405                 {
406                     "build_date": "2015-07-09T10:15:19Z",
407                     "vendor": "openSUSE Build Service",
408                     "description": (
409                         "This is the Virgo dummy package used for testing SUSE Manager"
410                     ),
411                     "license": "GPL-2.0",
412                     "build_host": "sheep05",
413                     "url": "http://www.suse.com",
414                     "build_date_time_t": 1436432119,
415                     "relocations": "(not relocatable)",
416                     "source_rpm": "virgo-dummy-1.0-1.1.src.rpm",
417                     "install_date": "2016-02-23T16:31:57Z",
418                     "install_date_time_t": 14562415127,
419                     "summary": "Virgo dummy package",
420                     "version": "1.0",
421                     "signature": (
422                         "DSA/SHA1, Thu Jul  9 08:55:33 2015, Key ID 27fa41bd8a7c64f9"
423                     ),
424                     "release": "1.1",
425                     "group": "Applications/System",
426                     "arch": "x86_64",
427                     "size": "13124",
428                 },
429             ],
430             "libopenssl1_0_0": [
431                 {
432                     "build_date": "2015-11-04T23:20:34Z",
433                     "vendor": "SUSE LLC &lt;https://www.suse.com/&gt;",
434                     "description": "The OpenSSL Project is a collaborative effort.",
435                     "license": "OpenSSL",
436                     "build_host": "sheep11",
437                     "url": "https://www.openssl.org/",
438                     "build_date_time_t": 1446675634,
439                     "relocations": "(not relocatable)",
440                     "source_rpm": "openssl-1.0.1i-34.1.src.rpm",
441                     "install_date": "2016-02-23T16:31:35Z",
442                     "install_date_time_t": 1456241495,
443                     "summary": "Secure Sockets and Transport Layer Security",
444                     "version": "1.0.1i",
445                     "signature": (
446                         "RSA/SHA256, Wed Nov  4 22:21:34 2015, Key ID 70af9e8139db7c82"
447                     ),
448                     "release": "34.1",
449                     "group": "Productivity/Networking/Security",
450                     "packager": "https://www.suse.com/",
451                     "arch": "x86_64",
452                     "size": "2576912",
453                 }
454             ],
455         }
456         with patch.dict(
457             zypper.__salt__, {"lowpkg.info": MagicMock(return_value=run_out)}
458         ):
459             installed = zypper.info_installed(all_versions=True)
460             self.assertEqual(len(installed), 2)
461             for pkg_name, pkg_info_list in installed.items():
462                 self.assertEqual(
463                     len(pkg_info_list), 2 if pkg_name == "virgo-dummy" else 1
464                 )
465                 for info in pkg_info_list:
466                     self.assertTrue(info["arch"] in ("x86_64", "i686"))
467     def test_info_available(self):
468         test_pkgs = ["vim", "emacs", "python"]
469         with patch(
470             "salt.modules.zypperpkg.__zypper__",
471             ZyppCallMock(return_value=get_test_data("zypper-available.txt")),
472         ):
473             available = zypper.info_available(*test_pkgs, refresh=False)
474             self.assertEqual(len(available), 3)
475             for pkg_name, pkg_info in available.items():
476                 self.assertIn(pkg_name, test_pkgs)
477             self.assertEqual(available["emacs"]["status"], "up-to-date")
478             self.assertTrue(available["emacs"]["installed"])
479             self.assertEqual(available["emacs"]["support level"], "Level 3")
480             self.assertEqual(
481                 available["emacs"]["vendor"], "SUSE LLC &lt;https://www.suse.com/&gt;"
482             )
483             self.assertEqual(available["emacs"]["summary"], "GNU Emacs Base Package")
484             self.assertEqual(available["vim"]["status"], "not installed")
485             self.assertFalse(available["vim"]["installed"])
486             self.assertEqual(available["vim"]["support level"], "Level 3")
487             self.assertEqual(
488                 available["vim"]["vendor"], "SUSE LLC &lt;https://www.suse.com/&gt;"
489             )
490             self.assertEqual(available["vim"]["summary"], "Vi IMproved")
491     def test_latest_version(self):
492         with patch(
493             "salt.modules.zypperpkg.__zypper__",
494             ZyppCallMock(return_value=get_test_data("zypper-available.txt")),
495         ), patch("salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)):
496             self.assertEqual(zypper.latest_version("vim"), "7.4.326-2.62")
497             self.assertDictEqual(
498                 zypper.latest_version("vim", "fakepkg"),
499                 {"vim": "7.4.326-2.62", "fakepkg": ""},
500             )
501     def test_upgrade_success(self):
502         with patch.dict(zypper.__grains__, {"osrelease_info": [12, 1]}), patch(
503             "salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)
504         ), patch(
505             "salt.modules.zypperpkg._systemd_scope", MagicMock(return_value=False)
506         ):
507             with patch(
508                 "salt.modules.zypperpkg.__zypper__.noraise.call", MagicMock()
509             ) as zypper_mock:
510                 with patch(
511                     "salt.modules.zypperpkg.list_pkgs",
512                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
513                 ):
514                     ret = zypper.upgrade()
515                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
516                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
517                 with patch(
518                     "salt.modules.zypperpkg.list_pkgs",
519                     MagicMock(
520                         side_effect=[
521                             {"kernel-default": "1.1"},
522                             {"kernel-default": "1.1,1.2"},
523                         ]
524                     ),
525                 ):
526                     ret = zypper.upgrade()
527                     self.assertDictEqual(
528                         ret, {"kernel-default": {"old": "1.1", "new": "1.1,1.2"}}
529                     )
530                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
531                 with patch(
532                     "salt.modules.zypperpkg.list_pkgs",
533                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1,1.2"}]),
534                 ):
535                     ret = zypper.upgrade()
536                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.1,1.2"}})
537                     zypper_mock.assert_any_call("update", "--auto-agree-with-licenses")
538                 with patch(
539                     "salt.modules.zypperpkg.list_pkgs",
540                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
541                 ):
542                     ret = zypper.upgrade(dist_upgrade=True)
543                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
544                     zypper_mock.assert_any_call(
545                         "dist-upgrade", "--auto-agree-with-licenses"
546                     )
547                 with patch(
548                     "salt.modules.zypperpkg.list_pkgs",
549                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
550                 ):
551                     ret = zypper.upgrade(dist_upgrade=True, dryrun=True)
552                     zypper_mock.assert_any_call(
553                         "dist-upgrade", "--auto-agree-with-licenses", "--dry-run"
554                     )
555                     zypper_mock.assert_any_call(
556                         "dist-upgrade",
557                         "--auto-agree-with-licenses",
558                         "--dry-run",
559                         "--debug-solver",
560                     )
561                 with patch(
562                     "salt.modules.zypperpkg.list_pkgs",
563                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
564                 ):
565                     ret = zypper.upgrade(
566                         dist_upgrade=True,
567                         dryrun=True,
568                         fromrepo=["Dummy", "Dummy2"],
569                         novendorchange=True,
570                     )
571                     zypper_mock.assert_any_call(
572                         "dist-upgrade",
573                         "--auto-agree-with-licenses",
574                         "--dry-run",
575                         "--from",
576                         "Dummy",
577                         "--from",
578                         "Dummy2",
579                         "--no-allow-vendor-change",
580                     )
581                     zypper_mock.assert_any_call(
582                         "dist-upgrade",
583                         "--auto-agree-with-licenses",
584                         "--dry-run",
585                         "--from",
586                         "Dummy",
587                         "--from",
588                         "Dummy2",
589                         "--no-allow-vendor-change",
590                         "--debug-solver",
591                     )
592                 with patch(
593                     "salt.modules.zypperpkg.list_pkgs",
594                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.1"}]),
595                 ):
596                     ret = zypper.upgrade(
597                         dist_upgrade=False, fromrepo=["Dummy", "Dummy2"], dryrun=False
598                     )
599                     zypper_mock.assert_any_call(
600                         "update",
601                         "--auto-agree-with-licenses",
602                         "--repo",
603                         "Dummy",
604                         "--repo",
605                         "Dummy2",
606                     )
607                 with patch(
608                     "salt.modules.zypperpkg.list_pkgs",
609                     MagicMock(side_effect=[{"vim": "1.1"}, {"vim": "1.2"}]),
610                 ):
611                     ret = zypper.upgrade(
612                         dist_upgrade=True,
613                         fromrepo=["Dummy", "Dummy2"],
614                         novendorchange=True,
615                     )
616                     self.assertDictEqual(ret, {"vim": {"old": "1.1", "new": "1.2"}})
617                     zypper_mock.assert_any_call(
618                         "dist-upgrade",
619                         "--auto-agree-with-licenses",
620                         "--from",
621                         "Dummy",
622                         "--from",
623                         "Dummy2",
624                         "--no-allow-vendor-change",
625                     )
626     def test_upgrade_kernel(self):
627         with patch.dict(zypper.__grains__, {"osrelease_info": [12, 1]}), patch(
628             "salt.modules.zypperpkg.refresh_db", MagicMock(return_value=True)
629         ), patch(
630             "salt.modules.zypperpkg._systemd_scope", MagicMock(return_value=False)
631         ):
632             with patch.dict(
633                 zypper.__salt__,
634                 {
635                     "pkg_resource.parse_targets": MagicMock(
636                         return_value=(["kernel-default"], None)
637                     )
638                 },
639             ):
640                 with patch(
641                     "salt.modules.zypperpkg.__zypper__.noraise.call", MagicMock()
642                 ):
643                     with patch(
644                         "salt.modules.zypperpkg.list_pkgs",
645                         MagicMock(
646                             side_effect=[
647                                 {"kernel-default": "3.12.49-11.1"},
648                                 {"kernel-default": "3.12.49-11.1,3.12.51-60.20.2"},
649                             ]
650                         ),
651                     ):
652                         ret = zypper.install(
653                             "kernel-default", "--auto-agree-with-licenses"
654                         )
655                         self.assertDictEqual(
656                             ret,
657                             {
658                                 "kernel-default": {
659                                     "old": "3.12.49-11.1",
660                                     "new": "3.12.49-11.1,3.12.51-60.20.2",
661                                 }
662                             },
663                         )
664     def test_upgrade_failure(self):
665         zypper_out = """
666 Loading repository data...
667 Reading installed packages...
668 Computing distribution upgrade...
669 Use 'zypper repos' to get the list of defined repositories.
670 Repository 'DUMMY' not found by its alias, number, or URI.
671         Test whether or not an upgrade is available for a given package.
672         :return:
673         Test packages listing.
674         :return:
675         Test packages listing.
676         :return:
677         Test packages listing with the attr parameter
678         :return:
679         Test packages listing with the attr parameter reporting multiple version installed
680         :return:
681         Test advisory patches listing.
682         :return:
683         Test downloaded packages listing.
684         :return:
685         Test downloaded packages listing.
686         :return:
687         Test package download
688         :return:
689         Test a package installation with downloadonly=True.
690         :return:
691         Test a package installation with downloadonly=True when package is already downloaded.
692         :return:
693         Test successfully advisory patch installation.
694         :return:
695         Test failing advisory patch installation because patch does not exist.
696         :return:
697         Test successfully product installation.
698         Test package removal
699         :return:
700         Tests if repo info is properly parsed.
701         :return:
702         Test mod_repo adds the new repo and nothing else
703         :return:
704         Test mod_repo detects the repo already exists,
705         no modification was requested and no refresh requested either
706         :return:
707         Test mod_repo detects the repo already exists,
708         no modification was requested and no refresh requested either
709         :return:
710         Test mod_repo adds the new repo and call modify to update autorefresh
711         :return:
712         Test mod_repo detects the repository exists,
713         calls modify to update 'autorefresh' but does not call refresh
714         :return:
715         Test mod_repo adds the new repo and refreshes the repo with
716             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
717         :return:
718         Test mod_repo detects the repo already exists,
719         has nothing to modify and refreshes the repo with
720             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
721         :return:
722         Test mod_repo adds the new repo,
723         calls modify to update 'autorefresh' and refreshes the repo with
724             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
725         :return:
726         Test mod_repo detects the repo already exists,
727         calls modify to update 'autorefresh' and refreshes the repo with
728             `zypper --gpg-auto-import-keys refresh &lt;repo-name&gt;`
729         :return:
730         Test wildcard to query match all pattern
731         :return:
732         _zpr = MagicMock()
733         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
734         wcard = zypper.Wildcard(_zpr)
735         wcard.name, wcard.version = "libzypp", "*"
736         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
737             "16.2.4-19.5",
738             "16.3.2-25.1",
739             "16.5.2-27.9.1",
740         ]
741     def test_wildcard_to_query_multiple_asterisk(self):
742         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
743         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
744         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
745         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
746         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
747         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
748         """
749         _zpr = MagicMock()
750         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
751         wcard = zypper.Wildcard(_zpr)
752         wcard.name, wcard.version = "libzypp", "16.2.*-2*"
753         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
754             "16.2.5-25.1",
755             "16.2.6-27.9.1",
756         ]
757     def test_wildcard_to_query_exact_match_at_end(self):
758         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
759         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
760         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
761         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
762         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
763         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
764         """
765         _zpr = MagicMock()
766         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
767         wcard = zypper.Wildcard(_zpr)
768         wcard.name, wcard.version = "libzypp", "16.2.5*"
769         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
770             "16.2.5-25.1"
771         ]
772     def test_wildcard_to_query_exact_match_at_beginning(self):
773         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
774         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
775         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
776         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
777         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
778         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
779         """
780         _zpr = MagicMock()
781         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
782         wcard = zypper.Wildcard(_zpr)
783         wcard.name, wcard.version = "libzypp", "*.1"
784         assert wcard._get_scope_versions(wcard._get_available_versions()) == [
785             "16.2.5-25.1",
786             "17.2.6-27.9.1",
787         ]
788     def test_wildcard_to_query_usage(self):
789         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
790         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
791         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
792         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
793         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
794         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
795         """
796         _zpr = MagicMock()
797         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
798         assert zypper.Wildcard(_zpr)("libzypp", "16.2.4*") == "16.2.4-19.5"
799         assert zypper.Wildcard(_zpr)("libzypp", "16.2*") == "16.2.5-25.1"
800         assert zypper.Wildcard(_zpr)("libzypp", "*6-*") == "17.2.6-27.9.1"
801         assert zypper.Wildcard(_zpr)("libzypp", "*.1") == "17.2.6-27.9.1"
802     def test_wildcard_to_query_noversion(self):
803         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
804         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
805         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
806         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
807         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
808         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
809         """
810         _zpr = MagicMock()
811         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
812         assert zypper.Wildcard(_zpr)("libzypp", None) is None
813     def test_wildcard_to_query_typecheck(self):
814         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
815         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
816         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
817         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
818         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
819         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
820         """
821         _zpr = MagicMock()
822         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
823         assert isinstance(zypper.Wildcard(_zpr)("libzypp", "*.1"), str)
824     def test_wildcard_to_query_condition_preservation(self):
825         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
826         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
827         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
828         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
829         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
830         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
831         """
832         _zpr = MagicMock()
833         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
834         for op in zypper.Wildcard.Z_OP:
835             assert zypper.Wildcard(_zpr)(
836                 "libzypp", "{}*.1".format(op)
837             ) == "{}17.2.6-27.9.1".format(op)
838         for op in zypper.Wildcard.Z_OP:
839             assert zypper.Wildcard(_zpr)(
840                 "libzypp", "16*{}".format(op)
841             ) == "{}16.2.5-25.1".format(op)
842     def test_wildcard_to_query_unsupported_operators(self):
843         xmldoc = """&lt;?xml version='1.0'?&gt;&lt;stream&gt;
844         &lt;search-result version="0.0"&gt;&lt;solvable-list&gt;
845         &lt;solvable status="installed" name="libzypp" kind="package" edition="16.2.4-19.5" arch="x86_64" repository="foo"/&gt;
846         &lt;solvable status="other-version" name="libzypp" kind="package" edition="16.2.5-25.1" arch="x86_64" repository="foo"/&gt;
847         &lt;solvable status="other-version" name="libzypp" kind="package" edition="17.2.6-27.9.1" arch="x86_64" repository="foo"/&gt;
848         &lt;/solvable-list&gt;&lt;/search-result&gt;&lt;/stream&gt;
849         """
850         _zpr = MagicMock()
851         _zpr.nolock.xml.call = MagicMock(return_value=minidom.parseString(xmldoc))
852         with self.assertRaises(CommandExecutionError):
853             for op in ["&gt;&gt;", "==", "&lt;&lt;", "+"]:
854                 zypper.Wildcard(_zpr)("libzypp", "{}*.1".format(op))
855     @patch("salt.modules.zypperpkg._get_visible_patterns")
856     def test__get_installed_patterns(self, get_visible_patterns):
857         get_visible_patterns.return_value = {
858             "package-a": {"installed": True, "summary": "description a"},
859             "package-b": {"installed": False, "summary": "description b"},
860         }
861         salt_mock = {
862             "cmd.run": MagicMock(
863                 return_value="""pattern() = package-a
864 pattern-visible()
865 pattern() = package-c"""
866             ),
867         }
868         with patch.dict("salt.modules.zypperpkg.__salt__", salt_mock):
869             assert zypper._get_installed_patterns() == {
870                 "package-a": {"installed": True, "summary": "description a"},
871                 "package-c": {"installed": True, "summary": "Non-visible pattern"},
872             }
873     @patch("salt.modules.zypperpkg._get_visible_patterns")
874     def test__get_installed_patterns_with_alias(self, get_visible_patterns):
875         get_visible_patterns.return_value = {
876             "package-a": {"installed": True, "summary": "description a"},
877             "package-b": {"installed": False, "summary": "description b"},
878         }
879         salt_mock = {
880             "cmd.run": MagicMock(
881                 return_value="""pattern() = .package-a-alias
882 pattern() = package-a
883 pattern-visible()
884 pattern() = package-c"""
885             ),
886         }
887         with patch.dict("salt.modules.zypperpkg.__salt__", salt_mock):
888             assert zypper._get_installed_patterns() == {
889                 "package-a": {"installed": True, "summary": "description a"},
890                 "package-c": {"installed": True, "summary": "Non-visible pattern"},
891             }
892     @patch("salt.modules.zypperpkg._get_visible_patterns")
893     def test_list_patterns(self, get_visible_patterns):
894         get_visible_patterns.return_value = {
895             "package-a": {"installed": True, "summary": "description a"},
896             "package-b": {"installed": False, "summary": "description b"},
897         }
898         assert zypper.list_patterns() == {
899             "package-a": {"installed": True, "summary": "description a"},
900             "package-b": {"installed": False, "summary": "description b"},
901         }
902     def test__clean_cache_empty(self):
903         context = {}
904         with patch.dict(zypper.__context__, context):
905             zypper._clean_cache()
906             assert context == {}
907     def test__clean_cache_filled(self):
908         context = {
909             "pkg.list_pkgs_/mnt_[]": None,
910             "pkg.list_pkgs_/mnt_[patterns]": None,
911             "pkg.list_provides": None,
912             "pkg.other_data": None,
913         }
914         with patch.dict(zypper.__context__, context):
915             zypper._clean_cache()
916             self.assertEqual(zypper.__context__, {"pkg.other_data": None})
917     def test_services_need_restart(self):
918         expected = ["salt-minion", "firewalld"]
919         zypper_output = "salt-minion\nfirewalld"
920         zypper_mock = Mock()
921         zypper_mock(root=None).nolock.call = Mock(return_value=zypper_output)
922         with patch("salt.modules.zypperpkg.__zypper__", zypper_mock):
923             assert zypper.services_need_restart() == expected
924             zypper_mock(root=None).nolock.call.assert_called_with("ps", "-sss")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
