<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for dfb.py &amp; arte.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for dfb.py &amp; arte.py
      </h3>
<h1 align="center">
        4.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>dfb.py (16.438356%)<th>arte.py (2.8037384%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-28)<td><a href="#" name="0">(219-231)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>dfb.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from .common import InfoExtractor
4 from ..utils import unified_strdate
5 class DFBIE(InfoExtractor):
6     IE_NAME = 'tv.dfb.de'
7 <a name="0"></a>    _VALID_URL = r'https?://tv\.dfb\.de/video/(?P&lt;display_id&gt;[^/]+)/(?P&lt;id&gt;\d+)'
8     _TEST = {
9         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'url': 'http://tv.dfb.de/video/u-19-em-stimmen-zum-spiel-gegen-russland/11633/',
10         'md5': 'ac0f98a52a330f700b4b3034ad240649',
11         'info_dict': {
12             'id': '11633',
13             'display_id': 'u-19-em-stimmen-zum-spiel-gegen-russland',
14             'ext': 'mp4',
15             'title': 'U 19-EM: Stimmen zum Spiel gegen Russland',
16             'upload_date': '20150714',
17         },
18     }
19     def _real_extract(self, url):
20         display_id, video_id = re.match(self._VALID_URL, url).groups()
21         player_info = self._download_xml(</b></font>
22             'http://tv.dfb.de/server/hd_video.php?play=%s' % video_id,
23             display_id)
24         video_info = player_info.find('video')
25         stream_access_url = self._proto_relative_url(video_info.find('url').text.strip())
26         formats = []
27         for sa_url in (stream_access_url, stream_access_url + '&amp;area=&amp;format=iphone'):
28             stream_access_info = self._download_xml(sa_url, display_id)
29             token_el = stream_access_info.find('token')
30             manifest_url = token_el.attrib['url'] + '?' + 'hdnea=' + token_el.attrib['auth']
31             if '.f4m' in manifest_url:
32                 formats.extend(self._extract_f4m_formats(
33                     manifest_url + '&amp;hdcore=3.2.0',
34                     display_id, f4m_id='hds', fatal=False))
35             else:
36                 formats.extend(self._extract_m3u8_formats(
37                     manifest_url, display_id, 'mp4',
38                     'm3u8_native', m3u8_id='hls', fatal=False))
39         self._sort_formats(formats)
40         return {
41             'id': video_id,
42             'display_id': display_id,
43             'title': video_info.find('title').text,
44             'thumbnail': 'http://tv.dfb.de/images/%s_640x360.jpg' % video_id,
45             'upload_date': unified_strdate(video_info.find('time_date').text),
46             'formats': formats,
47         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>arte.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from .common import InfoExtractor
4 from ..compat import (
5     compat_str,
6     compat_urlparse,
7 )
8 from ..utils import (
9     ExtractorError,
10     int_or_none,
11     qualities,
12     strip_or_none,
13     try_get,
14     unified_strdate,
15     url_or_none,
16 )
17 class ArteTVBaseIE(InfoExtractor):
18     _ARTE_LANGUAGES = 'fr|de|en|es|it|pl'
19     _API_BASE = 'https://api.arte.tv/api/player/v1'
20 class ArteTVIE(ArteTVBaseIE):
21     _VALID_URL = r'''(?x)
22                     https?://
23                         (?:
24                             (?:www\.)?arte\.tv/(?P&lt;lang&gt;%(langs)s)/videos|
25                             api\.arte\.tv/api/player/v\d+/config/(?P&lt;lang_2&gt;%(langs)s)
26                         )
27                         /(?P&lt;id&gt;\d{6}-\d{3}-[AF])
28                     ''' % {'langs': ArteTVBaseIE._ARTE_LANGUAGES}
29     _TESTS = [{
30         'url': 'https://www.arte.tv/en/videos/088501-000-A/mexico-stealing-petrol-to-survive/',
31         'info_dict': {
32             'id': '088501-000-A',
33             'ext': 'mp4',
34             'title': 'Mexico: Stealing Petrol to Survive',
35             'upload_date': '20190628',
36         },
37     }, {
38         'url': 'https://www.arte.tv/pl/videos/100103-000-A/usa-dyskryminacja-na-porodowce/',
39         'only_matching': True,
40     }, {
41         'url': 'https://api.arte.tv/api/player/v2/config/de/100605-013-A',
42         'only_matching': True,
43     }]
44     def _real_extract(self, url):
45         mobj = re.match(self._VALID_URL, url)
46         video_id = mobj.group('id')
47         lang = mobj.group('lang') or mobj.group('lang_2')
48         info = self._download_json(
49             '%s/config/%s/%s' % (self._API_BASE, lang, video_id), video_id)
50         player_info = info['videoJsonPlayer']
51         vsr = try_get(player_info, lambda x: x['VSR'], dict)
52         if not vsr:
53             error = None
54             if try_get(player_info, lambda x: x['custom_msg']['type']) == 'error':
55                 error = try_get(
56                     player_info, lambda x: x['custom_msg']['msg'], compat_str)
57             if not error:
58                 error = 'Video %s is not available' % player_info.get('VID') or video_id
59             raise ExtractorError(error, expected=True)
60         upload_date_str = player_info.get('shootingDate')
61         if not upload_date_str:
62             upload_date_str = (player_info.get('VRA') or player_info.get('VDA') or '').split(' ')[0]
63         title = (player_info.get('VTI') or player_info['VID']).strip()
64         subtitle = player_info.get('VSU', '').strip()
65         if subtitle:
66             title += ' - %s' % subtitle
67         qfunc = qualities(['MQ', 'HQ', 'EQ', 'SQ'])
68         LANGS = {
69             'fr': 'F',
70             'de': 'A',
71             'en': 'E[ANG]',
72             'es': 'E[ESP]',
73             'it': 'E[ITA]',
74             'pl': 'E[POL]',
75         }
76         langcode = LANGS.get(lang, lang)
77         formats = []
78         for format_id, format_dict in vsr.items():
79             f = dict(format_dict)
80             format_url = url_or_none(f.get('url'))
81             streamer = f.get('streamer')
82             if not format_url and not streamer:
83                 continue
84             versionCode = f.get('versionCode')
85             l = re.escape(langcode)
86             PREFERENCES = (
87                 r'VO{0}$'.format(l),
88                 r'VO{0}-ST{0}$'.format(l),
89                 r'VO{0}-STM{0}$'.format(l),
90                 r'V{0}$'.format(l),
91                 r'V{0}-ST{0}$'.format(l),
92                 r'V{0}-STM{0}$'.format(l),
93                 r'VO{0}-ST(?!{0}).+?$'.format(l),
94                 r'VO{0}-STM(?!{0}).+?$'.format(l),
95                 r'VO(?:(?!{0}).+?)?-ST{0}$'.format(l),
96                 r'VO(?:(?!{0}).+?)?-STM{0}$'.format(l),
97                 r'VO(?:(?!{0}))?$'.format(l),
98                 r'VO(?:(?!{0}).+?)?-ST(?!{0}).+?$'.format(l),
99                 r'VO(?:(?!{0}).+?)?-STM(?!{0}).+?$'.format(l),
100             )
101             for pref, p in enumerate(PREFERENCES):
102                 if re.match(p, versionCode):
103                     lang_pref = len(PREFERENCES) - pref
104                     break
105             else:
106                 lang_pref = -1
107             media_type = f.get('mediaType')
108             if media_type == 'hls':
109                 m3u8_formats = self._extract_m3u8_formats(
110                     format_url, video_id, 'mp4', entry_protocol='m3u8_native',
111                     m3u8_id=format_id, fatal=False)
112                 for m3u8_format in m3u8_formats:
113                     m3u8_format['language_preference'] = lang_pref
114                 formats.extend(m3u8_formats)
115                 continue
116             format = {
117                 'format_id': format_id,
118                 'preference': -10 if f.get('videoFormat') == 'M3U8' else None,
119                 'language_preference': lang_pref,
120                 'format_note': '%s, %s' % (f.get('versionCode'), f.get('versionLibelle')),
121                 'width': int_or_none(f.get('width')),
122                 'height': int_or_none(f.get('height')),
123                 'tbr': int_or_none(f.get('bitrate')),
124                 'quality': qfunc(f.get('quality')),
125             }
126             if media_type == 'rtmp':
127                 format['url'] = f['streamer']
128                 format['play_path'] = 'mp4:' + f['url']
129                 format['ext'] = 'flv'
130             else:
131                 format['url'] = f['url']
132             formats.append(format)
133         self._sort_formats(formats)
134         return {
135             'id': player_info.get('VID') or video_id,
136             'title': title,
137             'description': player_info.get('VDE'),
138             'upload_date': unified_strdate(upload_date_str),
139             'thumbnail': player_info.get('programImage') or player_info.get('VTU', {}).get('IUR'),
140             'formats': formats,
141         }
142 class ArteTVEmbedIE(InfoExtractor):
143     _VALID_URL = r'https?://(?:www\.)?arte\.tv/player/v\d+/index\.php\?.*?\bjson_url=.+'
144     _TESTS = [{
145         'url': 'https://www.arte.tv/player/v5/index.php?json_url=https%3A%2F%2Fapi.arte.tv%2Fapi%2Fplayer%2Fv2%2Fconfig%2Fde%2F100605-013-A&amp;lang=de&amp;autoplay=true&amp;mute=0100605-013-A',
146         'info_dict': {
147             'id': '100605-013-A',
148             'ext': 'mp4',
149             'title': 'United we Stream November Lockdown Edition #13',
150             'description': 'md5:be40b667f45189632b78c1425c7c2ce1',
151             'upload_date': '20201116',
152         },
153     }, {
154         'url': 'https://www.arte.tv/player/v3/index.php?json_url=https://api.arte.tv/api/player/v2/config/de/100605-013-A',
155         'only_matching': True,
156     }]
157     @staticmethod
158     def _extract_urls(webpage):
159         return [url for _, url in re.findall(
160             r'&lt;(?:iframe|script)[^&gt;]+src=(["\'])(?P&lt;url&gt;(?:https?:)?//(?:www\.)?arte\.tv/player/v\d+/index\.php\?.*?\bjson_url=.+?)\1',
161             webpage)]
162     def _real_extract(self, url):
163         qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)
164         json_url = qs['json_url'][0]
165         video_id = ArteTVIE._match_id(json_url)
166         return self.url_result(
167             json_url, ie=ArteTVIE.ie_key(), video_id=video_id)
168 class ArteTVPlaylistIE(ArteTVBaseIE):
169     _VALID_URL = r'https?://(?:www\.)?arte\.tv/(?P&lt;lang&gt;%s)/videos/(?P&lt;id&gt;RC-\d{6})' % ArteTVBaseIE._ARTE_LANGUAGES
170 <a name="0"></a>    _TESTS = [{
171         'url': 'https://www.arte.tv/en/videos/RC-016954/earn-a-living/',
172         'info_dict': {
173             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>'id': 'RC-016954',
174             'title': 'Earn a Living',
175             'description': 'md5:d322c55011514b3a7241f7fb80d494c2',
176         },
177         'playlist_mincount': 6,
178     }, {
179         'url': 'https://www.arte.tv/pl/videos/RC-014123/arte-reportage/',
180         'only_matching': True,
181     }]
182     def _real_extract(self, url):
183         lang, playlist_id = re.match(self._VALID_URL, url).groups()
184         collection = self._download_json(</b></font>
185             '%s/collectionData/%s/%s?source=videos'
186             % (self._API_BASE, lang, playlist_id), playlist_id)
187         entries = []
188         for video in collection['videos']:
189             if not isinstance(video, dict):
190                 continue
191             video_url = url_or_none(video.get('url')) or url_or_none(video.get('jsonUrl'))
192             if not video_url:
193                 continue
194             video_id = video.get('programId')
195             entries.append({
196                 '_type': 'url_transparent',
197                 'url': video_url,
198                 'id': video_id,
199                 'title': video.get('title'),
200                 'alt_title': video.get('subtitle'),
201                 'thumbnail': url_or_none(try_get(video, lambda x: x['mainImage']['url'], compat_str)),
202                 'duration': int_or_none(video.get('durationSeconds')),
203                 'view_count': int_or_none(video.get('views')),
204                 'ie_key': ArteTVIE.ie_key(),
205             })
206         title = collection.get('title')
207         description = collection.get('shortDescription') or collection.get('teaserText')
208         return self.playlist_result(entries, playlist_id, title, description)
209 class ArteTVCategoryIE(ArteTVBaseIE):
210     _VALID_URL = r'https?://(?:www\.)?arte\.tv/(?P&lt;lang&gt;%s)/videos/(?P&lt;id&gt;[\w-]+(?:/[\w-]+)*)/?\s*$' % ArteTVBaseIE._ARTE_LANGUAGES
211     _TESTS = [{
212         'url': 'https://www.arte.tv/en/videos/politics-and-society/',
213         'info_dict': {
214             'id': 'politics-and-society',
215             'title': 'Politics and society',
216             'description': 'Investigative documentary series, geopolitical analysis, and international commentary',
217         },
218         'playlist_mincount': 13,
219     },
220     ]
221     @classmethod
222     def suitable(cls, url):
223         return (
224             not any(ie.suitable(url) for ie in (ArteTVIE, ArteTVPlaylistIE, ))
225             and super(ArteTVCategoryIE, cls).suitable(url))
226     def _real_extract(self, url):
227         lang, playlist_id = re.match(self._VALID_URL, url).groups()
228         webpage = self._download_webpage(url, playlist_id)
229         items = []
230         for video in re.finditer(
231                 r'&lt;a\b[^&gt;]*?href\s*=\s*(?P&lt;q&gt;"|\'|\b)(?P&lt;url&gt;https?://www\.arte\.tv/%s/videos/[\w/-]+)(?P=q)' % lang,
232                 webpage):
233             video = video.group('url')
234             if video == url:
235                 continue
236             if any(ie.suitable(video) for ie in (ArteTVIE, ArteTVPlaylistIE, )):
237                 items.append(video)
238         if items:
239             title = (self._og_search_title(webpage, default=None)
240                      or self._html_search_regex(r'&lt;title\b[^&gt;]*&gt;([^&lt;]+)&lt;/title&gt;', default=None))
241             title = strip_or_none(title.rsplit('|', 1)[0]) or self._generic_title(url)
242             result = self.playlist_from_matches(items, playlist_id=playlist_id, playlist_title=title)
243             if result:
244                 description = self._og_search_description(webpage, default=None)
245                 if description:
246                     result['description'] = description
247                 return result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
