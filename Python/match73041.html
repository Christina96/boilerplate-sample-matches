<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_genesis.py & test_solr.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_genesis.py & test_solr.py
      </h3>
      <h1 align="center">
        4.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_genesis.py (13.227513%)<TH>test_solr.py (2.6399155%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match73041-0.html#0',2,'match73041-1.html#0',3)" NAME="0">(48-51)<TD><A HREF="javascript:ZweiFrames('match73041-0.html#0',2,'match73041-1.html#0',3)" NAME="0">(329-333)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match73041-0.html#1',2,'match73041-1.html#1',3)" NAME="1">(189-196)<TD><A HREF="javascript:ZweiFrames('match73041-0.html#1',2,'match73041-1.html#1',3)" NAME="1">(503-510)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_genesis.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Rupesh Tare &lt;rupesht@saltstack.com&gt;
&quot;&quot;&quot;


import sys

import salt.modules.genesis as genesis
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class GenesisTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.genesis
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {genesis: {}}

    def test_bootstrap(self):
        &quot;&quot;&quot;
        Test for Create an image for a specific platform.
        &quot;&quot;&quot;
        # Changed in 3.7.0 pformat no longer includes the comma
        if sys.version_info &gt;= (3, 7):
            exception_string = &quot;Exception({})&quot;.format(repr(&quot;foo&quot;))
        else:
            exception_string = &quot;Exception({},)&quot;.format(repr(&quot;foo&quot;))
        mock = MagicMock(return_value=False)
        with patch.dict(genesis.__salt__, {&quot;file.directory_exists&quot;: mock}):
            mock = MagicMock(side_effect=Exception(&quot;foo&quot;))
            with patch.dict(genesis.__salt__, {&quot;file.mkdir&quot;: mock}):
                self.assertEqual(
                    genesis.bootstrap(&quot;platform&quot;, &quot;root&quot;), {&quot;Error&quot;: exception_string}
                )

        with patch.object(genesis, &quot;_bootstrap_yum&quot;, return_value=&quot;A&quot;):
            with patch.dict(
                genesis.__salt__,
                {
                    &quot;mount.umount&quot;: MagicMock(),
                    &quot;file.rmdir&quot;: MagicMock(),
<A NAME="0"></A>                    &quot;file.directory_exists&quot;: MagicMock(),
                },
            ):
                <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match73041-1.html#0',3,'match73041-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>with patch.dict(
                    genesis.__salt__, {&quot;disk.blkid&quot;: MagicMock(return_value={})}
                ):
                    self.assertEqual(genesis.bootstrap(&quot;</B></FONT>rpm&quot;, &quot;root&quot;, &quot;dir&quot;), None)

        common_parms = {
            &quot;platform&quot;: &quot;deb&quot;,
            &quot;root&quot;: &quot;root&quot;,
            &quot;img_format&quot;: &quot;dir&quot;,
            &quot;arch&quot;: &quot;amd64&quot;,
            &quot;flavor&quot;: &quot;stable&quot;,
            &quot;static_qemu&quot;: &quot;qemu&quot;,
        }

        param_sets = [
            {
                &quot;params&quot;: {},
                &quot;cmd&quot;: [
                    &quot;debootstrap&quot;,
                    &quot;--foreign&quot;,
                    &quot;--arch&quot;,
                    &quot;amd64&quot;,
                    &quot;stable&quot;,
                    &quot;root&quot;,
                    &quot;http://ftp.debian.org/debian/&quot;,
                ],
            },
            {
                &quot;params&quot;: {&quot;pkgs&quot;: &quot;vim&quot;},
                &quot;cmd&quot;: [
                    &quot;debootstrap&quot;,
                    &quot;--foreign&quot;,
                    &quot;--arch&quot;,
                    &quot;amd64&quot;,
                    &quot;--include&quot;,
                    &quot;vim&quot;,
                    &quot;stable&quot;,
                    &quot;root&quot;,
                    &quot;http://ftp.debian.org/debian/&quot;,
                ],
            },
            {
                &quot;params&quot;: {&quot;pkgs&quot;: &quot;vim,emacs&quot;},
                &quot;cmd&quot;: [
                    &quot;debootstrap&quot;,
                    &quot;--foreign&quot;,
                    &quot;--arch&quot;,
                    &quot;amd64&quot;,
                    &quot;--include&quot;,
                    &quot;vim,emacs&quot;,
                    &quot;stable&quot;,
                    &quot;root&quot;,
                    &quot;http://ftp.debian.org/debian/&quot;,
                ],
            },
            {
                &quot;params&quot;: {&quot;pkgs&quot;: [&quot;vim&quot;, &quot;emacs&quot;]},
                &quot;cmd&quot;: [
                    &quot;debootstrap&quot;,
                    &quot;--foreign&quot;,
                    &quot;--arch&quot;,
                    &quot;amd64&quot;,
                    &quot;--include&quot;,
                    &quot;vim,emacs&quot;,
                    &quot;stable&quot;,
                    &quot;root&quot;,
                    &quot;http://ftp.debian.org/debian/&quot;,
                ],
            },
            {
                &quot;params&quot;: {&quot;pkgs&quot;: [&quot;vim&quot;, &quot;emacs&quot;], &quot;exclude_pkgs&quot;: [&quot;vim&quot;, &quot;foo&quot;]},
                &quot;cmd&quot;: [
                    &quot;debootstrap&quot;,
                    &quot;--foreign&quot;,
                    &quot;--arch&quot;,
                    &quot;amd64&quot;,
                    &quot;--include&quot;,
                    &quot;vim,emacs&quot;,
                    &quot;--exclude&quot;,
                    &quot;vim,foo&quot;,
                    &quot;stable&quot;,
                    &quot;root&quot;,
                    &quot;http://ftp.debian.org/debian/&quot;,
                ],
            },
        ]

        for param_set in param_sets:

            with patch.dict(
                genesis.__salt__,
                {
                    &quot;mount.umount&quot;: MagicMock(),
                    &quot;file.rmdir&quot;: MagicMock(),
                    &quot;file.directory_exists&quot;: MagicMock(),
                    &quot;cmd.run&quot;: MagicMock(),
                    &quot;disk.blkid&quot;: MagicMock(return_value={}),
                },
            ):
                with patch(
                    &quot;salt.modules.genesis.salt.utils.path.which&quot;, return_value=True
                ):
                    with patch(
                        &quot;salt.modules.genesis.salt.utils.validate.path.is_executable&quot;,
                        return_value=True,
                    ):
                        param_set[&quot;params&quot;].update(common_parms)
                        self.assertEqual(genesis.bootstrap(**param_set[&quot;params&quot;]), None)
                        genesis.__salt__[&quot;cmd.run&quot;].assert_any_call(
                            param_set[&quot;cmd&quot;], python_shell=False
                        )

        with patch.object(
            genesis, &quot;_bootstrap_pacman&quot;, return_value=&quot;A&quot;
        ) as pacman_patch:
            with patch.dict(
                genesis.__salt__,
                {
                    &quot;mount.umount&quot;: MagicMock(),
                    &quot;file.rmdir&quot;: MagicMock(),
                    &quot;file.directory_exists&quot;: MagicMock(),
                    &quot;disk.blkid&quot;: MagicMock(return_value={}),
                },
            ):
                genesis.bootstrap(&quot;pacman&quot;, &quot;root&quot;, &quot;dir&quot;)
                pacman_patch.assert_called_with(
                    &quot;root&quot;, img_format=&quot;dir&quot;, exclude_pkgs=[], pkgs=[]
                )

    def test_avail_platforms(self):
        &quot;&quot;&quot;
        Test for Return which platforms are available
        &quot;&quot;&quot;
        with patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=False)):
            self.assertFalse(genesis.avail_platforms()[&quot;deb&quot;])

    def test_pack(self):
        &quot;&quot;&quot;
<A NAME="1"></A>        Test for Pack up a directory structure, into a specific format
        &quot;&quot;&quot;
        with patch.object(genesis, &quot;_tar&quot;, return_value=&quot;tar&quot;):
            self<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match73041-1.html#1',3,'match73041-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.assertEqual(genesis.pack(&quot;name&quot;, &quot;root&quot;), None)

    def test_unpack(self):
        &quot;&quot;&quot;
        Test for Unpack an image into a directory structure
        &quot;&quot;&quot;
        with patch.object(genesis, &quot;_untar&quot;, return_value=&quot;untar&quot;):
            self.</B></FONT>assertEqual(genesis.unpack(&quot;name&quot;, &quot;root&quot;), None)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_solr.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import os

import salt.modules.solr as solr
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class SolrTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.solr
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {solr: {}}

    def test_lucene_version(self):
        &quot;&quot;&quot;
        Test to get the lucene version that solr is using.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(
                solr, &quot;_get_none_or_value&quot;, side_effect=[None, True, True]
            ):
                with patch.object(
                    solr, &quot;_check_for_cores&quot;, side_effect=[True, False, False]
                ):
                    tempdict = {
                        &quot;success&quot;: &quot;success&quot;,
                        &quot;errors&quot;: &quot;errors&quot;,
                        &quot;data&quot;: {&quot;lucene&quot;: {&quot;lucene-spec-version&quot;: 1}},
                    }
                    with patch.object(
                        solr,
                        &quot;_get_admin_info&quot;,
                        side_effect=[tempdict, tempdict, {&quot;success&quot;: None}],
                    ):
                        with patch.dict(
                            solr.__salt__,
                            {&quot;config.option&quot;: MagicMock(return_value=[&quot;A&quot;])},
                        ):

                            with patch.object(
                                solr, &quot;_update_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
                            ):
                                self.assertDictEqual(
                                    solr.lucene_version(&quot;c&quot;), {&quot;A&quot;: &quot;a&quot;}
                                )

                            self.assertDictEqual(solr.lucene_version(&quot;c&quot;), {&quot;A&quot;: &quot;a&quot;})

                            self.assertDictEqual(
                                solr.lucene_version(&quot;c&quot;), {&quot;success&quot;: None}
                            )

    def test_version(self):
        &quot;&quot;&quot;
        Test to get the solr version for the core specified
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(
                solr, &quot;_get_none_or_value&quot;, side_effect=[None, True, True]
            ):
                with patch.object(
                    solr, &quot;_check_for_cores&quot;, side_effect=[True, False, False]
                ):

                    tempdict = {
                        &quot;success&quot;: &quot;success&quot;,
                        &quot;errors&quot;: &quot;errors&quot;,
                        &quot;warnings&quot;: &quot;warnings&quot;,
                        &quot;data&quot;: {&quot;lucene&quot;: {&quot;solr-spec-version&quot;: 1}},
                    }
                    with patch.object(
                        solr, &quot;_get_admin_info&quot;, side_effect=[tempdict, tempdict]
                    ):
                        with patch.dict(
                            solr.__opts__, {&quot;solr.cores&quot;: MagicMock(return_value=[&quot;A&quot;])}
                        ):
                            with patch.object(
                                solr, &quot;_update_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
                            ):
                                self.assertDictEqual(solr.version(), {&quot;A&quot;: &quot;a&quot;})

                            self.assertDictEqual(solr.version(), {&quot;A&quot;: &quot;a&quot;})

                    with patch.object(
                        solr, &quot;_get_admin_info&quot;, return_value={&quot;success&quot;: None}
                    ):
                        self.assertDictEqual(solr.version(), {&quot;success&quot;: None})

    def test_optimize(self):
        &quot;&quot;&quot;
        Test to search queries fast, but it is a very expensive operation.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]):
                with patch.object(solr, &quot;_check_for_cores&quot;, side_effect=[True, False]):
                    tempdict = {
                        &quot;success&quot;: &quot;success&quot;,
                        &quot;errors&quot;: &quot;errors&quot;,
                        &quot;warnings&quot;: &quot;warnings&quot;,
                        &quot;data&quot;: {&quot;lucene&quot;: {&quot;solr-spec-version&quot;: 1}},
                    }
                    with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                        with patch.dict(
                            solr.__salt__,
                            {&quot;config.option&quot;: MagicMock(return_value=[&quot;A&quot;])},
                        ):
                            with patch.object(
                                solr, &quot;_http_request&quot;, return_value=tempdict
                            ):
                                with patch.object(
                                    solr, &quot;_update_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
                                ):
                                    self.assertDictEqual(solr.optimize(), {&quot;A&quot;: &quot;a&quot;})

                        with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                            self.assertEqual(solr.optimize(), &quot;A&quot;)

    def test_ping(self):
        &quot;&quot;&quot;
        Test to check on solr, makes sure solr can talk to the
        indexes.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]):
                with patch.object(solr, &quot;_check_for_cores&quot;, side_effect=[True, False]):

                    tempdict = {
                        &quot;success&quot;: &quot;success&quot;,
                        &quot;errors&quot;: &quot;errors&quot;,
                        &quot;warnings&quot;: &quot;warnings&quot;,
                        &quot;data&quot;: {&quot;lucene&quot;: {&quot;solr-spec-version&quot;: 1}},
                    }

                    with patch.dict(
                        solr.__opts__, {&quot;solr.cores&quot;: MagicMock(return_value=[&quot;A&quot;])}
                    ):
                        with patch.object(
                            solr, &quot;_get_admin_info&quot;, return_value=tempdict
                        ):
                            with patch.object(
                                solr, &quot;_update_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
                            ):
                                self.assertDictEqual(solr.ping(), {&quot;A&quot;: &quot;a&quot;})

                    with patch.object(solr, &quot;_get_admin_info&quot;, return_value=&quot;A&quot;):
                        self.assertEqual(solr.ping(), &quot;A&quot;)

    def test_is_replication_enabled(self):
        &quot;&quot;&quot;
        Test to check for errors, and determine if a slave
        is replicating or not.
        &quot;&quot;&quot;
        error = 'Only &quot;slave&quot; minions can run &quot;is_replication_enabled&quot;'
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_is_master&quot;, side_effect=[True, False]):
                self.assertIsNone(solr.is_replication_enabled())
                with patch.object(solr, &quot;_get_none_or_value&quot;, return_value=None):
                    with patch.object(solr, &quot;_check_for_cores&quot;, return_value=True):
                        with patch.dict(
                            solr.__opts__, {&quot;solr.cores&quot;: MagicMock(return_value=&quot;A&quot;)}
                        ):
                            with patch.object(
                                solr, &quot;_replication_request&quot;, return_value=&quot;A&quot;
                            ):
                                self.assertDictEqual(
                                    solr.is_replication_enabled(),
                                    {&quot;A&quot;: &quot;a&quot;, &quot;errors&quot;: [error], &quot;success&quot;: False},
                                )

    def test_match_index_versions(self):
        &quot;&quot;&quot;
        Test to verifies that the master and the slave versions are in sync by
        comparing the index version.
        &quot;&quot;&quot;
        err = 'solr.match_index_versions can only be called by &quot;slave&quot; minions'
        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_is_master&quot;, side_effect=[True, False]):

                self.assertIsNone(solr.match_index_versions())

                with patch.object(solr, &quot;_get_none_or_value&quot;, return_value=None):
                    with patch.object(solr, &quot;_check_for_cores&quot;, return_value=True):
                        with patch.dict(
                            solr.__opts__, {&quot;solr.cores&quot;: MagicMock(return_value=&quot;A&quot;)}
                        ):
                            with patch.object(
                                solr, &quot;_replication_request&quot;, return_value=&quot;A&quot;
                            ):
                                self.assertDictEqual(
                                    solr.match_index_versions(),
                                    {&quot;A&quot;: &quot;a&quot;, &quot;errors&quot;: [err], &quot;success&quot;: False},
                                )

    def test_replication_details(self):
        &quot;&quot;&quot;
        Test to get the full replication details.
        &quot;&quot;&quot;
        tempdict1 = {
            &quot;success&quot;: &quot;success&quot;,
            &quot;errors&quot;: &quot;errors&quot;,
            &quot;warnings&quot;: &quot;warnings&quot;,
            &quot;data&quot;: &quot;data&quot;,
        }

        tempdict2 = {
            &quot;success&quot;: None,
            &quot;errors&quot;: &quot;errors&quot;,
            &quot;warnings&quot;: &quot;warnings&quot;,
            &quot;data&quot;: &quot;data&quot;,
        }

        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_get_none_or_value&quot;, return_value=True):
                with patch.object(
                    solr, &quot;_replication_request&quot;, side_effect=[tempdict2, tempdict1]
                ):

                    self.assertDictEqual(solr.replication_details(), tempdict2)

                    with patch.object(
                        solr, &quot;_update_return_dict&quot;, return_value=tempdict1
                    ):
                        self.assertDictEqual(solr.replication_details(), tempdict1)

    def test_backup(self):
        &quot;&quot;&quot;
        Test to tell solr make a backup.
        &quot;&quot;&quot;
        tempdict = {
            &quot;success&quot;: &quot;success&quot;,
            &quot;errors&quot;: &quot;errors&quot;,
            &quot;warnings&quot;: &quot;warnings&quot;,
            &quot;data&quot;: &quot;data&quot;,
        }

        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.dict(
                solr.__opts__,
                {
                    &quot;solr.backup_path&quot;: MagicMock(return_value=&quot;A&quot;),
                    &quot;solr.num_backups&quot;: MagicMock(return_value=&quot;B&quot;),
                    &quot;solr.cores&quot;: MagicMock(return_value=[&quot;A&quot;]),
                },
            ):
                with patch.object(os.path, &quot;sep&quot;, return_value=&quot;B&quot;):
                    with patch.object(
                        solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]
                    ):
                        with patch.object(
                            solr, &quot;_check_for_cores&quot;, side_effect=[True, False]
                        ):
                            with patch.object(
                                solr, &quot;_replication_request&quot;, return_value=tempdict
                            ):
                                with patch.dict(
                                    solr.__opts__,
                                    {&quot;solr.cores&quot;: MagicMock(return_value=[&quot;A&quot;])},
                                ):
                                    with patch.object(
                                        solr, &quot;_update_return_dict&quot;, return_value=&quot;A&quot;
                                    ):
                                        self.assertDictEqual(solr.backup(), {&quot;A&quot;: &quot;a&quot;})

                                self.assertDictEqual(solr.backup(), tempdict)

    def test_set_is_polling(self):
        &quot;&quot;&quot;
        Test to prevent the slaves from polling the master for updates.
        &quot;&quot;&quot;
        tempdict = {
            &quot;success&quot;: &quot;success&quot;,
            &quot;errors&quot;: &quot;errors&quot;,
            &quot;warnings&quot;: &quot;warnings&quot;,
            &quot;data&quot;: &quot;data&quot;,
        }

        err = 'solr.set_is_polling can only be called by &quot;slave&quot; minions'

        with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
            with patch.object(solr, &quot;_is_master&quot;, side_effect=[True, False, False]):
                with patch.object(
                    solr, &quot;_get_none_or_value&quot;, side_effect=[None, None, True]
                ):
                    with patch.object(
                        solr, &quot;_check_for_cores&quot;, side_effect=[True, False]
                    ):

                        self.assertIsNone(solr.set_is_polling(&quot;p&quot;))

                        with patch.dict(
                            solr.__opts__, {&quot;solr.cores&quot;: MagicMock(return_value=&quot;A&quot;)}
                        ):
                            with patch.object(
                                solr, &quot;_update_return_dict&quot;, return_value=tempdict
                            ):
                                self.assertDictEqual(
                                    solr.set_is_polling(&quot;p&quot;),
                                    {&quot;A&quot;: &quot;a&quot;, &quot;errors&quot;: [err], &quot;success&quot;: False},
                                )

                        with patch.object(
                            solr, &quot;_replication_request&quot;, return_value=&quot;A&quot;
                        ):
                            self.assertEqual(solr.set_is_polling(&quot;p&quot;), &quot;A&quot;)

    def test_set_replication_enabled(self):
        &quot;&quot;&quot;
        Test to sets the master to ignore poll requests from the slaves.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_is_master&quot;, side_effect=[False, True, True, True]):
            with patch.object(
                solr, &quot;_get_none_or_value&quot;, side_effect=[None, None, True, True, True]
            ):
                with patch.object(
                    solr, &quot;_get_return_dict&quot;, side_effect=[{&quot;A&quot;: &quot;a&quot;}, {}]
                ):
                    with patch.object(solr, &quot;_replication_request&quot;, return_value=&quot;A&quot;):
                        self.assertDictEqual(
<A NAME="0"></A>                            solr.set_replication_enabled(&quot;s&quot;), {&quot;A&quot;: &quot;a&quot;}
                        )
                        with patch.object(solr, &quot;_check_for_cores&quot;, return_value=True):
                            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match73041-0.html#0',2,'match73041-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>with patch.dict(
                                solr.__opts__,
                                {&quot;solr.cores&quot;: MagicMock(return_value=&quot;n&quot;)},
                            ):
                                self.assertEqual(solr.set_replication_enabled(&quot;</B></FONT>s&quot;), {})
                        self.assertEqual(solr.set_replication_enabled(&quot;s&quot;), &quot;A&quot;)
                        self.assertEqual(solr.set_replication_enabled(False), &quot;A&quot;)

    def test_signal(self):
        &quot;&quot;&quot;
        Test to signals Apache Solr to start, stop, or restart.
        &quot;&quot;&quot;
        self.assertEqual(
            solr.signal(&quot;signal&quot;),
            &quot;signal is an invalid signal. Try: one of: start, stop or restart&quot;,
        )

    def test_reload_core(self):
        &quot;&quot;&quot;
        Test to load a new core from the same configuration as
        an existing registered core.
        &quot;&quot;&quot;
        error = ['solr.reload_core can only be called by &quot;multi-core&quot; minions']
        with patch.object(
            solr, &quot;_check_for_cores&quot;, side_effect=[False, True, True, True]
        ):
            with patch.object(solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]):
                with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
                    with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                        with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                            with patch.dict(
                                solr.__opts__,
                                {&quot;solr.cores&quot;: MagicMock(return_value=&quot;n&quot;)},
                            ):
                                self.assertIsNone(solr.reload_core())
                                self.assertDictEqual(
                                    solr.reload_core(),
                                    {&quot;A&quot;: &quot;a&quot;, &quot;errors&quot;: error, &quot;success&quot;: False},
                                )
                                self.assertEqual(solr.reload_core(), &quot;A&quot;)

    def test_core_status(self):
        &quot;&quot;&quot;
        Test to get the status for a given core or all cores
        if no core is specified
        &quot;&quot;&quot;
        error = ['solr.reload_core can only be called by &quot;multi-core&quot; minions']
        with patch.object(
            solr, &quot;_check_for_cores&quot;, side_effect=[False, True, True, True]
        ):
            with patch.object(solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]):
                with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
                    with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                        with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                            with patch.dict(
                                solr.__opts__,
                                {&quot;solr.cores&quot;: MagicMock(return_value=&quot;n&quot;)},
                            ):
                                self.assertIsNone(solr.core_status())
                                self.assertDictEqual(
                                    solr.core_status(),
                                    {&quot;A&quot;: &quot;a&quot;, &quot;errors&quot;: error, &quot;success&quot;: False},
                                )

                                self.assertEqual(solr.core_status(), &quot;A&quot;)

    def test_reload_import_config(self):
        &quot;&quot;&quot;
        Test to re-loads the handler config XML file.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_is_master&quot;, side_effect=[False, True, True]):
            with patch.object(
                solr, &quot;_get_none_or_value&quot;, side_effect=[None, None, None, True, True]
            ):
                with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
                    with patch.object(
                        solr, &quot;_check_for_cores&quot;, side_effect=[True, False]
                    ):
                        with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                            with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                                self.assertDictEqual(
                                    solr.reload_import_config(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;}
                                )
                                self.assertDictEqual(
                                    solr.reload_import_config(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;}
                                )
                                self.assertEqual(solr.reload_import_config(&quot;h&quot;), &quot;A&quot;)

    def test_abort_import(self):
        &quot;&quot;&quot;
        Test to aborts an existing import command to the specified handler.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_is_master&quot;, side_effect=[False, True, True]):
            with patch.object(
                solr, &quot;_get_none_or_value&quot;, side_effect=[None, None, None, True, True]
            ):
                with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
                    with patch.object(
                        solr, &quot;_check_for_cores&quot;, side_effect=[True, False]
                    ):
                        with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                            with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                                self.assertDictEqual(solr.abort_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
                                self.assertDictEqual(solr.abort_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
                                self.assertEqual(solr.abort_import(&quot;h&quot;), &quot;A&quot;)

    def test_full_import(self):
        &quot;&quot;&quot;
        Test to submits an import command to the specified handler using
        specified options.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.solr._format_url&quot;, MagicMock(return_value=&quot;A&quot;)
        ), patch.object(
            solr, &quot;_is_master&quot;, side_effect=[False, True, True, True, True, True]
        ), patch.object(
            solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
        ), patch.object(
            solr, &quot;_get_none_or_value&quot;, side_effect=[None, True, True, True, True]
        ), patch.object(
            solr, &quot;_check_for_cores&quot;, side_effect=[True, False, False, False, False]
        ), patch.object(
            solr,
            &quot;_pre_index_check&quot;,
            side_effect=[{&quot;success&quot;: False}, {&quot;success&quot;: True}, {&quot;success&quot;: True}],
        ), patch.object(
            solr, &quot;_merge_options&quot;, side_effect=[{&quot;clean&quot;: True}, {&quot;clean&quot;: False}]
        ), patch.object(
            solr, &quot;set_replication_enabled&quot;, return_value={&quot;success&quot;: False}
        ), patch.object(
            solr, &quot;_http_request&quot;, return_value=&quot;A&quot;
        ):

            self.assertDictEqual(solr.full_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
            self.assertDictEqual(solr.full_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
            self.assertDictEqual(solr.full_import(&quot;h&quot;), {&quot;success&quot;: False})
            self.assertDictEqual(solr.full_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
            self.assertEqual(solr.full_import(&quot;h&quot;), &quot;A&quot;)

    def test_delta_import(self):
        &quot;&quot;&quot;
        Test to submits an import command to the specified handler using
        specified options.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.solr._format_url&quot;, MagicMock(return_value=&quot;A&quot;)
        ), patch.object(
            solr, &quot;_is_master&quot;, side_effect=[False, True, True, True, True]
        ), patch.object(
            solr, &quot;_get_none_or_value&quot;, side_effect=[None, True, True, True, True]
        ), patch.object(
            solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}
        ), patch.object(
            solr,
            &quot;_pre_index_check&quot;,
            side_effect=[
                {&quot;success&quot;: False},
                {&quot;success&quot;: True},
                {&quot;success&quot;: True},
                {&quot;success&quot;: True},
            ],
        ), patch.object(
            solr, &quot;_merge_options&quot;, side_effect=[{&quot;clean&quot;: True}, {&quot;clean&quot;: False}]
        ), patch.object(
            solr, &quot;_check_for_cores&quot;, side_effect=[True, False]
        ), patch.object(
            solr, &quot;set_replication_enabled&quot;, return_value={&quot;success&quot;: False}
        ), patch.object(
            solr, &quot;_http_request&quot;, return_value=&quot;A&quot;
        ):

<A NAME="1"></A>            self.assertDictEqual(solr.delta_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
            self.assertDictEqual(solr.delta_import(&quot;h&quot;), {&quot;success&quot;: False})
            self.assertDictEqual(solr.delta_import(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
            self<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match73041-0.html#1',2,'match73041-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertEqual(solr.delta_import(&quot;h&quot;), &quot;A&quot;)

    def test_import_status(self):
        &quot;&quot;&quot;
        Test to submits an import command to the specified handler using
        specified options.
        &quot;&quot;&quot;
        with patch.object(solr, &quot;_is_master&quot;, side_effect=[False</B></FONT>, True]):
            with patch.object(solr, &quot;_get_none_or_value&quot;, side_effect=[None, True]):
                with patch.object(solr, &quot;_get_return_dict&quot;, return_value={&quot;A&quot;: &quot;a&quot;}):
                    with patch.object(solr, &quot;_format_url&quot;, return_value=&quot;A&quot;):
                        with patch.object(solr, &quot;_http_request&quot;, return_value=&quot;A&quot;):
                            self.assertDictEqual(solr.import_status(&quot;h&quot;), {&quot;A&quot;: &quot;a&quot;})
                            self.assertEqual(solr.import_status(&quot;h&quot;), &quot;A&quot;)
</PRE>
</div>
  </div>
</body>
</html>
