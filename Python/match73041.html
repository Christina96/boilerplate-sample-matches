<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_genesis.py &amp; test_solr.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_genesis.py &amp; test_solr.py
      </h3>
<h1 align="center">
        4.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_genesis.py (13.227513%)<th>test_solr.py (2.6399155%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(48-51)<td><a href="#" name="0">(329-333)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(189-196)<td><a href="#" name="1">(503-510)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_genesis.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Rupesh Tare &lt;rupesht@saltstack.com&gt;
"""


import sys

import salt.modules.genesis as genesis
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class GenesisTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.modules.genesis
    """

    def setup_loader_modules(self):
        return {genesis: {}}

    def test_bootstrap(self):
        """
        Test for Create an image for a specific platform.
        """
        # Changed in 3.7.0 pformat no longer includes the comma
        if sys.version_info &gt;= (3, 7):
            exception_string = "Exception({})".format(repr("foo"))
        else:
            exception_string = "Exception({},)".format(repr("foo"))
        mock = MagicMock(return_value=False)
        with patch.dict(genesis.__salt__, {"file.directory_exists": mock}):
            mock = MagicMock(side_effect=Exception("foo"))
            with patch.dict(genesis.__salt__, {"file.mkdir": mock}):
                self.assertEqual(
                    genesis.bootstrap("platform", "root"), {"Error": exception_string}
                )

        with patch.object(genesis, "_bootstrap_yum", return_value="A"):
            with patch.dict(
                genesis.__salt__,
                {
                    "mount.umount": MagicMock(),
                    "file.rmdir": MagicMock(),
<a name="0"></a>                    "file.directory_exists": MagicMock(),
                },
            ):
                <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(
                    genesis.__salt__, {"disk.blkid": MagicMock(return_value={})}
                ):
                    self.assertEqual(genesis.bootstrap("</b></font>rpm", "root", "dir"), None)

        common_parms = {
            "platform": "deb",
            "root": "root",
            "img_format": "dir",
            "arch": "amd64",
            "flavor": "stable",
            "static_qemu": "qemu",
        }

        param_sets = [
            {
                "params": {},
                "cmd": [
                    "debootstrap",
                    "--foreign",
                    "--arch",
                    "amd64",
                    "stable",
                    "root",
                    "http://ftp.debian.org/debian/",
                ],
            },
            {
                "params": {"pkgs": "vim"},
                "cmd": [
                    "debootstrap",
                    "--foreign",
                    "--arch",
                    "amd64",
                    "--include",
                    "vim",
                    "stable",
                    "root",
                    "http://ftp.debian.org/debian/",
                ],
            },
            {
                "params": {"pkgs": "vim,emacs"},
                "cmd": [
                    "debootstrap",
                    "--foreign",
                    "--arch",
                    "amd64",
                    "--include",
                    "vim,emacs",
                    "stable",
                    "root",
                    "http://ftp.debian.org/debian/",
                ],
            },
            {
                "params": {"pkgs": ["vim", "emacs"]},
                "cmd": [
                    "debootstrap",
                    "--foreign",
                    "--arch",
                    "amd64",
                    "--include",
                    "vim,emacs",
                    "stable",
                    "root",
                    "http://ftp.debian.org/debian/",
                ],
            },
            {
                "params": {"pkgs": ["vim", "emacs"], "exclude_pkgs": ["vim", "foo"]},
                "cmd": [
                    "debootstrap",
                    "--foreign",
                    "--arch",
                    "amd64",
                    "--include",
                    "vim,emacs",
                    "--exclude",
                    "vim,foo",
                    "stable",
                    "root",
                    "http://ftp.debian.org/debian/",
                ],
            },
        ]

        for param_set in param_sets:

            with patch.dict(
                genesis.__salt__,
                {
                    "mount.umount": MagicMock(),
                    "file.rmdir": MagicMock(),
                    "file.directory_exists": MagicMock(),
                    "cmd.run": MagicMock(),
                    "disk.blkid": MagicMock(return_value={}),
                },
            ):
                with patch(
                    "salt.modules.genesis.salt.utils.path.which", return_value=True
                ):
                    with patch(
                        "salt.modules.genesis.salt.utils.validate.path.is_executable",
                        return_value=True,
                    ):
                        param_set["params"].update(common_parms)
                        self.assertEqual(genesis.bootstrap(**param_set["params"]), None)
                        genesis.__salt__["cmd.run"].assert_any_call(
                            param_set["cmd"], python_shell=False
                        )

        with patch.object(
            genesis, "_bootstrap_pacman", return_value="A"
        ) as pacman_patch:
            with patch.dict(
                genesis.__salt__,
                {
                    "mount.umount": MagicMock(),
                    "file.rmdir": MagicMock(),
                    "file.directory_exists": MagicMock(),
                    "disk.blkid": MagicMock(return_value={}),
                },
            ):
                genesis.bootstrap("pacman", "root", "dir")
                pacman_patch.assert_called_with(
                    "root", img_format="dir", exclude_pkgs=[], pkgs=[]
                )

    def test_avail_platforms(self):
        """
        Test for Return which platforms are available
        """
        with patch("salt.utils.path.which", MagicMock(return_value=False)):
            self.assertFalse(genesis.avail_platforms()["deb"])

    def test_pack(self):
        """
<a name="1"></a>        Test for Pack up a directory structure, into a specific format
        """
        with patch.object(genesis, "_tar", return_value="tar"):
            self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(genesis.pack("name", "root"), None)

    def test_unpack(self):
        """
        Test for Unpack an image into a directory structure
        """
        with patch.object(genesis, "_untar", return_value="untar"):
            self.</b></font>assertEqual(genesis.unpack("name", "root"), None)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_solr.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
"""

import os

import salt.modules.solr as solr
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class SolrTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.modules.solr
    """

    def setup_loader_modules(self):
        return {solr: {}}

    def test_lucene_version(self):
        """
        Test to get the lucene version that solr is using.
        """
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(
                solr, "_get_none_or_value", side_effect=[None, True, True]
            ):
                with patch.object(
                    solr, "_check_for_cores", side_effect=[True, False, False]
                ):
                    tempdict = {
                        "success": "success",
                        "errors": "errors",
                        "data": {"lucene": {"lucene-spec-version": 1}},
                    }
                    with patch.object(
                        solr,
                        "_get_admin_info",
                        side_effect=[tempdict, tempdict, {"success": None}],
                    ):
                        with patch.dict(
                            solr.__salt__,
                            {"config.option": MagicMock(return_value=["A"])},
                        ):

                            with patch.object(
                                solr, "_update_return_dict", return_value={"A": "a"}
                            ):
                                self.assertDictEqual(
                                    solr.lucene_version("c"), {"A": "a"}
                                )

                            self.assertDictEqual(solr.lucene_version("c"), {"A": "a"})

                            self.assertDictEqual(
                                solr.lucene_version("c"), {"success": None}
                            )

    def test_version(self):
        """
        Test to get the solr version for the core specified
        """
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(
                solr, "_get_none_or_value", side_effect=[None, True, True]
            ):
                with patch.object(
                    solr, "_check_for_cores", side_effect=[True, False, False]
                ):

                    tempdict = {
                        "success": "success",
                        "errors": "errors",
                        "warnings": "warnings",
                        "data": {"lucene": {"solr-spec-version": 1}},
                    }
                    with patch.object(
                        solr, "_get_admin_info", side_effect=[tempdict, tempdict]
                    ):
                        with patch.dict(
                            solr.__opts__, {"solr.cores": MagicMock(return_value=["A"])}
                        ):
                            with patch.object(
                                solr, "_update_return_dict", return_value={"A": "a"}
                            ):
                                self.assertDictEqual(solr.version(), {"A": "a"})

                            self.assertDictEqual(solr.version(), {"A": "a"})

                    with patch.object(
                        solr, "_get_admin_info", return_value={"success": None}
                    ):
                        self.assertDictEqual(solr.version(), {"success": None})

    def test_optimize(self):
        """
        Test to search queries fast, but it is a very expensive operation.
        """
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_get_none_or_value", side_effect=[None, True]):
                with patch.object(solr, "_check_for_cores", side_effect=[True, False]):
                    tempdict = {
                        "success": "success",
                        "errors": "errors",
                        "warnings": "warnings",
                        "data": {"lucene": {"solr-spec-version": 1}},
                    }
                    with patch.object(solr, "_format_url", return_value="A"):
                        with patch.dict(
                            solr.__salt__,
                            {"config.option": MagicMock(return_value=["A"])},
                        ):
                            with patch.object(
                                solr, "_http_request", return_value=tempdict
                            ):
                                with patch.object(
                                    solr, "_update_return_dict", return_value={"A": "a"}
                                ):
                                    self.assertDictEqual(solr.optimize(), {"A": "a"})

                        with patch.object(solr, "_http_request", return_value="A"):
                            self.assertEqual(solr.optimize(), "A")

    def test_ping(self):
        """
        Test to check on solr, makes sure solr can talk to the
        indexes.
        """
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_get_none_or_value", side_effect=[None, True]):
                with patch.object(solr, "_check_for_cores", side_effect=[True, False]):

                    tempdict = {
                        "success": "success",
                        "errors": "errors",
                        "warnings": "warnings",
                        "data": {"lucene": {"solr-spec-version": 1}},
                    }

                    with patch.dict(
                        solr.__opts__, {"solr.cores": MagicMock(return_value=["A"])}
                    ):
                        with patch.object(
                            solr, "_get_admin_info", return_value=tempdict
                        ):
                            with patch.object(
                                solr, "_update_return_dict", return_value={"A": "a"}
                            ):
                                self.assertDictEqual(solr.ping(), {"A": "a"})

                    with patch.object(solr, "_get_admin_info", return_value="A"):
                        self.assertEqual(solr.ping(), "A")

    def test_is_replication_enabled(self):
        """
        Test to check for errors, and determine if a slave
        is replicating or not.
        """
        error = 'Only "slave" minions can run "is_replication_enabled"'
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_is_master", side_effect=[True, False]):
                self.assertIsNone(solr.is_replication_enabled())
                with patch.object(solr, "_get_none_or_value", return_value=None):
                    with patch.object(solr, "_check_for_cores", return_value=True):
                        with patch.dict(
                            solr.__opts__, {"solr.cores": MagicMock(return_value="A")}
                        ):
                            with patch.object(
                                solr, "_replication_request", return_value="A"
                            ):
                                self.assertDictEqual(
                                    solr.is_replication_enabled(),
                                    {"A": "a", "errors": [error], "success": False},
                                )

    def test_match_index_versions(self):
        """
        Test to verifies that the master and the slave versions are in sync by
        comparing the index version.
        """
        err = 'solr.match_index_versions can only be called by "slave" minions'
        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_is_master", side_effect=[True, False]):

                self.assertIsNone(solr.match_index_versions())

                with patch.object(solr, "_get_none_or_value", return_value=None):
                    with patch.object(solr, "_check_for_cores", return_value=True):
                        with patch.dict(
                            solr.__opts__, {"solr.cores": MagicMock(return_value="A")}
                        ):
                            with patch.object(
                                solr, "_replication_request", return_value="A"
                            ):
                                self.assertDictEqual(
                                    solr.match_index_versions(),
                                    {"A": "a", "errors": [err], "success": False},
                                )

    def test_replication_details(self):
        """
        Test to get the full replication details.
        """
        tempdict1 = {
            "success": "success",
            "errors": "errors",
            "warnings": "warnings",
            "data": "data",
        }

        tempdict2 = {
            "success": None,
            "errors": "errors",
            "warnings": "warnings",
            "data": "data",
        }

        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_get_none_or_value", return_value=True):
                with patch.object(
                    solr, "_replication_request", side_effect=[tempdict2, tempdict1]
                ):

                    self.assertDictEqual(solr.replication_details(), tempdict2)

                    with patch.object(
                        solr, "_update_return_dict", return_value=tempdict1
                    ):
                        self.assertDictEqual(solr.replication_details(), tempdict1)

    def test_backup(self):
        """
        Test to tell solr make a backup.
        """
        tempdict = {
            "success": "success",
            "errors": "errors",
            "warnings": "warnings",
            "data": "data",
        }

        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.dict(
                solr.__opts__,
                {
                    "solr.backup_path": MagicMock(return_value="A"),
                    "solr.num_backups": MagicMock(return_value="B"),
                    "solr.cores": MagicMock(return_value=["A"]),
                },
            ):
                with patch.object(os.path, "sep", return_value="B"):
                    with patch.object(
                        solr, "_get_none_or_value", side_effect=[None, True]
                    ):
                        with patch.object(
                            solr, "_check_for_cores", side_effect=[True, False]
                        ):
                            with patch.object(
                                solr, "_replication_request", return_value=tempdict
                            ):
                                with patch.dict(
                                    solr.__opts__,
                                    {"solr.cores": MagicMock(return_value=["A"])},
                                ):
                                    with patch.object(
                                        solr, "_update_return_dict", return_value="A"
                                    ):
                                        self.assertDictEqual(solr.backup(), {"A": "a"})

                                self.assertDictEqual(solr.backup(), tempdict)

    def test_set_is_polling(self):
        """
        Test to prevent the slaves from polling the master for updates.
        """
        tempdict = {
            "success": "success",
            "errors": "errors",
            "warnings": "warnings",
            "data": "data",
        }

        err = 'solr.set_is_polling can only be called by "slave" minions'

        with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
            with patch.object(solr, "_is_master", side_effect=[True, False, False]):
                with patch.object(
                    solr, "_get_none_or_value", side_effect=[None, None, True]
                ):
                    with patch.object(
                        solr, "_check_for_cores", side_effect=[True, False]
                    ):

                        self.assertIsNone(solr.set_is_polling("p"))

                        with patch.dict(
                            solr.__opts__, {"solr.cores": MagicMock(return_value="A")}
                        ):
                            with patch.object(
                                solr, "_update_return_dict", return_value=tempdict
                            ):
                                self.assertDictEqual(
                                    solr.set_is_polling("p"),
                                    {"A": "a", "errors": [err], "success": False},
                                )

                        with patch.object(
                            solr, "_replication_request", return_value="A"
                        ):
                            self.assertEqual(solr.set_is_polling("p"), "A")

    def test_set_replication_enabled(self):
        """
        Test to sets the master to ignore poll requests from the slaves.
        """
        with patch.object(solr, "_is_master", side_effect=[False, True, True, True]):
            with patch.object(
                solr, "_get_none_or_value", side_effect=[None, None, True, True, True]
            ):
                with patch.object(
                    solr, "_get_return_dict", side_effect=[{"A": "a"}, {}]
                ):
                    with patch.object(solr, "_replication_request", return_value="A"):
                        self.assertDictEqual(
<a name="0"></a>                            solr.set_replication_enabled("s"), {"A": "a"}
                        )
                        with patch.object(solr, "_check_for_cores", return_value=True):
                            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with patch.dict(
                                solr.__opts__,
                                {"solr.cores": MagicMock(return_value="n")},
                            ):
                                self.assertEqual(solr.set_replication_enabled("</b></font>s"), {})
                        self.assertEqual(solr.set_replication_enabled("s"), "A")
                        self.assertEqual(solr.set_replication_enabled(False), "A")

    def test_signal(self):
        """
        Test to signals Apache Solr to start, stop, or restart.
        """
        self.assertEqual(
            solr.signal("signal"),
            "signal is an invalid signal. Try: one of: start, stop or restart",
        )

    def test_reload_core(self):
        """
        Test to load a new core from the same configuration as
        an existing registered core.
        """
        error = ['solr.reload_core can only be called by "multi-core" minions']
        with patch.object(
            solr, "_check_for_cores", side_effect=[False, True, True, True]
        ):
            with patch.object(solr, "_get_none_or_value", side_effect=[None, True]):
                with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
                    with patch.object(solr, "_format_url", return_value="A"):
                        with patch.object(solr, "_http_request", return_value="A"):
                            with patch.dict(
                                solr.__opts__,
                                {"solr.cores": MagicMock(return_value="n")},
                            ):
                                self.assertIsNone(solr.reload_core())
                                self.assertDictEqual(
                                    solr.reload_core(),
                                    {"A": "a", "errors": error, "success": False},
                                )
                                self.assertEqual(solr.reload_core(), "A")

    def test_core_status(self):
        """
        Test to get the status for a given core or all cores
        if no core is specified
        """
        error = ['solr.reload_core can only be called by "multi-core" minions']
        with patch.object(
            solr, "_check_for_cores", side_effect=[False, True, True, True]
        ):
            with patch.object(solr, "_get_none_or_value", side_effect=[None, True]):
                with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
                    with patch.object(solr, "_format_url", return_value="A"):
                        with patch.object(solr, "_http_request", return_value="A"):
                            with patch.dict(
                                solr.__opts__,
                                {"solr.cores": MagicMock(return_value="n")},
                            ):
                                self.assertIsNone(solr.core_status())
                                self.assertDictEqual(
                                    solr.core_status(),
                                    {"A": "a", "errors": error, "success": False},
                                )

                                self.assertEqual(solr.core_status(), "A")

    def test_reload_import_config(self):
        """
        Test to re-loads the handler config XML file.
        """
        with patch.object(solr, "_is_master", side_effect=[False, True, True]):
            with patch.object(
                solr, "_get_none_or_value", side_effect=[None, None, None, True, True]
            ):
                with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
                    with patch.object(
                        solr, "_check_for_cores", side_effect=[True, False]
                    ):
                        with patch.object(solr, "_format_url", return_value="A"):
                            with patch.object(solr, "_http_request", return_value="A"):
                                self.assertDictEqual(
                                    solr.reload_import_config("h"), {"A": "a"}
                                )
                                self.assertDictEqual(
                                    solr.reload_import_config("h"), {"A": "a"}
                                )
                                self.assertEqual(solr.reload_import_config("h"), "A")

    def test_abort_import(self):
        """
        Test to aborts an existing import command to the specified handler.
        """
        with patch.object(solr, "_is_master", side_effect=[False, True, True]):
            with patch.object(
                solr, "_get_none_or_value", side_effect=[None, None, None, True, True]
            ):
                with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
                    with patch.object(
                        solr, "_check_for_cores", side_effect=[True, False]
                    ):
                        with patch.object(solr, "_format_url", return_value="A"):
                            with patch.object(solr, "_http_request", return_value="A"):
                                self.assertDictEqual(solr.abort_import("h"), {"A": "a"})
                                self.assertDictEqual(solr.abort_import("h"), {"A": "a"})
                                self.assertEqual(solr.abort_import("h"), "A")

    def test_full_import(self):
        """
        Test to submits an import command to the specified handler using
        specified options.
        """
        with patch(
            "salt.modules.solr._format_url", MagicMock(return_value="A")
        ), patch.object(
            solr, "_is_master", side_effect=[False, True, True, True, True, True]
        ), patch.object(
            solr, "_get_return_dict", return_value={"A": "a"}
        ), patch.object(
            solr, "_get_none_or_value", side_effect=[None, True, True, True, True]
        ), patch.object(
            solr, "_check_for_cores", side_effect=[True, False, False, False, False]
        ), patch.object(
            solr,
            "_pre_index_check",
            side_effect=[{"success": False}, {"success": True}, {"success": True}],
        ), patch.object(
            solr, "_merge_options", side_effect=[{"clean": True}, {"clean": False}]
        ), patch.object(
            solr, "set_replication_enabled", return_value={"success": False}
        ), patch.object(
            solr, "_http_request", return_value="A"
        ):

            self.assertDictEqual(solr.full_import("h"), {"A": "a"})
            self.assertDictEqual(solr.full_import("h"), {"A": "a"})
            self.assertDictEqual(solr.full_import("h"), {"success": False})
            self.assertDictEqual(solr.full_import("h"), {"A": "a"})
            self.assertEqual(solr.full_import("h"), "A")

    def test_delta_import(self):
        """
        Test to submits an import command to the specified handler using
        specified options.
        """
        with patch(
            "salt.modules.solr._format_url", MagicMock(return_value="A")
        ), patch.object(
            solr, "_is_master", side_effect=[False, True, True, True, True]
        ), patch.object(
            solr, "_get_none_or_value", side_effect=[None, True, True, True, True]
        ), patch.object(
            solr, "_get_return_dict", return_value={"A": "a"}
        ), patch.object(
            solr,
            "_pre_index_check",
            side_effect=[
                {"success": False},
                {"success": True},
                {"success": True},
                {"success": True},
            ],
        ), patch.object(
            solr, "_merge_options", side_effect=[{"clean": True}, {"clean": False}]
        ), patch.object(
            solr, "_check_for_cores", side_effect=[True, False]
        ), patch.object(
            solr, "set_replication_enabled", return_value={"success": False}
        ), patch.object(
            solr, "_http_request", return_value="A"
        ):

<a name="1"></a>            self.assertDictEqual(solr.delta_import("h"), {"A": "a"})
            self.assertDictEqual(solr.delta_import("h"), {"success": False})
            self.assertDictEqual(solr.delta_import("h"), {"A": "a"})
            self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(solr.delta_import("h"), "A")

    def test_import_status(self):
        """
        Test to submits an import command to the specified handler using
        specified options.
        """
        with patch.object(solr, "_is_master", side_effect=[False</b></font>, True]):
            with patch.object(solr, "_get_none_or_value", side_effect=[None, True]):
                with patch.object(solr, "_get_return_dict", return_value={"A": "a"}):
                    with patch.object(solr, "_format_url", return_value="A"):
                        with patch.object(solr, "_http_request", return_value="A"):
                            self.assertDictEqual(solr.import_status("h"), {"A": "a"})
                            self.assertEqual(solr.import_status("h"), "A")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
