
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.14534567229178%, Tokens: 9</h2>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-changesummary.py</h3>
            <pre><code>1  from enum import IntEnum
2  import json
3  from multiprocessing import Pool
4  import pathlib
5  import numpy as np
6  import pandas as pd
7  BRANCH_ARTIFACTS_DIR = (
8      pathlib.Path(__file__).parent.resolve()
9      / "googleapiclient"
10      / "discovery_cache"
11      / "documents"
12  )
13  MAIN_ARTIFACTS_DIR = (
14      pathlib.Path(__file__).parent.resolve()
15      / ".."
16      / "main"
17      / "googleapiclient"
18      / "discovery_cache"
19      / "documents"
20  )
21  MULTIPROCESSING_NUM_PER_BATCH = 5
22  MULTIPROCESSING_NUM_AGENTS = 10
23  class ChangeType(IntEnum):
24      UNKNOWN = 0
25      DELETED = 1
26      ADDED = 2
27      CHANGED = 3
28  class DirectoryDoesNotExist(ValueError):
29      pass
30  class ChangeSummary:
31      def __init__(self, new_artifacts_dir, current_artifacts_dir, temp_dir, file_list):
32          self._file_list = file_list
33          self._new_artifacts_dir = pathlib.Path(new_artifacts_dir)
34          self._current_artifacts_dir = pathlib.Path(current_artifacts_dir)
35          self._temp_dir = pathlib.Path(temp_dir)
36          self._raise_if_directory_not_found(self._new_artifacts_dir)
37          self._raise_if_directory_not_found(self._current_artifacts_dir)
38          self._raise_if_directory_not_found(self._temp_dir)
39      def _raise_if_directory_not_found(self, directory):
40          if not pathlib.Path(directory).exists():
41              raise DirectoryDoesNotExist(
42                  "Directory does not exist : {0}".format(directory)
43              )
44      def _load_json_to_dataframe(self, file_path):
45          dataframe_doc = pd.DataFrame()
46          if pathlib.Path(file_path).is_file():
47              with open(file_path, "r") as f:
48                  dataframe_doc = pd.json_normalize(json.load(f))
49          return dataframe_doc
50      def _get_discovery_differences(self, filename):
51          current_artifact_path = self._current_artifacts_dir / filename
52          new_artifact_path = self._new_artifacts_dir / filename
53          current_doc = self._load_json_to_dataframe(current_artifact_path)
54          new_doc = self._load_json_to_dataframe(new_artifact_path)
55          combined_docs = (
56              pd.concat([current_doc, new_doc], keys=["CurrentValue", "NewValue"])
57              .reset_index(drop=True, level=1)
58              .rename_axis(["Key"], axis=1).transpose()
59              .reset_index()
60          )
61          if "CurrentValue" not in combined_docs.columns:
62              combined_docs["CurrentValue"] = np.nan
63          if "NewValue" not in combined_docs.columns:
64              combined_docs["NewValue"] = np.nan
65          parent_child_df = combined_docs["Key"].str.rsplit(".", n=1, expand=True)
66          if len(parent_child_df.columns) == 1:
67              parent_child_df.columns = ["Parent"]
68          else:
69              parent_child_df.columns = ["Parent", "Child"]
70          combined_docs = combined_docs.join(parent_child_df)
71          combined_docs["Added"] = np.where(
72              combined_docs["CurrentValue"].isnull(), True, False
73          )
74          combined_docs["Deleted"] = np.where(
75              combined_docs["NewValue"].isnull(), True, False
76          )
77          parent_added_agg = (
78              combined_docs.groupby("Parent")
79              .Added.value_counts(normalize=True)
80              .reset_index(name="Proportion")
81          )
82          parent_added_agg["NumLevels"] = (
83              parent_added_agg["Parent"].str.split(".").apply(lambda x: len(x))
84          )
85          parent_deleted_agg = (
86              combined_docs.groupby("Parent")
87              .Deleted.value_counts(normalize=True)
88              .reset_index(name="Proportion")
89          )
90          parent_deleted_agg["NumLevels"] = (
91              parent_added_agg["Parent"].str.split(".").apply(lambda x: len(x))
92          )
93          all_added = (
94              parent_added_agg[
95                  (parent_added_agg["Proportion"] == 1)
96                  & (parent_added_agg["Added"] == True)
97              ][["Parent", "NumLevels"]]
98              .sort_values("NumLevels", ascending=True)
99              .Parent.to_list()
100          )
101          all_deleted = (
102              parent_deleted_agg[
103                  (parent_deleted_agg["Proportion"] == 1)
104                  & (parent_deleted_agg["Deleted"] == True)
105              ][["Parent", "NumLevels"]]
106              .sort_values("NumLevels", ascending=True)
107              .Parent.to_list()
108          )
109          for i in range(0, len(all_added)):
110              word = all_added[i]
111              combined_docs.Parent = np.where(
112                  combined_docs["Parent"].str.startswith(word), word, combined_docs.Parent
113              )
114          for i in range(0, len(all_deleted)):
115              word = all_deleted[i]
116              combined_docs.Parent = np.where(
117                  combined_docs["Parent"].str.startswith(word), word, combined_docs.Parent
118              )
119          docs_diff = combined_docs[
120              combined_docs["CurrentValue"] != combined_docs["NewValue"]
121          ].copy(deep=False)
122          api_version_string = filename.split(".")[:-1]
123          docs_diff["Name"] = api_version_string[0]
124          docs_diff["Version"] = ".".join(api_version_string[1:])
125          deleted_condition = docs_diff["NewValue"].isnull()
126          added_condition = docs_diff["CurrentValue"].isnull()
127          docs_diff["ChangeType"] = np.where(
128              deleted_condition,
129              ChangeType.DELETED,
130              np.where(added_condition, ChangeType.ADDED, ChangeType.CHANGED),
131          )
132          docs_diff = docs_diff[
133              ~docs_diff["Key"].str.contains(
134                  "|".join(self._get_keys_to_ignore()), case=False
135              )
136          ]
137          docs_diff_with_count = (
138              docs_diff.groupby(
139                  ["Parent", "Added", "Deleted", "Name", "Version", "ChangeType"]
140              )
<span onclick='openModal()' class='match'>141              .size()
142              .reset_index(name="Count")
143          )
144          docs_diff = docs_diff.merge(docs_diff_with_count)
145          docs_diff.loc[docs_diff["Count"] > 1, "Key"] = docs_diff["Parent"]
</span>146          return docs_diff[
147              ["Key", "Added", "Deleted", "Name", "Version", "ChangeType", "Count"]
148          ].drop_duplicates()
149      def _build_summary_message(self, api_name, is_feature):
150          commit_type = "feat" if is_feature else "fix"
151          return "{0}({1}): update the api".format(commit_type, api_name)
152      def _get_keys_to_ignore(self):
153          keys_to_ignore = [
154              "description",
155              "documentation",
156              "enum",
157              "etag",
158              "revision",
159              "title",
160              "url",
161              "rootUrl",
162          ]
163          return keys_to_ignore
164      def _get_stable_versions(self, versions):
165          return versions.str.extract(r"(v\d?\.?\d?\.?\d+$)").notnull()
166      def _get_summary_and_write_to_disk(self, dataframe, directory):
167          dataframe["IsStable"] = self._get_stable_versions(dataframe["Version"])
168          filter_features = (dataframe["ChangeType"] == ChangeType.DELETED) | (
169              dataframe["ChangeType"] == ChangeType.ADDED
170          )
171          dataframe["IsFeature"] = np.where(filter_features, True, np.nan)
172          dataframe["IsFeatureAggregate"] = dataframe.groupby("Name").IsFeature.transform(
173              lambda x: x.any()
174          )
175          dataframe["Summary"] = np.vectorize(self._build_summary_message)(
176              dataframe["Name"], dataframe["IsFeatureAggregate"]
177          )
178          dataframe.to_csv(directory / "allapis.dataframe")
179          return dataframe
180      def _write_verbose_changes_to_disk(self, dataframe, directory, summary_df):
181          verbose_changes = []
182          dataframe.sort_values(
183              by=["Name", "Version", "ChangeType"], ascending=True, inplace=True
184          )
185          change_type_groups = dataframe[
186              ["Name", "Version", "ChangeType", "Key", "Count"]
187          ].groupby(["Name", "Version", "ChangeType"])
188          lastApi = ""
189          lastVersion = ""
190          lastType = ChangeType.UNKNOWN
191          f = None
192          for name, group in change_type_groups:
193              currentApi = name[0]
194              currentVersion = name[1]
195              currentType = name[2]
196              if lastApi != currentApi:
197                  if f is not None:
198                      f.writelines(verbose_changes)
199                      f.close()
200                      f = None
201                  verbose_changes = []
202                  lastVersion = ""
203                  filename = "{0}.verbose".format(currentApi)
204                  f = open(pathlib.Path(directory / filename), "a")
205                  lastApi = currentApi
206                  current_api_filter = summary_df["Name"] == currentApi
207                  verbose_changes.append(summary_df[current_api_filter].Summary.iloc[0])
208              if lastVersion != currentVersion:
209                  verbose_changes.append(
210                      "\n\n#### {0}:{1}\n\n".format(currentApi, currentVersion)
211                  )
212                  lastVersion = currentVersion
213                  lastType = ChangeType.UNKNOWN
214              if currentType != lastType:
215                  if currentType == ChangeType.DELETED:
216                      verbose_changes.append("\nThe following keys were deleted:\n")
217                  elif currentType == ChangeType.ADDED:
218                      verbose_changes.append("\nThe following keys were added:\n")
219                  else:
220                      verbose_changes.append("\nThe following keys were changed:\n")
221                  lastType = currentType
222                  verbose_changes.extend(
223                      [
224                          "- {0} (Total Keys: {1})\n".format(row["Key"], row["Count"])
225                          for index, row in group[["Key", "Count"]].iterrows()
226                      ]
227                  )
228          if f is not None:
229              f.writelines(verbose_changes)
230              f.close()
231              f = None
232      def detect_discovery_changes(self):
233          result = pd.DataFrame()
234          with Pool(processes=MULTIPROCESSING_NUM_AGENTS) as pool:
235              if len(self._file_list):
236                  result = pd.concat(
237                      pool.map(
238                          self._get_discovery_differences,
239                          self._file_list,
240                          MULTIPROCESSING_NUM_PER_BATCH,
241                      )
242                  )
243          if len(result):
244              sort_columns = ["Name", "Version", "ChangeType", "Key"]
245              result.sort_values(by=sort_columns, ascending=True, inplace=True)
246              pathlib.Path(self._temp_dir).mkdir(exist_ok=True)
247              summary_df = self._get_summary_and_write_to_disk(result, self._temp_dir)
248              self._write_verbose_changes_to_disk(result, self._temp_dir, summary_df)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</h3>
            <pre><code>1  import binascii
2  import sys
3  from bitstring import BitArray, BitStream, CreationError
4  import esptool
5  from . import util
6  class CheckArgValue(object):
7      def __init__(self, efuses, name):
8          self.efuses = efuses
9          self.name = name
10      def __call__(self, new_value_str):
11          def check_arg_value(efuse, new_value):
12              if efuse.efuse_type.startswith("bool"):
13                  new_value = 1 if new_value is None else int(new_value, 0)
14                  if new_value != 1:
15                      raise esptool.FatalError(
16                          "New value is not accepted for efuse '{}' "
17                          "(will always burn 0->1), given value={}".format(
18                              efuse.name, new_value
19                          )
20                      )
21              elif efuse.efuse_type.startswith(("int", "uint")):
22                  if efuse.efuse_class == "bitcount":
23                      if new_value is None:
24                          old_value = efuse.get_raw()
25                          new_value = old_value
26                          bit = 1
27                          while new_value == old_value:
28                              new_value = bit | old_value
29                              bit <<= 1
30                      else:
31                          new_value = int(new_value, 0)
32                  else:
33                      if new_value is None:
34                          raise esptool.FatalError(
35                              "New value required for efuse '{}' (given None)".format(
36                                  efuse.name
37                              )
38                          )
39                      new_value = int(new_value, 0)
40                      if new_value == 0:
41                          raise esptool.FatalError(
42                              "New value should not be 0 for '{}' "
43                              "(given value= {})".format(efuse.name, new_value)
44                          )
45              elif efuse.efuse_type.startswith("bytes"):
46                  if new_value is None:
47                      raise esptool.FatalError(
48                          "New value required for efuse '{}' "
49                          "(given None)".format(efuse.name)
50                      )
51                  if len(new_value) * 8 != efuse.bitarray.len:
52                      raise esptool.FatalError(
53                          "The length of efuse '{}' ({} bits) "
54                          "(given len of the new value= {} bits)".format(
55                              efuse.name, efuse.bitarray.len, len(new_value) * 8
56                          )
57                      )
58              else:
59                  raise esptool.FatalError(
60                      "The '{}' type for the '{}' efuse is not supported yet.".format(
61                          efuse.efuse_type, efuse.name
62                      )
63                  )
64              return new_value
65          efuse = self.efuses[self.name]
66          new_value = efuse.check_format(new_value_str)
67          return check_arg_value(efuse, new_value)
68  class EfuseProtectBase(object):
69      def get_read_disable_mask(self, blk_part=None):
70          mask = 0
71          if isinstance(self.read_disable_bit, list):
72              if blk_part is None:
73                  for i in self.read_disable_bit:
74                      mask |= 1 << i
75              else:
76                  mask |= 1 << self.read_disable_bit[blk_part]
77          else:
78              mask = 1 << self.read_disable_bit
79          return mask
80      def get_count_read_disable_bits(self):
81          return bin(self.get_read_disable_mask()).count("1")
82      def is_readable(self, blk_part=None):
83          num_bit = self.read_disable_bit
84          if num_bit is None:
85              return True  # read cannot be disabled
86          return (self.parent["RD_DIS"].get() & self.get_read_disable_mask(blk_part)) == 0
87      def disable_read(self):
88          num_bit = self.read_disable_bit
89          if num_bit is None:
90              raise esptool.FatalError("This efuse cannot be read-disabled")
91          if not self.parent["RD_DIS"].is_writeable():
92              raise esptool.FatalError(
93                  "This efuse cannot be read-disabled due the to RD_DIS field is "
94                  "already write-disabled"
95              )
96          self.parent["RD_DIS"].save(self.get_read_disable_mask())
97      def is_writeable(self):
98          num_bit = self.write_disable_bit
99          if num_bit is None:
100              return True  # write cannot be disabled
101          return (self.parent["WR_DIS"].get() & (1 << num_bit)) == 0
102      def disable_write(self):
103          num_bit = self.write_disable_bit
104          if not self.parent["WR_DIS"].is_writeable():
105              raise esptool.FatalError(
106                  "This efuse cannot be write-disabled due to the WR_DIS field is "
107                  "already write-disabled"
108              )
109          self.parent["WR_DIS"].save(1 << num_bit)
110      def check_wr_rd_protect(self):
111          if not self.is_readable():
112              error_msg = "\t{} is read-protected.".format(self.name)
113              "The written value can not be read, the efuse/block looks as all 0.\n"
114              error_msg += "\tBurn in this case may damage an already written value."
115              self.parent.print_error_msg(error_msg)
116          if not self.is_writeable():
117              error_msg = "\t{} is write-protected. Burn is not possible.".format(
118                  self.name
119              )
120              self.parent.print_error_msg(error_msg)
121  class EfuseBlockBase(EfuseProtectBase):
122      def __init__(self, parent, param, skip_read=False):
123          self.parent = parent
124          self.name = param.name
125          self.alias = param.alias
126          self.id = param.id
127          self.rd_addr = param.rd_addr
128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
131          self.len = param.len
132          self.key_purpose_name = param.key_purpose
133          bit_block_len = self.get_block_len() * 8
134          self.bitarray = BitStream(bit_block_len)
135          self.bitarray.set(0)
136          self.wr_bitarray = BitStream(bit_block_len)
137          self.wr_bitarray.set(0)
138          self.fail = False
139          self.num_errors = 0
140          if self.id == 0:
141              self.err_bitarray = BitStream(bit_block_len)
142              self.err_bitarray.set(0)
143          else:
144              self.err_bitarray = None
145          if not skip_read:
146              self.read()
147      def get_block_len(self):
148          coding_scheme = self.get_coding_scheme()
149          if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
150              return self.len * 4
151          elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
152              return (self.len * 3 // 4) * 4
153          elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
154              return self.len * 4
155          else:
156              raise esptool.FatalError(
157                  "Coding scheme (%d) not supported" % (coding_scheme)
158              )
159      def get_coding_scheme(self):
160          if self.id == 0:
161              return self.parent.REGS.CODING_SCHEME_NONE
162          else:
163              return self.parent.coding_scheme
164      def get_raw(self, from_read=True):
165          if from_read:
166              return self.bitarray.bytes
167          else:
168              return self.wr_bitarray.bytes
169      def get(self, from_read=True):
170          self.get_bitstring(from_read=from_read)
171      def get_bitstring(self, from_read=True):
172          if from_read:
173              return self.bitarray
174          else:
175              return self.wr_bitarray
176      def convert_to_bitstring(self, new_data):
177          if isinstance(new_data, BitArray):
178              return new_data
179          else:
180              return BitArray(bytes=new_data, length=len(new_data) * 8)
181      def get_words(self):
182          def get_offsets(self):
183              return [x + self.rd_addr for x in range(0, self.get_block_len(), 4)]
184          return [self.parent.read_reg(offs) for offs in get_offsets(self)]
185      def read(self):
186          words = self.get_words()
187          data = BitArray()
188          for word in reversed(words):
189              data.append("uint:32=%d" % word)
190          self.bitarray.overwrite(data, pos=0)
191          self.print_block(self.bitarray, "read_regs")
192      def print_block(self, bit_string, comment, debug=False):
193          if self.parent.debug or debug:
194              bit_string.pos = 0
195              print(
196                  "%-15s (%-16s) [%-2d] %s:"
197                  % (self.name, " ".join(self.alias)[:16], self.id, comment),
198                  " ".join(
199                      [
200                          "%08x" % word
201                          for word in bit_string.readlist(
202                              "%d*uint:32" % (bit_string.len / 32)
203                          )[::-1]
204                      ]
205                  ),
206              )
207      def check_wr_data(self):
208          wr_data = self.wr_bitarray
209          if wr_data.all(False):
210              if self.parent.debug:
211                  print("[{:02}] {:20} nothing to burn".format(self.id, self.name))
212              return False
213          if len(wr_data.bytes) != len(self.bitarray.bytes):
214              raise esptool.FatalError(
215                  "Data does not fit: the block%d size is %d bytes, data is %d bytes"
216                  % (self.id, len(self.bitarray.bytes), len(wr_data.bytes))
217              )
218          self.check_wr_rd_protect()
219          if self.get_bitstring().all(False):
220              print(
221                  "[{:02}] {:20} is empty, will burn the new value".format(
222                      self.id, self.name
223                  )
224              )
225          else:
226              if self.get_bitstring() == wr_data:
227                  print(
228                      "[{:02}] {:20} is already written the same value, "
229                      "continue with EMPTY_BLOCK".format(self.id, self.name)
230                  )
231                  wr_data.set(0)
232              else:
233                  print("[{:02}] {:20} is not empty".format(self.id, self.name))
234                  print("\t(written ):", self.get_bitstring())
235                  print("\t(to write):", wr_data)
236                  mask = self.get_bitstring() & wr_data
237                  if mask == wr_data:
238                      print(
239                          "\tAll wr_data bits are set in the written block, "
240                          "continue with EMPTY_BLOCK."
241                      )
242                      wr_data.set(0)
243                  else:
244                      coding_scheme = self.get_coding_scheme()
245                      if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
246                          print("\t(coding scheme = NONE)")
247                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
248                          print("\t(coding scheme = RS)")
249                          error_msg = (
250                              "\tBurn into %s is forbidden "
251                              "(RS coding scheme does not allow this)." % (self.name)
252                          )
253                          self.parent.print_error_msg(error_msg)
254                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
255                          print("\t(coding scheme = 3/4)")
256                          data_can_not_be_burn = False
257                          for i in range(0, self.get_bitstring().len, 6 * 8):
258                              rd_chunk = self.get_bitstring()[i : i + 6 * 8 :]
259                              wr_chunk = wr_data[i : i + 6 * 8 :]
260                              if rd_chunk.any(True):
261                                  if wr_chunk.any(True):
262                                      print(
263                                          "\twritten chunk [%d] and wr_chunk "
264                                          "are not empty. " % (i // (6 * 8)),
265                                          end="",
266                                      )
267                                      if rd_chunk == wr_chunk:
268                                          print(
269                                              "wr_chunk == rd_chunk. "
270                                              "Countinue with empty chunk."
271                                          )
272                                          wr_data[i : i + 6 * 8 :].set(0)
273                                      else:
274                                          print("wr_chunk != rd_chunk. Can not burn.")
275                                          print("\twritten ", rd_chunk)
276                                          print("\tto write", wr_chunk)
277                                          data_can_not_be_burn = True
278                          if data_can_not_be_burn:
279                              error_msg = (
280                                  "\tBurn into %s is forbidden "
281                                  "(3/4 coding scheme does not allow this)." % (self.name)
282                              )
283                              self.parent.print_error_msg(error_msg)
284                      else:
285                          raise esptool.FatalError(
286                              "The coding scheme ({}) is not supported".format(
287                                  coding_scheme
288                              )
289                          )
290      def save(self, new_data):
291          data = BitStream(bytes=new_data[::-1], length=len(new_data) * 8)
292          if self.parent.debug:
293              print(
294                  "\twritten : {} ->\n\tto write: {}".format(self.get_bitstring(), data)
295              )
296          self.wr_bitarray.overwrite(self.wr_bitarray | data, pos=0)
297      def burn_words(self, words):
298          for burns in range(3):
299              self.parent.efuse_controller_setup()
300              if self.parent.debug:
301                  print("Write data to BLOCK%d" % (self.id))
302              write_reg_addr = self.wr_addr
303              for word in words:
304                  if self.parent.debug:
305                      print("Addr 0x%08x, data=0x%08x" % (write_reg_addr, word))
306                  self.parent.write_reg(write_reg_addr, word)
307                  write_reg_addr += 4
308              self.parent.write_efuses(self.id)
309              for _ in range(5):
310                  self.parent.efuse_read()
311                  self.parent.get_coding_scheme_warnings(silent=True)
312                  if self.fail or self.num_errors:
313                      print(
314                          "Error in BLOCK%d, re-burn it again (#%d), to fix it. "
315                          "fail_bit=%d, num_errors=%d"
316                          % (self.id, burns, self.fail, self.num_errors)
317                      )
318                      break
319              if not self.fail and self.num_errors == 0:
320                  break
321      def burn(self):
322          if self.wr_bitarray.all(False):
323              return
324          before_burn_bitarray = self.bitarray[:]
325          assert before_burn_bitarray is not self.bitarray
326          self.print_block(self.wr_bitarray, "to_write")
327          words = self.apply_coding_scheme()
328          self.burn_words(words)
329          self.read()
330          if not self.is_readable():
331              print(
332                  "{} ({}) is read-protected. "
333                  "Read back the burn value is not possible.".format(
334                      self.name, self.alias
335                  )
336              )
337              if self.bitarray.all(False):
338                  print("Read all '0'")
339              else:
340                  raise esptool.FatalError(
341                      "The {} is read-protected but not all '0' ({})".format(
342                          self.name, self.bitarray.hex
343                      )
344                  )
345          else:
346              if self.wr_bitarray == self.bitarray:
347                  print("BURN BLOCK%-2d - OK (write block == read block)" % self.id)
348              elif (
349                  self.wr_bitarray & self.bitarray == self.wr_bitarray
350                  and self.bitarray & before_burn_bitarray == before_burn_bitarray
351              ):
352                  print("BURN BLOCK%-2d - OK (all write block bits are set)" % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, "Expected")
355                  self.print_block(self.bitarray, "Real    ")
356                  if self.id != 0:
357                      raise esptool.FatalError(
358                          "Burn {} ({}) was not successful".format(self.name, self.alias)
359                      )
360          self.wr_bitarray.set(0)
361  class EspEfusesBase(object):
362      _esp = None
363      blocks = []
364      efuses = []
365      coding_scheme = None
366      force_write_always = None
367      batch_mode_cnt = 0
368      def __iter__(self):
369          return self.efuses.__iter__()
370      def get_crystal_freq(self):
371          return self._esp.get_crystal_freq()
372      def read_efuse(self, n):
373          return self._esp.read_efuse(n)
374      def read_reg(self, addr):
375          return self._esp.read_reg(addr)
376      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
377          return self._esp.write_reg(addr, value, mask, delay_us, delay_after_us)
378      def update_reg(self, addr, mask, new_val):
379          return self._esp.update_reg(addr, mask, new_val)
380      def efuse_controller_setup(self):
381          pass
382      def reconnect_chip(self, esp):
383          print("Re-connecting...")
384          baudrate = esp._port.baudrate
385          port = esp._port.port
386          esp._port.close()
387          return esptool.cmds.detect_chip(port, baudrate)
388      def get_index_block_by_name(self, name):
389          for block in self.blocks:
390              if block.name == name or name in block.alias:
391                  return block.id
392          return None
393      def read_blocks(self):
394          for block in self.blocks:
395              block.read()
396      def update_efuses(self):
397          for efuse in self.efuses:
398              efuse.update(self.blocks[efuse.block].bitarray)
399      def burn_all(self, check_batch_mode=False):
400          if check_batch_mode:
401              if self.batch_mode_cnt != 0:
402                  print(
403                      "\nBatch mode is enabled, "
404                      "the burn will be done at the end of the command."
405                  )
406                  return False
407          print("\nCheck all blocks for burn...")
408          print("idx, BLOCK_NAME,          Conclusion")
409          have_wr_data_for_burn = False
410          for block in self.blocks:
411              block.check_wr_data()
412              if not have_wr_data_for_burn and block.get_bitstring(from_read=False).any(
413                  True
414              ):
415                  have_wr_data_for_burn = True
416          if not have_wr_data_for_burn:
417              print("Nothing to burn, see messages above.")
418              return
419          EspEfusesBase.confirm("", self.do_not_confirm)
420          for block in reversed(self.blocks):
421              old_fail = block.fail
422              old_num_errors = block.num_errors
423              block.burn()
424              if (block.fail and old_fail != block.fail) or (
425                  block.num_errors and block.num_errors > old_num_errors
426              ):
427                  raise esptool.FatalError("Error(s) were detected in eFuses")
428          print("Reading updated efuses...")
429          self.read_coding_scheme()
430          self.read_blocks()
431          self.update_efuses()
432          return True
433      @staticmethod
434      def confirm(action, do_not_confirm):
435          print(
436              "%s%s\nThis is an irreversible operation!"
437              % (action, "" if action.endswith("\n") else ". ")
438          )
439          if not do_not_confirm:
440              print("Type 'BURN' (all capitals) to continue.")
441              sys.stdout.flush()
442              yes = input()
443              if yes != "BURN":
444                  print("Aborting.")
445                  sys.exit(0)
446      def print_error_msg(self, error_msg):
447          if self.force_write_always is not None:
448              if not self.force_write_always:
449                  error_msg += "(use '--force-write-always' option to ignore it)"
450          if self.force_write_always:
451              print(error_msg, "Skipped because '--force-write-always' option.")
452          else:
453              raise esptool.FatalError(error_msg)
454      def get_block_errors(self, block_num):
455          return self.blocks[block_num].num_errors, self.blocks[block_num].fail
456  class EfuseFieldBase(EfuseProtectBase):
457      def __init__(self, parent, param):
458          self.category = param.category
459          self.parent = parent
460          self.block = param.block
461          self.word = param.word
462          self.pos = param.pos
463          self.write_disable_bit = param.write_disable_bit
464          self.read_disable_bit = param.read_disable_bit
465          self.name = param.name
466          self.efuse_class = param.class_type
467          self.efuse_type = param.type
468          self.description = param.description
469          self.dict_value = param.dictionary
470          self.bit_len = param.bit_len
471          self.alt_names = param.alt_names
472          self.fail = False
473          self.num_errors = 0
474          self.bitarray = BitStream(self.bit_len)
475          self.bitarray.set(0)
476          self.update(self.parent.blocks[self.block].bitarray)
477      def check_format(self, new_value_str):
478          if new_value_str is None:
479              return new_value_str
480          else:
481              if self.efuse_type.startswith("bytes"):
482                  if new_value_str.startswith("0x"):
483                      return binascii.unhexlify(new_value_str[2:])[::-1]
484                  else:
485                      return binascii.unhexlify(new_value_str)
486              else:
487                  return new_value_str
488      def convert_to_bitstring(self, new_value):
489          if isinstance(new_value, BitArray):
490              return new_value
491          else:
492              if self.efuse_type.startswith("bytes"):
493                  return BitArray(bytes=new_value[::-1], length=len(new_value) * 8)
494              else:
495                  try:
496                      return BitArray(self.efuse_type + "={}".format(new_value))
497                  except CreationError as err:
498                      print(
499                          "New value '{}' is not suitable for {} ({})".format(
500                              new_value, self.name, self.efuse_type
501                          )
502                      )
503                      raise esptool.FatalError(err)
504      def check_new_value(self, bitarray_new_value):
505          bitarray_old_value = self.get_bitstring() | self.get_bitstring(from_read=False)
506          if bitarray_new_value.len != bitarray_old_value.len:
507              raise esptool.FatalError(
508                  "For {} efuse, the length of the new value is wrong, "
509                  "expected {} bits, was {} bits.".format(
510                      self.name, bitarray_old_value.len, bitarray_new_value.len
511                  )
512              )
513          if bitarray_new_value == bitarray_old_value:
514              error_msg = "\tThe same value for {} ".format(self.name)
515              error_msg += "is already burned. Do not change the efuse."
516              print(error_msg)
<span onclick='openModal()' class='match'>517              bitarray_new_value.set(0)
518          elif bitarray_new_value == self.get_bitstring(from_read=False):
519              error_msg = "\tThe same value for {} ".format(self.name)
</span>520              error_msg += "is already prepared for the burn operation."
521              print(error_msg)
522              bitarray_new_value.set(0)
523          else:
524              if self.name not in ["WR_DIS", "RD_DIS"]:
525                  if bitarray_new_value | bitarray_old_value != bitarray_new_value:
526                      error_msg = "\tNew value contains some bits that cannot be cleared "
527                      error_msg += "(value will be {})".format(
528                          bitarray_old_value | bitarray_new_value
529                      )
530                      self.parent.print_error_msg(error_msg)
531              self.check_wr_rd_protect()
532      def save_to_block(self, bitarray_field):
533          block = self.parent.blocks[self.block]
534          wr_bitarray_temp = block.wr_bitarray.copy()
535          position = wr_bitarray_temp.length - (
536              self.word * 32 + self.pos + bitarray_field.len
537          )
538          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
539          block.wr_bitarray |= wr_bitarray_temp
540      def save(self, new_value):
541          bitarray_field = self.convert_to_bitstring(new_value)
542          self.check_new_value(bitarray_field)
543          self.save_to_block(bitarray_field)
544      def update(self, bit_array_block):
545          if self.word is None or self.pos is None:
546              self.bitarray.overwrite(self.convert_to_bitstring(self.get()), pos=0)
547              return
548          field_len = self.bitarray.len
549          bit_array_block.pos = bit_array_block.length - (
550              self.word * 32 + self.pos + field_len
551          )
552          self.bitarray.overwrite(bit_array_block.read(field_len), pos=0)
553          err_bitarray = self.parent.blocks[self.block].err_bitarray
554          if err_bitarray is not None:
555              err_bitarray.pos = err_bitarray.length - (
556                  self.word * 32 + self.pos + field_len
557              )
558              self.fail = not err_bitarray.read(field_len).all(False)
559          else:
560              self.fail = self.parent.blocks[self.block].fail
561              self.num_errors = self.parent.blocks[self.block].num_errors
562      def get_raw(self, from_read=True):
563          return self.get_bitstring(from_read).read(self.efuse_type)
564      def get(self, from_read=True):
565          if self.efuse_type.startswith("bytes"):
566              return util.hexify(self.get_bitstring(from_read).bytes[::-1], " ")
567          else:
568              return self.get_raw(from_read)
569      def get_meaning(self, from_read=True):
570          if self.dict_value:
571              try:
572                  return self.dict_value[self.get_raw(from_read)]
573              except KeyError:
574                  pass
575          return self.get(from_read)
576      def get_bitstring(self, from_read=True):
577          if from_read:
578              self.bitarray.pos = 0
579              return self.bitarray
580          else:
581              field_len = self.bitarray.len
582              block = self.parent.blocks[self.block]
583              block.wr_bitarray.pos = block.wr_bitarray.length - (
584                  self.word * 32 + self.pos + field_len
585              )
586              return block.wr_bitarray.read(self.bitarray.len)
587      def burn(self, new_value):
588          self.save(new_value)
589          self.parent.burn_all()
590      def get_info(self):
591          output = f"{self.name} (BLOCK{self.block})"
592          if self.block == 0:
593              if self.fail:
594                  output += "[error]"
595          else:
596              errs, fail = self.parent.get_block_errors(self.block)
597              if errs != 0 or fail:
598                  output += "[error]"
599          if self.efuse_class == "keyblock":
600              name = self.parent.blocks[self.block].key_purpose_name
601              if name is not None:
602                  output += f"\n  Purpose: {self.parent[name].get()}\n "
603          return output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-changesummary.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</div>
                </div>
                <div class="column column_space"><pre><code>141              .size()
142              .reset_index(name="Count")
143          )
144          docs_diff = docs_diff.merge(docs_diff_with_count)
145          docs_diff.loc[docs_diff["Count"] > 1, "Key"] = docs_diff["Parent"]
</pre></code></div>
                <div class="column column_space"><pre><code>517              bitarray_new_value.set(0)
518          elif bitarray_new_value == self.get_bitstring(from_read=False):
519              error_msg = "\tThe same value for {} ".format(self.name)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    