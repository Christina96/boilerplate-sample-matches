<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_cp_1.py &amp; dns.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_cp_1.py &amp; dns.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_cp_1.py (2.8284671%)<th>dns.py (2.038133%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-20)<td><a href="#" name="0">(13-32)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(426-429)<td><a href="#" name="1">(579-586)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cp_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import shutil
4 import signal
5 import tempfile
6 import textwrap
7 import time
8 import uuid
9 import psutil  # pylint: disable=3rd-party-module-not-gated
10 import pytest
11 import salt.utils.files
12 import salt.utils.path
13 import salt.utils.platform
14 import salt.utils.stringutils
15 from saltfactories.utils.ports import get_unused_localhost_port
16 from saltfactories.utils.tempfiles import temp_file
17 from tests.support.case import ModuleCase
18 from</b></font> tests.support.helpers import with_tempfile
19 from tests.support.runtests import RUNTIME_VARS
20 from tests.support.unit import skipIf
21 log = logging.getLogger(__name__)
22 @pytest.mark.windows_whitelisted
23 class CPModuleTest(ModuleCase):
24     def run_function(self, *args, **kwargs):  # pylint: disable=arguments-differ
25         return salt.utils.data.decode(super().run_function(*args, **kwargs))
26     @with_tempfile()
27     @pytest.mark.slow_test
28     def test_get_file(self, tgt):
29         self.run_function("cp.get_file", ["salt://grail/scene33", tgt])
30         with salt.utils.files.fopen(tgt, "r") as scene:
31             data = salt.utils.stringutils.to_unicode(scene.read())
32         self.assertIn("KNIGHT:  They're nervous, sire.", data)
33         self.assertNotIn("bacon", data)
34     @pytest.mark.slow_test
35     def test_get_file_to_dir(self):
36         tgt = os.path.join(RUNTIME_VARS.TMP, "")
37         self.run_function("cp.get_file", ["salt://grail/scene33", tgt])
38         with salt.utils.files.fopen(tgt + "scene33", "r") as scene:
39             data = salt.utils.stringutils.to_unicode(scene.read())
40         self.assertIn("KNIGHT:  They're nervous, sire.", data)
41         self.assertNotIn("bacon", data)
42     @with_tempfile()
43     @skipIf(
44         salt.utils.platform.is_windows(),
45         "This test hangs on Windows on Py3",
46     )
47     def test_get_file_templated_paths(self, tgt):
48         self.run_function(
49             "cp.get_file",
50             [
51                 "salt://{{grains.test_grain}}",
52                 tgt.replace("cheese", "{{grains.test_grain}}"),
53             ],
54             template="jinja",
55         )
56         with salt.utils.files.fopen(tgt, "r") as cheese:
57             data = salt.utils.stringutils.to_unicode(cheese.read())
58         self.assertIn("Gromit", data)
59         self.assertNotIn("bacon", data)
60     @with_tempfile()
61     @pytest.mark.slow_test
62     def test_get_file_gzipped(self, tgt):
63         src = os.path.join(RUNTIME_VARS.FILES, "file", "base", "file.big")
64         with salt.utils.files.fopen(src, "rb") as fp_:
65             hash_str = hashlib.md5(fp_.read()).hexdigest()
66         self.run_function("cp.get_file", ["salt://file.big", tgt], gzip=5)
67         with salt.utils.files.fopen(tgt, "rb") as scene:
68             data = scene.read()
69         self.assertEqual(hash_str, hashlib.md5(data).hexdigest())
70         data = salt.utils.stringutils.to_unicode(data)
71         self.assertIn("KNIGHT:  They're nervous, sire.", data)
72         self.assertNotIn("bacon", data)
73     @pytest.mark.slow_test
74     def test_get_file_makedirs(self):
75         tgt = os.path.join(RUNTIME_VARS.TMP, "make", "dirs", "scene33")
76         self.run_function("cp.get_file", ["salt://grail/scene33", tgt], makedirs=True)
77         self.addCleanup(
78             shutil.rmtree, os.path.join(RUNTIME_VARS.TMP, "make"), ignore_errors=True
79         )
80         with salt.utils.files.fopen(tgt, "r") as scene:
81             data = salt.utils.stringutils.to_unicode(scene.read())
82         self.assertIn("KNIGHT:  They're nervous, sire.", data)
83         self.assertNotIn("bacon", data)
84     @with_tempfile()
85     @pytest.mark.slow_test
86     def test_get_template(self, tgt):
87         self.run_function(
88             "cp.get_template", ["salt://grail/scene33", tgt], spam="bacon"
89         )
90         with salt.utils.files.fopen(tgt, "r") as scene:
91             data = salt.utils.stringutils.to_unicode(scene.read())
92         self.assertIn("bacon", data)
93         self.assertNotIn("spam", data)
94     @pytest.mark.slow_test
95     def test_get_dir(self):
96         tgt = os.path.join(RUNTIME_VARS.TMP, "many")
97         self.run_function("cp.get_dir", ["salt://grail", tgt])
98         self.assertIn("grail", os.listdir(tgt))
99         self.assertIn("36", os.listdir(os.path.join(tgt, "grail")))
100         self.assertIn("empty", os.listdir(os.path.join(tgt, "grail")))
101         self.assertIn("scene", os.listdir(os.path.join(tgt, "grail", "36")))
102     @pytest.mark.slow_test
103     def test_get_dir_templated_paths(self):
104         tgt = os.path.join(RUNTIME_VARS.TMP, "many")
105         self.run_function(
106             "cp.get_dir",
107             ["salt://{{grains.script}}", tgt.replace("many", "{{grains.alot}}")],
108         )
109         self.assertIn("grail", os.listdir(tgt))
110         self.assertIn("36", os.listdir(os.path.join(tgt, "grail")))
111         self.assertIn("empty", os.listdir(os.path.join(tgt, "grail")))
112         self.assertIn("scene", os.listdir(os.path.join(tgt, "grail", "36")))
113     @with_tempfile()
114     @pytest.mark.slow_test
115     def test_get_url(self, tgt):
116         self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
117         with salt.utils.files.fopen(tgt, "r") as scene:
118             data = salt.utils.stringutils.to_unicode(scene.read())
119         self.assertIn("KNIGHT:  They're nervous, sire.", data)
120         self.assertNotIn("bacon", data)
121     @pytest.mark.slow_test
122     def test_get_url_makedirs(self):
123         tgt = os.path.join(RUNTIME_VARS.TMP, "make", "dirs", "scene33")
124         self.run_function("cp.get_url", ["salt://grail/scene33", tgt], makedirs=True)
125         self.addCleanup(
126             shutil.rmtree, os.path.join(RUNTIME_VARS.TMP, "make"), ignore_errors=True
127         )
128         with salt.utils.files.fopen(tgt, "r") as scene:
129             data = salt.utils.stringutils.to_unicode(scene.read())
130         self.assertIn("KNIGHT:  They're nervous, sire.", data)
131         self.assertNotIn("bacon", data)
132     @pytest.mark.slow_test
133     def test_get_url_dest_empty(self):
134         ret = self.run_function("cp.get_url", ["salt://grail/scene33"])
135         with salt.utils.files.fopen(ret, "r") as scene:
136             data = salt.utils.stringutils.to_unicode(scene.read())
137         self.assertIn("KNIGHT:  They're nervous, sire.", data)
138         self.assertNotIn("bacon", data)
139     @pytest.mark.slow_test
140     def test_get_url_no_dest(self):
141         tgt = None
142         ret = self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
143         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
144     @pytest.mark.slow_test
145     def test_get_url_nonexistent_source(self):
146         tgt = None
147         ret = self.run_function("cp.get_url", ["salt://grail/nonexistent_scene", tgt])
148         self.assertEqual(ret, False)
149     @pytest.mark.slow_test
150     def test_get_url_to_dir(self):
151         tgt = os.path.join(RUNTIME_VARS.TMP, "")
152         self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
153         with salt.utils.files.fopen(tgt + "scene33", "r") as scene:
154             data = salt.utils.stringutils.to_unicode(scene.read())
155         self.assertIn("KNIGHT:  They're nervous, sire.", data)
156         self.assertNotIn("bacon", data)
157     @with_tempfile()
158     @pytest.mark.slow_test
159     def test_get_url_https(self, tgt):
160         self.run_function("cp.get_url", ["https://repo.saltproject.io/index.html", tgt])
161         with salt.utils.files.fopen(tgt, "r") as instructions:
162             data = salt.utils.stringutils.to_unicode(instructions.read())
163         self.assertIn("Bootstrap", data)
164         self.assertIn("Debian", data)
165         self.assertIn("Windows", data)
166         self.assertNotIn("AYBABTU", data)
167     @pytest.mark.slow_test
168     def test_get_url_https_dest_empty(self):
169         ret = self.run_function(
170             "cp.get_url", ["https://repo.saltproject.io/index.html"]
171         )
172         with salt.utils.files.fopen(ret, "r") as instructions:
173             data = salt.utils.stringutils.to_unicode(instructions.read())
174         self.assertIn("Bootstrap", data)
175         self.assertIn("Debian", data)
176         self.assertIn("Windows", data)
177         self.assertNotIn("AYBABTU", data)
178     @pytest.mark.slow_test
179     def test_get_url_https_no_dest(self):
180         timeout = 500
181         start = time.time()
182         sleep = 5
183         tgt = None
184         while time.time() - start &lt;= timeout:
185             ret = self.run_function(
186                 "cp.get_url", ["https://repo.saltproject.io/index.html", tgt]
187             )
188             if ret.find("HTTP 599") == -1:
189                 break
190             time.sleep(sleep)
191         if ret.find("HTTP 599") != -1:
192             raise Exception("https://repo.saltproject.io/index.html returned 599 error")
193         self.assertIn("Bootstrap", ret)
194         self.assertIn("Debian", ret)
195         self.assertIn("Windows", ret)
196         self.assertNotIn("AYBABTU", ret)
197     @pytest.mark.slow_test
198     def test_get_url_file(self):
199         tgt = ""
200         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
201         ret = self.run_function("cp.get_url", [src, tgt])
202         with salt.utils.files.fopen(ret, "r") as scene:
203             data = salt.utils.stringutils.to_unicode(scene.read())
204         self.assertIn("KNIGHT:  They're nervous, sire.", data)
205         self.assertNotIn("bacon", data)
206     @pytest.mark.slow_test
207     def test_get_url_file_no_dest(self):
208         tgt = None
209         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
210         ret = self.run_function("cp.get_url", [src, tgt])
211         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
212         self.assertNotIn("bacon", ret)
213     @with_tempfile()
214     @pytest.mark.slow_test
215     def test_get_url_ftp(self, tgt):
216         self.run_function(
217             "cp.get_url",
218             [
219                 "ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/amd64/12.0-RELEASE/MANIFEST",
220                 tgt,
221             ],
222         )
223         with salt.utils.files.fopen(tgt, "r") as instructions:
224             data = salt.utils.stringutils.to_unicode(instructions.read())
225         self.assertIn("Base system", data)
226     @pytest.mark.slow_test
227     def test_get_file_str_salt(self):
228         src = "salt://grail/scene33"
229         ret = self.run_function("cp.get_file_str", [src])
230         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
231     @pytest.mark.slow_test
232     def test_get_file_str_nonexistent_source(self):
233         src = "salt://grail/nonexistent_scene"
234         ret = self.run_function("cp.get_file_str", [src])
235         self.assertEqual(ret, False)
236     @pytest.mark.slow_test
237     def test_get_file_str_https(self):
238         src = "https://repo.saltproject.io/index.html"
239         ret = self.run_function("cp.get_file_str", [src])
240         self.assertIn("Bootstrap", ret)
241         self.assertIn("Debian", ret)
242         self.assertIn("Windows", ret)
243         self.assertNotIn("AYBABTU", ret)
244     @pytest.mark.slow_test
245     def test_get_file_str_local(self):
246         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
247         ret = self.run_function("cp.get_file_str", [src])
248         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
249         self.assertNotIn("bacon", ret)
250     @pytest.mark.slow_test
251     def test_cache_file(self):
252         ret = self.run_function("cp.cache_file", ["salt://grail/scene33"])
253         with salt.utils.files.fopen(ret, "r") as scene:
254             data = salt.utils.stringutils.to_unicode(scene.read())
255         self.assertIn("KNIGHT:  They're nervous, sire.", data)
256         self.assertNotIn("bacon", data)
257     @pytest.mark.slow_test
258     def test_cache_files(self):
259         ret = self.run_function(
260             "cp.cache_files", [["salt://grail/scene33", "salt://grail/36/scene"]]
261         )
262         for path in ret:
263             with salt.utils.files.fopen(path, "r") as scene:
264                 data = salt.utils.stringutils.to_unicode(scene.read())
265             self.assertIn("ARTHUR:", data)
266             self.assertNotIn("bacon", data)
267     @with_tempfile()
268     @pytest.mark.slow_test
269     def test_cache_master(self, tgt):
270         ret = self.run_function(
271             "cp.cache_master",
272             [tgt],
273         )
274         for path in ret:
275             self.assertTrue(os.path.exists(path))
276     @pytest.mark.slow_test
277     def test_cache_local_file(self):
278         src = os.path.join(RUNTIME_VARS.TMP, "random")
279         with salt.utils.files.fopen(src, "w+") as fn_:
280             fn_.write(salt.utils.stringutils.to_str("foo"))
281         ret = self.run_function("cp.cache_local_file", [src])
282         with salt.utils.files.fopen(ret, "r") as cp_:
283             self.assertEqual(salt.utils.stringutils.to_unicode(cp_.read()), "foo")
284     @skipIf(not salt.utils.path.which("nginx"), "nginx not installed")
285     @pytest.mark.slow_test
286     @pytest.mark.skip_if_not_root
287     def test_cache_remote_file(self):
288         cp.cache_file
289         """
290         nginx_port = get_unused_localhost_port<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>()
291         url_prefix = "http://localhost:{}/".format(nginx_port)
292         temp_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
293         self.addCleanup(shutil.</b></font>rmtree, temp_dir, ignore_errors=True)
294         nginx_root_dir = os.path.join(temp_dir, "root")
295         nginx_conf_dir = os.path.join(temp_dir, "conf")
296         nginx_conf = os.path.join(nginx_conf_dir, "nginx.conf")
297         nginx_pidfile = os.path.join(nginx_conf_dir, "nginx.pid")
298         file_contents = "Hello world!"
299         for dirname in (nginx_root_dir, nginx_conf_dir):
300             os.makedirs(dirname)
301         with salt.utils.files.fopen(
302             os.path.join(nginx_root_dir, "actual_file"), "w"
303         ) as fp_:
304             fp_.write(salt.utils.stringutils.to_str(file_contents))
305         with salt.utils.files.fopen(nginx_conf, "w") as fp_:
306             fp_.write(
307                 textwrap.dedent(
308                     salt.utils.stringutils.to_str(
309                         """\
310                 user root;
311                 worker_processes 1;
312                 error_log {nginx_conf_dir}/server_error.log;
313                 pid {nginx_pidfile};
314                 events {{
315                     worker_connections 1024;
316                 }}
317                 http {{
318                     include       /etc/nginx/mime.types;
319                     default_type  application/octet-stream;
320                     access_log {nginx_conf_dir}/access.log;
321                     error_log {nginx_conf_dir}/error.log;
322                     server {{
323                         listen {nginx_port} default_server;
324                         server_name cachefile.local;
325                         root {nginx_root_dir};
326                         location ~ ^/301$ {{
327                             return 301 /actual_file;
328                         }}
329                         location ~ ^/302$ {{
330                             return 302 /actual_file;
331                         }}
332                     }}
333                 }}""".format(
334                             **locals()
335                         )
336                     )
337                 )
338             )
339         self.run_function("cmd.run", [["nginx", "-c", nginx_conf]], python_shell=False)
340         with salt.utils.files.fopen(nginx_pidfile) as fp_:
341             nginx_pid = int(fp_.read().strip())
342             nginx_proc = psutil.Process(pid=nginx_pid)
343             self.addCleanup(nginx_proc.send_signal, signal.SIGQUIT)
344         for code in ("", "301", "302"):
345             url = url_prefix + (code or "actual_file")
346             log.debug("attempting to cache %s", url)
347             ret = self.run_function("cp.cache_file", [url])
348             self.assertTrue(ret)
349             with salt.utils.files.fopen(ret) as fp_:
350                 cached_contents = salt.utils.stringutils.to_unicode(fp_.read())
351                 self.assertEqual(cached_contents, file_contents)
352     @pytest.mark.slow_test
353     def test_list_states(self):
354         """
355         cp.list_states
356         """
357         top_sls = """
358         base:
359           '*':
360             - core
361             """
362         core_state = """
363         {}/testfile:
364           file:
365             - managed
366             - source: salt://testfile
367             - makedirs: true
368             """.format(
369             RUNTIME_VARS.TMP
370         )
371         with temp_file(
372             "top.sls", top_sls, RUNTIME_VARS.TMP_BASEENV_STATE_TREE
373         ), temp_file("core.sls", core_state, RUNTIME_VARS.TMP_BASEENV_STATE_TREE):
374             ret = self.run_function(
375                 "cp.list_states",
376             )
377             self.assertIn("core", ret)
378             self.assertIn("top", ret)
379     @pytest.mark.slow_test
380     def test_list_minion(self):
381         """
382         cp.list_minion
383         """
384         self.run_function("cp.cache_file", ["salt://grail/scene33"])
385         ret = self.run_function("cp.list_minion")
386         found = False
387         search = "grail/scene33"
388         if salt.utils.platform.is_windows():
389             search = r"grail\scene33"
390         for path in ret:
391             if search in path:
392                 found = True
393                 break
394         self.assertTrue(found)
395     @pytest.mark.slow_test
396     def test_is_cached(self):
397         """
398         cp.is_cached
399         """
400         self.run_function("cp.cache_file", ["salt://grail/scene33"])
401         ret1 = self.run_function("cp.is_cached", ["salt://grail/scene33"])
402         self.assertTrue(ret1)
403         ret2 = self.run_function("cp.is_cached", ["salt://fasldkgj/poicxzbn"])
404         self.assertFalse(ret2)
405     @pytest.mark.slow_test
406     def test_hash_file(self):
407         """
408         cp.hash_file
409         """
410         sha256_hash = self.run_function("cp.hash_file", ["salt://grail/scene33"])
411         path = self.run_function("cp.cache_file", ["salt://grail/scene33"])
412         with salt.utils.files.fopen(path, "rb") as fn_:
413             data = fn_.read()
414             self.assertEqual(sha256_hash["hsum"], hashlib.sha256(data).hexdigest())
415     @with_tempfile()
416     @pytest.mark.slow_test
417     def test_get_file_from_env_predefined(self, tgt):
418         """
419         cp.get_file
420         """
421         tgt = os.path.join(RUNTIME_VARS.TMP, "cheese")
422         try:
423             self.run_function("cp.get_file", ["salt://cheese", tgt])
424             with salt.utils.files.fopen(tgt, "r") as cheese:
425                 data = salt.utils.stringutils.to_unicode(cheese.read())
426             self.assertIn("Gromit", data)
427             self.assertNotIn("Comte", data)
428         finally:
429             os.unlink(tgt)
430     @with_tempfile()
431     @pytest.mark.slow_test
432     def test_get_file_from_env_in_url(self, tgt):
433         tgt = os.path.join(RUNTIME_VARS.TMP, "cheese")
434         try:
435             self.run_function("cp.get_file", ["salt://cheese?saltenv=prod", tgt])
436             with salt.utils.files.fopen(tgt, "r") as cheese:
437                 data = salt.utils.stringutils.to_unicode(cheese.read())
438             self.assertIn("Gromit", data)
439             self.assertIn("Comte", data)
440         finally:
441             os.unlink(tgt)
442     @pytest.mark.slow_test
443     def test_push(self):
444         log_to_xfer = os.path.join(RUNTIME_VARS.TMP, uuid.uuid4().hex)
445         open(log_to_xfer, "w").close()  # pylint: disable=resource-leakage
446         try:
447             self.run_function("cp.push", [log_to_xfer])
448             tgt_cache_file = os.path.join(
449                 RUNTIME_VARS.TMP,
450                 "master-minion-root",
451                 "cache",
452                 "minions",
453                 "minion",
454                 "files",
455                 RUNTIME_VARS.TMP,
456                 log_to_xfer,
457             )
458             self.assertTrue(
459                 os.path.isfile(tgt_cache_file), "File was not cached on the master"
460             )
461         finally:
462             os.unlink(tgt_cache_file)
463     @pytest.mark.slow_test
464     def test_envs(self):
465         self.assertEqual(sorted(self.run_function("cp.envs")), sorted(["base", "prod"]))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Compendium of generic DNS utilities
3 dns.lookup(name, rdtype, ...)
4 dns.query(name, rdtype, ...)
5 dns.srv_rec(data)
6 dns.srv_data('my1.example.com', 389, prio=10, weight=100)
7 dns.srv_name('ldap/tcp', 'example.com')
8 """
9 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
10 import binascii
11 import functools
12 import hashlib
13 import itertools
14 import logging
15 import random
16 import re
17 import shlex
18 import socket
19 import ssl
20 import string
21 import salt.modules.cmdmod
22 import salt.utils.files
23 import salt.utils.network
24 import salt.utils.path
25 import salt.utils.stringutils
26 from salt._compat import ipaddress
27 from</b></font> salt.utils.odict import OrderedDict
28 try:
29     import dns.resolver
30     HAS_DNSPYTHON = True
31 except ImportError:
32     HAS_DNSPYTHON = False
33 try:
34     import tldextract
35     HAS_TLDEXTRACT = True
36 except ImportError:
37     HAS_TLDEXTRACT = False
38 HAS_DIG = salt.utils.path.which("dig") is not None
39 DIG_OPTIONS = "+search +fail +noall +answer +nocl +nottl"
40 HAS_DRILL = salt.utils.path.which("drill") is not None
41 HAS_HOST = salt.utils.path.which("host") is not None
42 HAS_NSLOOKUP = salt.utils.path.which("nslookup") is not None
43 __salt__ = {"cmd.run_all": salt.modules.cmdmod.run_all}
44 log = logging.getLogger(__name__)
45 class RFC:
46     """
47     Simple holding class for all RFC/IANA registered lists &amp; standards
48     """
49     CAA_TAGS = ("issue", "issuewild", "iodef")
50     SSHFP_ALGO = OrderedDict(
51         (
52             (1, "rsa"),
53             (2, "dsa"),
54             (3, "ecdsa"),
55             (4, "ed25519"),
56         )
57     )
58     SSHFP_HASH = OrderedDict(
59         (
60             (1, "sha1"),
61             (2, "sha256"),
62         )
63     )
64     TLSA_USAGE = OrderedDict(
65         (
66             (0, "pkixta"),
67             (1, "pkixee"),
68             (2, "daneta"),
69             (3, "daneee"),
70         )
71     )
72     TLSA_SELECT = OrderedDict(
73         (
74             (0, "cert"),
75             (1, "spki"),
76         )
77     )
78     TLSA_MATCHING = OrderedDict(
79         (
80             (0, "full"),
81             (1, "sha256"),
82             (2, "sha512"),
83         )
84     )
85     SRV_PROTO = ("tcp", "udp", "sctp")
86     @staticmethod
87     def validate(lookup, ref, match=None):
88         if lookup in ref:
89             return lookup
90         elif match == "in":
91             return [code for code, name in ref.items() if lookup in name][-1]
92         else:
93             return {name: code for code, name in ref.items()}[lookup]
94 def _to_port(port):
95     try:
96         port = int(port)
97         assert 1 &lt;= port &lt;= 65535
98         return port
99     except (ValueError, AssertionError):
100         raise ValueError("Invalid port {}".format(port))
101 def _tree(domain, tld=False):
102     """
103     Split out a domain in its parents
104     Leverages tldextract to take the TLDs from publicsuffix.org
105     or makes a valiant approximation of that
106     :param domain: dc2.ams2.example.com
107     :param tld: Include TLD in list
108     :return: [ 'dc2.ams2.example.com', 'ams2.example.com', 'example.com']
109     """
110     domain = domain.rstrip(".")
111     assert "." in domain, "Provide a decent domain"
112     if not tld:
113         if HAS_TLDEXTRACT:
114             tld = tldextract.extract(domain).suffix
115         else:
116             tld = re.search(
117                 r"((?:(?:ac|biz|com?|info|edu|gov|mil|name|net|n[oi]m|org)\.)?[^.]+)$",
118                 domain,
119             ).group()
120             log.info(
121                 "Without tldextract, dns.util resolves the TLD of %s to %s", domain, tld
122             )
123     res = [domain]
124     while True:
125         idx = domain.find(".")
126         if idx &lt; 0:
127             break
128         domain = domain[idx + 1 :]
129         if domain == tld:
130             break
131         res.append(domain)
132     return res
133 def _weighted_order(recs):
134     res = []
135     weights = [rec["weight"] for rec in recs]
136     while weights:
137         rnd = random.random() * sum(weights)
138         for i, w in enumerate(weights):
139             rnd -= w
140             if rnd &lt; 0:
141                 res.append(recs.pop(i)["name"])
142                 weights.pop(i)
143                 break
144     return res
145 def _cast(rec_data, rec_cast):
146     if isinstance(rec_cast, dict):
147         rec_data = type(next(iter(rec_cast.keys())))(rec_data)
148         res = rec_cast[rec_data]
149         return res
150     elif isinstance(rec_cast, (list, tuple)):
151         return RFC.validate(rec_data, rec_cast)
152     else:
153         return rec_cast(rec_data)
154 def _data2rec(schema, rec_data):
155     """
156     schema = OrderedDict({
157         'prio': int,
158         'weight': int,
159         'port': to_port,
160         'name': str,
161     })
162     rec_data = '10 20 25 myawesome.nl'
163     res = {'prio': 10, 'weight': 20, 'port': 25 'name': 'myawesome.nl'}
164     """
165     try:
166         rec_fields = rec_data.split(" ")
167         assert len(rec_fields) &gt;= len(schema)
168         if len(rec_fields) &gt; len(schema):
169             cutoff = len(schema) - 1
170             rec_fields = rec_fields[0:cutoff] + ["".join(rec_fields[cutoff:])]
171         if len(schema) == 1:
172             res = _cast(rec_fields[0], next(iter(schema.values())))
173         else:
174             res = {
175                 field_name: _cast(rec_field, rec_cast)
176                 for (field_name, rec_cast), rec_field in zip(schema.items(), rec_fields)
177             }
178         return res
179     except (AssertionError, AttributeError, TypeError, ValueError) as e:
180         raise ValueError(
181             'Unable to cast "{0}" as "{2}": {1}'.format(
182                 rec_data, e, " ".join(schema.keys())
183             )
184         )
185 def _data2rec_group(schema, recs_data, group_key):
186     if not isinstance(recs_data, (list, tuple)):
187         recs_data = [recs_data]
188     res = OrderedDict()
189     try:
190         for rdata in recs_data:
191             rdata = _data2rec(schema, rdata)
192             assert rdata and group_key in rdata
193             idx = rdata.pop(group_key)
194             if idx not in res:
195                 res[idx] = []
196             if len(rdata) == 1:
197                 rdata = next(iter(rdata.values()))
198             res[idx].append(rdata)
199         return res
200     except (AssertionError, ValueError) as e:
201         raise ValueError(
202             'Unable to cast "{}" as a group of "{}": {}'.format(
203                 ",".join(recs_data), " ".join(schema.keys()), e
204             )
205         )
206 def _rec2data(*rdata):
207     return " ".join(rdata)
208 def _data_clean(data):
209     data = data.strip(string.whitespace)
210     if data.startswith(('"', "'")) and data.endswith(('"', "'")):
211         return data[1:-1]
212     else:
213         return data
214 def _lookup_dig(name, rdtype, timeout=None, servers=None, secure=None):
215     """
216     Use dig to lookup addresses
217     :param name: Name of record to search
218     :param rdtype: DNS record type
219     :param timeout: server response timeout
220     :param servers: [] of servers to use
221     :return: [] of records or False if error
222     """
223     cmd = "dig {} -t {} ".format(DIG_OPTIONS, rdtype)
224     if servers:
225         cmd += "".join(["@{} ".format(srv) for srv in servers])
226     if timeout is not None:
227         if servers:
228             timeout = int(float(timeout) / len(servers))
229         else:
230             timeout = int(timeout)
231         cmd += "+time={} ".format(timeout)
232     if secure:
233         cmd += "+dnssec +adflag "
234     cmd = __salt__["cmd.run_all"](
235         "{} {}".format(cmd, name), python_shell=False, output_loglevel="quiet"
236     )
237     if "ignoring invalid type" in cmd["stderr"]:
238         raise ValueError("Invalid DNS type {}".format(rdtype))
239     elif cmd["retcode"] != 0:
240         log.warning(
241             "dig returned (%s): %s",
242             cmd["retcode"],
243             cmd["stderr"].strip(string.whitespace + ";"),
244         )
245         return False
246     elif not cmd["stdout"]:
247         return []
248     validated = False
249     res = []
250     for line in cmd["stdout"].splitlines():
251         _, rtype, rdata = line.split(None, 2)
252         if rtype == "CNAME" and rdtype != "CNAME":
253             continue
254         elif rtype == "RRSIG":
255             validated = True
256             continue
257         res.append(_data_clean(rdata))
258     if res and secure and not validated:
259         return False
260     else:
261         return res
262 def _lookup_drill(name, rdtype, timeout=None, servers=None, secure=None):
263     """
264     Use drill to lookup addresses
265     :param name: Name of record to search
266     :param rdtype: DNS record type
267     :param timeout: command return timeout
268     :param servers: [] of servers to use
269     :return: [] of records or False if error
270     """
271     cmd = "drill "
272     if secure:
273         cmd += "-D -o ad "
274     cmd += "{} {} ".format(rdtype, name)
275     if servers:
276         cmd += "".join(["@{} ".format(srv) for srv in servers])
277     cmd = __salt__["cmd.run_all"](
278         cmd, timeout=timeout, python_shell=False, output_loglevel="quiet"
279     )
280     if cmd["retcode"] != 0:
281         log.warning("drill returned (%s): %s", cmd["retcode"], cmd["stderr"])
282         return False
283     lookup_res = iter(cmd["stdout"].splitlines())
284     validated = False
285     res = []
286     try:
287         line = ""
288         while "ANSWER SECTION" not in line:
289             line = next(lookup_res)
290         while True:
291             line = next(lookup_res)
292             line = line.strip()
293             if not line or line.startswith(";;"):
294                 break
295             l_type, l_rec = line.split(None, 4)[-2:]
296             if l_type == "CNAME" and rdtype != "CNAME":
297                 continue
298             elif l_type == "RRSIG":
299                 validated = True
300                 continue
301             elif l_type != rdtype:
302                 raise ValueError("Invalid DNS type {}".format(rdtype))
303             res.append(_data_clean(l_rec))
304     except StopIteration:
305         pass
306     if res and secure and not validated:
307         return False
308     else:
309         return res
310 def _lookup_gai(name, rdtype, timeout=None):
311     """
312     Use Python's socket interface to lookup addresses
313     :param name: Name of record to search
314     :param rdtype: A or AAAA
315     :param timeout: ignored
316     :return: [] of addresses or False if error
317     """
318     try:
319         sock_t = {"A": socket.AF_INET, "AAAA": socket.AF_INET6}[rdtype]
320     except KeyError:
321         raise ValueError("Invalid DNS type {} for gai lookup".format(rdtype))
322     if timeout:
323         log.info("Ignoring timeout on gai resolver; fix resolv.conf to do that")
324     try:
325         addresses = [
326             sock[4][0]
327             for sock in socket.getaddrinfo(name, None, sock_t, 0, socket.SOCK_RAW)
328         ]
329         return addresses
330     except socket.gaierror:
331         return False
332 def _lookup_host(name, rdtype, timeout=None, server=None):
333     """
334     Use host to lookup addresses
335     :param name: Name of record to search
336     :param server: Server to query
337     :param rdtype: DNS record type
338     :param timeout: server response wait
339     :return: [] of records or False if error
340     """
341     cmd = "host -t {} ".format(rdtype)
342     if timeout:
343         cmd += "-W {} ".format(int(timeout))
344     cmd += name
345     if server is not None:
346         cmd += " {}".format(server)
347     cmd = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="quiet")
348     if "invalid type" in cmd["stderr"]:
349         raise ValueError("Invalid DNS type {}".format(rdtype))
350     elif cmd["retcode"] != 0:
351         log.warning("host returned (%s): %s", cmd["retcode"], cmd["stderr"])
352         return False
353     elif "has no" in cmd["stdout"]:
354         return []
355     res = []
356     _stdout = cmd["stdout"] if server is None else cmd["stdout"].split("\n\n")[-1]
357     for line in _stdout.splitlines():
358         if rdtype != "CNAME" and "is an alias" in line:
359             continue
360         line = line.split(" ", 3)[-1]
361         for prefix in ("record", "address", "handled by", "alias for"):
362             if line.startswith(prefix):
363                 line = line[len(prefix) + 1 :]
364                 break
365         res.append(_data_clean(line))
366     return res
367 def _lookup_dnspython(name, rdtype, timeout=None, servers=None, secure=None):
368     """
369     Use dnspython to lookup addresses
370     :param name: Name of record to search
371     :param rdtype: DNS record type
372     :param timeout: query timeout
373     :param server: [] of server(s) to try in order
374     :return: [] of records or False if error
375     """
376     resolver = dns.resolver.Resolver()
377     if timeout is not None:
378         resolver.lifetime = float(timeout)
379     if servers:
380         resolver.nameservers = servers
381     if secure:
382         resolver.ednsflags += dns.flags.DO
383     try:
384         res = [
385             _data_clean(rr.to_text())
386             for rr in resolver.query(name, rdtype, raise_on_no_answer=False)
387         ]
388         return res
389     except dns.rdatatype.UnknownRdatatype:
390         raise ValueError("Invalid DNS type {}".format(rdtype))
391     except (
392         dns.resolver.NXDOMAIN,
393         dns.resolver.YXDOMAIN,
394         dns.resolver.NoNameservers,
395         dns.exception.Timeout,
396     ):
397         return False
398 def _lookup_nslookup(name, rdtype, timeout=None, server=None):
399     """
400     Use nslookup to lookup addresses
401     :param name: Name of record to search
402     :param rdtype: DNS record type
403     :param timeout: server response timeout
404     :param server: server to query
405     :return: [] of records or False if error
406     """
407     cmd = "nslookup -query={} {}".format(rdtype, name)
408     if timeout is not None:
409         cmd += " -timeout={}".format(int(timeout))
410     if server is not None:
411         cmd += " {}".format(server)
412     cmd = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="quiet")
413     if cmd["retcode"] != 0:
414         log.warning(
415             "nslookup returned (%s): %s",
416             cmd["retcode"],
417             cmd["stdout"].splitlines()[-1].strip(string.whitespace + ";"),
418         )
419         return False
420     lookup_res = iter(cmd["stdout"].splitlines())
421     res = []
422     try:
423         line = next(lookup_res)
424         if "unknown query type" in line:
425             raise ValueError("Invalid DNS type {}".format(rdtype))
426         while True:
427             if name in line:
428                 break
429             line = next(lookup_res)
430         while True:
431             line = line.strip()
432             if not line or line.startswith("*"):
433                 break
434             elif rdtype != "CNAME" and "canonical name" in line:
435                 name = line.split()[-1][:-1]
436                 line = next(lookup_res)
437                 continue
438             elif rdtype == "SOA":
439                 line = line.split("=")
440             elif line.startswith("Name:"):
441                 line = next(lookup_res)
442                 line = line.split(":", 1)
443             elif line.startswith(name):
444                 if "=" in line:
445                     line = line.split("=", 1)
446                 else:
447                     line = line.split(" ")
448             res.append(_data_clean(line[-1]))
449             line = next(lookup_res)
450     except StopIteration:
451         pass
452     if rdtype == "SOA":
453         return [" ".join(res[1:])]
454     else:
455         return res
456 def lookup(
457     name,
458     rdtype,
459     method=None,
460     servers=None,
461     timeout=None,
462     walk=False,
463     walk_tld=False,
464     secure=None,
465 ):
466     """
467     Lookup DNS records and return their data
468     :param name: name to lookup
469     :param rdtype: DNS record type
470     :param method: gai (getaddrinfo()), dnspython, dig, drill, host, nslookup or auto (default)
471     :param servers: (list of) server(s) to try in-order
472     :param timeout: query timeout or a valiant approximation of that
473     :param walk: Walk the DNS upwards looking for the record type or name/recordtype if walk='name'.
474     :param walk_tld: Include the final domain in the walk
475     :param secure: return only DNSSEC secured responses
476     :return: [] of record data
477     """
478     method = method or opts.get("method", "auto")
479     secure = secure or opts.get("secure", None)
480     servers = servers or opts.get<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("servers", None)
481     timeout = timeout or opts.get("timeout", False)
482     rdtype = rdtype.upper()
483     query_methods = (
484         ("gai", _lookup_gai, not any((rdtype</b></font> not in ("A", "AAAA"), servers, secure))),
485         ("dnspython", _lookup_dnspython, HAS_DNSPYTHON),
486         ("dig", _lookup_dig, HAS_DIG),
487         ("drill", _lookup_drill, HAS_DRILL),
488         ("host", _lookup_host, HAS_HOST and not secure),
489         ("nslookup", _lookup_nslookup, HAS_NSLOOKUP and not secure),
490     )
491     try:
492         if method == "auto":
493             method, resolver = next(
494                 ((rname, rcb) for rname, rcb, rtest in query_methods if rtest)
495             )
496         else:
497             resolver = next(
498                 (
499                     rcb
500                     for rname, rcb, rtest in query_methods
501                     if rname == method and rtest
502                 )
503             )
504     except StopIteration:
505         log.error(
506             "Unable to lookup %s/%s: Resolver method %s invalid, unsupported "
507             "or unable to perform query",
508             method,
509             rdtype,
510             name,
511         )
512         return False
513     res_kwargs = {
514         "rdtype": rdtype,
515     }
516     if servers:
517         if not isinstance(servers, (list, tuple)):
518             servers = [servers]
519         if method in ("dnspython", "dig", "drill"):
520             res_kwargs["servers"] = servers
521         else:
522             if timeout:
523                 timeout /= len(servers)
524             def _multi_srvr(resolv_func):
525                 @functools.wraps(resolv_func)
526                 def _wrapper(**res_kwargs):
527                     for server in servers:
528                         s_res = resolv_func(server=server, **res_kwargs)
529                         if s_res:
530                             return s_res
531                 return _wrapper
532             resolver = _multi_srvr(resolver)
533     if not walk:
534         name = [name]
535     else:
536         idx = 0
537         if rdtype in ("SRV", "TLSA"):  # The only RRs I know that have 2 name components
538             idx = name.find(".") + 1
539         idx = name.find(".", idx) + 1
540         domain = name[idx:]
541         rname = name[0:idx]
542         name = _tree(domain, walk_tld)
543         if walk == "name":
544             name = [rname + domain for domain in name]
545         if timeout:
546             timeout /= len(name)
547     if secure:
548         res_kwargs["secure"] = secure
549     if timeout:
550         res_kwargs["timeout"] = timeout
551     for rname in name:
552         res = resolver(name=rname, **res_kwargs)
553         if res:
554             return res
555     return res
556 def query(
557     name,
558     rdtype,
559     method=None,
560     servers=None,
561     timeout=None,
562     walk=False,
563     walk_tld=False,
564     secure=None,
565 ):
566     """
567     Query DNS for information.
568     Where `lookup()` returns record data, `query()` tries to interpret the data and return its results
569     :param name: name to lookup
570     :param rdtype: DNS record type
571     :param method: gai (getaddrinfo()), pydns, dig, drill, host, nslookup or auto (default)
572     :param servers: (list of) server(s) to try in-order
573     :param timeout: query timeout or a valiant approximation of that
574     :param secure: return only DNSSEC secured response
575     :param walk: Walk the DNS upwards looking for the record type or name/recordtype if walk='name'.
576     :param walk_tld: Include the top-level domain in the walk
577     :return: [] of records
578     """
579     rdtype = rdtype.upper()
580     qargs = {
581         "method": method,
582         "servers": servers,
583         "timeout": timeout,
584         "walk": walk,
585         "walk_tld": walk_tld,
586         "secure": secure,
587     }
588     if rdtype == "PTR" and not name.endswith("arpa"):
589         name = ptr_name(name)
590     if rdtype == "SPF":
591         qres = [
592             answer
593             for answer in lookup(name, "TXT", **qargs)
594             if answer.startswith("v=spf")
595         ]
596         if not qres:
597             qres = lookup(name, rdtype, **qargs)
598     else:
599         qres = lookup(name, rdtype, **qargs)
600     rec_map = {
601         "A": a_rec,
602         "AAAA": aaaa_rec,
603         "CAA": caa_rec,
604         "MX": mx_rec,
605         "SOA": soa_rec,
606         "SPF": spf_rec,
607         "SRV": srv_rec,
608         "SSHFP": sshfp_rec,
609         "TLSA": tlsa_rec,
610     }
611     if not qres or rdtype not in rec_map:
612         return qres
613     elif rdtype in ("A", "AAAA", "SSHFP", "TLSA"):
614         res = [rec_map[rdtype](res) for res in qres]
615     elif rdtype in ("SOA", "SPF"):
616         res = rec_map[rdtype](qres[0])
617     else:
618         res = rec_map[rdtype](qres)
619     return res
620 def host(name, ip4=True, ip6=True, **kwargs):
621     """
622     Return a list of addresses for name
623     ip6:
624         Return IPv6 addresses
625     ip4:
626         Return IPv4 addresses
627     the rest is passed on to lookup()
628     """
629     res = {}
630     if ip6:
631         ip6 = lookup(name, "AAAA", **kwargs)
632         if ip6:
633             res["ip6"] = ip6
634     if ip4:
635         ip4 = lookup(name, "A", **kwargs)
636         if ip4:
637             res["ip4"] = ip4
638     return res
639 def a_rec(rdata):
640     """
641     Validate and parse DNS record data for an A record
642     :param rdata: DNS record data
643     :return: { 'address': ip }
644     """
645     rschema = OrderedDict((("address", ipaddress.IPv4Address),))
646     return _data2rec(rschema, rdata)
647 def aaaa_rec(rdata):
648     """
649     Validate and parse DNS record data for an AAAA record
650     :param rdata: DNS record data
651     :return: { 'address': ip }
652     """
653     rschema = OrderedDict((("address", ipaddress.IPv6Address),))
654     return _data2rec(rschema, rdata)
655 def caa_rec(rdatas):
656     """
657     Validate and parse DNS record data for a CAA record
658     :param rdata: DNS record data
659     :return: dict w/fields
660     """
661     rschema = OrderedDict(
662         (
663             ("flags", lambda flag: ["critical"] if int(flag) &gt; 0 else []),
664             ("tag", RFC.CAA_TAGS),
665             ("value", lambda val: val.strip("',\"")),
666         )
667     )
668     res = _data2rec_group(rschema, rdatas, "tag")
669     for tag in ("issue", "issuewild"):
670         tag_res = res.get(tag, False)
671         if not tag_res:
672             continue
673         for idx, val in enumerate(tag_res):
674             if ";" not in val:
675                 continue
676             val, params = val.split(";", 1)
677             params = dict(param.split("=") for param in shlex.split(params))
678             tag_res[idx] = {val: params}
679     return res
680 def mx_data(target, preference=10):
681     """
682     Generate MX record data
683     :param target: server
684     :param preference: preference number
685     :return: DNS record data
686     """
687     return _rec2data(int(preference), target)
688 def mx_rec(rdatas):
689     """
690     Validate and parse DNS record data for MX record(s)
691     :param rdata: DNS record data
692     :return: dict w/fields
693     """
694     rschema = OrderedDict(
695         (
696             ("preference", int),
697             ("name", str),
698         )
699     )
700     return _data2rec_group(rschema, rdatas, "preference")
701 def ptr_name(rdata):
702     """
703     Return PTR name of given IP
704     :param rdata: IP address
705     :return: PTR record name
706     """
707     try:
708         return ipaddress.ip_address(rdata).reverse_pointer
709     except ValueError:
710         log.error("Unable to generate PTR record; %s is not a valid IP address", rdata)
711         return False
712 def soa_rec(rdata):
713     """
714     Validate and parse DNS record data for SOA record(s)
715     :param rdata: DNS record data
716     :return: dict w/fields
717     """
718     rschema = OrderedDict(
719         (
720             ("mname", str),
721             ("rname", str),
722             ("serial", int),
723             ("refresh", int),
724             ("retry", int),
725             ("expire", int),
726             ("minimum", int),
727         )
728     )
729     return _data2rec(rschema, rdata)
730 def spf_rec(rdata):
731     """
732     Validate and parse DNS record data for SPF record(s)
733     :param rdata: DNS record data
734     :return: dict w/fields
735     """
736     spf_fields = rdata.split(" ")
737     if not spf_fields.pop(0).startswith("v=spf"):
738         raise ValueError("Not an SPF record")
739     res = OrderedDict()
740     mods = set()
741     for mech_spec in spf_fields:
742         if mech_spec.startswith(("exp", "redirect")):
743             mod, val = mech_spec.split("=", 1)
744             if mod in mods:
745                 raise KeyError("Modifier {} can only appear once".format(mod))
746             mods.add(mod)
747             continue
748         mech = {}
749         if mech_spec[0] in ("+", "-", "~", "?"):
750             mech["qualifier"] = mech_spec[0]
751             mech_spec = mech_spec[1:]
752         if ":" in mech_spec:
753             mech_spec, val = mech_spec.split(":", 1)
754         elif "/" in mech_spec:
755             idx = mech_spec.find("/")
756             mech_spec = mech_spec[0:idx]
757             val = mech_spec[idx:]
758         else:
759             val = None
760         res[mech_spec] = mech
761         if not val:
762             continue
763         elif mech_spec in ("ip4", "ip6"):
764             val = ipaddress.ip_interface(val)
765             assert val.version == int(mech_spec[-1])
766         mech["value"] = val
767     return res
768 def srv_data(target, port, prio=10, weight=10):
769     """
770     Generate SRV record data
771     :param target:
772     :param port:
773     :param prio:
774     :param weight:
775     :return:
776     """
777     return _rec2data(prio, weight, port, target)
778 def srv_name(svc, proto="tcp", domain=None):
779     """
780     Generate SRV record name
781     :param svc: ldap, 389 etc
782     :param proto: tcp, udp, sctp etc.
783     :param domain: name to append
784     :return:
785     """
786     proto = RFC.validate(proto, RFC.SRV_PROTO)
787     if isinstance(svc, int) or svc.isdigit():
788         svc = _to_port(svc)
789     if domain:
790         domain = "." + domain
791     return "_{}._{}{}".format(svc, proto, domain)
792 def srv_rec(rdatas):
793     """
794     Validate and parse DNS record data for SRV record(s)
795     :param rdata: DNS record data
796     :return: dict w/fields
797     """
798     rschema = OrderedDict(
799         (
800             ("prio", int),
801             ("weight", int),
802             ("port", _to_port),
803             ("name", str),
804         )
805     )
806     return _data2rec_group(rschema, rdatas, "prio")
807 def sshfp_data(key_t, hash_t, pub):
808     """
809     Generate an SSHFP record
810     :param key_t: rsa/dsa/ecdsa/ed25519
811     :param hash_t: sha1/sha256
812     :param pub: the SSH public key
813     """
814     key_t = RFC.validate(key_t, RFC.SSHFP_ALGO, "in")
815     hash_t = RFC.validate(hash_t, RFC.SSHFP_HASH)
816     hasher = hashlib.new(hash_t)
817     hasher.update(base64.b64decode(pub))
818     ssh_fp = hasher.hexdigest()
819     return _rec2data(key_t, hash_t, ssh_fp)
820 def sshfp_rec(rdata):
821     """
822     Validate and parse DNS record data for TLSA record(s)
823     :param rdata: DNS record data
824     :return: dict w/fields
825     """
826     rschema = OrderedDict(
827         (
828             ("algorithm", RFC.SSHFP_ALGO),
829             ("fp_hash", RFC.SSHFP_HASH),
830             (
831                 "fingerprint",
832                 lambda val: val.lower(),
833             ),  # resolvers are inconsistent on this one
834         )
835     )
836     return _data2rec(rschema, rdata)
837 def tlsa_data(pub, usage, selector, matching):
838     """
839     Generate a TLSA rec
840     :param pub: Pub key in PEM format
841     :param usage:
842     :param selector:
843     :param matching:
844     :return: TLSA data portion
845     """
846     usage = RFC.validate(usage, RFC.TLSA_USAGE)
847     selector = RFC.validate(selector, RFC.TLSA_SELECT)
848     matching = RFC.validate(matching, RFC.TLSA_MATCHING)
849     pub = ssl.PEM_cert_to_DER_cert(pub.strip())
850     if matching == 0:
851         cert_fp = binascii.b2a_hex(pub)
852     else:
853         hasher = hashlib.new(RFC.TLSA_MATCHING[matching])
854         hasher.update(pub)
855         cert_fp = hasher.hexdigest()
856     return _rec2data(usage, selector, matching, cert_fp)
857 def tlsa_rec(rdata):
858     """
859     Validate and parse DNS record data for TLSA record(s)
860     :param rdata: DNS record data
861     :return: dict w/fields
862     """
863     rschema = OrderedDict(
864         (
865             ("usage", RFC.TLSA_USAGE),
866             ("selector", RFC.TLSA_SELECT),
867             ("matching", RFC.TLSA_MATCHING),
868             ("pub", str),
869         )
870     )
871     return _data2rec(rschema, rdata)
872 def service(svc, proto="tcp", domain=None, walk=False, secure=None):
873     """
874     Find an SRV service in a domain or its parents
875     :param svc: service to find (ldap, 389, etc)
876     :param proto: protocol the service talks (tcp, udp, etc)
877     :param domain: domain to start search in
878     :param walk: walk the parents if domain doesn't provide the service
879     :param secure: only return DNSSEC-validated results
880     :return: [
881         [ prio1server1, prio1server2 ],
882         [ prio2server1, prio2server2 ],
883     ] (the servers will already be weighted according to the SRV rules)
884     """
885     qres = query(srv_name(svc, proto, domain), "SRV", walk=walk, secure=secure)
886     if not qres:
887         return False
888     res = []
889     for _, recs in qres.items():
890         res.append(_weighted_order(recs))
891     return res
892 def services(services_file="/etc/services"):
893     """
894     Parse through system-known services
895     :return: {
896         'svc': [
897           {  'port': port
898              'proto': proto,
899              'desc': comment
900           },
901         ],
902     }
903     """
904     res = {}
905     with salt.utils.files.fopen(services_file, "r") as svc_defs:
906         for svc_def in svc_defs.readlines():
907             svc_def = salt.utils.stringutils.to_unicode(svc_def.strip())
908             if not svc_def or svc_def.startswith("#"):
909                 continue
910             elif "#" in svc_def:
911                 svc_def, comment = svc_def.split("#", 1)
912                 comment = comment.strip()
913             else:
914                 comment = None
915             svc_def = svc_def.split()
916             port, proto = svc_def.pop(1).split("/")
917             port = int(port)
918             for name in svc_def:
919                 svc_res = res.get(name, {})
920                 pp_res = svc_res.get(port, False)
921                 if not pp_res:
922                     svc = {
923                         "port": port,
924                         "proto": proto,
925                     }
926                     if comment:
927                         svc["desc"] = comment
928                     svc_res[port] = svc
929                 else:
930                     curr_proto = pp_res["proto"]
931                     if isinstance(curr_proto, (list, tuple)):
932                         curr_proto.append(proto)
933                     else:
934                         pp_res["proto"] = [curr_proto, proto]
935                     curr_desc = pp_res.get("desc", False)
936                     if comment:
937                         if not curr_desc:
938                             pp_res["desc"] = comment
939                         elif comment != curr_desc:
940                             pp_res["desc"] = "{}, {}".format(curr_desc, comment)
941                 res[name] = svc_res
942     for svc, data in res.items():
943         if len(data) == 1:
944             res[svc] = data.values().pop()
945             continue
946         else:
947             res[svc] = list(data.values())
948     return res
949 def parse_resolv(src="/etc/resolv.conf"):
950     """
951     Parse a resolver configuration file (traditionally /etc/resolv.conf)
952     """
953     nameservers = []
954     ip4_nameservers = []
955     ip6_nameservers = []
956     search = []
957     sortlist = []
958     domain = ""
959     options = []
960     try:
961         with salt.utils.files.fopen(src) as src_file:
962             for line in src_file:
963                 line = salt.utils.stringutils.to_unicode(line).strip().split()
964                 try:
965                     (directive, arg) = (line[0].lower(), line[1:])
966                     arg = list(
967                         itertools.takewhile(lambda x: x[0] not in ("#", ";"), arg)
968                     )
969                     if directive == "nameserver":
970                         addr = arg[0]
971                         try:
972                             ip_addr = ipaddress.ip_address(addr)
973                             version = ip_addr.version
974                             ip_addr = str(ip_addr)
975                             if ip_addr not in nameservers:
976                                 nameservers.append(ip_addr)
977                             if version == 4 and ip_addr not in ip4_nameservers:
978                                 ip4_nameservers.append(ip_addr)
979                             elif version == 6 and ip_addr not in ip6_nameservers:
980                                 ip6_nameservers.append(ip_addr)
981                         except ValueError as exc:
982                             log.error("%s: %s", src, exc)
983                     elif directive == "domain":
984                         domain = arg[0]
985                     elif directive == "search":
986                         search = arg
987                     elif directive == "sortlist":
988                         for ip_raw in arg:
989                             try:
990                                 ip_net = ipaddress.ip_network(ip_raw)
991                             except ValueError as exc:
992                                 log.error("%s: %s", src, exc)
993                             else:
994                                 if "/" not in ip_raw:
995                                     if ip_net.version == 4:
996                                         ip_addr = str(ip_net.network_address)
997                                         mask = salt.utils.network.natural_ipv4_netmask(
998                                             ip_addr
999                                         )
1000                                         ip_net = ipaddress.ip_network(
1001                                             "{}{}".format(ip_addr, mask), strict=False
1002                                         )
1003                                     if ip_net.version == 6:
1004                                         pass
1005                                 if ip_net not in sortlist:
1006                                     sortlist.append(ip_net)
1007                     elif directive == "options":
1008                         if arg[0] not in options:
1009                             options.append(arg[0])
1010                 except IndexError:
1011                     continue
1012         if domain and search:
1013             log.debug("%s: The domain and search keywords are mutually exclusive.", src)
1014         return {
1015             "nameservers": nameservers,
1016             "ip4_nameservers": ip4_nameservers,
1017             "ip6_nameservers": ip6_nameservers,
1018             "sortlist": [ip.with_netmask for ip in sortlist],
1019             "domain": domain,
1020             "search": search,
1021             "options": options,
1022         }
1023     except OSError:
1024         return {}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
