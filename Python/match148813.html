<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_cp_1.py &amp; dns.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_cp_1.py &amp; dns.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_cp_1.py (2.8284671%)<th>dns.py (2.038133%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-20)<td><a href="#" name="0">(13-32)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(426-429)<td><a href="#" name="1">(579-586)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cp_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
2 import logging
3 import os
4 import shutil
5 import signal
6 import tempfile
7 import textwrap
8 import time
9 import uuid
10 import psutil  # pylint: disable=3rd-party-module-not-gated
11 import pytest
12 import salt.utils.files
13 import salt.utils.path
14 import salt.utils.platform
15 import salt.utils.stringutils
16 from saltfactories.utils.ports import get_unused_localhost_port
17 from saltfactories.utils.tempfiles import temp_file
18 from tests.support.case import ModuleCase
19 from</b></font> tests.support.helpers import with_tempfile
20 from tests.support.runtests import RUNTIME_VARS
21 from tests.support.unit import skipIf
22 log = logging.getLogger(__name__)
23 @pytest.mark.windows_whitelisted
24 class CPModuleTest(ModuleCase):
25     def run_function(self, *args, **kwargs):  # pylint: disable=arguments-differ
26         return salt.utils.data.decode(super().run_function(*args, **kwargs))
27     @with_tempfile()
28     @pytest.mark.slow_test
29     def test_get_file(self, tgt):
30         self.run_function("cp.get_file", ["salt://grail/scene33", tgt])
31         with salt.utils.files.fopen(tgt, "r") as scene:
32             data = salt.utils.stringutils.to_unicode(scene.read())
33         self.assertIn("KNIGHT:  They're nervous, sire.", data)
34         self.assertNotIn("bacon", data)
35     @pytest.mark.slow_test
36     def test_get_file_to_dir(self):
37         tgt = os.path.join(RUNTIME_VARS.TMP, "")
38         self.run_function("cp.get_file", ["salt://grail/scene33", tgt])
39         with salt.utils.files.fopen(tgt + "scene33", "r") as scene:
40             data = salt.utils.stringutils.to_unicode(scene.read())
41         self.assertIn("KNIGHT:  They're nervous, sire.", data)
42         self.assertNotIn("bacon", data)
43     @with_tempfile()
44     @skipIf(
45         salt.utils.platform.is_windows(),
46         "This test hangs on Windows on Py3",
47     )
48     def test_get_file_templated_paths(self, tgt):
49         self.run_function(
50             "cp.get_file",
51             [
52                 "salt://{{grains.test_grain}}",
53                 tgt.replace("cheese", "{{grains.test_grain}}"),
54             ],
55             template="jinja",
56         )
57         with salt.utils.files.fopen(tgt, "r") as cheese:
58             data = salt.utils.stringutils.to_unicode(cheese.read())
59         self.assertIn("Gromit", data)
60         self.assertNotIn("bacon", data)
61     @with_tempfile()
62     @pytest.mark.slow_test
63     def test_get_file_gzipped(self, tgt):
64         src = os.path.join(RUNTIME_VARS.FILES, "file", "base", "file.big")
65         with salt.utils.files.fopen(src, "rb") as fp_:
66             hash_str = hashlib.md5(fp_.read()).hexdigest()
67         self.run_function("cp.get_file", ["salt://file.big", tgt], gzip=5)
68         with salt.utils.files.fopen(tgt, "rb") as scene:
69             data = scene.read()
70         self.assertEqual(hash_str, hashlib.md5(data).hexdigest())
71         data = salt.utils.stringutils.to_unicode(data)
72         self.assertIn("KNIGHT:  They're nervous, sire.", data)
73         self.assertNotIn("bacon", data)
74     @pytest.mark.slow_test
75     def test_get_file_makedirs(self):
76         tgt = os.path.join(RUNTIME_VARS.TMP, "make", "dirs", "scene33")
77         self.run_function("cp.get_file", ["salt://grail/scene33", tgt], makedirs=True)
78         self.addCleanup(
79             shutil.rmtree, os.path.join(RUNTIME_VARS.TMP, "make"), ignore_errors=True
80         )
81         with salt.utils.files.fopen(tgt, "r") as scene:
82             data = salt.utils.stringutils.to_unicode(scene.read())
83         self.assertIn("KNIGHT:  They're nervous, sire.", data)
84         self.assertNotIn("bacon", data)
85     @with_tempfile()
86     @pytest.mark.slow_test
87     def test_get_template(self, tgt):
88         self.run_function(
89             "cp.get_template", ["salt://grail/scene33", tgt], spam="bacon"
90         )
91         with salt.utils.files.fopen(tgt, "r") as scene:
92             data = salt.utils.stringutils.to_unicode(scene.read())
93         self.assertIn("bacon", data)
94         self.assertNotIn("spam", data)
95     @pytest.mark.slow_test
96     def test_get_dir(self):
97         tgt = os.path.join(RUNTIME_VARS.TMP, "many")
98         self.run_function("cp.get_dir", ["salt://grail", tgt])
99         self.assertIn("grail", os.listdir(tgt))
100         self.assertIn("36", os.listdir(os.path.join(tgt, "grail")))
101         self.assertIn("empty", os.listdir(os.path.join(tgt, "grail")))
102         self.assertIn("scene", os.listdir(os.path.join(tgt, "grail", "36")))
103     @pytest.mark.slow_test
104     def test_get_dir_templated_paths(self):
105         tgt = os.path.join(RUNTIME_VARS.TMP, "many")
106         self.run_function(
107             "cp.get_dir",
108             ["salt://{{grains.script}}", tgt.replace("many", "{{grains.alot}}")],
109         )
110         self.assertIn("grail", os.listdir(tgt))
111         self.assertIn("36", os.listdir(os.path.join(tgt, "grail")))
112         self.assertIn("empty", os.listdir(os.path.join(tgt, "grail")))
113         self.assertIn("scene", os.listdir(os.path.join(tgt, "grail", "36")))
114     @with_tempfile()
115     @pytest.mark.slow_test
116     def test_get_url(self, tgt):
117         self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
118         with salt.utils.files.fopen(tgt, "r") as scene:
119             data = salt.utils.stringutils.to_unicode(scene.read())
120         self.assertIn("KNIGHT:  They're nervous, sire.", data)
121         self.assertNotIn("bacon", data)
122     @pytest.mark.slow_test
123     def test_get_url_makedirs(self):
124         tgt = os.path.join(RUNTIME_VARS.TMP, "make", "dirs", "scene33")
125         self.run_function("cp.get_url", ["salt://grail/scene33", tgt], makedirs=True)
126         self.addCleanup(
127             shutil.rmtree, os.path.join(RUNTIME_VARS.TMP, "make"), ignore_errors=True
128         )
129         with salt.utils.files.fopen(tgt, "r") as scene:
130             data = salt.utils.stringutils.to_unicode(scene.read())
131         self.assertIn("KNIGHT:  They're nervous, sire.", data)
132         self.assertNotIn("bacon", data)
133     @pytest.mark.slow_test
134     def test_get_url_dest_empty(self):
135         ret = self.run_function("cp.get_url", ["salt://grail/scene33"])
136         with salt.utils.files.fopen(ret, "r") as scene:
137             data = salt.utils.stringutils.to_unicode(scene.read())
138         self.assertIn("KNIGHT:  They're nervous, sire.", data)
139         self.assertNotIn("bacon", data)
140     @pytest.mark.slow_test
141     def test_get_url_no_dest(self):
142         tgt = None
143         ret = self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
144         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
145     @pytest.mark.slow_test
146     def test_get_url_nonexistent_source(self):
147         tgt = None
148         ret = self.run_function("cp.get_url", ["salt://grail/nonexistent_scene", tgt])
149         self.assertEqual(ret, False)
150     @pytest.mark.slow_test
151     def test_get_url_to_dir(self):
152         tgt = os.path.join(RUNTIME_VARS.TMP, "")
153         self.run_function("cp.get_url", ["salt://grail/scene33", tgt])
154         with salt.utils.files.fopen(tgt + "scene33", "r") as scene:
155             data = salt.utils.stringutils.to_unicode(scene.read())
156         self.assertIn("KNIGHT:  They're nervous, sire.", data)
157         self.assertNotIn("bacon", data)
158     @with_tempfile()
159     @pytest.mark.slow_test
160     def test_get_url_https(self, tgt):
161         self.run_function("cp.get_url", ["https://repo.saltproject.io/index.html", tgt])
162         with salt.utils.files.fopen(tgt, "r") as instructions:
163             data = salt.utils.stringutils.to_unicode(instructions.read())
164         self.assertIn("Bootstrap", data)
165         self.assertIn("Debian", data)
166         self.assertIn("Windows", data)
167         self.assertNotIn("AYBABTU", data)
168     @pytest.mark.slow_test
169     def test_get_url_https_dest_empty(self):
170         ret = self.run_function(
171             "cp.get_url", ["https://repo.saltproject.io/index.html"]
172         )
173         with salt.utils.files.fopen(ret, "r") as instructions:
174             data = salt.utils.stringutils.to_unicode(instructions.read())
175         self.assertIn("Bootstrap", data)
176         self.assertIn("Debian", data)
177         self.assertIn("Windows", data)
178         self.assertNotIn("AYBABTU", data)
179     @pytest.mark.slow_test
180     def test_get_url_https_no_dest(self):
181         timeout = 500
182         start = time.time()
183         sleep = 5
184         tgt = None
185         while time.time() - start &lt;= timeout:
186             ret = self.run_function(
187                 "cp.get_url", ["https://repo.saltproject.io/index.html", tgt]
188             )
189             if ret.find("HTTP 599") == -1:
190                 break
191             time.sleep(sleep)
192         if ret.find("HTTP 599") != -1:
193             raise Exception("https://repo.saltproject.io/index.html returned 599 error")
194         self.assertIn("Bootstrap", ret)
195         self.assertIn("Debian", ret)
196         self.assertIn("Windows", ret)
197         self.assertNotIn("AYBABTU", ret)
198     @pytest.mark.slow_test
199     def test_get_url_file(self):
200         tgt = ""
201         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
202         ret = self.run_function("cp.get_url", [src, tgt])
203         with salt.utils.files.fopen(ret, "r") as scene:
204             data = salt.utils.stringutils.to_unicode(scene.read())
205         self.assertIn("KNIGHT:  They're nervous, sire.", data)
206         self.assertNotIn("bacon", data)
207     @pytest.mark.slow_test
208     def test_get_url_file_no_dest(self):
209         tgt = None
210         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
211         ret = self.run_function("cp.get_url", [src, tgt])
212         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
213         self.assertNotIn("bacon", ret)
214     @with_tempfile()
215     @pytest.mark.slow_test
216     def test_get_url_ftp(self, tgt):
217         self.run_function(
218             "cp.get_url",
219             [
220                 "ftp://ftp.freebsd.org/pub/FreeBSD/releases/amd64/amd64/12.0-RELEASE/MANIFEST",
221                 tgt,
222             ],
223         )
224         with salt.utils.files.fopen(tgt, "r") as instructions:
225             data = salt.utils.stringutils.to_unicode(instructions.read())
226         self.assertIn("Base system", data)
227     @pytest.mark.slow_test
228     def test_get_file_str_salt(self):
229         src = "salt://grail/scene33"
230         ret = self.run_function("cp.get_file_str", [src])
231         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
232     @pytest.mark.slow_test
233     def test_get_file_str_nonexistent_source(self):
234         src = "salt://grail/nonexistent_scene"
235         ret = self.run_function("cp.get_file_str", [src])
236         self.assertEqual(ret, False)
237     @pytest.mark.slow_test
238     def test_get_file_str_https(self):
239         src = "https://repo.saltproject.io/index.html"
240         ret = self.run_function("cp.get_file_str", [src])
241         self.assertIn("Bootstrap", ret)
242         self.assertIn("Debian", ret)
243         self.assertIn("Windows", ret)
244         self.assertNotIn("AYBABTU", ret)
245     @pytest.mark.slow_test
246     def test_get_file_str_local(self):
247         src = os.path.join("file://", RUNTIME_VARS.FILES, "file", "base", "file.big")
248         ret = self.run_function("cp.get_file_str", [src])
249         self.assertIn("KNIGHT:  They're nervous, sire.", ret)
250         self.assertNotIn("bacon", ret)
251     @pytest.mark.slow_test
252     def test_cache_file(self):
253         ret = self.run_function("cp.cache_file", ["salt://grail/scene33"])
254         with salt.utils.files.fopen(ret, "r") as scene:
255             data = salt.utils.stringutils.to_unicode(scene.read())
256         self.assertIn("KNIGHT:  They're nervous, sire.", data)
257         self.assertNotIn("bacon", data)
258     @pytest.mark.slow_test
259     def test_cache_files(self):
260         ret = self.run_function(
261             "cp.cache_files", [["salt://grail/scene33", "salt://grail/36/scene"]]
262         )
263         for path in ret:
264             with salt.utils.files.fopen(path, "r") as scene:
265                 data = salt.utils.stringutils.to_unicode(scene.read())
266             self.assertIn("ARTHUR:", data)
267             self.assertNotIn("bacon", data)
268     @with_tempfile()
269     @pytest.mark.slow_test
270     def test_cache_master(self, tgt):
271         ret = self.run_function(
272             "cp.cache_master",
273             [tgt],
274         )
275         for path in ret:
276             self.assertTrue(os.path.exists(path))
277     @pytest.mark.slow_test
278     def test_cache_local_file(self):
279         src = os.path.join(RUNTIME_VARS.TMP, "random")
280         with salt.utils.files.fopen(src, "w+") as fn_:
281             fn_.write(salt.utils.stringutils.to_str("foo"))
282         ret = self.run_function("cp.cache_local_file", [src])
283         with salt.utils.files.fopen(ret, "r") as cp_:
284             self.assertEqual(salt.utils.stringutils.to_unicode(cp_.read()), "foo")
285     @skipIf(not salt.utils.path.which("nginx"), "nginx not installed")
286     @pytest.mark.slow_test
287     @pytest.mark.skip_if_not_root
288     def test_cache_remote_file(self):
289 <a name="1"></a>        """
290         cp.cache_file
291         nginx_port = get_unused_localhost_port<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>()
292         url_prefix = "http://localhost:{}/".format(nginx_port)
293         temp_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
294         self.addCleanup(shutil.</b></font>rmtree, temp_dir, ignore_errors=True)
295         nginx_root_dir = os.path.join(temp_dir, "root")
296         nginx_conf_dir = os.path.join(temp_dir, "conf")
297         nginx_conf = os.path.join(nginx_conf_dir, "nginx.conf")
298         nginx_pidfile = os.path.join(nginx_conf_dir, "nginx.pid")
299         file_contents = "Hello world!"
300         for dirname in (nginx_root_dir, nginx_conf_dir):
301             os.makedirs(dirname)
302         with salt.utils.files.fopen(
303             os.path.join(nginx_root_dir, "actual_file"), "w"
304         ) as fp_:
305             fp_.write(salt.utils.stringutils.to_str(file_contents))
306         with salt.utils.files.fopen(nginx_conf, "w") as fp_:
307             fp_.write(
308                 textwrap.dedent(
309                     salt.utils.stringutils.to_str(
310         cp.list_states
311         core_state = """
312         {}/testfile:
313           file:
314             - managed
315             - source: salt://testfile
316             - makedirs: true
317         cp.list_minion
318         cp.is_cached
319         cp.hash_file
320         cp.get_file
321 Compendium of generic DNS utilities
322 dns.lookup(name, rdtype, ...)
323 dns.query(name, rdtype, ...)
324 dns.srv_rec(data)
325 dns.srv_data('my1.example.com', 389, prio=10, weight=100)
326 dns.srv_name('ldap/tcp', 'example.com')
327 <a name="0"></a>
328 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
329 import binascii
330 import functools
331 import hashlib
332 import itertools
333 import logging
334 import random
335 import re
336 import shlex
337 import socket
338 import ssl
339 import string
340 import salt.modules.cmdmod
341 import salt.utils.files
342 import salt.utils.network
343 import salt.utils.path
344 import salt.utils.stringutils
345 from salt._compat import ipaddress
346 from</b></font> salt.utils.odict import OrderedDict
347 try:
348     import dns.resolver
349     HAS_DNSPYTHON = True
350 except ImportError:
351     HAS_DNSPYTHON = False
352 try:
353     import tldextract
354     HAS_TLDEXTRACT = True
355 except ImportError:
356     HAS_TLDEXTRACT = False
357 HAS_DIG = salt.utils.path.which("dig") is not None
358 DIG_OPTIONS = "+search +fail +noall +answer +nocl +nottl"
359 HAS_DRILL = salt.utils.path.which("drill") is not None
360 HAS_HOST = salt.utils.path.which("host") is not None
361 HAS_NSLOOKUP = salt.utils.path.which("nslookup") is not None
362 __salt__ = {"cmd.run_all": salt.modules.cmdmod.run_all}
363 log = logging.getLogger(__name__)
364 class RFC:
365     CAA_TAGS = ("issue", "issuewild", "iodef")
366     SSHFP_ALGO = OrderedDict(
367         (
368             (1, "rsa"),
369             (2, "dsa"),
370             (3, "ecdsa"),
371             (4, "ed25519"),
372         )
373     )
374     SSHFP_HASH = OrderedDict(
375         (
376             (1, "sha1"),
377             (2, "sha256"),
378         )
379     )
380     TLSA_USAGE = OrderedDict(
381         (
382             (0, "pkixta"),
383             (1, "pkixee"),
384             (2, "daneta"),
385             (3, "daneee"),
386         )
387     )
388     TLSA_SELECT = OrderedDict(
389         (
390             (0, "cert"),
391             (1, "spki"),
392         )
393     )
394     TLSA_MATCHING = OrderedDict(
395         (
396             (0, "full"),
397             (1, "sha256"),
398             (2, "sha512"),
399         )
400     )
401     SRV_PROTO = ("tcp", "udp", "sctp")
402     @staticmethod
403     def validate(lookup, ref, match=None):
404         if lookup in ref:
405             return lookup
406         elif match == "in":
407             return [code for code, name in ref.items() if lookup in name][-1]
408         else:
409             return {name: code for code, name in ref.items()}[lookup]
410 def _to_port(port):
411     try:
412         port = int(port)
413         assert 1 &lt;= port &lt;= 65535
414         return port
415     except (ValueError, AssertionError):
416         raise ValueError("Invalid port {}".format(port))
417 def _tree(domain, tld=False):
418     domain = domain.rstrip(".")
419     assert "." in domain, "Provide a decent domain"
420     if not tld:
421         if HAS_TLDEXTRACT:
422             tld = tldextract.extract(domain).suffix
423         else:
424             tld = re.search(
425                 r"((?:(?:ac|biz|com?|info|edu|gov|mil|name|net|n[oi]m|org)\.)?[^.]+)$",
426                 domain,
427             ).group()
428             log.info(
429                 "Without tldextract, dns.util resolves the TLD of %s to %s", domain, tld
430             )
431     res = [domain]
432     while True:
433         idx = domain.find(".")
434         if idx &lt; 0:
435             break
436         domain = domain[idx + 1 :]
437         if domain == tld:
438             break
439         res.append(domain)
440     return res
441 def _weighted_order(recs):
442     res = []
443     weights = [rec["weight"] for rec in recs]
444     while weights:
445         rnd = random.random() * sum(weights)
446         for i, w in enumerate(weights):
447             rnd -= w
448             if rnd &lt; 0:
449                 res.append(recs.pop(i)["name"])
450                 weights.pop(i)
451                 break
452     return res
453 def _cast(rec_data, rec_cast):
454     if isinstance(rec_cast, dict):
455         rec_data = type(next(iter(rec_cast.keys())))(rec_data)
456         res = rec_cast[rec_data]
457         return res
458     elif isinstance(rec_cast, (list, tuple)):
459         return RFC.validate(rec_data, rec_cast)
460     else:
461         return rec_cast(rec_data)
462 def _data2rec(schema, rec_data):
463     try:
464         rec_fields = rec_data.split(" ")
465         assert len(rec_fields) &gt;= len(schema)
466         if len(rec_fields) &gt; len(schema):
467             cutoff = len(schema) - 1
468             rec_fields = rec_fields[0:cutoff] + ["".join(rec_fields[cutoff:])]
469         if len(schema) == 1:
470             res = _cast(rec_fields[0], next(iter(schema.values())))
471         else:
472             res = {
473                 field_name: _cast(rec_field, rec_cast)
474                 for (field_name, rec_cast), rec_field in zip(schema.items(), rec_fields)
475             }
476         return res
477     except (AssertionError, AttributeError, TypeError, ValueError) as e:
478         raise ValueError(
479             'Unable to cast "{0}" as "{2}": {1}'.format(
480                 rec_data, e, " ".join(schema.keys())
481             )
482         )
483 def _data2rec_group(schema, recs_data, group_key):
484     if not isinstance(recs_data, (list, tuple)):
485         recs_data = [recs_data]
486     res = OrderedDict()
487     try:
488         for rdata in recs_data:
489             rdata = _data2rec(schema, rdata)
490             assert rdata and group_key in rdata
491             idx = rdata.pop(group_key)
492             if idx not in res:
493                 res[idx] = []
494             if len(rdata) == 1:
495                 rdata = next(iter(rdata.values()))
496             res[idx].append(rdata)
497         return res
498     except (AssertionError, ValueError) as e:
499         raise ValueError(
500             'Unable to cast "{}" as a group of "{}": {}'.format(
501                 ",".join(recs_data), " ".join(schema.keys()), e
502             )
503         )
504 def _rec2data(*rdata):
505     return " ".join(rdata)
506 def _data_clean(data):
507     data = data.strip(string.whitespace)
508     if data.startswith(('"', "'")) and data.endswith(('"', "'")):
509         return data[1:-1]
510     else:
511         return data
512 def _lookup_dig(name, rdtype, timeout=None, servers=None, secure=None):
513     cmd = "dig {} -t {} ".format(DIG_OPTIONS, rdtype)
514     if servers:
515         cmd += "".join(["@{} ".format(srv) for srv in servers])
516     if timeout is not None:
517         if servers:
518             timeout = int(float(timeout) / len(servers))
519         else:
520             timeout = int(timeout)
521         cmd += "+time={} ".format(timeout)
522     if secure:
523         cmd += "+dnssec +adflag "
524     cmd = __salt__["cmd.run_all"](
525         "{} {}".format(cmd, name), python_shell=False, output_loglevel="quiet"
526     )
527     if "ignoring invalid type" in cmd["stderr"]:
528         raise ValueError("Invalid DNS type {}".format(rdtype))
529     elif cmd["retcode"] != 0:
530         log.warning(
531             "dig returned (%s): %s",
532             cmd["retcode"],
533             cmd["stderr"].strip(string.whitespace + ";"),
534         )
535         return False
536     elif not cmd["stdout"]:
537         return []
538     validated = False
539     res = []
540     for line in cmd["stdout"].splitlines():
541         _, rtype, rdata = line.split(None, 2)
542         if rtype == "CNAME" and rdtype != "CNAME":
543             continue
544         elif rtype == "RRSIG":
545             validated = True
546             continue
547         res.append(_data_clean(rdata))
548     if res and secure and not validated:
549         return False
550     else:
551         return res
552 def _lookup_drill(name, rdtype, timeout=None, servers=None, secure=None):
553     cmd = "drill "
554     if secure:
555         cmd += "-D -o ad "
556     cmd += "{} {} ".format(rdtype, name)
557     if servers:
558         cmd += "".join(["@{} ".format(srv) for srv in servers])
559     cmd = __salt__["cmd.run_all"](
560         cmd, timeout=timeout, python_shell=False, output_loglevel="quiet"
561     )
562     if cmd["retcode"] != 0:
563         log.warning("drill returned (%s): %s", cmd["retcode"], cmd["stderr"])
564         return False
565     lookup_res = iter(cmd["stdout"].splitlines())
566     validated = False
567     res = []
568     try:
569         line = ""
570         while "ANSWER SECTION" not in line:
571             line = next(lookup_res)
572         while True:
573             line = next(lookup_res)
574             line = line.strip()
575             if not line or line.startswith(";;"):
576                 break
577             l_type, l_rec = line.split(None, 4)[-2:]
578             if l_type == "CNAME" and rdtype != "CNAME":
579                 continue
580             elif l_type == "RRSIG":
581                 validated = True
582                 continue
583             elif l_type != rdtype:
584                 raise ValueError("Invalid DNS type {}".format(rdtype))
585             res.append(_data_clean(l_rec))
586     except StopIteration:
587         pass
588     if res and secure and not validated:
589         return False
590     else:
591         return res
592 def _lookup_gai(name, rdtype, timeout=None):
593     try:
594         sock_t = {"A": socket.AF_INET, "AAAA": socket.AF_INET6}[rdtype]
595     except KeyError:
596         raise ValueError("Invalid DNS type {} for gai lookup".format(rdtype))
597     if timeout:
598         log.info("Ignoring timeout on gai resolver; fix resolv.conf to do that")
599     try:
600         addresses = [
601             sock[4][0]
602             for sock in socket.getaddrinfo(name, None, sock_t, 0, socket.SOCK_RAW)
603         ]
604         return addresses
605     except socket.gaierror:
606         return False
607 def _lookup_host(name, rdtype, timeout=None, server=None):
608     cmd = "host -t {} ".format(rdtype)
609     if timeout:
610         cmd += "-W {} ".format(int(timeout))
611     cmd += name
612     if server is not None:
613         cmd += " {}".format(server)
614     cmd = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="quiet")
615     if "invalid type" in cmd["stderr"]:
616         raise ValueError("Invalid DNS type {}".format(rdtype))
617     elif cmd["retcode"] != 0:
618         log.warning("host returned (%s): %s", cmd["retcode"], cmd["stderr"])
619         return False
620     elif "has no" in cmd["stdout"]:
621         return []
622     res = []
623     _stdout = cmd["stdout"] if server is None else cmd["stdout"].split("\n\n")[-1]
624     for line in _stdout.splitlines():
625         if rdtype != "CNAME" and "is an alias" in line:
626             continue
627         line = line.split(" ", 3)[-1]
628         for prefix in ("record", "address", "handled by", "alias for"):
629             if line.startswith(prefix):
630                 line = line[len(prefix) + 1 :]
631                 break
632         res.append(_data_clean(line))
633     return res
634 def _lookup_dnspython(name, rdtype, timeout=None, servers=None, secure=None):
635     resolver = dns.resolver.Resolver()
636     if timeout is not None:
637         resolver.lifetime = float(timeout)
638     if servers:
639         resolver.nameservers = servers
640     if secure:
641         resolver.ednsflags += dns.flags.DO
642     try:
643         res = [
644             _data_clean(rr.to_text())
645             for rr in resolver.query(name, rdtype, raise_on_no_answer=False)
646         ]
647         return res
648     except dns.rdatatype.UnknownRdatatype:
649         raise ValueError("Invalid DNS type {}".format(rdtype))
650     except (
651         dns.resolver.NXDOMAIN,
652         dns.resolver.YXDOMAIN,
653         dns.resolver.NoNameservers,
654         dns.exception.Timeout,
655     ):
656         return False
657 def _lookup_nslookup(name, rdtype, timeout=None, server=None):
658     cmd = "nslookup -query={} {}".format(rdtype, name)
659     if timeout is not None:
660         cmd += " -timeout={}".format(int(timeout))
661     if server is not None:
662         cmd += " {}".format(server)
663     cmd = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="quiet")
664     if cmd["retcode"] != 0:
665         log.warning(
666             "nslookup returned (%s): %s",
667             cmd["retcode"],
668             cmd["stdout"].splitlines()[-1].strip(string.whitespace + ";"),
669         )
670         return False
671     lookup_res = iter(cmd["stdout"].splitlines())
672     res = []
673     try:
674         line = next(lookup_res)
675         if "unknown query type" in line:
676             raise ValueError("Invalid DNS type {}".format(rdtype))
677         while True:
678             if name in line:
679                 break
680             line = next(lookup_res)
681         while True:
682             line = line.strip()
683             if not line or line.startswith("*"):
684                 break
685             elif rdtype != "CNAME" and "canonical name" in line:
686                 name = line.split()[-1][:-1]
687                 line = next(lookup_res)
688                 continue
689             elif rdtype == "SOA":
690                 line = line.split("=")
691             elif line.startswith("Name:"):
692                 line = next(lookup_res)
693                 line = line.split(":", 1)
694             elif line.startswith(name):
695                 if "=" in line:
696                     line = line.split("=", 1)
697                 else:
698                     line = line.split(" ")
699             res.append(_data_clean(line[-1]))
700             line = next(lookup_res)
701     except StopIteration:
702         pass
703     if rdtype == "SOA":
704         return [" ".join(res[1:])]
705     else:
706         return res
707 def lookup(
708     name,
709     rdtype,
710     method=None,
711     servers=None,
712     timeout=None,
713     walk=False,
714     walk_tld=False,
715     secure=None,
716 ):
717 <a name="1"></a>    opts = {}
718     method = method or opts.get("method", "auto")
719     secure = secure or opts.get("secure", None)
720     servers = servers or opts.get<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("servers", None)
721     timeout = timeout or opts.get("timeout", False)
722     rdtype = rdtype.upper()
723     query_methods = (
724         ("gai", _lookup_gai, not any((rdtype</b></font> not in ("A", "AAAA"), servers, secure))),
725         ("dnspython", _lookup_dnspython, HAS_DNSPYTHON),
726         ("dig", _lookup_dig, HAS_DIG),
727         ("drill", _lookup_drill, HAS_DRILL),
728         ("host", _lookup_host, HAS_HOST and not secure),
729         ("nslookup", _lookup_nslookup, HAS_NSLOOKUP and not secure),
730     )
731     try:
732         if method == "auto":
733             method, resolver = next(
734                 ((rname, rcb) for rname, rcb, rtest in query_methods if rtest)
735             )
736         else:
737             resolver = next(
738                 (
739                     rcb
740                     for rname, rcb, rtest in query_methods
741                     if rname == method and rtest
742                 )
743             )
744     except StopIteration:
745         log.error(
746             "Unable to lookup %s/%s: Resolver method %s invalid, unsupported "
747             "or unable to perform query",
748             method,
749             rdtype,
750             name,
751         )
752         return False
753     res_kwargs = {
754         "rdtype": rdtype,
755     }
756     if servers:
757         if not isinstance(servers, (list, tuple)):
758             servers = [servers]
759         if method in ("dnspython", "dig", "drill"):
760             res_kwargs["servers"] = servers
761         else:
762             if timeout:
763                 timeout /= len(servers)
764             def _multi_srvr(resolv_func):
765                 @functools.wraps(resolv_func)
766                 def _wrapper(**res_kwargs):
767                     for server in servers:
768                         s_res = resolv_func(server=server, **res_kwargs)
769                         if s_res:
770                             return s_res
771                 return _wrapper
772             resolver = _multi_srvr(resolver)
773     if not walk:
774         name = [name]
775     else:
776         idx = 0
777         if rdtype in ("SRV", "TLSA"):  # The only RRs I know that have 2 name components
778             idx = name.find(".") + 1
779         idx = name.find(".", idx) + 1
780         domain = name[idx:]
781         rname = name[0:idx]
782         name = _tree(domain, walk_tld)
783         if walk == "name":
784             name = [rname + domain for domain in name]
785         if timeout:
786             timeout /= len(name)
787     if secure:
788         res_kwargs["secure"] = secure
789     if timeout:
790         res_kwargs["timeout"] = timeout
791     for rname in name:
792         res = resolver(name=rname, **res_kwargs)
793         if res:
794             return res
795     return res
796 def query(
797     name,
798     rdtype,
799     method=None,
800     servers=None,
801     timeout=None,
802     walk=False,
803     walk_tld=False,
804     secure=None,
805 ):
806     rdtype = rdtype.upper()
807     qargs = {
808         "method": method,
809         "servers": servers,
810         "timeout": timeout,
811         "walk": walk,
812         "walk_tld": walk_tld,
813         "secure": secure,
814     }
815     if rdtype == "PTR" and not name.endswith("arpa"):
816         name = ptr_name(name)
817     if rdtype == "SPF":
818         qres = [
819             answer
820             for answer in lookup(name, "TXT", **qargs)
821             if answer.startswith("v=spf")
822         ]
823         if not qres:
824             qres = lookup(name, rdtype, **qargs)
825     else:
826         qres = lookup(name, rdtype, **qargs)
827     rec_map = {
828         "A": a_rec,
829         "AAAA": aaaa_rec,
830         "CAA": caa_rec,
831         "MX": mx_rec,
832         "SOA": soa_rec,
833         "SPF": spf_rec,
834         "SRV": srv_rec,
835         "SSHFP": sshfp_rec,
836         "TLSA": tlsa_rec,
837     }
838     if not qres or rdtype not in rec_map:
839         return qres
840     elif rdtype in ("A", "AAAA", "SSHFP", "TLSA"):
841         res = [rec_map[rdtype](res) for res in qres]
842     elif rdtype in ("SOA", "SPF"):
843         res = rec_map[rdtype](qres[0])
844     else:
845         res = rec_map[rdtype](qres)
846     return res
847 def host(name, ip4=True, ip6=True, **kwargs):
848     res = {}
849     if ip6:
850         ip6 = lookup(name, "AAAA", **kwargs)
851         if ip6:
852             res["ip6"] = ip6
853     if ip4:
854         ip4 = lookup(name, "A", **kwargs)
855         if ip4:
856             res["ip4"] = ip4
857     return res
858 def a_rec(rdata):
859     rschema = OrderedDict((("address", ipaddress.IPv4Address),))
860     return _data2rec(rschema, rdata)
861 def aaaa_rec(rdata):
862     rschema = OrderedDict((("address", ipaddress.IPv6Address),))
863     return _data2rec(rschema, rdata)
864 def caa_rec(rdatas):
865     rschema = OrderedDict(
866         (
867             ("flags", lambda flag: ["critical"] if int(flag) &gt; 0 else []),
868             ("tag", RFC.CAA_TAGS),
869             ("value", lambda val: val.strip("',\"")),
870         )
871     )
872     res = _data2rec_group(rschema, rdatas, "tag")
873     for tag in ("issue", "issuewild"):
874         tag_res = res.get(tag, False)
875         if not tag_res:
876             continue
877         for idx, val in enumerate(tag_res):
878             if ";" not in val:
879                 continue
880             val, params = val.split(";", 1)
881             params = dict(param.split("=") for param in shlex.split(params))
882             tag_res[idx] = {val: params}
883     return res
884 def mx_data(target, preference=10):
885     return _rec2data(int(preference), target)
886 def mx_rec(rdatas):
887     rschema = OrderedDict(
888         (
889             ("preference", int),
890             ("name", str),
891         )
892     )
893     return _data2rec_group(rschema, rdatas, "preference")
894 def ptr_name(rdata):
895     try:
896         return ipaddress.ip_address(rdata).reverse_pointer
897     except ValueError:
898         log.error("Unable to generate PTR record; %s is not a valid IP address", rdata)
899         return False
900 def soa_rec(rdata):
901     rschema = OrderedDict(
902         (
903             ("mname", str),
904             ("rname", str),
905             ("serial", int),
906             ("refresh", int),
907             ("retry", int),
908             ("expire", int),
909             ("minimum", int),
910         )
911     )
912     return _data2rec(rschema, rdata)
913 def spf_rec(rdata):
914     spf_fields = rdata.split(" ")
915     if not spf_fields.pop(0).startswith("v=spf"):
916         raise ValueError("Not an SPF record")
917     res = OrderedDict()
918     mods = set()
919     for mech_spec in spf_fields:
920         if mech_spec.startswith(("exp", "redirect")):
921             mod, val = mech_spec.split("=", 1)
922             if mod in mods:
923                 raise KeyError("Modifier {} can only appear once".format(mod))
924             mods.add(mod)
925             continue
926         mech = {}
927         if mech_spec[0] in ("+", "-", "~", "?"):
928             mech["qualifier"] = mech_spec[0]
929             mech_spec = mech_spec[1:]
930         if ":" in mech_spec:
931             mech_spec, val = mech_spec.split(":", 1)
932         elif "/" in mech_spec:
933             idx = mech_spec.find("/")
934             mech_spec = mech_spec[0:idx]
935             val = mech_spec[idx:]
936         else:
937             val = None
938         res[mech_spec] = mech
939         if not val:
940             continue
941         elif mech_spec in ("ip4", "ip6"):
942             val = ipaddress.ip_interface(val)
943             assert val.version == int(mech_spec[-1])
944         mech["value"] = val
945     return res
946 def srv_data(target, port, prio=10, weight=10):
947     return _rec2data(prio, weight, port, target)
948 def srv_name(svc, proto="tcp", domain=None):
949     proto = RFC.validate(proto, RFC.SRV_PROTO)
950     if isinstance(svc, int) or svc.isdigit():
951         svc = _to_port(svc)
952     if domain:
953         domain = "." + domain
954     return "_{}._{}{}".format(svc, proto, domain)
955 def srv_rec(rdatas):
956     rschema = OrderedDict(
957         (
958             ("prio", int),
959             ("weight", int),
960             ("port", _to_port),
961             ("name", str),
962         )
963     )
964     return _data2rec_group(rschema, rdatas, "prio")
965 def sshfp_data(key_t, hash_t, pub):
966     key_t = RFC.validate(key_t, RFC.SSHFP_ALGO, "in")
967     hash_t = RFC.validate(hash_t, RFC.SSHFP_HASH)
968     hasher = hashlib.new(hash_t)
969     hasher.update(base64.b64decode(pub))
970     ssh_fp = hasher.hexdigest()
971     return _rec2data(key_t, hash_t, ssh_fp)
972 def sshfp_rec(rdata):
973     rschema = OrderedDict(
974         (
975             ("algorithm", RFC.SSHFP_ALGO),
976             ("fp_hash", RFC.SSHFP_HASH),
977             (
978                 "fingerprint",
979                 lambda val: val.lower(),
980             ),  # resolvers are inconsistent on this one
981         )
982     )
983     return _data2rec(rschema, rdata)
984 def tlsa_data(pub, usage, selector, matching):
985     usage = RFC.validate(usage, RFC.TLSA_USAGE)
986     selector = RFC.validate(selector, RFC.TLSA_SELECT)
987     matching = RFC.validate(matching, RFC.TLSA_MATCHING)
988     pub = ssl.PEM_cert_to_DER_cert(pub.strip())
989     if matching == 0:
990         cert_fp = binascii.b2a_hex(pub)
991     else:
992         hasher = hashlib.new(RFC.TLSA_MATCHING[matching])
993         hasher.update(pub)
994         cert_fp = hasher.hexdigest()
995     return _rec2data(usage, selector, matching, cert_fp)
996 def tlsa_rec(rdata):
997     rschema = OrderedDict(
998         (
999             ("usage", RFC.TLSA_USAGE),
1000             ("selector", RFC.TLSA_SELECT),
1001             ("matching", RFC.TLSA_MATCHING),
1002             ("pub", str),
1003         )
1004     )
1005     return _data2rec(rschema, rdata)
1006 def service(svc, proto="tcp", domain=None, walk=False, secure=None):
1007     qres = query(srv_name(svc, proto, domain), "SRV", walk=walk, secure=secure)
1008     if not qres:
1009         return False
1010     res = []
1011     for _, recs in qres.items():
1012         res.append(_weighted_order(recs))
1013     return res
1014 def services(services_file="/etc/services"):
1015     res = {}
1016     with salt.utils.files.fopen(services_file, "r") as svc_defs:
1017         for svc_def in svc_defs.readlines():
1018             svc_def = salt.utils.stringutils.to_unicode(svc_def.strip())
1019             if not svc_def or svc_def.startswith("#"):
1020                 continue
1021             elif "#" in svc_def:
1022                 svc_def, comment = svc_def.split("#", 1)
1023                 comment = comment.strip()
1024             else:
1025                 comment = None
1026             svc_def = svc_def.split()
1027             port, proto = svc_def.pop(1).split("/")
1028             port = int(port)
1029             for name in svc_def:
1030                 svc_res = res.get(name, {})
1031                 pp_res = svc_res.get(port, False)
1032                 if not pp_res:
1033                     svc = {
1034                         "port": port,
1035                         "proto": proto,
1036                     }
1037                     if comment:
1038                         svc["desc"] = comment
1039                     svc_res[port] = svc
1040                 else:
1041                     curr_proto = pp_res["proto"]
1042                     if isinstance(curr_proto, (list, tuple)):
1043                         curr_proto.append(proto)
1044                     else:
1045                         pp_res["proto"] = [curr_proto, proto]
1046                     curr_desc = pp_res.get("desc", False)
1047                     if comment:
1048                         if not curr_desc:
1049                             pp_res["desc"] = comment
1050                         elif comment != curr_desc:
1051                             pp_res["desc"] = "{}, {}".format(curr_desc, comment)
1052                 res[name] = svc_res
1053     for svc, data in res.items():
1054         if len(data) == 1:
1055             res[svc] = data.values().pop()
1056             continue
1057         else:
1058             res[svc] = list(data.values())
1059     return res
1060 def parse_resolv(src="/etc/resolv.conf"):
1061     nameservers = []
1062     ip4_nameservers = []
1063     ip6_nameservers = []
1064     search = []
1065     sortlist = []
1066     domain = ""
1067     options = []
1068     try:
1069         with salt.utils.files.fopen(src) as src_file:
1070             for line in src_file:
1071                 line = salt.utils.stringutils.to_unicode(line).strip().split()
1072                 try:
1073                     (directive, arg) = (line[0].lower(), line[1:])
1074                     arg = list(
1075                         itertools.takewhile(lambda x: x[0] not in ("#", ";"), arg)
1076                     )
1077                     if directive == "nameserver":
1078                         addr = arg[0]
1079                         try:
1080                             ip_addr = ipaddress.ip_address(addr)
1081                             version = ip_addr.version
1082                             ip_addr = str(ip_addr)
1083                             if ip_addr not in nameservers:
1084                                 nameservers.append(ip_addr)
1085                             if version == 4 and ip_addr not in ip4_nameservers:
1086                                 ip4_nameservers.append(ip_addr)
1087                             elif version == 6 and ip_addr not in ip6_nameservers:
1088                                 ip6_nameservers.append(ip_addr)
1089                         except ValueError as exc:
1090                             log.error("%s: %s", src, exc)
1091                     elif directive == "domain":
1092                         domain = arg[0]
1093                     elif directive == "search":
1094                         search = arg
1095                     elif directive == "sortlist":
1096                         for ip_raw in arg:
1097                             try:
1098                                 ip_net = ipaddress.ip_network(ip_raw)
1099                             except ValueError as exc:
1100                                 log.error("%s: %s", src, exc)
1101                             else:
1102                                 if "/" not in ip_raw:
1103                                     if ip_net.version == 4:
1104                                         ip_addr = str(ip_net.network_address)
1105                                         mask = salt.utils.network.natural_ipv4_netmask(
1106                                             ip_addr
1107                                         )
1108                                         ip_net = ipaddress.ip_network(
1109                                             "{}{}".format(ip_addr, mask), strict=False
1110                                         )
1111                                     if ip_net.version == 6:
1112                                         pass
1113                                 if ip_net not in sortlist:
1114                                     sortlist.append(ip_net)
1115                     elif directive == "options":
1116                         if arg[0] not in options:
1117                             options.append(arg[0])
1118                 except IndexError:
1119                     continue
1120         if domain and search:
1121             log.debug("%s: The domain and search keywords are mutually exclusive.", src)
1122         return {
1123             "nameservers": nameservers,
1124             "ip4_nameservers": ip4_nameservers,
1125             "ip6_nameservers": ip6_nameservers,
1126             "sortlist": [ip.with_netmask for ip in sortlist],
1127             "domain": domain,
1128             "search": search,
1129             "options": options,
1130         }
1131     except OSError:
1132         return {}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
