
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.13013698630137%, Tokens: 9</h2>
        <div class="column">
            <h3>seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search_test.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  from __future__ import division
3  from __future__ import print_function
4  from __future__ import unicode_literals
5  import tensorflow as tf
6  import numpy as np
7  from seq2seq.inference import beam_search
8  class TestGatherTree(tf.test.TestCase):
9    def test_gather_tree(self):
10      predicted_ids = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
11      parent_ids = np.array([[0, 0, 0], [0, 1, 1], [2, 1, 2]])
12      expected_result = np.array([[2, 2, 2], [6, 5, 6], [7, 8, 9]])
13      res = beam_search.gather_tree(
14          tf.convert_to_tensor(predicted_ids), tf.convert_to_tensor(parent_ids))
15      with self.test_session() as sess:
16        res_ = sess.run(res)
17      np.testing.assert_array_equal(expected_result, res_)
18  class TestLengthNorm(tf.test.TestCase):
19    def test_length_norm(self):
20      lengths_ = np.array([[1, 2, 3], [3, 3, 3]])
21      penalty_factor_ = 0.6
22      length_pen = beam_search.length_penalty(
23          sequence_lengths=tf.convert_to_tensor(lengths_),
24          penalty_factor=penalty_factor_)
25      with self.test_session() as sess:
26        length_pen_ = sess.run(length_pen)
27      np.testing.assert_almost_equal(length_pen_[0, 0], 1.0, decimal=5)
28      np.testing.assert_almost_equal(length_pen_[0, 1], 1.0969027, decimal=4)
29      np.testing.assert_almost_equal(length_pen_[0, 2], 1.1884017, decimal=4)
30  class TestBeamStep(tf.test.TestCase):
31    def setUp(self):
32      super(TestBeamStep, self).setUp()
33      self.state_size = 10
34      config = beam_search.BeamSearchConfig(
35          beam_width=3,
36          vocab_size=5,
37          eos_token=0,
38          length_penalty_weight=0.6,
39          choose_successors_fn=beam_search.choose_top_k)
40      self.config = config
41    def test_step(self):
42      beam_state = beam_search.BeamSearchState(
43          log_probs=tf.nn.log_softmax(tf.ones(self.config.beam_width)),
44          lengths=tf.constant(
45              2, shape=[self.config.beam_width], dtype=tf.int32),
46          finished=tf.zeros(
47              [self.config.beam_width], dtype=tf.bool))
48      logits_ = np.full([self.config.beam_width, self.config.vocab_size], 0.0001)
49      logits_[0, 2] = 1.9
50      logits_[0, 3] = 2.1
51      logits_[1, 3] = 3.1
52      logits_[1, 4] = 0.9
53      logits = tf.convert_to_tensor(logits_, dtype=tf.float32)
54      log_probs = tf.nn.log_softmax(logits)
55      outputs, next_beam_state = beam_search.beam_search_step(
56          time_=2, logits=logits, beam_state=beam_state, config=self.config)
57      with self.test_session() as sess:
58        outputs_, next_state_, state_, log_probs_ = sess.run(
59            [outputs, next_beam_state, beam_state, log_probs])
60      np.testing.assert_array_equal(outputs_.predicted_ids, [3, 3, 2])
61      np.testing.assert_array_equal(outputs_.beam_parent_ids, [1, 0, 0])
62      np.testing.assert_array_equal(next_state_.lengths, [3, 3, 3])
63      np.testing.assert_array_equal(next_state_.finished, [False, False, False])
64      expected_log_probs = state_.log_probs[[1, 0, 0]]
65      expected_log_probs[0] += log_probs_[1, 3]
66      expected_log_probs[1] += log_probs_[0, 3]
67      expected_log_probs[2] += log_probs_[0, 2]
68      np.testing.assert_array_equal(next_state_.log_probs, expected_log_probs)
69    def test_step_with_eos(self):
70      beam_state = beam_search.BeamSearchState(
71          log_probs=tf.nn.log_softmax(tf.ones(self.config.beam_width)),
<span onclick='openModal()' class='match'>72          lengths=tf.convert_to_tensor(
73              [2, 1, 2], dtype=tf.int32),
74          finished=tf.constant(
</span>75              [False, True, False], dtype=tf.bool))
76      logits_ = np.full([self.config.beam_width, self.config.vocab_size], 0.0001)
77      logits_[0, 2] = 1.1
78      logits_[1, 2] = 1.0
79      logits_[2, 2] = 1.0
80      logits = tf.convert_to_tensor(logits_, dtype=tf.float32)
81      log_probs = tf.nn.log_softmax(logits)
82      outputs, next_beam_state = beam_search.beam_search_step(
83          time_=2, logits=logits, beam_state=beam_state, config=self.config)
84      with self.test_session() as sess:
85        outputs_, next_state_, state_, log_probs_ = sess.run(
86            [outputs, next_beam_state, beam_state, log_probs])
87      np.testing.assert_array_equal(outputs_.predicted_ids, [0, 2, 2])
88      np.testing.assert_array_equal(outputs_.beam_parent_ids, [1, 0, 2])
89      np.testing.assert_array_equal(next_state_.lengths, [1, 3, 3])
90      np.testing.assert_array_equal(next_state_.finished, [True, False, False])
91      expected_log_probs = state_.log_probs[outputs_.beam_parent_ids]
92      expected_log_probs[1] += log_probs_[0, 2]
93      expected_log_probs[2] += log_probs_[2, 2]
94      np.testing.assert_array_equal(next_state_.log_probs, expected_log_probs)
95    def test_step_with_new_eos(self):
96      beam_state = beam_search.BeamSearchState(
97          log_probs=tf.nn.log_softmax(tf.ones(self.config.beam_width)),
98          lengths=tf.constant(
99              2, shape=[self.config.beam_width], dtype=tf.int32),
100          finished=tf.zeros(
101              [self.config.beam_width], dtype=tf.bool))
102      logits_ = np.full([self.config.beam_width, self.config.vocab_size], 0.0001)
103      logits_[0, 0] = 1.9
104      logits_[0, 3] = 2.1
105      logits_[1, 3] = 3.1
106      logits_[1, 4] = 0.9
107      logits = tf.convert_to_tensor(logits_, dtype=tf.float32)
108      log_probs = tf.nn.log_softmax(logits)
109      outputs, next_beam_state = beam_search.beam_search_step(
110          time_=2, logits=logits, beam_state=beam_state, config=self.config)
111      with self.test_session() as sess:
112        outputs_, next_state_, state_, log_probs_ = sess.run(
113            [outputs, next_beam_state, beam_state, log_probs])
114      np.testing.assert_array_equal(outputs_.predicted_ids, [3, 3, 0])
115      np.testing.assert_array_equal(outputs_.beam_parent_ids, [1, 0, 0])
116      np.testing.assert_array_equal(next_state_.lengths, [3, 3, 2])
117      np.testing.assert_array_equal(next_state_.finished, [False, False, True])
118      expected_log_probs = state_.log_probs[[1, 0, 0]]
119      expected_log_probs[0] += log_probs_[1, 3]
120      expected_log_probs[1] += log_probs_[0, 3]
121      expected_log_probs[2] += log_probs_[0, 0]
122      np.testing.assert_array_equal(next_state_.log_probs, expected_log_probs)
123  class TestEosMasking(tf.test.TestCase):
124    def test_eos_masking(self):
125      probs = tf.constant([[-.2, -.2, -.2, -.2, -.2], [-.3, -.3, -.3, 3, 0],
126                           [5, 6, 0, 0, 0]])
127      eos_token = 0
128      previously_finished = tf.constant([0, 1, 0], dtype=tf.float32)
129      masked = beam_search.mask_probs(probs, eos_token, previously_finished)
130      with self.test_session() as sess:
131        probs = sess.run(probs)
132        masked = sess.run(masked)
133        np.testing.assert_array_equal(probs[0], masked[0])
134        np.testing.assert_array_equal(probs[2], masked[2])
135        np.testing.assert_equal(masked[1][0], 0)
136        np.testing.assert_approx_equal(masked[1][1], np.finfo('float32').min)
137        np.testing.assert_approx_equal(masked[1][2], np.finfo('float32').min)
138        np.testing.assert_approx_equal(masked[1][3], np.finfo('float32').min)
139        np.testing.assert_approx_equal(masked[1][4], np.finfo('float32').min)
140  if __name__ == "__main__":
141    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_test.py</h3>
            <pre><code>1  from absl.testing import parameterized
2  import numpy as np
3  from sonnet.src import conv
4  from sonnet.src import initializers
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  def create_constant_initializers(w, b, with_bias):
8    if with_bias:
9      return {
10          "w_init": initializers.Constant(w),
11          "b_init": initializers.Constant(b)
12      }
13    else:
14      return {"w_init": initializers.Constant(w)}
15  class ConvTest(test_utils.TestCase, parameterized.TestCase):
16    def testPaddingFunctionReached(self):
17      self.reached = False
18      def padding_func(*unused_args):
19        padding_func.called = True
20        return [0, 0]
21      conv1 = conv.ConvND(
22          num_spatial_dims=2,
23          output_channels=1,
24          kernel_shape=3,
25          stride=1,
26          padding=padding_func,
27          data_format="NHWC",
28          **create_constant_initializers(1.0, 1.0, True))
29      conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
30      self.assertEqual(conv1.conv_padding, "VALID")
31      self.assertEqual(conv1.padding_func, padding_func)
32      self.assertTrue(getattr(padding_func, "called", False))
33    @parameterized.parameters(0, 4)
34    def testIncorrectN(self, n):
35      with self.assertRaisesRegex(
36          ValueError,
37          "We only support convoltion operations for num_spatial_dims=1, 2 or 3"):
38        conv.ConvND(
39            num_spatial_dims=n,
40            output_channels=1,
41            kernel_shape=3,
42            data_format="NHWC")
43    def testInitializerKeysInvalidWithoutBias(self):
44      with self.assertRaisesRegex(ValueError, "b_init must be None"):
45        conv.ConvND(
46            num_spatial_dims=2,
47            output_channels=1,
48            kernel_shape=3,
49            data_format="NHWC",
50            with_bias=False,
51            b_init=tf.zeros_initializer())
52    def testIncorrectRankInput(self):
53      c = conv.ConvND(
54          num_spatial_dims=2,
55          output_channels=1,
56          kernel_shape=3,
57          data_format="NHWC")
58      with self.assertRaisesRegex(ValueError, "Shape .* must have rank 4"):
59        c(tf.ones([2, 4, 4]))
60    @parameterized.parameters(tf.float32, tf.float64)
61    def testDefaultInitializers(self, dtype):
62      if "TPU" in self.device_types and dtype == tf.float64:
63        self.skipTest("Double precision not supported on TPU.")
64      conv1 = conv.ConvND(
65          num_spatial_dims=2,
66          output_channels=1,
67          kernel_shape=16,
68          stride=1,
69          padding="VALID",
70          data_format="NHWC")
71      out = conv1(tf.random.normal([8, 64, 64, 1], dtype=dtype))
72      self.assertAllEqual(out.shape, [8, 49, 49, 1])
73      self.assertEqual(out.dtype, dtype)
74      err = 0.2 if self.primary_device == "TPU" else 0.1
75      self.assertNear(out.numpy().std(), 0.87, err=err)
76    @parameterized.named_parameters(
77        ("SamePaddingUseBias", True, "SAME"),
78        ("SamePaddingNoBias", False, "SAME"),
79        ("samePaddingUseBias", True, "same"),
80        ("samePaddingNoBias", False, "same"),
81        ("ValidPaddingNoBias", False, "VALID"),
82        ("ValidPaddingUseBias", True, "VALID"),
83        ("validPaddingNoBias", False, "valid"),
84        ("validPaddingUseBias", True, "valid"),
85    )
86    def testFunction(self, with_bias, padding):
87      conv1 = conv.ConvND(
88          num_spatial_dims=2,
89          output_channels=1,
90          kernel_shape=3,
91          stride=1,
92          padding=padding,
93          with_bias=with_bias,
94          data_format="NHWC",
95          **create_constant_initializers(1.0, 1.0, with_bias))
96      conv2 = conv.ConvND(
97          num_spatial_dims=2,
98          output_channels=1,
99          kernel_shape=3,
100          stride=1,
101          padding=padding,
102          with_bias=with_bias,
103          data_format="NHWC",
104          **create_constant_initializers(1.0, 1.0, with_bias))
105      defun_conv = tf.function(conv2)
106      iterations = 5
107      for _ in range(iterations):
108        x = tf.random.uniform([1, 5, 5, 1])
109        y1 = conv1(x)
110        y2 = defun_conv(x)
111        self.assertAllClose(self.evaluate(y1), self.evaluate(y2), atol=1e-4)
112    def testUnknownBatchSizeNHWC(self):
113      x = tf.TensorSpec([None, 5, 5, 3], dtype=tf.float32)
114      c = conv.ConvND(
115          num_spatial_dims=2,
116          output_channels=2,
117          kernel_shape=3,
118          data_format="NHWC")
119      defun_conv = tf.function(c).get_concrete_function(x)
120      out1 = defun_conv(tf.ones([3, 5, 5, 3]))
121      self.assertEqual(out1.shape, [3, 5, 5, 2])
122      out2 = defun_conv(tf.ones([5, 5, 5, 3]))
123      self.assertEqual(out2.shape, [5, 5, 5, 2])
124    def testUnknownBatchSizeNCHW(self):
125      if self.primary_device == "CPU":
126        self.skipTest("NCHW not supported on CPU")
<span onclick='openModal()' class='match'>127      x = tf.TensorSpec([None, 3, 5, 5], dtype=tf.float32)
128      c = conv.ConvND(
</span>129          num_spatial_dims=2,
130          output_channels=2,
131          kernel_shape=3,
132          data_format="NCHW")
133      defun_conv = tf.function(c).get_concrete_function(x)
134      out1 = defun_conv(tf.ones([3, 3, 5, 5]))
135      self.assertEqual(out1.shape, [3, 2, 5, 5])
136      out2 = defun_conv(tf.ones([5, 3, 5, 5]))
137      self.assertEqual(out2.shape, [5, 2, 5, 5])
138    @parameterized.parameters(True, False)
139    def testUnknownChannels(self, autograph):
140      x = tf.TensorSpec([3, 3, 3, None], dtype=tf.float32)
141      c = conv.ConvND(
142          num_spatial_dims=2,
143          output_channels=1,
144          kernel_shape=3,
145          data_format="NHWC")
146      defun_conv = tf.function(c, autograph=autograph)
147      with self.assertRaisesRegex(ValueError,
148                                  "The number of input channels must be known"):
149        defun_conv.get_concrete_function(x)
150    def testUnknownSpatialDims(self):
151      x = tf.TensorSpec([3, None, None, 3], dtype=tf.float32)
152      c = conv.ConvND(
153          num_spatial_dims=2,
154          output_channels=1,
155          kernel_shape=3,
156          data_format="NHWC")
157      defun_conv = tf.function(c).get_concrete_function(x)
158      out = defun_conv(tf.ones([3, 5, 5, 3]))
159      expected_out = c(tf.ones([3, 5, 5, 3]))
160      self.assertEqual(out.shape, [3, 5, 5, 1])
161      self.assertAllEqual(self.evaluate(out), self.evaluate(expected_out))
162      out = defun_conv(tf.ones([3, 4, 4, 3]))
163      expected_out = c(tf.ones([3, 4, 4, 3]))
164      self.assertEqual(out.shape, [3, 4, 4, 1])
165      self.assertAllEqual(self.evaluate(out), self.evaluate(expected_out))
166  class Conv2DTest(test_utils.TestCase, parameterized.TestCase):
167    @parameterized.parameters(True, False)
168    def testComputationPaddingSame(self, with_bias):
169      expected_out = [[4, 6, 6, 6, 4], [6, 9, 9, 9, 6], [6, 9, 9, 9, 6],
170                      [6, 9, 9, 9, 6], [4, 6, 6, 6, 4]]
171      conv1 = conv.Conv2D(
172          output_channels=1,
173          kernel_shape=3,
174          stride=1,
175          padding="SAME",
176          with_bias=with_bias,
177          **create_constant_initializers(1.0, 1.0, with_bias))
178      out = conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
179      self.assertEqual(out.shape, [1, 5, 5, 1])
180      out = tf.squeeze(out, axis=(0, 3))
181      expected_out = np.asarray(expected_out, dtype=np.float32)
182      if with_bias:
183        expected_out += 1
184      self.assertAllClose(self.evaluate(out), expected_out)
185    @parameterized.parameters(True, False)
186    def testComputationPaddingValid(self, with_bias):
187      expected_out = [[9, 9, 9], [9, 9, 9], [9, 9, 9]]
188      conv1 = conv.Conv2D(
189          output_channels=1,
190          kernel_shape=3,
191          stride=1,
192          padding="VALID",
193          with_bias=with_bias,
194          **create_constant_initializers(1.0, 1.0, with_bias))
195      out = conv1(tf.ones([1, 5, 5, 1], dtype=tf.float32))
196      self.assertEqual(out.shape, [1, 3, 3, 1])
197      out = tf.squeeze(out, axis=(0, 3))
198      expected_out = np.asarray(expected_out, dtype=np.float32)
199      if with_bias:
200        expected_out += 1
201      self.assertAllClose(self.evaluate(out), expected_out)
202  class Conv1DTest(test_utils.TestCase, parameterized.TestCase):
203    @parameterized.parameters(True, False)
204    def testComputationPaddingSame(self, with_bias):
205      expected_out = [2, 3, 3, 3, 2]
206      conv1 = conv.Conv1D(
207          output_channels=1,
208          kernel_shape=3,
209          stride=1,
210          padding="SAME",
211          with_bias=with_bias,
212          **create_constant_initializers(1.0, 1.0, with_bias))
213      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
214      self.assertEqual(out.shape, [1, 5, 1])
215      out = tf.squeeze(out, axis=(0, 2))
216      expected_out = np.asarray(expected_out, dtype=np.float32)
217      if with_bias:
218        expected_out += 1
219      self.assertAllClose(self.evaluate(out), expected_out)
220    @parameterized.parameters(True, False)
221    def testComputationPaddingValid(self, with_bias):
222      expected_out = [3, 3, 3]
223      expected_out = np.asarray(expected_out, dtype=np.float32)
224      if with_bias:
225        expected_out += 1
226      conv1 = conv.Conv1D(
227          output_channels=1,
228          kernel_shape=3,
229          stride=1,
230          padding="VALID",
231          with_bias=with_bias,
232          **create_constant_initializers(1.0, 1.0, with_bias))
233      out = conv1(tf.ones([1, 5, 1], dtype=tf.float32))
234      self.assertEqual(out.shape, [1, 3, 1])
235      out = tf.squeeze(out, axis=(0, 2))
236      self.assertAllClose(self.evaluate(out), expected_out)
237  class Conv3DTest(test_utils.TestCase, parameterized.TestCase):
238    @parameterized.parameters(True, False)
239    def testComputationPaddingSame(self, with_bias):
240      expected_out = np.asarray([
241          9, 13, 13, 13, 9, 13, 19, 19, 19, 13, 13, 19, 19, 19, 13, 13, 19, 19,
242          19, 13, 9, 13, 13, 13, 9, 13, 19, 19, 19, 13, 19, 28, 28, 28, 19, 19,
243          28, 28, 28, 19, 19, 28, 28, 28, 19, 13, 19, 19, 19, 13, 13, 19, 19, 19,
244          13, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19, 13, 19,
245          19, 19, 13, 13, 19, 19, 19, 13, 19, 28, 28, 28, 19, 19, 28, 28, 28, 19,
246          19, 28, 28, 28, 19, 13, 19, 19, 19, 13, 9, 13, 13, 13, 9, 13, 19, 19,
247          19, 13, 13, 19, 19, 19, 13, 13, 19, 19, 19, 13, 9, 13, 13, 13, 9
248      ]).reshape((5, 5, 5))
249      if not with_bias:
250        expected_out -= 1
251      conv1 = conv.Conv3D(
252          output_channels=1,
253          kernel_shape=3,
254          stride=1,
255          padding="SAME",
256          with_bias=with_bias,
257          **create_constant_initializers(1.0, 1.0, with_bias))
258      out = conv1(tf.ones([1, 5, 5, 5, 1], dtype=tf.float32))
259      self.assertEqual(out.shape, [1, 5, 5, 5, 1])
260      out = tf.squeeze(out, axis=(0, 4))
261      self.assertAllClose(self.evaluate(out), expected_out)
262    @parameterized.parameters(True, False)
263    def testComputationPaddingValid(self, with_bias):
264      expected_out = np.asarray([
265          28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
266          28, 28, 28, 28, 28, 28, 28, 28, 28
267      ]).reshape((3, 3, 3))
268      if not with_bias:
269        expected_out -= 1
270      conv1 = conv.Conv3D(
271          output_channels=1,
272          kernel_shape=3,
273          stride=1,
274          padding="VALID",
275          with_bias=with_bias,
276          **create_constant_initializers(1.0, 1.0, with_bias))
277      out = conv1(tf.ones([1, 5, 5, 5, 1], dtype=tf.float32))
278      self.assertEqual(out.shape, [1, 3, 3, 3, 1])
279      out = tf.squeeze(out, axis=(0, 4))
280      self.assertAllClose(self.evaluate(out), expected_out)
281  if __name__ == "__main__":
282    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search_test.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_test.py</div>
                <div class="column column_space"><pre><code>72          lengths=tf.convert_to_tensor(
73              [2, 1, 2], dtype=tf.int32),
74          finished=tf.constant(
</pre></code></div>
                <div class="column column_space"><pre><code>127      x = tf.TensorSpec([None, 3, 5, 5], dtype=tf.float32)
128      c = conv.ConvND(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    