<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_docker_network.py &amp; test_mysql_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_docker_network.py &amp; test_mysql_2.py
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_docker_network.py (4.949054%)<th>test_mysql_2.py (2.905983%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(447-463)<td><a href="#" name="0">(50-145)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(397-407)<td><a href="#" name="1">(182-249)</a><td align="center"><font color="#b20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_docker_network.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Integration tests for the docker_network states
"""

import errno
import functools
import logging
import os
import subprocess
import tempfile

import pytest
import salt.utils.files
import salt.utils.network
import salt.utils.path
from salt.exceptions import CommandExecutionError
from tests.support.case import ModuleCase
from tests.support.docker import random_name, with_network
from tests.support.helpers import requires_system_grains
from tests.support.mixins import SaltReturnAssertsMixin
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import skipIf

log = logging.getLogger(__name__)


IMAGE_NAME = random_name(prefix="salt_busybox_")
IPV6_ENABLED = bool(salt.utils.network.ip_addrs6(include_loopback=True))


def network_name(func):
    """
    Generate a randomized name for a network and clean it up afterward
    """

    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        name = random_name(prefix="salt_net_")
        try:
            return func(self, name, *args, **kwargs)
        finally:
            self.run_function("docker.disconnect_all_containers_from_network", [name])
            try:
                self.run_function("docker.remove_network", [name])
            except CommandExecutionError as exc:
                if "No such network" not in exc.__str__():
                    raise

    return wrapper


def container_name(func):
    """
    Generate a randomized name for a container and clean it up afterward
    """

    def build_image():
        # Create temp dir
        image_build_rootdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        script_path = os.path.join(RUNTIME_VARS.BASE_FILES, "mkimage-busybox-static")
        cmd = [script_path, image_build_rootdir, IMAGE_NAME]
        log.debug("Running '%s' to build busybox image", " ".join(cmd))
        process = subprocess.Popen(
            cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        output = process.communicate()[0]
        log.debug("Output from mkimge-busybox-static:\n%s", output)

        if process.returncode != 0:
            raise Exception("Failed to build image")

        try:
            salt.utils.files.rm_rf(image_build_rootdir)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise

    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            self.run_function("docker.inspect_image", [IMAGE_NAME])
        except CommandExecutionError:
            pass
        else:
            build_image()

        name = random_name(prefix="salt_test_")
        self.run_function(
            "docker.create",
            name=name,
            image=IMAGE_NAME,
            command="sleep 600",
            start=True,
        )
        try:
            return func(self, name, *args, **kwargs)
        finally:
            try:
                self.run_function("docker.rm", [name], force=True)
            except CommandExecutionError as exc:
                if "No such container" not in exc.__str__():
                    raise

    return wrapper


@pytest.mark.destructive_test
@pytest.mark.slow_test
@skipIf(salt.utils.platform.is_freebsd(), "No Docker on FreeBSD available")
@skipIf(not salt.utils.path.which("dockerd"), "Docker not installed")
class DockerNetworkTestCase(ModuleCase, SaltReturnAssertsMixin):
    """
    Test docker_network states
    """

    @classmethod
    def tearDownClass(cls):
        """
        Remove test image if present. Note that this will run a docker rmi even
        if no test which required the image was run.
        """
        cmd = ["docker", "rmi", "--force", IMAGE_NAME]
        log.debug("Running '%s' to destroy busybox image", " ".join(cmd))
        process = subprocess.Popen(
            cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        output = process.communicate()[0]
        log.debug("Output from %s:\n%s", " ".join(cmd), output)

        if process.returncode != 0 and "No such image" not in str(output):
            raise Exception("Failed to destroy image")

    def run_state(self, function, **kwargs):
        ret = super().run_state(function, **kwargs)
        log.debug("ret = %s", ret)
        return ret

    @with_network(create=False)
    @pytest.mark.slow_test
    def test_absent(self, net):
        self.assertSaltTrueReturn(
            self.run_state("docker_network.present", name=net.name)
        )
        ret = self.run_state("docker_network.absent", name=net.name)
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        self.assertEqual(ret["changes"], {"removed": True})
        self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))

    @container_name
    @with_network(create=False)
    @pytest.mark.slow_test
    @pytest.mark.skipif(
        salt.utils.platform.is_photonos() is True,
        reason="Skip on PhotonOS.  No busybox available.",
    )
    def test_absent_with_disconnected_container(self, net, container_name):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present", name=net.name, containers=[container_name]
            )
        )
        ret = self.run_state("docker_network.absent", name=net.name)
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        self.assertEqual(
            ret["changes"], {"removed": True, "disconnected": [container_name]}
        )
        self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))

    @with_network(create=False)
    @pytest.mark.slow_test
    def test_absent_when_not_present(self, net):
        ret = self.run_state("docker_network.absent", name=net.name)
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]
        self.assertEqual(ret["changes"], {})
        self.assertEqual(ret["comment"], "Network '{}' already absent".format(net.name))

    @with_network(create=False)
    @pytest.mark.slow_test
    def test_present(self, net):
        ret = self.run_state("docker_network.present", name=net.name)
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        # Make sure the state return is what we expect
        self.assertEqual(ret["changes"], {"created": True})
        self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))

        # Now check to see that the network actually exists. If it doesn't,
        # this next function call will raise an exception.
        self.run_function("docker.inspect_network", [net.name])

    @container_name
    @with_network(create=False)
    @pytest.mark.slow_test
    @pytest.mark.skipif(
        salt.utils.platform.is_photonos() is True,
        reason="Skip on PhotonOS.  No busybox available.",
    )
    def test_present_with_containers(self, net, container_name):
        ret = self.run_state(
            "docker_network.present", name=net.name, containers=[container_name]
        )
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        self.assertEqual(
            ret["changes"], {"created": True, "connected": [container_name]}
        )
        self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))

        # Now check to see that the network actually exists. If it doesn't,
        # this next function call will raise an exception.
        self.run_function("docker.inspect_network", [net.name])

    def _test_present_reconnect(self, net, container_name, reconnect=True):
        ret = self.run_state("docker_network.present", name=net.name, driver="bridge")
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        self.assertEqual(ret["changes"], {"created": True})
        self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))

        # Connect the container
        self.run_function(
            "docker.connect_container_to_network", [container_name, net.name]
        )

        # Change the driver to force the network to be replaced
        ret = self.run_state(
            "docker_network.present",
            name=net.name,
            driver="macvlan",
            reconnect=reconnect,
        )
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        self.assertEqual(
            ret["changes"],
            {
                "recreated": True,
                "reconnected" if reconnect else "disconnected": [container_name],
                net.name: {"Driver": {"old": "bridge", "new": "macvlan"}},
            },
        )
        self.assertEqual(
            ret["comment"],
            "Network '{}' was replaced with updated config".format(net.name),
        )

    @container_name
    @with_network(create=False)
    @pytest.mark.slow_test
    @pytest.mark.skipif(
        salt.utils.platform.is_photonos() is True,
        reason="Skip on PhotonOS.  No busybox available.",
    )
    def test_present_with_reconnect(self, net, container_name):
        """
        Test reconnecting with containers not passed to state
        """
        self._test_present_reconnect(net, container_name, reconnect=True)

    @container_name
    @with_network(create=False)
    @pytest.mark.slow_test
    @pytest.mark.skipif(
        salt.utils.platform.is_photonos() is True,
        reason="Skip on PhotonOS.  No busybox available.",
    )
    def test_present_with_no_reconnect(self, net, container_name):
        """
        Test reconnecting with containers not passed to state
        """
        self._test_present_reconnect(net, container_name, reconnect=False)

    @with_network()
    @pytest.mark.slow_test
    def test_present_internal(self, net):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net.name,
                internal=True,
            )
        )
        net_info = self.run_function("docker.inspect_network", [net.name])
        self.assertIs(net_info["Internal"], True)

    @with_network()
    @pytest.mark.slow_test
    def test_present_labels(self, net):
        # Test a mix of different ways of specifying labels
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net.name,
                labels=["foo", "bar=baz", {"hello": "world"}],
            )
        )
        net_info = self.run_function("docker.inspect_network", [net.name])
        self.assertEqual(
            net_info["Labels"],
            {"foo": "", "bar": "baz", "hello": "world"},
        )

    @with_network(subnet="fe3f:2180:26:1::/123")
    @with_network(subnet="10.247.197.96/27")
    @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
    @pytest.mark.slow_test
    def test_present_enable_ipv6(self, net1, net2):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net1.name,
                enable_ipv6=True,
                ipam_pools=[{"subnet": net1.subnet}, {"subnet": net2.subnet}],
            )
        )
        net_info = self.run_function("docker.inspect_network", [net1.name])
        self.assertIs(net_info["EnableIPv6"], True)

    @requires_system_grains
    @with_network()
    @pytest.mark.slow_test
    def test_present_attachable(self, net, grains):
        if grains["os_family"] == "RedHat" and grains.get("osmajorrelease", 0) &lt;= 7:
            self.skipTest("Cannot reliably manage attachable on RHEL &lt;= 7")

        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net.name,
                attachable=True,
            )
        )
        net_info = self.run_function("docker.inspect_network", [net.name])
        self.assertIs(net_info["Attachable"], True)

    @skipIf(True, "Skip until we can set up docker swarm testing")
    @with_network()
    def test_present_scope(self, net):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net.name,
                scope="global",
            )
        )
        net_info = self.run_function("docker.inspect_network", [net.name])
        self.assertIs(net_info["Scope"], "global")

    @skipIf(True, "Skip until we can set up docker swarm testing")
    @with_network()
    def test_present_ingress(self, net):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net.name,
                ingress=True,
            )
        )
        net_info = self.run_function("docker.inspect_network", [net.name])
        self.assertIs(net_info["Ingress"], True)

    @with_network(subnet="10.247.197.128/27")
    @with_network(subnet="10.247.197.96/27")
    @pytest.mark.slow_test
    def test_present_with_custom_ipv4(self, net1, net2):
        # First run will test passing the IPAM arguments individually
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=net1.name,
                subnet=net1.subnet,
                gateway=net1.gateway,
            )
        )
        # Second run will pass them in the ipam_pools argument
        ret = self.run_state(
            "docker_network.present",
            name=net1.name,  # We want to keep the same network name
            ipam_pools=[{"subnet": net2.subnet, "gateway": net2.gateway}],
        )
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        # Docker requires there to be IPv4, even when only an IPv6 subnet was
<a name="1"></a>        # provided. So, there will be both an IPv4 and IPv6 pool in the
        # configuration.
        expected = {
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"recreated": True,
            net1.name: {
                "IPAM": {
                    "Config": {
                        "old": [{"Subnet": net1.subnet, "Gateway": net1.gateway}],
                        "new": [{"Subnet": net2.subnet, "Gateway": net2.gateway}],
                    }
                }
            },
        }
        self.</b></font>assertEqual(ret["changes"], expected)
        self.assertEqual(
            ret["comment"],
            "Network '{}' was replaced with updated config".format(net1.name),
        )

    @with_network(subnet="fe3f:2180:26:1::20/123")
    @with_network(subnet="fe3f:2180:26:1::/123")
    @with_network(subnet="10.247.197.96/27")
    @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
    @pytest.mark.slow_test
    def test_present_with_custom_ipv6(self, ipv4_net, ipv6_net1, ipv6_net2):
        self.assertSaltTrueReturn(
            self.run_state(
                "docker_network.present",
                name=ipv4_net.name,
                enable_ipv6=True,
                ipam_pools=[
                    {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
                    {"subnet": ipv6_net1.subnet, "gateway": ipv6_net1.gateway},
                ],
            )
        )

        ret = self.run_state(
            "docker_network.present",
            name=ipv4_net.name,  # We want to keep the same network name
            enable_ipv6=True,
            ipam_pools=[
                {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
                {"subnet": ipv6_net2.subnet, "gateway": ipv6_net2.gateway},
            ],
        )
        self.assertSaltTrueReturn(ret)
        ret = ret[next(iter(ret))]

        # Docker requires there to be IPv4, even when only an IPv6 subnet was
<a name="0"></a>        # provided. So, there will be both an IPv4 and IPv6 pool in the
        # configuration.
        expected = {
            <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"recreated": True,
            ipv4_net.name: {
                "IPAM": {
                    "Config": {
                        "old": [
                            {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
                            {"Subnet": ipv6_net1.subnet, "Gateway": ipv6_net1.gateway},
                        ],
                        "new": [
                            {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
                            {"Subnet": ipv6_net2.subnet, "Gateway": ipv6_net2.gateway},
                        ],
                    }
                }
            },
        }
        self.</b></font>assertEqual(ret["changes"], expected)
        self.assertEqual(
            ret["comment"],
            "Network '{}' was replaced with updated config".format(ipv4_net.name),
        )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mysql_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.pillar.mysql as mysql
from tests.support.unit import TestCase, skipIf


@skipIf(mysql.MySQLdb is None, "MySQL-python module not installed")
class MysqlPillarTestCase(TestCase):
    maxDiff = None

    def test_001_extract_queries_legacy(self):
        return_data = mysql.MySQLExtPillar()
        args, kwargs = ["SELECT blah"], {}
        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                [
                    None,
                    {
                        "query": "SELECT blah",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ]
            ],
            qbuffer,
        )

    def test_002_extract_queries_list(self):
        return_data = mysql.MySQLExtPillar()
        args, kwargs = (
            [
                "SELECT blah",
                "SELECT blah2",
                ("SELECT blah3",),
                ("SELECT blah4", 2),
                {"query": "SELECT blah5"},
                {"query": "SELECT blah6", "depth": 2},
                {"query": "SELECT blah7", "as_list": True},
                {"query": "SELECT blah8", "with_lists": "1"},
                {"query": "SELECT blah9", "with_lists": "1,2"},
                {"query": "SELECT json1", "as_json": True},
            ],
            {},
        )
<a name="0"></a>        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[
                    None,
                    {
                        "query": "SELECT blah",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah2",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah3",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah4",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah5",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah6",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah7",
                        "depth": 0,
                        "as_list": True,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah8",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": [1],
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah9",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": [1</b></font>, 2],
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT json1",
                        "depth": 0,
                        "as_list": False,
                        "as_json": True,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
            ],
            qbuffer,
        )

    def test_003_extract_queries_kwarg(self):
        return_data = mysql.MySQLExtPillar()
        args, kwargs = (
            [],
            {
                "1": "SELECT blah",
                "2": "SELECT blah2",
                "3": ("SELECT blah3",),
                "4": ("SELECT blah4", 2),
                "5": {"query": "SELECT blah5"},
                "6": {"query": "SELECT blah6", "depth": 2},
                "7": {"query": "SELECT blah7", "as_list": True},
                "8": {"query": "SELECT json1", "as_json": True},
            },
        )
<a name="1"></a>        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[
                    "1",
                    {
                        "query": "SELECT blah",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "2",
                    {
                        "query": "SELECT blah2",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "3",
                    {
                        "query": "SELECT blah3",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "4",
                    {
                        "query": "SELECT blah4",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "5",
                    {
                        "query": "SELECT blah5",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "6",
                    {
                        "query": "SELECT blah6",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "7"</b></font>,
                    {
                        "query": "SELECT blah7",
                        "depth": 0,
                        "as_list": True,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "8",
                    {
                        "query": "SELECT json1",
                        "depth": 0,
                        "as_list": False,
                        "as_json": True,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
            ],
            qbuffer,
        )

    def test_004_extract_queries_mixed(self):
        return_data = mysql.MySQLExtPillar()
        args, kwargs = (
            [
                "SELECT blah1",
                ("SELECT blah2", 2),
                {"query": "SELECT blah3", "as_list": True},
            ],
            {
                "1": "SELECT blah1",
                "2": ("SELECT blah2", 2),
                "3": {"query": "SELECT blah3", "as_list": True},
            },
        )
        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                [
                    None,
                    {
                        "query": "SELECT blah1",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah2",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah3",
                        "depth": 0,
                        "as_list": True,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "1",
                    {
                        "query": "SELECT blah1",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "2",
                    {
                        "query": "SELECT blah2",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "3",
                    {
                        "query": "SELECT blah3",
                        "depth": 0,
                        "as_list": True,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
            ],
            qbuffer,
        )

    def test_005_extract_queries_bogus_list(self):
        # This test is specifically checking that empty queries are dropped
        return_data = mysql.MySQLExtPillar()
        args, kwargs = (
            [
                "SELECT blah",
                "",
                "SELECT blah2",
                ("SELECT blah3",),
                ("",),
                ("SELECT blah4", 2),
                tuple(),
                ("SELECT blah5",),
                {"query": "SELECT blah6"},
                {"query": ""},
                {"query": "SELECT blah7", "depth": 2},
                {"not_a_query": "in sight!"},
                {"query": "SELECT blah8", "as_list": True},
            ],
            {},
        )
        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                [
                    None,
                    {
                        "query": "SELECT blah",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah2",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah3",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah4",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah5",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah6",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah7",
                        "depth": 2,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    None,
                    {
                        "query": "SELECT blah8",
                        "depth": 0,
                        "as_list": True,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
            ],
            qbuffer,
        )

    def test_006_extract_queries_bogus_kwargs(self):
        # this test is cut down as most of the path matches test_*_bogus_list
        return_data = mysql.MySQLExtPillar()
        args, kwargs = [], {"1": "SELECT blah", "2": "", "3": "SELECT blah2"}
        qbuffer = return_data.extract_queries(args, kwargs)
        self.assertEqual(
            [
                [
                    "1",
                    {
                        "query": "SELECT blah",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
                [
                    "3",
                    {
                        "query": "SELECT blah2",
                        "depth": 0,
                        "as_list": False,
                        "as_json": False,
                        "with_lists": None,
                        "ignore_null": False,
                    },
                ],
            ],
            qbuffer,
        )

    def test_011_enter_root(self):
        return_data = mysql.MySQLExtPillar()
        return_data.enter_root("test")
        self.assertEqual(return_data.result["test"], return_data.focus)
        return_data.enter_root(None)
        self.assertEqual(return_data.result, return_data.focus)

    def test_021_process_fields(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b"], 0)
        self.assertEqual(return_data.num_fields, 2)
        self.assertEqual(return_data.depth, 1)
        return_data.process_fields(["a", "b"], 2)
        self.assertEqual(return_data.num_fields, 2)
        self.assertEqual(return_data.depth, 1)
        return_data.process_fields(["a", "b", "c", "d"], 0)
        self.assertEqual(return_data.num_fields, 4)
        self.assertEqual(return_data.depth, 3)
        return_data.process_fields(["a", "b", "c", "d"], 1)
        self.assertEqual(return_data.num_fields, 4)
        self.assertEqual(return_data.depth, 1)
        return_data.process_fields(["a", "b", "c", "d"], 2)
        self.assertEqual(return_data.num_fields, 4)
        self.assertEqual(return_data.depth, 2)
        return_data.process_fields(["a", "b", "c", "d"], 3)
        self.assertEqual(return_data.num_fields, 4)
        self.assertEqual(return_data.depth, 3)
        return_data.process_fields(["a", "b", "c", "d"], 4)
        self.assertEqual(return_data.num_fields, 4)
        self.assertEqual(return_data.depth, 3)

    def test_111_process_results_legacy(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b"], 0)
        return_data.with_lists = []
        return_data.process_results([[1, 2]])
        self.assertEqual({1: 2}, return_data.result)

    def test_112_process_results_legacy_multiple(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b"], 0)
        return_data.with_lists = []
        return_data.process_results([[1, 2], [3, 4], [5, 6]])
        self.assertEqual({1: 2, 3: 4, 5: 6}, return_data.result)

    def test_121_process_results_depth_0(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [5, 6, 7, 8]])
        self.assertEqual({1: {2: {3: 4}}, 5: {6: {7: 8}}}, return_data.result)

    def test_122_process_results_depth_1(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 1)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [5, 6, 7, 8]])
        self.assertEqual(
            {1: {"b": 2, "c": 3, "d": 4}, 5: {"b": 6, "c": 7, "d": 8}},
            return_data.result,
        )

    def test_123_process_results_depth_2(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 2)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [5, 6, 7, 8]])
        self.assertEqual(
            {1: {2: {"c": 3, "d": 4}}, 5: {6: {"c": 7, "d": 8}}}, return_data.result
        )

    def test_124_process_results_depth_3(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 3)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [5, 6, 7, 8]])
        self.assertEqual({1: {2: {3: 4}}, 5: {6: {7: 8}}}, return_data.result)

    def test_125_process_results_depth_4(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 4)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [5, 6, 7, 8]])
        self.assertEqual({1: {2: {3: 4}}, 5: {6: {7: 8}}}, return_data.result)

    def test_131_process_results_overwrite_legacy_multiple(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b"], 0)
        return_data.with_lists = []
        return_data.process_results([[1, 2], [3, 4], [1, 6]])
        self.assertEqual({1: 6, 3: 4}, return_data.result)

    def test_132_process_results_merge_depth_0(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 6, 7, 8]])
        self.assertEqual({1: {2: {3: 4}, 6: {7: 8}}}, return_data.result)

    def test_133_process_results_overwrite_depth_0(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 2, 3, 8]])
        self.assertEqual({1: {2: {3: 8}}}, return_data.result)

    def test_134_process_results_deepmerge_depth_0(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 2, 7, 8]])
        self.assertEqual({1: {2: {3: 4, 7: 8}}}, return_data.result)

    def test_135_process_results_overwrite_depth_1(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 1)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 6, 7, 8]])
        self.assertEqual({1: {"b": 6, "c": 7, "d": 8}}, return_data.result)

    def test_136_process_results_merge_depth_2(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 2)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 6, 7, 8]])
        self.assertEqual(
            {1: {2: {"c": 3, "d": 4}, 6: {"c": 7, "d": 8}}}, return_data.result
        )

    def test_137_process_results_overwrite_depth_2(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 2)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4], [1, 2, 7, 8]])
        self.assertEqual({1: {2: {"c": 7, "d": 8}}}, return_data.result)

    def test_201_process_results_complexity_multiresults(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 2)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 7, 8]])
        self.assertEqual({1: {2: {"c": 7, "d": 8}}}, return_data.result)

    def test_202_process_results_complexity_as_list(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 2)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.as_list = True
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 7, 8]])
        self.assertEqual({1: {2: {"c": [3, 7], "d": [4, 8]}}}, return_data.result)

    def test_203_process_results_complexity_as_list_deeper(self):
        return_data = mysql.MySQLExtPillar()
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.as_list = True
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 3, 8]])
        self.assertEqual({1: {2: {3: [4, 8]}}}, return_data.result)

    def test_204_process_results_complexity_as_list_mismatch_depth(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = True
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 3, 5]])
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        self.assertEqual({1: {2: {3: [4, 5, {6: 7}]}}}, return_data.result)

    def test_205_process_results_complexity_as_list_mismatch_depth_reversed(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = True
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        return_data.process_results([[1, 2, 3, 8, 9]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 3, 5]])
        self.assertEqual({1: {2: {3: [{6: 7, 8: 9}, 4, 5]}}}, return_data.result)

    def test_206_process_results_complexity_as_list_mismatch_depth_weird_order(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = True
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 8, 9]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 5]])
        self.assertEqual({1: {2: {3: [{6: 7}, 4, {8: 9}, 5]}}}, return_data.result)

    def test_207_process_results_complexity_collision_mismatch_depth(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 3, 5]])
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        self.assertEqual({1: {2: {3: {6: 7}}}}, return_data.result)

    def test_208_process_results_complexity_collision_mismatch_depth_reversed(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        return_data.process_results([[1, 2, 3, 8, 9]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_results([[1, 2, 3, 5]])
        self.assertEqual({1: {2: {3: 5}}}, return_data.result)

    def test_209_process_results_complexity_collision_mismatch_depth_weird_order(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 8, 9]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 5]])
        self.assertEqual({1: {2: {3: 5}}}, return_data.result)

    def test_20A_process_results_complexity_as_list_vary(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = True
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e"], 0)
        return_data.process_results([[1, 2, 3, 6, 7]])
        return_data.process_results([[1, 2, 3, 8, 9]])
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.as_list = False
        return_data.process_results([[1, 2, 3, 5]])
        self.assertEqual({1: {2: {3: 5}}}, return_data.result)

    def test_207_process_results_complexity_roots_collision(self):
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = []
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d"], 0)
        return_data.process_results([[1, 2, 3, 4]])
        return_data.enter_root(1)
        return_data.process_results([[5, 6, 7, 8]])
        self.assertEqual({1: {5: {6: {7: 8}}}}, return_data.result)

    def test_301_process_results_with_lists(self):
        """
        Validates the following results:

          {'a': [
                {'c': [
                    {'e': 1},
                    {'g': 2}
                    ]
                },
                {'h': [
                    {'j': 3, 'k': 4}
                    ]
                }
          ]}
        """
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = [1, 3]
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e", "v"], 0)
        return_data.process_results(
            [
                ["a", "b", "c", "d", "e", 1],
                ["a", "b", "c", "f", "g", 2],
                ["a", "z", "h", "y", "j", 3],
                ["a", "z", "h", "y", "k", 4],
            ]
        )
        assert "a" in return_data.result
        for x in return_data.result["a"]:
            if "c" in x:
                assert list(x.keys()) == ["c"], x.keys()
                for y in x["c"]:
                    if "e" in y:
                        assert list(y.keys()) == ["e"]
                        assert y["e"] == 1
                    elif "g" in y:
                        assert list(y.keys()) == ["g"]
                        assert y["g"] == 2
                    else:
                        raise ValueError("Unexpected value {}".format(y))
            elif "h" in x:
                assert len(x["h"]) == 1
                for y in x["h"]:
                    if "j" in y:
                        assert len(y.keys()) == 2
                        assert y["j"] == 3
                    elif "h" in y:
                        assert len(y.keys()) == 2
                        assert y["k"] == 4
                    else:
                        raise ValueError("Unexpected value {}".format(y))
            else:
                raise ValueError("Unexpected value {}".format(x))

    def test_302_process_results_with_lists_consecutive(self):
        """
        Validates the following results:

          {'a': [
                [[
                    {'e': 1},
                    {'g': 2}
                    ]
                ],
                [[
                    {'j': 3, 'k': 4}
                    ]
                ]
          ]}
        """
        return_data = mysql.MySQLExtPillar()
        return_data.as_list = False
        return_data.with_lists = [1, 2, 3]
        return_data.enter_root(None)
        return_data.process_fields(["a", "b", "c", "d", "e", "v"], 0)
        return_data.process_results(
            [
                ["a", "b", "c", "d", "e", 1],
                ["a", "b", "c", "f", "g", 2],
                ["a", "z", "h", "y", "j", 3],
                ["a", "z", "h", "y", "k", 4],
            ]
        )

        assert "a" in return_data.result
        for x in return_data.result["a"]:
            assert len(x) == 1
            if len(x[0][0]) == 1:
                for y in x[0]:
                    if "e" in y:
                        assert list(y.keys()) == ["e"]
                        assert y["e"] == 1
                    elif "g" in y:
                        assert list(y.keys()) == ["g"]
                        assert y["g"] == 2
                    else:
                        raise ValueError("Unexpected value {}".format(y))
            elif len(x[0][0]) == 2:
                for y in x[0]:
                    if "j" in y:
                        assert len(y.keys()) == 2
                        assert y["j"] == 3
                    elif "k" in y:
                        assert len(y.keys()) == 2
                        assert y["k"] == 4
                    else:
                        raise ValueError("Unexpected value {}".format(len(x[0][0])))
            else:
                raise ValueError("Unexpected value {}".format(x))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
