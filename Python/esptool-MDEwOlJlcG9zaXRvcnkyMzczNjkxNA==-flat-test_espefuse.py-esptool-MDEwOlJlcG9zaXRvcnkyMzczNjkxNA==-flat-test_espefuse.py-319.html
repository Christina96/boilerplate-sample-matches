
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, &quot;images&quot;, &quot;efuse&quot;)
10  S_IMAGES_DIR = os.path.join(TEST_DIR, &quot;secure_images&quot;)
11  EFUSE_S_DIR = os.path.join(TEST_DIR, &quot;efuse_scripts&quot;)
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f&quot;{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}&quot;)
24  print(f&quot;\nHost tests of espefuse.py for {arg_chip}:&quot;)
25  print(&quot;Running espefuse.py tests...&quot;)
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
33                  f&quot;--virt --path-efuse-file {self.efuse_file.name} -d&quot;
34              )
35          else:
36              self.base_cmd = (
37                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
38                  f&quot;--port {arg_port} -d&quot;
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py(&quot;burn_efuse CODING_SCHEME 1&quot;)
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, &quot;rb&quot;) as f:
72              data = BitStream(&quot;0x00&quot;) * offset + BitStream(f)
73              blk = data.readlist(f&quot;{data.len // 8}*uint:8&quot;)
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = &quot; &quot;.join(f&quot;{num:02x}&quot; for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = &quot; &quot;.join((f&quot;{sys.executable} -m espefuse&quot;, cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = &quot; &quot;.join(
82              [self.base_cmd, &quot;--do-not-confirm&quot; if do_not_confirm else &quot;&quot;, cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              &quot; &quot;.join([self.base_cmd, &quot;check_error&quot;]), &quot;No errors detected&quot;, 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py(&quot;--help&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;)
114          self.espefuse_not_virt_py(f&quot;--chip {arg_chip} --help&quot;)
115      def test_help2(self):
116          self.espefuse_not_virt_py(&quot;&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;, ret_code=1)
117      def test_dump(self):
118          self.espefuse_py(&quot;dump -h&quot;)
119          self.espefuse_py(&quot;dump&quot;)
120      def test_summary(self):
121          self.espefuse_py(&quot;summary -h&quot;)
122          self.espefuse_py(&quot;summary&quot;)
123      def test_summary_json(self):
124          self.espefuse_py(&quot;summary --format json&quot;)
125      def test_get_custom_mac(self):
126          self.espefuse_py(&quot;get_custom_mac -h&quot;)
127          if arg_chip == &quot;esp32&quot;:
128              right_msg = &quot;Custom MAC Address is not set in the device.&quot;
129          else:
130              right_msg = &quot;Custom MAC Address: 00:00:00:00:00:00 (OK)&quot;
131          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=right_msg)
132      def test_adc_info(self):
133          self.espefuse_py(&quot;adc_info -h&quot;)
134          self.espefuse_py(&quot;adc_info&quot;)
135      def test_check_error(self):
136          self.espefuse_py(&quot;check_error -h&quot;)
137          self.espefuse_py(&quot;check_error&quot;)
138          self.espefuse_py(&quot;check_error --recovery&quot;)
139  class TestReadProtectionCommands(EfuseTestCase):
140      def test_read_protect_efuse(self):
141          self.espefuse_py(&quot;read_protect_efuse -h&quot;)
142          if arg_chip == &quot;esp32&quot;:
143              cmd = &quot;read_protect_efuse \
144                     CODING_SCHEME \
145                     MAC_VERSION \
146                     BLOCK1 \
147                     BLOCK2 \
148                     BLOCK3&quot;
149              count_protects = 5
150          elif arg_chip == &quot;esp32c2&quot;:
151              cmd = &quot;read_protect_efuse \
152                     BLOCK_KEY0_LOW_128&quot;
153              count_protects = 1
154          else:
155              self.espefuse_py(
156                  &quot;burn_efuse \
157                  KEY_PURPOSE_0 HMAC_UP \
158                  KEY_PURPOSE_1 XTS_AES_128_KEY \
159                  KEY_PURPOSE_2 XTS_AES_128_KEY \
160                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
161                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
162                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE&quot;
163              )
164              cmd = &quot;read_protect_efuse \
165                     BLOCK_KEY0 \
166                     BLOCK_KEY1 \
167                     BLOCK_KEY2 \
168                     BLOCK_KEY3 \
169                     BLOCK_KEY4 \
170                     BLOCK_KEY5&quot;
171              count_protects = 6
172          self.espefuse_py(cmd)
173          output = self.espefuse_py(cmd)
174          assert count_protects == output.count(&quot;is already read protected&quot;)
175      def test_read_protect_efuse2(self):
176          self.espefuse_py(&quot;write_protect_efuse RD_DIS&quot;)
177          if arg_chip == &quot;esp32&quot;:
178              efuse_name = &quot;CODING_SCHEME&quot;
179          elif arg_chip == &quot;esp32c2&quot;:
180              efuse_name = &quot;BLOCK_KEY0_HI_128&quot;
181          else:
182              efuse_name = &quot;BLOCK_SYS_DATA2&quot;
183          self.espefuse_py(
184              f&quot;read_protect_efuse {efuse_name}&quot;,
185              check_msg=&quot;A fatal error occurred: This efuse cannot be read-disabled &quot;
186              &quot;due the to RD_DIS field is already write-disabled&quot;,
187              ret_code=2,
188          )
189      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;when the purpose of BLOCK2 is set&quot;)
190      def test_read_protect_efuse3(self):
191          self.espefuse_py(&quot;burn_efuse ABS_DONE_1 1&quot;)
192          self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
193          self.espefuse_py(
194              &quot;read_protect_efuse BLOCK2&quot;,
195              check_msg=&quot;Secure Boot V2 is on (ABS_DONE_1 = True), &quot;
196              &quot;BLOCK2 must be readable, stop this operation!&quot;,
197              ret_code=2,
198          )
199      def test_read_protect_efuse4(self):
200          if arg_chip == &quot;esp32&quot;:
201              self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
202              msg = &quot;must be readable, please stop this operation!&quot;
203              self.espefuse_py(&quot;read_protect_efuse BLOCK2&quot;, check_msg=msg)
204          elif arg_chip == &quot;esp32c2&quot;:
205              self.espefuse_py(
206                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
207              )
208              self.espefuse_py(
209                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
210                  check_msg=&quot;A fatal error occurred: &quot;
211                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
212                  ret_code=2,
213              )
214          else:
215              self.espefuse_py(
216                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
217                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
218                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
219                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
220                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
221                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP&quot;
222              )
223              self.espefuse_py(
224                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
225                  check_msg=&quot;A fatal error occurred: &quot;
226                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
227                  ret_code=2,
228              )
229              self.espefuse_py(
230                  &quot;read_protect_efuse BLOCK_KEY1&quot;,
231                  check_msg=&quot;A fatal error occurred: &quot;
232                  &quot;BLOCK_KEY1 must be readable, stop this operation!&quot;,
233                  ret_code=2,
234              )
235              self.espefuse_py(
236                  &quot;read_protect_efuse BLOCK_KEY2&quot;,
237                  check_msg=&quot;A fatal error occurred: &quot;
238                  &quot;BLOCK_KEY2 must be readable, stop this operation!&quot;,
239                  ret_code=2,
240              )
241              self.espefuse_py(
242                  &quot;read_protect_efuse BLOCK_KEY3&quot;,
243                  check_msg=&quot;A fatal error occurred: &quot;
244                  &quot;BLOCK_KEY3 must be readable, stop this operation!&quot;,
245                  ret_code=2,
246              )
247              self.espefuse_py(
248                  &quot;read_protect_efuse BLOCK_KEY4&quot;,
249                  check_msg=&quot;A fatal error occurred: &quot;
250                  &quot;BLOCK_KEY4 must be readable, stop this operation!&quot;,
251                  ret_code=2,
252              )
253              self.espefuse_py(&quot;read_protect_efuse BLOCK_KEY5&quot;)
254      @pytest.mark.skipif(
255          arg_chip != &quot;esp32&quot;,
256          reason=&quot;system parameters efuse read-protection is supported only by esp32, &quot;
257          &quot;other chips protect whole blocks&quot;,
258      )
259      def test_burn_and_read_protect_efuse(self):
260          self.espefuse_py(
261              &quot;burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8&quot;,
262              check_msg=&quot;Efuse FLASH_CRYPT_CONFIG is read-protected. &quot;
263              &quot;Read back the burn value is not possible.&quot;,
264          )
265  class TestWriteProtectionCommands(EfuseTestCase):
266      def test_write_protect_efuse(self):
267          self.espefuse_py(&quot;write_protect_efuse -h&quot;)
268          if arg_chip == &quot;esp32&quot;:
269              efuse_lists = 
270              efuse_lists2 = &quot;WR_DIS RD_DIS&quot;
271          elif arg_chip == &quot;esp32c2&quot;:
272              efuse_lists = 
273              efuse_lists2 = &quot;RD_DIS DIS_DOWNLOAD_ICACHE&quot;
274          else:
275              efuse_lists = 
276              if arg_chip not in [&quot;esp32h2&quot;, &quot;esp32h2beta1&quot;] and arg_chip not in [
277                  &quot;esp32c6&quot;
278              ]:
279                  efuse_lists += 
280              efuse_lists2 = &quot;RD_DIS DIS_ICACHE&quot;
281          self.espefuse_py(f&quot;write_protect_efuse {efuse_lists}&quot;)
282          output = self.espefuse_py(f&quot;write_protect_efuse {efuse_lists2}&quot;)
283          assert output.count(&quot;is already write protected&quot;) == 2
284      def test_write_protect_efuse2(self):
285          if arg_chip == &quot;esp32&quot;:
286              self.espefuse_py(&quot;write_protect_efuse WR_DIS&quot;)
287              self.espefuse_py(
288                  &quot;write_protect_efuse CODING_SCHEME&quot;,
289                  check_msg=&quot;A fatal error occurred: This efuse cannot be write-disabled &quot;
290                  &quot;due to the WR_DIS field is already write-disabled&quot;,
291                  ret_code=2,
292              )
293  class TestBurnCustomMacCommands(EfuseTestCase):
294      def test_burn_custom_mac(self):
295          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
296          cmd = &quot;burn_custom_mac AA:CD:EF:11:22:33&quot;
297          mac = &quot;aa:cd:ef:11:22:33&quot;
298          if arg_chip == &quot;esp32&quot;:
299              self.espefuse_py(
300                  cmd, check_msg=f&quot;Custom MAC Address version 1: {mac} (CRC 0x63 OK)&quot;
301              )
302          else:
303              self.espefuse_py(cmd, check_msg=f&quot;Custom MAC Address: {mac} (OK)&quot;)
304      def test_burn_custom_mac2(self):
305          self.espefuse_py(
306              &quot;burn_custom_mac AA:CD:EF:11:22:33:44&quot;,
307              check_msg=&quot;A fatal error occurred: MAC Address needs to be a 6-byte &quot;
308              &quot;hexadecimal format separated by colons (:)!&quot;,
309              ret_code=2,
310          )
311      def test_burn_custom_mac3(self):
312          self.espefuse_py(
313              &quot;burn_custom_mac AB:CD:EF:11:22:33&quot;,
314              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
315              ret_code=2,
316          )
317      @pytest.mark.skipif(
318          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
319      )
320      def test_burn_custom_mac_with_34_coding_scheme(self):
321          self._set_34_coding_scheme()
322          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
323          self.espefuse_py(
324              &quot;burn_custom_mac AA:CD:EF:01:02:03&quot;,
325              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
326          )
327          self.espefuse_py(
328              &quot;get_custom_mac&quot;,
329              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
330          )
331          self.espefuse_py(
332              &quot;burn_custom_mac FE:22:33:44:55:66&quot;,
333              check_msg=&quot;New value contains some bits that cannot be cleared &quot;
334              &quot;(value will be 0x675745ffeffe)&quot;,
335              ret_code=2,
336          )
337  @pytest.mark.skipif(
338      arg_chip in [&quot;esp32c2&quot;, &quot;esp32h2beta1&quot;, &quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;],
339      reason=f&quot;TODO: add support set_flash_voltage for {arg_chip}&quot;,
340  )
341  class TestSetFlashVoltageCommands(EfuseTestCase):
342      def test_set_flash_voltage_1_8v(self):
343          self.espefuse_py(&quot;set_flash_voltage -h&quot;)
<span onclick='openModal()' class='match'>344          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
345          self.espefuse_py(
346              &quot;set_flash_voltage 1.8V&quot;,
347              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
348          )
349          if arg_chip == &quot;esp32&quot;:
</span>350              error_msg = &quot;A fatal error occurred: &quot;
351              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
352          else:
353              error_msg = &quot;A fatal error occurred: &quot;
354              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
355          self.espefuse_py(
356              &quot;set_flash_voltage 3.3V&quot;,
357              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
358          )
359          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
360      def test_set_flash_voltage_3_3v(self):
361          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
362          self.espefuse_py(
363              &quot;set_flash_voltage 3.3V&quot;,
364              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
365          )
366          if arg_chip == &quot;esp32&quot;:
367              error_msg = &quot;A fatal error occurred: &quot;
368              &quot;Can&#x27;t set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned&quot;
369          else:
370              error_msg = &quot;A fatal error occurred: &quot;
371              &quot;Can&#x27;t set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned&quot;
372          self.espefuse_py(&quot;set_flash_voltage 1.8V&quot;, check_msg=error_msg, ret_code=2)
373          if arg_chip == &quot;esp32&quot;:
374              error_msg = &quot;A fatal error occurred: &quot;
375              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
376          else:
377              error_msg = &quot;A fatal error occurred: &quot;
378              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
379          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
380      def test_set_flash_voltage_off(self):
381          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
382          self.espefuse_py(
383              &quot;set_flash_voltage OFF&quot;,
384              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
385          )
386          self.espefuse_py(
387              &quot;set_flash_voltage 3.3V&quot;,
388              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
389          )
390      def test_set_flash_voltage_off2(self):
391          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
392          self.espefuse_py(
393              &quot;set_flash_voltage OFF&quot;,
394              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
395          )
396          self.espefuse_py(
397              &quot;set_flash_voltage 1.8V&quot;,
398              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
399          )
400  @pytest.mark.skipif(arg_chip != &quot;esp32c3&quot;, reason=&quot;Not necessary fo all chips&quot;)
401  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
402      def test_efuse_is_bool_given_none(self):
403          self.espefuse_py(&quot;burn_efuse SECURE_BOOT_KEY_REVOKE0&quot;)
404      def test_efuse_is_bool_given_0(self):
405          self.espefuse_py(
406              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 0&quot;,
407              check_msg=&quot;A fatal error occurred: &quot;
408              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
409              &quot;(will always burn 0-&gt;1), given value=0&quot;,
410              ret_code=2,
411          )
412      def test_efuse_is_bool_given_2(self):
413          self.espefuse_py(
414              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 2&quot;,
415              check_msg=&quot;A fatal error occurred: &quot;
416              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
417              &quot;(will always burn 0-&gt;1), given value=2&quot;,
418              ret_code=2,
419          )
420      def test_efuse_is_bytes_ok(self):
421          self.espefuse_py(
422              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678&quot;
423          )
424      def test_efuse_is_bytes_given_short_val(self):
425          self.espefuse_py(
426              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678&quot;,
427              check_msg=&quot;A fatal error occurred: &quot;
428              &quot;The length of efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (128 bits) &quot;
429              &quot;(given len of the new value= 64 bits)&quot;,
430              ret_code=2,
431          )
432      def test_efuse_is_bytes_given_none(self):
433          self.espefuse_py(
434              &quot;burn_efuse OPTIONAL_UNIQUE_ID&quot;,
435              check_msg=&quot;A fatal error occurred: &quot;
436              &quot;New value required for efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (given None)&quot;,
437              ret_code=2,
438          )
439      def test_efuse_is_int_ok(self):
440          self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_D 7&quot;)
441      def test_efuse_is_int_given_out_of_range_val(self):
442          self.espefuse_py(
443              &quot;burn_efuse SPI_PAD_CONFIG_D 200&quot;,
444              check_msg=&quot;A fatal error occurred: &quot;
445              &quot;200 is too large an unsigned integer for a bitstring &quot;
446              &quot;of length 6. The allowed range is [0, 63].&quot;,
447              ret_code=2,
448          )
449      def test_efuse_is_int_given_none(self):
450          self.espefuse_py(
451              &quot;burn_efuse SPI_PAD_CONFIG_D&quot;,
452              check_msg=&quot;A fatal error occurred: &quot;
453              &quot;New value required for efuse &#x27;SPI_PAD_CONFIG_D&#x27; (given None)&quot;,
454              ret_code=2,
455          )
456      def test_efuse_is_int_given_0(self):
457          self.espefuse_py(
458              &quot;burn_efuse SPI_PAD_CONFIG_D 0&quot;,
459              check_msg=&quot;A fatal error occurred: &quot;
460              &quot;New value should not be 0 for &#x27;SPI_PAD_CONFIG_D&#x27; &quot;
461              &quot;(given value= 0)&quot;,
462              ret_code=2,
463          )
464      def test_efuse_is_bitcount_given_out_of_range_val(self):
465          self.espefuse_py(
466              &quot;burn_efuse SPI_BOOT_CRYPT_CNT 9&quot;,
467              check_msg=&quot;A fatal error occurred: &quot;
468              &quot;9 is too large an unsigned integer for a bitstring &quot;
469              &quot;of length 3. The allowed range is [0, 7].&quot;,
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_increase_over_max(self):
473          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
474          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
475          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
476          self.espefuse_py(
477              &quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;,
478              check_msg=&quot;A fatal error occurred: &quot;
479              &quot;15 is too large an unsigned integer for a bitstring &quot;
480              &quot;of length 3. The allowed range is [0, 7].&quot;,
481              ret_code=2,
482          )
483  class TestBurnEfuseCommands(EfuseTestCase):
484      @pytest.mark.skipif(
485          arg_chip != &quot;esp32&quot;,
486          reason=&quot;IO pins 30 &amp; 31 cannot be set for SPI flash only on esp32&quot;,
487      )
488      def test_set_spi_flash_pin_efuses(self):
489          self.espefuse_py(
490              &quot;burn_efuse SPI_PAD_CONFIG_HD 30&quot;,
491              check_msg=&quot;A fatal error occurred: &quot;
492              &quot;IO pins 30 &amp; 31 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
493              ret_code=2,
494          )
495          self.espefuse_py(
496              &quot;burn_efuse SPI_PAD_CONFIG_Q 0x23&quot;,
497              check_msg=&quot;A fatal error occurred: &quot;
498              &quot;IO pin 35 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
499              ret_code=2,
500          )
501          output = self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_CS0 33&quot;)
502          assert &quot;(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -&gt; 0b11111&quot; in output
503          assert &quot;BURN BLOCK0  - OK (all write block bits are set)&quot; in output
504      def test_burn_mac_custom_efuse(self):
505          crc_msg = &quot;(OK)&quot;
506          self.espefuse_py(&quot;burn_efuse -h&quot;)
507          if arg_chip == &quot;esp32&quot;:
508              self.espefuse_py(
509                  &quot;burn_efuse MAC AA:CD:EF:01:02:03&quot;,
510                  check_msg=&quot;Writing Factory MAC address is not supported&quot;,
511                  ret_code=2,
512              )
513              self.espefuse_py(&quot;burn_efuse MAC_VERSION 1&quot;)
514              crc_msg = &quot;(CRC 0x56 OK)&quot;
515          if arg_chip == &quot;esp32c2&quot;:
516              self.espefuse_py(&quot;burn_efuse CUSTOM_MAC_USED 1&quot;)
517          self.espefuse_py(&quot;burn_efuse -h&quot;)
518          self.espefuse_py(
519              &quot;burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03&quot;,
520              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
521              ret_code=2,
522          )
523          self.espefuse_py(&quot;burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03&quot;)
524          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=f&quot;aa:cd:ef:01:02:03 {crc_msg}&quot;)
525      def test_burn_efuse(self):
526          self.espefuse_py(&quot;burn_efuse -h&quot;)
527          if arg_chip == &quot;esp32&quot;:
528              self.espefuse_py(
529                  &quot;burn_efuse \
530                  CHIP_VER_REV2 1 \
531                  DISABLE_DL_ENCRYPT 1 \
532                  CONSOLE_DEBUG_DISABLE 1&quot;
533              )
534              blk1 = &quot;BLOCK1&quot;
535              blk2 = &quot;BLOCK2&quot;
536          elif arg_chip == &quot;esp32c2&quot;:
537              self.espefuse_py(
538                  &quot;burn_efuse \
539                  XTS_KEY_LENGTH_256 1 \
540                  UART_PRINT_CONTROL 1 \
541                  FORCE_SEND_RESUME 1&quot;
542              )
543              blk1 = &quot;BLOCK_KEY0&quot;
544              blk2 = None
545          else:
546              self.espefuse_py(
547                  &quot;burn_efuse \
548                  SECURE_BOOT_EN 1 \
549                  UART_PRINT_CONTROL 1&quot;
550              )
551              self.espefuse_py(
552                  &quot;burn_efuse \
553                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168&quot;,
554                  check_msg=&quot;-&gt; 0x2328ad5ac9145f698f843a26d6eae168&quot;,
555              )
556              output = self.espefuse_py(&quot;summary -d&quot;)
557              assert (
558                  &quot;read_regs: d6eae168 8f843a26 c9145f69 2328ad5a &quot;
559                  &quot;00000000 00000000 00000000 00000000&quot;
560              ) in output
561              assert &quot;= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W&quot; in output
562              efuse_from_blk2 = &quot;BLK_VERSION_MAJOR&quot;
563              if arg_chip == &quot;esp32s2&quot;:
564                  efuse_from_blk2 = &quot;BLK_VERSION_MINOR&quot;
565              if arg_chip != &quot;esp32c6&quot;:
566                  self.espefuse_py(
567                      f&quot;burn_efuse {efuse_from_blk2} 1&quot;,
568                      check_msg=&quot;Burn into BLOCK_SYS_DATA is forbidden &quot;
569                      &quot;(RS coding scheme does not allow this).&quot;,
570                      ret_code=2,
571                  )
572              blk1 = &quot;BLOCK_KEY1&quot;
573              blk2 = &quot;BLOCK_KEY2&quot;
574          output = self.espefuse_py(
575              f&quot;burn_efuse {blk1}&quot;
576              + &quot; 0x00010203040506070809111111111111111111111111111111110000112233FF&quot;
577          )
578          assert (
579              &quot;-&gt; 0x00010203040506070809111111111111111111111111111111110000112233ff&quot;
580              in output
581          )
582          output = self.espefuse_py(&quot;summary -d&quot;)
583          assert (
584              &quot;read_regs: 112233ff 11110000 11111111 11111111 &quot;
585              &quot;11111111 08091111 04050607 00010203&quot;
586          ) in output
587          assert (
588              &quot;= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 &quot;
589              &quot;11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W&quot;
590          ) in output
591          if blk2 is not None:
592              output = self.espefuse_py(
593                  f&quot;burn_efuse {blk2}&quot;
594                  + &quot; 00010203040506070809111111111111111111111111111111110000112233FF&quot;
595              )
596              assert (
597                  &quot;-&gt; 0xff33221100001111111111111111111111111111111109080706050403020100&quot;
598                  in output
599              )
600              output = self.espefuse_py(&quot;summary -d&quot;)
601              assert (
602                  &quot;read_regs: 03020100 07060504 11110908 11111111 &quot;
603                  &quot;11111111 11111111 00001111 ff332211&quot;
604              ) in output
605              assert (
606                  &quot;= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 &quot;
607                  &quot;11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W&quot;
608              ) in output
609      @pytest.mark.skipif(
610          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
611      )
612      def test_burn_efuse_with_34_coding_scheme(self):
613          self._set_34_coding_scheme()
614          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
615          self.espefuse_py(&quot;burn_efuse ADC1_TP_LOW 50&quot;)
616          self.espefuse_py(
617              &quot;burn_efuse ADC1_TP_HIGH 55&quot;,
618              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
619              &quot;(3/4 coding scheme does not allow this)&quot;,
620              ret_code=2,
621          )
622      @pytest.mark.skipif(
623          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
624      )
625      def test_burn_efuse_with_34_coding_scheme2(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
628          self.espefuse_py(
629              &quot;burn_efuse \
630              ADC1_TP_LOW 50 \
631              ADC1_TP_HIGH 55 \
632              ADC2_TP_LOW 40 \
633              ADC2_TP_HIGH 45&quot;
634          )
635  class TestBurnKeyCommands(EfuseTestCase):
636      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
637      def test_burn_key_3_key_blocks(self):
638          self.espefuse_py(&quot;burn_key -h&quot;)
639          self.espefuse_py(
640              f&quot;burn_key BLOCK1 {IMAGES_DIR}/192bit&quot;,
641              check_msg=&quot;A fatal error occurred: Incorrect key file size 24. &quot;
642              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
643              ret_code=2,
644          )
645          self.espefuse_py(
646              f&quot;burn_key \
647              BLOCK1 {IMAGES_DIR}/256bit \
648              BLOCK2 {IMAGES_DIR}/256bit_1 \
649              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key&quot;
650          )
651          output = self.espefuse_py(&quot;summary -d&quot;)
652          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
653          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
654          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
655          self.espefuse_py(
656              f&quot;burn_key \
657              BLOCK1 {IMAGES_DIR}/256bit \
658              BLOCK2 {IMAGES_DIR}/256bit_1 \
659              BLOCK3 {IMAGES_DIR}/256bit_2&quot;
660          )
661          output = self.espefuse_py(&quot;summary -d&quot;)
662          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
663          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
664          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
665      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
666      def test_burn_key_1_key_block(self):
667          self.espefuse_py(&quot;burn_key -h&quot;)
668          self.espefuse_py(
669              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY&quot;,
670              check_msg=&quot;A fatal error occurred: Incorrect key file size 16. &quot;
671              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
672              ret_code=2,
673          )
674          self.espefuse_py(
675              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect&quot;
676          )
677          output = self.espefuse_py(&quot;summary -d&quot;)
678          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
679          self.espefuse_py(f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;)
680          output = self.espefuse_py(&quot;summary -d&quot;)
681          assert (
682              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
683              &quot;00000000 00000000 00000000 00000000&quot;
684          ) in output
685          assert (
686              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
687              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
688          ) in output
689      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
690      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
691          self.espefuse_py(&quot;burn_key -h&quot;)
692          self.espefuse_py(
693              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
694              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;,
695              check_msg=&quot;A fatal error occurred: These keypurposes are incompatible &quot;
696              &quot;[&#x27;XTS_AES_128_KEY&#x27;, &#x27;SECURE_BOOT_DIGEST&#x27;]&quot;,
697              ret_code=2,
698          )
699          self.espefuse_py(
700              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
701              f&quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
702              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect&quot;
703          )
704          output = self.espefuse_py(&quot;summary -d&quot;)
705          assert (
706              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
707              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
708          ) in output
709          self.espefuse_py(
710              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
711              &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
712              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
713          )
714          output = self.espefuse_py(&quot;summary -d&quot;)
715          assert (
716              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
717              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
718          ) in output
719          assert (
720              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
721              &quot;00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-&quot;
722          ) in output
723          assert &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
724          assert &quot;= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-&quot; in output
725      @pytest.mark.skipif(
726          arg_chip
727          not in [
728              &quot;esp32s2&quot;,
729              &quot;esp32s3&quot;,
730              &quot;esp32s3beta1&quot;,
731              &quot;esp32c3&quot;,
732              &quot;esp32h2beta1&quot;,
733              &quot;esp32c6&quot;,
734              &quot;esp32h2&quot;,
735          ],
736          reason=&quot;Only chips with 6 keys&quot;,
737      )
738      def test_burn_key_with_6_keys(self):
739          cmd = f&quot;burn_key \
740                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
741                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
742                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY&quot;
743          if arg_chip in [&quot;esp32c3&quot;, &quot;esp32c6&quot;] or arg_chip in [
744              &quot;esp32h2&quot;,
745              &quot;esp32h2beta1&quot;,
746          ]:
747              cmd = cmd.replace(&quot;XTS_AES_256_KEY_1&quot;, &quot;XTS_AES_128_KEY&quot;)
748              cmd = cmd.replace(&quot;XTS_AES_256_KEY_2&quot;, &quot;XTS_AES_128_KEY&quot;)
749          self.espefuse_py(cmd + &quot; --no-read-protect --no-write-protect&quot;)
750          output = self.espefuse_py(&quot;summary -d&quot;)
751          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
752          self.check_data_block_in_log(
753              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
754          )
755          self.check_data_block_in_log(
756              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
757          )
758          self.espefuse_py(cmd)
759          output = self.espefuse_py(&quot;summary -d&quot;)
760          assert (
761              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
762              &quot;00000000 00000000 00000000 00000000&quot;
763          ) in output
764          assert (
765              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
766              &quot;00000000 00000000 00000000 00000000&quot;
767          ) in output
768          assert (
769              &quot;[6 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
770              &quot;00000000 00000000 00000000 00000000&quot;
771          ) in output
772          self.espefuse_py(
773              f&quot;burn_key \
774              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
775              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
776              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2&quot;
777          )
778          output = self.espefuse_py(&quot;summary -d&quot;)
779          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
780          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
781          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
782      @pytest.mark.skipif(
783          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
784      )
785      def test_burn_key_with_34_coding_scheme(self):
786          self._set_34_coding_scheme()
787          self.espefuse_py(
788              f&quot;burn_key BLOCK1 {IMAGES_DIR}/256bit&quot;,
789              check_msg=&quot;A fatal error occurred: Incorrect key file size 32. &quot;
790              &quot;Key file must be 24 bytes (192 bits) of raw binary key data.&quot;,
791              ret_code=2,
792          )
793          self.espefuse_py(
794              f&quot;burn_key \
795              BLOCK1 {IMAGES_DIR}/192bit \
796              BLOCK2 {IMAGES_DIR}/192bit_1 \
797              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key&quot;
798          )
799          output = self.espefuse_py(&quot;summary -d&quot;)
800          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
801          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
802          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
803          self.espefuse_py(
804              f&quot;burn_key \
805              BLOCK1 {IMAGES_DIR}/192bit \
806              BLOCK2 {IMAGES_DIR}/192bit_1 \
807              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
808          )
809          output = self.espefuse_py(&quot;summary -d&quot;)
810          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
811          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
812          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
813      @pytest.mark.skipif(
814          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
815          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
816      )
817      def test_burn_key_512bit(self):
818          self.espefuse_py(
819              f&quot;burn_key \
820              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
821              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
822          )
823          output = self.espefuse_py(&quot;summary -d&quot;)
824          self.check_data_block_in_log(
825              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
826          )
827          self.check_data_block_in_log(
828              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
829          )
830      @pytest.mark.skipif(
831          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
832          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
833      )
834      def test_burn_key_512bit_non_consecutive_blocks(self):
835          self.espefuse_py(
836              f&quot;burn_key \
837              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;
838          )
839          self.espefuse_py(
840              f&quot;burn_key \
841              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0&quot;
842          )
843          self.espefuse_py(
844              f&quot;burn_key \
845              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
846              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
847          )
848          self.espefuse_py(
849              f&quot;burn_key \
850              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect&quot;
851          )
852          output = self.espefuse_py(&quot;summary -d&quot;)
853          self.check_data_block_in_log(
854              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
855          )
856          self.check_data_block_in_log(
857              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
858          )
859          assert (
860              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 &quot;
861              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
862          ) in output
863          assert (
864              &quot;[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 &quot;
865              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
866          ) in output
867      @pytest.mark.skipif(
868          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
869          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
870      )
871      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
872          self.espefuse_py(
873              f&quot;burn_key \
874              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
875              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
876              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
877              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
878              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
879              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
880          )
881          output = self.espefuse_py(&quot;summary -d&quot;)
882          self.check_data_block_in_log(
883              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
884          )
885          self.check_data_block_in_log(
886              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
887          )
888          assert (
889              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
890              &quot;acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
891          ) in output
892          assert (
893              &quot;[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
894              &quot;acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
895          ) in output
896      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
897      def test_burn_key_ecdsa_key(self):
898          self.espefuse_py(
899              f&quot;burn_key \
900              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
901              ECDSA_KEY \
902              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
903              ECDSA_KEY&quot;
904          )
905          output = self.espefuse_py(&quot;summary -d&quot;)
906          assert 2 == output.count(
907              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
908              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
909          )
910          assert (
911              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
912              &quot;00000000 00000000 00000000 00000000&quot;
913          ) in output
914          assert (
915              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
916              &quot;00000000 00000000 00000000 00000000&quot;
917          ) in output
918      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
919      def test_burn_key_ecdsa_key_check_byte_order(self):
920          self.espefuse_py(
921              f&quot;burn_key \
922              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
923              ECDSA_KEY \
924              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
925              ECDSA_KEY \
926              --no-read-protect&quot;
927          )
928          output = self.espefuse_py(&quot;summary -d&quot;)
929          assert (
930              &quot;= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 &quot;
931              &quot;cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-&quot;
932          ) in output
933          assert (
934              &quot;= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b &quot;
935              &quot;38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-&quot;
936          ) in output
937          assert (
938              &quot;[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 &quot;
939              &quot;238123cb 4f71b795 00000000 00000000&quot;
940          ) in output
941          assert (
942              &quot;[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed &quot;
943              &quot;8450c238 c39d087a 90066a66 b4548b23&quot;
944          ) in output
945  class TestBurnBlockDataCommands(EfuseTestCase):
946      def test_burn_block_data_check_args(self):
947          self.espefuse_py(&quot;burn_block_data -h&quot;)
948          blk0 = &quot;BLOCK0&quot;
949          blk1 = &quot;BLOCK1&quot;
950          self.espefuse_py(
951              f&quot;burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}&quot;,
952              check_msg=&quot;A fatal error occurred: &quot;
953              &quot;The number of block_name (2) and datafile (1) should be the same.&quot;,
954              ret_code=2,
955          )
956      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
957      def test_burn_block_data_with_3_key_blocks(self):
958          self.espefuse_py(
959              f&quot;burn_block_data \
960              BLOCK0 {IMAGES_DIR}/224bit \
961              BLOCK3 {IMAGES_DIR}/256bit&quot;
962          )
963          output = self.espefuse_py(&quot;summary -d&quot;)
964          assert (
965              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
966              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
967          ) in output
968          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
969          self.espefuse_py(
970              f&quot;burn_block_data \
971              BLOCK2 {IMAGES_DIR}/256bit_1&quot;
972          )
973          self.check_data_block_in_log(
974              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
975          )
976          self.espefuse_py(
977              f&quot;burn_block_data \
978              BLOCK1 {IMAGES_DIR}/256bit_2&quot;
979          )
980          self.check_data_block_in_log(
981              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_2&quot;
982          )
983      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
984      def test_burn_block_data_with_1_key_block(self):
985          self.espefuse_py(
986              f&quot;burn_block_data \
987              BLOCK0 {IMAGES_DIR}/64bit \
988              BLOCK1 {IMAGES_DIR}/96bit \
989              BLOCK2 {IMAGES_DIR}/256bit \
990              BLOCK3 {IMAGES_DIR}/256bit&quot;
991          )
992          output = self.espefuse_py(&quot;summary -d&quot;)
993          assert &quot;[0 ] read_regs: 00000001 0000000c&quot; in output
994          assert &quot;[1 ] read_regs: 03020100 07060504 000a0908&quot; in output
995          assert (
996              &quot;[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
997              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
998          ) in output
999          assert (
1000              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1001              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1002          ) in output
1003      @pytest.mark.skipif(
1004          arg_chip
1005          not in [
1006              &quot;esp32s2&quot;,
1007              &quot;esp32s3&quot;,
1008              &quot;esp32s3beta1&quot;,
1009              &quot;esp32c3&quot;,
1010              &quot;esp32h2beta1&quot;,
1011              &quot;esp32c6&quot;,
1012              &quot;esp32h2&quot;,
1013          ],
1014          reason=&quot;Only chip with 6 keys&quot;,
1015      )
1016      def test_burn_block_data_with_6_keys(self):
1017          self.espefuse_py(
1018              f&quot;burn_block_data \
1019              BLOCK0 {IMAGES_DIR}/192bit \
1020              BLOCK3 {IMAGES_DIR}/256bit&quot;
1021          )
1022          output = self.espefuse_py(&quot;summary -d&quot;)
1023          assert (
1024              &quot;[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1025              in output
1026          )
1027          assert (
1028              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1029              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1030          ) in output
1031          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1032          self.espefuse_py(
1033              f&quot;burn_block_data \
1034              BLOCK10 {IMAGES_DIR}/256bit_1&quot;
1035          )
1036          self.check_data_block_in_log(
1037              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
1038          )
1039          self.espefuse_py(
1040              f&quot;burn_block_data \
1041              BLOCK1 {IMAGES_DIR}/192bit \
1042              BLOCK5 {IMAGES_DIR}/256bit_1 \
1043              BLOCK6 {IMAGES_DIR}/256bit_2&quot;
1044          )
1045          output = self.espefuse_py(&quot;summary -d&quot;)
1046          assert (
1047              &quot;[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1048              in output
1049          )
1050          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1051          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;, 2)
1052          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
1053      def test_burn_block_data_check_errors(self):
1054          self.espefuse_py(
1055              f&quot;burn_block_data \
1056              BLOCK2 {IMAGES_DIR}/192bit \
1057              BLOCK2 {IMAGES_DIR}/192bit_1&quot;,
1058              check_msg=&quot;A fatal error occurred: Found repeated&quot;,
1059              ret_code=2,
1060          )
1061          self.espefuse_py(
1062              f&quot;burn_block_data \
1063              BLOCK2 {IMAGES_DIR}/192bit \
1064              BLOCK3 {IMAGES_DIR}/192bit_1 \
1065              --offset 4&quot;,
1066              check_msg=&quot;A fatal error occurred: &quot;
1067              &quot;The &#x27;offset&#x27; option is not applicable when a few blocks are passed.&quot;,
1068              ret_code=2,
1069          )
1070          self.espefuse_py(
1071              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33&quot;,
1072              check_msg=&quot;A fatal error occurred: Invalid offset: the block0 only holds&quot;,
1073              ret_code=2,
1074          )
1075          self.espefuse_py(
1076              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4&quot;,
1077              check_msg=&quot;A fatal error occurred: Data does not fit:&quot;,
1078              ret_code=2,
1079          )
1080      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1081      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1082          offset = 1
1083          self.espefuse_py(
1084              f&quot;burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit&quot;
1085          )
1086          offset = 4
1087          self.espefuse_py(
1088              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1&quot;
1089          )
1090          self.check_data_block_in_log(
1091              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1092          )
1093          offset = 6
1094          self.espefuse_py(
1095              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2&quot;
1096          )
1097          self.check_data_block_in_log(
1098              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1099          )
1100          offset = 8
1101          self.espefuse_py(
1102              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1103          )
1104          self.check_data_block_in_log(
1105              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1106          )
1107      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1108      def test_burn_block_data_with_offset_1_key_block(self):
1109          offset = 4
1110          self.espefuse_py(f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit&quot;)
1111          output = self.espefuse_py(&quot;summary -d&quot;)
1112          assert &quot;[1 ] read_regs: 00000000 03020100 00060504&quot; in output
1113          offset = 6
1114          self.espefuse_py(
1115              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1&quot;
1116          )
1117          output = self.espefuse_py(&quot;summary -d&quot;)
1118          assert (
1119              &quot;[2 ] read_regs: 00000000 00110000 05000000 09080706 &quot;
1120              &quot;0d0c0b0a 11100f0e 15141312 00002116&quot;
1121          ) in output
1122          offset = 8
1123          self.espefuse_py(
1124              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1125          )
1126          self.check_data_block_in_log(
1127              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1128          )
1129      @pytest.mark.skipif(
1130          arg_chip
1131          not in [
1132              &quot;esp32s2&quot;,
1133              &quot;esp32s3&quot;,
1134              &quot;esp32s3beta1&quot;,
1135              &quot;esp32c3&quot;,
1136              &quot;esp32h2beta1&quot;,
1137              &quot;esp32c6&quot;,
1138              &quot;esp32h2&quot;,
1139          ],
1140          reason=&quot;Only chips with 6 keys&quot;,
1141      )
1142      def test_burn_block_data_with_offset_6_keys(self):
1143          offset = 4
1144          self.espefuse_py(
1145              f&quot;burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1&quot;
1146          )
1147          self.check_data_block_in_log(
1148              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1149          )
1150          offset = 6
1151          self.espefuse_py(
1152              f&quot;burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2&quot;
1153          )
1154          self.check_data_block_in_log(
1155              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1156          )
1157          offset = 8
1158          self.espefuse_py(
1159              f&quot;burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2&quot;
1160          )
1161          self.check_data_block_in_log(
1162              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1163          )
1164      @pytest.mark.skipif(
1165          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1166      )
1167      def test_burn_block_data_with_34_coding_scheme(self):
1168          self._set_34_coding_scheme()
1169          self.espefuse_py(
1170              f&quot;burn_block_data BLOCK1 {IMAGES_DIR}/256bit&quot;,
1171              check_msg=&quot;A fatal error occurred: Data does not fit: &quot;
1172              &quot;the block1 size is 24 bytes, data file is 32 bytes, offset 0&quot;,
1173              ret_code=2,
1174          )
1175          self.espefuse_py(
1176              f&quot;burn_block_data \
1177              BLOCK1 {IMAGES_DIR}/192bit \
1178              BLOCK2 {IMAGES_DIR}/192bit_1 \
1179              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1180          )
1181          output = self.espefuse_py(&quot;summary -d&quot;)
1182          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
1183          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
1184          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
1185      @pytest.mark.skipif(
1186          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1187      )
1188      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1189          self._set_34_coding_scheme()
1190          offset = 4
1191          self.espefuse_py(
1192              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit&quot;
1193          )
1194          self.check_data_block_in_log(
1195              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1196          )
1197          offset = 6
1198          self.espefuse_py(
1199              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit&quot;
1200          )
1201          self.check_data_block_in_log(
1202              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1203          )
1204          offset = 8
1205          self.espefuse_py(
1206              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit&quot;
1207          )
1208          self.check_data_block_in_log(
1209              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1210          )
1211  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only, supports 2 key blocks&quot;)
1212  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1213      def test_burn_key_digest(self):
1214          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1215          esp = self.get_esptool()
1216          if esp.get_chip_revision() &gt;= 300:
1217              self.espefuse_py(
1218                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1219              )
1220              output = self.espefuse_py(&quot;summary -d&quot;)
1221              assert (
1222                  &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1223                  &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1224              ) in output
1225          else:
1226              self.espefuse_py(
1227                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1228                  check_msg=&quot;Incorrect chip revision for Secure boot v2.&quot;,
1229                  ret_code=2,
1230              )
1231      def test_burn_key_from_digest(self):
1232          self.espefuse_py(
1233              f&quot;burn_key \
1234              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key&quot;
1235          )
1236          output = self.espefuse_py(&quot;summary -d&quot;)
1237          assert 1 == output.count(
1238              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1239              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W&quot;
1240          )
1241      def test_burn_key_digest_with_34_coding_scheme(self):
1242          self._set_34_coding_scheme()
1243          self.espefuse_py(
1244              f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1245              check_msg=&quot;burn_key_digest only works with &#x27;None&#x27; coding scheme&quot;,
1246              ret_code=2,
1247          )
1248  @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only, supports 1 key block&quot;)
1249  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1250      def test_burn_key_digest1(self):
1251          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1252          self.espefuse_py(
1253              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem&quot;
1254          )
1255          output = self.espefuse_py(&quot;summary -d&quot;)
1256          assert &quot; = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot; in output
1257          assert (
1258              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1259              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1260          ) in output
1261      def test_burn_key_digest2(self):
1262          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1263          self.espefuse_py(
1264              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1265          )
1266          output = self.espefuse_py(&quot;summary -d&quot;)
1267          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1268          assert (
1269              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1270              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1271          ) in output
1272      def test_burn_key_from_digest1(self):
1273          self.espefuse_py(
1274              &quot;burn_key BLOCK_KEY0 &quot;
1275              f&quot;{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1276          )
1277          output = self.espefuse_py(&quot;summary -d&quot;)
1278          assert (
1279              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1280              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1281          ) in output
1282      def test_burn_key_from_digest2(self):
1283          self.espefuse_py(
1284              &quot;burn_key BLOCK_KEY0 &quot;
1285              f&quot;{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1286          )
1287          output = self.espefuse_py(&quot;summary -d&quot;)
1288          assert (
1289              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1290              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1291          ) in output
1292  @pytest.mark.skipif(
1293      arg_chip
1294      not in [
1295          &quot;esp32s2&quot;,
1296          &quot;esp32s3&quot;,
1297          &quot;esp32s3beta1&quot;,
1298          &quot;esp32c3&quot;,
1299          &quot;esp32h2beta1&quot;,
1300          &quot;esp32c6&quot;,
1301          &quot;esp32h2&quot;,
1302      ],
1303      reason=&quot;Supports 6 key blocks&quot;,
1304  )
1305  class TestBurnKeyDigestCommands(EfuseTestCase):
1306      def test_burn_key_digest(self):
1307          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1308          self.espefuse_py(
1309              f&quot;burn_key_digest \
1310              BLOCK_KEY0 \
1311              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1312              BLOCK_KEY1 \
1313              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1314              BLOCK_KEY2 &quot;,
1315              check_msg=&quot;A fatal error occurred: The number of blocks (3), &quot;
1316              &quot;datafile (2) and keypurpose (2) should be the same.&quot;,
1317              ret_code=2,
1318          )
1319          self.espefuse_py(
1320              f&quot;burn_key_digest \
1321              BLOCK_KEY0 \
1322              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1323              BLOCK_KEY1 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1325              BLOCK_KEY2 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2&quot;
1327          )
1328          output = self.espefuse_py(&quot;summary -d&quot;)
1329          assert 1 == output.count(
1330              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1331              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1332          )
1333          assert 2 == output.count(
1334              &quot; = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 &quot;
1335              &quot;6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-&quot;
1336          )
1337      def test_burn_key_from_digest(self):
1338          self.espefuse_py(
1339              f&quot;burn_key \
1340              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1341          )
1342          output = self.espefuse_py(&quot;summary -d&quot;)
1343          assert 1 == output.count(
1344              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1345              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1346          )
1347          self.espefuse_py(
1348              f&quot;burn_key_digest \
1349              BLOCK_KEY1 \
1350              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1&quot;
1351          )
1352          output = self.espefuse_py(&quot;summary -d&quot;)
1353          assert 2 == output.count(
1354              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1355              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1356          )
1357  class TestBurnBitCommands(EfuseTestCase):
1358      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1359      def test_burn_bit_for_chips_with_3_key_blocks(self):
1360          self.espefuse_py(&quot;burn_bit -h&quot;)
1361          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1362          self.espefuse_py(
1363              &quot;summary&quot;,
1364              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 &quot;
1365              &quot;00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1366          )
1367          self.espefuse_py(
1368              &quot;burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254&quot;
1369          )
1370          self.espefuse_py(
1371              &quot;summary&quot;,
1372              check_msg=&quot;ff ff 01 80 01 00 00 80 01 00 00 80 01 &quot;
1373              &quot;00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0&quot;,
1374          )
1375      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1376      def test_burn_bit_for_chips_with_1_key_block(self):
1377          self.espefuse_py(&quot;burn_bit -h&quot;)
1378          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1379          self.espefuse_py(
1380              &quot;summary&quot;,
1381              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1382              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1383          )
1384          self.espefuse_py(
1385              &quot;burn_bit BLOCK3 100&quot;,
1386              check_msg=&quot;Burn into BLOCK_KEY0 is forbidden &quot;
1387              &quot;(RS coding scheme does not allow this)&quot;,
1388              ret_code=2,
1389          )
1390          self.espefuse_py(&quot;burn_bit BLOCK0 0 1 2&quot;)
1391          self.espefuse_py(&quot;summary&quot;, check_msg=&quot;[0 ] read_regs: 00000007 00000000&quot;)
1392      @pytest.mark.skipif(
1393          arg_chip
1394          not in [
1395              &quot;esp32s2&quot;,
1396              &quot;esp32s3&quot;,
1397              &quot;esp32s3beta1&quot;,
1398              &quot;esp32c3&quot;,
1399              &quot;esp32h2beta1&quot;,
1400              &quot;esp32c6&quot;,
1401              &quot;esp32h2&quot;,
1402          ],
1403          reason=&quot;Only chip with 6 keys&quot;,
1404      )
1405      def test_burn_bit_for_chips_with_6_key_blocks(self):
1406          self.espefuse_py(&quot;burn_bit -h&quot;)
1407          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1408          self.espefuse_py(
1409              &quot;summary&quot;,
1410              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1411              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1412          )
1413          self.espefuse_py(
1414              &quot;burn_bit BLOCK3 100&quot;,
1415              check_msg=&quot;Burn into BLOCK_USR_DATA is forbidden &quot;
1416              &quot;(RS coding scheme does not allow this)&quot;,
1417              ret_code=2,
1418          )
1419          self.espefuse_py(&quot;burn_bit BLOCK0 13&quot;)
1420          self.espefuse_py(
1421              &quot;summary&quot;,
1422              check_msg=&quot;[0 ] read_regs: 00002000 00000000 00000000 &quot;
1423              &quot;00000000 00000000 00000000&quot;,
1424          )
1425          self.espefuse_py(&quot;burn_bit BLOCK0 24&quot;)
1426          self.espefuse_py(
1427              &quot;summary&quot;,
1428              check_msg=&quot;[0 ] read_regs: 01002000 00000000 00000000 &quot;
1429              &quot;00000000 00000000 00000000&quot;,
1430          )
1431      @pytest.mark.skipif(
1432          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1433      )
1434      def test_burn_bit_with_34_coding_scheme(self):
1435          self._set_34_coding_scheme()
1436          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191&quot;)
1437          self.espefuse_py(
1438              &quot;summary&quot;,
1439              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1440              &quot;00 00 01 00 00 00 01 00 00 80&quot;,
1441          )
1442          self.espefuse_py(
1443              &quot;burn_bit BLOCK3 17&quot;,
1444              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
1445              &quot;(3/4 coding scheme does not allow this).&quot;,
1446              ret_code=2,
1447          )
1448  @pytest.mark.skipif(
1449      arg_chip != &quot;esp32&quot;, reason=&quot;Tests are only for esp32. (TODO: add for all chips)&quot;
1450  )
1451  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1452      def test_1_secure_boot_v1(self):
1453          if arg_chip == &quot;esp32&quot;:
1454              self.espefuse_py(
1455                  f&quot;burn_key \
1456                  flash_encryption {IMAGES_DIR}/256bit \
1457                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1458              )
1459              output = self.espefuse_py(&quot;summary -d&quot;)
1460              self.check_data_block_in_log(
1461                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1462              )
1463              self.check_data_block_in_log(
1464                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
1465              )
1466              self.espefuse_py(
1467                  f&quot;burn_key \
1468                  flash_encryption  {IMAGES_DIR}/256bit \
1469                  secure_boot_v1    {IMAGES_DIR}/256bit_1&quot;
1470              )
1471              output = self.espefuse_py(&quot;summary -d&quot;)
1472              assert (
1473                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1474                  &quot;00000000 00000000 00000000 00000000&quot;
1475              ) in output
1476              assert (
1477                  &quot;[2 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1478                  &quot;00000000 00000000 00000000 00000000&quot;
1479              ) in output
1480              assert (
1481                  &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1482                  &quot;00000000 00000000 00000000 00000000&quot;
1483              ) in output
1484      def test_2_secure_boot_v1(self):
1485          if arg_chip == &quot;esp32&quot;:
1486              self.espefuse_py(
1487                  f&quot;burn_key \
1488                  flash_encryption {IMAGES_DIR}/256bit \
1489                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1490              )
1491              output = self.espefuse_py(&quot;summary -d&quot;)
1492              self.check_data_block_in_log(
1493                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1494              )
1495              self.check_data_block_in_log(
1496                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1497              )
1498              self.espefuse_py(
1499                  f&quot;burn_key \
1500                  flash_encryption {IMAGES_DIR}/256bit \
1501                  secure_boot_v2 {IMAGES_DIR}/256bit_1&quot;
1502              )
1503              output = self.espefuse_py(&quot;summary -d&quot;)
1504              assert (
1505                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1506                  &quot;00000000 00000000 00000000 00000000&quot;
1507              ) in output
1508              self.check_data_block_in_log(
1509                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1510              )
1511  class TestExecuteScriptsCommands(EfuseTestCase):
1512      @classmethod
1513      def setup_class(self):
1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
1518      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1519      def test_execute_scripts_with_check_that_only_one_burn(self):
1520          self.espefuse_py(&quot;execute_scripts -h&quot;)
1521          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1522          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1523          self.espefuse_py(&quot;execute_scripts execute_efuse_script2.py&quot;)
1524      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1525      def test_execute_scripts_with_check(self):
1526          self.espefuse_py(&quot;execute_scripts -h&quot;)
1527          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1528          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1529          self.espefuse_py(&quot;execute_scripts execute_efuse_script.py&quot;)
1530      def test_execute_scripts_with_index_and_config(self):
1531          os.chdir(TEST_DIR)
1532          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1533              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1534              --configfiles {EFUSE_S_DIR}/esp32/config1.json&quot;
1535          else:
1536              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1537              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json&quot;
1538          self.espefuse_py(cmd)
1539          output = self.espefuse_py(&quot;summary -d&quot;)
1540          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1541              assert (
1542                  &quot;[3 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1543                  &quot;00000000 00000000 00000000 00000000&quot;
1544              ) in output
1545          else:
1546              assert (
1547                  &quot;[8 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1548                  &quot;00000000 00000000 00000000 00000000&quot;
1549              ) in output
1550      def test_execute_scripts_nesting(self):
1551          os.chdir(TEST_DIR)
1552          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1553              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1554              --configfiles {EFUSE_S_DIR}/esp32/config2.json&quot;
1555          else:
1556              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1557              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json&quot;
1558          self.espefuse_py(cmd)
1559          output = self.espefuse_py(&quot;summary -d&quot;)
1560          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1561              assert (
1562                  &quot;[2 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1563                  &quot;00000000 00000000 00000000 00000000&quot;
1564              ) in output
1565              assert (
1566                  &quot;[3 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1567                  &quot;00000000 00000000 00000000 00000000&quot;
1568              ) in output
1569          else:
1570              assert (
1571                  &quot;[7 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1572                  &quot;00000000 00000000 00000000 00000000&quot;
1573              ) in output
1574              assert (
1575                  &quot;[8 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1576                  &quot;00000000 00000000 00000000 00000000&quot;
1577              ) in output
1578  class TestMultipleCommands(EfuseTestCase):
1579      def test_multiple_cmds_help(self):
1580          if arg_chip == &quot;esp32c2&quot;:
1581              command1 = (
1582                  f&quot;burn_key_digest {S_IMAGES_DIR}&quot;
1583                  &quot;/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1584              )
1585              command2 = (
1586                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
1587                  &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS&quot;
1588              )
1589          elif arg_chip == &quot;esp32&quot;:
1590              command1 = f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1591              command2 = f&quot;burn_key flash_encryption {IMAGES_DIR}/256bit&quot;
1592          else:
1593              command1 = f&quot;burn_key_digest BLOCK_KEY0 \
1594              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0&quot;
1595              command2 = f&quot;burn_key BLOCK_KEY0 \
1596              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1597          self.espefuse_py(
1598              f&quot;-h {command1} {command2}&quot;,
1599              check_msg=&quot;usage: __main__.py [-h]&quot;,
1600          )
1601          self.espefuse_py(
1602              f&quot;{command1} -h {command2}&quot;,
1603              check_msg=&quot;usage: __main__.py burn_key_digest [-h]&quot;,
1604          )
1605          self.espefuse_py(
1606              f&quot;{command1} {command2} -h&quot;,
1607              check_msg=&quot;usage: __main__.py burn_key [-h]&quot;,
1608          )
1609      @pytest.mark.skipif(
1610          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1611      )
1612      def test_1_esp32c2(self):
1613          self.espefuse_py(
1614              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1615              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1616              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1617              summary&quot;
1618          )
1619          output = self.espefuse_py(&quot;summary -d&quot;)
1620          assert (
1621              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
1622              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1623          ) in output
1624          assert &quot; = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-&quot; in output
1625          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1626      @pytest.mark.skipif(
1627          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1628      )
1629      def test_2_esp32c2(self):
1630          self.espefuse_py(
1631              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1632              burn_key BLOCK_KEY0 \
1633              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1634              summary&quot;
1635          )
1636          output = self.espefuse_py(&quot;summary -d&quot;)
1637          assert (
1638              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1639              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1640          ) in output
1641          assert &quot; = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
1642          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1643      def test_burn_bit(self):
1644          if arg_chip == &quot;esp32&quot;:
1645              self._set_34_coding_scheme()
1646          self.espefuse_py(
1647              &quot;burn_bit BLOCK2 0 1 2 3 \
1648              burn_bit BLOCK2 4 5 6 7 \
1649              burn_bit BLOCK2 8 9 10 11 \
1650              burn_bit BLOCK2 12 13 14 15 \
1651              summary&quot;
1652          )
1653          output = self.espefuse_py(&quot;summary -d&quot;)
1654          assert &quot;[2 ] read_regs: 0000ffff 00000000&quot; in output
1655      def test_not_burn_cmds(self):
1656          self.espefuse_py(
1657              &quot;summary \
1658              dump \
1659              get_custom_mac \
1660              adc_info \
1661              check_error&quot;
1662          )
1663  @pytest.mark.skipif(
1664      arg_chip not in [&quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;, &quot;esp32s3&quot;],
1665      reason=&quot;These chips have a hardware bug that limits the use of the KEY5&quot;,
1666  )
1667  class TestKeyPurposes(EfuseTestCase):
1668      def test_burn_xts_aes_key_purpose(self):
1669          self.espefuse_py(
1670              &quot;burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY&quot;,
1671              check_msg=&quot;A fatal error occurred: &quot;
1672              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1673              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1674              ret_code=2,
1675          )
1676      @pytest.mark.skipif(
1677          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1678      )
1679      def test_burn_ecdsa_key_purpose(self):
1680          self.espefuse_py(
1681              &quot;burn_efuse KEY_PURPOSE_5 ECDSA_KEY&quot;,
1682              check_msg=&quot;A fatal error occurred: &quot;
1683              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1684              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1685              ret_code=2,
1686          )
1687      def test_burn_xts_aes_key(self):
1688          self.espefuse_py(
1689              f&quot;burn_key \
1690              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;,
1691              check_msg=&quot;A fatal error occurred: &quot;
1692              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1693              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1694              ret_code=2,
1695          )
1696      @pytest.mark.skipif(
1697          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1698      )
1699      def test_burn_ecdsa_key(self):
1700          self.espefuse_py(
1701              f&quot;burn_key \
1702              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1703              ECDSA_KEY&quot;,
1704              check_msg=&quot;A fatal error occurred: &quot;
1705              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1706              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1707              ret_code=2,
1708          )
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, &quot;images&quot;, &quot;efuse&quot;)
10  S_IMAGES_DIR = os.path.join(TEST_DIR, &quot;secure_images&quot;)
11  EFUSE_S_DIR = os.path.join(TEST_DIR, &quot;efuse_scripts&quot;)
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f&quot;{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}&quot;)
24  print(f&quot;\nHost tests of espefuse.py for {arg_chip}:&quot;)
25  print(&quot;Running espefuse.py tests...&quot;)
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
33                  f&quot;--virt --path-efuse-file {self.efuse_file.name} -d&quot;
34              )
35          else:
36              self.base_cmd = (
37                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
38                  f&quot;--port {arg_port} -d&quot;
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py(&quot;burn_efuse CODING_SCHEME 1&quot;)
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, &quot;rb&quot;) as f:
72              data = BitStream(&quot;0x00&quot;) * offset + BitStream(f)
73              blk = data.readlist(f&quot;{data.len // 8}*uint:8&quot;)
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = &quot; &quot;.join(f&quot;{num:02x}&quot; for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = &quot; &quot;.join((f&quot;{sys.executable} -m espefuse&quot;, cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = &quot; &quot;.join(
82              [self.base_cmd, &quot;--do-not-confirm&quot; if do_not_confirm else &quot;&quot;, cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              &quot; &quot;.join([self.base_cmd, &quot;check_error&quot;]), &quot;No errors detected&quot;, 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py(&quot;--help&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;)
114          self.espefuse_not_virt_py(f&quot;--chip {arg_chip} --help&quot;)
115      def test_help2(self):
116          self.espefuse_not_virt_py(&quot;&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;, ret_code=1)
117      def test_dump(self):
118          self.espefuse_py(&quot;dump -h&quot;)
119          self.espefuse_py(&quot;dump&quot;)
120      def test_summary(self):
121          self.espefuse_py(&quot;summary -h&quot;)
122          self.espefuse_py(&quot;summary&quot;)
123      def test_summary_json(self):
124          self.espefuse_py(&quot;summary --format json&quot;)
125      def test_get_custom_mac(self):
126          self.espefuse_py(&quot;get_custom_mac -h&quot;)
127          if arg_chip == &quot;esp32&quot;:
128              right_msg = &quot;Custom MAC Address is not set in the device.&quot;
129          else:
130              right_msg = &quot;Custom MAC Address: 00:00:00:00:00:00 (OK)&quot;
131          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=right_msg)
132      def test_adc_info(self):
133          self.espefuse_py(&quot;adc_info -h&quot;)
134          self.espefuse_py(&quot;adc_info&quot;)
135      def test_check_error(self):
136          self.espefuse_py(&quot;check_error -h&quot;)
137          self.espefuse_py(&quot;check_error&quot;)
138          self.espefuse_py(&quot;check_error --recovery&quot;)
139  class TestReadProtectionCommands(EfuseTestCase):
140      def test_read_protect_efuse(self):
141          self.espefuse_py(&quot;read_protect_efuse -h&quot;)
142          if arg_chip == &quot;esp32&quot;:
143              cmd = &quot;read_protect_efuse \
144                     CODING_SCHEME \
145                     MAC_VERSION \
146                     BLOCK1 \
147                     BLOCK2 \
148                     BLOCK3&quot;
149              count_protects = 5
150          elif arg_chip == &quot;esp32c2&quot;:
151              cmd = &quot;read_protect_efuse \
152                     BLOCK_KEY0_LOW_128&quot;
153              count_protects = 1
154          else:
155              self.espefuse_py(
156                  &quot;burn_efuse \
157                  KEY_PURPOSE_0 HMAC_UP \
158                  KEY_PURPOSE_1 XTS_AES_128_KEY \
159                  KEY_PURPOSE_2 XTS_AES_128_KEY \
160                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
161                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
162                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE&quot;
163              )
164              cmd = &quot;read_protect_efuse \
165                     BLOCK_KEY0 \
166                     BLOCK_KEY1 \
167                     BLOCK_KEY2 \
168                     BLOCK_KEY3 \
169                     BLOCK_KEY4 \
170                     BLOCK_KEY5&quot;
171              count_protects = 6
172          self.espefuse_py(cmd)
173          output = self.espefuse_py(cmd)
174          assert count_protects == output.count(&quot;is already read protected&quot;)
175      def test_read_protect_efuse2(self):
176          self.espefuse_py(&quot;write_protect_efuse RD_DIS&quot;)
177          if arg_chip == &quot;esp32&quot;:
178              efuse_name = &quot;CODING_SCHEME&quot;
179          elif arg_chip == &quot;esp32c2&quot;:
180              efuse_name = &quot;BLOCK_KEY0_HI_128&quot;
181          else:
182              efuse_name = &quot;BLOCK_SYS_DATA2&quot;
183          self.espefuse_py(
184              f&quot;read_protect_efuse {efuse_name}&quot;,
185              check_msg=&quot;A fatal error occurred: This efuse cannot be read-disabled &quot;
186              &quot;due the to RD_DIS field is already write-disabled&quot;,
187              ret_code=2,
188          )
189      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;when the purpose of BLOCK2 is set&quot;)
190      def test_read_protect_efuse3(self):
191          self.espefuse_py(&quot;burn_efuse ABS_DONE_1 1&quot;)
192          self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
193          self.espefuse_py(
194              &quot;read_protect_efuse BLOCK2&quot;,
195              check_msg=&quot;Secure Boot V2 is on (ABS_DONE_1 = True), &quot;
196              &quot;BLOCK2 must be readable, stop this operation!&quot;,
197              ret_code=2,
198          )
199      def test_read_protect_efuse4(self):
200          if arg_chip == &quot;esp32&quot;:
201              self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
202              msg = &quot;must be readable, please stop this operation!&quot;
203              self.espefuse_py(&quot;read_protect_efuse BLOCK2&quot;, check_msg=msg)
204          elif arg_chip == &quot;esp32c2&quot;:
205              self.espefuse_py(
206                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
207              )
208              self.espefuse_py(
209                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
210                  check_msg=&quot;A fatal error occurred: &quot;
211                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
212                  ret_code=2,
213              )
214          else:
215              self.espefuse_py(
216                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
217                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
218                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
219                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
220                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
221                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP&quot;
222              )
223              self.espefuse_py(
224                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
225                  check_msg=&quot;A fatal error occurred: &quot;
226                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
227                  ret_code=2,
228              )
229              self.espefuse_py(
230                  &quot;read_protect_efuse BLOCK_KEY1&quot;,
231                  check_msg=&quot;A fatal error occurred: &quot;
232                  &quot;BLOCK_KEY1 must be readable, stop this operation!&quot;,
233                  ret_code=2,
234              )
235              self.espefuse_py(
236                  &quot;read_protect_efuse BLOCK_KEY2&quot;,
237                  check_msg=&quot;A fatal error occurred: &quot;
238                  &quot;BLOCK_KEY2 must be readable, stop this operation!&quot;,
239                  ret_code=2,
240              )
241              self.espefuse_py(
242                  &quot;read_protect_efuse BLOCK_KEY3&quot;,
243                  check_msg=&quot;A fatal error occurred: &quot;
244                  &quot;BLOCK_KEY3 must be readable, stop this operation!&quot;,
245                  ret_code=2,
246              )
247              self.espefuse_py(
248                  &quot;read_protect_efuse BLOCK_KEY4&quot;,
249                  check_msg=&quot;A fatal error occurred: &quot;
250                  &quot;BLOCK_KEY4 must be readable, stop this operation!&quot;,
251                  ret_code=2,
252              )
253              self.espefuse_py(&quot;read_protect_efuse BLOCK_KEY5&quot;)
254      @pytest.mark.skipif(
255          arg_chip != &quot;esp32&quot;,
256          reason=&quot;system parameters efuse read-protection is supported only by esp32, &quot;
257          &quot;other chips protect whole blocks&quot;,
258      )
259      def test_burn_and_read_protect_efuse(self):
260          self.espefuse_py(
261              &quot;burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8&quot;,
262              check_msg=&quot;Efuse FLASH_CRYPT_CONFIG is read-protected. &quot;
263              &quot;Read back the burn value is not possible.&quot;,
264          )
265  class TestWriteProtectionCommands(EfuseTestCase):
266      def test_write_protect_efuse(self):
267          self.espefuse_py(&quot;write_protect_efuse -h&quot;)
268          if arg_chip == &quot;esp32&quot;:
269              efuse_lists = 
270              efuse_lists2 = &quot;WR_DIS RD_DIS&quot;
271          elif arg_chip == &quot;esp32c2&quot;:
272              efuse_lists = 
273              efuse_lists2 = &quot;RD_DIS DIS_DOWNLOAD_ICACHE&quot;
274          else:
275              efuse_lists = 
276              if arg_chip not in [&quot;esp32h2&quot;, &quot;esp32h2beta1&quot;] and arg_chip not in [
277                  &quot;esp32c6&quot;
278              ]:
279                  efuse_lists += 
280              efuse_lists2 = &quot;RD_DIS DIS_ICACHE&quot;
281          self.espefuse_py(f&quot;write_protect_efuse {efuse_lists}&quot;)
282          output = self.espefuse_py(f&quot;write_protect_efuse {efuse_lists2}&quot;)
283          assert output.count(&quot;is already write protected&quot;) == 2
284      def test_write_protect_efuse2(self):
285          if arg_chip == &quot;esp32&quot;:
286              self.espefuse_py(&quot;write_protect_efuse WR_DIS&quot;)
287              self.espefuse_py(
288                  &quot;write_protect_efuse CODING_SCHEME&quot;,
289                  check_msg=&quot;A fatal error occurred: This efuse cannot be write-disabled &quot;
290                  &quot;due to the WR_DIS field is already write-disabled&quot;,
291                  ret_code=2,
292              )
293  class TestBurnCustomMacCommands(EfuseTestCase):
294      def test_burn_custom_mac(self):
295          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
296          cmd = &quot;burn_custom_mac AA:CD:EF:11:22:33&quot;
297          mac = &quot;aa:cd:ef:11:22:33&quot;
298          if arg_chip == &quot;esp32&quot;:
299              self.espefuse_py(
300                  cmd, check_msg=f&quot;Custom MAC Address version 1: {mac} (CRC 0x63 OK)&quot;
301              )
302          else:
303              self.espefuse_py(cmd, check_msg=f&quot;Custom MAC Address: {mac} (OK)&quot;)
304      def test_burn_custom_mac2(self):
305          self.espefuse_py(
306              &quot;burn_custom_mac AA:CD:EF:11:22:33:44&quot;,
307              check_msg=&quot;A fatal error occurred: MAC Address needs to be a 6-byte &quot;
308              &quot;hexadecimal format separated by colons (:)!&quot;,
309              ret_code=2,
310          )
311      def test_burn_custom_mac3(self):
312          self.espefuse_py(
313              &quot;burn_custom_mac AB:CD:EF:11:22:33&quot;,
314              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
315              ret_code=2,
316          )
317      @pytest.mark.skipif(
318          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
319      )
320      def test_burn_custom_mac_with_34_coding_scheme(self):
321          self._set_34_coding_scheme()
322          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
323          self.espefuse_py(
324              &quot;burn_custom_mac AA:CD:EF:01:02:03&quot;,
325              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
326          )
327          self.espefuse_py(
328              &quot;get_custom_mac&quot;,
329              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
330          )
331          self.espefuse_py(
332              &quot;burn_custom_mac FE:22:33:44:55:66&quot;,
333              check_msg=&quot;New value contains some bits that cannot be cleared &quot;
334              &quot;(value will be 0x675745ffeffe)&quot;,
335              ret_code=2,
336          )
337  @pytest.mark.skipif(
338      arg_chip in [&quot;esp32c2&quot;, &quot;esp32h2beta1&quot;, &quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;],
339      reason=f&quot;TODO: add support set_flash_voltage for {arg_chip}&quot;,
340  )
341  class TestSetFlashVoltageCommands(EfuseTestCase):
342      def test_set_flash_voltage_1_8v(self):
343          self.espefuse_py(&quot;set_flash_voltage -h&quot;)
344          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
345          self.espefuse_py(
346              &quot;set_flash_voltage 1.8V&quot;,
347              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
348          )
349          if arg_chip == &quot;esp32&quot;:
350              error_msg = &quot;A fatal error occurred: &quot;
351              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
352          else:
353              error_msg = &quot;A fatal error occurred: &quot;
354              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
355          self.espefuse_py(
356              &quot;set_flash_voltage 3.3V&quot;,
357              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
358          )
359          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
360      def test_set_flash_voltage_3_3v(self):
<span onclick='openModal()' class='match'>361          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
362          self.espefuse_py(
363              &quot;set_flash_voltage 3.3V&quot;,
364              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
365          )
366          if arg_chip == &quot;esp32&quot;:
</span>367              error_msg = &quot;A fatal error occurred: &quot;
368              &quot;Can&#x27;t set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned&quot;
369          else:
370              error_msg = &quot;A fatal error occurred: &quot;
371              &quot;Can&#x27;t set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned&quot;
372          self.espefuse_py(&quot;set_flash_voltage 1.8V&quot;, check_msg=error_msg, ret_code=2)
373          if arg_chip == &quot;esp32&quot;:
374              error_msg = &quot;A fatal error occurred: &quot;
375              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
376          else:
377              error_msg = &quot;A fatal error occurred: &quot;
378              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
379          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
380      def test_set_flash_voltage_off(self):
381          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
382          self.espefuse_py(
383              &quot;set_flash_voltage OFF&quot;,
384              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
385          )
386          self.espefuse_py(
387              &quot;set_flash_voltage 3.3V&quot;,
388              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
389          )
390      def test_set_flash_voltage_off2(self):
391          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
392          self.espefuse_py(
393              &quot;set_flash_voltage OFF&quot;,
394              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
395          )
396          self.espefuse_py(
397              &quot;set_flash_voltage 1.8V&quot;,
398              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
399          )
400  @pytest.mark.skipif(arg_chip != &quot;esp32c3&quot;, reason=&quot;Not necessary fo all chips&quot;)
401  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
402      def test_efuse_is_bool_given_none(self):
403          self.espefuse_py(&quot;burn_efuse SECURE_BOOT_KEY_REVOKE0&quot;)
404      def test_efuse_is_bool_given_0(self):
405          self.espefuse_py(
406              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 0&quot;,
407              check_msg=&quot;A fatal error occurred: &quot;
408              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
409              &quot;(will always burn 0-&gt;1), given value=0&quot;,
410              ret_code=2,
411          )
412      def test_efuse_is_bool_given_2(self):
413          self.espefuse_py(
414              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 2&quot;,
415              check_msg=&quot;A fatal error occurred: &quot;
416              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
417              &quot;(will always burn 0-&gt;1), given value=2&quot;,
418              ret_code=2,
419          )
420      def test_efuse_is_bytes_ok(self):
421          self.espefuse_py(
422              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678&quot;
423          )
424      def test_efuse_is_bytes_given_short_val(self):
425          self.espefuse_py(
426              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678&quot;,
427              check_msg=&quot;A fatal error occurred: &quot;
428              &quot;The length of efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (128 bits) &quot;
429              &quot;(given len of the new value= 64 bits)&quot;,
430              ret_code=2,
431          )
432      def test_efuse_is_bytes_given_none(self):
433          self.espefuse_py(
434              &quot;burn_efuse OPTIONAL_UNIQUE_ID&quot;,
435              check_msg=&quot;A fatal error occurred: &quot;
436              &quot;New value required for efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (given None)&quot;,
437              ret_code=2,
438          )
439      def test_efuse_is_int_ok(self):
440          self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_D 7&quot;)
441      def test_efuse_is_int_given_out_of_range_val(self):
442          self.espefuse_py(
443              &quot;burn_efuse SPI_PAD_CONFIG_D 200&quot;,
444              check_msg=&quot;A fatal error occurred: &quot;
445              &quot;200 is too large an unsigned integer for a bitstring &quot;
446              &quot;of length 6. The allowed range is [0, 63].&quot;,
447              ret_code=2,
448          )
449      def test_efuse_is_int_given_none(self):
450          self.espefuse_py(
451              &quot;burn_efuse SPI_PAD_CONFIG_D&quot;,
452              check_msg=&quot;A fatal error occurred: &quot;
453              &quot;New value required for efuse &#x27;SPI_PAD_CONFIG_D&#x27; (given None)&quot;,
454              ret_code=2,
455          )
456      def test_efuse_is_int_given_0(self):
457          self.espefuse_py(
458              &quot;burn_efuse SPI_PAD_CONFIG_D 0&quot;,
459              check_msg=&quot;A fatal error occurred: &quot;
460              &quot;New value should not be 0 for &#x27;SPI_PAD_CONFIG_D&#x27; &quot;
461              &quot;(given value= 0)&quot;,
462              ret_code=2,
463          )
464      def test_efuse_is_bitcount_given_out_of_range_val(self):
465          self.espefuse_py(
466              &quot;burn_efuse SPI_BOOT_CRYPT_CNT 9&quot;,
467              check_msg=&quot;A fatal error occurred: &quot;
468              &quot;9 is too large an unsigned integer for a bitstring &quot;
469              &quot;of length 3. The allowed range is [0, 7].&quot;,
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_increase_over_max(self):
473          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
474          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
475          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
476          self.espefuse_py(
477              &quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;,
478              check_msg=&quot;A fatal error occurred: &quot;
479              &quot;15 is too large an unsigned integer for a bitstring &quot;
480              &quot;of length 3. The allowed range is [0, 7].&quot;,
481              ret_code=2,
482          )
483  class TestBurnEfuseCommands(EfuseTestCase):
484      @pytest.mark.skipif(
485          arg_chip != &quot;esp32&quot;,
486          reason=&quot;IO pins 30 &amp; 31 cannot be set for SPI flash only on esp32&quot;,
487      )
488      def test_set_spi_flash_pin_efuses(self):
489          self.espefuse_py(
490              &quot;burn_efuse SPI_PAD_CONFIG_HD 30&quot;,
491              check_msg=&quot;A fatal error occurred: &quot;
492              &quot;IO pins 30 &amp; 31 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
493              ret_code=2,
494          )
495          self.espefuse_py(
496              &quot;burn_efuse SPI_PAD_CONFIG_Q 0x23&quot;,
497              check_msg=&quot;A fatal error occurred: &quot;
498              &quot;IO pin 35 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
499              ret_code=2,
500          )
501          output = self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_CS0 33&quot;)
502          assert &quot;(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -&gt; 0b11111&quot; in output
503          assert &quot;BURN BLOCK0  - OK (all write block bits are set)&quot; in output
504      def test_burn_mac_custom_efuse(self):
505          crc_msg = &quot;(OK)&quot;
506          self.espefuse_py(&quot;burn_efuse -h&quot;)
507          if arg_chip == &quot;esp32&quot;:
508              self.espefuse_py(
509                  &quot;burn_efuse MAC AA:CD:EF:01:02:03&quot;,
510                  check_msg=&quot;Writing Factory MAC address is not supported&quot;,
511                  ret_code=2,
512              )
513              self.espefuse_py(&quot;burn_efuse MAC_VERSION 1&quot;)
514              crc_msg = &quot;(CRC 0x56 OK)&quot;
515          if arg_chip == &quot;esp32c2&quot;:
516              self.espefuse_py(&quot;burn_efuse CUSTOM_MAC_USED 1&quot;)
517          self.espefuse_py(&quot;burn_efuse -h&quot;)
518          self.espefuse_py(
519              &quot;burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03&quot;,
520              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
521              ret_code=2,
522          )
523          self.espefuse_py(&quot;burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03&quot;)
524          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=f&quot;aa:cd:ef:01:02:03 {crc_msg}&quot;)
525      def test_burn_efuse(self):
526          self.espefuse_py(&quot;burn_efuse -h&quot;)
527          if arg_chip == &quot;esp32&quot;:
528              self.espefuse_py(
529                  &quot;burn_efuse \
530                  CHIP_VER_REV2 1 \
531                  DISABLE_DL_ENCRYPT 1 \
532                  CONSOLE_DEBUG_DISABLE 1&quot;
533              )
534              blk1 = &quot;BLOCK1&quot;
535              blk2 = &quot;BLOCK2&quot;
536          elif arg_chip == &quot;esp32c2&quot;:
537              self.espefuse_py(
538                  &quot;burn_efuse \
539                  XTS_KEY_LENGTH_256 1 \
540                  UART_PRINT_CONTROL 1 \
541                  FORCE_SEND_RESUME 1&quot;
542              )
543              blk1 = &quot;BLOCK_KEY0&quot;
544              blk2 = None
545          else:
546              self.espefuse_py(
547                  &quot;burn_efuse \
548                  SECURE_BOOT_EN 1 \
549                  UART_PRINT_CONTROL 1&quot;
550              )
551              self.espefuse_py(
552                  &quot;burn_efuse \
553                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168&quot;,
554                  check_msg=&quot;-&gt; 0x2328ad5ac9145f698f843a26d6eae168&quot;,
555              )
556              output = self.espefuse_py(&quot;summary -d&quot;)
557              assert (
558                  &quot;read_regs: d6eae168 8f843a26 c9145f69 2328ad5a &quot;
559                  &quot;00000000 00000000 00000000 00000000&quot;
560              ) in output
561              assert &quot;= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W&quot; in output
562              efuse_from_blk2 = &quot;BLK_VERSION_MAJOR&quot;
563              if arg_chip == &quot;esp32s2&quot;:
564                  efuse_from_blk2 = &quot;BLK_VERSION_MINOR&quot;
565              if arg_chip != &quot;esp32c6&quot;:
566                  self.espefuse_py(
567                      f&quot;burn_efuse {efuse_from_blk2} 1&quot;,
568                      check_msg=&quot;Burn into BLOCK_SYS_DATA is forbidden &quot;
569                      &quot;(RS coding scheme does not allow this).&quot;,
570                      ret_code=2,
571                  )
572              blk1 = &quot;BLOCK_KEY1&quot;
573              blk2 = &quot;BLOCK_KEY2&quot;
574          output = self.espefuse_py(
575              f&quot;burn_efuse {blk1}&quot;
576              + &quot; 0x00010203040506070809111111111111111111111111111111110000112233FF&quot;
577          )
578          assert (
579              &quot;-&gt; 0x00010203040506070809111111111111111111111111111111110000112233ff&quot;
580              in output
581          )
582          output = self.espefuse_py(&quot;summary -d&quot;)
583          assert (
584              &quot;read_regs: 112233ff 11110000 11111111 11111111 &quot;
585              &quot;11111111 08091111 04050607 00010203&quot;
586          ) in output
587          assert (
588              &quot;= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 &quot;
589              &quot;11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W&quot;
590          ) in output
591          if blk2 is not None:
592              output = self.espefuse_py(
593                  f&quot;burn_efuse {blk2}&quot;
594                  + &quot; 00010203040506070809111111111111111111111111111111110000112233FF&quot;
595              )
596              assert (
597                  &quot;-&gt; 0xff33221100001111111111111111111111111111111109080706050403020100&quot;
598                  in output
599              )
600              output = self.espefuse_py(&quot;summary -d&quot;)
601              assert (
602                  &quot;read_regs: 03020100 07060504 11110908 11111111 &quot;
603                  &quot;11111111 11111111 00001111 ff332211&quot;
604              ) in output
605              assert (
606                  &quot;= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 &quot;
607                  &quot;11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W&quot;
608              ) in output
609      @pytest.mark.skipif(
610          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
611      )
612      def test_burn_efuse_with_34_coding_scheme(self):
613          self._set_34_coding_scheme()
614          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
615          self.espefuse_py(&quot;burn_efuse ADC1_TP_LOW 50&quot;)
616          self.espefuse_py(
617              &quot;burn_efuse ADC1_TP_HIGH 55&quot;,
618              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
619              &quot;(3/4 coding scheme does not allow this)&quot;,
620              ret_code=2,
621          )
622      @pytest.mark.skipif(
623          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
624      )
625      def test_burn_efuse_with_34_coding_scheme2(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
628          self.espefuse_py(
629              &quot;burn_efuse \
630              ADC1_TP_LOW 50 \
631              ADC1_TP_HIGH 55 \
632              ADC2_TP_LOW 40 \
633              ADC2_TP_HIGH 45&quot;
634          )
635  class TestBurnKeyCommands(EfuseTestCase):
636      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
637      def test_burn_key_3_key_blocks(self):
638          self.espefuse_py(&quot;burn_key -h&quot;)
639          self.espefuse_py(
640              f&quot;burn_key BLOCK1 {IMAGES_DIR}/192bit&quot;,
641              check_msg=&quot;A fatal error occurred: Incorrect key file size 24. &quot;
642              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
643              ret_code=2,
644          )
645          self.espefuse_py(
646              f&quot;burn_key \
647              BLOCK1 {IMAGES_DIR}/256bit \
648              BLOCK2 {IMAGES_DIR}/256bit_1 \
649              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key&quot;
650          )
651          output = self.espefuse_py(&quot;summary -d&quot;)
652          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
653          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
654          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
655          self.espefuse_py(
656              f&quot;burn_key \
657              BLOCK1 {IMAGES_DIR}/256bit \
658              BLOCK2 {IMAGES_DIR}/256bit_1 \
659              BLOCK3 {IMAGES_DIR}/256bit_2&quot;
660          )
661          output = self.espefuse_py(&quot;summary -d&quot;)
662          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
663          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
664          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
665      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
666      def test_burn_key_1_key_block(self):
667          self.espefuse_py(&quot;burn_key -h&quot;)
668          self.espefuse_py(
669              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY&quot;,
670              check_msg=&quot;A fatal error occurred: Incorrect key file size 16. &quot;
671              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
672              ret_code=2,
673          )
674          self.espefuse_py(
675              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect&quot;
676          )
677          output = self.espefuse_py(&quot;summary -d&quot;)
678          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
679          self.espefuse_py(f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;)
680          output = self.espefuse_py(&quot;summary -d&quot;)
681          assert (
682              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
683              &quot;00000000 00000000 00000000 00000000&quot;
684          ) in output
685          assert (
686              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
687              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
688          ) in output
689      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
690      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
691          self.espefuse_py(&quot;burn_key -h&quot;)
692          self.espefuse_py(
693              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
694              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;,
695              check_msg=&quot;A fatal error occurred: These keypurposes are incompatible &quot;
696              &quot;[&#x27;XTS_AES_128_KEY&#x27;, &#x27;SECURE_BOOT_DIGEST&#x27;]&quot;,
697              ret_code=2,
698          )
699          self.espefuse_py(
700              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
701              f&quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
702              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect&quot;
703          )
704          output = self.espefuse_py(&quot;summary -d&quot;)
705          assert (
706              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
707              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
708          ) in output
709          self.espefuse_py(
710              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
711              &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
712              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
713          )
714          output = self.espefuse_py(&quot;summary -d&quot;)
715          assert (
716              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
717              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
718          ) in output
719          assert (
720              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
721              &quot;00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-&quot;
722          ) in output
723          assert &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
724          assert &quot;= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-&quot; in output
725      @pytest.mark.skipif(
726          arg_chip
727          not in [
728              &quot;esp32s2&quot;,
729              &quot;esp32s3&quot;,
730              &quot;esp32s3beta1&quot;,
731              &quot;esp32c3&quot;,
732              &quot;esp32h2beta1&quot;,
733              &quot;esp32c6&quot;,
734              &quot;esp32h2&quot;,
735          ],
736          reason=&quot;Only chips with 6 keys&quot;,
737      )
738      def test_burn_key_with_6_keys(self):
739          cmd = f&quot;burn_key \
740                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
741                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
742                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY&quot;
743          if arg_chip in [&quot;esp32c3&quot;, &quot;esp32c6&quot;] or arg_chip in [
744              &quot;esp32h2&quot;,
745              &quot;esp32h2beta1&quot;,
746          ]:
747              cmd = cmd.replace(&quot;XTS_AES_256_KEY_1&quot;, &quot;XTS_AES_128_KEY&quot;)
748              cmd = cmd.replace(&quot;XTS_AES_256_KEY_2&quot;, &quot;XTS_AES_128_KEY&quot;)
749          self.espefuse_py(cmd + &quot; --no-read-protect --no-write-protect&quot;)
750          output = self.espefuse_py(&quot;summary -d&quot;)
751          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
752          self.check_data_block_in_log(
753              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
754          )
755          self.check_data_block_in_log(
756              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
757          )
758          self.espefuse_py(cmd)
759          output = self.espefuse_py(&quot;summary -d&quot;)
760          assert (
761              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
762              &quot;00000000 00000000 00000000 00000000&quot;
763          ) in output
764          assert (
765              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
766              &quot;00000000 00000000 00000000 00000000&quot;
767          ) in output
768          assert (
769              &quot;[6 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
770              &quot;00000000 00000000 00000000 00000000&quot;
771          ) in output
772          self.espefuse_py(
773              f&quot;burn_key \
774              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
775              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
776              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2&quot;
777          )
778          output = self.espefuse_py(&quot;summary -d&quot;)
779          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
780          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
781          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
782      @pytest.mark.skipif(
783          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
784      )
785      def test_burn_key_with_34_coding_scheme(self):
786          self._set_34_coding_scheme()
787          self.espefuse_py(
788              f&quot;burn_key BLOCK1 {IMAGES_DIR}/256bit&quot;,
789              check_msg=&quot;A fatal error occurred: Incorrect key file size 32. &quot;
790              &quot;Key file must be 24 bytes (192 bits) of raw binary key data.&quot;,
791              ret_code=2,
792          )
793          self.espefuse_py(
794              f&quot;burn_key \
795              BLOCK1 {IMAGES_DIR}/192bit \
796              BLOCK2 {IMAGES_DIR}/192bit_1 \
797              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key&quot;
798          )
799          output = self.espefuse_py(&quot;summary -d&quot;)
800          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
801          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
802          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
803          self.espefuse_py(
804              f&quot;burn_key \
805              BLOCK1 {IMAGES_DIR}/192bit \
806              BLOCK2 {IMAGES_DIR}/192bit_1 \
807              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
808          )
809          output = self.espefuse_py(&quot;summary -d&quot;)
810          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
811          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
812          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
813      @pytest.mark.skipif(
814          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
815          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
816      )
817      def test_burn_key_512bit(self):
818          self.espefuse_py(
819              f&quot;burn_key \
820              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
821              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
822          )
823          output = self.espefuse_py(&quot;summary -d&quot;)
824          self.check_data_block_in_log(
825              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
826          )
827          self.check_data_block_in_log(
828              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
829          )
830      @pytest.mark.skipif(
831          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
832          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
833      )
834      def test_burn_key_512bit_non_consecutive_blocks(self):
835          self.espefuse_py(
836              f&quot;burn_key \
837              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;
838          )
839          self.espefuse_py(
840              f&quot;burn_key \
841              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0&quot;
842          )
843          self.espefuse_py(
844              f&quot;burn_key \
845              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
846              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
847          )
848          self.espefuse_py(
849              f&quot;burn_key \
850              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect&quot;
851          )
852          output = self.espefuse_py(&quot;summary -d&quot;)
853          self.check_data_block_in_log(
854              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
855          )
856          self.check_data_block_in_log(
857              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
858          )
859          assert (
860              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 &quot;
861              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
862          ) in output
863          assert (
864              &quot;[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 &quot;
865              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
866          ) in output
867      @pytest.mark.skipif(
868          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
869          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
870      )
871      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
872          self.espefuse_py(
873              f&quot;burn_key \
874              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
875              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
876              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
877              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
878              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
879              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
880          )
881          output = self.espefuse_py(&quot;summary -d&quot;)
882          self.check_data_block_in_log(
883              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
884          )
885          self.check_data_block_in_log(
886              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
887          )
888          assert (
889              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
890              &quot;acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
891          ) in output
892          assert (
893              &quot;[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
894              &quot;acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
895          ) in output
896      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
897      def test_burn_key_ecdsa_key(self):
898          self.espefuse_py(
899              f&quot;burn_key \
900              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
901              ECDSA_KEY \
902              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
903              ECDSA_KEY&quot;
904          )
905          output = self.espefuse_py(&quot;summary -d&quot;)
906          assert 2 == output.count(
907              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
908              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
909          )
910          assert (
911              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
912              &quot;00000000 00000000 00000000 00000000&quot;
913          ) in output
914          assert (
915              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
916              &quot;00000000 00000000 00000000 00000000&quot;
917          ) in output
918      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
919      def test_burn_key_ecdsa_key_check_byte_order(self):
920          self.espefuse_py(
921              f&quot;burn_key \
922              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
923              ECDSA_KEY \
924              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
925              ECDSA_KEY \
926              --no-read-protect&quot;
927          )
928          output = self.espefuse_py(&quot;summary -d&quot;)
929          assert (
930              &quot;= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 &quot;
931              &quot;cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-&quot;
932          ) in output
933          assert (
934              &quot;= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b &quot;
935              &quot;38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-&quot;
936          ) in output
937          assert (
938              &quot;[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 &quot;
939              &quot;238123cb 4f71b795 00000000 00000000&quot;
940          ) in output
941          assert (
942              &quot;[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed &quot;
943              &quot;8450c238 c39d087a 90066a66 b4548b23&quot;
944          ) in output
945  class TestBurnBlockDataCommands(EfuseTestCase):
946      def test_burn_block_data_check_args(self):
947          self.espefuse_py(&quot;burn_block_data -h&quot;)
948          blk0 = &quot;BLOCK0&quot;
949          blk1 = &quot;BLOCK1&quot;
950          self.espefuse_py(
951              f&quot;burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}&quot;,
952              check_msg=&quot;A fatal error occurred: &quot;
953              &quot;The number of block_name (2) and datafile (1) should be the same.&quot;,
954              ret_code=2,
955          )
956      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
957      def test_burn_block_data_with_3_key_blocks(self):
958          self.espefuse_py(
959              f&quot;burn_block_data \
960              BLOCK0 {IMAGES_DIR}/224bit \
961              BLOCK3 {IMAGES_DIR}/256bit&quot;
962          )
963          output = self.espefuse_py(&quot;summary -d&quot;)
964          assert (
965              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
966              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
967          ) in output
968          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
969          self.espefuse_py(
970              f&quot;burn_block_data \
971              BLOCK2 {IMAGES_DIR}/256bit_1&quot;
972          )
973          self.check_data_block_in_log(
974              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
975          )
976          self.espefuse_py(
977              f&quot;burn_block_data \
978              BLOCK1 {IMAGES_DIR}/256bit_2&quot;
979          )
980          self.check_data_block_in_log(
981              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_2&quot;
982          )
983      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
984      def test_burn_block_data_with_1_key_block(self):
985          self.espefuse_py(
986              f&quot;burn_block_data \
987              BLOCK0 {IMAGES_DIR}/64bit \
988              BLOCK1 {IMAGES_DIR}/96bit \
989              BLOCK2 {IMAGES_DIR}/256bit \
990              BLOCK3 {IMAGES_DIR}/256bit&quot;
991          )
992          output = self.espefuse_py(&quot;summary -d&quot;)
993          assert &quot;[0 ] read_regs: 00000001 0000000c&quot; in output
994          assert &quot;[1 ] read_regs: 03020100 07060504 000a0908&quot; in output
995          assert (
996              &quot;[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
997              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
998          ) in output
999          assert (
1000              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1001              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1002          ) in output
1003      @pytest.mark.skipif(
1004          arg_chip
1005          not in [
1006              &quot;esp32s2&quot;,
1007              &quot;esp32s3&quot;,
1008              &quot;esp32s3beta1&quot;,
1009              &quot;esp32c3&quot;,
1010              &quot;esp32h2beta1&quot;,
1011              &quot;esp32c6&quot;,
1012              &quot;esp32h2&quot;,
1013          ],
1014          reason=&quot;Only chip with 6 keys&quot;,
1015      )
1016      def test_burn_block_data_with_6_keys(self):
1017          self.espefuse_py(
1018              f&quot;burn_block_data \
1019              BLOCK0 {IMAGES_DIR}/192bit \
1020              BLOCK3 {IMAGES_DIR}/256bit&quot;
1021          )
1022          output = self.espefuse_py(&quot;summary -d&quot;)
1023          assert (
1024              &quot;[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1025              in output
1026          )
1027          assert (
1028              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1029              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1030          ) in output
1031          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1032          self.espefuse_py(
1033              f&quot;burn_block_data \
1034              BLOCK10 {IMAGES_DIR}/256bit_1&quot;
1035          )
1036          self.check_data_block_in_log(
1037              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
1038          )
1039          self.espefuse_py(
1040              f&quot;burn_block_data \
1041              BLOCK1 {IMAGES_DIR}/192bit \
1042              BLOCK5 {IMAGES_DIR}/256bit_1 \
1043              BLOCK6 {IMAGES_DIR}/256bit_2&quot;
1044          )
1045          output = self.espefuse_py(&quot;summary -d&quot;)
1046          assert (
1047              &quot;[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1048              in output
1049          )
1050          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1051          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;, 2)
1052          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
1053      def test_burn_block_data_check_errors(self):
1054          self.espefuse_py(
1055              f&quot;burn_block_data \
1056              BLOCK2 {IMAGES_DIR}/192bit \
1057              BLOCK2 {IMAGES_DIR}/192bit_1&quot;,
1058              check_msg=&quot;A fatal error occurred: Found repeated&quot;,
1059              ret_code=2,
1060          )
1061          self.espefuse_py(
1062              f&quot;burn_block_data \
1063              BLOCK2 {IMAGES_DIR}/192bit \
1064              BLOCK3 {IMAGES_DIR}/192bit_1 \
1065              --offset 4&quot;,
1066              check_msg=&quot;A fatal error occurred: &quot;
1067              &quot;The &#x27;offset&#x27; option is not applicable when a few blocks are passed.&quot;,
1068              ret_code=2,
1069          )
1070          self.espefuse_py(
1071              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33&quot;,
1072              check_msg=&quot;A fatal error occurred: Invalid offset: the block0 only holds&quot;,
1073              ret_code=2,
1074          )
1075          self.espefuse_py(
1076              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4&quot;,
1077              check_msg=&quot;A fatal error occurred: Data does not fit:&quot;,
1078              ret_code=2,
1079          )
1080      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1081      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1082          offset = 1
1083          self.espefuse_py(
1084              f&quot;burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit&quot;
1085          )
1086          offset = 4
1087          self.espefuse_py(
1088              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1&quot;
1089          )
1090          self.check_data_block_in_log(
1091              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1092          )
1093          offset = 6
1094          self.espefuse_py(
1095              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2&quot;
1096          )
1097          self.check_data_block_in_log(
1098              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1099          )
1100          offset = 8
1101          self.espefuse_py(
1102              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1103          )
1104          self.check_data_block_in_log(
1105              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1106          )
1107      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1108      def test_burn_block_data_with_offset_1_key_block(self):
1109          offset = 4
1110          self.espefuse_py(f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit&quot;)
1111          output = self.espefuse_py(&quot;summary -d&quot;)
1112          assert &quot;[1 ] read_regs: 00000000 03020100 00060504&quot; in output
1113          offset = 6
1114          self.espefuse_py(
1115              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1&quot;
1116          )
1117          output = self.espefuse_py(&quot;summary -d&quot;)
1118          assert (
1119              &quot;[2 ] read_regs: 00000000 00110000 05000000 09080706 &quot;
1120              &quot;0d0c0b0a 11100f0e 15141312 00002116&quot;
1121          ) in output
1122          offset = 8
1123          self.espefuse_py(
1124              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1125          )
1126          self.check_data_block_in_log(
1127              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1128          )
1129      @pytest.mark.skipif(
1130          arg_chip
1131          not in [
1132              &quot;esp32s2&quot;,
1133              &quot;esp32s3&quot;,
1134              &quot;esp32s3beta1&quot;,
1135              &quot;esp32c3&quot;,
1136              &quot;esp32h2beta1&quot;,
1137              &quot;esp32c6&quot;,
1138              &quot;esp32h2&quot;,
1139          ],
1140          reason=&quot;Only chips with 6 keys&quot;,
1141      )
1142      def test_burn_block_data_with_offset_6_keys(self):
1143          offset = 4
1144          self.espefuse_py(
1145              f&quot;burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1&quot;
1146          )
1147          self.check_data_block_in_log(
1148              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1149          )
1150          offset = 6
1151          self.espefuse_py(
1152              f&quot;burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2&quot;
1153          )
1154          self.check_data_block_in_log(
1155              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1156          )
1157          offset = 8
1158          self.espefuse_py(
1159              f&quot;burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2&quot;
1160          )
1161          self.check_data_block_in_log(
1162              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1163          )
1164      @pytest.mark.skipif(
1165          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1166      )
1167      def test_burn_block_data_with_34_coding_scheme(self):
1168          self._set_34_coding_scheme()
1169          self.espefuse_py(
1170              f&quot;burn_block_data BLOCK1 {IMAGES_DIR}/256bit&quot;,
1171              check_msg=&quot;A fatal error occurred: Data does not fit: &quot;
1172              &quot;the block1 size is 24 bytes, data file is 32 bytes, offset 0&quot;,
1173              ret_code=2,
1174          )
1175          self.espefuse_py(
1176              f&quot;burn_block_data \
1177              BLOCK1 {IMAGES_DIR}/192bit \
1178              BLOCK2 {IMAGES_DIR}/192bit_1 \
1179              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1180          )
1181          output = self.espefuse_py(&quot;summary -d&quot;)
1182          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
1183          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
1184          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
1185      @pytest.mark.skipif(
1186          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1187      )
1188      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1189          self._set_34_coding_scheme()
1190          offset = 4
1191          self.espefuse_py(
1192              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit&quot;
1193          )
1194          self.check_data_block_in_log(
1195              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1196          )
1197          offset = 6
1198          self.espefuse_py(
1199              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit&quot;
1200          )
1201          self.check_data_block_in_log(
1202              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1203          )
1204          offset = 8
1205          self.espefuse_py(
1206              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit&quot;
1207          )
1208          self.check_data_block_in_log(
1209              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1210          )
1211  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only, supports 2 key blocks&quot;)
1212  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1213      def test_burn_key_digest(self):
1214          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1215          esp = self.get_esptool()
1216          if esp.get_chip_revision() &gt;= 300:
1217              self.espefuse_py(
1218                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1219              )
1220              output = self.espefuse_py(&quot;summary -d&quot;)
1221              assert (
1222                  &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1223                  &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1224              ) in output
1225          else:
1226              self.espefuse_py(
1227                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1228                  check_msg=&quot;Incorrect chip revision for Secure boot v2.&quot;,
1229                  ret_code=2,
1230              )
1231      def test_burn_key_from_digest(self):
1232          self.espefuse_py(
1233              f&quot;burn_key \
1234              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key&quot;
1235          )
1236          output = self.espefuse_py(&quot;summary -d&quot;)
1237          assert 1 == output.count(
1238              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1239              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W&quot;
1240          )
1241      def test_burn_key_digest_with_34_coding_scheme(self):
1242          self._set_34_coding_scheme()
1243          self.espefuse_py(
1244              f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1245              check_msg=&quot;burn_key_digest only works with &#x27;None&#x27; coding scheme&quot;,
1246              ret_code=2,
1247          )
1248  @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only, supports 1 key block&quot;)
1249  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1250      def test_burn_key_digest1(self):
1251          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1252          self.espefuse_py(
1253              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem&quot;
1254          )
1255          output = self.espefuse_py(&quot;summary -d&quot;)
1256          assert &quot; = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot; in output
1257          assert (
1258              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1259              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1260          ) in output
1261      def test_burn_key_digest2(self):
1262          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1263          self.espefuse_py(
1264              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1265          )
1266          output = self.espefuse_py(&quot;summary -d&quot;)
1267          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1268          assert (
1269              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1270              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1271          ) in output
1272      def test_burn_key_from_digest1(self):
1273          self.espefuse_py(
1274              &quot;burn_key BLOCK_KEY0 &quot;
1275              f&quot;{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1276          )
1277          output = self.espefuse_py(&quot;summary -d&quot;)
1278          assert (
1279              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1280              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1281          ) in output
1282      def test_burn_key_from_digest2(self):
1283          self.espefuse_py(
1284              &quot;burn_key BLOCK_KEY0 &quot;
1285              f&quot;{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1286          )
1287          output = self.espefuse_py(&quot;summary -d&quot;)
1288          assert (
1289              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1290              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1291          ) in output
1292  @pytest.mark.skipif(
1293      arg_chip
1294      not in [
1295          &quot;esp32s2&quot;,
1296          &quot;esp32s3&quot;,
1297          &quot;esp32s3beta1&quot;,
1298          &quot;esp32c3&quot;,
1299          &quot;esp32h2beta1&quot;,
1300          &quot;esp32c6&quot;,
1301          &quot;esp32h2&quot;,
1302      ],
1303      reason=&quot;Supports 6 key blocks&quot;,
1304  )
1305  class TestBurnKeyDigestCommands(EfuseTestCase):
1306      def test_burn_key_digest(self):
1307          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1308          self.espefuse_py(
1309              f&quot;burn_key_digest \
1310              BLOCK_KEY0 \
1311              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1312              BLOCK_KEY1 \
1313              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1314              BLOCK_KEY2 &quot;,
1315              check_msg=&quot;A fatal error occurred: The number of blocks (3), &quot;
1316              &quot;datafile (2) and keypurpose (2) should be the same.&quot;,
1317              ret_code=2,
1318          )
1319          self.espefuse_py(
1320              f&quot;burn_key_digest \
1321              BLOCK_KEY0 \
1322              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1323              BLOCK_KEY1 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1325              BLOCK_KEY2 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2&quot;
1327          )
1328          output = self.espefuse_py(&quot;summary -d&quot;)
1329          assert 1 == output.count(
1330              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1331              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1332          )
1333          assert 2 == output.count(
1334              &quot; = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 &quot;
1335              &quot;6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-&quot;
1336          )
1337      def test_burn_key_from_digest(self):
1338          self.espefuse_py(
1339              f&quot;burn_key \
1340              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1341          )
1342          output = self.espefuse_py(&quot;summary -d&quot;)
1343          assert 1 == output.count(
1344              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1345              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1346          )
1347          self.espefuse_py(
1348              f&quot;burn_key_digest \
1349              BLOCK_KEY1 \
1350              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1&quot;
1351          )
1352          output = self.espefuse_py(&quot;summary -d&quot;)
1353          assert 2 == output.count(
1354              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1355              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1356          )
1357  class TestBurnBitCommands(EfuseTestCase):
1358      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1359      def test_burn_bit_for_chips_with_3_key_blocks(self):
1360          self.espefuse_py(&quot;burn_bit -h&quot;)
1361          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1362          self.espefuse_py(
1363              &quot;summary&quot;,
1364              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 &quot;
1365              &quot;00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1366          )
1367          self.espefuse_py(
1368              &quot;burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254&quot;
1369          )
1370          self.espefuse_py(
1371              &quot;summary&quot;,
1372              check_msg=&quot;ff ff 01 80 01 00 00 80 01 00 00 80 01 &quot;
1373              &quot;00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0&quot;,
1374          )
1375      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1376      def test_burn_bit_for_chips_with_1_key_block(self):
1377          self.espefuse_py(&quot;burn_bit -h&quot;)
1378          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1379          self.espefuse_py(
1380              &quot;summary&quot;,
1381              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1382              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1383          )
1384          self.espefuse_py(
1385              &quot;burn_bit BLOCK3 100&quot;,
1386              check_msg=&quot;Burn into BLOCK_KEY0 is forbidden &quot;
1387              &quot;(RS coding scheme does not allow this)&quot;,
1388              ret_code=2,
1389          )
1390          self.espefuse_py(&quot;burn_bit BLOCK0 0 1 2&quot;)
1391          self.espefuse_py(&quot;summary&quot;, check_msg=&quot;[0 ] read_regs: 00000007 00000000&quot;)
1392      @pytest.mark.skipif(
1393          arg_chip
1394          not in [
1395              &quot;esp32s2&quot;,
1396              &quot;esp32s3&quot;,
1397              &quot;esp32s3beta1&quot;,
1398              &quot;esp32c3&quot;,
1399              &quot;esp32h2beta1&quot;,
1400              &quot;esp32c6&quot;,
1401              &quot;esp32h2&quot;,
1402          ],
1403          reason=&quot;Only chip with 6 keys&quot;,
1404      )
1405      def test_burn_bit_for_chips_with_6_key_blocks(self):
1406          self.espefuse_py(&quot;burn_bit -h&quot;)
1407          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1408          self.espefuse_py(
1409              &quot;summary&quot;,
1410              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1411              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1412          )
1413          self.espefuse_py(
1414              &quot;burn_bit BLOCK3 100&quot;,
1415              check_msg=&quot;Burn into BLOCK_USR_DATA is forbidden &quot;
1416              &quot;(RS coding scheme does not allow this)&quot;,
1417              ret_code=2,
1418          )
1419          self.espefuse_py(&quot;burn_bit BLOCK0 13&quot;)
1420          self.espefuse_py(
1421              &quot;summary&quot;,
1422              check_msg=&quot;[0 ] read_regs: 00002000 00000000 00000000 &quot;
1423              &quot;00000000 00000000 00000000&quot;,
1424          )
1425          self.espefuse_py(&quot;burn_bit BLOCK0 24&quot;)
1426          self.espefuse_py(
1427              &quot;summary&quot;,
1428              check_msg=&quot;[0 ] read_regs: 01002000 00000000 00000000 &quot;
1429              &quot;00000000 00000000 00000000&quot;,
1430          )
1431      @pytest.mark.skipif(
1432          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1433      )
1434      def test_burn_bit_with_34_coding_scheme(self):
1435          self._set_34_coding_scheme()
1436          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191&quot;)
1437          self.espefuse_py(
1438              &quot;summary&quot;,
1439              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1440              &quot;00 00 01 00 00 00 01 00 00 80&quot;,
1441          )
1442          self.espefuse_py(
1443              &quot;burn_bit BLOCK3 17&quot;,
1444              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
1445              &quot;(3/4 coding scheme does not allow this).&quot;,
1446              ret_code=2,
1447          )
1448  @pytest.mark.skipif(
1449      arg_chip != &quot;esp32&quot;, reason=&quot;Tests are only for esp32. (TODO: add for all chips)&quot;
1450  )
1451  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1452      def test_1_secure_boot_v1(self):
1453          if arg_chip == &quot;esp32&quot;:
1454              self.espefuse_py(
1455                  f&quot;burn_key \
1456                  flash_encryption {IMAGES_DIR}/256bit \
1457                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1458              )
1459              output = self.espefuse_py(&quot;summary -d&quot;)
1460              self.check_data_block_in_log(
1461                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1462              )
1463              self.check_data_block_in_log(
1464                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
1465              )
1466              self.espefuse_py(
1467                  f&quot;burn_key \
1468                  flash_encryption  {IMAGES_DIR}/256bit \
1469                  secure_boot_v1    {IMAGES_DIR}/256bit_1&quot;
1470              )
1471              output = self.espefuse_py(&quot;summary -d&quot;)
1472              assert (
1473                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1474                  &quot;00000000 00000000 00000000 00000000&quot;
1475              ) in output
1476              assert (
1477                  &quot;[2 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1478                  &quot;00000000 00000000 00000000 00000000&quot;
1479              ) in output
1480              assert (
1481                  &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1482                  &quot;00000000 00000000 00000000 00000000&quot;
1483              ) in output
1484      def test_2_secure_boot_v1(self):
1485          if arg_chip == &quot;esp32&quot;:
1486              self.espefuse_py(
1487                  f&quot;burn_key \
1488                  flash_encryption {IMAGES_DIR}/256bit \
1489                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1490              )
1491              output = self.espefuse_py(&quot;summary -d&quot;)
1492              self.check_data_block_in_log(
1493                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1494              )
1495              self.check_data_block_in_log(
1496                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1497              )
1498              self.espefuse_py(
1499                  f&quot;burn_key \
1500                  flash_encryption {IMAGES_DIR}/256bit \
1501                  secure_boot_v2 {IMAGES_DIR}/256bit_1&quot;
1502              )
1503              output = self.espefuse_py(&quot;summary -d&quot;)
1504              assert (
1505                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1506                  &quot;00000000 00000000 00000000 00000000&quot;
1507              ) in output
1508              self.check_data_block_in_log(
1509                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1510              )
1511  class TestExecuteScriptsCommands(EfuseTestCase):
1512      @classmethod
1513      def setup_class(self):
1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
1518      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1519      def test_execute_scripts_with_check_that_only_one_burn(self):
1520          self.espefuse_py(&quot;execute_scripts -h&quot;)
1521          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1522          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1523          self.espefuse_py(&quot;execute_scripts execute_efuse_script2.py&quot;)
1524      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1525      def test_execute_scripts_with_check(self):
1526          self.espefuse_py(&quot;execute_scripts -h&quot;)
1527          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1528          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1529          self.espefuse_py(&quot;execute_scripts execute_efuse_script.py&quot;)
1530      def test_execute_scripts_with_index_and_config(self):
1531          os.chdir(TEST_DIR)
1532          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1533              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1534              --configfiles {EFUSE_S_DIR}/esp32/config1.json&quot;
1535          else:
1536              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1537              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json&quot;
1538          self.espefuse_py(cmd)
1539          output = self.espefuse_py(&quot;summary -d&quot;)
1540          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1541              assert (
1542                  &quot;[3 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1543                  &quot;00000000 00000000 00000000 00000000&quot;
1544              ) in output
1545          else:
1546              assert (
1547                  &quot;[8 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1548                  &quot;00000000 00000000 00000000 00000000&quot;
1549              ) in output
1550      def test_execute_scripts_nesting(self):
1551          os.chdir(TEST_DIR)
1552          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1553              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1554              --configfiles {EFUSE_S_DIR}/esp32/config2.json&quot;
1555          else:
1556              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1557              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json&quot;
1558          self.espefuse_py(cmd)
1559          output = self.espefuse_py(&quot;summary -d&quot;)
1560          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1561              assert (
1562                  &quot;[2 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1563                  &quot;00000000 00000000 00000000 00000000&quot;
1564              ) in output
1565              assert (
1566                  &quot;[3 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1567                  &quot;00000000 00000000 00000000 00000000&quot;
1568              ) in output
1569          else:
1570              assert (
1571                  &quot;[7 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1572                  &quot;00000000 00000000 00000000 00000000&quot;
1573              ) in output
1574              assert (
1575                  &quot;[8 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1576                  &quot;00000000 00000000 00000000 00000000&quot;
1577              ) in output
1578  class TestMultipleCommands(EfuseTestCase):
1579      def test_multiple_cmds_help(self):
1580          if arg_chip == &quot;esp32c2&quot;:
1581              command1 = (
1582                  f&quot;burn_key_digest {S_IMAGES_DIR}&quot;
1583                  &quot;/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1584              )
1585              command2 = (
1586                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
1587                  &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS&quot;
1588              )
1589          elif arg_chip == &quot;esp32&quot;:
1590              command1 = f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1591              command2 = f&quot;burn_key flash_encryption {IMAGES_DIR}/256bit&quot;
1592          else:
1593              command1 = f&quot;burn_key_digest BLOCK_KEY0 \
1594              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0&quot;
1595              command2 = f&quot;burn_key BLOCK_KEY0 \
1596              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1597          self.espefuse_py(
1598              f&quot;-h {command1} {command2}&quot;,
1599              check_msg=&quot;usage: __main__.py [-h]&quot;,
1600          )
1601          self.espefuse_py(
1602              f&quot;{command1} -h {command2}&quot;,
1603              check_msg=&quot;usage: __main__.py burn_key_digest [-h]&quot;,
1604          )
1605          self.espefuse_py(
1606              f&quot;{command1} {command2} -h&quot;,
1607              check_msg=&quot;usage: __main__.py burn_key [-h]&quot;,
1608          )
1609      @pytest.mark.skipif(
1610          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1611      )
1612      def test_1_esp32c2(self):
1613          self.espefuse_py(
1614              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1615              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1616              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1617              summary&quot;
1618          )
1619          output = self.espefuse_py(&quot;summary -d&quot;)
1620          assert (
1621              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
1622              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1623          ) in output
1624          assert &quot; = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-&quot; in output
1625          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1626      @pytest.mark.skipif(
1627          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1628      )
1629      def test_2_esp32c2(self):
1630          self.espefuse_py(
1631              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1632              burn_key BLOCK_KEY0 \
1633              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1634              summary&quot;
1635          )
1636          output = self.espefuse_py(&quot;summary -d&quot;)
1637          assert (
1638              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1639              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1640          ) in output
1641          assert &quot; = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
1642          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1643      def test_burn_bit(self):
1644          if arg_chip == &quot;esp32&quot;:
1645              self._set_34_coding_scheme()
1646          self.espefuse_py(
1647              &quot;burn_bit BLOCK2 0 1 2 3 \
1648              burn_bit BLOCK2 4 5 6 7 \
1649              burn_bit BLOCK2 8 9 10 11 \
1650              burn_bit BLOCK2 12 13 14 15 \
1651              summary&quot;
1652          )
1653          output = self.espefuse_py(&quot;summary -d&quot;)
1654          assert &quot;[2 ] read_regs: 0000ffff 00000000&quot; in output
1655      def test_not_burn_cmds(self):
1656          self.espefuse_py(
1657              &quot;summary \
1658              dump \
1659              get_custom_mac \
1660              adc_info \
1661              check_error&quot;
1662          )
1663  @pytest.mark.skipif(
1664      arg_chip not in [&quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;, &quot;esp32s3&quot;],
1665      reason=&quot;These chips have a hardware bug that limits the use of the KEY5&quot;,
1666  )
1667  class TestKeyPurposes(EfuseTestCase):
1668      def test_burn_xts_aes_key_purpose(self):
1669          self.espefuse_py(
1670              &quot;burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY&quot;,
1671              check_msg=&quot;A fatal error occurred: &quot;
1672              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1673              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1674              ret_code=2,
1675          )
1676      @pytest.mark.skipif(
1677          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1678      )
1679      def test_burn_ecdsa_key_purpose(self):
1680          self.espefuse_py(
1681              &quot;burn_efuse KEY_PURPOSE_5 ECDSA_KEY&quot;,
1682              check_msg=&quot;A fatal error occurred: &quot;
1683              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1684              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1685              ret_code=2,
1686          )
1687      def test_burn_xts_aes_key(self):
1688          self.espefuse_py(
1689              f&quot;burn_key \
1690              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;,
1691              check_msg=&quot;A fatal error occurred: &quot;
1692              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1693              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1694              ret_code=2,
1695          )
1696      @pytest.mark.skipif(
1697          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1698      )
1699      def test_burn_ecdsa_key(self):
1700          self.espefuse_py(
1701              f&quot;burn_key \
1702              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1703              ECDSA_KEY&quot;,
1704              check_msg=&quot;A fatal error occurred: &quot;
1705              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1706              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1707              ret_code=2,
1708          )
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                </div>
                <div class="column column_space"><pre><code>344          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
345          self.espefuse_py(
346              &quot;set_flash_voltage 1.8V&quot;,
347              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
348          )
349          if arg_chip == &quot;esp32&quot;:
</pre></code></div>
                <div class="column column_space"><pre><code>361          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
362          self.espefuse_py(
363              &quot;set_flash_voltage 3.3V&quot;,
364              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
365          )
366          if arg_chip == &quot;esp32&quot;:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    