<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for predicates.py &amp; test_technical.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for predicates.py &amp; test_technical.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>predicates.py (3.7518036%)<th>test_technical.py (2.6236124%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-48)<td><a href="#" name="0">(1-27)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(655-668)<td><a href="#" name="1">(299-317)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>predicates.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from collections import OrderedDict
2 from contextlib import contextmanager
3 import datetime
4 from functools import partial
5 import re
6 from nose.tools import (  # noqa
7     assert_almost_equal,
8     assert_almost_equals,
9     assert_dict_contains_subset,
10     assert_false,
11     assert_greater,
12     assert_greater_equal,
13     assert_in,
14     assert_is,
15     assert_is_instance,
16     assert_is_none,
17     assert_is_not,
18     assert_is_not_none,
19     assert_less,
20     assert_less_equal,
21     assert_multi_line_equal,
22     assert_not_almost_equal,
23     assert_not_almost_equals,
24     assert_not_equal,
25     assert_not_equals,
26     assert_not_in,
27     assert_not_is_instance,
28     assert_raises,
29     assert_raises_regexp,
30     assert_regexp_matches,
31     assert_true,
32     assert_tuple_equal,
33 )
34 import numpy as np
35 import pandas as pd
36 from pandas.util.testing import (
37     assert_frame_equal,
38     assert_panel_equal,
39     assert_series_equal,
40     assert_index_equal,
41 )
42 from six import iteritems, viewkeys, PY2
43 from six.moves import zip_longest
44 from toolz import dissoc, keyfilter
45 import toolz.curried.operator as op
46 from</b></font> zipline.assets import Asset
47 from zipline.dispatch import dispatch
48 from zipline.lib.adjustment import Adjustment
49 from zipline.lib.labelarray import LabelArray
50 from zipline.testing.core import ensure_doctest
51 from zipline.utils.compat import getargspec, mappingproxy
52 from zipline.utils.formatting import s
53 from zipline.utils.functional import dzip_exact, instance
54 from zipline.utils.math_utils import tolerant_equals
55 from zipline.utils.numpy_utils import (
56     assert_array_compare,
57     compare_datetime_arrays,
58 )
59 @instance
60 @ensure_doctest
61 class wildcard(object):
62     @staticmethod
63     def __eq__(other):
64         return True
65     @staticmethod
66     def __ne__(other):
67         return False
68     def __repr__(self):
69         return '&lt;%s&gt;' % type(self).__name__
70 class instance_of(object):
71     def __init__(self, types, exact=False):
72         if not isinstance(types, tuple):
73             types = (types,)
74         for type_ in types:
75             if not isinstance(type_, type):
76                 raise TypeError('types must be a type or tuple of types')
77         self.types = types
78         self.exact = exact
79     def __eq__(self, other):
80         if self.exact:
81             return type(other) in self.types
82         return isinstance(other, self.types)
83     def __ne__(self, other):
84         return not self == other
85     def __repr__(self):
86         typenames = tuple(t.__name__ for t in self.types)
87         return '%s(%s%s)' % (
88             type(self).__name__,
89             (
90                 typenames[0]
91                 if len(typenames) == 1 else
92                 '(%s)' % ', '.join(typenames)
93             ),
94             ', exact=True' if self.exact else ''
95         )
96 def keywords(func):
97     if isinstance(func, type):
98         return keywords(func.__init__)
99     elif isinstance(func, partial):
100         return keywords(func.func)
101     return getargspec(func).args
102 def filter_kwargs(f, kwargs):
103     return keyfilter(op.contains(keywords(f)), kwargs)
104 def _fmt_path(path):
105     if not path:
106         return ''
107     return 'path: _' + ''.join(path)
108 def _fmt_msg(msg):
109     if not msg:
110         return ''
111     return msg + '\n'
112 def _safe_cls_name(cls):
113     try:
114         return cls.__name__
115     except AttributeError:
116         return repr(cls)
117 def assert_is_subclass(subcls, cls, msg=''):
118     assert issubclass(subcls, cls), (
119         '%s is not a subclass of %s\n%s' % (
120             _safe_cls_name(subcls),
121             _safe_cls_name(cls),
122             msg,
123         )
124     )
125 def assert_is_not_subclass(not_subcls, cls, msg=''):
126     assert not issubclass(not_subcls, cls), (
127         '%s is a subclass of %s\n%s' % (
128             _safe_cls_name(not_subcls),
129             _safe_cls_name(cls),
130             msg,
131         )
132     )
133 def assert_regex(result, expected, msg=''):
134     assert re.search(expected, result), (
135         '%s%r not found in %r' % (_fmt_msg(msg), expected, result)
136     )
137 @contextmanager
138 def _assert_raises_helper(do_check, exc_type, msg):
139     try:
140         yield
141     except exc_type as e:
142         do_check(e)
143     else:
144         raise AssertionError('%s%s was not raised' % (_fmt_msg(msg), exc_type))
145 def assert_raises_regex(exc, pattern, msg=''):
146     def check_exception(e):
147         assert re.search(pattern, str(e)), (
148             '%s%r not found in %r' % (_fmt_msg(msg), pattern, str(e))
149         )
150     return _assert_raises_helper(
151         do_check=check_exception,
152         exc_type=exc,
153         msg=msg,
154     )
155 def assert_raises_str(exc, expected_str, msg=''):
156     def check_exception(e):
157         result = str(e)
158         assert_messages_equal(result, expected_str, msg=msg)
159     return _assert_raises_helper(
160         check_exception,
161         exc_type=exc,
162         msg=msg,
163     )
164 def make_assert_equal_assertion_error(assertion_message, path, msg):
165     return AssertionError(
166         '%s%s\n%s' % (
167             _fmt_msg(msg),
168             assertion_message,
169             _fmt_path(path),
170         ),
171     )
172 @dispatch(object, object)
173 def assert_equal(result, expected, path=(), msg='', **kwargs):
174     if result != expected:
175         raise make_assert_equal_assertion_error(
176             '%s != %s' % (result, expected),
177             path,
178             msg,
179         )
180 @assert_equal.register(float, float)
181 def assert_float_equal(result,
182                        expected,
183                        path=(),
184                        msg='',
185                        float_rtol=10e-7,
186                        float_atol=10e-7,
187                        float_equal_nan=True,
188                        **kwargs):
189     assert tolerant_equals(
190         result,
191         expected,
192         rtol=float_rtol,
193         atol=float_atol,
194         equal_nan=float_equal_nan,
195     ), '%s%s != %s with rtol=%s and atol=%s%s\n%s' % (
196         _fmt_msg(msg),
197         result,
198         expected,
199         float_rtol,
200         float_atol,
201         (' (with nan != nan)' if not float_equal_nan else ''),
202         _fmt_path(path),
203     )
204 def _check_sets(result, expected, msg, path, type_):
205     if result != expected:
206         if result &gt; expected:
207             diff = result - expected
208             msg = 'extra %s in result: %r' % (s(type_, diff), diff)
209         elif result &lt; expected:
210             diff = expected - result
211             msg = 'result is missing %s: %r' % (s(type_, diff), diff)
212         else:
213             in_result = result - expected
214             in_expected = expected - result
215             msg = '%s only in result: %s\n%s only in expected: %s' % (
216                 s(type_, in_result),
217                 in_result,
218                 s(type_, in_expected),
219                 in_expected,
220             )
221         raise AssertionError(
222             '%ss do not match\n%s%s' % (
223                 type_,
224                 _fmt_msg(msg),
225                 _fmt_path(path),
226             ),
227         )
228 @assert_equal.register(dict, dict)
229 def assert_dict_equal(result, expected, path=(), msg='', **kwargs):
230     _check_sets(
231         viewkeys(result),
232         viewkeys(expected),
233         msg,
234         path + ('.%s()' % ('viewkeys' if PY2 else 'keys'),),
235         'key',
236     )
237     failures = []
238     for k, (resultv, expectedv) in iteritems(dzip_exact(result, expected)):
239         try:
240             assert_equal(
241                 resultv,
242                 expectedv,
243                 path=path + ('[%r]' % (k,),),
244                 msg=msg,
245                 **kwargs
246             )
247         except AssertionError as e:
248             failures.append(str(e))
249     if failures:
250         raise AssertionError('\n===\n'.join(failures))
251 @assert_equal.register(mappingproxy, mappingproxy)
252 def asssert_mappingproxy_equal(result, expected, path=(), msg='', **kwargs):
253     _check_sets(
254         set(result),
255         set(expected),
256         msg,
257         path + ('.keys()',),
258         'key',
259     )
260     failures = []
261     for k, resultv in iteritems(result):
262         expectedv = expected[k]
263         try:
264             assert_equal(
265                 resultv,
266                 expectedv,
267                 path=path + ('[%r]' % (k,),),
268                 msg=msg,
269                 **kwargs
270             )
271         except AssertionError as e:
272             failures.append(str(e))
273     if failures:
274         raise AssertionError('\n'.join(failures))
275 @assert_equal.register(OrderedDict, OrderedDict)
276 def assert_ordereddict_equal(result, expected, path=(), **kwargs):
277     assert_sequence_equal(
278         result.items(),
279         expected.items(),
280         path=path + ('.items()',),
281         **kwargs
282     )
283 @assert_equal.register(list, list)
284 @assert_equal.register(tuple, tuple)
285 def assert_sequence_equal(result, expected, path=(), msg='', **kwargs):
286     result_len = len(result)
287     expected_len = len(expected)
288     assert result_len == expected_len, (
289         '%s%s lengths do not match: %d != %d\n%s' % (
290             _fmt_msg(msg),
291             type(result).__name__,
292             result_len,
293             expected_len,
294             _fmt_path(path),
295         )
296     )
297     for n, (resultv, expectedv) in enumerate(zip(result, expected)):
298         assert_equal(
299             resultv,
300             expectedv,
301             path=path + ('[%d]' % n,),
302             msg=msg,
303             **kwargs
304         )
305 @assert_equal.register(set, set)
306 def assert_set_equal(result, expected, path=(), msg='', **kwargs):
307     _check_sets(
308         result,
309         expected,
310         msg,
311         path,
312         'element',
313     )
314 @assert_equal.register(np.ndarray, np.ndarray)
315 def assert_array_equal(result,
316                        expected,
317                        path=(),
318                        msg='',
319                        array_verbose=True,
320                        array_decimal=None,
321                        **kwargs):
322     result_dtype = result.dtype
323     expected_dtype = expected.dtype
324     if result_dtype.kind in 'mM' and expected_dtype.kind in 'mM':
325         assert result_dtype == expected_dtype, (
326             "\nType mismatch:\n\n"
327             "result dtype: %s\n"
328             "expected dtype: %s\n%s"
329             % (result_dtype, expected_dtype, _fmt_path(path))
330         )
331         f = partial(
332             assert_array_compare,
333             compare_datetime_arrays,
334             header='Arrays are not equal',
335         )
336     elif array_decimal is not None and expected_dtype.kind not in {'O', 'S'}:
337         f = partial(
338             np.testing.assert_array_almost_equal,
339             decimal=array_decimal,
340         )
341     else:
342         f = np.testing.assert_array_equal
343     try:
344         f(
345             result,
346             expected,
347             verbose=array_verbose,
348             err_msg=msg,
349         )
350     except AssertionError as e:
351         raise AssertionError('\n'.join((str(e), _fmt_path(path))))
352 @assert_equal.register(LabelArray, LabelArray)
353 def assert_labelarray_equal(result, expected, path=(), **kwargs):
354     assert_equal(
355         result.categories,
356         expected.categories,
357         path=path + ('.categories',),
358         **kwargs
359     )
360     assert_equal(
361         result.as_int_array(),
362         expected.as_int_array(),
363         path=path + ('.as_int_array()',),
364         **kwargs
365     )
366 def _register_assert_equal_wrapper(type_, assert_eq):
367     @assert_equal.register(type_, type_)
368     def assert_ndframe_equal(result, expected, path=(), msg='', **kwargs):
369         try:
370             assert_eq(
371                 result,
372                 expected,
373                 **filter_kwargs(assert_eq, kwargs)
374             )
375         except AssertionError as e:
376             raise AssertionError(
377                 _fmt_msg(msg) + '\n'.join((str(e), _fmt_path(path))),
378             )
379 <a name="1"></a>    return assert_ndframe_equal
380 assert_frame_equal <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _register_assert_equal_wrapper(
381     pd.DataFrame,
382     assert_frame_equal,
383 )
384 assert_panel_equal = _register_assert_equal_wrapper(
385     pd.Panel,
386     assert_panel_equal,
387 )
388 assert_series_equal = _register_assert_equal_wrapper(
389     pd.Series,
390     assert_series_equal,
391 )
392 assert_index_equal = _register_assert_equal_wrapper(
393     pd.</b></font>Index,
394     assert_index_equal,
395 )
396 @assert_equal.register(pd.Categorical, pd.Categorical)
397 def assert_categorical_equal(result, expected, path=(), msg='', **kwargs):
398     assert_equal(
399         result.categories,
400         expected.categories,
401         path=path + ('.categories',),
402         msg=msg,
403         **kwargs
404     )
405     assert_equal(
406         result.codes,
407         expected.codes,
408         path=path + ('.codes',),
409         msg=msg,
410         **kwargs
411     )
412 @assert_equal.register(Adjustment, Adjustment)
413 def assert_adjustment_equal(result, expected, path=(), **kwargs):
414     for attr in ('first_row', 'last_row', 'first_col', 'last_col', 'value'):
415         assert_equal(
416             getattr(result, attr),
417             getattr(expected, attr),
418             path=path + ('.' + attr,),
419             **kwargs
420         )
421 @assert_equal.register(
422     (datetime.datetime, np.datetime64),
423     (datetime.datetime, np.datetime64),
424 )
425 def assert_timestamp_and_datetime_equal(result,
426                                         expected,
427                                         path=(),
428                                         msg='',
429                                         allow_datetime_coercions=False,
430                                         compare_nat_equal=True,
431                                         **kwargs):
432     assert allow_datetime_coercions or type(result) == type(expected), (
433         "%sdatetime types (%s, %s) don't match and "
434         "allow_datetime_coercions was not set.\n%s" % (
435             _fmt_msg(msg),
436             type(result),
437             type(expected),
438             _fmt_path(path),
439         )
440     )
441     if isinstance(result, pd.Timestamp) and isinstance(expected, pd.Timestamp):
442         assert_equal(
443             result.tz,
444             expected.tz,
445             path=path + ('.tz',),
446             msg=msg,
447             **kwargs
448         )
449     result = pd.Timestamp(result)
450     expected = pd.Timestamp(expected)
451     if compare_nat_equal and pd.isnull(result) and pd.isnull(expected):
452         return
453     assert_equal.dispatch(object, object)(
454         result,
455         expected,
456         path=path,
457         msg=msg,
458         **kwargs
459     )
460 @assert_equal.register(slice, slice)
461 def assert_slice_equal(result, expected, path=(), msg=''):
462     diff_start = (
463         ('starts are not equal: %s != %s' % (result.start, result.stop))
464         if result.start != expected.start else
465         ''
466     )
467     diff_stop = (
468         ('stops are not equal: %s != %s' % (result.stop, result.stop))
469         if result.stop != expected.stop else
470         ''
471     )
472     diff_step = (
473         ('steps are not equal: %s != %s' % (result.step, result.stop))
474         if result.step != expected.step else
475         ''
476     )
477     diffs = diff_start, diff_stop, diff_step
478     assert not any(diffs), '%s%s\n%s' % (
479         _fmt_msg(msg),
480         '\n'.join(filter(None, diffs)),
481         _fmt_path(path),
482     )
483 @assert_equal.register(Asset, Asset)
484 def assert_asset_equal(result, expected, path=(), msg='', **kwargs):
485     if type(result) is not type(expected):
486         raise AssertionError(
487             '%sresult type differs from expected type: %s is not %s\n%s',
488             _fmt_msg(msg),
489             type(result).__name__,
490             type(expected).__name__,
491             _fmt_path(path),
492         )
493     assert_equal(
494         result.to_dict(),
495         expected.to_dict(),
496         path=path + ('.to_dict()',),
497         msg=msg,
498         **kwargs
499     )
500 def assert_isidentical(result, expected, msg=''):
501     assert result.isidentical(expected), (
502         '%s%s is not identical to %s' % (_fmt_msg(msg), result, expected)
503     )
504 def assert_messages_equal(result, expected, msg=''):
505     left_lines = result.splitlines(True)
506     right_lines = expected.splitlines(True)
507     iter_lines = enumerate(zip_longest(left_lines, right_lines))
508     for line, (ll, rl) in iter_lines:
509         if ll != rl:
510             col = index_of_first_difference(ll, rl)
511             raise AssertionError(
512                 "{msg}Messages differ on line {line}, col {col}:"
513                 "\n{ll!r}\n!=\n{rl!r}".format(
514                     msg=_fmt_msg(msg), line=line, col=col, ll=ll, rl=rl
515                 )
516             )
517 def index_of_first_difference(left, right):
518     difflocs = (i for (i, (lc, rc)) in enumerate(zip_longest(left, right))
519                 if lc != rc)
520     try:
521         return next(difflocs)
522     except StopIteration:
523         raise ValueError("Left was equal to right!")
524 try:
525     from datashape.util.testing import assert_dshape_equal
526 except ImportError:
527     pass
528 else:
529     assert_equal.funcs.update(
530         dissoc(assert_dshape_equal.funcs, (object, object)),
531     )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_technical.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import division
2 from nose_parameterized import parameterized
3 from six.moves import range
4 import numpy as np
5 import pandas as pd
6 import talib
7 from numpy.random import RandomState
8 from zipline.lib.adjusted_array import AdjustedArray
9 from zipline.pipeline.data import USEquityPricing
10 from zipline.pipeline.factors import (
11     BollingerBands,
12     Aroon,
13     FastStochasticOscillator,
14     IchimokuKinkoHyo,
15     LinearWeightedMovingAverage,
16     RateOfChangePercentage,
17     TrueRange,
18     MovingAverageConvergenceDivergenceSignal,
19     AnnualizedVolatility,
20     RSI,
21 )
22 from zipline.testing import check_allclose, parameter_space
23 from zipline.testing.fixtures import ZiplineTestCase
24 from zipline.testing.predicates import assert_equal
25 from</b></font> .base import BaseUSEquityPipelineTestCase
26 class BollingerBandsTestCase(BaseUSEquityPipelineTestCase):
27     def closes(self, mask_last_sid):
28         data = self.arange_data(dtype=np.float64)
29         if mask_last_sid:
30             data[:, -1] = np.nan
31         return data
32     def expected_bbands(self, window_length, k, closes):
33         lower_cols = []
34         middle_cols = []
35         upper_cols = []
36         ndates, nassets = closes.shape
37         for n in range(nassets):
38             close_col = closes[:, n]
39             if np.isnan(close_col).all():
40                 upper, middle, lower = [np.full(ndates, np.nan)] * 3
41             else:
42                 upper, middle, lower = talib.BBANDS(
43                     close_col,
44                     window_length,
45                     k,
46                     k,
47                 )
48             upper_cols.append(upper)
49             middle_cols.append(middle)
50             lower_cols.append(lower)
51         where = np.s_[window_length - 1:]
52         uppers = np.column_stack(upper_cols)[where]
53         middles = np.column_stack(middle_cols)[where]
54         lowers = np.column_stack(lower_cols)[where]
55         return uppers, middles, lowers
56     @parameter_space(
57         window_length={5, 10, 20},
58         k={1.5, 2, 2.5},
59         mask_last_sid={True, False},
60         __fail_fast=True,
61     )
62     def test_bollinger_bands(self, window_length, k, mask_last_sid):
63         closes = self.closes(mask_last_sid=mask_last_sid)
64         mask = ~np.isnan(closes)
65         bbands = BollingerBands(window_length=window_length, k=k)
66         expected = self.expected_bbands(window_length, k, closes)
67         self.check_terms(
68             terms={
69                 'upper': bbands.upper,
70                 'middle': bbands.middle,
71                 'lower': bbands.lower,
72             },
73             expected={
74                 'upper': expected[0],
75                 'middle': expected[1],
76                 'lower': expected[2],
77             },
78             initial_workspace={
79                 USEquityPricing.close: AdjustedArray(
80                     data=closes,
81                     adjustments={},
82                     missing_value=np.nan,
83                 ),
84             },
85             mask=self.build_mask(mask),
86         )
87     def test_bollinger_bands_output_ordering(self):
88         bbands = BollingerBands(window_length=5, k=2)
89         lower, middle, upper = bbands
90         self.assertIs(lower, bbands.lower)
91         self.assertIs(middle, bbands.middle)
92         self.assertIs(upper, bbands.upper)
93 class AroonTestCase(ZiplineTestCase):
94     window_length = 10
95     nassets = 5
96     dtype = [('down', 'f8'), ('up', 'f8')]
97     @parameterized.expand([
98         (np.arange(window_length),
99          np.arange(window_length) + 1,
100          np.recarray(shape=(nassets,), dtype=dtype,
101                      buf=np.array([0, 100] * nassets, dtype='f8'))),
102         (np.arange(window_length, 0, -1),
103          np.arange(window_length, 0, -1) - 1,
104          np.recarray(shape=(nassets,), dtype=dtype,
105                      buf=np.array([100, 0] * nassets, dtype='f8'))),
106         (np.array([10, 10, 10, 1, 10, 10, 10, 10, 10, 10]),
107          np.array([1, 1, 1, 1, 1, 10, 1, 1, 1, 1]),
108          np.recarray(shape=(nassets,), dtype=dtype,
109                      buf=np.array([100 * 3 / 9, 100 * 5 / 9] * nassets,
110                                   dtype='f8'))),
111     ])
112     def test_aroon_basic(self, lows, highs, expected_out):
113         aroon = Aroon(window_length=self.window_length)
114         today = pd.Timestamp('2014', tz='utc')
115         assets = pd.Index(np.arange(self.nassets, dtype=np.int64))
116         shape = (self.nassets,)
117         out = np.recarray(shape=shape, dtype=self.dtype,
118                           buf=np.empty(shape=shape, dtype=self.dtype))
119         aroon.compute(today, assets, out, lows, highs)
120         assert_equal(out, expected_out)
121 class TestFastStochasticOscillator(ZiplineTestCase):
122     def test_fso_expected_basic(self):
123         fso = FastStochasticOscillator()
124         today = pd.Timestamp('2015')
125         assets = np.arange(3, dtype=np.float64)
126         out = np.empty(shape=(3,), dtype=np.float64)
127         highs = np.full((50, 3), 3, dtype=np.float64)
128         lows = np.full((50, 3), 2, dtype=np.float64)
129         closes = np.full((50, 3), 4, dtype=np.float64)
130         fso.compute(today, assets, out, closes, lows, highs)
131         assert_equal(out, np.full((3,), 200, dtype=np.float64))
132     @parameter_space(seed=range(5))
133     def test_fso_expected_with_talib(self, seed):
134         window_length = 14
135         nassets = 6
136         rng = np.random.RandomState(seed=seed)
137         input_size = (window_length, nassets)
138         closes = 9.0 + (rng.random_sample(input_size) * 3.0)
139         highs = 13.0 + (rng.random_sample(input_size) * 2.0)
140         lows = 6.0 + (rng.random_sample(input_size) * 2.0)
141         expected_out_k = []
142         for i in range(nassets):
143             fastk, fastd = talib.STOCHF(
144                 high=highs[:, i],
145                 low=lows[:, i],
146                 close=closes[:, i],
147                 fastk_period=window_length,
148                 fastd_period=1,
149             )
150             expected_out_k.append(fastk[-1])
151         expected_out_k = np.array(expected_out_k)
152         today = pd.Timestamp('2015')
153         out = np.empty(shape=(nassets,), dtype=np.float)
154         assets = np.arange(nassets, dtype=np.float)
155         fso = FastStochasticOscillator()
156         fso.compute(
157             today, assets, out, closes, lows, highs
158         )
159         assert_equal(out, expected_out_k, array_decimal=6)
160 class IchimokuKinkoHyoTestCase(ZiplineTestCase):
161     def test_ichimoku_kinko_hyo(self):
162         window_length = 52
163         today = pd.Timestamp('2014', tz='utc')
164         nassets = 5
165         assets = pd.Index(np.arange(nassets))
166         days_col = np.arange(window_length)[:, np.newaxis]
167         highs = np.arange(nassets) + 2 + days_col
168         closes = np.arange(nassets) + 1 + days_col
169         lows = np.arange(nassets) + days_col
170         tenkan_sen_length = 9
171         kijun_sen_length = 26
172         chikou_span_length = 26
173         ichimoku_kinko_hyo = IchimokuKinkoHyo(
174             window_length=window_length,
175             tenkan_sen_length=tenkan_sen_length,
176             kijun_sen_length=kijun_sen_length,
177             chikou_span_length=chikou_span_length,
178         )
179         dtype = [
180             ('tenkan_sen', 'f8'),
181             ('kijun_sen', 'f8'),
182             ('senkou_span_a', 'f8'),
183             ('senkou_span_b', 'f8'),
184             ('chikou_span', 'f8'),
185         ]
186         out = np.recarray(
187             shape=(nassets,),
188             dtype=dtype,
189             buf=np.empty(shape=(nassets,), dtype=dtype),
190         )
191         ichimoku_kinko_hyo.compute(
192             today,
193             assets,
194             out,
195             highs,
196             lows,
197             closes,
198             tenkan_sen_length,
199             kijun_sen_length,
200             chikou_span_length,
201         )
202         expected_tenkan_sen = np.array([
203             (53 + 43) / 2,
204             (54 + 44) / 2,
205             (55 + 45) / 2,
206             (56 + 46) / 2,
207             (57 + 47) / 2,
208         ])
209         expected_kijun_sen = np.array([
210             (53 + 26) / 2,
211             (54 + 27) / 2,
212             (55 + 28) / 2,
213             (56 + 29) / 2,
214             (57 + 30) / 2,
215         ])
216         expected_senkou_span_a = (expected_tenkan_sen + expected_kijun_sen) / 2
217         expected_senkou_span_b = np.array([
218             (53 + 0) / 2,
219             (54 + 1) / 2,
220             (55 + 2) / 2,
221             (56 + 3) / 2,
222             (57 + 4) / 2,
223         ])
224         expected_chikou_span = np.array([
225             27.0,
226             28.0,
227             29.0,
228             30.0,
229             31.0,
230         ])
231 <a name="1"></a>        assert_equal(
232             out.tenkan_sen,
233             expected_tenkan_sen,
234             msg<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='tenkan_sen',
235         )
236         assert_equal(
237             out.kijun_sen,
238             expected_kijun_sen,
239             msg='kijun_sen',
240         )
241         assert_equal(
242             out.senkou_span_a,
243             expected_senkou_span_a,
244             msg='senkou_span_a',
245         )
246         assert_equal(
247             out.senkou_span_b,
248             expected_senkou_span_b,
249             msg='senkou_span_b',
250         )
251         assert_equal(
252             out.</b></font>chikou_span,
253             expected_chikou_span,
254             msg='chikou_span',
255         )
256     @parameter_space(
257         arg={'tenkan_sen_length', 'kijun_sen_length', 'chikou_span_length'},
258     )
259     def test_input_validation(self, arg):
260         window_length = 52
261         with self.assertRaises(ValueError) as e:
262             IchimokuKinkoHyo(**{arg: window_length + 1})
263         assert_equal(
264             str(e.exception),
265             '%s must be &lt;= the window_length: 53 &gt; 52' % arg,
266         )
267 class TestRateOfChangePercentage(ZiplineTestCase):
268     @parameterized.expand([
269         ('constant', [2.] * 10, 0.0),
270         ('step', [2.] + [1.] * 9, -50.0),
271         ('linear', [2. + x for x in range(10)], 450.0),
272         ('quadratic', [2. + x**2 for x in range(10)], 4050.0),
273     ])
274     def test_rate_of_change_percentage(self, test_name, data, expected):
275         window_length = len(data)
276         rocp = RateOfChangePercentage(
277             inputs=(USEquityPricing.close,),
278             window_length=window_length,
279         )
280         today = pd.Timestamp('2014')
281         assets = np.arange(5, dtype=np.int64)
282         data = np.array(data)[:, np.newaxis] * np.ones(len(assets))
283         out = np.zeros(len(assets))
284         rocp.compute(today, assets, out, data)
285         assert_equal(out, np.full((len(assets),), expected))
286 class TestLinearWeightedMovingAverage(ZiplineTestCase):
287     def test_wma1(self):
288         wma1 = LinearWeightedMovingAverage(
289             inputs=(USEquityPricing.close,),
290             window_length=10
291         )
292         today = pd.Timestamp('2015')
293         assets = np.arange(5, dtype=np.int64)
294         data = np.ones((10, 5))
295         out = np.zeros(data.shape[1])
296         wma1.compute(today, assets, out, data)
297         assert_equal(out, np.ones(5))
298     def test_wma2(self):
299         wma2 = LinearWeightedMovingAverage(
300             inputs=(USEquityPricing.close,),
301             window_length=10
302         )
303         today = pd.Timestamp('2015')
304         assets = np.arange(5, dtype=np.int64)
305         data = np.arange(50, dtype=np.float64).reshape((10, 5))
306         out = np.zeros(data.shape[1])
307         wma2.compute(today, assets, out, data)
308         assert_equal(out, np.array([30.,  31.,  32.,  33.,  34.]))
309 class TestTrueRange(ZiplineTestCase):
310     def test_tr_basic(self):
311         tr = TrueRange()
312         today = pd.Timestamp('2014')
313         assets = np.arange(3, dtype=np.int64)
314         out = np.empty(3, dtype=np.float64)
315         highs = np.full((2, 3), 3.)
316         lows = np.full((2, 3), 2.)
317         closes = np.full((2, 3), 1.)
318         tr.compute(today, assets, out, highs, lows, closes)
319         assert_equal(out, np.full((3,), 2.))
320 class MovingAverageConvergenceDivergenceTestCase(ZiplineTestCase):
321     def expected_ewma(self, data_df, window):
322         return data_df.rolling(window).apply(
323             lambda sub: pd.DataFrame(sub)
324             .ewm(span=window)
325             .mean()
326             .values[-1])
327     @parameter_space(seed=range(5))
328     def test_MACD_window_length_generation(self, seed):
329         rng = RandomState(seed)
330         signal_period = rng.randint(1, 90)
331         fast_period = rng.randint(signal_period + 1, signal_period + 100)
332         slow_period = rng.randint(fast_period + 1, fast_period + 100)
333         ewma = MovingAverageConvergenceDivergenceSignal(
334             fast_period=fast_period,
335             slow_period=slow_period,
336             signal_period=signal_period,
337         )
338         assert_equal(
339             ewma.window_length,
340             slow_period + signal_period - 1,
341         )
342     def test_bad_inputs(self):
343         template = (
344             "MACDSignal() expected a value greater than or equal to 1"
345             " for argument %r, but got 0 instead."
346         )
347         with self.assertRaises(ValueError) as e:
348             MovingAverageConvergenceDivergenceSignal(fast_period=0)
349         self.assertEqual(template % 'fast_period', str(e.exception))
350         with self.assertRaises(ValueError) as e:
351             MovingAverageConvergenceDivergenceSignal(slow_period=0)
352         self.assertEqual(template % 'slow_period', str(e.exception))
353         with self.assertRaises(ValueError) as e:
354             MovingAverageConvergenceDivergenceSignal(signal_period=0)
355         self.assertEqual(template % 'signal_period', str(e.exception))
356         with self.assertRaises(ValueError) as e:
357             MovingAverageConvergenceDivergenceSignal(
358                 fast_period=5,
359                 slow_period=4,
360             )
361         expected = (
362             "'slow_period' must be greater than 'fast_period', but got\n"
363             "slow_period=4, fast_period=5"
364         )
365         self.assertEqual(expected, str(e.exception))
366     @parameter_space(
367         seed=range(2),
368         fast_period=[3, 5],
369         slow_period=[8, 10],
370         signal_period=[3, 9],
371         __fail_fast=True,
372     )
373     def test_moving_average_convergence_divergence(self,
374                                                    seed,
375                                                    fast_period,
376                                                    slow_period,
377                                                    signal_period):
378         rng = RandomState(seed)
379         nassets = 3
380         macd = MovingAverageConvergenceDivergenceSignal(
381             fast_period=fast_period,
382             slow_period=slow_period,
383             signal_period=signal_period,
384         )
385         today = pd.Timestamp('2016', tz='utc')
386         assets = pd.Index(np.arange(nassets))
387         out = np.empty(shape=(nassets,), dtype=np.float64)
388         close = rng.rand(macd.window_length, nassets)
389         macd.compute(
390             today,
391             assets,
392             out,
393             close,
394             fast_period,
395             slow_period,
396             signal_period,
397         )
398         close_df = pd.DataFrame(close)
399         fast_ewma = self.expected_ewma(
400             close_df,
401             fast_period,
402         )
403         slow_ewma = self.expected_ewma(
404             close_df,
405             slow_period,
406         )
407         signal_ewma = self.expected_ewma(
408             fast_ewma - slow_ewma,
409             signal_period
410         )
411         self.assertTrue(signal_ewma.iloc[:-1].isnull().all().all())
412         expected_signal = signal_ewma.values[-1]
413         np.testing.assert_almost_equal(
414             out,
415             expected_signal,
416             decimal=8
417         )
418 class RSITestCase(ZiplineTestCase):
419     @parameterized.expand([
420         (100, np.array([41.032913785966, 51.553585468393, 51.022005016446])),
421         (101, np.array([43.506969935466, 46.145367530182, 50.57407044197])),
422         (102, np.array([46.610102205934, 47.646892444315, 52.13182788538])),
423     ])
424     def test_rsi(self, seed_value, expected):
425         rsi = RSI()
426         today = np.datetime64(1, 'ns')
427         assets = np.arange(3)
428         out = np.empty((3,), dtype=float)
429         np.random.seed(seed_value)  # Seed so we get deterministic results.
430         test_data = np.abs(np.random.randn(15, 3))
431         out = np.empty((3,), dtype=float)
432         rsi.compute(today, assets, out, test_data)
433         check_allclose(expected, out)
434     def test_rsi_all_positive_returns(self):
435         rsi = RSI()
436         today = np.datetime64(1, 'ns')
437         assets = np.arange(1)
438         out = np.empty((1,), dtype=float)
439         closes = np.linspace(46, 60, num=15)
440         closes.shape = (15, 1)
441         rsi.compute(today, assets, out, closes)
442         self.assertEqual(out[0], 100.0)
443     def test_rsi_all_negative_returns(self):
444         rsi = RSI()
445         today = np.datetime64(1, 'ns')
446         assets = np.arange(1)
447         out = np.empty((1,), dtype=float)
448         closes = np.linspace(46, 32, num=15)
449         closes.shape = (15, 1)
450         rsi.compute(today, assets, out, closes)
451         self.assertEqual(out[0], 0.0)
452     def test_rsi_same_returns(self):
453         rsi = RSI()
454         today = np.datetime64(1, 'ns')
455         assets = np.arange(2)
456         out = np.empty((2,), dtype=float)
457         example_case = np.array([46.125, 47.125, 46.4375, 46.9375, 44.9375,
458                                  44.25, 44.625, 45.75, 47.8125, 47.5625, 47.,
459                                  44.5625, 46.3125, 47.6875, 46.6875])
460         double = example_case * 2
461         closes = np.vstack((example_case, double)).T
462         rsi.compute(today, assets, out, closes)
463         self.assertAlmostEqual(out[0], out[1])
464 class AnnualizedVolatilityTestCase(ZiplineTestCase):
465     def test_simple_volatility(self):
466         nassets = 3
467         ann_vol = AnnualizedVolatility()
468         today = pd.Timestamp('2016', tz='utc')
469         assets = np.arange(nassets, dtype=np.float64)
470         returns = np.full((ann_vol.window_length, nassets),
471                           0.004,
472                           dtype=np.float64)
473         out = np.empty(shape=(nassets,), dtype=np.float64)
474         ann_vol.compute(today, assets, out, returns, 252)
475         expected_vol = np.zeros(nassets)
476         np.testing.assert_almost_equal(
477             out,
478             expected_vol,
479             decimal=8
480         )
481     def test_volatility(self):
482         nassets = 3
483         ann_vol = AnnualizedVolatility()
484         today = pd.Timestamp('2016', tz='utc')
485         assets = np.arange(nassets, dtype=np.float64)
486         returns = np.random.normal(loc=0.001,
487                                    scale=0.01,
488                                    size=(ann_vol.window_length, nassets))
489         out = np.empty(shape=(nassets,), dtype=np.float64)
490         ann_vol.compute(today, assets, out, returns, 252)
491         mean = np.mean(returns, axis=0)
492         annualized_variance = ((returns - mean) ** 2).sum(axis=0) / \
493             returns.shape[0] * 252
494         expected_vol = np.sqrt(annualized_variance)
495         np.testing.assert_almost_equal(
496             out,
497             expected_vol,
498             decimal=8
499         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
