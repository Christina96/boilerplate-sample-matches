<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for predicates.py &amp; test_technical.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for predicates.py &amp; test_technical.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>predicates.py (3.7518036%)<th>test_technical.py (2.6236124%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-48)<td><a href="#" name="0">(1-27)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(655-668)<td><a href="#" name="1">(299-317)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>predicates.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from contextlib import contextmanager
2 import datetime
3 from functools import partial
4 import re
5 from nose.tools import (  # noqa
6     assert_almost_equal,
7     assert_almost_equals,
8     assert_dict_contains_subset,
9     assert_false,
10     assert_greater,
11     assert_greater_equal,
12     assert_in,
13     assert_is,
14     assert_is_instance,
15     assert_is_none,
16     assert_is_not,
17     assert_is_not_none,
18     assert_less,
19     assert_less_equal,
20     assert_multi_line_equal,
21     assert_not_almost_equal,
22     assert_not_almost_equals,
23     assert_not_equal,
24     assert_not_equals,
25     assert_not_in,
26     assert_not_is_instance,
27     assert_raises,
28     assert_raises_regexp,
29     assert_regexp_matches,
30     assert_true,
31     assert_tuple_equal,
32 )
33 import numpy as np
34 import pandas as pd
35 from pandas.util.testing import (
36     assert_frame_equal,
37     assert_panel_equal,
38     assert_series_equal,
39     assert_index_equal,
40 )
41 from six import iteritems, viewkeys, PY2
42 from six.moves import zip_longest
43 from toolz import dissoc, keyfilter
44 import toolz.curried.operator as op
45 from</b></font> zipline.assets import Asset
46 from zipline.dispatch import dispatch
47 from zipline.lib.adjustment import Adjustment
48 from zipline.lib.labelarray import LabelArray
49 from zipline.testing.core import ensure_doctest
50 from zipline.utils.compat import getargspec, mappingproxy
51 from zipline.utils.formatting import s
52 from zipline.utils.functional import dzip_exact, instance
53 from zipline.utils.math_utils import tolerant_equals
54 from zipline.utils.numpy_utils import (
55     assert_array_compare,
56     compare_datetime_arrays,
57 )
58 @instance
59 @ensure_doctest
60 class wildcard(object):
61     @staticmethod
62     def __eq__(other):
63         return True
64     @staticmethod
65     def __ne__(other):
66         return False
67     def __repr__(self):
68         return '&lt;%s&gt;' % type(self).__name__
69 class instance_of(object):
70     def __init__(self, types, exact=False):
71         if not isinstance(types, tuple):
72             types = (types,)
73         for type_ in types:
74             if not isinstance(type_, type):
75                 raise TypeError('types must be a type or tuple of types')
76         self.types = types
77         self.exact = exact
78     def __eq__(self, other):
79         if self.exact:
80             return type(other) in self.types
81         return isinstance(other, self.types)
82     def __ne__(self, other):
83         return not self == other
84     def __repr__(self):
85         typenames = tuple(t.__name__ for t in self.types)
86         return '%s(%s%s)' % (
87             type(self).__name__,
88             (
89                 typenames[0]
90                 if len(typenames) == 1 else
91                 '(%s)' % ', '.join(typenames)
92             ),
93             ', exact=True' if self.exact else ''
94         )
95 def keywords(func):
96     if isinstance(func, type):
97         return keywords(func.__init__)
98     elif isinstance(func, partial):
99         return keywords(func.func)
100     return getargspec(func).args
101 def filter_kwargs(f, kwargs):
102     return keyfilter(op.contains(keywords(f)), kwargs)
103 def _fmt_path(path):
104     if not path:
105         return ''
106     return 'path: _' + ''.join(path)
107 def _fmt_msg(msg):
108     if not msg:
109         return ''
110     return msg + '\n'
111 def _safe_cls_name(cls):
112     try:
113         return cls.__name__
114     except AttributeError:
115         return repr(cls)
116 def assert_is_subclass(subcls, cls, msg=''):
117     assert issubclass(subcls, cls), (
118         '%s is not a subclass of %s\n%s' % (
119             _safe_cls_name(subcls),
120             _safe_cls_name(cls),
121             msg,
122         )
123     )
124 def assert_is_not_subclass(not_subcls, cls, msg=''):
125     assert not issubclass(not_subcls, cls), (
126         '%s is a subclass of %s\n%s' % (
127             _safe_cls_name(not_subcls),
128             _safe_cls_name(cls),
129             msg,
130         )
131     )
132 def assert_regex(result, expected, msg=''):
133     assert re.search(expected, result), (
134         '%s%r not found in %r' % (_fmt_msg(msg), expected, result)
135     )
136 @contextmanager
137 def _assert_raises_helper(do_check, exc_type, msg):
138     try:
139         yield
140     except exc_type as e:
141         do_check(e)
142     else:
143         raise AssertionError('%s%s was not raised' % (_fmt_msg(msg), exc_type))
144 def assert_raises_regex(exc, pattern, msg=''):
145     def check_exception(e):
146         assert re.search(pattern, str(e)), (
147             '%s%r not found in %r' % (_fmt_msg(msg), pattern, str(e))
148         )
149     return _assert_raises_helper(
150         do_check=check_exception,
151         exc_type=exc,
152         msg=msg,
153     )
154 def assert_raises_str(exc, expected_str, msg=''):
155     def check_exception(e):
156         result = str(e)
157         assert_messages_equal(result, expected_str, msg=msg)
158     return _assert_raises_helper(
159         check_exception,
160         exc_type=exc,
161         msg=msg,
162     )
163 def make_assert_equal_assertion_error(assertion_message, path, msg):
164     return AssertionError(
165         '%s%s\n%s' % (
166             _fmt_msg(msg),
167             assertion_message,
168             _fmt_path(path),
169         ),
170     )
171 @dispatch(object, object)
172 def assert_equal(result, expected, path=(), msg='', **kwargs):
173     if result != expected:
174         raise make_assert_equal_assertion_error(
175             '%s != %s' % (result, expected),
176             path,
177             msg,
178         )
179 @assert_equal.register(float, float)
180 def assert_float_equal(result,
181                        expected,
182                        path=(),
183                        msg='',
184                        float_rtol=10e-7,
185                        float_atol=10e-7,
186                        float_equal_nan=True,
187                        **kwargs):
188     assert tolerant_equals(
189         result,
190         expected,
191         rtol=float_rtol,
192         atol=float_atol,
193         equal_nan=float_equal_nan,
194     ), '%s%s != %s with rtol=%s and atol=%s%s\n%s' % (
195         _fmt_msg(msg),
196         result,
197         expected,
198         float_rtol,
199         float_atol,
200         (' (with nan != nan)' if not float_equal_nan else ''),
201         _fmt_path(path),
202     )
203 def _check_sets(result, expected, msg, path, type_):
204     if result != expected:
205         if result &gt; expected:
206             diff = result - expected
207             msg = 'extra %s in result: %r' % (s(type_, diff), diff)
208         elif result &lt; expected:
209             diff = expected - result
210             msg = 'result is missing %s: %r' % (s(type_, diff), diff)
211         else:
212             in_result = result - expected
213             in_expected = expected - result
214             msg = '%s only in result: %s\n%s only in expected: %s' % (
215                 s(type_, in_result),
216                 in_result,
217                 s(type_, in_expected),
218                 in_expected,
219             )
220         raise AssertionError(
221             '%ss do not match\n%s%s' % (
222                 type_,
223                 _fmt_msg(msg),
224                 _fmt_path(path),
225             ),
226         )
227 @assert_equal.register(dict, dict)
228 def assert_dict_equal(result, expected, path=(), msg='', **kwargs):
229     _check_sets(
230         viewkeys(result),
231         viewkeys(expected),
232         msg,
233         path + ('.%s()' % ('viewkeys' if PY2 else 'keys'),),
234         'key',
235     )
236     failures = []
237     for k, (resultv, expectedv) in iteritems(dzip_exact(result, expected)):
238         try:
239             assert_equal(
240                 resultv,
241                 expectedv,
242                 path=path + ('[%r]' % (k,),),
243                 msg=msg,
244                 **kwargs
245             )
246         except AssertionError as e:
247             failures.append(str(e))
248     if failures:
249         raise AssertionError('\n===\n'.join(failures))
250 @assert_equal.register(mappingproxy, mappingproxy)
251 def asssert_mappingproxy_equal(result, expected, path=(), msg='', **kwargs):
252     _check_sets(
253         set(result),
254         set(expected),
255         msg,
256         path + ('.keys()',),
257         'key',
258     )
259     failures = []
260     for k, resultv in iteritems(result):
261         expectedv = expected[k]
262         try:
263             assert_equal(
264                 resultv,
265                 expectedv,
266                 path=path + ('[%r]' % (k,),),
267                 msg=msg,
268                 **kwargs
269             )
270         except AssertionError as e:
271             failures.append(str(e))
272     if failures:
273         raise AssertionError('\n'.join(failures))
274 @assert_equal.register(OrderedDict, OrderedDict)
275 def assert_ordereddict_equal(result, expected, path=(), **kwargs):
276     assert_sequence_equal(
277         result.items(),
278         expected.items(),
279         path=path + ('.items()',),
280         **kwargs
281     )
282 @assert_equal.register(list, list)
283 @assert_equal.register(tuple, tuple)
284 def assert_sequence_equal(result, expected, path=(), msg='', **kwargs):
285     result_len = len(result)
286     expected_len = len(expected)
287     assert result_len == expected_len, (
288         '%s%s lengths do not match: %d != %d\n%s' % (
289             _fmt_msg(msg),
290             type(result).__name__,
291             result_len,
292             expected_len,
293             _fmt_path(path),
294         )
295     )
296     for n, (resultv, expectedv) in enumerate(zip(result, expected)):
297         assert_equal(
298             resultv,
299             expectedv,
300             path=path + ('[%d]' % n,),
301             msg=msg,
302             **kwargs
303         )
304 @assert_equal.register(set, set)
305 def assert_set_equal(result, expected, path=(), msg='', **kwargs):
306     _check_sets(
307         result,
308         expected,
309         msg,
310         path,
311         'element',
312     )
313 @assert_equal.register(np.ndarray, np.ndarray)
314 def assert_array_equal(result,
315                        expected,
316                        path=(),
317                        msg='',
318                        array_verbose=True,
319                        array_decimal=None,
320                        **kwargs):
321     result_dtype = result.dtype
322     expected_dtype = expected.dtype
323     if result_dtype.kind in 'mM' and expected_dtype.kind in 'mM':
324         assert result_dtype == expected_dtype, (
325             "\nType mismatch:\n\n"
326             "result dtype: %s\n"
327             "expected dtype: %s\n%s"
328             % (result_dtype, expected_dtype, _fmt_path(path))
329         )
330         f = partial(
331             assert_array_compare,
332             compare_datetime_arrays,
333             header='Arrays are not equal',
334         )
335     elif array_decimal is not None and expected_dtype.kind not in {'O', 'S'}:
336         f = partial(
337             np.testing.assert_array_almost_equal,
338             decimal=array_decimal,
339         )
340     else:
341         f = np.testing.assert_array_equal
342     try:
343         f(
344             result,
345             expected,
346             verbose=array_verbose,
347             err_msg=msg,
348         )
349     except AssertionError as e:
350         raise AssertionError('\n'.join((str(e), _fmt_path(path))))
351 @assert_equal.register(LabelArray, LabelArray)
352 def assert_labelarray_equal(result, expected, path=(), **kwargs):
353     assert_equal(
354         result.categories,
355         expected.categories,
356         path=path + ('.categories',),
357         **kwargs
358     )
359     assert_equal(
360         result.as_int_array(),
361         expected.as_int_array(),
362         path=path + ('.as_int_array()',),
363         **kwargs
364     )
365 def _register_assert_equal_wrapper(type_, assert_eq):
366     @assert_equal.register(type_, type_)
367     def assert_ndframe_equal(result, expected, path=(), msg='', **kwargs):
368         try:
369             assert_eq(
370                 result,
371                 expected,
372                 **filter_kwargs(assert_eq, kwargs)
373             )
374         except AssertionError as e:
375             raise AssertionError(
376                 _fmt_msg(msg) + '\n'.join((str(e), _fmt_path(path))),
377             )
378 assert_frame_equal <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _register_assert_equal_wrapper(
379     pd.DataFrame,
380     assert_frame_equal,
381 )
382 assert_panel_equal = _register_assert_equal_wrapper(
383     pd.Panel,
384     assert_panel_equal,
385 )
386 assert_series_equal = _register_assert_equal_wrapper(
387     pd.Series,
388     assert_series_equal,
389 )
390 assert_index_equal = _register_assert_equal_wrapper(
391     pd.</b></font>Index,
392     assert_index_equal,
393 )
394 @assert_equal.register(pd.Categorical, pd.Categorical)
395 def assert_categorical_equal(result, expected, path=(), msg='', **kwargs):
396     assert_equal(
397         result.categories,
398         expected.categories,
399         path=path + ('.categories',),
400         msg=msg,
401         **kwargs
402     )
403     assert_equal(
404         result.codes,
405         expected.codes,
406         path=path + ('.codes',),
407         msg=msg,
408         **kwargs
409     )
410 @assert_equal.register(Adjustment, Adjustment)
411 def assert_adjustment_equal(result, expected, path=(), **kwargs):
412     for attr in ('first_row', 'last_row', 'first_col', 'last_col', 'value'):
413         assert_equal(
414             getattr(result, attr),
415             getattr(expected, attr),
416             path=path + ('.' + attr,),
417             **kwargs
418         )
419 @assert_equal.register(
420     (datetime.datetime, np.datetime64),
421     (datetime.datetime, np.datetime64),
422 )
423 def assert_timestamp_and_datetime_equal(result,
424                                         expected,
425                                         path=(),
426                                         msg='',
427                                         allow_datetime_coercions=False,
428                                         compare_nat_equal=True,
429                                         **kwargs):
430     assert allow_datetime_coercions or type(result) == type(expected), (
431         "%sdatetime types (%s, %s) don't match and "
432         "allow_datetime_coercions was not set.\n%s" % (
433             _fmt_msg(msg),
434             type(result),
435             type(expected),
436             _fmt_path(path),
437         )
438     )
439     if isinstance(result, pd.Timestamp) and isinstance(expected, pd.Timestamp):
440         assert_equal(
441             result.tz,
442             expected.tz,
443             path=path + ('.tz',),
444             msg=msg,
445             **kwargs
446         )
447     result = pd.Timestamp(result)
448     expected = pd.Timestamp(expected)
449     if compare_nat_equal and pd.isnull(result) and pd.isnull(expected):
450         return
451     assert_equal.dispatch(object, object)(
452         result,
453         expected,
454         path=path,
455         msg=msg,
456         **kwargs
457     )
458 @assert_equal.register(slice, slice)
459 def assert_slice_equal(result, expected, path=(), msg=''):
460     diff_start = (
461         ('starts are not equal: %s != %s' % (result.start, result.stop))
462         if result.start != expected.start else
463         ''
464     )
465     diff_stop = (
466         ('stops are not equal: %s != %s' % (result.stop, result.stop))
467         if result.stop != expected.stop else
468         ''
469     )
470     diff_step = (
471         ('steps are not equal: %s != %s' % (result.step, result.stop))
472         if result.step != expected.step else
473         ''
474     )
475     diffs = diff_start, diff_stop, diff_step
476     assert not any(diffs), '%s%s\n%s' % (
477         _fmt_msg(msg),
478         '\n'.join(filter(None, diffs)),
479         _fmt_path(path),
480     )
481 @assert_equal.register(Asset, Asset)
482 def assert_asset_equal(result, expected, path=(), msg='', **kwargs):
483     if type(result) is not type(expected):
484         raise AssertionError(
485             '%sresult type differs from expected type: %s is not %s\n%s',
486             _fmt_msg(msg),
487             type(result).__name__,
488             type(expected).__name__,
489             _fmt_path(path),
490         )
491     assert_equal(
492         result.to_dict(),
493         expected.to_dict(),
494         path=path + ('.to_dict()',),
495         msg=msg,
496         **kwargs
497     )
498 def assert_isidentical(result, expected, msg=''):
499     assert result.isidentical(expected), (
500         '%s%s is not identical to %s' % (_fmt_msg(msg), result, expected)
501     )
502 def assert_messages_equal(result, expected, msg=''):
503     left_lines = result.splitlines(True)
504     right_lines = expected.splitlines(True)
505     iter_lines = enumerate(zip_longest(left_lines, right_lines))
506     for line, (ll, rl) in iter_lines:
507         if ll != rl:
508             col = index_of_first_difference(ll, rl)
509             raise AssertionError(
510                 "{msg}Messages differ on line {line}, col {col}:"
511                 "\n{ll!r}\n!=\n{rl!r}".format(
512                     msg=_fmt_msg(msg), line=line, col=col, ll=ll, rl=rl
513                 )
514             )
515 def index_of_first_difference(left, right):
516     difflocs = (i for (i, (lc, rc)) in enumerate(zip_longest(left, right))
517                 if lc != rc)
518     try:
519         return next(difflocs)
520     except StopIteration:
521         raise ValueError("Left was equal to right!")
522 try:
523     from datashape.util.testing import assert_dshape_equal
524 except ImportError:
525     pass
526 else:
527     assert_equal.funcs.update(
528         dissoc(assert_dshape_equal.funcs, (object, object)),
529     )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_technical.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from nose_parameterized import parameterized
2 from six.moves import range
3 import numpy as np
4 import pandas as pd
5 import talib
6 from numpy.random import RandomState
7 from zipline.lib.adjusted_array import AdjustedArray
8 from zipline.pipeline.data import USEquityPricing
9 from zipline.pipeline.factors import (
10     BollingerBands,
11     Aroon,
12     FastStochasticOscillator,
13     IchimokuKinkoHyo,
14     LinearWeightedMovingAverage,
15     RateOfChangePercentage,
16     TrueRange,
17     MovingAverageConvergenceDivergenceSignal,
18     AnnualizedVolatility,
19     RSI,
20 )
21 from zipline.testing import check_allclose, parameter_space
22 from zipline.testing.fixtures import ZiplineTestCase
23 from zipline.testing.predicates import assert_equal
24 from</b></font> .base import BaseUSEquityPipelineTestCase
25 class BollingerBandsTestCase(BaseUSEquityPipelineTestCase):
26     def closes(self, mask_last_sid):
27         data = self.arange_data(dtype=np.float64)
28         if mask_last_sid:
29             data[:, -1] = np.nan
30         return data
31     def expected_bbands(self, window_length, k, closes):
32         lower_cols = []
33         middle_cols = []
34         upper_cols = []
35         ndates, nassets = closes.shape
36         for n in range(nassets):
37             close_col = closes[:, n]
38             if np.isnan(close_col).all():
39                 upper, middle, lower = [np.full(ndates, np.nan)] * 3
40             else:
41                 upper, middle, lower = talib.BBANDS(
42                     close_col,
43                     window_length,
44                     k,
45                     k,
46                 )
47             upper_cols.append(upper)
48             middle_cols.append(middle)
49             lower_cols.append(lower)
50         where = np.s_[window_length - 1:]
51         uppers = np.column_stack(upper_cols)[where]
52         middles = np.column_stack(middle_cols)[where]
53         lowers = np.column_stack(lower_cols)[where]
54         return uppers, middles, lowers
55     @parameter_space(
56         window_length={5, 10, 20},
57         k={1.5, 2, 2.5},
58         mask_last_sid={True, False},
59         __fail_fast=True,
60     )
61     def test_bollinger_bands(self, window_length, k, mask_last_sid):
62         closes = self.closes(mask_last_sid=mask_last_sid)
63         mask = ~np.isnan(closes)
64         bbands = BollingerBands(window_length=window_length, k=k)
65         expected = self.expected_bbands(window_length, k, closes)
66         self.check_terms(
67             terms={
68                 'upper': bbands.upper,
69                 'middle': bbands.middle,
70                 'lower': bbands.lower,
71             },
72             expected={
73                 'upper': expected[0],
74                 'middle': expected[1],
75                 'lower': expected[2],
76             },
77             initial_workspace={
78                 USEquityPricing.close: AdjustedArray(
79                     data=closes,
80                     adjustments={},
81                     missing_value=np.nan,
82                 ),
83             },
84             mask=self.build_mask(mask),
85         )
86     def test_bollinger_bands_output_ordering(self):
87         bbands = BollingerBands(window_length=5, k=2)
88         lower, middle, upper = bbands
89         self.assertIs(lower, bbands.lower)
90         self.assertIs(middle, bbands.middle)
91         self.assertIs(upper, bbands.upper)
92 class AroonTestCase(ZiplineTestCase):
93     window_length = 10
94     nassets = 5
95     dtype = [('down', 'f8'), ('up', 'f8')]
96     @parameterized.expand([
97         (np.arange(window_length),
98          np.arange(window_length) + 1,
99          np.recarray(shape=(nassets,), dtype=dtype,
100                      buf=np.array([0, 100] * nassets, dtype='f8'))),
101         (np.arange(window_length, 0, -1),
102          np.arange(window_length, 0, -1) - 1,
103          np.recarray(shape=(nassets,), dtype=dtype,
104                      buf=np.array([100, 0] * nassets, dtype='f8'))),
105         (np.array([10, 10, 10, 1, 10, 10, 10, 10, 10, 10]),
106          np.array([1, 1, 1, 1, 1, 10, 1, 1, 1, 1]),
107          np.recarray(shape=(nassets,), dtype=dtype,
108                      buf=np.array([100 * 3 / 9, 100 * 5 / 9] * nassets,
109                                   dtype='f8'))),
110     ])
111     def test_aroon_basic(self, lows, highs, expected_out):
112         aroon = Aroon(window_length=self.window_length)
113         today = pd.Timestamp('2014', tz='utc')
114         assets = pd.Index(np.arange(self.nassets, dtype=np.int64))
115         shape = (self.nassets,)
116         out = np.recarray(shape=shape, dtype=self.dtype,
117                           buf=np.empty(shape=shape, dtype=self.dtype))
118         aroon.compute(today, assets, out, lows, highs)
119         assert_equal(out, expected_out)
120 class TestFastStochasticOscillator(ZiplineTestCase):
121     def test_fso_expected_basic(self):
122         fso = FastStochasticOscillator()
123         today = pd.Timestamp('2015')
124         assets = np.arange(3, dtype=np.float64)
125         out = np.empty(shape=(3,), dtype=np.float64)
126         highs = np.full((50, 3), 3, dtype=np.float64)
127         lows = np.full((50, 3), 2, dtype=np.float64)
128         closes = np.full((50, 3), 4, dtype=np.float64)
129         fso.compute(today, assets, out, closes, lows, highs)
130         assert_equal(out, np.full((3,), 200, dtype=np.float64))
131     @parameter_space(seed=range(5))
132     def test_fso_expected_with_talib(self, seed):
133         window_length = 14
134         nassets = 6
135         rng = np.random.RandomState(seed=seed)
136         input_size = (window_length, nassets)
137         closes = 9.0 + (rng.random_sample(input_size) * 3.0)
138         highs = 13.0 + (rng.random_sample(input_size) * 2.0)
139         lows = 6.0 + (rng.random_sample(input_size) * 2.0)
140         expected_out_k = []
141         for i in range(nassets):
142             fastk, fastd = talib.STOCHF(
143                 high=highs[:, i],
144                 low=lows[:, i],
145                 close=closes[:, i],
146                 fastk_period=window_length,
147                 fastd_period=1,
148             )
149             expected_out_k.append(fastk[-1])
150         expected_out_k = np.array(expected_out_k)
151         today = pd.Timestamp('2015')
152         out = np.empty(shape=(nassets,), dtype=np.float)
153         assets = np.arange(nassets, dtype=np.float)
154         fso = FastStochasticOscillator()
155         fso.compute(
156             today, assets, out, closes, lows, highs
157         )
158         assert_equal(out, expected_out_k, array_decimal=6)
159 class IchimokuKinkoHyoTestCase(ZiplineTestCase):
160     def test_ichimoku_kinko_hyo(self):
161         window_length = 52
162         today = pd.Timestamp('2014', tz='utc')
163         nassets = 5
164         assets = pd.Index(np.arange(nassets))
165         days_col = np.arange(window_length)[:, np.newaxis]
166         highs = np.arange(nassets) + 2 + days_col
167         closes = np.arange(nassets) + 1 + days_col
168         lows = np.arange(nassets) + days_col
169         tenkan_sen_length = 9
170         kijun_sen_length = 26
171         chikou_span_length = 26
172         ichimoku_kinko_hyo = IchimokuKinkoHyo(
173             window_length=window_length,
174             tenkan_sen_length=tenkan_sen_length,
175             kijun_sen_length=kijun_sen_length,
176             chikou_span_length=chikou_span_length,
177         )
178         dtype = [
179             ('tenkan_sen', 'f8'),
180             ('kijun_sen', 'f8'),
181             ('senkou_span_a', 'f8'),
182             ('senkou_span_b', 'f8'),
183             ('chikou_span', 'f8'),
184         ]
185         out = np.recarray(
186             shape=(nassets,),
187             dtype=dtype,
188             buf=np.empty(shape=(nassets,), dtype=dtype),
189         )
190         ichimoku_kinko_hyo.compute(
191             today,
192             assets,
193             out,
194             highs,
195             lows,
196             closes,
197             tenkan_sen_length,
198             kijun_sen_length,
199             chikou_span_length,
200         )
201         expected_tenkan_sen = np.array([
202             (53 + 43) / 2,
203             (54 + 44) / 2,
204             (55 + 45) / 2,
205             (56 + 46) / 2,
206             (57 + 47) / 2,
207         ])
208         expected_kijun_sen = np.array([
209             (53 + 26) / 2,
210             (54 + 27) / 2,
211             (55 + 28) / 2,
212             (56 + 29) / 2,
213             (57 + 30) / 2,
214         ])
215         expected_senkou_span_a = (expected_tenkan_sen + expected_kijun_sen) / 2
216         expected_senkou_span_b = np.array([
217             (53 + 0) / 2,
218             (54 + 1) / 2,
219             (55 + 2) / 2,
220             (56 + 3) / 2,
221             (57 + 4) / 2,
222         ])
223         expected_chikou_span = np.array([
224             27.0,
225             28.0,
226             29.0,
227             30.0,
228             31.0,
229         ])
230             out.tenkan_sen,
231             expected_tenkan_sen,
232             msg<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='tenkan_sen',
233         )
234         assert_equal(
235             out.kijun_sen,
236             expected_kijun_sen,
237             msg='kijun_sen',
238         )
239         assert_equal(
240             out.senkou_span_a,
241             expected_senkou_span_a,
242             msg='senkou_span_a',
243         )
244         assert_equal(
245             out.senkou_span_b,
246             expected_senkou_span_b,
247             msg='senkou_span_b',
248         )
249         assert_equal(
250             out.</b></font>chikou_span,
251             expected_chikou_span,
252             msg='chikou_span',
253         )
254     @parameter_space(
255         arg={'tenkan_sen_length', 'kijun_sen_length', 'chikou_span_length'},
256     )
257     def test_input_validation(self, arg):
258         window_length = 52
259         with self.assertRaises(ValueError) as e:
260             IchimokuKinkoHyo(**{arg: window_length + 1})
261         assert_equal(
262             str(e.exception),
263             '%s must be &lt;= the window_length: 53 &gt; 52' % arg,
264         )
265 class TestRateOfChangePercentage(ZiplineTestCase):
266     @parameterized.expand([
267         ('constant', [2.] * 10, 0.0),
268         ('step', [2.] + [1.] * 9, -50.0),
269         ('linear', [2. + x for x in range(10)], 450.0),
270         ('quadratic', [2. + x**2 for x in range(10)], 4050.0),
271     ])
272     def test_rate_of_change_percentage(self, test_name, data, expected):
273         window_length = len(data)
274         rocp = RateOfChangePercentage(
275             inputs=(USEquityPricing.close,),
276             window_length=window_length,
277         )
278         today = pd.Timestamp('2014')
279         assets = np.arange(5, dtype=np.int64)
280         data = np.array(data)[:, np.newaxis] * np.ones(len(assets))
281         out = np.zeros(len(assets))
282         rocp.compute(today, assets, out, data)
283         assert_equal(out, np.full((len(assets),), expected))
284 class TestLinearWeightedMovingAverage(ZiplineTestCase):
285     def test_wma1(self):
286         wma1 = LinearWeightedMovingAverage(
287             inputs=(USEquityPricing.close,),
288             window_length=10
289         )
290         today = pd.Timestamp('2015')
291         assets = np.arange(5, dtype=np.int64)
292         data = np.ones((10, 5))
293         out = np.zeros(data.shape[1])
294         wma1.compute(today, assets, out, data)
295         assert_equal(out, np.ones(5))
296     def test_wma2(self):
297         wma2 = LinearWeightedMovingAverage(
298             inputs=(USEquityPricing.close,),
299             window_length=10
300         )
301         today = pd.Timestamp('2015')
302         assets = np.arange(5, dtype=np.int64)
303         data = np.arange(50, dtype=np.float64).reshape((10, 5))
304         out = np.zeros(data.shape[1])
305         wma2.compute(today, assets, out, data)
306         assert_equal(out, np.array([30.,  31.,  32.,  33.,  34.]))
307 class TestTrueRange(ZiplineTestCase):
308     def test_tr_basic(self):
309         tr = TrueRange()
310         today = pd.Timestamp('2014')
311         assets = np.arange(3, dtype=np.int64)
312         out = np.empty(3, dtype=np.float64)
313         highs = np.full((2, 3), 3.)
314         lows = np.full((2, 3), 2.)
315         closes = np.full((2, 3), 1.)
316         tr.compute(today, assets, out, highs, lows, closes)
317         assert_equal(out, np.full((3,), 2.))
318 class MovingAverageConvergenceDivergenceTestCase(ZiplineTestCase):
319     def expected_ewma(self, data_df, window):
320         return data_df.rolling(window).apply(
321             lambda sub: pd.DataFrame(sub)
322             .ewm(span=window)
323             .mean()
324             .values[-1])
325     @parameter_space(seed=range(5))
326     def test_MACD_window_length_generation(self, seed):
327         rng = RandomState(seed)
328         signal_period = rng.randint(1, 90)
329         fast_period = rng.randint(signal_period + 1, signal_period + 100)
330         slow_period = rng.randint(fast_period + 1, fast_period + 100)
331         ewma = MovingAverageConvergenceDivergenceSignal(
332             fast_period=fast_period,
333             slow_period=slow_period,
334             signal_period=signal_period,
335         )
336         assert_equal(
337             ewma.window_length,
338             slow_period + signal_period - 1,
339         )
340     def test_bad_inputs(self):
341         template = (
342             "MACDSignal() expected a value greater than or equal to 1"
343             " for argument %r, but got 0 instead."
344         )
345         with self.assertRaises(ValueError) as e:
346             MovingAverageConvergenceDivergenceSignal(fast_period=0)
347         self.assertEqual(template % 'fast_period', str(e.exception))
348         with self.assertRaises(ValueError) as e:
349             MovingAverageConvergenceDivergenceSignal(slow_period=0)
350         self.assertEqual(template % 'slow_period', str(e.exception))
351         with self.assertRaises(ValueError) as e:
352             MovingAverageConvergenceDivergenceSignal(signal_period=0)
353         self.assertEqual(template % 'signal_period', str(e.exception))
354         with self.assertRaises(ValueError) as e:
355             MovingAverageConvergenceDivergenceSignal(
356                 fast_period=5,
357                 slow_period=4,
358             )
359         expected = (
360             "'slow_period' must be greater than 'fast_period', but got\n"
361             "slow_period=4, fast_period=5"
362         )
363         self.assertEqual(expected, str(e.exception))
364     @parameter_space(
365         seed=range(2),
366         fast_period=[3, 5],
367         slow_period=[8, 10],
368         signal_period=[3, 9],
369         __fail_fast=True,
370     )
371     def test_moving_average_convergence_divergence(self,
372                                                    seed,
373                                                    fast_period,
374                                                    slow_period,
375                                                    signal_period):
376         rng = RandomState(seed)
377         nassets = 3
378         macd = MovingAverageConvergenceDivergenceSignal(
379             fast_period=fast_period,
380             slow_period=slow_period,
381             signal_period=signal_period,
382         )
383         today = pd.Timestamp('2016', tz='utc')
384         assets = pd.Index(np.arange(nassets))
385         out = np.empty(shape=(nassets,), dtype=np.float64)
386         close = rng.rand(macd.window_length, nassets)
387         macd.compute(
388             today,
389             assets,
390             out,
391             close,
392             fast_period,
393             slow_period,
394             signal_period,
395         )
396         close_df = pd.DataFrame(close)
397         fast_ewma = self.expected_ewma(
398             close_df,
399             fast_period,
400         )
401         slow_ewma = self.expected_ewma(
402             close_df,
403             slow_period,
404         )
405         signal_ewma = self.expected_ewma(
406             fast_ewma - slow_ewma,
407             signal_period
408         )
409         self.assertTrue(signal_ewma.iloc[:-1].isnull().all().all())
410         expected_signal = signal_ewma.values[-1]
411         np.testing.assert_almost_equal(
412             out,
413             expected_signal,
414             decimal=8
415         )
416 class RSITestCase(ZiplineTestCase):
417     @parameterized.expand([
418         (100, np.array([41.032913785966, 51.553585468393, 51.022005016446])),
419         (101, np.array([43.506969935466, 46.145367530182, 50.57407044197])),
420         (102, np.array([46.610102205934, 47.646892444315, 52.13182788538])),
421     ])
422     def test_rsi(self, seed_value, expected):
423         rsi = RSI()
424         today = np.datetime64(1, 'ns')
425         assets = np.arange(3)
426         out = np.empty((3,), dtype=float)
427         np.random.seed(seed_value)  # Seed so we get deterministic results.
428         test_data = np.abs(np.random.randn(15, 3))
429         out = np.empty((3,), dtype=float)
430         rsi.compute(today, assets, out, test_data)
431         check_allclose(expected, out)
432     def test_rsi_all_positive_returns(self):
433         rsi = RSI()
434         today = np.datetime64(1, 'ns')
435         assets = np.arange(1)
436         out = np.empty((1,), dtype=float)
437         closes = np.linspace(46, 60, num=15)
438         closes.shape = (15, 1)
439         rsi.compute(today, assets, out, closes)
440         self.assertEqual(out[0], 100.0)
441     def test_rsi_all_negative_returns(self):
442         rsi = RSI()
443         today = np.datetime64(1, 'ns')
444         assets = np.arange(1)
445         out = np.empty((1,), dtype=float)
446         closes = np.linspace(46, 32, num=15)
447         closes.shape = (15, 1)
448         rsi.compute(today, assets, out, closes)
449         self.assertEqual(out[0], 0.0)
450     def test_rsi_same_returns(self):
451         rsi = RSI()
452         today = np.datetime64(1, 'ns')
453         assets = np.arange(2)
454         out = np.empty((2,), dtype=float)
455         example_case = np.array([46.125, 47.125, 46.4375, 46.9375, 44.9375,
456                                  44.25, 44.625, 45.75, 47.8125, 47.5625, 47.,
457                                  44.5625, 46.3125, 47.6875, 46.6875])
458         double = example_case * 2
459         closes = np.vstack((example_case, double)).T
460         rsi.compute(today, assets, out, closes)
461         self.assertAlmostEqual(out[0], out[1])
462 class AnnualizedVolatilityTestCase(ZiplineTestCase):
463     def test_simple_volatility(self):
464         nassets = 3
465         ann_vol = AnnualizedVolatility()
466         today = pd.Timestamp('2016', tz='utc')
467         assets = np.arange(nassets, dtype=np.float64)
468         returns = np.full((ann_vol.window_length, nassets),
469                           0.004,
470                           dtype=np.float64)
471         out = np.empty(shape=(nassets,), dtype=np.float64)
472         ann_vol.compute(today, assets, out, returns, 252)
473         expected_vol = np.zeros(nassets)
474         np.testing.assert_almost_equal(
475             out,
476             expected_vol,
477             decimal=8
478         )
479     def test_volatility(self):
480         nassets = 3
481         ann_vol = AnnualizedVolatility()
482         today = pd.Timestamp('2016', tz='utc')
483         assets = np.arange(nassets, dtype=np.float64)
484         returns = np.random.normal(loc=0.001,
485                                    scale=0.01,
486                                    size=(ann_vol.window_length, nassets))
487         out = np.empty(shape=(nassets,), dtype=np.float64)
488         ann_vol.compute(today, assets, out, returns, 252)
489         mean = np.mean(returns, axis=0)
490         annualized_variance = ((returns - mean) ** 2).sum(axis=0) / \
491             returns.shape[0] * 252
492         expected_vol = np.sqrt(annualized_variance)
493         np.testing.assert_almost_equal(
494             out,
495             expected_vol,
496             decimal=8
497         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
