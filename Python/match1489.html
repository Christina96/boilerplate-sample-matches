<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for predicates.py &amp; test_technical.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for predicates.py &amp; test_technical.py
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>predicates.py (3.7518036%)<th>test_technical.py (2.6236124%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-48)<td><a href="#" name="0">(1-27)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(655-668)<td><a href="#" name="1">(299-317)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>predicates.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from collections import OrderedDict
from contextlib import contextmanager
import datetime
from functools import partial
import re
from nose.tools import (  # noqa
    assert_almost_equal,
    assert_almost_equals,
    assert_dict_contains_subset,
    assert_false,
    assert_greater,
    assert_greater_equal,
    assert_in,
    assert_is,
    assert_is_instance,
    assert_is_none,
    assert_is_not,
    assert_is_not_none,
    assert_less,
    assert_less_equal,
    assert_multi_line_equal,
    assert_not_almost_equal,
    assert_not_almost_equals,
    assert_not_equal,
    assert_not_equals,
    assert_not_in,
    assert_not_is_instance,
    assert_raises,
    assert_raises_regexp,
    assert_regexp_matches,
    assert_true,
    assert_tuple_equal,
)
import numpy as np
import pandas as pd
from pandas.util.testing import (
    assert_frame_equal,
    assert_panel_equal,
    assert_series_equal,
    assert_index_equal,
)
from six import iteritems, viewkeys, PY2
from six.moves import zip_longest
from toolz import dissoc, keyfilter
import toolz.curried.operator as op
from</b></font> zipline.assets import Asset
from zipline.dispatch import dispatch
from zipline.lib.adjustment import Adjustment
from zipline.lib.labelarray import LabelArray
from zipline.testing.core import ensure_doctest
from zipline.utils.compat import getargspec, mappingproxy
from zipline.utils.formatting import s
from zipline.utils.functional import dzip_exact, instance
from zipline.utils.math_utils import tolerant_equals
from zipline.utils.numpy_utils import (
    assert_array_compare,
    compare_datetime_arrays,
)
@instance
@ensure_doctest
class wildcard(object):
    @staticmethod
    def __eq__(other):
        return True
    @staticmethod
    def __ne__(other):
        return False
    def __repr__(self):
        return '&lt;%s&gt;' % type(self).__name__
class instance_of(object):
    def __init__(self, types, exact=False):
        if not isinstance(types, tuple):
            types = (types,)
        for type_ in types:
            if not isinstance(type_, type):
                raise TypeError('types must be a type or tuple of types')
        self.types = types
        self.exact = exact
    def __eq__(self, other):
        if self.exact:
            return type(other) in self.types
        return isinstance(other, self.types)
    def __ne__(self, other):
        return not self == other
    def __repr__(self):
        typenames = tuple(t.__name__ for t in self.types)
        return '%s(%s%s)' % (
            type(self).__name__,
            (
                typenames[0]
                if len(typenames) == 1 else
                '(%s)' % ', '.join(typenames)
            ),
            ', exact=True' if self.exact else ''
        )
def keywords(func):
    if isinstance(func, type):
        return keywords(func.__init__)
    elif isinstance(func, partial):
        return keywords(func.func)
    return getargspec(func).args
def filter_kwargs(f, kwargs):
    return keyfilter(op.contains(keywords(f)), kwargs)
def _fmt_path(path):
    if not path:
        return ''
    return 'path: _' + ''.join(path)
def _fmt_msg(msg):
    if not msg:
        return ''
    return msg + '\n'
def _safe_cls_name(cls):
    try:
        return cls.__name__
    except AttributeError:
        return repr(cls)
def assert_is_subclass(subcls, cls, msg=''):
    assert issubclass(subcls, cls), (
        '%s is not a subclass of %s\n%s' % (
            _safe_cls_name(subcls),
            _safe_cls_name(cls),
            msg,
        )
    )
def assert_is_not_subclass(not_subcls, cls, msg=''):
    assert not issubclass(not_subcls, cls), (
        '%s is a subclass of %s\n%s' % (
            _safe_cls_name(not_subcls),
            _safe_cls_name(cls),
            msg,
        )
    )
def assert_regex(result, expected, msg=''):
    assert re.search(expected, result), (
        '%s%r not found in %r' % (_fmt_msg(msg), expected, result)
    )
@contextmanager
def _assert_raises_helper(do_check, exc_type, msg):
    try:
        yield
    except exc_type as e:
        do_check(e)
    else:
        raise AssertionError('%s%s was not raised' % (_fmt_msg(msg), exc_type))
def assert_raises_regex(exc, pattern, msg=''):
    def check_exception(e):
        assert re.search(pattern, str(e)), (
            '%s%r not found in %r' % (_fmt_msg(msg), pattern, str(e))
        )
    return _assert_raises_helper(
        do_check=check_exception,
        exc_type=exc,
        msg=msg,
    )
def assert_raises_str(exc, expected_str, msg=''):
    def check_exception(e):
        result = str(e)
        assert_messages_equal(result, expected_str, msg=msg)
    return _assert_raises_helper(
        check_exception,
        exc_type=exc,
        msg=msg,
    )
def make_assert_equal_assertion_error(assertion_message, path, msg):
    return AssertionError(
        '%s%s\n%s' % (
            _fmt_msg(msg),
            assertion_message,
            _fmt_path(path),
        ),
    )
@dispatch(object, object)
def assert_equal(result, expected, path=(), msg='', **kwargs):
    if result != expected:
        raise make_assert_equal_assertion_error(
            '%s != %s' % (result, expected),
            path,
            msg,
        )
@assert_equal.register(float, float)
def assert_float_equal(result,
                       expected,
                       path=(),
                       msg='',
                       float_rtol=10e-7,
                       float_atol=10e-7,
                       float_equal_nan=True,
                       **kwargs):
    assert tolerant_equals(
        result,
        expected,
        rtol=float_rtol,
        atol=float_atol,
        equal_nan=float_equal_nan,
    ), '%s%s != %s with rtol=%s and atol=%s%s\n%s' % (
        _fmt_msg(msg),
        result,
        expected,
        float_rtol,
        float_atol,
        (' (with nan != nan)' if not float_equal_nan else ''),
        _fmt_path(path),
    )
def _check_sets(result, expected, msg, path, type_):
    if result != expected:
        if result &gt; expected:
            diff = result - expected
            msg = 'extra %s in result: %r' % (s(type_, diff), diff)
        elif result &lt; expected:
            diff = expected - result
            msg = 'result is missing %s: %r' % (s(type_, diff), diff)
        else:
            in_result = result - expected
            in_expected = expected - result
            msg = '%s only in result: %s\n%s only in expected: %s' % (
                s(type_, in_result),
                in_result,
                s(type_, in_expected),
                in_expected,
            )
        raise AssertionError(
            '%ss do not match\n%s%s' % (
                type_,
                _fmt_msg(msg),
                _fmt_path(path),
            ),
        )
@assert_equal.register(dict, dict)
def assert_dict_equal(result, expected, path=(), msg='', **kwargs):
    _check_sets(
        viewkeys(result),
        viewkeys(expected),
        msg,
        path + ('.%s()' % ('viewkeys' if PY2 else 'keys'),),
        'key',
    )
    failures = []
    for k, (resultv, expectedv) in iteritems(dzip_exact(result, expected)):
        try:
            assert_equal(
                resultv,
                expectedv,
                path=path + ('[%r]' % (k,),),
                msg=msg,
                **kwargs
            )
        except AssertionError as e:
            failures.append(str(e))
    if failures:
        raise AssertionError('\n===\n'.join(failures))
@assert_equal.register(mappingproxy, mappingproxy)
def asssert_mappingproxy_equal(result, expected, path=(), msg='', **kwargs):
    _check_sets(
        set(result),
        set(expected),
        msg,
        path + ('.keys()',),
        'key',
    )
    failures = []
    for k, resultv in iteritems(result):
        expectedv = expected[k]
        try:
            assert_equal(
                resultv,
                expectedv,
                path=path + ('[%r]' % (k,),),
                msg=msg,
                **kwargs
            )
        except AssertionError as e:
            failures.append(str(e))
    if failures:
        raise AssertionError('\n'.join(failures))
@assert_equal.register(OrderedDict, OrderedDict)
def assert_ordereddict_equal(result, expected, path=(), **kwargs):
    assert_sequence_equal(
        result.items(),
        expected.items(),
        path=path + ('.items()',),
        **kwargs
    )
@assert_equal.register(list, list)
@assert_equal.register(tuple, tuple)
def assert_sequence_equal(result, expected, path=(), msg='', **kwargs):
    result_len = len(result)
    expected_len = len(expected)
    assert result_len == expected_len, (
        '%s%s lengths do not match: %d != %d\n%s' % (
            _fmt_msg(msg),
            type(result).__name__,
            result_len,
            expected_len,
            _fmt_path(path),
        )
    )
    for n, (resultv, expectedv) in enumerate(zip(result, expected)):
        assert_equal(
            resultv,
            expectedv,
            path=path + ('[%d]' % n,),
            msg=msg,
            **kwargs
        )
@assert_equal.register(set, set)
def assert_set_equal(result, expected, path=(), msg='', **kwargs):
    _check_sets(
        result,
        expected,
        msg,
        path,
        'element',
    )
@assert_equal.register(np.ndarray, np.ndarray)
def assert_array_equal(result,
                       expected,
                       path=(),
                       msg='',
                       array_verbose=True,
                       array_decimal=None,
                       **kwargs):
    result_dtype = result.dtype
    expected_dtype = expected.dtype
    if result_dtype.kind in 'mM' and expected_dtype.kind in 'mM':
        assert result_dtype == expected_dtype, (
            "\nType mismatch:\n\n"
            "result dtype: %s\n"
            "expected dtype: %s\n%s"
            % (result_dtype, expected_dtype, _fmt_path(path))
        )
        f = partial(
            assert_array_compare,
            compare_datetime_arrays,
            header='Arrays are not equal',
        )
    elif array_decimal is not None and expected_dtype.kind not in {'O', 'S'}:
        f = partial(
            np.testing.assert_array_almost_equal,
            decimal=array_decimal,
        )
    else:
        f = np.testing.assert_array_equal
    try:
        f(
            result,
            expected,
            verbose=array_verbose,
            err_msg=msg,
        )
    except AssertionError as e:
        raise AssertionError('\n'.join((str(e), _fmt_path(path))))
@assert_equal.register(LabelArray, LabelArray)
def assert_labelarray_equal(result, expected, path=(), **kwargs):
    assert_equal(
        result.categories,
        expected.categories,
        path=path + ('.categories',),
        **kwargs
    )
    assert_equal(
        result.as_int_array(),
        expected.as_int_array(),
        path=path + ('.as_int_array()',),
        **kwargs
    )
def _register_assert_equal_wrapper(type_, assert_eq):
    @assert_equal.register(type_, type_)
    def assert_ndframe_equal(result, expected, path=(), msg='', **kwargs):
        try:
            assert_eq(
                result,
                expected,
                **filter_kwargs(assert_eq, kwargs)
            )
        except AssertionError as e:
            raise AssertionError(
                _fmt_msg(msg) + '\n'.join((str(e), _fmt_path(path))),
            )
<a name="1"></a>    return assert_ndframe_equal
assert_frame_equal <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _register_assert_equal_wrapper(
    pd.DataFrame,
    assert_frame_equal,
)
assert_panel_equal = _register_assert_equal_wrapper(
    pd.Panel,
    assert_panel_equal,
)
assert_series_equal = _register_assert_equal_wrapper(
    pd.Series,
    assert_series_equal,
)
assert_index_equal = _register_assert_equal_wrapper(
    pd.</b></font>Index,
    assert_index_equal,
)
@assert_equal.register(pd.Categorical, pd.Categorical)
def assert_categorical_equal(result, expected, path=(), msg='', **kwargs):
    assert_equal(
        result.categories,
        expected.categories,
        path=path + ('.categories',),
        msg=msg,
        **kwargs
    )
    assert_equal(
        result.codes,
        expected.codes,
        path=path + ('.codes',),
        msg=msg,
        **kwargs
    )
@assert_equal.register(Adjustment, Adjustment)
def assert_adjustment_equal(result, expected, path=(), **kwargs):
    for attr in ('first_row', 'last_row', 'first_col', 'last_col', 'value'):
        assert_equal(
            getattr(result, attr),
            getattr(expected, attr),
            path=path + ('.' + attr,),
            **kwargs
        )
@assert_equal.register(
    (datetime.datetime, np.datetime64),
    (datetime.datetime, np.datetime64),
)
def assert_timestamp_and_datetime_equal(result,
                                        expected,
                                        path=(),
                                        msg='',
                                        allow_datetime_coercions=False,
                                        compare_nat_equal=True,
                                        **kwargs):
    assert allow_datetime_coercions or type(result) == type(expected), (
        "%sdatetime types (%s, %s) don't match and "
        "allow_datetime_coercions was not set.\n%s" % (
            _fmt_msg(msg),
            type(result),
            type(expected),
            _fmt_path(path),
        )
    )
    if isinstance(result, pd.Timestamp) and isinstance(expected, pd.Timestamp):
        assert_equal(
            result.tz,
            expected.tz,
            path=path + ('.tz',),
            msg=msg,
            **kwargs
        )
    result = pd.Timestamp(result)
    expected = pd.Timestamp(expected)
    if compare_nat_equal and pd.isnull(result) and pd.isnull(expected):
        return
    assert_equal.dispatch(object, object)(
        result,
        expected,
        path=path,
        msg=msg,
        **kwargs
    )
@assert_equal.register(slice, slice)
def assert_slice_equal(result, expected, path=(), msg=''):
    diff_start = (
        ('starts are not equal: %s != %s' % (result.start, result.stop))
        if result.start != expected.start else
        ''
    )
    diff_stop = (
        ('stops are not equal: %s != %s' % (result.stop, result.stop))
        if result.stop != expected.stop else
        ''
    )
    diff_step = (
        ('steps are not equal: %s != %s' % (result.step, result.stop))
        if result.step != expected.step else
        ''
    )
    diffs = diff_start, diff_stop, diff_step
    assert not any(diffs), '%s%s\n%s' % (
        _fmt_msg(msg),
        '\n'.join(filter(None, diffs)),
        _fmt_path(path),
    )
@assert_equal.register(Asset, Asset)
def assert_asset_equal(result, expected, path=(), msg='', **kwargs):
    if type(result) is not type(expected):
        raise AssertionError(
            '%sresult type differs from expected type: %s is not %s\n%s',
            _fmt_msg(msg),
            type(result).__name__,
            type(expected).__name__,
            _fmt_path(path),
        )
    assert_equal(
        result.to_dict(),
        expected.to_dict(),
        path=path + ('.to_dict()',),
        msg=msg,
        **kwargs
    )
def assert_isidentical(result, expected, msg=''):
    assert result.isidentical(expected), (
        '%s%s is not identical to %s' % (_fmt_msg(msg), result, expected)
    )
def assert_messages_equal(result, expected, msg=''):
    left_lines = result.splitlines(True)
    right_lines = expected.splitlines(True)
    iter_lines = enumerate(zip_longest(left_lines, right_lines))
    for line, (ll, rl) in iter_lines:
        if ll != rl:
            col = index_of_first_difference(ll, rl)
            raise AssertionError(
                "{msg}Messages differ on line {line}, col {col}:"
                "\n{ll!r}\n!=\n{rl!r}".format(
                    msg=_fmt_msg(msg), line=line, col=col, ll=ll, rl=rl
                )
            )
def index_of_first_difference(left, right):
    difflocs = (i for (i, (lc, rc)) in enumerate(zip_longest(left, right))
                if lc != rc)
    try:
        return next(difflocs)
    except StopIteration:
        raise ValueError("Left was equal to right!")
try:
    from datashape.util.testing import assert_dshape_equal
except ImportError:
    pass
else:
    assert_equal.funcs.update(
        dissoc(assert_dshape_equal.funcs, (object, object)),
    )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_technical.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import division
from nose_parameterized import parameterized
from six.moves import range
import numpy as np
import pandas as pd
import talib
from numpy.random import RandomState
from zipline.lib.adjusted_array import AdjustedArray
from zipline.pipeline.data import USEquityPricing
from zipline.pipeline.factors import (
    BollingerBands,
    Aroon,
    FastStochasticOscillator,
    IchimokuKinkoHyo,
    LinearWeightedMovingAverage,
    RateOfChangePercentage,
    TrueRange,
    MovingAverageConvergenceDivergenceSignal,
    AnnualizedVolatility,
    RSI,
)
from zipline.testing import check_allclose, parameter_space
from zipline.testing.fixtures import ZiplineTestCase
from zipline.testing.predicates import assert_equal
from</b></font> .base import BaseUSEquityPipelineTestCase
class BollingerBandsTestCase(BaseUSEquityPipelineTestCase):
    def closes(self, mask_last_sid):
        data = self.arange_data(dtype=np.float64)
        if mask_last_sid:
            data[:, -1] = np.nan
        return data
    def expected_bbands(self, window_length, k, closes):
        lower_cols = []
        middle_cols = []
        upper_cols = []
        ndates, nassets = closes.shape
        for n in range(nassets):
            close_col = closes[:, n]
            if np.isnan(close_col).all():
                upper, middle, lower = [np.full(ndates, np.nan)] * 3
            else:
                upper, middle, lower = talib.BBANDS(
                    close_col,
                    window_length,
                    k,
                    k,
                )
            upper_cols.append(upper)
            middle_cols.append(middle)
            lower_cols.append(lower)
        where = np.s_[window_length - 1:]
        uppers = np.column_stack(upper_cols)[where]
        middles = np.column_stack(middle_cols)[where]
        lowers = np.column_stack(lower_cols)[where]
        return uppers, middles, lowers
    @parameter_space(
        window_length={5, 10, 20},
        k={1.5, 2, 2.5},
        mask_last_sid={True, False},
        __fail_fast=True,
    )
    def test_bollinger_bands(self, window_length, k, mask_last_sid):
        closes = self.closes(mask_last_sid=mask_last_sid)
        mask = ~np.isnan(closes)
        bbands = BollingerBands(window_length=window_length, k=k)
        expected = self.expected_bbands(window_length, k, closes)
        self.check_terms(
            terms={
                'upper': bbands.upper,
                'middle': bbands.middle,
                'lower': bbands.lower,
            },
            expected={
                'upper': expected[0],
                'middle': expected[1],
                'lower': expected[2],
            },
            initial_workspace={
                USEquityPricing.close: AdjustedArray(
                    data=closes,
                    adjustments={},
                    missing_value=np.nan,
                ),
            },
            mask=self.build_mask(mask),
        )
    def test_bollinger_bands_output_ordering(self):
        bbands = BollingerBands(window_length=5, k=2)
        lower, middle, upper = bbands
        self.assertIs(lower, bbands.lower)
        self.assertIs(middle, bbands.middle)
        self.assertIs(upper, bbands.upper)
class AroonTestCase(ZiplineTestCase):
    window_length = 10
    nassets = 5
    dtype = [('down', 'f8'), ('up', 'f8')]
    @parameterized.expand([
        (np.arange(window_length),
         np.arange(window_length) + 1,
         np.recarray(shape=(nassets,), dtype=dtype,
                     buf=np.array([0, 100] * nassets, dtype='f8'))),
        (np.arange(window_length, 0, -1),
         np.arange(window_length, 0, -1) - 1,
         np.recarray(shape=(nassets,), dtype=dtype,
                     buf=np.array([100, 0] * nassets, dtype='f8'))),
        (np.array([10, 10, 10, 1, 10, 10, 10, 10, 10, 10]),
         np.array([1, 1, 1, 1, 1, 10, 1, 1, 1, 1]),
         np.recarray(shape=(nassets,), dtype=dtype,
                     buf=np.array([100 * 3 / 9, 100 * 5 / 9] * nassets,
                                  dtype='f8'))),
    ])
    def test_aroon_basic(self, lows, highs, expected_out):
        aroon = Aroon(window_length=self.window_length)
        today = pd.Timestamp('2014', tz='utc')
        assets = pd.Index(np.arange(self.nassets, dtype=np.int64))
        shape = (self.nassets,)
        out = np.recarray(shape=shape, dtype=self.dtype,
                          buf=np.empty(shape=shape, dtype=self.dtype))
        aroon.compute(today, assets, out, lows, highs)
        assert_equal(out, expected_out)
class TestFastStochasticOscillator(ZiplineTestCase):
    def test_fso_expected_basic(self):
        fso = FastStochasticOscillator()
        today = pd.Timestamp('2015')
        assets = np.arange(3, dtype=np.float64)
        out = np.empty(shape=(3,), dtype=np.float64)
        highs = np.full((50, 3), 3, dtype=np.float64)
        lows = np.full((50, 3), 2, dtype=np.float64)
        closes = np.full((50, 3), 4, dtype=np.float64)
        fso.compute(today, assets, out, closes, lows, highs)
        assert_equal(out, np.full((3,), 200, dtype=np.float64))
    @parameter_space(seed=range(5))
    def test_fso_expected_with_talib(self, seed):
        window_length = 14
        nassets = 6
        rng = np.random.RandomState(seed=seed)
        input_size = (window_length, nassets)
        closes = 9.0 + (rng.random_sample(input_size) * 3.0)
        highs = 13.0 + (rng.random_sample(input_size) * 2.0)
        lows = 6.0 + (rng.random_sample(input_size) * 2.0)
        expected_out_k = []
        for i in range(nassets):
            fastk, fastd = talib.STOCHF(
                high=highs[:, i],
                low=lows[:, i],
                close=closes[:, i],
                fastk_period=window_length,
                fastd_period=1,
            )
            expected_out_k.append(fastk[-1])
        expected_out_k = np.array(expected_out_k)
        today = pd.Timestamp('2015')
        out = np.empty(shape=(nassets,), dtype=np.float)
        assets = np.arange(nassets, dtype=np.float)
        fso = FastStochasticOscillator()
        fso.compute(
            today, assets, out, closes, lows, highs
        )
        assert_equal(out, expected_out_k, array_decimal=6)
class IchimokuKinkoHyoTestCase(ZiplineTestCase):
    def test_ichimoku_kinko_hyo(self):
        window_length = 52
        today = pd.Timestamp('2014', tz='utc')
        nassets = 5
        assets = pd.Index(np.arange(nassets))
        days_col = np.arange(window_length)[:, np.newaxis]
        highs = np.arange(nassets) + 2 + days_col
        closes = np.arange(nassets) + 1 + days_col
        lows = np.arange(nassets) + days_col
        tenkan_sen_length = 9
        kijun_sen_length = 26
        chikou_span_length = 26
        ichimoku_kinko_hyo = IchimokuKinkoHyo(
            window_length=window_length,
            tenkan_sen_length=tenkan_sen_length,
            kijun_sen_length=kijun_sen_length,
            chikou_span_length=chikou_span_length,
        )
        dtype = [
            ('tenkan_sen', 'f8'),
            ('kijun_sen', 'f8'),
            ('senkou_span_a', 'f8'),
            ('senkou_span_b', 'f8'),
            ('chikou_span', 'f8'),
        ]
        out = np.recarray(
            shape=(nassets,),
            dtype=dtype,
            buf=np.empty(shape=(nassets,), dtype=dtype),
        )
        ichimoku_kinko_hyo.compute(
            today,
            assets,
            out,
            highs,
            lows,
            closes,
            tenkan_sen_length,
            kijun_sen_length,
            chikou_span_length,
        )
        expected_tenkan_sen = np.array([
            (53 + 43) / 2,
            (54 + 44) / 2,
            (55 + 45) / 2,
            (56 + 46) / 2,
            (57 + 47) / 2,
        ])
        expected_kijun_sen = np.array([
            (53 + 26) / 2,
            (54 + 27) / 2,
            (55 + 28) / 2,
            (56 + 29) / 2,
            (57 + 30) / 2,
        ])
        expected_senkou_span_a = (expected_tenkan_sen + expected_kijun_sen) / 2
        expected_senkou_span_b = np.array([
            (53 + 0) / 2,
            (54 + 1) / 2,
            (55 + 2) / 2,
            (56 + 3) / 2,
            (57 + 4) / 2,
        ])
        expected_chikou_span = np.array([
            27.0,
            28.0,
            29.0,
            30.0,
            31.0,
        ])
<a name="1"></a>        assert_equal(
            out.tenkan_sen,
            expected_tenkan_sen,
            msg<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>='tenkan_sen',
        )
        assert_equal(
            out.kijun_sen,
            expected_kijun_sen,
            msg='kijun_sen',
        )
        assert_equal(
            out.senkou_span_a,
            expected_senkou_span_a,
            msg='senkou_span_a',
        )
        assert_equal(
            out.senkou_span_b,
            expected_senkou_span_b,
            msg='senkou_span_b',
        )
        assert_equal(
            out.</b></font>chikou_span,
            expected_chikou_span,
            msg='chikou_span',
        )
    @parameter_space(
        arg={'tenkan_sen_length', 'kijun_sen_length', 'chikou_span_length'},
    )
    def test_input_validation(self, arg):
        window_length = 52
        with self.assertRaises(ValueError) as e:
            IchimokuKinkoHyo(**{arg: window_length + 1})
        assert_equal(
            str(e.exception),
            '%s must be &lt;= the window_length: 53 &gt; 52' % arg,
        )
class TestRateOfChangePercentage(ZiplineTestCase):
    @parameterized.expand([
        ('constant', [2.] * 10, 0.0),
        ('step', [2.] + [1.] * 9, -50.0),
        ('linear', [2. + x for x in range(10)], 450.0),
        ('quadratic', [2. + x**2 for x in range(10)], 4050.0),
    ])
    def test_rate_of_change_percentage(self, test_name, data, expected):
        window_length = len(data)
        rocp = RateOfChangePercentage(
            inputs=(USEquityPricing.close,),
            window_length=window_length,
        )
        today = pd.Timestamp('2014')
        assets = np.arange(5, dtype=np.int64)
        data = np.array(data)[:, np.newaxis] * np.ones(len(assets))
        out = np.zeros(len(assets))
        rocp.compute(today, assets, out, data)
        assert_equal(out, np.full((len(assets),), expected))
class TestLinearWeightedMovingAverage(ZiplineTestCase):
    def test_wma1(self):
        wma1 = LinearWeightedMovingAverage(
            inputs=(USEquityPricing.close,),
            window_length=10
        )
        today = pd.Timestamp('2015')
        assets = np.arange(5, dtype=np.int64)
        data = np.ones((10, 5))
        out = np.zeros(data.shape[1])
        wma1.compute(today, assets, out, data)
        assert_equal(out, np.ones(5))
    def test_wma2(self):
        wma2 = LinearWeightedMovingAverage(
            inputs=(USEquityPricing.close,),
            window_length=10
        )
        today = pd.Timestamp('2015')
        assets = np.arange(5, dtype=np.int64)
        data = np.arange(50, dtype=np.float64).reshape((10, 5))
        out = np.zeros(data.shape[1])
        wma2.compute(today, assets, out, data)
        assert_equal(out, np.array([30.,  31.,  32.,  33.,  34.]))
class TestTrueRange(ZiplineTestCase):
    def test_tr_basic(self):
        tr = TrueRange()
        today = pd.Timestamp('2014')
        assets = np.arange(3, dtype=np.int64)
        out = np.empty(3, dtype=np.float64)
        highs = np.full((2, 3), 3.)
        lows = np.full((2, 3), 2.)
        closes = np.full((2, 3), 1.)
        tr.compute(today, assets, out, highs, lows, closes)
        assert_equal(out, np.full((3,), 2.))
class MovingAverageConvergenceDivergenceTestCase(ZiplineTestCase):
    def expected_ewma(self, data_df, window):
        return data_df.rolling(window).apply(
            lambda sub: pd.DataFrame(sub)
            .ewm(span=window)
            .mean()
            .values[-1])
    @parameter_space(seed=range(5))
    def test_MACD_window_length_generation(self, seed):
        rng = RandomState(seed)
        signal_period = rng.randint(1, 90)
        fast_period = rng.randint(signal_period + 1, signal_period + 100)
        slow_period = rng.randint(fast_period + 1, fast_period + 100)
        ewma = MovingAverageConvergenceDivergenceSignal(
            fast_period=fast_period,
            slow_period=slow_period,
            signal_period=signal_period,
        )
        assert_equal(
            ewma.window_length,
            slow_period + signal_period - 1,
        )
    def test_bad_inputs(self):
        template = (
            "MACDSignal() expected a value greater than or equal to 1"
            " for argument %r, but got 0 instead."
        )
        with self.assertRaises(ValueError) as e:
            MovingAverageConvergenceDivergenceSignal(fast_period=0)
        self.assertEqual(template % 'fast_period', str(e.exception))
        with self.assertRaises(ValueError) as e:
            MovingAverageConvergenceDivergenceSignal(slow_period=0)
        self.assertEqual(template % 'slow_period', str(e.exception))
        with self.assertRaises(ValueError) as e:
            MovingAverageConvergenceDivergenceSignal(signal_period=0)
        self.assertEqual(template % 'signal_period', str(e.exception))
        with self.assertRaises(ValueError) as e:
            MovingAverageConvergenceDivergenceSignal(
                fast_period=5,
                slow_period=4,
            )
        expected = (
            "'slow_period' must be greater than 'fast_period', but got\n"
            "slow_period=4, fast_period=5"
        )
        self.assertEqual(expected, str(e.exception))
    @parameter_space(
        seed=range(2),
        fast_period=[3, 5],
        slow_period=[8, 10],
        signal_period=[3, 9],
        __fail_fast=True,
    )
    def test_moving_average_convergence_divergence(self,
                                                   seed,
                                                   fast_period,
                                                   slow_period,
                                                   signal_period):
        rng = RandomState(seed)
        nassets = 3
        macd = MovingAverageConvergenceDivergenceSignal(
            fast_period=fast_period,
            slow_period=slow_period,
            signal_period=signal_period,
        )
        today = pd.Timestamp('2016', tz='utc')
        assets = pd.Index(np.arange(nassets))
        out = np.empty(shape=(nassets,), dtype=np.float64)
        close = rng.rand(macd.window_length, nassets)
        macd.compute(
            today,
            assets,
            out,
            close,
            fast_period,
            slow_period,
            signal_period,
        )
        close_df = pd.DataFrame(close)
        fast_ewma = self.expected_ewma(
            close_df,
            fast_period,
        )
        slow_ewma = self.expected_ewma(
            close_df,
            slow_period,
        )
        signal_ewma = self.expected_ewma(
            fast_ewma - slow_ewma,
            signal_period
        )
        self.assertTrue(signal_ewma.iloc[:-1].isnull().all().all())
        expected_signal = signal_ewma.values[-1]
        np.testing.assert_almost_equal(
            out,
            expected_signal,
            decimal=8
        )
class RSITestCase(ZiplineTestCase):
    @parameterized.expand([
        (100, np.array([41.032913785966, 51.553585468393, 51.022005016446])),
        (101, np.array([43.506969935466, 46.145367530182, 50.57407044197])),
        (102, np.array([46.610102205934, 47.646892444315, 52.13182788538])),
    ])
    def test_rsi(self, seed_value, expected):
        rsi = RSI()
        today = np.datetime64(1, 'ns')
        assets = np.arange(3)
        out = np.empty((3,), dtype=float)
        np.random.seed(seed_value)  # Seed so we get deterministic results.
        test_data = np.abs(np.random.randn(15, 3))
        out = np.empty((3,), dtype=float)
        rsi.compute(today, assets, out, test_data)
        check_allclose(expected, out)
    def test_rsi_all_positive_returns(self):
        rsi = RSI()
        today = np.datetime64(1, 'ns')
        assets = np.arange(1)
        out = np.empty((1,), dtype=float)
        closes = np.linspace(46, 60, num=15)
        closes.shape = (15, 1)
        rsi.compute(today, assets, out, closes)
        self.assertEqual(out[0], 100.0)
    def test_rsi_all_negative_returns(self):
        rsi = RSI()
        today = np.datetime64(1, 'ns')
        assets = np.arange(1)
        out = np.empty((1,), dtype=float)
        closes = np.linspace(46, 32, num=15)
        closes.shape = (15, 1)
        rsi.compute(today, assets, out, closes)
        self.assertEqual(out[0], 0.0)
    def test_rsi_same_returns(self):
        rsi = RSI()
        today = np.datetime64(1, 'ns')
        assets = np.arange(2)
        out = np.empty((2,), dtype=float)
        example_case = np.array([46.125, 47.125, 46.4375, 46.9375, 44.9375,
                                 44.25, 44.625, 45.75, 47.8125, 47.5625, 47.,
                                 44.5625, 46.3125, 47.6875, 46.6875])
        double = example_case * 2
        closes = np.vstack((example_case, double)).T
        rsi.compute(today, assets, out, closes)
        self.assertAlmostEqual(out[0], out[1])
class AnnualizedVolatilityTestCase(ZiplineTestCase):
    def test_simple_volatility(self):
        nassets = 3
        ann_vol = AnnualizedVolatility()
        today = pd.Timestamp('2016', tz='utc')
        assets = np.arange(nassets, dtype=np.float64)
        returns = np.full((ann_vol.window_length, nassets),
                          0.004,
                          dtype=np.float64)
        out = np.empty(shape=(nassets,), dtype=np.float64)
        ann_vol.compute(today, assets, out, returns, 252)
        expected_vol = np.zeros(nassets)
        np.testing.assert_almost_equal(
            out,
            expected_vol,
            decimal=8
        )
    def test_volatility(self):
        nassets = 3
        ann_vol = AnnualizedVolatility()
        today = pd.Timestamp('2016', tz='utc')
        assets = np.arange(nassets, dtype=np.float64)
        returns = np.random.normal(loc=0.001,
                                   scale=0.01,
                                   size=(ann_vol.window_length, nassets))
        out = np.empty(shape=(nassets,), dtype=np.float64)
        ann_vol.compute(today, assets, out, returns, 252)
        mean = np.mean(returns, axis=0)
        annualized_variance = ((returns - mean) ** 2).sum(axis=0) / \
            returns.shape[0] * 252
        expected_vol = np.sqrt(annualized_variance)
        np.testing.assert_almost_equal(
            out,
            expected_vol,
            decimal=8
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
