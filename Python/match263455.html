<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for query.py & test_mysql_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for query.py & test_mysql_1.py
      </h3>
      <h1 align="center">
        0.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>query.py (1.6574585%)<TH>test_mysql_1.py (0.65970314%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match263455-0.html#0',2,'match263455-1.html#0',3)" NAME="0">(324-325)<TD><A HREF="javascript:ZweiFrames('match263455-0.html#0',2,'match263455-1.html#0',3)" NAME="0">(1394-1400)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#
# Copyright 2015 SUSE LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import logging
import os
import time

import salt.utils.files
import salt.utils.fsutils
import salt.utils.network
from salt.modules.inspectlib import EnvLoader
from salt.modules.inspectlib.entities import Package, PackageCfgFile, PayloadFile
from salt.modules.inspectlib.exceptions import InspectorQueryException, SIException

log = logging.getLogger(__name__)


class SysInfo:
    &quot;&quot;&quot;
    System information.
    &quot;&quot;&quot;

    def __init__(self, systype):
        if systype.lower() == &quot;solaris&quot;:
            raise SIException(&quot;Platform {} not (yet) supported.&quot;.format(systype))

    def _grain(self, grain):
        &quot;&quot;&quot;
        An alias for grains getter.
        &quot;&quot;&quot;
        return __grains__.get(grain, &quot;N/A&quot;)

    def _get_disk_size(self, device):
        &quot;&quot;&quot;
        Get a size of a disk.
        &quot;&quot;&quot;
        out = __salt__[&quot;cmd.run_all&quot;](&quot;df {}&quot;.format(device))
        if out[&quot;retcode&quot;]:
            msg = &quot;Disk size info error: {}&quot;.format(out[&quot;stderr&quot;])
            log.error(msg)
            raise SIException(msg)

        devpath, blocks, used, available, used_p, mountpoint = (
            elm for elm in out[&quot;stdout&quot;].split(os.linesep)[-1].split(&quot; &quot;) if elm
        )
        return {
            &quot;device&quot;: devpath,
            &quot;blocks&quot;: blocks,
            &quot;used&quot;: used,
            &quot;available&quot;: available,
            &quot;used (%)&quot;: used_p,
            &quot;mounted&quot;: mountpoint,
        }

    def _get_fs(self):
        &quot;&quot;&quot;
        Get available file systems and their types.
        &quot;&quot;&quot;

        data = dict()
        for dev, dev_data in salt.utils.fsutils._blkid().items():
            dev = self._get_disk_size(dev)
            device = dev.pop(&quot;device&quot;)
            dev[&quot;type&quot;] = dev_data[&quot;type&quot;]
            data[device] = dev

        return data

    def _get_mounts(self):
        &quot;&quot;&quot;
        Get mounted FS on the system.
        &quot;&quot;&quot;
        return salt.utils.fsutils._get_mounts()

    def _get_cpu(self):
        &quot;&quot;&quot;
        Get available CPU information.
        &quot;&quot;&quot;
        # CPU data in grains is OK-ish, but lscpu is still better in this case
        out = __salt__[&quot;cmd.run_all&quot;](&quot;lscpu&quot;)
        salt.utils.fsutils._verify_run(out)
        data = dict()
        for descr, value in [
            elm.split(&quot;:&quot;, 1) for elm in out[&quot;stdout&quot;].split(os.linesep)
        ]:
            data[descr.strip()] = value.strip()

        return data

    def _get_mem(self):
        &quot;&quot;&quot;
        Get memory.
        &quot;&quot;&quot;
        out = __salt__[&quot;cmd.run_all&quot;](&quot;vmstat -s&quot;)
        if out[&quot;retcode&quot;]:
            raise SIException(&quot;Memory info error: {}&quot;.format(out[&quot;stderr&quot;]))

        ret = dict()
        for line in out[&quot;stdout&quot;].split(os.linesep):
            line = line.strip()
            if not line:
                continue
            size, descr = line.split(&quot; &quot;, 1)
            if descr.startswith(&quot;K &quot;):
                descr = descr[2:]
                size = size + &quot;K&quot;
            ret[descr] = size
        return ret

    def _get_network(self):
        &quot;&quot;&quot;
        Get network configuration.
        &quot;&quot;&quot;
        data = dict()
        data[&quot;interfaces&quot;] = salt.utils.network.interfaces()
        data[&quot;subnets&quot;] = salt.utils.network.subnets()

        return data

    def _get_os(self):
        &quot;&quot;&quot;
        Get operating system summary
        &quot;&quot;&quot;
        return {
            &quot;name&quot;: self._grain(&quot;os&quot;),
            &quot;family&quot;: self._grain(&quot;os_family&quot;),
            &quot;arch&quot;: self._grain(&quot;osarch&quot;),
            &quot;release&quot;: self._grain(&quot;osrelease&quot;),
        }


class Query(EnvLoader):
    &quot;&quot;&quot;
    Query the system.
    This class is actually puts all Salt features together,
    so there would be no need to pick it from various places.
    &quot;&quot;&quot;

    # Configuration: config files
    # Identity: users/groups
    # Software: packages, patterns, repositories
    # Services
    # System: distro, RAM etc
    # Changes: all files that are managed and were changed from the original
    # all: include all scopes (scary!)
    # payload: files that are not managed

    SCOPES = [
        &quot;changes&quot;,
        &quot;configuration&quot;,
        &quot;identity&quot;,
        &quot;system&quot;,
        &quot;software&quot;,
        &quot;services&quot;,
        &quot;payload&quot;,
        &quot;all&quot;,
    ]

    def __init__(self, scope, cachedir=None):
        &quot;&quot;&quot;
        Constructor.

        :param scope:
        :return:
        &quot;&quot;&quot;
        if scope and scope not in self.SCOPES:
            raise InspectorQueryException(
                &quot;Unknown scope: {}. Must be one of: {}&quot;.format(
                    repr(scope), &quot;, &quot;.join(self.SCOPES)
                )
            )
        elif not scope:
            raise InspectorQueryException(
                &quot;Scope cannot be empty. Must be one of: {}&quot;.format(
                    &quot;, &quot;.join(self.SCOPES)
                )
            )
        EnvLoader.__init__(self, cachedir=cachedir)
        self.scope = &quot;_&quot; + scope
        self.local_identity = dict()

    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Call the query with the defined scope.

        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;

        return getattr(self, self.scope)(*args, **kwargs)

    def _changes(self, *args, **kwargs):
        &quot;&quot;&quot;
        Returns all diffs to the configuration files.
        &quot;&quot;&quot;
        raise Exception(&quot;Not yet implemented&quot;)

    def _configuration(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return configuration files.
        &quot;&quot;&quot;

        data = dict()
        self.db.open()
        for pkg in self.db.get(Package):
            configs = list()
            for pkg_cfg in self.db.get(PackageCfgFile, eq={&quot;pkgid&quot;: pkg.id}):
                configs.append(pkg_cfg.path)
            data[pkg.name] = configs

        if not data:
            raise InspectorQueryException(&quot;No inspected configuration yet available.&quot;)

        return data

    def _get_local_users(self, disabled=None):
        &quot;&quot;&quot;
        Return all known local accounts to the system.
        &quot;&quot;&quot;
        users = dict()
        path = &quot;/etc/passwd&quot;
        with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
            for line in fp_:
                line = line.strip()
                if &quot;:&quot; not in line:
                    continue
                name, password, uid, gid, gecos, directory, shell = line.split(&quot;:&quot;)
                active = not (password == &quot;*&quot; or password.startswith(&quot;!&quot;))
                if (
                    (disabled is False and active)
                    or (disabled is True and not active)
                    or disabled is None
                ):
                    users[name] = {
                        &quot;uid&quot;: uid,
                        &quot;git&quot;: gid,
                        &quot;info&quot;: gecos,
                        &quot;home&quot;: directory,
                        &quot;shell&quot;: shell,
                        &quot;disabled&quot;: not active,
                    }

        return users

    def _get_local_groups(self):
        &quot;&quot;&quot;
        Return all known local groups to the system.
        &quot;&quot;&quot;
        groups = dict()
        path = &quot;/etc/group&quot;
        with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
            for line in fp_:
                line = line.strip()
                if &quot;:&quot; not in line:
                    continue
                name, password, gid, users = line.split(&quot;:&quot;)
                groups[name] = {
                    &quot;gid&quot;: gid,
                }

                if users:
                    groups[name][&quot;users&quot;] = users.split(&quot;,&quot;)

        return groups

    def _get_external_accounts(self, locals):
        &quot;&quot;&quot;
        Return all known accounts, excluding local accounts.
        &quot;&quot;&quot;
        users = dict()
        out = __salt__[&quot;cmd.run_all&quot;](&quot;passwd -S -a&quot;)
        if out[&quot;retcode&quot;]:
            # System does not supports all accounts descriptions, just skipping.
            return users
        status = {
            &quot;L&quot;: &quot;Locked&quot;,
            &quot;NP&quot;: &quot;No password&quot;,
            &quot;P&quot;: &quot;Usable password&quot;,
            &quot;LK&quot;: &quot;Locked&quot;,
        }
        for data in [
            elm.strip().split(&quot; &quot;)
            for elm in out[&quot;stdout&quot;].split(os.linesep)
            if elm.strip()
        ]:
            if len(data) &lt; 2:
                continue
            name, login = data[:2]
            if name not in locals:
                users[name] = {&quot;login&quot;: login, &quot;status&quot;: status.get(login, &quot;N/A&quot;)}

        return users

    def _identity(self, *args, **kwargs):
        &quot;&quot;&quot;
        Local users and groups.

        accounts
            Can be either 'local', 'remote' or 'all' (equal to &quot;local,remote&quot;).
            Remote accounts cannot be resolved on all systems, but only
            those, which supports 'passwd -S -a'.

        disabled
            True (or False, default) to return only disabled accounts.
        &quot;&quot;&quot;
        LOCAL = &quot;local accounts&quot;
<A NAME="0"></A>        EXT = &quot;external accounts&quot;

        data = dict()
        data[LOCAL] = self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match263455-1.html#0',3,'match263455-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>._get_local_users(disabled=kwargs.get(&quot;disabled&quot;))
        data[EXT] = self._get_external_accounts(data[LOCAL].keys(</B></FONT>)) or &quot;N/A&quot;
        data[&quot;local groups&quot;] = self._get_local_groups()

        return data

    def _system(self, *args, **kwargs):
        &quot;&quot;&quot;
        This basically calls grains items and picks out only
        necessary information in a certain structure.

        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;
        sysinfo = SysInfo(__grains__.get(&quot;kernel&quot;))

        data = dict()
        data[&quot;cpu&quot;] = sysinfo._get_cpu()
        data[&quot;disks&quot;] = sysinfo._get_fs()
        data[&quot;mounts&quot;] = sysinfo._get_mounts()
        data[&quot;memory&quot;] = sysinfo._get_mem()
        data[&quot;network&quot;] = sysinfo._get_network()
        data[&quot;os&quot;] = sysinfo._get_os()

        return data

    def _software(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return installed software.
        &quot;&quot;&quot;
        data = dict()
        if &quot;exclude&quot; in kwargs:
            excludes = kwargs[&quot;exclude&quot;].split(&quot;,&quot;)
        else:
            excludes = list()

        os_family = __grains__.get(&quot;os_family&quot;).lower()

        # Get locks
        if os_family == &quot;suse&quot;:
            LOCKS = &quot;pkg.list_locks&quot;
            if &quot;products&quot; not in excludes:
                products = __salt__[&quot;pkg.list_products&quot;]()
                if products:
                    data[&quot;products&quot;] = products
        elif os_family == &quot;redhat&quot;:
            LOCKS = &quot;pkg.get_locked_packages&quot;
        else:
            LOCKS = None

        if LOCKS and &quot;locks&quot; not in excludes:
            locks = __salt__[LOCKS]()
            if locks:
                data[&quot;locks&quot;] = locks

        # Get patterns
        if os_family == &quot;suse&quot;:
            PATTERNS = &quot;pkg.list_installed_patterns&quot;
        elif os_family == &quot;redhat&quot;:
            PATTERNS = &quot;pkg.group_list&quot;
        else:
            PATTERNS = None

        if PATTERNS and &quot;patterns&quot; not in excludes:
            patterns = __salt__[PATTERNS]()
            if patterns:
                data[&quot;patterns&quot;] = patterns

        # Get packages
        if &quot;packages&quot; not in excludes:
            data[&quot;packages&quot;] = __salt__[&quot;pkg.list_pkgs&quot;]()

        # Get repositories
        if &quot;repositories&quot; not in excludes:
            repos = __salt__[&quot;pkg.list_repos&quot;]()
            if repos:
                data[&quot;repositories&quot;] = repos

        return data

    def _services(self, *args, **kwargs):
        &quot;&quot;&quot;
        Get list of enabled and disabled services on the particular system.
        &quot;&quot;&quot;
        return {
            &quot;enabled&quot;: __salt__[&quot;service.get_enabled&quot;](),
            &quot;disabled&quot;: __salt__[&quot;service.get_disabled&quot;](),
        }

    def _id_resolv(self, iid, named=True, uid=True):
        &quot;&quot;&quot;
        Resolve local users and groups.

        :param iid:
        :param named:
        :param uid:
        :return:
        &quot;&quot;&quot;

        if not self.local_identity:
            self.local_identity[&quot;users&quot;] = self._get_local_users()
            self.local_identity[&quot;groups&quot;] = self._get_local_groups()

        if not named:
            return iid

        for name, meta in self.local_identity[uid and &quot;users&quot; or &quot;groups&quot;].items():
            if (uid and int(meta.get(&quot;uid&quot;, -1)) == iid) or (
                not uid and int(meta.get(&quot;gid&quot;, -1)) == iid
            ):
                return name

        return iid

    def _payload(self, *args, **kwargs):
        &quot;&quot;&quot;
        Find all unmanaged files. Returns maximum 1000 values.

        Parameters:

        * **filter**: Include only results which path starts from the filter string.
        * **time**: Display time in Unix ticks or format according to the configured TZ (default)
                    Values: ticks, tz (default)
        * **size**: Format size. Values: B, KB, MB, GB
        * **owners**: Resolve UID/GID to an actual names or leave them numeric (default).
                      Values: name (default), id
        * **type**: Comma-separated type of included payload: dir (or directory), link and/or file.
        * **brief**: Return just a list of matches, if True. Default: False
        * **offset**: Offset of the files
        * **max**: Maximum returned values. Default 1000.

        Options:

        * **total**: Return a total amount of found payload files
        &quot;&quot;&quot;

        def _size_format(size, fmt):
            if fmt is None:
                return size

            fmt = fmt.lower()
            if fmt == &quot;b&quot;:
                return &quot;{} Bytes&quot;.format(size)
            elif fmt == &quot;kb&quot;:
                return &quot;{} Kb&quot;.format(round((float(size) / 0x400), 2))
            elif fmt == &quot;mb&quot;:
                return &quot;{} Mb&quot;.format(round((float(size) / 0x400 / 0x400), 2))
            elif fmt == &quot;gb&quot;:
                return &quot;{} Gb&quot;.format(round((float(size) / 0x400 / 0x400 / 0x400), 2))

        filter = kwargs.get(&quot;filter&quot;)
        offset = kwargs.get(&quot;offset&quot;, 0)

        timeformat = kwargs.get(&quot;time&quot;, &quot;tz&quot;)
        if timeformat not in [&quot;ticks&quot;, &quot;tz&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;time&quot;'.format(timeformat)
            )
        tfmt = (
            lambda param: timeformat == &quot;tz&quot;
            and time.strftime(&quot;%b %d %Y %H:%M:%S&quot;, time.gmtime(param))
            or int(param)
        )

        size_fmt = kwargs.get(&quot;size&quot;)
        if size_fmt is not None and size_fmt.lower() not in [&quot;b&quot;, &quot;kb&quot;, &quot;mb&quot;, &quot;gb&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;size&quot;. '
                &quot;Should be either B, Kb, Mb or Gb&quot;.format(timeformat)
            )

        owners = kwargs.get(&quot;owners&quot;, &quot;id&quot;)
        if owners not in [&quot;name&quot;, &quot;id&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;owners&quot;. '
                &quot;Should be either name or id (default)&quot;.format(owners)
            )

        incl_type = [prm for prm in kwargs.get(&quot;type&quot;, &quot;&quot;).lower().split(&quot;,&quot;) if prm]
        if not incl_type:
            incl_type.append(&quot;file&quot;)

        for i_type in incl_type:
            if i_type not in [&quot;directory&quot;, &quot;dir&quot;, &quot;d&quot;, &quot;file&quot;, &quot;f&quot;, &quot;link&quot;, &quot;l&quot;]:
                raise InspectorQueryException(
                    'Unknown &quot;{}&quot; values for parameter &quot;type&quot;. '
                    &quot;Should be comma separated one or more of &quot;
                    &quot;dir, file and/or link.&quot;.format(&quot;, &quot;.join(incl_type))
                )
        self.db.open()

        if &quot;total&quot; in args:
            return {&quot;total&quot;: len(self.db.get(PayloadFile))}

        brief = kwargs.get(&quot;brief&quot;)
        pld_files = list() if brief else dict()
        for pld_data in self.db.get(PayloadFile)[
            offset : offset + kwargs.get(&quot;max&quot;, 1000)
        ]:
            if brief:
                pld_files.append(pld_data.path)
            else:
                pld_files[pld_data.path] = {
                    &quot;uid&quot;: self._id_resolv(pld_data.uid, named=(owners == &quot;id&quot;)),
                    &quot;gid&quot;: self._id_resolv(
                        pld_data.gid, named=(owners == &quot;id&quot;), uid=False
                    ),
                    &quot;size&quot;: _size_format(pld_data.p_size, fmt=size_fmt),
                    &quot;mode&quot;: oct(pld_data.mode),
                    &quot;accessed&quot;: tfmt(pld_data.atime),
                    &quot;modified&quot;: tfmt(pld_data.mtime),
                    &quot;created&quot;: tfmt(pld_data.ctime),
                }

        return pld_files

    def _all(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return all the summary of the particular system.
        &quot;&quot;&quot;
        data = dict()
        data[&quot;software&quot;] = self._software(**kwargs)
        data[&quot;system&quot;] = self._system(**kwargs)
        data[&quot;services&quot;] = self._services(**kwargs)
        try:
            data[&quot;configuration&quot;] = self._configuration(**kwargs)
        except InspectorQueryException as ex:
            data[&quot;configuration&quot;] = &quot;N/A&quot;
            log.error(ex)
        data[&quot;payload&quot;] = self._payload(**kwargs) or &quot;N/A&quot;

        return data
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mysql_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging

import pytest
import salt.utils.path
from salt.modules import mysql as mysqlmod
from tests.support.case import ModuleCase
from tests.support.mixins import SaltReturnAssertsMixin
from tests.support.unit import skipIf

log = logging.getLogger(__name__)

NO_MYSQL = False
try:
    import MySQLdb  # pylint: disable=import-error,unused-import
except Exception:  # pylint: disable=broad-except
    NO_MYSQL = True

if not salt.utils.path.which(&quot;mysqladmin&quot;):
    NO_MYSQL = True


@skipIf(
    NO_MYSQL,
    &quot;Please install MySQL bindings and a MySQL Server before running&quot;
    &quot;MySQL integration tests.&quot;,
)
@pytest.mark.windows_whitelisted
class MysqlModuleDbTest(ModuleCase, SaltReturnAssertsMixin):
    &quot;&quot;&quot;
    Module testing database creation on a real MySQL Server.
    &quot;&quot;&quot;

    user = &quot;root&quot;
    password = &quot;poney&quot;

    @pytest.mark.destructive_test
    def setUp(self):
        &quot;&quot;&quot;
        Test presence of MySQL server, enforce a root password
        &quot;&quot;&quot;
        super().setUp()
        NO_MYSQL_SERVER = True
        # now ensure we know the mysql root password
        # one of theses two at least should work
        ret1 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        ret2 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' --password=&quot;'
            + self.password
            + '&quot; flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        key, value = ret2.popitem()
        if value[&quot;result&quot;]:
            NO_MYSQL_SERVER = False
        else:
            self.skipTest(&quot;No MySQL Server running, or no root access on it.&quot;)

    def _db_creation_loop(self, db_name, returning_name, test_conn=False, **kwargs):
        &quot;&quot;&quot;
        Used in db testCase, create, check exists, check in list and removes.
        &quot;&quot;&quot;
        ret = self.run_function(&quot;mysql.db_create&quot;, name=db_name, **kwargs)
        self.assertEqual(
            True, ret, &quot;Problem while creating db for db name: '{}'&quot;.format(db_name)
        )
        # test db exists
        ret = self.run_function(&quot;mysql.db_exists&quot;, name=db_name, **kwargs)
        self.assertEqual(
            True,
            ret,
            &quot;Problem while testing db exists for db name: '{}'&quot;.format(db_name),
        )
        # List db names to ensure db is created with the right utf8 string
        ret = self.run_function(&quot;mysql.db_list&quot;, **kwargs)
        if not isinstance(ret, list):
            raise AssertionError(
                (
                    &quot;Unexpected query result while retrieving databases list&quot;
                    &quot; '{}' for '{}' test&quot;
                ).format(ret, db_name)
            )
        self.assertIn(
            returning_name,
            ret,
            (
                &quot;Problem while testing presence of db name in db lists&quot;
                &quot; for db name: '{}' in list '{}'&quot;
            ).format(db_name, ret),
        )

        if test_conn:
            # test connections on database with root user
            ret = self.run_function(
                &quot;mysql.query&quot;, database=db_name, query=&quot;SELECT 1&quot;, **kwargs
            )
            if not isinstance(ret, dict) or &quot;results&quot; not in ret:
                raise AssertionError(
                    &quot;Unexpected result while testing connection on database : {}&quot;.format(
                        repr(db_name)
                    )
                )
            self.assertEqual([[&quot;1&quot;]], ret[&quot;results&quot;])

        # Now remove database
        ret = self.run_function(&quot;mysql.db_remove&quot;, name=db_name, **kwargs)
        self.assertEqual(
            True, ret, &quot;Problem while removing db for db name: '{}'&quot;.format(db_name)
        )

    @pytest.mark.destructive_test
    def test_database_creation_level1(self):
        &quot;&quot;&quot;
        Create database, test presence, then drop db. All theses with complex names.
        &quot;&quot;&quot;
        # name with space
        db_name = &quot;foo 1&quot;
        self._db_creation_loop(
            db_name=db_name,
            returning_name=db_name,
            test_conn=True,
            connection_user=self.user,
            connection_pass=self.password,
        )

        # ```````
        # create
        # also with character_set and collate only
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=&quot;foo`2&quot;,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        # test db exists
        ret = self.run_function(
            &quot;mysql.db_exists&quot;,
            name=&quot;foo`2&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        # redoing the same should fail
        # even with other character sets or collations
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=&quot;foo`2&quot;,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(False, ret)
        # redoing the same should fail
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=&quot;foo`2&quot;,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(False, ret)
        # Now remove database
        ret = self.run_function(
            &quot;mysql.db_remove&quot;,
            name=&quot;foo`2&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)

        # '''''''
        # create
        # also with character_set only
        db_name = &quot;foo'3&quot;
        self._db_creation_loop(
            db_name=db_name,
            returning_name=db_name,
            test_conn=True,
            character_set=&quot;utf8&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )

        # &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
        # also with collate only
        db_name = 'foo&quot;4'
        self._db_creation_loop(
            db_name=db_name,
            returning_name=db_name,
            test_conn=True,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # fuzzy
        db_name = '&lt;foo` --&quot;5&gt;'
        self._db_creation_loop(
            db_name=db_name,
            returning_name=db_name,
            test_conn=True,
            connection_user=self.user,
            connection_pass=self.password,
        )

    @pytest.mark.destructive_test
    def test_mysql_dbname_character_percent(self):
        &quot;&quot;&quot;
        Play with the '%' character problems

        This character should be escaped in the form '%%' on queries, but only
        when theses queries have arguments. It is also a special character
        in LIKE SQL queries. Finally it is used to indicate query arguments.
        &quot;&quot;&quot;
        db_name1 = &quot;foo%1_&quot;
        db_name2 = &quot;foo%12&quot;
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=db_name1,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=db_name2,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        ret = self.run_function(
            &quot;mysql.db_remove&quot;,
            name=db_name1,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        ret = self.run_function(
            &quot;mysql.db_exists&quot;,
            name=db_name1,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(False, ret)
        ret = self.run_function(
            &quot;mysql.db_exists&quot;,
            name=db_name2,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        ret = self.run_function(
            &quot;mysql.db_remove&quot;,
            name=db_name2,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)

    @pytest.mark.destructive_test
    def test_database_creation_utf8(self):
        &quot;&quot;&quot;
        Test support of utf8 in database names
        &quot;&quot;&quot;
        # Simple accents : using utf8 string
        db_name_unicode = &quot;notam\xe9rican&quot;
        # same as 'notamérican' because of file encoding
        # but ensure it on this test
        db_name_utf8 = &quot;notam\xc3\xa9rican&quot;
        # FIXME: MySQLdb problems on conn strings containing
        # utf-8 on user name of db name prevent conn test
        self._db_creation_loop(
            db_name=db_name_utf8,
            returning_name=db_name_utf8,
            test_conn=False,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # test unicode entry will also return utf8 name
        self._db_creation_loop(
            db_name=db_name_unicode,
            returning_name=db_name_utf8,
            test_conn=False,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # Using more complex unicode characters:
        db_name_unicode = &quot;\u6a19\u6e96\u8a9e&quot;
        # same as '標準語' because of file encoding
        # but ensure it on this test
        db_name_utf8 = &quot;\xe6\xa8\x99\xe6\xba\x96\xe8\xaa\x9e&quot;
        self._db_creation_loop(
            db_name=db_name_utf8,
            returning_name=db_name_utf8,
            test_conn=False,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # test unicode entry will also return utf8 name
        self._db_creation_loop(
            db_name=db_name_unicode,
            returning_name=db_name_utf8,
            test_conn=False,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )

    @pytest.mark.destructive_test
    def test_database_maintenance(self):
        &quot;&quot;&quot;
        Test maintenance operations on a created database
        &quot;&quot;&quot;
        dbname = &quot;foo%'-- `\&quot;'&quot;
        # create database
        # but first silently try to remove it
        # in case of previous tests failures
        ret = self.run_function(
            &quot;mysql.db_remove&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )
        ret = self.run_function(
            &quot;mysql.db_create&quot;,
            name=dbname,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        # test db exists
        ret = self.run_function(
            &quot;mysql.db_exists&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)
        # Create 3 tables
        tablenames = {
            'A%table &quot;`1': &quot;MYISAM&quot;,
            &quot;B%table '`2&quot;: &quot;InnoDB&quot;,
            &quot;Ctable --`3&quot;: &quot;MEMORY&quot;,
        }
        for tablename, engine in sorted(tablenames.items()):
            # prepare queries
            create_query = (
                &quot;CREATE TABLE {tblname} (&quot;
                &quot; id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,&quot;
                &quot; data VARCHAR(100)) ENGINE={engine};&quot;.format(
                    tblname=mysqlmod.quote_identifier(tablename),
                    engine=engine,
                )
            )
            insert_query = &quot;INSERT INTO {tblname} (data) VALUES &quot;.format(
                tblname=mysqlmod.quote_identifier(tablename)
            )
            delete_query = &quot;DELETE from  {tblname} order by rand() limit 50;&quot;.format(
                tblname=mysqlmod.quote_identifier(tablename)
            )
            for x in range(100):
                insert_query += &quot;('foo&quot; + str(x) + &quot;'),&quot;
            insert_query += &quot;('bar');&quot;

            # populate database
            log.info(&quot;Adding table '%s'&quot;, tablename)
            ret = self.run_function(
                &quot;mysql.query&quot;,
                database=dbname,
                query=create_query,
                connection_user=self.user,
                connection_pass=self.password,
            )
            if not isinstance(ret, dict) or &quot;rows affected&quot; not in ret:
                raise AssertionError(
                    (
                        &quot;Unexpected query result while populating test table&quot;
                        &quot; '{}' : '{}'&quot;
                    ).format(
                        tablename,
                        ret,
                    )
                )
            self.assertEqual(ret[&quot;rows affected&quot;], 0)
            log.info(&quot;Populating table '%s'&quot;, tablename)
            ret = self.run_function(
                &quot;mysql.query&quot;,
                database=dbname,
                query=insert_query,
                connection_user=self.user,
                connection_pass=self.password,
            )
            if not isinstance(ret, dict) or &quot;rows affected&quot; not in ret:
                raise AssertionError(
                    (
                        &quot;Unexpected query result while populating test table&quot;
                        &quot; '{}' : '{}'&quot;
                    ).format(
                        tablename,
                        ret,
                    )
                )
            self.assertEqual(ret[&quot;rows affected&quot;], 101)
            log.info(&quot;Removing some rows on table'%s'&quot;, tablename)
            ret = self.run_function(
                &quot;mysql.query&quot;,
                database=dbname,
                query=delete_query,
                connection_user=self.user,
                connection_pass=self.password,
            )
            if not isinstance(ret, dict) or &quot;rows affected&quot; not in ret:
                raise AssertionError(
                    (
                        &quot;Unexpected query result while removing rows on test table&quot;
                        &quot; '{}' : '{}'&quot;
                    ).format(
                        tablename,
                        ret,
                    )
                )
            self.assertEqual(ret[&quot;rows affected&quot;], 50)
        # test check/repair/opimize on 1 table
        tablename = 'A%table &quot;`1'
        ret = self.run_function(
            &quot;mysql.db_check&quot;,
            name=dbname,
            table=tablename,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Note that returned result does not quote_identifier of table and db
        self.assertEqual(
            ret,
            [
                {
                    &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                    &quot;Msg_text&quot;: &quot;OK&quot;,
                    &quot;Msg_type&quot;: &quot;status&quot;,
                    &quot;Op&quot;: &quot;check&quot;,
                }
            ],
        )
        ret = self.run_function(
            &quot;mysql.db_repair&quot;,
            name=dbname,
            table=tablename,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Note that returned result does not quote_identifier of table and db
        self.assertEqual(
            ret,
            [
                {
                    &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                    &quot;Msg_text&quot;: &quot;OK&quot;,
                    &quot;Msg_type&quot;: &quot;status&quot;,
                    &quot;Op&quot;: &quot;repair&quot;,
                }
            ],
        )
        ret = self.run_function(
            &quot;mysql.db_optimize&quot;,
            name=dbname,
            table=tablename,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Note that returned result does not quote_identifier of table and db
        self.assertEqual(
            ret,
            [
                {
                    &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                    &quot;Msg_text&quot;: &quot;OK&quot;,
                    &quot;Msg_type&quot;: &quot;status&quot;,
                    &quot;Op&quot;: &quot;optimize&quot;,
                }
            ],
        )

        # test check/repair/opimize on all tables
        ret = self.run_function(
            &quot;mysql.db_check&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )
        expected = []
        for tablename, engine in sorted(tablenames.items()):
            if engine == &quot;MEMORY&quot;:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: (
                                &quot;The storage engine for the table doesn't support check&quot;
                            ),
                            &quot;Msg_type&quot;: &quot;note&quot;,
                            &quot;Op&quot;: &quot;check&quot;,
                        }
                    ]
                )
            else:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: &quot;OK&quot;,
                            &quot;Msg_type&quot;: &quot;status&quot;,
                            &quot;Op&quot;: &quot;check&quot;,
                        }
                    ]
                )
        self.assertEqual(ret, expected)

        ret = self.run_function(
            &quot;mysql.db_repair&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )
        expected = []
        for tablename, engine in sorted(tablenames.items()):
            if engine == &quot;MYISAM&quot;:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: &quot;OK&quot;,
                            &quot;Msg_type&quot;: &quot;status&quot;,
                            &quot;Op&quot;: &quot;repair&quot;,
                        }
                    ]
                )
            else:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: (
                                &quot;The storage engine for the table doesn't&quot;
                                &quot; support repair&quot;
                            ),
                            &quot;Msg_type&quot;: &quot;note&quot;,
                            &quot;Op&quot;: &quot;repair&quot;,
                        }
                    ]
                )
        self.assertEqual(ret, expected)

        ret = self.run_function(
            &quot;mysql.db_optimize&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )

        expected = []
        for tablename, engine in sorted(tablenames.items()):
            if engine == &quot;MYISAM&quot;:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: &quot;OK&quot;,
                            &quot;Msg_type&quot;: &quot;status&quot;,
                            &quot;Op&quot;: &quot;optimize&quot;,
                        }
                    ]
                )
            elif engine == &quot;InnoDB&quot;:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: (
                                &quot;Table does not support optimize, &quot;
                                &quot;doing recreate + analyze instead&quot;
                            ),
                            &quot;Msg_type&quot;: &quot;note&quot;,
                            &quot;Op&quot;: &quot;optimize&quot;,
                        },
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: &quot;OK&quot;,
                            &quot;Msg_type&quot;: &quot;status&quot;,
                            &quot;Op&quot;: &quot;optimize&quot;,
                        },
                    ]
                )
            elif engine == &quot;MEMORY&quot;:
                expected.append(
                    [
                        {
                            &quot;Table&quot;: dbname + &quot;.&quot; + tablename,
                            &quot;Msg_text&quot;: (
                                &quot;The storage engine for the table doesn't&quot;
                                &quot; support optimize&quot;
                            ),
                            &quot;Msg_type&quot;: &quot;note&quot;,
                            &quot;Op&quot;: &quot;optimize&quot;,
                        }
                    ]
                )
        self.assertEqual(ret, expected)
        # Teardown, remove database
        ret = self.run_function(
            &quot;mysql.db_remove&quot;,
            name=dbname,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(True, ret)


@skipIf(
    NO_MYSQL,
    &quot;Please install MySQL bindings and a MySQL Server before running&quot;
    &quot;MySQL integration tests.&quot;,
)
@pytest.mark.windows_whitelisted
class MysqlModuleUserTest(ModuleCase, SaltReturnAssertsMixin):
    &quot;&quot;&quot;
    User Creation and connection tests
    &quot;&quot;&quot;

    user = &quot;root&quot;
    password = &quot;poney&quot;

    @pytest.mark.destructive_test
    def setUp(self):
        &quot;&quot;&quot;
        Test presence of MySQL server, enforce a root password
        &quot;&quot;&quot;
        super().setUp()
        NO_MYSQL_SERVER = True
        # now ensure we know the mysql root password
        # one of theses two at least should work
        ret1 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        ret2 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' --password=&quot;'
            + self.password
            + '&quot; flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        key, value = ret2.popitem()
        if value[&quot;result&quot;]:
            NO_MYSQL_SERVER = False
        else:
            self.skipTest(&quot;No MySQL Server running, or no root access on it.&quot;)

    def _userCreationLoop(
        self,
        uname,
        host,
        password=None,
        new_password=None,
        new_password_hash=None,
        **kwargs
    ):
        &quot;&quot;&quot;
        Perform some tests around creation of the given user
        &quot;&quot;&quot;
        # First silently remove it, in case of
        ret = self.run_function(&quot;mysql.user_remove&quot;, user=uname, host=host, **kwargs)
        # creation
        ret = self.run_function(
            &quot;mysql.user_create&quot;, user=uname, host=host, password=password, **kwargs
        )
        self.assertEqual(
            True,
            ret,
            &quot;Calling user_create on user '{}' did not return True: {}&quot;.format(
                uname, repr(ret)
            ),
        )
        # double creation failure
        ret = self.run_function(
            &quot;mysql.user_create&quot;, user=uname, host=host, password=password, **kwargs
        )
        self.assertEqual(
            False,
            ret,
            (
                &quot;Calling user_create a second time on&quot;
                &quot; user '{}' did not return False: {}&quot;
            ).format(uname, repr(ret)),
        )
        # Alter password
        if new_password is not None or new_password_hash is not None:
            ret = self.run_function(
                &quot;mysql.user_chpass&quot;,
                user=uname,
                host=host,
                password=new_password,
                password_hash=new_password_hash,
                connection_user=self.user,
                connection_pass=self.password,
                connection_charset=&quot;utf8&quot;,
                saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
            )
            self.assertEqual(
                True,
                ret,
                &quot;Calling user_chpass on user '{}' did not return True: {}&quot;.format(
                    uname, repr(ret)
                ),
            )

    def _chck_userinfo(self, user, host, check_user, check_hash):
        &quot;&quot;&quot;
        Internal routine to check user_info returned results
        &quot;&quot;&quot;
        ret = self.run_function(
            &quot;mysql.user_info&quot;,
            user=user,
            host=host,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        if not isinstance(ret, dict):
            raise AssertionError(
                &quot;Unexpected result while retrieving user_info for '{}'&quot;.format(user)
            )
        self.assertEqual(ret[&quot;Host&quot;], host)
        self.assertEqual(ret[&quot;Password&quot;], check_hash)
        self.assertEqual(ret[&quot;User&quot;], check_user)

    def _chk_remove_user(self, user, host, **kwargs):
        &quot;&quot;&quot;
        Internal routine to check user_remove
        &quot;&quot;&quot;
        ret = self.run_function(&quot;mysql.user_remove&quot;, user=user, host=host, **kwargs)
        self.assertEqual(
            True,
            ret,
            &quot;Assertion failed  while removing user '{}' on host '{}': {}&quot;.format(
                user, host, repr(ret)
            ),
        )

    @pytest.mark.destructive_test
    def test_user_management(self):
        &quot;&quot;&quot;
        Test various users creation settings
        &quot;&quot;&quot;
        # Create users with rights on this database
        # and rights on other databases
        user1 = &quot;user '1&quot;
        user1_pwd = &quot;pwd`'\&quot;1b&quot;
        user1_pwd_hash = &quot;*4DF33B3B12E43384677050A818327877FAB2F4BA&quot;
        # this is : user &quot;2'標
        user2 = &quot;user \&quot;2'\xe6\xa8\x99&quot;
        user2_pwd = &quot;user \&quot;2'\xe6\xa8\x99b&quot;
        user2_pwd_hash = &quot;*3A38A7B94B024B983687BB9B44FB60B7AA38FE61&quot;
        user3 = 'user &quot;3;,?:@=&amp;/'
        user3_pwd = 'user &quot;3;,?:@=&amp;/'
        user3_pwd_hash = &quot;*AA3B1D4105A45D381C23A5C221C47EA349E1FD7D&quot;
        # this is : user &quot;:=;4標 in unicode instead of utf-8
        # if unicode char is counted as 1 char we hit the max user
        # size (16)
        user4 = 'user&quot;:;,?:@=&amp;/4\u6a19'
        user4_utf8 = 'user&quot;:;,?:@=&amp;/4\xe6\xa8\x99'
        user4_pwd = 'user &quot;4;,?:@=&amp;/'
        user4_pwd_hash = &quot;*FC8EF8DBF27628E4E113359F8E7478D5CF3DD57C&quot;
        user5 = 'user ``&quot;5'
        user5_utf8 = 'user ``&quot;5'
        # this is 標標標\
        user5_pwd = &quot;\xe6\xa8\x99\xe6\xa8\x99\\&quot;
        # this is password('標標\\')
        user5_pwd_hash = &quot;*3752E65CDD8751AF8D889C62CFFC6C998B12C376&quot;
        user6 = 'user %--&quot;6'
        user6_utf8 = 'user %--&quot;6'
        # this is : --'&quot;% SIX標b
        user6_pwd_u = &quot; --'\&quot;% SIX\u6a19b&quot;
        user6_pwd_utf8 = &quot; --'\&quot;% SIX\xe6\xa8\x99b&quot;
        # this is password(' --\'&quot;% SIX標b')
        user6_pwd_hash = &quot;*90AE800593E2D407CD9E28CCAFBE42D17EEA5369&quot;
        self._userCreationLoop(
            uname=user1,
            host=&quot;localhost&quot;,
            password=&quot;pwd`'\&quot;1&quot;,
            new_password=&quot;pwd`'\&quot;1b&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Now check for results
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user1,
            host=&quot;localhost&quot;,
            password=user1_pwd,
            password_hash=None,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' existence failed&quot;.format(
                user1, &quot;localhost&quot;
            ),
        )

        self._userCreationLoop(
            uname=user2,
            host=&quot;localhost&quot;,
            password=None,
            # this is his name hash : user &quot;2'標
            password_hash=&quot;*EEF6F854748ACF841226BB1C2422BEC70AE7F1FF&quot;,
            # and this is the same with a 'b' added
            new_password_hash=user2_pwd_hash,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # user2 can connect from other places with other password
        self._userCreationLoop(
            uname=user2,
            host=&quot;10.0.0.1&quot;,
            allow_passwordless=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self._userCreationLoop(
            uname=user2,
            host=&quot;10.0.0.2&quot;,
            allow_passwordless=True,
            unix_socket=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # Now check for results
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user2,
            host=&quot;localhost&quot;,
            password=None,
            password_hash=user2_pwd_hash,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' failed&quot;.format(user2, &quot;localhost&quot;),
        )
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user2,
            host=&quot;10.0.0.1&quot;,
            allow_passwordless=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' without password failed&quot;.format(
                user2, &quot;10.0.0.1&quot;
            ),
        )
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user2,
            host=&quot;10.0.0.2&quot;,
            allow_passwordless=True,
            unix_socket=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' without password failed&quot;.format(
                user2, &quot;10.0.0.2&quot;
            ),
        )

        # Empty password is not passwordless (or is it a bug?)
        self._userCreationLoop(
            uname=user3,
            host=&quot;localhost&quot;,
            password=&quot;&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # user 3 on another host with a password
        self._userCreationLoop(
            uname=user3,
            host=&quot;%&quot;,
            password=&quot;foo&quot;,
            new_password=user3_pwd,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Now check for results
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user3,
            host=&quot;localhost&quot;,
            password=&quot;&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' without empty password failed&quot;.format(
                user3, &quot;localhost&quot;
            ),
        )
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user3,
            host=&quot;%&quot;,
            password=user3_pwd,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' with password failed&quot;.format(
                user3, &quot;%&quot;
            ),
        )

        # check unicode name, and password &gt; password_hash
        self._userCreationLoop(
            uname=user4,
            host=&quot;%&quot;,
            password=user4_pwd,
            # this is password('foo')
            password_hash=&quot;*F3A2A51A9B0F2BE2468926B4132313728C250DBF&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # Now check for results
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user4_utf8,
            host=&quot;%&quot;,
            password=user4_pwd,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            (
                &quot;Testing final user '{}' on host '{}'&quot;
                &quot; with password take from password and not password_hash&quot;
                &quot; failed&quot;
            ).format(user4_utf8, &quot;%&quot;),
        )
        self._userCreationLoop(
            uname=user5,
            host=&quot;localhost&quot;,
            password=&quot;\xe6\xa8\x99\xe6\xa8\x99&quot;,
            new_password=user5_pwd,
            unix_socket=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user5_utf8,
            host=&quot;localhost&quot;,
            password=user5_pwd,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' with utf8 password failed&quot;.format(
                user5_utf8, &quot;localhost&quot;
            ),
        )
        # for this one we give password in unicode and check it in utf-8
        self._userCreationLoop(
            uname=user6,
            host=&quot;10.0.0.1&quot;,
            password=&quot; foobar&quot;,
            new_password=user6_pwd_u,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        # Now check for results
        ret = self.run_function(
            &quot;mysql.user_exists&quot;,
            user=user6_utf8,
            host=&quot;10.0.0.1&quot;,
            password=user6_pwd_utf8,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertEqual(
            True,
            ret,
            &quot;Testing final user '{}' on host '{}' with unicode password failed&quot;.format(
                user6_utf8, &quot;10.0.0.1&quot;
            ),
        )
        # Final result should be:
        # mysql&gt; select Host, User, Password from user where user like 'user%';
        # +--------------------+-----------+-------------------------------+
        # | User               | Host      | Password                      |
        # +--------------------+-----------+-------------------------------+
        # | user &quot;2'標         | 10.0.0.1  |                               |
        # | user &quot;2'標         | 10.0.0.2  |                               |
        # | user &quot;2'標         | localhost | *3A38A7B94B0(...)60B7AA38FE61 |
        # | user &quot;3;,?:@=&amp;/    | %         | *AA3B1D4105(...)47EA349E1FD7D |
        # | user &quot;3;,?:@=&amp;/    | localhost |                               |
        # | user %--&quot;6         | 10.0.0.1  | *90AE800593(...)E42D17EEA5369 |
        # | user '1            | localhost | *4DF33B3B1(...)327877FAB2F4BA |
        # | user ``&quot;5          | localhost | *3752E65CD(...)FC6C998B12C376 |
        # | user&quot;:;,?:@=&amp;/4標  | %         | *FC8EF8DBF(...)7478D5CF3DD57C |
        # +--------------------+-----------+-------------------------------+
        self._chck_userinfo(
            user=user2, host=&quot;10.0.0.1&quot;, check_user=user2, check_hash=&quot;&quot;
        )
        self._chck_userinfo(
            user=user2, host=&quot;10.0.0.2&quot;, check_user=user2, check_hash=&quot;&quot;
        )
        self._chck_userinfo(
            user=user2, host=&quot;localhost&quot;, check_user=user2, check_hash=user2_pwd_hash
        )
        self._chck_userinfo(
            user=user3, host=&quot;%&quot;, check_user=user3, check_hash=user3_pwd_hash
        )
        self._chck_userinfo(
            user=user3, host=&quot;localhost&quot;, check_user=user3, check_hash=&quot;&quot;
        )
        self._chck_userinfo(
            user=user4, host=&quot;%&quot;, check_user=user4_utf8, check_hash=user4_pwd_hash
        )
        self._chck_userinfo(
            user=user6,
            host=&quot;10.0.0.1&quot;,
            check_user=user6_utf8,
            check_hash=user6_pwd_hash,
        )
        self._chck_userinfo(
            user=user1, host=&quot;localhost&quot;, check_user=user1, check_hash=user1_pwd_hash
        )
        self._chck_userinfo(
            user=user5,
            host=&quot;localhost&quot;,
            check_user=user5_utf8,
            check_hash=user5_pwd_hash,
        )
        # check user_list function
        ret = self.run_function(
            &quot;mysql.user_list&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user1}, ret)
        self.assertIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user2}, ret)
        self.assertIn({&quot;Host&quot;: &quot;10.0.0.1&quot;, &quot;User&quot;: user2}, ret)
        self.assertIn({&quot;Host&quot;: &quot;10.0.0.2&quot;, &quot;User&quot;: user2}, ret)
        self.assertIn({&quot;Host&quot;: &quot;%&quot;, &quot;User&quot;: user3}, ret)
        self.assertIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user3}, ret)
        self.assertIn({&quot;Host&quot;: &quot;%&quot;, &quot;User&quot;: user4_utf8}, ret)
        self.assertIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user5_utf8}, ret)
        self.assertIn({&quot;Host&quot;: &quot;10.0.0.1&quot;, &quot;User&quot;: user6_utf8}, ret)

        # And finally, test connections on MySQL with theses users
        ret = self.run_function(
            &quot;mysql.query&quot;,
            database=&quot;information_schema&quot;,
            query=&quot;SELECT 1&quot;,
            connection_user=user1,
            connection_pass=&quot;pwd`'\&quot;1b&quot;,
            connection_host=&quot;localhost&quot;,
        )
        if not isinstance(ret, dict) or &quot;results&quot; not in ret:
            raise AssertionError(
                &quot;Unexpected result while testing connection with user '{}': {}&quot;.format(
                    user1, repr(ret)
                )
            )
        self.assertEqual([[&quot;1&quot;]], ret[&quot;results&quot;])

        # FIXME: still failing, but works by hand...
        # mysql --user=&quot;user \&quot;2'標&quot; --password=&quot;user \&quot;2'標b&quot; information_schema
        # Seems to be a python-mysql library problem with user names containing
        # utf8 characters
        # @see https://github.com/farcepest/MySQLdb1/issues/40
        # import urllib
        # ret = self.run_function(
        #    'mysql.query',
        #    database='information_schema',
        #    query='SELECT 1',
        #    connection_user=urllib.quote_plus(user2),
        #    connection_pass=urllib.quote_plus(user2_pwd),
        #    connection_host='localhost',
        #    connection_charset='utf8',
        #    saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;}
        # )
        # if not isinstance(ret, dict) or 'results' not in ret:
        #    raise AssertionError(
        #        ('Unexpected result while testing connection'
        #        ' with user \'{0}\': {1}').format(
        #            user2,
        #            repr(ret)
        #        )
        #    )
        # self.assertEqual([['1']], ret['results'])
        ret = self.run_function(
            &quot;mysql.query&quot;,
            database=&quot;information_schema&quot;,
            query=&quot;SELECT 1&quot;,
            connection_user=user3,
            connection_pass=&quot;&quot;,
            connection_host=&quot;localhost&quot;,
        )
        if not isinstance(ret, dict) or &quot;results&quot; not in ret:
            raise AssertionError(
                &quot;Unexpected result while testing connection with user '{}': {}&quot;.format(
                    user3, repr(ret)
                )
            )
        self.assertEqual([[&quot;1&quot;]], ret[&quot;results&quot;])
        # FIXME: Failing
        # ret = self.run_function(
        #    'mysql.query',
        #    database='information_schema',
        #    query='SELECT 1',
        #    connection_user=user4_utf8,
        #    connection_pass=user4_pwd,
        #    connection_host='localhost',
        #    connection_charset='utf8',
        #    saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;}
        # )
        # if not isinstance(ret, dict) or 'results' not in ret:
        #    raise AssertionError(
        #        ('Unexpected result while testing connection'
        #        ' with user \'{0}\': {1}').format(
        #            user4_utf8,
        #            repr(ret)
        #        )
        #    )
        # self.assertEqual([['1']], ret['results'])
        ret = self.run_function(
            &quot;mysql.query&quot;,
            database=&quot;information_schema&quot;,
            query=&quot;SELECT 1&quot;,
            connection_user=user5_utf8,
            connection_pass=user5_pwd,
            connection_host=&quot;localhost&quot;,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        if not isinstance(ret, dict) or &quot;results&quot; not in ret:
            raise AssertionError(
                &quot;Unexpected result while testing connection with user '{}': {}&quot;.format(
                    user5_utf8, repr(ret)
                )
            )
        self.assertEqual([[&quot;1&quot;]], ret[&quot;results&quot;])

        # Teardown by deleting with user_remove
        self._chk_remove_user(
            user=user2,
            host=&quot;10.0.0.1&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self._chk_remove_user(
            user=user2,
            host=&quot;10.0.0.2&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self._chk_remove_user(
            user=user2,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self._chk_remove_user(
            user=user3,
            host=&quot;%&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._chk_remove_user(
            user=user3,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._chk_remove_user(
            user=user4,
            host=&quot;%&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self._chk_remove_user(
            user=user6,
            host=&quot;10.0.0.1&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._chk_remove_user(
            user=user1,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._chk_remove_user(
            user=user5,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Final verification of the cleanup
        ret = self.run_function(
            &quot;mysql.user_list&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )
        self.assertNotIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user1}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user2}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;10.0.0.1&quot;, &quot;User&quot;: user2}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;10.0.0.2&quot;, &quot;User&quot;: user2}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;%&quot;, &quot;User&quot;: user3}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user3}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;%&quot;, &quot;User&quot;: user4_utf8}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;localhost&quot;, &quot;User&quot;: user5_utf8}, ret)
        self.assertNotIn({&quot;Host&quot;: &quot;10.0.0.1&quot;, &quot;User&quot;: user6_utf8}, ret)


@skipIf(
    NO_MYSQL,
    &quot;Please install MySQL bindings and a MySQL Server before running&quot;
    &quot;MySQL integration tests.&quot;,
)
@pytest.mark.windows_whitelisted
class MysqlModuleUserGrantTest(ModuleCase, SaltReturnAssertsMixin):
    &quot;&quot;&quot;
    User Creation and connection tests
    &quot;&quot;&quot;

    user = &quot;root&quot;
    password = &quot;poney&quot;
    # yep, theses are valid MySQL db names
    # very special chars are _ % and .
    testdb1 = &quot;tes.t'\&quot;saltdb&quot;
    testdb2 = &quot;t_st `(:=salt%b)&quot;
    testdb3 = &quot;test `(:=salteeb)&quot;
    test_file_query_db = &quot;test_query&quot;
    table1 = &quot;foo&quot;
    table2 = &quot;foo `'%_bar&quot;
    users = {
        &quot;user1&quot;: {&quot;name&quot;: &quot;foo&quot;, &quot;pwd&quot;: &quot;bar&quot;},
        &quot;user2&quot;: {&quot;name&quot;: 'user &quot;;--,?:&amp;/\\', &quot;pwd&quot;: '&quot;;--(),?:@=&amp;/\\'},
        # this is : passwd 標標
        &quot;user3&quot;: {&quot;name&quot;: &quot;user( @ )=foobar&quot;, &quot;pwd&quot;: &quot;\xe6\xa8\x99\xe6\xa8\x99&quot;},
        # this is : user/password containing 標標
        &quot;user4&quot;: {&quot;name&quot;: &quot;user \xe6\xa8\x99&quot;, &quot;pwd&quot;: &quot;\xe6\xa8\x99\xe6\xa8\x99&quot;},
    }

    @pytest.mark.destructive_test
    def setUp(self):
        &quot;&quot;&quot;
        Test presence of MySQL server, enforce a root password, create users
        &quot;&quot;&quot;
        super().setUp()
        NO_MYSQL_SERVER = True
        # now ensure we know the mysql root password
        # one of theses two at least should work
        ret1 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        ret2 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' --password=&quot;'
            + self.password
            + '&quot; flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        key, value = ret2.popitem()
        if value[&quot;result&quot;]:
            NO_MYSQL_SERVER = False
        else:
            self.skipTest(&quot;No MySQL Server running, or no root access on it.&quot;)
        # Create some users and a test db
        for user, userdef in self.users.items():
            self._userCreation(uname=userdef[&quot;name&quot;], password=userdef[&quot;pwd&quot;])
        self.run_function(
            &quot;mysql.db_create&quot;,
            name=self.testdb1,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.run_function(
            &quot;mysql.db_create&quot;,
            name=self.testdb2,
            connection_user=self.user,
            connection_pass=self.password,
        )
<A NAME="0"></A>        create_query = (
            &quot;CREATE TABLE {tblname} (&quot;
            &quot; id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,&quot;
            &quot; data VARCHAR(100)) ENGINE={engine};&quot;<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match263455-0.html#0',2,'match263455-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.format(
                tblname=mysqlmod.quote_identifier(self.table1),
                engine=&quot;MYISAM&quot;,
            )
        )
        log.info(&quot;Adding table '%s'&quot;, self.table1)
        self.run_function(</B></FONT>
            &quot;mysql.query&quot;,
            database=self.testdb2,
            query=create_query,
            connection_user=self.user,
            connection_pass=self.password,
        )
        create_query = (
            &quot;CREATE TABLE {tblname} (&quot;
            &quot; id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,&quot;
            &quot; data VARCHAR(100)) ENGINE={engine};&quot;.format(
                tblname=mysqlmod.quote_identifier(self.table2),
                engine=&quot;MYISAM&quot;,
            )
        )
        log.info(&quot;Adding table '%s'&quot;, self.table2)
        self.run_function(
            &quot;mysql.query&quot;,
            database=self.testdb2,
            query=create_query,
            connection_user=self.user,
            connection_pass=self.password,
        )

    @pytest.mark.destructive_test
    def tearDown(self):
        &quot;&quot;&quot;
        Removes created users and db
        &quot;&quot;&quot;
        for user, userdef in self.users.items():
            self._userRemoval(uname=userdef[&quot;name&quot;], password=userdef[&quot;pwd&quot;])
        self.run_function(
            &quot;mysql.db_remove&quot;,
            name=self.testdb1,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.run_function(
            &quot;mysql.db_remove&quot;,
            name=self.testdb2,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.run_function(
            &quot;mysql.db_remove&quot;,
            name=self.test_file_query_db,
            connection_user=self.user,
            connection_pass=self.password,
        )

    def _userCreation(self, uname, password=None):
        &quot;&quot;&quot;
        Create a test user
        &quot;&quot;&quot;
        self.run_function(
            &quot;mysql.user_create&quot;,
            user=uname,
            host=&quot;localhost&quot;,
            password=password,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )

    def _userRemoval(self, uname, password=None):
        &quot;&quot;&quot;
        Removes a test user
        &quot;&quot;&quot;
        self.run_function(
            &quot;mysql.user_remove&quot;,
            user=uname,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
            saltenv={&quot;LC_ALL&quot;: &quot;en_US.utf8&quot;},
        )

    def _addGrantRoutine(
        self, grant, user, db, grant_option=False, escape=True, **kwargs
    ):
        &quot;&quot;&quot;
        Perform some tests around creation of the given grants
        &quot;&quot;&quot;
        ret = self.run_function(
            &quot;mysql.grant_add&quot;,
            grant=grant,
            database=db,
            user=user,
            grant_option=grant_option,
            escape=escape,
            **kwargs
        )
        self.assertEqual(
            True,
            ret,
            (
                &quot;Calling grant_add on user '{}' and grants '{}' did not return True: {}&quot;
            ).format(user, grant, repr(ret)),
        )
        ret = self.run_function(
            &quot;mysql.grant_exists&quot;,
            grant=grant,
            database=db,
            user=user,
            grant_option=grant_option,
            escape=escape,
            **kwargs
        )
        self.assertEqual(
            True,
            ret,
            (
                &quot;Calling grant_exists on&quot;
                &quot; user '{}' and grants '{}' did not return True: {}&quot;
            ).format(user, grant, repr(ret)),
        )

    @pytest.mark.destructive_test
    def testGrants(self):
        &quot;&quot;&quot;
        Test user grant methods
        &quot;&quot;&quot;
        self._addGrantRoutine(
            grant=&quot;SELECT, INSERT,UPDATE, CREATE&quot;,
            user=self.users[&quot;user1&quot;][&quot;name&quot;],
            db=self.testdb1 + &quot;.*&quot;,
            grant_option=True,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._addGrantRoutine(
            grant=&quot;INSERT, SELECT&quot;,
            user=self.users[&quot;user1&quot;][&quot;name&quot;],
            db=self.testdb2 + &quot;.&quot; + self.table1,
            grant_option=True,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._addGrantRoutine(
            grant=&quot;  SELECT, UPDATE,DELETE, CREATE TEMPORARY TABLES&quot;,
            user=self.users[&quot;user2&quot;][&quot;name&quot;],
            db=self.testdb1 + &quot;.*&quot;,
            grant_option=True,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._addGrantRoutine(
            grant=&quot;select, ALTER,CREATE TEMPORARY TABLES, EXECUTE &quot;,
            user=self.users[&quot;user3&quot;][&quot;name&quot;],
            db=self.testdb1 + &quot;.*&quot;,
            grant_option=True,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self._addGrantRoutine(
            grant=&quot;SELECT, INSERT&quot;,
            user=self.users[&quot;user4&quot;][&quot;name&quot;],
            db=self.testdb2 + &quot;.&quot; + self.table2,
            grant_option=False,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
        )
        self._addGrantRoutine(
            grant=&quot;CREATE&quot;,
            user=self.users[&quot;user4&quot;][&quot;name&quot;],
            db=self.testdb2 + &quot;.*&quot;,
            grant_option=False,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
        )
        self._addGrantRoutine(
            grant=&quot;SELECT, INSERT&quot;,
            user=self.users[&quot;user4&quot;][&quot;name&quot;],
            db=self.testdb2 + &quot;.&quot; + self.table1,
            grant_option=False,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
        )
        # '' is valid for anonymous users
        self._addGrantRoutine(
            grant=&quot;DELETE&quot;,
            user=&quot;&quot;,
            db=self.testdb3 + &quot;.*&quot;,
            grant_option=False,
            escape=True,
            connection_user=self.user,
            connection_pass=self.password,
        )
        # Check result for users
        ret = self.run_function(
            &quot;mysql.user_grants&quot;,
            user=self.users[&quot;user1&quot;][&quot;name&quot;],
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            ret,
            [
                &quot;GRANT USAGE ON *.* TO 'foo'@'localhost'&quot;,
                &quot;GRANT SELECT, INSERT, UPDATE, CREATE ON &quot;
                &quot;`tes.t'\&quot;saltdb`.* TO 'foo'@'localhost' WITH GRANT OPTION&quot;,
                &quot;GRANT SELECT, INSERT ON `t_st ``(:=salt%b)`.`foo`&quot;
                &quot; TO 'foo'@'localhost' WITH GRANT OPTION&quot;,
            ],
        )

        ret = self.run_function(
            &quot;mysql.user_grants&quot;,
            user=self.users[&quot;user2&quot;][&quot;name&quot;],
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            ret,
            [
                &quot;GRANT USAGE ON *.* TO 'user \&quot;;--,?:&amp;/\\'@'localhost'&quot;,
                &quot;GRANT SELECT, UPDATE, DELETE, CREATE TEMPORARY TABLES ON `tes.t'&quot;
                &quot;\&quot;saltdb`.* TO 'user \&quot;;--,?:&amp;/\\'@'localhost'&quot;
                &quot; WITH GRANT OPTION&quot;,
            ],
        )

        ret = self.run_function(
            &quot;mysql.user_grants&quot;,
            user=self.users[&quot;user3&quot;][&quot;name&quot;],
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            ret,
            [
                &quot;GRANT USAGE ON *.* TO 'user( @ )=foobar'@'localhost'&quot;,
                &quot;GRANT SELECT, ALTER, CREATE TEMPORARY TABLES, EXECUTE ON &quot;
                &quot;`tes.t'\&quot;saltdb`.* TO 'user( @ )=foobar'@'localhost' &quot;
                &quot;WITH GRANT OPTION&quot;,
            ],
        )

        ret = self.run_function(
            &quot;mysql.user_grants&quot;,
            user=self.users[&quot;user4&quot;][&quot;name&quot;],
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
            connection_charset=&quot;utf8&quot;,
        )
        self.assertEqual(
            ret,
            [
                &quot;GRANT USAGE ON *.* TO 'user \xe6\xa8\x99'@'localhost'&quot;,
                (
                    r&quot;GRANT CREATE ON `t\_st ``(:=salt\%b)`.* TO &quot;
                    &quot;'user \xe6\xa8\x99'@'localhost'&quot;
                ),
                &quot;GRANT SELECT, INSERT ON `t_st ``(:=salt%b)`.`foo ``'%_bar` TO &quot;
                &quot;'user \xe6\xa8\x99'@'localhost'&quot;,
                &quot;GRANT SELECT, INSERT ON `t_st ``(:=salt%b)`.`foo` TO &quot;
                &quot;'user \xe6\xa8\x99'@'localhost'&quot;,
            ],
        )

        ret = self.run_function(
            &quot;mysql.user_grants&quot;,
            user=&quot;&quot;,
            host=&quot;localhost&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertEqual(
            ret,
            [
                &quot;GRANT USAGE ON *.* TO ''@'localhost'&quot;,
                &quot;GRANT DELETE ON `test ``(:=salteeb)`.* TO ''@'localhost'&quot;,
            ],
        )


@skipIf(
    NO_MYSQL,
    &quot;Please install MySQL bindings and a MySQL Server before running&quot;
    &quot;MySQL integration tests.&quot;,
)
@pytest.mark.windows_whitelisted
class MysqlModuleFileQueryTest(ModuleCase, SaltReturnAssertsMixin):
    &quot;&quot;&quot;
    Test file query module
    &quot;&quot;&quot;

    user = &quot;root&quot;
    password = &quot;poney&quot;
    testdb = &quot;test_file_query&quot;

    @pytest.mark.destructive_test
    def setUp(self):
        &quot;&quot;&quot;
        Test presence of MySQL server, enforce a root password, create users
        &quot;&quot;&quot;
        super().setUp()
        NO_MYSQL_SERVER = True
        # now ensure we know the mysql root password
        # one of theses two at least should work
        ret1 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        ret2 = self.run_state(
            &quot;cmd.run&quot;,
            name='mysqladmin --host=&quot;localhost&quot; -u '
            + self.user
            + ' --password=&quot;'
            + self.password
            + '&quot; flush-privileges password &quot;'
            + self.password
            + '&quot;',
        )
        key, value = ret2.popitem()
        if value[&quot;result&quot;]:
            NO_MYSQL_SERVER = False
        else:
            self.skipTest(&quot;No MySQL Server running, or no root access on it.&quot;)
        # Create some users and a test db
        self.run_function(
            &quot;mysql.db_create&quot;,
            name=self.testdb,
            connection_user=self.user,
            connection_pass=self.password,
            connection_db=&quot;mysql&quot;,
        )

    @pytest.mark.destructive_test
    def tearDown(self):
        &quot;&quot;&quot;
        Removes created users and db
        &quot;&quot;&quot;
        self.run_function(
            &quot;mysql.db_remove&quot;,
            name=self.testdb,
            connection_user=self.user,
            connection_pass=self.password,
            connection_db=&quot;mysql&quot;,
        )

    @pytest.mark.destructive_test
    def test_update_file_query(self):
        &quot;&quot;&quot;
        Test query without any output
        &quot;&quot;&quot;
        ret = self.run_function(
            &quot;mysql.file_query&quot;,
            database=self.testdb,
            file_name=&quot;salt://mysql/update_query.sql&quot;,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        self.assertTrue(&quot;query time&quot; in ret)
        ret.pop(&quot;query time&quot;)
        self.assertEqual(ret, {&quot;rows affected&quot;: 2})

    @pytest.mark.destructive_test
    def test_select_file_query(self):
        &quot;&quot;&quot;
        Test query with table output
        &quot;&quot;&quot;
        ret = self.run_function(
            &quot;mysql.file_query&quot;,
            database=self.testdb,
            file_name=&quot;salt://mysql/select_query.sql&quot;,
            character_set=&quot;utf8&quot;,
            collate=&quot;utf8_general_ci&quot;,
            connection_user=self.user,
            connection_pass=self.password,
        )
        expected = {
            &quot;rows affected&quot;: 5,
            &quot;rows returned&quot;: 4,
            &quot;results&quot;: [[[&quot;2&quot;], [&quot;3&quot;], [&quot;4&quot;], [&quot;5&quot;]]],
            &quot;columns&quot;: [[&quot;a&quot;]],
        }
        self.assertTrue(&quot;query time&quot; in ret)
        ret.pop(&quot;query time&quot;)
        self.assertEqual(ret, expected)
</PRE>
</div>
  </div>
</body>
</html>
