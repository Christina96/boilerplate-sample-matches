<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for zpool_1.py & archive_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for zpool_1.py & archive_1.py
      </h3>
      <h1 align="center">
        1.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>zpool_1.py (1.0942761%)<TH>archive_1.py (1.0433387%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match252514-0.html#0',2,'match252514-1.html#0',3)" NAME="0">(1055-1097)<TD><A HREF="javascript:ZweiFrames('match252514-0.html#0',2,'match252514-1.html#0',3)" NAME="0">(557-588)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zpool_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for running ZFS zpool command

:codeauthor:    Nitin Madhok &lt;nmadhok@g.clemson.edu&gt;, Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maintainer:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maturity:      new
:depends:       salt.utils.zfs
:platform:      illumos,freebsd,linux

.. versionchanged:: 2018.3.1
  Big refactor to remove duplicate code, better type conversions and improved
  consistency in output.

&quot;&quot;&quot;

import logging
import os

import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.path
from salt.utils.odict import OrderedDict

log = logging.getLogger(__name__)

__virtualname__ = &quot;zpool&quot;
__func_alias__ = {
    &quot;import_&quot;: &quot;import&quot;,
    &quot;list_&quot;: &quot;list&quot;,
}


def __virtual__():
    &quot;&quot;&quot;
    Only load when the platform has zfs support
    &quot;&quot;&quot;
    if __grains__.get(&quot;zfs_support&quot;):
        return __virtualname__
    else:
        return False, &quot;The zpool module cannot be loaded: zfs not supported&quot;


def _clean_vdev_config(config):
    &quot;&quot;&quot;
    Return a simple vdev tree from zpool.status' config section
    &quot;&quot;&quot;
    cln_config = OrderedDict()
    for label, sub_config in config.items():
        if label not in [&quot;state&quot;, &quot;read&quot;, &quot;write&quot;, &quot;cksum&quot;]:
            sub_config = _clean_vdev_config(sub_config)

            if sub_config and isinstance(cln_config, list):
                cln_config.append(OrderedDict([(label, sub_config)]))
            elif sub_config and isinstance(cln_config, OrderedDict):
                cln_config[label] = sub_config
            elif isinstance(cln_config, list):
                cln_config.append(label)
            elif isinstance(cln_config, OrderedDict):
                new_config = []
                for old_label, old_config in cln_config.items():
                    new_config.append(OrderedDict([(old_label, old_config)]))
                new_config.append(label)
                cln_config = new_config
            else:
                cln_config = [label]

    return cln_config


def healthy():
    &quot;&quot;&quot;
    Check if all zpools are healthy

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.healthy

    &quot;&quot;&quot;
    ## collect status output
    # NOTE: we pass the -x flag, by doing this
    #       we will get 'all pools are healthy' on stdout
    #       if all pools are healthy, otherwise we will get
    #       the same output that we expect from zpool status
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](&quot;status&quot;, flags=[&quot;-x&quot;]),
        python_shell=False,
    )
    return res[&quot;stdout&quot;] == &quot;all pools are healthy&quot;


def status(zpool=None):
    &quot;&quot;&quot;
    Return the status of the named zpool

    zpool : string
        optional name of storage pool

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.status myzpool

    &quot;&quot;&quot;
    ret = OrderedDict()

    ## collect status output
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](&quot;status&quot;, target=zpool),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res)

    # NOTE: command output for reference
    # =====================================================================
    #   pool: data
    #  state: ONLINE
    #   scan: scrub repaired 0 in 2h27m with 0 errors on Mon Jan  8 03:27:25 2018
    # config:
    #
    #     NAME                       STATE     READ WRITE CKSUM
    #     data                       ONLINE       0     0     0
    #       mirror-0                 ONLINE       0     0     0
    #         c0tXXXXCXXXXXXXXXXXd0  ONLINE       0     0     0
    #         c0tXXXXCXXXXXXXXXXXd0  ONLINE       0     0     0
    #         c0tXXXXCXXXXXXXXXXXd0  ONLINE       0     0     0
    #
    # errors: No known data errors
    # =====================================================================

    ## parse status output
    # NOTE: output is 'key: value' except for the 'config' key.
    #       multiple pools will repeat the output, so if switch pools if
    #       we see 'pool:'
    current_pool = None
    current_prop = None
    for zpd in res[&quot;stdout&quot;].splitlines():
        if zpd.strip() == &quot;&quot;:
            continue
        if &quot;:&quot; in zpd and zpd[0] != &quot;\t&quot;:
            # NOTE: line is 'key: value' format, we just update a dict
            prop = zpd.split(&quot;:&quot;)[0].strip()
            value = &quot;:&quot;.join(zpd.split(&quot;:&quot;)[1:]).strip()
            if prop == &quot;pool&quot; and current_pool != value:
                current_pool = value
                ret[current_pool] = OrderedDict()
            if prop != &quot;pool&quot;:
                ret[current_pool][prop] = value

            current_prop = prop
        else:
            # NOTE: we append the line output to the last property
            #       this should only happens once we hit the config
            #       section
            ret[current_pool][current_prop] = &quot;{}\n{}&quot;.format(
                ret[current_pool][current_prop], zpd
            )

    ## parse config property for each pool
    # NOTE: the config property has some structured data
    #       sadly this data is in a different format than
    #       the rest and it needs further processing
    for pool in ret:
        if &quot;config&quot; not in ret[pool]:
            continue
        header = None
        root_vdev = None
        vdev = None
        dev = None
        rdev = None
        config = ret[pool][&quot;config&quot;]
        config_data = OrderedDict()
        for line in config.splitlines():
            # NOTE: the first line is the header
            #       we grab all the none whitespace values
            if not header:
                header = line.strip().lower()
                header = [x for x in header.split(&quot; &quot;) if x not in [&quot;&quot;]]
                continue

            # NOTE: data is indented by 1 tab, then multiples of 2 spaces
            #       to differential root vdev, vdev, and dev
            #
            #       we just strip the initial tab (can't use .strip() here)
            if line[0] == &quot;\t&quot;:
                line = line[1:]

            # NOTE: transform data into dict
            stat_data = OrderedDict(
                list(
                    zip(
                        header,
                        [x for x in line.strip().split(&quot; &quot;) if x not in [&quot;&quot;]],
                    )
                )
            )

            # NOTE: decode the zfs values properly
            stat_data = __utils__[&quot;zfs.from_auto_dict&quot;](stat_data)

            # NOTE: store stat_data in the proper location
            if line.startswith(&quot; &quot; * 6):
                rdev = stat_data[&quot;name&quot;]
                config_data[root_vdev][vdev][dev][rdev] = stat_data
            elif line.startswith(&quot; &quot; * 4):
                rdev = None
                dev = stat_data[&quot;name&quot;]
                config_data[root_vdev][vdev][dev] = stat_data
            elif line.startswith(&quot; &quot; * 2):
                rdev = dev = None
                vdev = stat_data[&quot;name&quot;]
                config_data[root_vdev][vdev] = stat_data
            else:
                rdev = dev = vdev = None
                root_vdev = stat_data[&quot;name&quot;]
                config_data[root_vdev] = stat_data

            # NOTE: name already used as identifier, drop duplicate data
            del stat_data[&quot;name&quot;]

        ret[pool][&quot;config&quot;] = config_data

    return ret


def iostat(zpool=None, sample_time=5, parsable=True):
    &quot;&quot;&quot;
    Display I/O statistics for the given pools

    zpool : string
        optional name of storage pool

    sample_time : int
        seconds to capture data before output
        default a sample of 5 seconds is used
    parsable : boolean
        display data in pythonc values (True, False, Bytes,...)

    .. versionadded:: 2016.3.0
    .. versionchanged:: 2018.3.1

        Added ```parsable``` parameter that defaults to True

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.iostat myzpool

    &quot;&quot;&quot;
    ret = OrderedDict()

    ## get iostat output
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;iostat&quot;, flags=[&quot;-v&quot;], target=[zpool, sample_time, 2]
        ),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res)

    # NOTE: command output for reference
    # =====================================================================
    #                               capacity     operations    bandwidth
    # pool                       alloc   free   read  write   read  write
    # -------------------------  -----  -----  -----  -----  -----  -----
    # mypool                      648G  1.18T     10      6  1.30M   817K
    #   mirror                    648G  1.18T     10      6  1.30M   817K
    #     c0tXXXXCXXXXXXXXXXXd0      -      -      9      5  1.29M   817K
    #     c0tXXXXCXXXXXXXXXXXd0      -      -      9      5  1.29M   817K
    #     c0tXXXXCXXXXXXXXXXXd0      -      -      9      5  1.29M   817K
    # -------------------------  -----  -----  -----  -----  -----  -----
    # =====================================================================

    ## parse iostat output
    # NOTE: hardcode the header
    #       the double header line is hard to parse, we opt to
    #       hardcode the header fields
    header = [
        &quot;name&quot;,
        &quot;capacity-alloc&quot;,
        &quot;capacity-free&quot;,
        &quot;operations-read&quot;,
        &quot;operations-write&quot;,
        &quot;bandwidth-read&quot;,
        &quot;bandwidth-write&quot;,
    ]
    root_vdev = None
    vdev = None
    dev = None
    current_data = OrderedDict()
    for line in res[&quot;stdout&quot;].splitlines():
        # NOTE: skip header
        if line.strip() == &quot;&quot; or line.strip().split()[-1] in [&quot;write&quot;, &quot;bandwidth&quot;]:
            continue

        # NOTE: reset pool on line separator
        if line.startswith(&quot;-&quot;) and line.endswith(&quot;-&quot;):
            ret.update(current_data)
            current_data = OrderedDict()
            continue

        # NOTE: transform data into dict
        io_data = OrderedDict(
            list(
                zip(
                    header,
                    [x for x in line.strip().split(&quot; &quot;) if x not in [&quot;&quot;]],
                )
            )
        )

        # NOTE: normalize values
        if parsable:
            # NOTE: raw numbers and pythonic types
            io_data = __utils__[&quot;zfs.from_auto_dict&quot;](io_data)
        else:
            # NOTE: human readable zfs types
            io_data = __utils__[&quot;zfs.to_auto_dict&quot;](io_data)

        # NOTE: store io_data in the proper location
        if line.startswith(&quot; &quot; * 4):
            dev = io_data[&quot;name&quot;]
            current_data[root_vdev][vdev][dev] = io_data
        elif line.startswith(&quot; &quot; * 2):
            dev = None
            vdev = io_data[&quot;name&quot;]
            current_data[root_vdev][vdev] = io_data
        else:
            dev = vdev = None
            root_vdev = io_data[&quot;name&quot;]
            current_data[root_vdev] = io_data

        # NOTE: name already used as identifier, drop duplicate data
        del io_data[&quot;name&quot;]

    return ret


def list_(properties=&quot;size,alloc,free,cap,frag,health&quot;, zpool=None, parsable=True):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Return information about (all) storage pools

    zpool : string
        optional name of storage pool

    properties : string
        comma-separated list of properties to list

    parsable : boolean
        display numbers in parsable (exact) values

        .. versionadded:: 2018.3.0

    .. note::

        The ``name`` property will always be included, while the ``frag``
        property will get removed if not available

    zpool : string
        optional zpool

    .. note::

        Multiple storage pool can be provided as a space separated list

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.list
        salt '*' zpool.list zpool=tank
        salt '*' zpool.list 'size,free'
        salt '*' zpool.list 'size,free' tank

    &quot;&quot;&quot;
    ret = OrderedDict()

    ## update properties
    # NOTE: properties should be a list
    if not isinstance(properties, list):
        properties = properties.split(&quot;,&quot;)

    # NOTE: name should be first property
    while &quot;name&quot; in properties:
        properties.remove(&quot;name&quot;)
    properties.insert(0, &quot;name&quot;)

    # NOTE: remove 'frags' if we don't have feature flags
    if not __utils__[&quot;zfs.has_feature_flags&quot;]():
        while &quot;frag&quot; in properties:
            properties.remove(&quot;frag&quot;)

    ## collect list output
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;list&quot;,
            flags=[&quot;-H&quot;],
            opts={&quot;-o&quot;: &quot;,&quot;.join(properties)},
            target=zpool,
        ),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res)

    # NOTE: command output for reference
    # ========================================================================
    # data  1992864825344   695955501056    1296909324288   34  11%     ONLINE
    # =========================================================================

    ## parse list output
    for line in res[&quot;stdout&quot;].splitlines():
        # NOTE: transform data into dict
        zpool_data = OrderedDict(
            list(
                zip(
                    properties,
                    line.strip().split(&quot;\t&quot;),
                )
            )
        )

        # NOTE: normalize values
        if parsable:
            # NOTE: raw numbers and pythonic types
            zpool_data = __utils__[&quot;zfs.from_auto_dict&quot;](zpool_data)
        else:
            # NOTE: human readable zfs types
            zpool_data = __utils__[&quot;zfs.to_auto_dict&quot;](zpool_data)

        ret[zpool_data[&quot;name&quot;]] = zpool_data
        del ret[zpool_data[&quot;name&quot;]][&quot;name&quot;]

    return ret


def get(zpool, prop=None, show_source=False, parsable=True):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Retrieves the given list of properties

    zpool : string
        Name of storage pool

    prop : string
        Optional name of property to retrieve

    show_source : boolean
        Show source of property

    parsable : boolean
        Display numbers in parsable (exact) values

        .. versionadded:: 2018.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.get myzpool

    &quot;&quot;&quot;
    ret = OrderedDict()
    value_properties = [&quot;name&quot;, &quot;property&quot;, &quot;value&quot;, &quot;source&quot;]

    ## collect get output
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;get&quot;,
            flags=[&quot;-H&quot;],
            property_name=prop if prop else &quot;all&quot;,
            target=zpool,
        ),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res)

    # NOTE: command output for reference
    # ========================================================================
    # ...
    # data  mountpoint  /data   local
    # data  compression off     default
    # ...
    # =========================================================================

    # parse get output
    for line in res[&quot;stdout&quot;].splitlines():
        # NOTE: transform data into dict
        prop_data = OrderedDict(
            list(
                zip(
                    value_properties,
                    [x for x in line.strip().split(&quot;\t&quot;) if x not in [&quot;&quot;]],
                )
            )
        )

        # NOTE: older zfs does not have -o, fall back to manually stipping the name field
        del prop_data[&quot;name&quot;]

        # NOTE: normalize values
        if parsable:
            # NOTE: raw numbers and pythonic types
            prop_data[&quot;value&quot;] = __utils__[&quot;zfs.from_auto&quot;](
                prop_data[&quot;property&quot;], prop_data[&quot;value&quot;]
            )
        else:
            # NOTE: human readable zfs types
            prop_data[&quot;value&quot;] = __utils__[&quot;zfs.to_auto&quot;](
                prop_data[&quot;property&quot;], prop_data[&quot;value&quot;]
            )

        # NOTE: show source if requested
        if show_source:
            ret[prop_data[&quot;property&quot;]] = prop_data
            del ret[prop_data[&quot;property&quot;]][&quot;property&quot;]
        else:
            ret[prop_data[&quot;property&quot;]] = prop_data[&quot;value&quot;]

    return ret


def set(zpool, prop, value):
    &quot;&quot;&quot;
    Sets the given property on the specified pool

    zpool : string
        Name of storage pool

    prop : string
        Name of property to set

    value : string
        Value to set for the specified property

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.set myzpool readonly yes

    &quot;&quot;&quot;
    ret = OrderedDict()

    # set property
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;set&quot;,
            property_name=prop,
            property_value=value,
            target=zpool,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;set&quot;)


def exists(zpool):
    &quot;&quot;&quot;
    Check if a ZFS storage pool is active

    zpool : string
        Name of storage pool

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.exists myzpool

    &quot;&quot;&quot;
    # list for zpool
    # NOTE: retcode &gt; 0 if zpool does not exists
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;list&quot;,
            target=zpool,
        ),
        python_shell=False,
        ignore_retcode=True,
    )

    return res[&quot;retcode&quot;] == 0


def destroy(zpool, force=False):
    &quot;&quot;&quot;
    Destroys a storage pool

    zpool : string
        Name of storage pool

    force : boolean
        Force destroy of pool

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.destroy myzpool

    &quot;&quot;&quot;
    # destroy zpool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;destroy&quot;,
            flags=[&quot;-f&quot;] if force else None,
            target=zpool,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;destroyed&quot;)


def scrub(zpool, stop=False, pause=False):
    &quot;&quot;&quot;
    Scrub a storage pool

    zpool : string
        Name of storage pool

    stop : boolean
        If ``True``, cancel ongoing scrub

    pause : boolean
        If ``True``, pause ongoing scrub

        .. versionadded:: 2018.3.0

        .. note::

            Pause is only available on recent versions of ZFS.

            If both ``pause`` and ``stop`` are ``True``, then ``stop`` will
            win.

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.scrub myzpool

    &quot;&quot;&quot;
    ## select correct action
    if stop:
        action = [&quot;-s&quot;]
    elif pause:
        action = [&quot;-p&quot;]
    else:
        action = None

    ## Scrub storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;scrub&quot;,
            flags=action,
            target=zpool,
        ),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;scrubbing&quot;)

    ret = OrderedDict()
    if stop or pause:
        ret[&quot;scrubbing&quot;] = False
    else:
        ret[&quot;scrubbing&quot;] = True
    return ret


def create(zpool, *vdevs, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Create a simple zpool, a mirrored zpool, a zpool having nested VDEVs, a hybrid zpool with cache, spare and log drives or a zpool with RAIDZ-1, RAIDZ-2 or RAIDZ-3

    zpool : string
        Name of storage pool

    vdevs : string
        One or move devices

    force : boolean
        Forces use of vdevs, even if they appear in use or specify a
        conflicting replication level.

    mountpoint : string
        Sets the mount point for the root dataset

    altroot : string
        Equivalent to &quot;-o cachefile=none,altroot=root&quot;

    properties : dict
        Additional pool properties

    filesystem_properties : dict
        Additional filesystem properties

    createboot : boolean
        create a boot partition

        .. versionadded:: 2018.3.0

        .. warning:
          This is only available on illumos and Solaris

    CLI Examples:

    .. code-block:: bash

        salt '*' zpool.create myzpool /path/to/vdev1 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 /path/to/vdev2 [...] [force=True|False]
        salt '*' zpool.create myzpool raidz1 /path/to/vdev1 /path/to/vdev2 raidz2 /path/to/vdev3 /path/to/vdev4 /path/to/vdev5 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 [...] mirror /path/to/vdev2 /path/to/vdev3 [...] [force=True|False]
        salt '*' zpool.create myhybridzpool mirror /tmp/file1 [...] log mirror /path/to/vdev1 [...] cache /path/to/vdev2 [...] spare /path/to/vdev3 [...] [force=True|False]

    .. note::

        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called &quot;properties&quot; and specifying
        the properties with their respective values in the form of a python
        dictionary:

        .. code-block:: text

            properties=&quot;{'property1': 'value1', 'property2': 'value2'}&quot;

        Filesystem properties can be specified at the time of creation of the
        pool by passing an additional argument called &quot;filesystem_properties&quot;
        and specifying the properties with their respective values in the form
        of a python dictionary:

        .. code-block:: text

            filesystem_properties=&quot;{'property1': 'value1', 'property2': 'value2'}&quot;

        Example:

        .. code-block:: bash

            salt '*' zpool.create myzpool /path/to/vdev1 [...] properties=&quot;{'property1': 'value1', 'property2': 'value2'}&quot;

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.create myzpool /path/to/vdev1 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 /path/to/vdev2 [...] [force=True|False]
        salt '*' zpool.create myzpool raidz1 /path/to/vdev1 /path/to/vdev2 raidz2 /path/to/vdev3 /path/to/vdev4 /path/to/vdev5 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 [...] mirror /path/to/vdev2 /path/to/vdev3 [...] [force=True|False]
        salt '*' zpool.create myhybridzpool mirror /tmp/file1 [...] log mirror /path/to/vdev1 [...] cache /path/to/vdev2 [...] spare /path/to/vdev3 [...] [force=True|False]

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    opts = {}
    target = []

    # NOTE: push pool and filesystem properties
    pool_properties = kwargs.get(&quot;properties&quot;, {})
    filesystem_properties = kwargs.get(&quot;filesystem_properties&quot;, {})

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;force&quot;, False):
        flags.append(&quot;-f&quot;)
    if kwargs.get(&quot;createboot&quot;, False) or &quot;bootsize&quot; in pool_properties:
        flags.append(&quot;-B&quot;)
    if kwargs.get(&quot;altroot&quot;, False):
        opts[&quot;-R&quot;] = kwargs.get(&quot;altroot&quot;)
    if kwargs.get(&quot;mountpoint&quot;, False):
        opts[&quot;-m&quot;] = kwargs.get(&quot;mountpoint&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.extend(vdevs)

    ## Create storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;create&quot;,
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            filesystem_properties=filesystem_properties,
            target=target,
        ),
        python_shell=False,
    )

    ret = __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;created&quot;)
    if ret[&quot;created&quot;]:
        ## NOTE: lookup zpool status for vdev config
        ret[&quot;vdevs&quot;] = _clean_vdev_config(
            __salt__[&quot;zpool.status&quot;](zpool=zpool)[zpool][&quot;config&quot;][zpool],
        )

    return ret


def add(zpool, *vdevs, **kwargs):
    &quot;&quot;&quot;
    Add the specified vdev\'s to the given storage pool

    zpool : string
        Name of storage pool

    vdevs : string
        One or more devices

    force : boolean
        Forces use of device

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.add myzpool /path/to/vdev1 /path/to/vdev2 [...]

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    target = []

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;force&quot;, False):
        flags.append(&quot;-f&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.extend(vdevs)

    ## Update storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;add&quot;,
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )

    ret = __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;added&quot;)
    if ret[&quot;added&quot;]:
        ## NOTE: lookup zpool status for vdev config
        ret[&quot;vdevs&quot;] = _clean_vdev_config(
            __salt__[&quot;zpool.status&quot;](zpool=zpool)[zpool][&quot;config&quot;][zpool],
        )

    return ret


def attach(zpool, device, new_device, force=False):
    &quot;&quot;&quot;
    Attach specified device to zpool

    zpool : string
        Name of storage pool

    device : string
        Existing device name too

    new_device : string
        New device name (to be attached to ``device``)

    force : boolean
        Forces use of device

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.attach myzpool /path/to/vdev1 /path/to/vdev2 [...]

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    target = []

    # NOTE: set extra config
    if force:
        flags.append(&quot;-f&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.append(device)
    target.append(new_device)

    ## Update storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;attach&quot;,
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )

    ret = __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;attached&quot;)
    if ret[&quot;attached&quot;]:
        ## NOTE: lookup zpool status for vdev config
        ret[&quot;vdevs&quot;] = _clean_vdev_config(
            __salt__[&quot;zpool.status&quot;](zpool=zpool)[zpool][&quot;config&quot;][zpool],
        )

    return ret


def detach(zpool, device):
    &quot;&quot;&quot;
    Detach specified device to zpool

    zpool : string
        Name of storage pool

    device : string
        Device to detach

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.detach myzpool /path/to/vdev1

    &quot;&quot;&quot;
    ## Update storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;detach&quot;,
            target=[zpool, device],
        ),
        python_shell=False,
    )

    ret = __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;detatched&quot;)
    if ret[&quot;detatched&quot;]:
        ## NOTE: lookup zpool status for vdev config
        ret[&quot;vdevs&quot;] = _clean_vdev_config(
            __salt__[&quot;zpool.status&quot;](zpool=zpool)[zpool][&quot;config&quot;][zpool],
        )

    return ret


def split(zpool, newzpool, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2018.3.0

    Splits devices off pool creating newpool.

    .. note::

        All vdevs in pool must be mirrors.  At the time of the split,
        ``newzpool`` will be a replica of ``zpool``.

        After splitting, do not forget to import the new pool!

    zpool : string
        Name of storage pool

    newzpool : string
        Name of new storage pool

    mountpoint : string
        Sets the mount point for the root dataset

    altroot : string
        Sets altroot for newzpool

    properties : dict
        Additional pool properties for newzpool

    CLI Examples:

    .. code-block:: bash

        salt '*' zpool.split datamirror databackup
        salt '*' zpool.split datamirror databackup altroot=/backup

    .. note::

        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called &quot;properties&quot; and specifying
        the properties with their respective values in the form of a python
        dictionary:

        .. code-block:: text

            properties=&quot;{'property1': 'value1', 'property2': 'value2'}&quot;

        Example:

        .. code-block:: bash

            salt '*' zpool.split datamirror databackup properties=&quot;{'readonly': 'on'}&quot;

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.split datamirror databackup
        salt '*' zpool.split datamirror databackup altroot=/backup

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    opts = {}

    # NOTE: push pool and filesystem properties
    pool_properties = kwargs.get(&quot;properties&quot;, {})

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;altroot&quot;, False):
        opts[&quot;-R&quot;] = kwargs.get(&quot;altroot&quot;)

    ## Split storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;split&quot;,
            opts=opts,
            pool_properties=pool_properties,
            target=[zpool, newzpool],
        ),
        python_shell=False,
    )

<A NAME="0"></A>    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;split&quot;)


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match252514-1.html#0',3,'match252514-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>def replace(zpool, old_device, new_device=None, force=False):
    &quot;&quot;&quot;
    Replaces ``old_device`` with ``new_device``

    .. note::

        This is equivalent to attaching ``new_device``,
        waiting for it to resilver, and then detaching ``old_device``.

        The size of ``new_device`` must be greater than or equal to the minimum
        size of all the devices in a mirror or raidz configuration.

    zpool : string
        Name of storage pool

    old_device : string
        Old device to replace

    new_device : string
        Optional new device

    force : boolean
        Forces use of new_device, even if its appears to be in use.

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.replace myzpool /path/to/vdev1 /path/to/vdev2

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    target = []

    # NOTE: set extra config
    if force:
        flags.append(&quot;-f&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.append(</B></FONT>old_device)
    if new_device:
        target.append(new_device)

    ## Replace device
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;replace&quot;,
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )

    ret = __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;replaced&quot;)
    if ret[&quot;replaced&quot;]:
        ## NOTE: lookup zpool status for vdev config
        ret[&quot;vdevs&quot;] = _clean_vdev_config(
            __salt__[&quot;zpool.status&quot;](zpool=zpool)[zpool][&quot;config&quot;][zpool],
        )

    return ret


@salt.utils.decorators.path.which(&quot;mkfile&quot;)
def create_file_vdev(size, *vdevs):
    &quot;&quot;&quot;
    Creates file based virtual devices for a zpool

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.create_file_vdev 7G /path/to/vdev1 [/path/to/vdev2] [...]

    .. note::

        Depending on file size, the above command may take a while to return.

    &quot;&quot;&quot;
    ret = OrderedDict()
    err = OrderedDict()

    _mkfile_cmd = salt.utils.path.which(&quot;mkfile&quot;)
    for vdev in vdevs:
        if os.path.isfile(vdev):
            ret[vdev] = &quot;existed&quot;
        else:
            res = __salt__[&quot;cmd.run_all&quot;](
                &quot;{mkfile} {size} {vdev}&quot;.format(
                    mkfile=_mkfile_cmd,
                    size=size,
                    vdev=vdev,
                ),
                python_shell=False,
            )
            if res[&quot;retcode&quot;] != 0:
                if &quot;stderr&quot; in res and &quot;:&quot; in res[&quot;stderr&quot;]:
                    ret[vdev] = &quot;failed&quot;
                    err[vdev] = &quot;:&quot;.join(res[&quot;stderr&quot;].strip().split(&quot;:&quot;)[1:])
            else:
                ret[vdev] = &quot;created&quot;
    if err:
        ret[&quot;error&quot;] = err

    return ret


def export(*pools, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Export storage pools

    pools : string
        One or more storage pools to export

    force : boolean
        Force export of storage pools

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.export myzpool ... [force=True|False]
        salt '*' zpool.export myzpool2 myzpool2 ... [force=True|False]

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    targets = []

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;force&quot;, False):
        flags.append(&quot;-f&quot;)

    # NOTE: append the pool name and specifications
    targets = list(pools)

    ## Export pools
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;export&quot;,
            flags=flags,
            target=targets,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;exported&quot;)


def import_(zpool=None, new_name=None, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Import storage pools or list pools available for import

    zpool : string
        Optional name of storage pool

    new_name : string
        Optional new name for the storage pool

    mntopts : string
        Comma-separated list of mount options to use when mounting datasets
        within the pool.

    force : boolean
        Forces import, even if the pool appears to be potentially active.

    altroot : string
        Equivalent to &quot;-o cachefile=none,altroot=root&quot;

    dir : string
        Searches for devices or files in dir, multiple dirs can be specified as
        follows: ``dir=&quot;dir1,dir2&quot;``

    no_mount : boolean
        Import the pool without mounting any file systems.

    only_destroyed : boolean
        Imports destroyed pools only. This also sets ``force=True``.

    recovery : bool|str
        false: do not try to recovery broken pools
        true: try to recovery the pool by rolling back the latest transactions
        test: check if a pool can be recovered, but don't import it
        nolog: allow import without log device, recent transactions might be lost

        .. note::
            If feature flags are not support this forced to the default of 'false'

        .. warning::
            When recovery is set to 'test' the result will be have imported set to True if the pool
            can be imported. The pool might also be imported if the pool was not broken to begin with.

    properties : dict
        Additional pool properties

    .. note::

        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called &quot;properties&quot; and specifying
        the properties with their respective values in the form of a python
        dictionary:

        .. code-block:: text

            properties=&quot;{'property1': 'value1', 'property2': 'value2'}&quot;

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.import [force=True|False]
        salt '*' zpool.import myzpool [mynewzpool] [force=True|False]
        salt '*' zpool.import myzpool dir='/tmp'

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    opts = {}
    target = []

    # NOTE: push pool and filesystem properties
    pool_properties = kwargs.get(&quot;properties&quot;, {})

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;force&quot;, False) or kwargs.get(&quot;only_destroyed&quot;, False):
        flags.append(&quot;-f&quot;)
    if kwargs.get(&quot;only_destroyed&quot;, False):
        flags.append(&quot;-D&quot;)
    if kwargs.get(&quot;no_mount&quot;, False):
        flags.append(&quot;-N&quot;)
    if kwargs.get(&quot;altroot&quot;, False):
        opts[&quot;-R&quot;] = kwargs.get(&quot;altroot&quot;)
    if kwargs.get(&quot;mntopts&quot;, False):
        # NOTE: -o is used for both mount options and pool properties!
        #       ```-o nodevices,noexec,nosetuid,ro``` vs ```-o prop=val```
        opts[&quot;-o&quot;] = kwargs.get(&quot;mntopts&quot;)
    if kwargs.get(&quot;dir&quot;, False):
        opts[&quot;-d&quot;] = kwargs.get(&quot;dir&quot;).split(&quot;,&quot;)
    if kwargs.get(&quot;recovery&quot;, False) and __utils__[&quot;zfs.has_feature_flags&quot;]():
        recovery = kwargs.get(&quot;recovery&quot;)
        if recovery in [True, &quot;test&quot;]:
            flags.append(&quot;-F&quot;)
        if recovery == &quot;test&quot;:
            flags.append(&quot;-n&quot;)
        if recovery == &quot;nolog&quot;:
            flags.append(&quot;-m&quot;)

    # NOTE: append the pool name and specifications
    if zpool:
        target.append(zpool)
        target.append(new_name)
    else:
        flags.append(&quot;-a&quot;)

    ## Import storage pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;import&quot;,
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            target=target,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;imported&quot;)


def online(zpool, *vdevs, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Ensure that the specified devices are online

    zpool : string
        name of storage pool

    vdevs : string
        one or more devices

    expand : boolean
        Expand the device to use all available space.

        .. note::

            If the device is part of a mirror or raidz then all devices must be
            expanded before the new space will become available to the pool.

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.online myzpool /path/to/vdev1 [...]

    &quot;&quot;&quot;
    ## Configure pool
    # default options
    flags = []
    target = []

    # set flags and options
    if kwargs.get(&quot;expand&quot;, False):
        flags.append(&quot;-e&quot;)
    target.append(zpool)
    if vdevs:
        target.extend(vdevs)

    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    target = []

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;expand&quot;, False):
        flags.append(&quot;-e&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.extend(vdevs)

    ## Bring online device
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;online&quot;,
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;onlined&quot;)


def offline(zpool, *vdevs, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0

    Ensure that the specified devices are offline

    .. warning::

        By default, the ``OFFLINE`` state is persistent. The device remains
        offline when the system is rebooted. To temporarily take a device
        offline, use ``temporary=True``.

    zpool : string
        name of storage pool

    vdevs : string
        One or more devices

    temporary : boolean
        Enable temporarily offline

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.offline myzpool /path/to/vdev1 [...] [temporary=True|False]

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    target = []

    # NOTE: set extra config based on kwargs
    if kwargs.get(&quot;temporary&quot;, False):
        flags.append(&quot;-t&quot;)

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.extend(vdevs)

    ## Take a device offline
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;offline&quot;,
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;offlined&quot;)


def labelclear(device, force=False):
    &quot;&quot;&quot;
    .. versionadded:: 2018.3.0

    Removes ZFS label information from the specified device

    device : string
        Device name; must not be part of an active pool configuration.

    force : boolean
        Treat exported or foreign devices as inactive

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.labelclear /path/to/dev

    &quot;&quot;&quot;
    ## clear label for all specified device
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;labelclear&quot;,
            flags=[&quot;-f&quot;] if force else None,
            target=device,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;labelcleared&quot;)


def clear(zpool, device=None):
    &quot;&quot;&quot;
    Clears device errors in a pool.

    .. warning::

        The device must not be part of an active pool configuration.

    zpool : string
        name of storage pool
    device : string
        (optional) specific device to clear

    .. versionadded:: 2018.3.1

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.clear mypool
        salt '*' zpool.clear mypool /path/to/dev

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    target = []

    # NOTE: append the pool name and specifications
    target.append(zpool)
    target.append(device)

    ## clear storage pool errors
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;clear&quot;,
            target=target,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;cleared&quot;)


def reguid(zpool):
    &quot;&quot;&quot;
    Generates a new unique identifier for the pool

    .. warning::
        You must ensure that all devices in this pool are online and healthy
        before performing this action.

    zpool : string
        name of storage pool

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.reguid myzpool
    &quot;&quot;&quot;
    ## generate new GUID for pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;reguid&quot;,
            target=zpool,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;reguided&quot;)


def reopen(zpool):
    &quot;&quot;&quot;
    Reopen all the vdevs associated with the pool

    zpool : string
        name of storage pool

    .. versionadded:: 2016.3.0

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.reopen myzpool

    &quot;&quot;&quot;
    ## reopen all devices fro pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;reopen&quot;,
            target=zpool,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;reopened&quot;)


def upgrade(zpool=None, version=None):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Enables all supported features on the given pool

    zpool : string
        Optional storage pool, applies to all otherwize

    version : int
        Version to upgrade to, if unspecified upgrade to the highest possible

    .. warning::
        Once this is done, the pool will no longer be accessible on systems that do not
        support feature flags. See zpool-features(5) for details on compatibility with
        systems that support feature flags, but do not support all features enabled on the pool.

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.upgrade myzpool

    &quot;&quot;&quot;
    ## Configure pool
    # NOTE: initialize the defaults
    flags = []
    opts = {}

    # NOTE: set extra config
    if version:
        opts[&quot;-V&quot;] = version
    if not zpool:
        flags.append(&quot;-a&quot;)

    ## Upgrade pool
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;upgrade&quot;,
            flags=flags,
            opts=opts,
            target=zpool,
        ),
        python_shell=False,
    )

    return __utils__[&quot;zfs.parse_command_result&quot;](res, &quot;upgraded&quot;)


def history(zpool=None, internal=False, verbose=False):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Displays the command history of the specified pools, or all pools if no
    pool is specified

    zpool : string
        Optional storage pool

    internal : boolean
        Toggle display of internally logged ZFS events

    verbose : boolean
        Toggle display of the user name, the hostname, and the zone in which
        the operation was performed

    CLI Example:

    .. code-block:: bash

        salt '*' zpool.upgrade myzpool

    &quot;&quot;&quot;
    ret = OrderedDict()

    ## Configure pool
    # NOTE: initialize the defaults
    flags = []

    # NOTE: set extra config
    if verbose:
        flags.append(&quot;-l&quot;)
    if internal:
        flags.append(&quot;-i&quot;)

    ## Lookup history
    res = __salt__[&quot;cmd.run_all&quot;](
        __utils__[&quot;zfs.zpool_command&quot;](
            command=&quot;history&quot;,
            flags=flags,
            target=zpool,
        ),
        python_shell=False,
    )

    if res[&quot;retcode&quot;] != 0:
        return __utils__[&quot;zfs.parse_command_result&quot;](res)
    else:
        pool = &quot;unknown&quot;
        for line in res[&quot;stdout&quot;].splitlines():
            if line.startswith(&quot;History for&quot;):
                pool = line[13:-2]
                ret[pool] = OrderedDict()
            else:
                if line == &quot;&quot;:
                    continue
                log_timestamp = line[0:19]
                log_command = line[20:]
                ret[pool][log_timestamp] = log_command

    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
A module to wrap (non-Windows) archive calls

.. versionadded:: 2014.1.0
&quot;&quot;&quot;

import contextlib
import copy
import errno
import glob
import logging
import os
import re
import shlex
import stat
import subprocess
import tarfile
import urllib.parse
import zipfile

import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
from salt.exceptions import CommandExecutionError, SaltInvocationError

try:
    import rarfile

    HAS_RARFILE = True
except ImportError:
    HAS_RARFILE = False


if salt.utils.platform.is_windows():
    import win32file

# TODO: Check that the passed arguments are correct

# Don't shadow built-in's.
__func_alias__ = {&quot;zip_&quot;: &quot;zip&quot;, &quot;list_&quot;: &quot;list&quot;}

log = logging.getLogger(__name__)


def list_(
    name,
    archive_format=None,
    options=None,
    strip_components=None,
    clean=False,
    verbose=False,
    saltenv=&quot;base&quot;,
    source_hash=None,
    use_etag=False,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0
    .. versionchanged:: 2016.11.2,3005
        The rarfile_ Python module is now supported for listing the contents of
        rar archives. This is necessary on minions with older releases of the
        ``rar`` CLI tool, which do not support listing the contents in a
        parsable format.

    .. _rarfile: https://pypi.python.org/pypi/rarfile

    List the files and directories in an tar, zip, or rar archive.

    .. note::
        This function will only provide results for XZ-compressed archives if
        the xz_ CLI command is available, as Python does not at this time
        natively support XZ compression in its tarfile_ module. Keep in mind
        however that most Linux distros ship with xz_ already installed.

        To check if a given minion has xz_, the following Salt command can be
        run:

        .. code-block:: bash

            salt minion_id cmd.which xz

        If ``None`` is returned, then xz_ is not present and must be installed.
        It is widely available and should be packaged as either ``xz`` or
        ``xz-utils``.

    name
        Path/URL of archive

    archive_format
        Specify the format of the archive (``tar``, ``zip``, or ``rar``). If
        this argument is omitted, the archive format will be guessed based on
        the value of the ``name`` parameter.

    options
        **For tar archives only.** This function will, by default, try to use
        the tarfile_ module from the Python standard library to get a list of
        files/directories. If this method fails, then it will fall back to
        using the shell to decompress the archive to stdout and pipe the
        results to ``tar -tf -`` to produce a list of filenames. XZ-compressed
        archives are already supported automatically, but in the event that the
        tar archive uses a different sort of compression not supported natively
        by tarfile_, this option can be used to specify a command that will
        decompress the archive to stdout. For example:

        .. code-block:: bash

            salt minion_id archive.list /path/to/foo.tar.gz options='gzip --decompress --stdout'

        .. note::
            It is not necessary to manually specify options for gzip'ed
            archives, as gzip compression is natively supported by tarfile_.

    strip_components
        This argument specifies a number of top-level directories to strip from
        the results. This is similar to the paths that would be extracted if
        ``--strip-components`` (or ``--strip``) were used when extracting tar
        archives.

        .. versionadded:: 2016.11.2

    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.

        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.

    verbose : False
        If ``False``, this function will return a list of files/dirs in the
        archive. If ``True``, it will return a dictionary categorizing the
        paths into separate keys containing the directory names, file names,
        and also directories/files present in the top level of the archive.

        .. versionchanged:: 2016.11.2
            This option now includes symlinks in their own list. Before, they
            were included with files.

    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.

    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.

        .. versionadded:: 2018.3.0

    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.

        .. versionadded:: 3005

    .. _tarfile: https://docs.python.org/2/library/tarfile.html
    .. _xz: http://tukaani.org/xz/

    CLI Examples:

    .. code-block:: bash

            salt '*' archive.list /path/to/myfile.tar.gz
            salt '*' archive.list /path/to/myfile.tar.gz strip_components=1
            salt '*' archive.list salt://foo.tar.gz
            salt '*' archive.list https://domain.tld/myfile.zip
            salt '*' archive.list https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.list ftp://10.1.2.3/foo.rar
    &quot;&quot;&quot;

    def _list_tar(name, cached, decompress_cmd, failhard=False):
        &quot;&quot;&quot;
        List the contents of a tar archive.
        &quot;&quot;&quot;
        dirs = []
        files = []
        links = []
        try:
            open_kwargs = (
                {&quot;name&quot;: cached}
                if not isinstance(cached, subprocess.Popen)
                else {&quot;fileobj&quot;: cached.stdout, &quot;mode&quot;: &quot;r|&quot;}
            )
            with contextlib.closing(tarfile.open(**open_kwargs)) as tar_archive:
                for member in tar_archive.getmembers():
                    _member = salt.utils.data.decode(member.name)
                    if member.issym():
                        links.append(_member)
                    elif member.isdir():
                        dirs.append(_member + &quot;/&quot;)
                    else:
                        files.append(_member)
            return dirs, files, links

        except tarfile.ReadError:
            if failhard:
                if isinstance(cached, subprocess.Popen):
                    stderr = cached.communicate()[1]
                    if cached.returncode != 0:
                        raise CommandExecutionError(
                            &quot;Failed to decompress {}&quot;.format(name),
                            info={&quot;error&quot;: stderr},
                        )
            else:
                if not salt.utils.path.which(&quot;tar&quot;):
                    raise CommandExecutionError(&quot;'tar' command not available&quot;)
                if decompress_cmd is not None and isinstance(decompress_cmd, str):
                    # Guard against shell injection
                    try:
                        decompress_cmd = [
                            shlex.quote(x) for x in shlex.split(decompress_cmd)
                        ]
                    except AttributeError:
                        raise CommandExecutionError(&quot;Invalid CLI options&quot;)
                else:
                    if (
                        salt.utils.path.which(&quot;xz&quot;)
                        and __salt__[&quot;cmd.retcode&quot;](
                            [&quot;xz&quot;, &quot;-t&quot;, cached],
                            python_shell=False,
                            ignore_retcode=True,
                        )
                        == 0
                    ):
                        decompress_cmd = [&quot;xz&quot;, &quot;--decompress&quot;, &quot;--stdout&quot;]

                if decompress_cmd:
                    decompressed = subprocess.Popen(
                        decompress_cmd + [shlex.quote(cached)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                    )
                    return _list_tar(name, decompressed, None, True)

        raise CommandExecutionError(
            &quot;Unable to list contents of {}. If this is an XZ-compressed tar &quot;
            &quot;archive, install XZ Utils to enable listing its contents. If it &quot;
            &quot;is compressed using something other than XZ, it may be necessary &quot;
            &quot;to specify CLI options to decompress the archive. See the &quot;
            &quot;documentation for details.&quot;.format(name)
        )

    def _list_zip(name, cached):
        &quot;&quot;&quot;
        List the contents of a zip archive.
        Password-protected ZIP archives can still be listed by zipfile, so
        there is no reason to invoke the unzip command.
        &quot;&quot;&quot;
        dirs = set()
        files = []
        links = []
        try:
            with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
                for member in zip_archive.infolist():
                    path = member.filename
                    if salt.utils.platform.is_windows():
                        if path.endswith(&quot;/&quot;):
                            # zipfile.ZipInfo objects on windows use forward
                            # slash at end of the directory name.
                            dirs.add(path)
                        else:
                            files.append(path)
                    else:
                        mode = member.external_attr &gt;&gt; 16
                        if stat.S_ISLNK(mode):
                            links.append(path)
                        elif stat.S_ISDIR(mode):
                            dirs.add(path)
                        else:
                            files.append(path)

                _files = copy.deepcopy(files)
                for path in _files:
                    # ZIP files created on Windows do not add entries
                    # to the archive for directories. So, we'll need to
                    # manually add them.
                    dirname = &quot;&quot;.join(path.rpartition(&quot;/&quot;)[:2])
                    if dirname:
                        dirs.add(dirname)
                        if dirname in files:
                            files.remove(dirname)
            return list(dirs), files, links
        except zipfile.BadZipfile:
            raise CommandExecutionError(&quot;{} is not a ZIP file&quot;.format(name))

    def _list_rar(name, cached):
        &quot;&quot;&quot;
        List the contents of a rar archive.
        &quot;&quot;&quot;
        dirs = []
        files = []
        if HAS_RARFILE:
            with rarfile.RarFile(cached) as rf:
                for member in rf.infolist():
                    path = member.filename.replace(&quot;\\&quot;, &quot;/&quot;)
                    if member.isdir():
                        dirs.append(path + &quot;/&quot;)
                    else:
                        files.append(path)
        else:
            if not salt.utils.path.which(&quot;rar&quot;):
                raise CommandExecutionError(
                    &quot;rar command not available, is it installed?&quot;
                )
            output = __salt__[&quot;cmd.run&quot;](
                [&quot;rar&quot;, &quot;lt&quot;, name], python_shell=False, ignore_retcode=False
            )
            matches = re.findall(r&quot;Name:\s*([^\n]+)\s*Type:\s*([^\n]+)&quot;, output)
            for path, type_ in matches:
                if type_ == &quot;Directory&quot;:
                    dirs.append(path + &quot;/&quot;)
                else:
                    files.append(path)
            if not dirs and not files:
                raise CommandExecutionError(
                    &quot;Failed to list {}, is it a rar file? If so, the &quot;
                    &quot;installed version of rar may be too old to list data in &quot;
                    &quot;a parsable format. Installing the rarfile Python module &quot;
                    &quot;may be an easier workaround if newer rar is not readily &quot;
                    &quot;available.&quot;.format(name),
                    info={&quot;error&quot;: output},
                )
        return dirs, files, []

    cached = __salt__[&quot;cp.cache_file&quot;](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError(&quot;Failed to cache {}&quot;.format(name))

    try:
        if strip_components:
            try:
                int(strip_components)
            except ValueError:
                strip_components = -1

            if strip_components &lt;= 0:
                raise CommandExecutionError(
                    &quot;'strip_components' must be a positive integer&quot;
                )

        parsed = urllib.parse.urlparse(name)
        path = parsed.path or parsed.netloc

        def _unsupported_format(archive_format):
            &quot;&quot;&quot;
            Raise the proper exception message for the given archive format.
            &quot;&quot;&quot;
            if archive_format is None:
                raise CommandExecutionError(
                    &quot;Unable to guess archive format, please pass an &quot;
                    &quot;'archive_format' argument.&quot;
                )
            raise CommandExecutionError(
                &quot;Unsupported archive format '{}'&quot;.format(archive_format)
            )

        if not archive_format:
            guessed_format = salt.utils.files.guess_archive_type(path)
            if guessed_format is None:
                _unsupported_format(archive_format)
            archive_format = guessed_format

        func = locals().get(&quot;_list_&quot; + archive_format)
        if not hasattr(func, &quot;__call__&quot;):
            _unsupported_format(archive_format)

        args = (options,) if archive_format == &quot;tar&quot; else ()
        try:
            dirs, files, links = func(name, cached, *args)
        except OSError as exc:
            raise CommandExecutionError(
                &quot;Failed to list contents of {}: {}&quot;.format(name, exc.__str__())
            )
        except CommandExecutionError as exc:
            raise
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                &quot;Uncaught exception '{}' when listing contents of {}&quot;.format(exc, name)
            )

        if clean:
            try:
                os.remove(cached)
                log.debug(&quot;Cleaned cached archive %s&quot;, cached)
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    log.warning(
                        &quot;Failed to clean cached archive %s: %s&quot;, cached, exc.__str__()
                    )

        if strip_components:
            for item in (dirs, files, links):
                for index, path in enumerate(item):
                    try:
                        # Strip off the specified number of directory
                        # boundaries, and grab what comes after the last
                        # stripped path separator.
                        item[index] = item[index].split(os.sep, strip_components)[
                            strip_components
                        ]
                    except IndexError:
                        # Path is excluded by strip_components because it is not
                        # deep enough. Set this to an empty string so it can
                        # be removed in the generator expression below.
                        item[index] = &quot;&quot;

                # Remove all paths which were excluded
                item[:] = (x for x in item if x)
                item.sort()

        if verbose:
            ret = {
                &quot;dirs&quot;: sorted(salt.utils.data.decode_list(dirs)),
                &quot;files&quot;: sorted(salt.utils.data.decode_list(files)),
                &quot;links&quot;: sorted(salt.utils.data.decode_list(links)),
            }
            ret[&quot;top_level_dirs&quot;] = [x for x in ret[&quot;dirs&quot;] if x.count(&quot;/&quot;) == 1]
            ret[&quot;top_level_files&quot;] = [x for x in ret[&quot;files&quot;] if x.count(&quot;/&quot;) == 0]
            ret[&quot;top_level_links&quot;] = [x for x in ret[&quot;links&quot;] if x.count(&quot;/&quot;) == 0]
        else:
            ret = sorted(dirs + files + links)
        return ret

    except CommandExecutionError as exc:
        # Reraise with cache path in the error so that the user can examine the
        # cached archive for troubleshooting purposes.
        info = exc.info or {}
        info[&quot;archive location&quot;] = cached
        raise CommandExecutionError(exc.error, info=info)


_glob_wildcards = re.compile(&quot;[*?[]&quot;)


def _glob(pathname):
    &quot;&quot;&quot;
    In case ``pathname`` contains glob wildcards, performs expansion and returns
    the possibly empty list of matching pathnames. Otherwise returns a list that
    contains only ``pathname`` itself.
    &quot;&quot;&quot;
    if _glob_wildcards.search(pathname) is None:
        return [pathname]
    else:
        return glob.glob(pathname)


def _expand_sources(sources):
    &quot;&quot;&quot;
    Expands a user-provided specification of source files into a list of paths.
    &quot;&quot;&quot;
    if sources is None:
        return []
    if isinstance(sources, str):
        sources = [x.strip() for x in sources.split(&quot;,&quot;)]
    elif isinstance(sources, (float, int)):
        sources = [str(sources)]
    return [path for source in sources for path in _glob(source)]


@salt.utils.decorators.path.which(&quot;tar&quot;)
def tar(options, tarfile, sources=None, dest=None, cwd=None, template=None, runas=None):
    &quot;&quot;&quot;
    .. note::

        This function has changed for version 0.17.0. In prior versions, the
        ``cwd`` and ``template`` arguments must be specified, with the source
        directories/files coming as a space-separated list at the end of the
        command. Beginning with 0.17.0, ``sources`` must be a comma-separated
        list, and the ``cwd`` and ``template`` arguments are optional.

    Uses the tar command to pack, unpack, etc. tar files


    options
        Options to pass to the tar command

        .. versionchanged:: 2015.8.0

            The mandatory `-` prefixing has been removed.  An options string
            beginning with a `--long-option`, would have uncharacteristically
            needed its first `-` removed under the former scheme.

            Also, tar will parse its options differently if short options are
            used with or without a preceding `-`, so it is better to not
            confuse the user into thinking they're using the non-`-` format,
            when really they are using the with-`-` format.

    tarfile
        The filename of the tar archive to pack/unpack

    sources
        Comma delimited list of files to **pack** into the tarfile. Can also be
        passed as a Python list.

        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument

    dest
        The destination directory into which to **unpack** the tarfile

    cwd : None
        The directory in which the tar command should be executed. If not
        specified, will default to the home directory of the user under which
        the salt minion process is running.

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.tar cjvf /tmp/salt.tar.bz2 {{grains.saltpath}} template=jinja

    CLI Examples:

    .. code-block:: bash

        # Create a tarfile
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1,/tmp/file_2
        # Create a tarfile using globbing (2017.7.0 and later)
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 '/tmp/file_*'
        # Unpack a tarfile
        salt '*' archive.tar xf foo.tar dest=/target/directory
    &quot;&quot;&quot;
    if not options:
        # Catch instances were people pass an empty string for the &quot;options&quot;
        # argument. Someone would have to be really silly to do this, but we
        # should at least let them know of their silliness.
        raise SaltInvocationError(&quot;Tar options can not be empty&quot;)

    cmd = [&quot;tar&quot;]
    if options:
        cmd.extend(options.split())

    cmd.extend([&quot;{}&quot;.format(tarfile)])
    cmd.extend(_expand_sources(sources))
    if dest:
        cmd.extend([&quot;-C&quot;, &quot;{}&quot;.format(dest)])

    return __salt__[&quot;cmd.run&quot;](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
<A NAME="0"></A>

@salt.utils.decorators.path.which(&quot;gzip&quot;)
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match252514-0.html#0',2,'match252514-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>def gzip(sourcefile, template=None, runas=None, options=None):
    &quot;&quot;&quot;
    Uses the gzip command to create gzip files

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.gzip template=jinja /tmp/{{grains.id}}.txt

    runas : None
        The user with which to run the gzip command line

    options : None
        Pass any additional arguments to gzip

        .. versionadded:: 2016.3.4

    CLI Example:

    .. code-block:: bash

        # Create /tmp/sourcefile.txt.gz
        salt '*' archive.gzip /tmp/sourcefile.txt
        salt '*' archive.gzip /tmp/sourcefile.txt options='-9 --verbose'
    &quot;&quot;&quot;
    cmd = [&quot;gzip&quot;]
    if options:
        cmd.append(options)
    cmd.append(&quot;{}&quot;.format(</B></FONT>sourcefile))

    return __salt__[&quot;cmd.run&quot;](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()


@salt.utils.decorators.path.which(&quot;gunzip&quot;)
def gunzip(gzipfile, template=None, runas=None, options=None):
    &quot;&quot;&quot;
    Uses the gunzip command to unpack gzip files

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.gunzip template=jinja /tmp/{{grains.id}}.txt.gz

    runas : None
        The user with which to run the gzip command line

    options : None
        Pass any additional arguments to gzip

        .. versionadded:: 2016.3.4

    CLI Example:

    .. code-block:: bash

        # Create /tmp/sourcefile.txt
        salt '*' archive.gunzip /tmp/sourcefile.txt.gz
        salt '*' archive.gunzip /tmp/sourcefile.txt options='--verbose'
    &quot;&quot;&quot;
    cmd = [&quot;gunzip&quot;]
    if options:
        cmd.append(options)
    cmd.append(&quot;{}&quot;.format(gzipfile))

    return __salt__[&quot;cmd.run&quot;](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()


@salt.utils.decorators.path.which(&quot;zip&quot;)
def cmd_zip(zip_file, sources, template=None, cwd=None, runas=None):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.zip``.

    Uses the ``zip`` command to create zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``zip``.

    .. _`Info-ZIP`: http://www.info-zip.org/

    zip_file
        Path of zip file to be created

    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.

        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.cmd_zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt

    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:

        .. code-block:: bash

            salt '*' archive.cmd_zip /tmp/baz.zip baz.txt cwd=/foo/bar

        .. versionadded:: 2014.7.1

    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.

        .. versionadded:: 2015.5.0

    CLI Example:

    .. code-block:: bash

        salt '*' archive.cmd_zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        # Globbing for sources (2017.7.0 and later)
        salt '*' archive.cmd_zip /tmp/zipfile.zip '/tmp/sourcefile*'
    &quot;&quot;&quot;
    cmd = [&quot;zip&quot;, &quot;-r&quot;]
    cmd.append(&quot;{}&quot;.format(zip_file))
    cmd.extend(_expand_sources(sources))
    return __salt__[&quot;cmd.run&quot;](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()


@salt.utils.decorators.depends(&quot;zipfile&quot;, fallback_function=cmd_zip)
def zip_(zip_file, sources, template=None, cwd=None, runas=None, zip64=False):
    &quot;&quot;&quot;
    Uses the ``zipfile`` Python module to create zip files

    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_zip &lt;salt.modules.archive.cmd_zip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.

    zip_file
        Path of zip file to be created

    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.

        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt

    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:

        .. code-block:: bash

            salt '*' archive.zip /tmp/baz.zip baz.txt cwd=/foo/bar

    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.

    zip64 : False
        Used to enable ZIP64 support, necessary to create archives larger than
        4 GByte in size.
        If true, will create ZIP file with the ZIPp64 extension when the zipfile
        is larger than 2 GB.
        ZIP64 extension is disabled by default in the Python native zip support
        because the default zip and unzip commands on Unix (the InfoZIP utilities)
        don't support these extensions.

    CLI Example:

    .. code-block:: bash

        salt '*' archive.zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        # Globbing for sources (2017.7.0 and later)
        salt '*' archive.zip /tmp/zipfile.zip '/tmp/sourcefile*'
    &quot;&quot;&quot;
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__[&quot;user.info&quot;](runas)
        if not uinfo:
            raise SaltInvocationError(&quot;User '{}' does not exist&quot;.format(runas))

    zip_file, sources = _render_filenames(zip_file, sources, None, template)
    sources = _expand_sources(sources)

    if not cwd:
        for src in sources:
            if not os.path.isabs(src):
                raise SaltInvocationError(&quot;Relative paths require the 'cwd' parameter&quot;)
    else:
        err_msg = &quot;cwd must be absolute&quot;
        try:
            if not os.path.isabs(cwd):
                raise SaltInvocationError(err_msg)
        except AttributeError:
            raise SaltInvocationError(err_msg)

    if runas and (euid != uinfo[&quot;uid&quot;] or egid != uinfo[&quot;gid&quot;]):
        # Change the egid first, as changing it after the euid will fail
        # if the runas user is non-privileged.
        os.setegid(uinfo[&quot;gid&quot;])
        os.seteuid(uinfo[&quot;uid&quot;])

    try:
        exc = None
        archived_files = []
        with contextlib.closing(
            zipfile.ZipFile(zip_file, &quot;w&quot;, zipfile.ZIP_DEFLATED, zip64)
        ) as zfile:
            for src in sources:
                if cwd:
                    src = os.path.join(cwd, src)
                if os.path.exists(src):
                    if os.path.isabs(src):
                        rel_root = &quot;/&quot;
                    else:
                        rel_root = cwd if cwd is not None else &quot;/&quot;
                    if os.path.isdir(src):
                        for dir_name, sub_dirs, files in salt.utils.path.os_walk(src):
                            if cwd and dir_name.startswith(cwd):
                                arc_dir = os.path.relpath(dir_name, cwd)
                            else:
                                arc_dir = os.path.relpath(dir_name, rel_root)
                            if arc_dir:
                                archived_files.append(arc_dir + &quot;/&quot;)
                                zfile.write(dir_name, arc_dir)
                            for filename in files:
                                abs_name = os.path.join(dir_name, filename)
                                arc_name = os.path.join(arc_dir, filename)
                                archived_files.append(arc_name)
                                zfile.write(abs_name, arc_name)
                    else:
                        if cwd and src.startswith(cwd):
                            arc_name = os.path.relpath(src, cwd)
                        else:
                            arc_name = os.path.relpath(src, rel_root)
                        archived_files.append(arc_name)
                        zfile.write(src, arc_name)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    finally:
        # Restore the euid/egid
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        if exc is not None:
            # Wait to raise the exception until euid/egid are restored to avoid
            # permission errors in writing to minion log.
            if exc == zipfile.LargeZipFile:
                raise CommandExecutionError(
                    &quot;Resulting zip file too large, would require ZIP64 support&quot;
                    &quot;which has not been enabled. Rerun command with zip64=True&quot;
                )
            else:
                raise CommandExecutionError(
                    &quot;Exception encountered creating zipfile: {}&quot;.format(exc)
                )

    return archived_files


@salt.utils.decorators.path.which(&quot;unzip&quot;)
def cmd_unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.unzip``.

    Uses the ``unzip`` command to unpack zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``unzip``.

    .. _`Info-ZIP`: http://www.info-zip.org/

    zip_file
        Path of zip file to be unpacked

    dest
        The destination directory into which the file should be unpacked

    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.cmd_unzip template=jinja /tmp/zipfile.zip '/tmp/{{grains.id}}' excludes=file_1,file_2

    options
        Optional when using ``zip`` archives, ignored when usign other archives
        files. This is mostly used to overwrite existing files with ``o``.
        This options are only used when ``unzip`` binary is used.

        .. versionadded:: 2016.3.1

    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.

        .. versionadded:: 2015.5.0

    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100

    password
        Password to use with password protected zip files

        .. note::
            This is not considered secure. It is recommended to instead use
            :py:func:`archive.unzip &lt;salt.modules.archive.unzip&gt;` for
            password-protected ZIP files. If a password is used here, then the
            unzip command run to extract the ZIP file will not show up in the
            minion log like most shell commands Salt runs do. However, the
            password will still be present in the events logged to the minion
            log at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.

        .. versionadded:: 2016.11.0

    CLI Example:

    .. code-block:: bash

        salt '*' archive.cmd_unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2
    &quot;&quot;&quot;
    if isinstance(excludes, str):
        excludes = [x.strip() for x in excludes.split(&quot;,&quot;)]
    elif isinstance(excludes, (float, int)):
        excludes = [str(excludes)]

    cmd = [&quot;unzip&quot;]
    if password:
        cmd.extend([&quot;-P&quot;, password])
    if options:
        cmd.extend(shlex.split(options))
    cmd.extend([&quot;{}&quot;.format(zip_file), &quot;-d&quot;, &quot;{}&quot;.format(dest)])

    if excludes is not None:
        cmd.append(&quot;-x&quot;)
        cmd.extend(excludes)

    result = __salt__[&quot;cmd.run_all&quot;](
        cmd,
        template=template,
        runas=runas,
        python_shell=False,
        redirect_stderr=True,
        output_loglevel=&quot;quiet&quot; if password else &quot;debug&quot;,
    )

    if result[&quot;retcode&quot;] != 0:
        raise CommandExecutionError(result[&quot;stdout&quot;])

    return _trim_files(result[&quot;stdout&quot;].splitlines(), trim_output)


def unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
    extract_perms=True,
):
    &quot;&quot;&quot;
    Uses the ``zipfile`` Python module to unpack zip files

    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_unzip &lt;salt.modules.archive.cmd_unzip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.

    zip_file
        Path of zip file to be unpacked

    dest
        The destination directory into which the file should be unpacked

    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.

    options
        This options are only used when ``unzip`` binary is used. In this
        function is ignored.

        .. versionadded:: 2016.3.1

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.unzip template=jinja /tmp/zipfile.zip /tmp/{{grains.id}}/ excludes=file_1,file_2

    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.

    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100

    CLI Example:

    .. code-block:: bash

        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2

    password
        Password to use with password protected zip files

        .. note::
            The password will be present in the events logged to the minion log
            file at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.

        .. versionadded:: 2016.3.0

    extract_perms : True
        The Python zipfile_ module does not extract file/directory attributes
        by default. When this argument is set to ``True``, Salt will attempt to
        apply the file permission attributes to the extracted files/folders.

        On Windows, only the read-only flag will be extracted as set within the
        zip file, other attributes (i.e. user/group permissions) are ignored.

        Set this argument to ``False`` to disable this behavior.

        .. versionadded:: 2016.11.0

    .. _zipfile: https://docs.python.org/2/library/zipfile.html

    CLI Example:

    .. code-block:: bash

        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ password='BadPassword'
    &quot;&quot;&quot;
    if not excludes:
        excludes = []
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__[&quot;user.info&quot;](runas)
        if not uinfo:
            raise SaltInvocationError(&quot;User '{}' does not exist&quot;.format(runas))

    zip_file, dest = _render_filenames(zip_file, dest, None, template)

    if runas and (euid != uinfo[&quot;uid&quot;] or egid != uinfo[&quot;gid&quot;]):
        # Change the egid first, as changing it after the euid will fail
        # if the runas user is non-privileged.
        os.setegid(uinfo[&quot;gid&quot;])
        os.seteuid(uinfo[&quot;uid&quot;])

    try:
        # Define cleaned_files here so that an exception will not prevent this
        # variable from being defined and cause a NameError in the return
        # statement at the end of the function.
        cleaned_files = []
        with contextlib.closing(zipfile.ZipFile(zip_file, &quot;r&quot;)) as zfile:
            files = zfile.namelist()

            if isinstance(excludes, str):
                excludes = [x.strip() for x in excludes.split(&quot;,&quot;)]
            elif isinstance(excludes, (float, int)):
                excludes = [str(excludes)]

            cleaned_files.extend([x for x in files if x not in excludes])
            for target in cleaned_files:
                if target not in excludes:
                    if salt.utils.platform.is_windows() is False:
                        info = zfile.getinfo(target)
                        # Check if zipped file is a symbolic link
                        if stat.S_ISLNK(info.external_attr &gt;&gt; 16):
                            source = zfile.read(target)
                            os.symlink(source, os.path.join(dest, target))
                            continue
                    zfile.extract(target, dest, password)
                    if extract_perms:
                        if not salt.utils.platform.is_windows():
                            perm = zfile.getinfo(target).external_attr &gt;&gt; 16
                            if perm == 0:
                                umask_ = salt.utils.files.get_umask()
                                if target.endswith(&quot;/&quot;):
                                    perm = 0o777 &amp; ~umask_
                                else:
                                    perm = 0o666 &amp; ~umask_
                            os.chmod(os.path.join(dest, target), perm)
                        else:
                            win32_attr = zfile.getinfo(target).external_attr &amp; 0xFF
                            win32file.SetFileAttributes(
                                os.path.join(dest, target), win32_attr
                            )
    except Exception as exc:  # pylint: disable=broad-except
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        # Wait to raise the exception until euid/egid are restored to avoid
        # permission errors in writing to minion log.
        raise CommandExecutionError(
            &quot;Exception encountered unpacking zipfile: {}&quot;.format(exc)
        )
    finally:
        # Restore the euid/egid
        if runas:
            os.seteuid(euid)
            os.setegid(egid)

    return _trim_files(cleaned_files, trim_output)


def is_encrypted(name, clean=False, saltenv=&quot;base&quot;, source_hash=None, use_etag=False):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0
    .. versionchanged:: 3005

    Returns ``True`` if the zip archive is password-protected, ``False`` if
    not. If the specified file is not a ZIP archive, an error will be raised.

    name
        The path / URL of the archive to check.

    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.

        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.

    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.

    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.

        .. versionadded:: 2018.3.0

    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.

        .. versionadded:: 3005

    CLI Examples:

    .. code-block:: bash

            salt '*' archive.is_encrypted /path/to/myfile.zip
            salt '*' archive.is_encrypted salt://foo.zip
            salt '*' archive.is_encrypted salt://foo.zip saltenv=dev
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip clean=True
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.is_encrypted ftp://10.1.2.3/foo.zip
    &quot;&quot;&quot;
    cached = __salt__[&quot;cp.cache_file&quot;](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError(&quot;Failed to cache {}&quot;.format(name))

    archive_info = {&quot;archive location&quot;: cached}
    try:
        with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
            zip_archive.testzip()
    except RuntimeError:
        ret = True
    except zipfile.BadZipfile:
        raise CommandExecutionError(
            &quot;{} is not a ZIP file&quot;.format(name), info=archive_info
        )
    except Exception as exc:  # pylint: disable=broad-except
        raise CommandExecutionError(exc.__str__(), info=archive_info)
    else:
        ret = False

    if clean:
        try:
            os.remove(cached)
            log.debug(&quot;Cleaned cached archive %s&quot;, cached)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                log.warning(
                    &quot;Failed to clean cached archive %s: %s&quot;, cached, exc.__str__()
                )
    return ret


@salt.utils.decorators.path.which(&quot;rar&quot;)
def rar(rarfile, sources, template=None, cwd=None, runas=None):
    &quot;&quot;&quot;
    Uses `rar for Linux`_ to create rar files

    .. _`rar for Linux`: http://www.rarlab.com/

    rarfile
        Path of rar file to be created

    sources
        Comma-separated list of sources to include in the rar file. Sources can
        also be passed in a Python list.

        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument

    cwd : None
        Run the rar command from the specified directory. Use this argument
        along with relative file paths to create rar files which do not
        contain the leading directories. If not specified, this will default
        to the home directory of the user under which the salt minion process
        is running.

        .. versionadded:: 2014.7.1

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.rar template=jinja /tmp/rarfile.rar '/tmp/sourcefile1,/tmp/{{grains.id}}.txt'

    CLI Example:

    .. code-block:: bash

        salt '*' archive.rar /tmp/rarfile.rar /tmp/sourcefile1,/tmp/sourcefile2
        # Globbing for sources (2017.7.0 and later)
        salt '*' archive.rar /tmp/rarfile.rar '/tmp/sourcefile*'
    &quot;&quot;&quot;
    cmd = [&quot;rar&quot;, &quot;a&quot;, &quot;-idp&quot;, &quot;{}&quot;.format(rarfile)]
    cmd.extend(_expand_sources(sources))
    return __salt__[&quot;cmd.run&quot;](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()


@salt.utils.decorators.path.which_bin((&quot;unrar&quot;, &quot;rar&quot;))
def unrar(rarfile, dest, excludes=None, template=None, runas=None, trim_output=False):
    &quot;&quot;&quot;
    Uses `rar for Linux`_ to unpack rar files

    .. _`rar for Linux`: http://www.rarlab.com/

    rarfile
        Name of rar file to be unpacked

    dest
        The destination directory into which to **unpack** the rar file

    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:

        .. code-block:: bash

            salt '*' archive.unrar template=jinja /tmp/rarfile.rar /tmp/{{grains.id}}/ excludes=file_1,file_2

    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100

    CLI Example:

    .. code-block:: bash

        salt '*' archive.unrar /tmp/rarfile.rar /home/strongbad/ excludes=file_1,file_2

    &quot;&quot;&quot;
    if isinstance(excludes, str):
        excludes = [entry.strip() for entry in excludes.split(&quot;,&quot;)]

    cmd = [
        salt.utils.path.which_bin((&quot;unrar&quot;, &quot;rar&quot;)),
        &quot;x&quot;,
        &quot;-idp&quot;,
        &quot;{}&quot;.format(rarfile),
    ]
    if excludes is not None:
        for exclude in excludes:
            cmd.extend([&quot;-x&quot;, &quot;{}&quot;.format(exclude)])
    cmd.append(&quot;{}&quot;.format(dest))
    files = __salt__[&quot;cmd.run&quot;](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()

    return _trim_files(files, trim_output)


def _render_filenames(filenames, zip_file, saltenv, template):
    &quot;&quot;&quot;
    Process markup in the :param:`filenames` and :param:`zipfile` variables (NOT the
    files under the paths they ultimately point to) according to the markup
    format provided by :param:`template`.
    &quot;&quot;&quot;
    if not template:
        return (filenames, zip_file)

    # render the path as a template using path_template_engine as the engine
    if template not in salt.utils.templates.TEMPLATE_REGISTRY:
        raise CommandExecutionError(
            &quot;Attempted to render file paths with unavailable engine {}&quot;.format(template)
        )

    kwargs = {}
    kwargs[&quot;salt&quot;] = __salt__
    kwargs[&quot;pillar&quot;] = __pillar__
    kwargs[&quot;grains&quot;] = __grains__
    kwargs[&quot;opts&quot;] = __opts__
    kwargs[&quot;saltenv&quot;] = saltenv

    def _render(contents):
        &quot;&quot;&quot;
        Render :param:`contents` into a literal pathname by writing it to a
        temp file, rendering that file, and returning the result.
        &quot;&quot;&quot;
        # write out path to temp file
        tmp_path_fn = salt.utils.files.mkstemp()
        with salt.utils.files.fopen(tmp_path_fn, &quot;w+&quot;) as fp_:
            fp_.write(salt.utils.stringutils.to_str(contents))
        data = salt.utils.templates.TEMPLATE_REGISTRY[template](
            tmp_path_fn, to_str=True, **kwargs
        )
        salt.utils.files.safe_rm(tmp_path_fn)
        if not data[&quot;result&quot;]:
            # Failed to render the template
            raise CommandExecutionError(
                &quot;Failed to render file path with error: {}&quot;.format(data[&quot;data&quot;])
            )
        else:
            return data[&quot;data&quot;]

    filenames = _render(filenames)
    zip_file = _render(zip_file)
    return (filenames, zip_file)


def _trim_files(files, trim_output):
    &quot;&quot;&quot;
    Trim the file list for output.
    &quot;&quot;&quot;
    count = 100
    if not isinstance(trim_output, bool):
        count = trim_output

    if (
        not (isinstance(trim_output, bool) and trim_output is False)
        and len(files) &gt; count
    ):
        files = files[:count]
        files.append(&quot;List trimmed after {} files.&quot;.format(count))

    return files
</PRE>
</div>
  </div>
</body>
</html>
