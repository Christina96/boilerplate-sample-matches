<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zpool_1.py &amp; archive_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zpool_1.py &amp; archive_1.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zpool_1.py (1.0942761%)<th>archive_1.py (1.0433387%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1055-1097)<td><a href="#" name="0">(557-588)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zpool_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Module for running ZFS zpool command
:codeauthor:    Nitin Madhok &lt;nmadhok@g.clemson.edu&gt;, Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maintainer:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maturity:      new
:depends:       salt.utils.zfs
:platform:      illumos,freebsd,linux
.. versionchanged:: 2018.3.1
  Big refactor to remove duplicate code, better type conversions and improved
  consistency in output.
"""
import logging
import os
import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.path
from salt.utils.odict import OrderedDict
log = logging.getLogger(__name__)
__virtualname__ = "zpool"
__func_alias__ = {
    "import_": "import",
    "list_": "list",
}
def __virtual__():
    """
    Only load when the platform has zfs support
    """
    if __grains__.get("zfs_support"):
        return __virtualname__
    else:
        return False, "The zpool module cannot be loaded: zfs not supported"
def _clean_vdev_config(config):
    """
    Return a simple vdev tree from zpool.status' config section
    """
    cln_config = OrderedDict()
    for label, sub_config in config.items():
        if label not in ["state", "read", "write", "cksum"]:
            sub_config = _clean_vdev_config(sub_config)
            if sub_config and isinstance(cln_config, list):
                cln_config.append(OrderedDict([(label, sub_config)]))
            elif sub_config and isinstance(cln_config, OrderedDict):
                cln_config[label] = sub_config
            elif isinstance(cln_config, list):
                cln_config.append(label)
            elif isinstance(cln_config, OrderedDict):
                new_config = []
                for old_label, old_config in cln_config.items():
                    new_config.append(OrderedDict([(old_label, old_config)]))
                new_config.append(label)
                cln_config = new_config
            else:
                cln_config = [label]
    return cln_config
def healthy():
    """
    Check if all zpools are healthy
    .. versionadded:: 2016.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.healthy
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"]("status", flags=["-x"]),
        python_shell=False,
    )
    return res["stdout"] == "all pools are healthy"
def status(zpool=None):
    """
    Return the status of the named zpool
    zpool : string
        optional name of storage pool
    .. versionadded:: 2016.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.status myzpool
    """
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"]("status", target=zpool),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    current_pool = None
    current_prop = None
    for zpd in res["stdout"].splitlines():
        if zpd.strip() == "":
            continue
        if ":" in zpd and zpd[0] != "\t":
            prop = zpd.split(":")[0].strip()
            value = ":".join(zpd.split(":")[1:]).strip()
            if prop == "pool" and current_pool != value:
                current_pool = value
                ret[current_pool] = OrderedDict()
            if prop != "pool":
                ret[current_pool][prop] = value
            current_prop = prop
        else:
            ret[current_pool][current_prop] = "{}\n{}".format(
                ret[current_pool][current_prop], zpd
            )
    for pool in ret:
        if "config" not in ret[pool]:
            continue
        header = None
        root_vdev = None
        vdev = None
        dev = None
        rdev = None
        config = ret[pool]["config"]
        config_data = OrderedDict()
        for line in config.splitlines():
            if not header:
                header = line.strip().lower()
                header = [x for x in header.split(" ") if x not in [""]]
                continue
            if line[0] == "\t":
                line = line[1:]
            stat_data = OrderedDict(
                list(
                    zip(
                        header,
                        [x for x in line.strip().split(" ") if x not in [""]],
                    )
                )
            )
            stat_data = __utils__["zfs.from_auto_dict"](stat_data)
            if line.startswith(" " * 6):
                rdev = stat_data["name"]
                config_data[root_vdev][vdev][dev][rdev] = stat_data
            elif line.startswith(" " * 4):
                rdev = None
                dev = stat_data["name"]
                config_data[root_vdev][vdev][dev] = stat_data
            elif line.startswith(" " * 2):
                rdev = dev = None
                vdev = stat_data["name"]
                config_data[root_vdev][vdev] = stat_data
            else:
                rdev = dev = vdev = None
                root_vdev = stat_data["name"]
                config_data[root_vdev] = stat_data
            del stat_data["name"]
        ret[pool]["config"] = config_data
    return ret
def iostat(zpool=None, sample_time=5, parsable=True):
    """
    Display I/O statistics for the given pools
    zpool : string
        optional name of storage pool
    sample_time : int
        seconds to capture data before output
        default a sample of 5 seconds is used
    parsable : boolean
        display data in pythonc values (True, False, Bytes,...)
    .. versionadded:: 2016.3.0
    .. versionchanged:: 2018.3.1
        Added ```parsable``` parameter that defaults to True
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.iostat myzpool
    """
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="iostat", flags=["-v"], target=[zpool, sample_time, 2]
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    header = [
        "name",
        "capacity-alloc",
        "capacity-free",
        "operations-read",
        "operations-write",
        "bandwidth-read",
        "bandwidth-write",
    ]
    root_vdev = None
    vdev = None
    dev = None
    current_data = OrderedDict()
    for line in res["stdout"].splitlines():
        if line.strip() == "" or line.strip().split()[-1] in ["write", "bandwidth"]:
            continue
        if line.startswith("-") and line.endswith("-"):
            ret.update(current_data)
            current_data = OrderedDict()
            continue
        io_data = OrderedDict(
            list(
                zip(
                    header,
                    [x for x in line.strip().split(" ") if x not in [""]],
                )
            )
        )
        if parsable:
            io_data = __utils__["zfs.from_auto_dict"](io_data)
        else:
            io_data = __utils__["zfs.to_auto_dict"](io_data)
        if line.startswith(" " * 4):
            dev = io_data["name"]
            current_data[root_vdev][vdev][dev] = io_data
        elif line.startswith(" " * 2):
            dev = None
            vdev = io_data["name"]
            current_data[root_vdev][vdev] = io_data
        else:
            dev = vdev = None
            root_vdev = io_data["name"]
            current_data[root_vdev] = io_data
        del io_data["name"]
    return ret
def list_(properties="size,alloc,free,cap,frag,health", zpool=None, parsable=True):
    """
    .. versionadded:: 2015.5.0
    Return information about (all) storage pools
    zpool : string
        optional name of storage pool
    properties : string
        comma-separated list of properties to list
    parsable : boolean
        display numbers in parsable (exact) values
        .. versionadded:: 2018.3.0
    .. note::
        The ``name`` property will always be included, while the ``frag``
        property will get removed if not available
    zpool : string
        optional zpool
    .. note::
        Multiple storage pool can be provided as a space separated list
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.list
        salt '*' zpool.list zpool=tank
        salt '*' zpool.list 'size,free'
        salt '*' zpool.list 'size,free' tank
    """
    ret = OrderedDict()
    if not isinstance(properties, list):
        properties = properties.split(",")
    while "name" in properties:
        properties.remove("name")
    properties.insert(0, "name")
    if not __utils__["zfs.has_feature_flags"]():
        while "frag" in properties:
            properties.remove("frag")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="list",
            flags=["-H"],
            opts={"-o": ",".join(properties)},
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    for line in res["stdout"].splitlines():
        zpool_data = OrderedDict(
            list(
                zip(
                    properties,
                    line.strip().split("\t"),
                )
            )
        )
        if parsable:
            zpool_data = __utils__["zfs.from_auto_dict"](zpool_data)
        else:
            zpool_data = __utils__["zfs.to_auto_dict"](zpool_data)
        ret[zpool_data["name"]] = zpool_data
        del ret[zpool_data["name"]]["name"]
    return ret
def get(zpool, prop=None, show_source=False, parsable=True):
    """
    .. versionadded:: 2016.3.0
    Retrieves the given list of properties
    zpool : string
        Name of storage pool
    prop : string
        Optional name of property to retrieve
    show_source : boolean
        Show source of property
    parsable : boolean
        Display numbers in parsable (exact) values
        .. versionadded:: 2018.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.get myzpool
    """
    ret = OrderedDict()
    value_properties = ["name", "property", "value", "source"]
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="get",
            flags=["-H"],
            property_name=prop if prop else "all",
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    for line in res["stdout"].splitlines():
        prop_data = OrderedDict(
            list(
                zip(
                    value_properties,
                    [x for x in line.strip().split("\t") if x not in [""]],
                )
            )
        )
        del prop_data["name"]
        if parsable:
            prop_data["value"] = __utils__["zfs.from_auto"](
                prop_data["property"], prop_data["value"]
            )
        else:
            prop_data["value"] = __utils__["zfs.to_auto"](
                prop_data["property"], prop_data["value"]
            )
        if show_source:
            ret[prop_data["property"]] = prop_data
            del ret[prop_data["property"]]["property"]
        else:
            ret[prop_data["property"]] = prop_data["value"]
    return ret
def set(zpool, prop, value):
    """
    Sets the given property on the specified pool
    zpool : string
        Name of storage pool
    prop : string
        Name of property to set
    value : string
        Value to set for the specified property
    .. versionadded:: 2016.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.set myzpool readonly yes
    """
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="set",
            property_name=prop,
            property_value=value,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "set")
def exists(zpool):
    """
    Check if a ZFS storage pool is active
    zpool : string
        Name of storage pool
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.exists myzpool
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="list",
            target=zpool,
        ),
        python_shell=False,
        ignore_retcode=True,
    )
    return res["retcode"] == 0
def destroy(zpool, force=False):
    """
    Destroys a storage pool
    zpool : string
        Name of storage pool
    force : boolean
        Force destroy of pool
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.destroy myzpool
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="destroy",
            flags=["-f"] if force else None,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "destroyed")
def scrub(zpool, stop=False, pause=False):
    """
    Scrub a storage pool
    zpool : string
        Name of storage pool
    stop : boolean
        If ``True``, cancel ongoing scrub
    pause : boolean
        If ``True``, pause ongoing scrub
        .. versionadded:: 2018.3.0
        .. note::
            Pause is only available on recent versions of ZFS.
            If both ``pause`` and ``stop`` are ``True``, then ``stop`` will
            win.
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.scrub myzpool
    """
    if stop:
        action = ["-s"]
    elif pause:
        action = ["-p"]
    else:
        action = None
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="scrub",
            flags=action,
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res, "scrubbing")
    ret = OrderedDict()
    if stop or pause:
        ret["scrubbing"] = False
    else:
        ret["scrubbing"] = True
    return ret
def create(zpool, *vdevs, **kwargs):
    """
    .. versionadded:: 2015.5.0
    Create a simple zpool, a mirrored zpool, a zpool having nested VDEVs, a hybrid zpool with cache, spare and log drives or a zpool with RAIDZ-1, RAIDZ-2 or RAIDZ-3
    zpool : string
        Name of storage pool
    vdevs : string
        One or move devices
    force : boolean
        Forces use of vdevs, even if they appear in use or specify a
        conflicting replication level.
    mountpoint : string
        Sets the mount point for the root dataset
    altroot : string
        Equivalent to "-o cachefile=none,altroot=root"
    properties : dict
        Additional pool properties
    filesystem_properties : dict
        Additional filesystem properties
    createboot : boolean
        create a boot partition
        .. versionadded:: 2018.3.0
        .. warning:
          This is only available on illumos and Solaris
    CLI Examples:
    .. code-block:: bash
        salt '*' zpool.create myzpool /path/to/vdev1 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 /path/to/vdev2 [...] [force=True|False]
        salt '*' zpool.create myzpool raidz1 /path/to/vdev1 /path/to/vdev2 raidz2 /path/to/vdev3 /path/to/vdev4 /path/to/vdev5 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 [...] mirror /path/to/vdev2 /path/to/vdev3 [...] [force=True|False]
        salt '*' zpool.create myhybridzpool mirror /tmp/file1 [...] log mirror /path/to/vdev1 [...] cache /path/to/vdev2 [...] spare /path/to/vdev3 [...] [force=True|False]
    .. note::
        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called "properties" and specifying
        the properties with their respective values in the form of a python
        dictionary:
        .. code-block:: text
            properties="{'property1': 'value1', 'property2': 'value2'}"
        Filesystem properties can be specified at the time of creation of the
        pool by passing an additional argument called "filesystem_properties"
        and specifying the properties with their respective values in the form
        of a python dictionary:
        .. code-block:: text
            filesystem_properties="{'property1': 'value1', 'property2': 'value2'}"
        Example:
        .. code-block:: bash
            salt '*' zpool.create myzpool /path/to/vdev1 [...] properties="{'property1': 'value1', 'property2': 'value2'}"
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.create myzpool /path/to/vdev1 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 /path/to/vdev2 [...] [force=True|False]
        salt '*' zpool.create myzpool raidz1 /path/to/vdev1 /path/to/vdev2 raidz2 /path/to/vdev3 /path/to/vdev4 /path/to/vdev5 [...] [force=True|False]
        salt '*' zpool.create myzpool mirror /path/to/vdev1 [...] mirror /path/to/vdev2 /path/to/vdev3 [...] [force=True|False]
        salt '*' zpool.create myhybridzpool mirror /tmp/file1 [...] log mirror /path/to/vdev1 [...] cache /path/to/vdev2 [...] spare /path/to/vdev3 [...] [force=True|False]
    """
    flags = []
    opts = {}
    target = []
    pool_properties = kwargs.get("properties", {})
    filesystem_properties = kwargs.get("filesystem_properties", {})
    if kwargs.get("force", False):
        flags.append("-f")
    if kwargs.get("createboot", False) or "bootsize" in pool_properties:
        flags.append("-B")
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    if kwargs.get("mountpoint", False):
        opts["-m"] = kwargs.get("mountpoint")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="create",
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            filesystem_properties=filesystem_properties,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "created")
    if ret["created"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def add(zpool, *vdevs, **kwargs):
    """
    Add the specified vdev\'s to the given storage pool
    zpool : string
        Name of storage pool
    vdevs : string
        One or more devices
    force : boolean
        Forces use of device
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.add myzpool /path/to/vdev1 /path/to/vdev2 [...]
    """
    flags = []
    target = []
    if kwargs.get("force", False):
        flags.append("-f")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="add",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "added")
    if ret["added"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def attach(zpool, device, new_device, force=False):
    """
    Attach specified device to zpool
    zpool : string
        Name of storage pool
    device : string
        Existing device name too
    new_device : string
        New device name (to be attached to ``device``)
    force : boolean
        Forces use of device
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.attach myzpool /path/to/vdev1 /path/to/vdev2 [...]
    """
    flags = []
    target = []
    if force:
        flags.append("-f")
    target.append(zpool)
    target.append(device)
    target.append(new_device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="attach",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "attached")
    if ret["attached"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def detach(zpool, device):
    """
    Detach specified device to zpool
    zpool : string
        Name of storage pool
    device : string
        Device to detach
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.detach myzpool /path/to/vdev1
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="detach",
            target=[zpool, device],
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "detatched")
    if ret["detatched"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def split(zpool, newzpool, **kwargs):
    """
    .. versionadded:: 2018.3.0
    Splits devices off pool creating newpool.
    .. note::
        All vdevs in pool must be mirrors.  At the time of the split,
        ``newzpool`` will be a replica of ``zpool``.
        After splitting, do not forget to import the new pool!
    zpool : string
        Name of storage pool
    newzpool : string
        Name of new storage pool
    mountpoint : string
        Sets the mount point for the root dataset
    altroot : string
        Sets altroot for newzpool
    properties : dict
        Additional pool properties for newzpool
    CLI Examples:
    .. code-block:: bash
        salt '*' zpool.split datamirror databackup
        salt '*' zpool.split datamirror databackup altroot=/backup
    .. note::
        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called "properties" and specifying
        the properties with their respective values in the form of a python
        dictionary:
        .. code-block:: text
            properties="{'property1': 'value1', 'property2': 'value2'}"
        Example:
        .. code-block:: bash
            salt '*' zpool.split datamirror databackup properties="{'readonly': 'on'}"
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.split datamirror databackup
        salt '*' zpool.split datamirror databackup altroot=/backup
    """
    opts = {}
    pool_properties = kwargs.get("properties", {})
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="split",
            opts=opts,
            pool_properties=pool_properties,
            target=[zpool, newzpool],
        ),
        python_shell=False,
    )
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def replace(zpool, old_device, new_device=None, force=False):
    """
    Replaces ``old_device`` with ``new_device``
    .. note::
        This is equivalent to attaching ``new_device``,
        waiting for it to resilver, and then detaching ``old_device``.
        The size of ``new_device`` must be greater than or equal to the minimum
        size of all the devices in a mirror or raidz configuration.
    zpool : string
        Name of storage pool
    old_device : string
        Old device to replace
    new_device : string
        Optional new device
    force : boolean
        Forces use of new_device, even if its appears to be in use.
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.replace myzpool /path/to/vdev1 /path/to/vdev2
    """
    flags = []
    target = []
    if force:
        flags.append("-f")
    target.append(zpool)
    target.append(</b></font>old_device)
    if new_device:
        target.append(new_device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="replace",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "replaced")
    if ret["replaced"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
@salt.utils.decorators.path.which("mkfile")
def create_file_vdev(size, *vdevs):
    """
    Creates file based virtual devices for a zpool
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.create_file_vdev 7G /path/to/vdev1 [/path/to/vdev2] [...]
    .. note::
        Depending on file size, the above command may take a while to return.
    """
    ret = OrderedDict()
    err = OrderedDict()
    _mkfile_cmd = salt.utils.path.which("mkfile")
    for vdev in vdevs:
        if os.path.isfile(vdev):
            ret[vdev] = "existed"
        else:
            res = __salt__["cmd.run_all"](
                "{mkfile} {size} {vdev}".format(
                    mkfile=_mkfile_cmd,
                    size=size,
                    vdev=vdev,
                ),
                python_shell=False,
            )
            if res["retcode"] != 0:
                if "stderr" in res and ":" in res["stderr"]:
                    ret[vdev] = "failed"
                    err[vdev] = ":".join(res["stderr"].strip().split(":")[1:])
            else:
                ret[vdev] = "created"
    if err:
        ret["error"] = err
    return ret
def export(*pools, **kwargs):
    """
    .. versionadded:: 2015.5.0
    Export storage pools
    pools : string
        One or more storage pools to export
    force : boolean
        Force export of storage pools
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.export myzpool ... [force=True|False]
        salt '*' zpool.export myzpool2 myzpool2 ... [force=True|False]
    """
    flags = []
    targets = []
    if kwargs.get("force", False):
        flags.append("-f")
    targets = list(pools)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="export",
            flags=flags,
            target=targets,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "exported")
def import_(zpool=None, new_name=None, **kwargs):
    """
    .. versionadded:: 2015.5.0
    Import storage pools or list pools available for import
    zpool : string
        Optional name of storage pool
    new_name : string
        Optional new name for the storage pool
    mntopts : string
        Comma-separated list of mount options to use when mounting datasets
        within the pool.
    force : boolean
        Forces import, even if the pool appears to be potentially active.
    altroot : string
        Equivalent to "-o cachefile=none,altroot=root"
    dir : string
        Searches for devices or files in dir, multiple dirs can be specified as
        follows: ``dir="dir1,dir2"``
    no_mount : boolean
        Import the pool without mounting any file systems.
    only_destroyed : boolean
        Imports destroyed pools only. This also sets ``force=True``.
    recovery : bool|str
        false: do not try to recovery broken pools
        true: try to recovery the pool by rolling back the latest transactions
        test: check if a pool can be recovered, but don't import it
        nolog: allow import without log device, recent transactions might be lost
        .. note::
            If feature flags are not support this forced to the default of 'false'
        .. warning::
            When recovery is set to 'test' the result will be have imported set to True if the pool
            can be imported. The pool might also be imported if the pool was not broken to begin with.
    properties : dict
        Additional pool properties
    .. note::
        Zpool properties can be specified at the time of creation of the pool
        by passing an additional argument called "properties" and specifying
        the properties with their respective values in the form of a python
        dictionary:
        .. code-block:: text
            properties="{'property1': 'value1', 'property2': 'value2'}"
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.import [force=True|False]
        salt '*' zpool.import myzpool [mynewzpool] [force=True|False]
        salt '*' zpool.import myzpool dir='/tmp'
    """
    flags = []
    opts = {}
    target = []
    pool_properties = kwargs.get("properties", {})
    if kwargs.get("force", False) or kwargs.get("only_destroyed", False):
        flags.append("-f")
    if kwargs.get("only_destroyed", False):
        flags.append("-D")
    if kwargs.get("no_mount", False):
        flags.append("-N")
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    if kwargs.get("mntopts", False):
        opts["-o"] = kwargs.get("mntopts")
    if kwargs.get("dir", False):
        opts["-d"] = kwargs.get("dir").split(",")
    if kwargs.get("recovery", False) and __utils__["zfs.has_feature_flags"]():
        recovery = kwargs.get("recovery")
        if recovery in [True, "test"]:
            flags.append("-F")
        if recovery == "test":
            flags.append("-n")
        if recovery == "nolog":
            flags.append("-m")
    if zpool:
        target.append(zpool)
        target.append(new_name)
    else:
        flags.append("-a")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="import",
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "imported")
def online(zpool, *vdevs, **kwargs):
    """
    .. versionadded:: 2015.5.0
    Ensure that the specified devices are online
    zpool : string
        name of storage pool
    vdevs : string
        one or more devices
    expand : boolean
        Expand the device to use all available space.
        .. note::
            If the device is part of a mirror or raidz then all devices must be
            expanded before the new space will become available to the pool.
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.online myzpool /path/to/vdev1 [...]
    """
    flags = []
    target = []
    if kwargs.get("expand", False):
        flags.append("-e")
    target.append(zpool)
    if vdevs:
        target.extend(vdevs)
    flags = []
    target = []
    if kwargs.get("expand", False):
        flags.append("-e")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="online",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "onlined")
def offline(zpool, *vdevs, **kwargs):
    """
    .. versionadded:: 2015.5.0
    Ensure that the specified devices are offline
    .. warning::
        By default, the ``OFFLINE`` state is persistent. The device remains
        offline when the system is rebooted. To temporarily take a device
        offline, use ``temporary=True``.
    zpool : string
        name of storage pool
    vdevs : string
        One or more devices
    temporary : boolean
        Enable temporarily offline
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.offline myzpool /path/to/vdev1 [...] [temporary=True|False]
    """
    flags = []
    target = []
    if kwargs.get("temporary", False):
        flags.append("-t")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="offline",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "offlined")
def labelclear(device, force=False):
    """
    .. versionadded:: 2018.3.0
    Removes ZFS label information from the specified device
    device : string
        Device name; must not be part of an active pool configuration.
    force : boolean
        Treat exported or foreign devices as inactive
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.labelclear /path/to/dev
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="labelclear",
            flags=["-f"] if force else None,
            target=device,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "labelcleared")
def clear(zpool, device=None):
    """
    Clears device errors in a pool.
    .. warning::
        The device must not be part of an active pool configuration.
    zpool : string
        name of storage pool
    device : string
        (optional) specific device to clear
    .. versionadded:: 2018.3.1
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.clear mypool
        salt '*' zpool.clear mypool /path/to/dev
    """
    target = []
    target.append(zpool)
    target.append(device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="clear",
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "cleared")
def reguid(zpool):
    """
    Generates a new unique identifier for the pool
    .. warning::
        You must ensure that all devices in this pool are online and healthy
        before performing this action.
    zpool : string
        name of storage pool
    .. versionadded:: 2016.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.reguid myzpool
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="reguid",
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "reguided")
def reopen(zpool):
    """
    Reopen all the vdevs associated with the pool
    zpool : string
        name of storage pool
    .. versionadded:: 2016.3.0
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.reopen myzpool
    """
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="reopen",
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "reopened")
def upgrade(zpool=None, version=None):
    """
    .. versionadded:: 2016.3.0
    Enables all supported features on the given pool
    zpool : string
        Optional storage pool, applies to all otherwize
    version : int
        Version to upgrade to, if unspecified upgrade to the highest possible
    .. warning::
        Once this is done, the pool will no longer be accessible on systems that do not
        support feature flags. See zpool-features(5) for details on compatibility with
        systems that support feature flags, but do not support all features enabled on the pool.
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.upgrade myzpool
    """
    flags = []
    opts = {}
    if version:
        opts["-V"] = version
    if not zpool:
        flags.append("-a")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="upgrade",
            flags=flags,
            opts=opts,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "upgraded")
def history(zpool=None, internal=False, verbose=False):
    """
    .. versionadded:: 2016.3.0
    Displays the command history of the specified pools, or all pools if no
    pool is specified
    zpool : string
        Optional storage pool
    internal : boolean
        Toggle display of internally logged ZFS events
    verbose : boolean
        Toggle display of the user name, the hostname, and the zone in which
        the operation was performed
    CLI Example:
    .. code-block:: bash
        salt '*' zpool.upgrade myzpool
    """
    ret = OrderedDict()
    flags = []
    if verbose:
        flags.append("-l")
    if internal:
        flags.append("-i")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="history",
            flags=flags,
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    else:
        pool = "unknown"
        for line in res["stdout"].splitlines():
            if line.startswith("History for"):
                pool = line[13:-2]
                ret[pool] = OrderedDict()
            else:
                if line == "":
                    continue
                log_timestamp = line[0:19]
                log_command = line[20:]
                ret[pool][log_timestamp] = log_command
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
A module to wrap (non-Windows) archive calls
.. versionadded:: 2014.1.0
"""
import contextlib
import copy
import errno
import glob
import logging
import os
import re
import shlex
import stat
import subprocess
import tarfile
import urllib.parse
import zipfile
import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
from salt.exceptions import CommandExecutionError, SaltInvocationError
try:
    import rarfile
    HAS_RARFILE = True
except ImportError:
    HAS_RARFILE = False
if salt.utils.platform.is_windows():
    import win32file
__func_alias__ = {"zip_": "zip", "list_": "list"}
log = logging.getLogger(__name__)
def list_(
    name,
    archive_format=None,
    options=None,
    strip_components=None,
    clean=False,
    verbose=False,
    saltenv="base",
    source_hash=None,
    use_etag=False,
):
    """
    .. versionadded:: 2016.11.0
    .. versionchanged:: 2016.11.2,3005
        The rarfile_ Python module is now supported for listing the contents of
        rar archives. This is necessary on minions with older releases of the
        ``rar`` CLI tool, which do not support listing the contents in a
        parsable format.
    .. _rarfile: https://pypi.python.org/pypi/rarfile
    List the files and directories in an tar, zip, or rar archive.
    .. note::
        This function will only provide results for XZ-compressed archives if
        the xz_ CLI command is available, as Python does not at this time
        natively support XZ compression in its tarfile_ module. Keep in mind
        however that most Linux distros ship with xz_ already installed.
        To check if a given minion has xz_, the following Salt command can be
        run:
        .. code-block:: bash
            salt minion_id cmd.which xz
        If ``None`` is returned, then xz_ is not present and must be installed.
        It is widely available and should be packaged as either ``xz`` or
        ``xz-utils``.
    name
        Path/URL of archive
    archive_format
        Specify the format of the archive (``tar``, ``zip``, or ``rar``). If
        this argument is omitted, the archive format will be guessed based on
        the value of the ``name`` parameter.
    options
        **For tar archives only.** This function will, by default, try to use
        the tarfile_ module from the Python standard library to get a list of
        files/directories. If this method fails, then it will fall back to
        using the shell to decompress the archive to stdout and pipe the
        results to ``tar -tf -`` to produce a list of filenames. XZ-compressed
        archives are already supported automatically, but in the event that the
        tar archive uses a different sort of compression not supported natively
        by tarfile_, this option can be used to specify a command that will
        decompress the archive to stdout. For example:
        .. code-block:: bash
            salt minion_id archive.list /path/to/foo.tar.gz options='gzip --decompress --stdout'
        .. note::
            It is not necessary to manually specify options for gzip'ed
            archives, as gzip compression is natively supported by tarfile_.
    strip_components
        This argument specifies a number of top-level directories to strip from
        the results. This is similar to the paths that would be extracted if
        ``--strip-components`` (or ``--strip``) were used when extracting tar
        archives.
        .. versionadded:: 2016.11.2
    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.
        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.
    verbose : False
        If ``False``, this function will return a list of files/dirs in the
        archive. If ``True``, it will return a dictionary categorizing the
        paths into separate keys containing the directory names, file names,
        and also directories/files present in the top level of the archive.
        .. versionchanged:: 2016.11.2
            This option now includes symlinks in their own list. Before, they
            were included with files.
    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.
    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.
        .. versionadded:: 2018.3.0
    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.
        .. versionadded:: 3005
    .. _tarfile: https://docs.python.org/2/library/tarfile.html
    .. _xz: http://tukaani.org/xz/
    CLI Examples:
    .. code-block:: bash
            salt '*' archive.list /path/to/myfile.tar.gz
            salt '*' archive.list /path/to/myfile.tar.gz strip_components=1
            salt '*' archive.list salt://foo.tar.gz
            salt '*' archive.list https://domain.tld/myfile.zip
            salt '*' archive.list https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.list ftp://10.1.2.3/foo.rar
    """
    def _list_tar(name, cached, decompress_cmd, failhard=False):
        """
        List the contents of a tar archive.
        """
        dirs = []
        files = []
        links = []
        try:
            open_kwargs = (
                {"name": cached}
                if not isinstance(cached, subprocess.Popen)
                else {"fileobj": cached.stdout, "mode": "r|"}
            )
            with contextlib.closing(tarfile.open(**open_kwargs)) as tar_archive:
                for member in tar_archive.getmembers():
                    _member = salt.utils.data.decode(member.name)
                    if member.issym():
                        links.append(_member)
                    elif member.isdir():
                        dirs.append(_member + "/")
                    else:
                        files.append(_member)
            return dirs, files, links
        except tarfile.ReadError:
            if failhard:
                if isinstance(cached, subprocess.Popen):
                    stderr = cached.communicate()[1]
                    if cached.returncode != 0:
                        raise CommandExecutionError(
                            "Failed to decompress {}".format(name),
                            info={"error": stderr},
                        )
            else:
                if not salt.utils.path.which("tar"):
                    raise CommandExecutionError("'tar' command not available")
                if decompress_cmd is not None and isinstance(decompress_cmd, str):
                    try:
                        decompress_cmd = [
                            shlex.quote(x) for x in shlex.split(decompress_cmd)
                        ]
                    except AttributeError:
                        raise CommandExecutionError("Invalid CLI options")
                else:
                    if (
                        salt.utils.path.which("xz")
                        and __salt__["cmd.retcode"](
                            ["xz", "-t", cached],
                            python_shell=False,
                            ignore_retcode=True,
                        )
                        == 0
                    ):
                        decompress_cmd = ["xz", "--decompress", "--stdout"]
                if decompress_cmd:
                    decompressed = subprocess.Popen(
                        decompress_cmd + [shlex.quote(cached)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                    )
                    return _list_tar(name, decompressed, None, True)
        raise CommandExecutionError(
            "Unable to list contents of {}. If this is an XZ-compressed tar "
            "archive, install XZ Utils to enable listing its contents. If it "
            "is compressed using something other than XZ, it may be necessary "
            "to specify CLI options to decompress the archive. See the "
            "documentation for details.".format(name)
        )
    def _list_zip(name, cached):
        """
        List the contents of a zip archive.
        Password-protected ZIP archives can still be listed by zipfile, so
        there is no reason to invoke the unzip command.
        """
        dirs = set()
        files = []
        links = []
        try:
            with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
                for member in zip_archive.infolist():
                    path = member.filename
                    if salt.utils.platform.is_windows():
                        if path.endswith("/"):
                            dirs.add(path)
                        else:
                            files.append(path)
                    else:
                        mode = member.external_attr &gt;&gt; 16
                        if stat.S_ISLNK(mode):
                            links.append(path)
                        elif stat.S_ISDIR(mode):
                            dirs.add(path)
                        else:
                            files.append(path)
                _files = copy.deepcopy(files)
                for path in _files:
                    dirname = "".join(path.rpartition("/")[:2])
                    if dirname:
                        dirs.add(dirname)
                        if dirname in files:
                            files.remove(dirname)
            return list(dirs), files, links
        except zipfile.BadZipfile:
            raise CommandExecutionError("{} is not a ZIP file".format(name))
    def _list_rar(name, cached):
        """
        List the contents of a rar archive.
        """
        dirs = []
        files = []
        if HAS_RARFILE:
            with rarfile.RarFile(cached) as rf:
                for member in rf.infolist():
                    path = member.filename.replace("\\", "/")
                    if member.isdir():
                        dirs.append(path + "/")
                    else:
                        files.append(path)
        else:
            if not salt.utils.path.which("rar"):
                raise CommandExecutionError(
                    "rar command not available, is it installed?"
                )
            output = __salt__["cmd.run"](
                ["rar", "lt", name], python_shell=False, ignore_retcode=False
            )
            matches = re.findall(r"Name:\s*([^\n]+)\s*Type:\s*([^\n]+)", output)
            for path, type_ in matches:
                if type_ == "Directory":
                    dirs.append(path + "/")
                else:
                    files.append(path)
            if not dirs and not files:
                raise CommandExecutionError(
                    "Failed to list {}, is it a rar file? If so, the "
                    "installed version of rar may be too old to list data in "
                    "a parsable format. Installing the rarfile Python module "
                    "may be an easier workaround if newer rar is not readily "
                    "available.".format(name),
                    info={"error": output},
                )
        return dirs, files, []
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    try:
        if strip_components:
            try:
                int(strip_components)
            except ValueError:
                strip_components = -1
            if strip_components &lt;= 0:
                raise CommandExecutionError(
                    "'strip_components' must be a positive integer"
                )
        parsed = urllib.parse.urlparse(name)
        path = parsed.path or parsed.netloc
        def _unsupported_format(archive_format):
            """
            Raise the proper exception message for the given archive format.
            """
            if archive_format is None:
                raise CommandExecutionError(
                    "Unable to guess archive format, please pass an "
                    "'archive_format' argument."
                )
            raise CommandExecutionError(
                "Unsupported archive format '{}'".format(archive_format)
            )
        if not archive_format:
            guessed_format = salt.utils.files.guess_archive_type(path)
            if guessed_format is None:
                _unsupported_format(archive_format)
            archive_format = guessed_format
        func = locals().get("_list_" + archive_format)
        if not hasattr(func, "__call__"):
            _unsupported_format(archive_format)
        args = (options,) if archive_format == "tar" else ()
        try:
            dirs, files, links = func(name, cached, *args)
        except OSError as exc:
            raise CommandExecutionError(
                "Failed to list contents of {}: {}".format(name, exc.__str__())
            )
        except CommandExecutionError as exc:
            raise
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                "Uncaught exception '{}' when listing contents of {}".format(exc, name)
            )
        if clean:
            try:
                os.remove(cached)
                log.debug("Cleaned cached archive %s", cached)
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    log.warning(
                        "Failed to clean cached archive %s: %s", cached, exc.__str__()
                    )
        if strip_components:
            for item in (dirs, files, links):
                for index, path in enumerate(item):
                    try:
                        item[index] = item[index].split(os.sep, strip_components)[
                            strip_components
                        ]
                    except IndexError:
                        item[index] = ""
                item[:] = (x for x in item if x)
                item.sort()
        if verbose:
            ret = {
                "dirs": sorted(salt.utils.data.decode_list(dirs)),
                "files": sorted(salt.utils.data.decode_list(files)),
                "links": sorted(salt.utils.data.decode_list(links)),
            }
            ret["top_level_dirs"] = [x for x in ret["dirs"] if x.count("/") == 1]
            ret["top_level_files"] = [x for x in ret["files"] if x.count("/") == 0]
            ret["top_level_links"] = [x for x in ret["links"] if x.count("/") == 0]
        else:
            ret = sorted(dirs + files + links)
        return ret
    except CommandExecutionError as exc:
        info = exc.info or {}
        info["archive location"] = cached
        raise CommandExecutionError(exc.error, info=info)
_glob_wildcards = re.compile("[*?[]")
def _glob(pathname):
    """
    In case ``pathname`` contains glob wildcards, performs expansion and returns
    the possibly empty list of matching pathnames. Otherwise returns a list that
    contains only ``pathname`` itself.
    """
    if _glob_wildcards.search(pathname) is None:
        return [pathname]
    else:
        return glob.glob(pathname)
def _expand_sources(sources):
    """
    Expands a user-provided specification of source files into a list of paths.
    """
    if sources is None:
        return []
    if isinstance(sources, str):
        sources = [x.strip() for x in sources.split(",")]
    elif isinstance(sources, (float, int)):
        sources = [str(sources)]
    return [path for source in sources for path in _glob(source)]
@salt.utils.decorators.path.which("tar")
def tar(options, tarfile, sources=None, dest=None, cwd=None, template=None, runas=None):
    """
    .. note::
        This function has changed for version 0.17.0. In prior versions, the
        ``cwd`` and ``template`` arguments must be specified, with the source
        directories/files coming as a space-separated list at the end of the
        command. Beginning with 0.17.0, ``sources`` must be a comma-separated
        list, and the ``cwd`` and ``template`` arguments are optional.
    Uses the tar command to pack, unpack, etc. tar files
    options
        Options to pass to the tar command
        .. versionchanged:: 2015.8.0
            The mandatory `-` prefixing has been removed.  An options string
            beginning with a `--long-option`, would have uncharacteristically
            needed its first `-` removed under the former scheme.
            Also, tar will parse its options differently if short options are
            used with or without a preceding `-`, so it is better to not
            confuse the user into thinking they're using the non-`-` format,
            when really they are using the with-`-` format.
    tarfile
        The filename of the tar archive to pack/unpack
    sources
        Comma delimited list of files to **pack** into the tarfile. Can also be
        passed as a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    dest
        The destination directory into which to **unpack** the tarfile
    cwd : None
        The directory in which the tar command should be executed. If not
        specified, will default to the home directory of the user under which
        the salt minion process is running.
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.tar cjvf /tmp/salt.tar.bz2 {{grains.saltpath}} template=jinja
    CLI Examples:
    .. code-block:: bash
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1,/tmp/file_2
        salt '*' archive.tar cjvf /tmp/tarfile.tar.bz2 '/tmp/file_*'
        salt '*' archive.tar xf foo.tar dest=/target/directory
    """
    if not options:
        raise SaltInvocationError("Tar options can not be empty")
    cmd = ["tar"]
    if options:
        cmd.extend(options.split())
    cmd.extend(["{}".format(tarfile)])
    cmd.extend(_expand_sources(sources))
    if dest:
        cmd.extend(["-C", "{}".format(dest)])
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("gzip")
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def gzip(sourcefile, template=None, runas=None, options=None):
    """
    Uses the gzip command to create gzip files
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.gzip template=jinja /tmp/{{grains.id}}.txt
    runas : None
        The user with which to run the gzip command line
    options : None
        Pass any additional arguments to gzip
        .. versionadded:: 2016.3.4
    CLI Example:
    .. code-block:: bash
        salt '*' archive.gzip /tmp/sourcefile.txt
        salt '*' archive.gzip /tmp/sourcefile.txt options='-9 --verbose'
    """
    cmd = ["gzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(</b></font>sourcefile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("gunzip")
def gunzip(gzipfile, template=None, runas=None, options=None):
    """
    Uses the gunzip command to unpack gzip files
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.gunzip template=jinja /tmp/{{grains.id}}.txt.gz
    runas : None
        The user with which to run the gzip command line
    options : None
        Pass any additional arguments to gzip
        .. versionadded:: 2016.3.4
    CLI Example:
    .. code-block:: bash
        salt '*' archive.gunzip /tmp/sourcefile.txt.gz
        salt '*' archive.gunzip /tmp/sourcefile.txt options='--verbose'
    """
    cmd = ["gunzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(gzipfile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("zip")
def cmd_zip(zip_file, sources, template=None, cwd=None, runas=None):
    """
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.zip``.
    Uses the ``zip`` command to create zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``zip``.
    .. _`Info-ZIP`: http://www.info-zip.org/
    zip_file
        Path of zip file to be created
    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.cmd_zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt
    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:
        .. code-block:: bash
            salt '*' archive.cmd_zip /tmp/baz.zip baz.txt cwd=/foo/bar
        .. versionadded:: 2014.7.1
    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.
        .. versionadded:: 2015.5.0
    CLI Example:
    .. code-block:: bash
        salt '*' archive.cmd_zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.cmd_zip /tmp/zipfile.zip '/tmp/sourcefile*'
    """
    cmd = ["zip", "-r"]
    cmd.append("{}".format(zip_file))
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.depends("zipfile", fallback_function=cmd_zip)
def zip_(zip_file, sources, template=None, cwd=None, runas=None, zip64=False):
    """
    Uses the ``zipfile`` Python module to create zip files
    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_zip &lt;salt.modules.archive.cmd_zip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.
    zip_file
        Path of zip file to be created
    sources
        Comma-separated list of sources to include in the zip file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1,/tmp/{{grains.id}}.txt
    cwd : None
        Use this argument along with relative paths in ``sources`` to create
        zip files which do not contain the leading directories. If not
        specified, the zip file will be created as if the cwd was ``/``, and
        creating a zip file of ``/foo/bar/baz.txt`` will contain the parent
        directories ``foo`` and ``bar``. To create a zip file containing just
        ``baz.txt``, the following command would be used:
        .. code-block:: bash
            salt '*' archive.zip /tmp/baz.zip baz.txt cwd=/foo/bar
    runas : None
        Create the zip file as the specified user. Defaults to the user under
        which the minion is running.
    zip64 : False
        Used to enable ZIP64 support, necessary to create archives larger than
        4 GByte in size.
        If true, will create ZIP file with the ZIPp64 extension when the zipfile
        is larger than 2 GB.
        ZIP64 extension is disabled by default in the Python native zip support
        because the default zip and unzip commands on Unix (the InfoZIP utilities)
        don't support these extensions.
    CLI Example:
    .. code-block:: bash
        salt '*' archive.zip /tmp/zipfile.zip /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.zip /tmp/zipfile.zip '/tmp/sourcefile*'
    """
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, sources = _render_filenames(zip_file, sources, None, template)
    sources = _expand_sources(sources)
    if not cwd:
        for src in sources:
            if not os.path.isabs(src):
                raise SaltInvocationError("Relative paths require the 'cwd' parameter")
    else:
        err_msg = "cwd must be absolute"
        try:
            if not os.path.isabs(cwd):
                raise SaltInvocationError(err_msg)
        except AttributeError:
            raise SaltInvocationError(err_msg)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        exc = None
        archived_files = []
        with contextlib.closing(
            zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED, zip64)
        ) as zfile:
            for src in sources:
                if cwd:
                    src = os.path.join(cwd, src)
                if os.path.exists(src):
                    if os.path.isabs(src):
                        rel_root = "/"
                    else:
                        rel_root = cwd if cwd is not None else "/"
                    if os.path.isdir(src):
                        for dir_name, sub_dirs, files in salt.utils.path.os_walk(src):
                            if cwd and dir_name.startswith(cwd):
                                arc_dir = os.path.relpath(dir_name, cwd)
                            else:
                                arc_dir = os.path.relpath(dir_name, rel_root)
                            if arc_dir:
                                archived_files.append(arc_dir + "/")
                                zfile.write(dir_name, arc_dir)
                            for filename in files:
                                abs_name = os.path.join(dir_name, filename)
                                arc_name = os.path.join(arc_dir, filename)
                                archived_files.append(arc_name)
                                zfile.write(abs_name, arc_name)
                    else:
                        if cwd and src.startswith(cwd):
                            arc_name = os.path.relpath(src, cwd)
                        else:
                            arc_name = os.path.relpath(src, rel_root)
                        archived_files.append(arc_name)
                        zfile.write(src, arc_name)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        if exc is not None:
            if exc == zipfile.LargeZipFile:
                raise CommandExecutionError(
                    "Resulting zip file too large, would require ZIP64 support"
                    "which has not been enabled. Rerun command with zip64=True"
                )
            else:
                raise CommandExecutionError(
                    "Exception encountered creating zipfile: {}".format(exc)
                )
    return archived_files
@salt.utils.decorators.path.which("unzip")
def cmd_unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
):
    """
    .. versionadded:: 2015.5.0
        In versions 2014.7.x and earlier, this function was known as
        ``archive.unzip``.
    Uses the ``unzip`` command to unpack zip files. This command is part of the
    `Info-ZIP`_ suite of tools, and is typically packaged as simply ``unzip``.
    .. _`Info-ZIP`: http://www.info-zip.org/
    zip_file
        Path of zip file to be unpacked
    dest
        The destination directory into which the file should be unpacked
    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.cmd_unzip template=jinja /tmp/zipfile.zip '/tmp/{{grains.id}}' excludes=file_1,file_2
    options
        Optional when using ``zip`` archives, ignored when usign other archives
        files. This is mostly used to overwrite existing files with ``o``.
        This options are only used when ``unzip`` binary is used.
        .. versionadded:: 2016.3.1
    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.
        .. versionadded:: 2015.5.0
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    password
        Password to use with password protected zip files
        .. note::
            This is not considered secure. It is recommended to instead use
            :py:func:`archive.unzip &lt;salt.modules.archive.unzip&gt;` for
            password-protected ZIP files. If a password is used here, then the
            unzip command run to extract the ZIP file will not show up in the
            minion log like most shell commands Salt runs do. However, the
            password will still be present in the events logged to the minion
            log at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.
        .. versionadded:: 2016.11.0
    CLI Example:
    .. code-block:: bash
        salt '*' archive.cmd_unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2
    """
    if isinstance(excludes, str):
        excludes = [x.strip() for x in excludes.split(",")]
    elif isinstance(excludes, (float, int)):
        excludes = [str(excludes)]
    cmd = ["unzip"]
    if password:
        cmd.extend(["-P", password])
    if options:
        cmd.extend(shlex.split(options))
    cmd.extend(["{}".format(zip_file), "-d", "{}".format(dest)])
    if excludes is not None:
        cmd.append("-x")
        cmd.extend(excludes)
    result = __salt__["cmd.run_all"](
        cmd,
        template=template,
        runas=runas,
        python_shell=False,
        redirect_stderr=True,
        output_loglevel="quiet" if password else "debug",
    )
    if result["retcode"] != 0:
        raise CommandExecutionError(result["stdout"])
    return _trim_files(result["stdout"].splitlines(), trim_output)
def unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
    extract_perms=True,
):
    """
    Uses the ``zipfile`` Python module to unpack zip files
    .. versionchanged:: 2015.5.0
        This function was rewritten to use Python's native zip file support.
        The old functionality has been preserved in the new function
        :mod:`archive.cmd_unzip &lt;salt.modules.archive.cmd_unzip&gt;`. For versions
        2014.7.x and earlier, see the :mod:`archive.cmd_zip
        &lt;salt.modules.archive.cmd_zip&gt;` documentation.
    zip_file
        Path of zip file to be unpacked
    dest
        The destination directory into which the file should be unpacked
    excludes : None
        Comma-separated list of files not to unpack. Can also be passed in a
        Python list.
    options
        This options are only used when ``unzip`` binary is used. In this
        function is ignored.
        .. versionadded:: 2016.3.1
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.unzip template=jinja /tmp/zipfile.zip /tmp/{{grains.id}}/ excludes=file_1,file_2
    runas : None
        Unpack the zip file as the specified user. Defaults to the user under
        which the minion is running.
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ excludes=file_1,file_2
    password
        Password to use with password protected zip files
        .. note::
            The password will be present in the events logged to the minion log
            file at the ``debug`` log level. If the minion is logging at
            ``debug`` (or more verbose), then be advised that the password will
            appear in the log.
        .. versionadded:: 2016.3.0
    extract_perms : True
        The Python zipfile_ module does not extract file/directory attributes
        by default. When this argument is set to ``True``, Salt will attempt to
        apply the file permission attributes to the extracted files/folders.
        On Windows, only the read-only flag will be extracted as set within the
        zip file, other attributes (i.e. user/group permissions) are ignored.
        Set this argument to ``False`` to disable this behavior.
        .. versionadded:: 2016.11.0
    .. _zipfile: https://docs.python.org/2/library/zipfile.html
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unzip /tmp/zipfile.zip /home/strongbad/ password='BadPassword'
    """
    if not excludes:
        excludes = []
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, dest = _render_filenames(zip_file, dest, None, template)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        cleaned_files = []
        with contextlib.closing(zipfile.ZipFile(zip_file, "r")) as zfile:
            files = zfile.namelist()
            if isinstance(excludes, str):
                excludes = [x.strip() for x in excludes.split(",")]
            elif isinstance(excludes, (float, int)):
                excludes = [str(excludes)]
            cleaned_files.extend([x for x in files if x not in excludes])
            for target in cleaned_files:
                if target not in excludes:
                    if salt.utils.platform.is_windows() is False:
                        info = zfile.getinfo(target)
                        if stat.S_ISLNK(info.external_attr &gt;&gt; 16):
                            source = zfile.read(target)
                            os.symlink(source, os.path.join(dest, target))
                            continue
                    zfile.extract(target, dest, password)
                    if extract_perms:
                        if not salt.utils.platform.is_windows():
                            perm = zfile.getinfo(target).external_attr &gt;&gt; 16
                            if perm == 0:
                                umask_ = salt.utils.files.get_umask()
                                if target.endswith("/"):
                                    perm = 0o777 &amp; ~umask_
                                else:
                                    perm = 0o666 &amp; ~umask_
                            os.chmod(os.path.join(dest, target), perm)
                        else:
                            win32_attr = zfile.getinfo(target).external_attr &amp; 0xFF
                            win32file.SetFileAttributes(
                                os.path.join(dest, target), win32_attr
                            )
    except Exception as exc:  # pylint: disable=broad-except
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        raise CommandExecutionError(
            "Exception encountered unpacking zipfile: {}".format(exc)
        )
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
    return _trim_files(cleaned_files, trim_output)
def is_encrypted(name, clean=False, saltenv="base", source_hash=None, use_etag=False):
    """
    .. versionadded:: 2016.11.0
    .. versionchanged:: 3005
    Returns ``True`` if the zip archive is password-protected, ``False`` if
    not. If the specified file is not a ZIP archive, an error will be raised.
    name
        The path / URL of the archive to check.
    clean : False
        Set this value to ``True`` to delete the path referred to by ``name``
        once the contents have been listed. This option should be used with
        care.
        .. note::
            If there is an error listing the archive's contents, the cached
            file will not be removed, to allow for troubleshooting.
    saltenv : base
        Specifies the fileserver environment from which to retrieve
        ``archive``. This is only applicable when ``archive`` is a file from
        the ``salt://`` fileserver.
    source_hash
        If ``name`` is an http(s)/ftp URL and the file exists in the minion's
        file cache, this option can be passed to keep the minion from
        re-downloading the archive if the cached copy matches the specified
        hash.
        .. versionadded:: 2018.3.0
    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.
        .. versionadded:: 3005
    CLI Examples:
    .. code-block:: bash
            salt '*' archive.is_encrypted /path/to/myfile.zip
            salt '*' archive.is_encrypted salt://foo.zip
            salt '*' archive.is_encrypted salt://foo.zip saltenv=dev
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip clean=True
            salt '*' archive.is_encrypted https://domain.tld/myfile.zip source_hash=f1d2d2f924e986ac86fdf7b36c94bcdf32beec15
            salt '*' archive.is_encrypted ftp://10.1.2.3/foo.zip
    """
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    archive_info = {"archive location": cached}
    try:
        with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
            zip_archive.testzip()
    except RuntimeError:
        ret = True
    except zipfile.BadZipfile:
        raise CommandExecutionError(
            "{} is not a ZIP file".format(name), info=archive_info
        )
    except Exception as exc:  # pylint: disable=broad-except
        raise CommandExecutionError(exc.__str__(), info=archive_info)
    else:
        ret = False
    if clean:
        try:
            os.remove(cached)
            log.debug("Cleaned cached archive %s", cached)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                log.warning(
                    "Failed to clean cached archive %s: %s", cached, exc.__str__()
                )
    return ret
@salt.utils.decorators.path.which("rar")
def rar(rarfile, sources, template=None, cwd=None, runas=None):
    """
    Uses `rar for Linux`_ to create rar files
    .. _`rar for Linux`: http://www.rarlab.com/
    rarfile
        Path of rar file to be created
    sources
        Comma-separated list of sources to include in the rar file. Sources can
        also be passed in a Python list.
        .. versionchanged:: 2017.7.0
            Globbing is now supported for this argument
    cwd : None
        Run the rar command from the specified directory. Use this argument
        along with relative file paths to create rar files which do not
        contain the leading directories. If not specified, this will default
        to the home directory of the user under which the salt minion process
        is running.
        .. versionadded:: 2014.7.1
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.rar template=jinja /tmp/rarfile.rar '/tmp/sourcefile1,/tmp/{{grains.id}}.txt'
    CLI Example:
    .. code-block:: bash
        salt '*' archive.rar /tmp/rarfile.rar /tmp/sourcefile1,/tmp/sourcefile2
        salt '*' archive.rar /tmp/rarfile.rar '/tmp/sourcefile*'
    """
    cmd = ["rar", "a", "-idp", "{}".format(rarfile)]
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which_bin(("unrar", "rar"))
def unrar(rarfile, dest, excludes=None, template=None, runas=None, trim_output=False):
    """
    Uses `rar for Linux`_ to unpack rar files
    .. _`rar for Linux`: http://www.rarlab.com/
    rarfile
        Name of rar file to be unpacked
    dest
        The destination directory into which to **unpack** the rar file
    template : None
        Can be set to 'jinja' or another supported template engine to render
        the command arguments before execution:
        .. code-block:: bash
            salt '*' archive.unrar template=jinja /tmp/rarfile.rar /tmp/{{grains.id}}/ excludes=file_1,file_2
    trim_output : False
        The number of files we should output on success before the rest are trimmed, if this is
        set to True then it will default to 100
    CLI Example:
    .. code-block:: bash
        salt '*' archive.unrar /tmp/rarfile.rar /home/strongbad/ excludes=file_1,file_2
    """
    if isinstance(excludes, str):
        excludes = [entry.strip() for entry in excludes.split(",")]
    cmd = [
        salt.utils.path.which_bin(("unrar", "rar")),
        "x",
        "-idp",
        "{}".format(rarfile),
    ]
    if excludes is not None:
        for exclude in excludes:
            cmd.extend(["-x", "{}".format(exclude)])
    cmd.append("{}".format(dest))
    files = __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
    return _trim_files(files, trim_output)
def _render_filenames(filenames, zip_file, saltenv, template):
    """
    Process markup in the :param:`filenames` and :param:`zipfile` variables (NOT the
    files under the paths they ultimately point to) according to the markup
    format provided by :param:`template`.
    """
    if not template:
        return (filenames, zip_file)
    if template not in salt.utils.templates.TEMPLATE_REGISTRY:
        raise CommandExecutionError(
            "Attempted to render file paths with unavailable engine {}".format(template)
        )
    kwargs = {}
    kwargs["salt"] = __salt__
    kwargs["pillar"] = __pillar__
    kwargs["grains"] = __grains__
    kwargs["opts"] = __opts__
    kwargs["saltenv"] = saltenv
    def _render(contents):
        """
        Render :param:`contents` into a literal pathname by writing it to a
        temp file, rendering that file, and returning the result.
        """
        tmp_path_fn = salt.utils.files.mkstemp()
        with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
            fp_.write(salt.utils.stringutils.to_str(contents))
        data = salt.utils.templates.TEMPLATE_REGISTRY[template](
            tmp_path_fn, to_str=True, **kwargs
        )
        salt.utils.files.safe_rm(tmp_path_fn)
        if not data["result"]:
            raise CommandExecutionError(
                "Failed to render file path with error: {}".format(data["data"])
            )
        else:
            return data["data"]
    filenames = _render(filenames)
    zip_file = _render(zip_file)
    return (filenames, zip_file)
def _trim_files(files, trim_output):
    """
    Trim the file list for output.
    """
    count = 100
    if not isinstance(trim_output, bool):
        count = trim_output
    if (
        not (isinstance(trim_output, bool) and trim_output is False)
        and len(files) &gt; count
    ):
        files = files[:count]
        files.append("List trimmed after {} files.".format(count))
    return files
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
