<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zpool_1.py &amp; archive_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zpool_1.py &amp; archive_1.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zpool_1.py (1.0942761%)<th>archive_1.py (1.0433387%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1055-1097)<td><a href="#" name="0">(557-588)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zpool_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import salt.utils.decorators
4 import salt.utils.decorators.path
5 import salt.utils.path
6 from salt.utils.odict import OrderedDict
7 log = logging.getLogger(__name__)
8 __virtualname__ = "zpool"
9 __func_alias__ = {
10     "import_": "import",
11     "list_": "list",
12 }
13 def __virtual__():
14     if __grains__.get("zfs_support"):
15         return __virtualname__
16     else:
17         return False, "The zpool module cannot be loaded: zfs not supported"
18 def _clean_vdev_config(config):
19     cln_config = OrderedDict()
20     for label, sub_config in config.items():
21         if label not in ["state", "read", "write", "cksum"]:
22             sub_config = _clean_vdev_config(sub_config)
23             if sub_config and isinstance(cln_config, list):
24                 cln_config.append(OrderedDict([(label, sub_config)]))
25             elif sub_config and isinstance(cln_config, OrderedDict):
26                 cln_config[label] = sub_config
27             elif isinstance(cln_config, list):
28                 cln_config.append(label)
29             elif isinstance(cln_config, OrderedDict):
30                 new_config = []
31                 for old_label, old_config in cln_config.items():
32                     new_config.append(OrderedDict([(old_label, old_config)]))
33                 new_config.append(label)
34                 cln_config = new_config
35             else:
36                 cln_config = [label]
37     return cln_config
38 def healthy():
39     res = __salt__["cmd.run_all"](
40         __utils__["zfs.zpool_command"]("status", flags=["-x"]),
41         python_shell=False,
42     )
43     return res["stdout"] == "all pools are healthy"
44 def status(zpool=None):
45     ret = OrderedDict()
46     res = __salt__["cmd.run_all"](
47         __utils__["zfs.zpool_command"]("status", target=zpool),
48         python_shell=False,
49     )
50     if res["retcode"] != 0:
51         return __utils__["zfs.parse_command_result"](res)
52     current_pool = None
53     current_prop = None
54     for zpd in res["stdout"].splitlines():
55         if zpd.strip() == "":
56             continue
57         if ":" in zpd and zpd[0] != "\t":
58             prop = zpd.split(":")[0].strip()
59             value = ":".join(zpd.split(":")[1:]).strip()
60             if prop == "pool" and current_pool != value:
61                 current_pool = value
62                 ret[current_pool] = OrderedDict()
63             if prop != "pool":
64                 ret[current_pool][prop] = value
65             current_prop = prop
66         else:
67             ret[current_pool][current_prop] = "{}\n{}".format(
68                 ret[current_pool][current_prop], zpd
69             )
70     for pool in ret:
71         if "config" not in ret[pool]:
72             continue
73         header = None
74         root_vdev = None
75         vdev = None
76         dev = None
77         rdev = None
78         config = ret[pool]["config"]
79         config_data = OrderedDict()
80         for line in config.splitlines():
81             if not header:
82                 header = line.strip().lower()
83                 header = [x for x in header.split(" ") if x not in [""]]
84                 continue
85             if line[0] == "\t":
86                 line = line[1:]
87             stat_data = OrderedDict(
88                 list(
89                     zip(
90                         header,
91                         [x for x in line.strip().split(" ") if x not in [""]],
92                     )
93                 )
94             )
95             stat_data = __utils__["zfs.from_auto_dict"](stat_data)
96             if line.startswith(" " * 6):
97                 rdev = stat_data["name"]
98                 config_data[root_vdev][vdev][dev][rdev] = stat_data
99             elif line.startswith(" " * 4):
100                 rdev = None
101                 dev = stat_data["name"]
102                 config_data[root_vdev][vdev][dev] = stat_data
103             elif line.startswith(" " * 2):
104                 rdev = dev = None
105                 vdev = stat_data["name"]
106                 config_data[root_vdev][vdev] = stat_data
107             else:
108                 rdev = dev = vdev = None
109                 root_vdev = stat_data["name"]
110                 config_data[root_vdev] = stat_data
111             del stat_data["name"]
112         ret[pool]["config"] = config_data
113     return ret
114 def iostat(zpool=None, sample_time=5, parsable=True):
115     ret = OrderedDict()
116     res = __salt__["cmd.run_all"](
117         __utils__["zfs.zpool_command"](
118             command="iostat", flags=["-v"], target=[zpool, sample_time, 2]
119         ),
120         python_shell=False,
121     )
122     if res["retcode"] != 0:
123         return __utils__["zfs.parse_command_result"](res)
124     header = [
125         "name",
126         "capacity-alloc",
127         "capacity-free",
128         "operations-read",
129         "operations-write",
130         "bandwidth-read",
131         "bandwidth-write",
132     ]
133     root_vdev = None
134     vdev = None
135     dev = None
136     current_data = OrderedDict()
137     for line in res["stdout"].splitlines():
138         if line.strip() == "" or line.strip().split()[-1] in ["write", "bandwidth"]:
139             continue
140         if line.startswith("-") and line.endswith("-"):
141             ret.update(current_data)
142             current_data = OrderedDict()
143             continue
144         io_data = OrderedDict(
145             list(
146                 zip(
147                     header,
148                     [x for x in line.strip().split(" ") if x not in [""]],
149                 )
150             )
151         )
152         if parsable:
153             io_data = __utils__["zfs.from_auto_dict"](io_data)
154         else:
155             io_data = __utils__["zfs.to_auto_dict"](io_data)
156         if line.startswith(" " * 4):
157             dev = io_data["name"]
158             current_data[root_vdev][vdev][dev] = io_data
159         elif line.startswith(" " * 2):
160             dev = None
161             vdev = io_data["name"]
162             current_data[root_vdev][vdev] = io_data
163         else:
164             dev = vdev = None
165             root_vdev = io_data["name"]
166             current_data[root_vdev] = io_data
167         del io_data["name"]
168     return ret
169 def list_(properties="size,alloc,free,cap,frag,health", zpool=None, parsable=True):
170     ret = OrderedDict()
171     if not isinstance(properties, list):
172         properties = properties.split(",")
173     while "name" in properties:
174         properties.remove("name")
175     properties.insert(0, "name")
176     if not __utils__["zfs.has_feature_flags"]():
177         while "frag" in properties:
178             properties.remove("frag")
179     res = __salt__["cmd.run_all"](
180         __utils__["zfs.zpool_command"](
181             command="list",
182             flags=["-H"],
183             opts={"-o": ",".join(properties)},
184             target=zpool,
185         ),
186         python_shell=False,
187     )
188     if res["retcode"] != 0:
189         return __utils__["zfs.parse_command_result"](res)
190     for line in res["stdout"].splitlines():
191         zpool_data = OrderedDict(
192             list(
193                 zip(
194                     properties,
195                     line.strip().split("\t"),
196                 )
197             )
198         )
199         if parsable:
200             zpool_data = __utils__["zfs.from_auto_dict"](zpool_data)
201         else:
202             zpool_data = __utils__["zfs.to_auto_dict"](zpool_data)
203         ret[zpool_data["name"]] = zpool_data
204         del ret[zpool_data["name"]]["name"]
205     return ret
206 def get(zpool, prop=None, show_source=False, parsable=True):
207     ret = OrderedDict()
208     value_properties = ["name", "property", "value", "source"]
209     res = __salt__["cmd.run_all"](
210         __utils__["zfs.zpool_command"](
211             command="get",
212             flags=["-H"],
213             property_name=prop if prop else "all",
214             target=zpool,
215         ),
216         python_shell=False,
217     )
218     if res["retcode"] != 0:
219         return __utils__["zfs.parse_command_result"](res)
220     for line in res["stdout"].splitlines():
221         prop_data = OrderedDict(
222             list(
223                 zip(
224                     value_properties,
225                     [x for x in line.strip().split("\t") if x not in [""]],
226                 )
227             )
228         )
229         del prop_data["name"]
230         if parsable:
231             prop_data["value"] = __utils__["zfs.from_auto"](
232                 prop_data["property"], prop_data["value"]
233             )
234         else:
235             prop_data["value"] = __utils__["zfs.to_auto"](
236                 prop_data["property"], prop_data["value"]
237             )
238         if show_source:
239             ret[prop_data["property"]] = prop_data
240             del ret[prop_data["property"]]["property"]
241         else:
242             ret[prop_data["property"]] = prop_data["value"]
243     return ret
244 def set(zpool, prop, value):
245     ret = OrderedDict()
246     res = __salt__["cmd.run_all"](
247         __utils__["zfs.zpool_command"](
248             command="set",
249             property_name=prop,
250             property_value=value,
251             target=zpool,
252         ),
253         python_shell=False,
254     )
255     return __utils__["zfs.parse_command_result"](res, "set")
256 def exists(zpool):
257     res = __salt__["cmd.run_all"](
258         __utils__["zfs.zpool_command"](
259             command="list",
260             target=zpool,
261         ),
262         python_shell=False,
263         ignore_retcode=True,
264     )
265     return res["retcode"] == 0
266 def destroy(zpool, force=False):
267     res = __salt__["cmd.run_all"](
268         __utils__["zfs.zpool_command"](
269             command="destroy",
270             flags=["-f"] if force else None,
271             target=zpool,
272         ),
273         python_shell=False,
274     )
275     return __utils__["zfs.parse_command_result"](res, "destroyed")
276 def scrub(zpool, stop=False, pause=False):
277     if stop:
278         action = ["-s"]
279     elif pause:
280         action = ["-p"]
281     else:
282         action = None
283     res = __salt__["cmd.run_all"](
284         __utils__["zfs.zpool_command"](
285             command="scrub",
286             flags=action,
287             target=zpool,
288         ),
289         python_shell=False,
290     )
291     if res["retcode"] != 0:
292         return __utils__["zfs.parse_command_result"](res, "scrubbing")
293     ret = OrderedDict()
294     if stop or pause:
295         ret["scrubbing"] = False
296     else:
297         ret["scrubbing"] = True
298     return ret
299 def create(zpool, *vdevs, **kwargs):
300     flags = []
301     opts = {}
302     target = []
303     pool_properties = kwargs.get("properties", {})
304     filesystem_properties = kwargs.get("filesystem_properties", {})
305     if kwargs.get("force", False):
306         flags.append("-f")
307     if kwargs.get("createboot", False) or "bootsize" in pool_properties:
308         flags.append("-B")
309     if kwargs.get("altroot", False):
310         opts["-R"] = kwargs.get("altroot")
311     if kwargs.get("mountpoint", False):
312         opts["-m"] = kwargs.get("mountpoint")
313     target.append(zpool)
314     target.extend(vdevs)
315     res = __salt__["cmd.run_all"](
316         __utils__["zfs.zpool_command"](
317             command="create",
318             flags=flags,
319             opts=opts,
320             pool_properties=pool_properties,
321             filesystem_properties=filesystem_properties,
322             target=target,
323         ),
324         python_shell=False,
325     )
326     ret = __utils__["zfs.parse_command_result"](res, "created")
327     if ret["created"]:
328         ret["vdevs"] = _clean_vdev_config(
329             __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
330         )
331     return ret
332 def add(zpool, *vdevs, **kwargs):
333     flags = []
334     target = []
335     if kwargs.get("force", False):
336         flags.append("-f")
337     target.append(zpool)
338     target.extend(vdevs)
339     res = __salt__["cmd.run_all"](
340         __utils__["zfs.zpool_command"](
341             command="add",
342             flags=flags,
343             target=target,
344         ),
345         python_shell=False,
346     )
347     ret = __utils__["zfs.parse_command_result"](res, "added")
348     if ret["added"]:
349         ret["vdevs"] = _clean_vdev_config(
350             __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
351         )
352     return ret
353 def attach(zpool, device, new_device, force=False):
354     flags = []
355     target = []
356     if force:
357         flags.append("-f")
358     target.append(zpool)
359     target.append(device)
360     target.append(new_device)
361     res = __salt__["cmd.run_all"](
362         __utils__["zfs.zpool_command"](
363             command="attach",
364             flags=flags,
365             target=target,
366         ),
367         python_shell=False,
368     )
369     ret = __utils__["zfs.parse_command_result"](res, "attached")
370     if ret["attached"]:
371         ret["vdevs"] = _clean_vdev_config(
372             __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
373         )
374     return ret
375 def detach(zpool, device):
376     res = __salt__["cmd.run_all"](
377         __utils__["zfs.zpool_command"](
378             command="detach",
379             target=[zpool, device],
380         ),
381         python_shell=False,
382     )
383     ret = __utils__["zfs.parse_command_result"](res, "detatched")
384     if ret["detatched"]:
385         ret["vdevs"] = _clean_vdev_config(
386             __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
387         )
388     return ret
389 def split(zpool, newzpool, **kwargs):
390     opts = {}
391     pool_properties = kwargs.get("properties", {})
392     if kwargs.get("altroot", False):
393         opts["-R"] = kwargs.get("altroot")
394     res = __salt__["cmd.run_all"](
395         __utils__["zfs.zpool_command"](
396             command="split",
397             opts=opts,
398             pool_properties=pool_properties,
399             target=[zpool, newzpool],
400         ),
401         python_shell=False,
402     )
403 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def replace(zpool, old_device, new_device=None, force=False):
404     flags = []
405     target = []
406     if force:
407         flags.append("-f")
408     target.append(zpool)
409     target.append(</b></font>old_device)
410     if new_device:
411         target.append(new_device)
412     res = __salt__["cmd.run_all"](
413         __utils__["zfs.zpool_command"](
414             command="replace",
415             flags=flags,
416             target=target,
417         ),
418         python_shell=False,
419     )
420     ret = __utils__["zfs.parse_command_result"](res, "replaced")
421     if ret["replaced"]:
422         ret["vdevs"] = _clean_vdev_config(
423             __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
424         )
425     return ret
426 @salt.utils.decorators.path.which("mkfile")
427 def create_file_vdev(size, *vdevs):
428     ret = OrderedDict()
429     err = OrderedDict()
430     _mkfile_cmd = salt.utils.path.which("mkfile")
431     for vdev in vdevs:
432         if os.path.isfile(vdev):
433             ret[vdev] = "existed"
434         else:
435             res = __salt__["cmd.run_all"](
436                 "{mkfile} {size} {vdev}".format(
437                     mkfile=_mkfile_cmd,
438                     size=size,
439                     vdev=vdev,
440                 ),
441                 python_shell=False,
442             )
443             if res["retcode"] != 0:
444                 if "stderr" in res and ":" in res["stderr"]:
445                     ret[vdev] = "failed"
446                     err[vdev] = ":".join(res["stderr"].strip().split(":")[1:])
447             else:
448                 ret[vdev] = "created"
449     if err:
450         ret["error"] = err
451     return ret
452 def export(*pools, **kwargs):
453     flags = []
454     targets = []
455     if kwargs.get("force", False):
456         flags.append("-f")
457     targets = list(pools)
458     res = __salt__["cmd.run_all"](
459         __utils__["zfs.zpool_command"](
460             command="export",
461             flags=flags,
462             target=targets,
463         ),
464         python_shell=False,
465     )
466     return __utils__["zfs.parse_command_result"](res, "exported")
467 def import_(zpool=None, new_name=None, **kwargs):
468     flags = []
469     opts = {}
470     target = []
471     pool_properties = kwargs.get("properties", {})
472     if kwargs.get("force", False) or kwargs.get("only_destroyed", False):
473         flags.append("-f")
474     if kwargs.get("only_destroyed", False):
475         flags.append("-D")
476     if kwargs.get("no_mount", False):
477         flags.append("-N")
478     if kwargs.get("altroot", False):
479         opts["-R"] = kwargs.get("altroot")
480     if kwargs.get("mntopts", False):
481         opts["-o"] = kwargs.get("mntopts")
482     if kwargs.get("dir", False):
483         opts["-d"] = kwargs.get("dir").split(",")
484     if kwargs.get("recovery", False) and __utils__["zfs.has_feature_flags"]():
485         recovery = kwargs.get("recovery")
486         if recovery in [True, "test"]:
487             flags.append("-F")
488         if recovery == "test":
489             flags.append("-n")
490         if recovery == "nolog":
491             flags.append("-m")
492     if zpool:
493         target.append(zpool)
494         target.append(new_name)
495     else:
496         flags.append("-a")
497     res = __salt__["cmd.run_all"](
498         __utils__["zfs.zpool_command"](
499             command="import",
500             flags=flags,
501             opts=opts,
502             pool_properties=pool_properties,
503             target=target,
504         ),
505         python_shell=False,
506     )
507     return __utils__["zfs.parse_command_result"](res, "imported")
508 def online(zpool, *vdevs, **kwargs):
509     flags = []
510     target = []
511     if kwargs.get("expand", False):
512         flags.append("-e")
513     target.append(zpool)
514     if vdevs:
515         target.extend(vdevs)
516     flags = []
517     target = []
518     if kwargs.get("expand", False):
519         flags.append("-e")
520     target.append(zpool)
521     target.extend(vdevs)
522     res = __salt__["cmd.run_all"](
523         __utils__["zfs.zpool_command"](
524             command="online",
525             flags=flags,
526             target=target,
527         ),
528         python_shell=False,
529     )
530     return __utils__["zfs.parse_command_result"](res, "onlined")
531 def offline(zpool, *vdevs, **kwargs):
532     flags = []
533     target = []
534     if kwargs.get("temporary", False):
535         flags.append("-t")
536     target.append(zpool)
537     target.extend(vdevs)
538     res = __salt__["cmd.run_all"](
539         __utils__["zfs.zpool_command"](
540             command="offline",
541             flags=flags,
542             target=target,
543         ),
544         python_shell=False,
545     )
546     return __utils__["zfs.parse_command_result"](res, "offlined")
547 def labelclear(device, force=False):
548     res = __salt__["cmd.run_all"](
549         __utils__["zfs.zpool_command"](
550             command="labelclear",
551             flags=["-f"] if force else None,
552             target=device,
553         ),
554         python_shell=False,
555     )
556     return __utils__["zfs.parse_command_result"](res, "labelcleared")
557 def clear(zpool, device=None):
558     target = []
559     target.append(zpool)
560     target.append(device)
561     res = __salt__["cmd.run_all"](
562         __utils__["zfs.zpool_command"](
563             command="clear",
564             target=target,
565         ),
566         python_shell=False,
567     )
568     return __utils__["zfs.parse_command_result"](res, "cleared")
569 def reguid(zpool):
570     res = __salt__["cmd.run_all"](
571         __utils__["zfs.zpool_command"](
572             command="reguid",
573             target=zpool,
574         ),
575         python_shell=False,
576     )
577     return __utils__["zfs.parse_command_result"](res, "reguided")
578 def reopen(zpool):
579     res = __salt__["cmd.run_all"](
580         __utils__["zfs.zpool_command"](
581             command="reopen",
582             target=zpool,
583         ),
584         python_shell=False,
585     )
586     return __utils__["zfs.parse_command_result"](res, "reopened")
587 def upgrade(zpool=None, version=None):
588     flags = []
589     opts = {}
590     if version:
591         opts["-V"] = version
592     if not zpool:
593         flags.append("-a")
594     res = __salt__["cmd.run_all"](
595         __utils__["zfs.zpool_command"](
596             command="upgrade",
597             flags=flags,
598             opts=opts,
599             target=zpool,
600         ),
601         python_shell=False,
602     )
603     return __utils__["zfs.parse_command_result"](res, "upgraded")
604 def history(zpool=None, internal=False, verbose=False):
605     ret = OrderedDict()
606     flags = []
607     if verbose:
608         flags.append("-l")
609     if internal:
610         flags.append("-i")
611     res = __salt__["cmd.run_all"](
612         __utils__["zfs.zpool_command"](
613             command="history",
614             flags=flags,
615             target=zpool,
616         ),
617         python_shell=False,
618     )
619     if res["retcode"] != 0:
620         return __utils__["zfs.parse_command_result"](res)
621     else:
622         pool = "unknown"
623         for line in res["stdout"].splitlines():
624             if line.startswith("History for"):
625                 pool = line[13:-2]
626                 ret[pool] = OrderedDict()
627             else:
628                 if line == "":
629                     continue
630                 log_timestamp = line[0:19]
631                 log_command = line[20:]
632                 ret[pool][log_timestamp] = log_command
633     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import copy
3 import errno
4 import glob
5 import logging
6 import os
7 import re
8 import shlex
9 import stat
10 import subprocess
11 import tarfile
12 import urllib.parse
13 import zipfile
14 import salt.utils.decorators
15 import salt.utils.decorators.path
16 import salt.utils.files
17 import salt.utils.path
18 import salt.utils.platform
19 import salt.utils.stringutils
20 import salt.utils.templates
21 from salt.exceptions import CommandExecutionError, SaltInvocationError
22 try:
23     import rarfile
24     HAS_RARFILE = True
25 except ImportError:
26     HAS_RARFILE = False
27 if salt.utils.platform.is_windows():
28     import win32file
29 __func_alias__ = {"zip_": "zip", "list_": "list"}
30 log = logging.getLogger(__name__)
31 def list_(
32     name,
33     archive_format=None,
34     options=None,
35     strip_components=None,
36     clean=False,
37     verbose=False,
38     saltenv="base",
39     source_hash=None,
40     use_etag=False,
41 ):
42     def _list_tar(name, cached, decompress_cmd, failhard=False):
43         dirs = []
44         files = []
45         links = []
46         try:
47             open_kwargs = (
48                 {"name": cached}
49                 if not isinstance(cached, subprocess.Popen)
50                 else {"fileobj": cached.stdout, "mode": "r|"}
51             )
52             with contextlib.closing(tarfile.open(**open_kwargs)) as tar_archive:
53                 for member in tar_archive.getmembers():
54                     _member = salt.utils.data.decode(member.name)
55                     if member.issym():
56                         links.append(_member)
57                     elif member.isdir():
58                         dirs.append(_member + "/")
59                     else:
60                         files.append(_member)
61             return dirs, files, links
62         except tarfile.ReadError:
63             if failhard:
64                 if isinstance(cached, subprocess.Popen):
65                     stderr = cached.communicate()[1]
66                     if cached.returncode != 0:
67                         raise CommandExecutionError(
68                             "Failed to decompress {}".format(name),
69                             info={"error": stderr},
70                         )
71             else:
72                 if not salt.utils.path.which("tar"):
73                     raise CommandExecutionError("'tar' command not available")
74                 if decompress_cmd is not None and isinstance(decompress_cmd, str):
75                     try:
76                         decompress_cmd = [
77                             shlex.quote(x) for x in shlex.split(decompress_cmd)
78                         ]
79                     except AttributeError:
80                         raise CommandExecutionError("Invalid CLI options")
81                 else:
82                     if (
83                         salt.utils.path.which("xz")
84                         and __salt__["cmd.retcode"](
85                             ["xz", "-t", cached],
86                             python_shell=False,
87                             ignore_retcode=True,
88                         )
89                         == 0
90                     ):
91                         decompress_cmd = ["xz", "--decompress", "--stdout"]
92                 if decompress_cmd:
93                     decompressed = subprocess.Popen(
94                         decompress_cmd + [shlex.quote(cached)],
95                         stdout=subprocess.PIPE,
96                         stderr=subprocess.PIPE,
97                     )
98                     return _list_tar(name, decompressed, None, True)
99         raise CommandExecutionError(
100             "Unable to list contents of {}. If this is an XZ-compressed tar "
101             "archive, install XZ Utils to enable listing its contents. If it "
102             "is compressed using something other than XZ, it may be necessary "
103             "to specify CLI options to decompress the archive. See the "
104             "documentation for details.".format(name)
105         )
106     def _list_zip(name, cached):
107         dirs = set()
108         files = []
109         links = []
110         try:
111             with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
112                 for member in zip_archive.infolist():
113                     path = member.filename
114                     if salt.utils.platform.is_windows():
115                         if path.endswith("/"):
116                             dirs.add(path)
117                         else:
118                             files.append(path)
119                     else:
120                         mode = member.external_attr &gt;&gt; 16
121                         if stat.S_ISLNK(mode):
122                             links.append(path)
123                         elif stat.S_ISDIR(mode):
124                             dirs.add(path)
125                         else:
126                             files.append(path)
127                 _files = copy.deepcopy(files)
128                 for path in _files:
129                     dirname = "".join(path.rpartition("/")[:2])
130                     if dirname:
131                         dirs.add(dirname)
132                         if dirname in files:
133                             files.remove(dirname)
134             return list(dirs), files, links
135         except zipfile.BadZipfile:
136             raise CommandExecutionError("{} is not a ZIP file".format(name))
137     def _list_rar(name, cached):
138         dirs = []
139         files = []
140         if HAS_RARFILE:
141             with rarfile.RarFile(cached) as rf:
142                 for member in rf.infolist():
143                     path = member.filename.replace("\\", "/")
144                     if member.isdir():
145                         dirs.append(path + "/")
146                     else:
147                         files.append(path)
148         else:
149             if not salt.utils.path.which("rar"):
150                 raise CommandExecutionError(
151                     "rar command not available, is it installed?"
152                 )
153             output = __salt__["cmd.run"](
154                 ["rar", "lt", name], python_shell=False, ignore_retcode=False
155             )
156             matches = re.findall(r"Name:\s*([^\n]+)\s*Type:\s*([^\n]+)", output)
157             for path, type_ in matches:
158                 if type_ == "Directory":
159                     dirs.append(path + "/")
160                 else:
161                     files.append(path)
162             if not dirs and not files:
163                 raise CommandExecutionError(
164                     "Failed to list {}, is it a rar file? If so, the "
165                     "installed version of rar may be too old to list data in "
166                     "a parsable format. Installing the rarfile Python module "
167                     "may be an easier workaround if newer rar is not readily "
168                     "available.".format(name),
169                     info={"error": output},
170                 )
171         return dirs, files, []
172     cached = __salt__["cp.cache_file"](
173         name, saltenv, source_hash=source_hash, use_etag=use_etag
174     )
175     if not cached:
176         raise CommandExecutionError("Failed to cache {}".format(name))
177     try:
178         if strip_components:
179             try:
180                 int(strip_components)
181             except ValueError:
182                 strip_components = -1
183             if strip_components &lt;= 0:
184                 raise CommandExecutionError(
185                     "'strip_components' must be a positive integer"
186                 )
187         parsed = urllib.parse.urlparse(name)
188         path = parsed.path or parsed.netloc
189         def _unsupported_format(archive_format):
190             if archive_format is None:
191                 raise CommandExecutionError(
192                     "Unable to guess archive format, please pass an "
193                     "'archive_format' argument."
194                 )
195             raise CommandExecutionError(
196                 "Unsupported archive format '{}'".format(archive_format)
197             )
198         if not archive_format:
199             guessed_format = salt.utils.files.guess_archive_type(path)
200             if guessed_format is None:
201                 _unsupported_format(archive_format)
202             archive_format = guessed_format
203         func = locals().get("_list_" + archive_format)
204         if not hasattr(func, "__call__"):
205             _unsupported_format(archive_format)
206         args = (options,) if archive_format == "tar" else ()
207         try:
208             dirs, files, links = func(name, cached, *args)
209         except OSError as exc:
210             raise CommandExecutionError(
211                 "Failed to list contents of {}: {}".format(name, exc.__str__())
212             )
213         except CommandExecutionError as exc:
214             raise
215         except Exception as exc:  # pylint: disable=broad-except
216             raise CommandExecutionError(
217                 "Uncaught exception '{}' when listing contents of {}".format(exc, name)
218             )
219         if clean:
220             try:
221                 os.remove(cached)
222                 log.debug("Cleaned cached archive %s", cached)
223             except OSError as exc:
224                 if exc.errno != errno.ENOENT:
225                     log.warning(
226                         "Failed to clean cached archive %s: %s", cached, exc.__str__()
227                     )
228         if strip_components:
229             for item in (dirs, files, links):
230                 for index, path in enumerate(item):
231                     try:
232                         item[index] = item[index].split(os.sep, strip_components)[
233                             strip_components
234                         ]
235                     except IndexError:
236                         item[index] = ""
237                 item[:] = (x for x in item if x)
238                 item.sort()
239         if verbose:
240             ret = {
241                 "dirs": sorted(salt.utils.data.decode_list(dirs)),
242                 "files": sorted(salt.utils.data.decode_list(files)),
243                 "links": sorted(salt.utils.data.decode_list(links)),
244             }
245             ret["top_level_dirs"] = [x for x in ret["dirs"] if x.count("/") == 1]
246             ret["top_level_files"] = [x for x in ret["files"] if x.count("/") == 0]
247             ret["top_level_links"] = [x for x in ret["links"] if x.count("/") == 0]
248         else:
249             ret = sorted(dirs + files + links)
250         return ret
251     except CommandExecutionError as exc:
252         info = exc.info or {}
253         info["archive location"] = cached
254         raise CommandExecutionError(exc.error, info=info)
255 _glob_wildcards = re.compile("[*?[]")
256 def _glob(pathname):
257     if _glob_wildcards.search(pathname) is None:
258         return [pathname]
259     else:
260         return glob.glob(pathname)
261 def _expand_sources(sources):
262     if sources is None:
263         return []
264     if isinstance(sources, str):
265         sources = [x.strip() for x in sources.split(",")]
266     elif isinstance(sources, (float, int)):
267         sources = [str(sources)]
268     return [path for source in sources for path in _glob(source)]
269 @salt.utils.decorators.path.which("tar")
270 def tar(options, tarfile, sources=None, dest=None, cwd=None, template=None, runas=None):
271     if not options:
272         raise SaltInvocationError("Tar options can not be empty")
273     cmd = ["tar"]
274     if options:
275         cmd.extend(options.split())
276     cmd.extend(["{}".format(tarfile)])
277     cmd.extend(_expand_sources(sources))
278     if dest:
279         cmd.extend(["-C", "{}".format(dest)])
280     return __salt__["cmd.run"](
281         cmd, cwd=cwd, template=template, runas=runas, python_shell=False
282     ).splitlines()
283 @salt.utils.decorators.path.which("gzip")
284 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def gzip(sourcefile, template=None, runas=None, options=None):
285     cmd = ["gzip"]
286     if options:
287         cmd.append(options)
288     cmd.append("{}".format(</b></font>sourcefile))
289     return __salt__["cmd.run"](
290         cmd, template=template, runas=runas, python_shell=False
291     ).splitlines()
292 @salt.utils.decorators.path.which("gunzip")
293 def gunzip(gzipfile, template=None, runas=None, options=None):
294     cmd = ["gunzip"]
295     if options:
296         cmd.append(options)
297     cmd.append("{}".format(gzipfile))
298     return __salt__["cmd.run"](
299         cmd, template=template, runas=runas, python_shell=False
300     ).splitlines()
301 @salt.utils.decorators.path.which("zip")
302 def cmd_zip(zip_file, sources, template=None, cwd=None, runas=None):
303     cmd = ["zip", "-r"]
304     cmd.append("{}".format(zip_file))
305     cmd.extend(_expand_sources(sources))
306     return __salt__["cmd.run"](
307         cmd, cwd=cwd, template=template, runas=runas, python_shell=False
308     ).splitlines()
309 @salt.utils.decorators.depends("zipfile", fallback_function=cmd_zip)
310 def zip_(zip_file, sources, template=None, cwd=None, runas=None, zip64=False):
311     if runas:
312         euid = os.geteuid()
313         egid = os.getegid()
314         uinfo = __salt__["user.info"](runas)
315         if not uinfo:
316             raise SaltInvocationError("User '{}' does not exist".format(runas))
317     zip_file, sources = _render_filenames(zip_file, sources, None, template)
318     sources = _expand_sources(sources)
319     if not cwd:
320         for src in sources:
321             if not os.path.isabs(src):
322                 raise SaltInvocationError("Relative paths require the 'cwd' parameter")
323     else:
324         err_msg = "cwd must be absolute"
325         try:
326             if not os.path.isabs(cwd):
327                 raise SaltInvocationError(err_msg)
328         except AttributeError:
329             raise SaltInvocationError(err_msg)
330     if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
331         os.setegid(uinfo["gid"])
332         os.seteuid(uinfo["uid"])
333     try:
334         exc = None
335         archived_files = []
336         with contextlib.closing(
337             zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED, zip64)
338         ) as zfile:
339             for src in sources:
340                 if cwd:
341                     src = os.path.join(cwd, src)
342                 if os.path.exists(src):
343                     if os.path.isabs(src):
344                         rel_root = "/"
345                     else:
346                         rel_root = cwd if cwd is not None else "/"
347                     if os.path.isdir(src):
348                         for dir_name, sub_dirs, files in salt.utils.path.os_walk(src):
349                             if cwd and dir_name.startswith(cwd):
350                                 arc_dir = os.path.relpath(dir_name, cwd)
351                             else:
352                                 arc_dir = os.path.relpath(dir_name, rel_root)
353                             if arc_dir:
354                                 archived_files.append(arc_dir + "/")
355                                 zfile.write(dir_name, arc_dir)
356                             for filename in files:
357                                 abs_name = os.path.join(dir_name, filename)
358                                 arc_name = os.path.join(arc_dir, filename)
359                                 archived_files.append(arc_name)
360                                 zfile.write(abs_name, arc_name)
361                     else:
362                         if cwd and src.startswith(cwd):
363                             arc_name = os.path.relpath(src, cwd)
364                         else:
365                             arc_name = os.path.relpath(src, rel_root)
366                         archived_files.append(arc_name)
367                         zfile.write(src, arc_name)
368     except Exception as exc:  # pylint: disable=broad-except
369         pass
370     finally:
371         if runas:
372             os.seteuid(euid)
373             os.setegid(egid)
374         if exc is not None:
375             if exc == zipfile.LargeZipFile:
376                 raise CommandExecutionError(
377                     "Resulting zip file too large, would require ZIP64 support"
378                     "which has not been enabled. Rerun command with zip64=True"
379                 )
380             else:
381                 raise CommandExecutionError(
382                     "Exception encountered creating zipfile: {}".format(exc)
383                 )
384     return archived_files
385 @salt.utils.decorators.path.which("unzip")
386 def cmd_unzip(
387     zip_file,
388     dest,
389     excludes=None,
390     options=None,
391     template=None,
392     runas=None,
393     trim_output=False,
394     password=None,
395 ):
396     if isinstance(excludes, str):
397         excludes = [x.strip() for x in excludes.split(",")]
398     elif isinstance(excludes, (float, int)):
399         excludes = [str(excludes)]
400     cmd = ["unzip"]
401     if password:
402         cmd.extend(["-P", password])
403     if options:
404         cmd.extend(shlex.split(options))
405     cmd.extend(["{}".format(zip_file), "-d", "{}".format(dest)])
406     if excludes is not None:
407         cmd.append("-x")
408         cmd.extend(excludes)
409     result = __salt__["cmd.run_all"](
410         cmd,
411         template=template,
412         runas=runas,
413         python_shell=False,
414         redirect_stderr=True,
415         output_loglevel="quiet" if password else "debug",
416     )
417     if result["retcode"] != 0:
418         raise CommandExecutionError(result["stdout"])
419     return _trim_files(result["stdout"].splitlines(), trim_output)
420 def unzip(
421     zip_file,
422     dest,
423     excludes=None,
424     options=None,
425     template=None,
426     runas=None,
427     trim_output=False,
428     password=None,
429     extract_perms=True,
430 ):
431     if not excludes:
432         excludes = []
433     if runas:
434         euid = os.geteuid()
435         egid = os.getegid()
436         uinfo = __salt__["user.info"](runas)
437         if not uinfo:
438             raise SaltInvocationError("User '{}' does not exist".format(runas))
439     zip_file, dest = _render_filenames(zip_file, dest, None, template)
440     if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
441         os.setegid(uinfo["gid"])
442         os.seteuid(uinfo["uid"])
443     try:
444         cleaned_files = []
445         with contextlib.closing(zipfile.ZipFile(zip_file, "r")) as zfile:
446             files = zfile.namelist()
447             if isinstance(excludes, str):
448                 excludes = [x.strip() for x in excludes.split(",")]
449             elif isinstance(excludes, (float, int)):
450                 excludes = [str(excludes)]
451             cleaned_files.extend([x for x in files if x not in excludes])
452             for target in cleaned_files:
453                 if target not in excludes:
454                     if salt.utils.platform.is_windows() is False:
455                         info = zfile.getinfo(target)
456                         if stat.S_ISLNK(info.external_attr &gt;&gt; 16):
457                             source = zfile.read(target)
458                             os.symlink(source, os.path.join(dest, target))
459                             continue
460                     zfile.extract(target, dest, password)
461                     if extract_perms:
462                         if not salt.utils.platform.is_windows():
463                             perm = zfile.getinfo(target).external_attr &gt;&gt; 16
464                             if perm == 0:
465                                 umask_ = salt.utils.files.get_umask()
466                                 if target.endswith("/"):
467                                     perm = 0o777 &amp; ~umask_
468                                 else:
469                                     perm = 0o666 &amp; ~umask_
470                             os.chmod(os.path.join(dest, target), perm)
471                         else:
472                             win32_attr = zfile.getinfo(target).external_attr &amp; 0xFF
473                             win32file.SetFileAttributes(
474                                 os.path.join(dest, target), win32_attr
475                             )
476     except Exception as exc:  # pylint: disable=broad-except
477         if runas:
478             os.seteuid(euid)
479             os.setegid(egid)
480         raise CommandExecutionError(
481             "Exception encountered unpacking zipfile: {}".format(exc)
482         )
483     finally:
484         if runas:
485             os.seteuid(euid)
486             os.setegid(egid)
487     return _trim_files(cleaned_files, trim_output)
488 def is_encrypted(name, clean=False, saltenv="base", source_hash=None, use_etag=False):
489     cached = __salt__["cp.cache_file"](
490         name, saltenv, source_hash=source_hash, use_etag=use_etag
491     )
492     if not cached:
493         raise CommandExecutionError("Failed to cache {}".format(name))
494     archive_info = {"archive location": cached}
495     try:
496         with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
497             zip_archive.testzip()
498     except RuntimeError:
499         ret = True
500     except zipfile.BadZipfile:
501         raise CommandExecutionError(
502             "{} is not a ZIP file".format(name), info=archive_info
503         )
504     except Exception as exc:  # pylint: disable=broad-except
505         raise CommandExecutionError(exc.__str__(), info=archive_info)
506     else:
507         ret = False
508     if clean:
509         try:
510             os.remove(cached)
511             log.debug("Cleaned cached archive %s", cached)
512         except OSError as exc:
513             if exc.errno != errno.ENOENT:
514                 log.warning(
515                     "Failed to clean cached archive %s: %s", cached, exc.__str__()
516                 )
517     return ret
518 @salt.utils.decorators.path.which("rar")
519 def rar(rarfile, sources, template=None, cwd=None, runas=None):
520     cmd = ["rar", "a", "-idp", "{}".format(rarfile)]
521     cmd.extend(_expand_sources(sources))
522     return __salt__["cmd.run"](
523         cmd, cwd=cwd, template=template, runas=runas, python_shell=False
524     ).splitlines()
525 @salt.utils.decorators.path.which_bin(("unrar", "rar"))
526 def unrar(rarfile, dest, excludes=None, template=None, runas=None, trim_output=False):
527     if isinstance(excludes, str):
528         excludes = [entry.strip() for entry in excludes.split(",")]
529     cmd = [
530         salt.utils.path.which_bin(("unrar", "rar")),
531         "x",
532         "-idp",
533         "{}".format(rarfile),
534     ]
535     if excludes is not None:
536         for exclude in excludes:
537             cmd.extend(["-x", "{}".format(exclude)])
538     cmd.append("{}".format(dest))
539     files = __salt__["cmd.run"](
540         cmd, template=template, runas=runas, python_shell=False
541     ).splitlines()
542     return _trim_files(files, trim_output)
543 def _render_filenames(filenames, zip_file, saltenv, template):
544     if not template:
545         return (filenames, zip_file)
546     if template not in salt.utils.templates.TEMPLATE_REGISTRY:
547         raise CommandExecutionError(
548             "Attempted to render file paths with unavailable engine {}".format(template)
549         )
550     kwargs = {}
551     kwargs["salt"] = __salt__
552     kwargs["pillar"] = __pillar__
553     kwargs["grains"] = __grains__
554     kwargs["opts"] = __opts__
555     kwargs["saltenv"] = saltenv
556     def _render(contents):
557         tmp_path_fn = salt.utils.files.mkstemp()
558         with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
559             fp_.write(salt.utils.stringutils.to_str(contents))
560         data = salt.utils.templates.TEMPLATE_REGISTRY[template](
561             tmp_path_fn, to_str=True, **kwargs
562         )
563         salt.utils.files.safe_rm(tmp_path_fn)
564         if not data["result"]:
565             raise CommandExecutionError(
566                 "Failed to render file path with error: {}".format(data["data"])
567             )
568         else:
569             return data["data"]
570     filenames = _render(filenames)
571     zip_file = _render(zip_file)
572     return (filenames, zip_file)
573 def _trim_files(files, trim_output):
574     count = 100
575     if not isinstance(trim_output, bool):
576         count = trim_output
577     if (
578         not (isinstance(trim_output, bool) and trim_output is False)
579         and len(files) &gt; count
580     ):
581         files = files[:count]
582         files.append("List trimmed after {} files.".format(count))
583     return files
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
