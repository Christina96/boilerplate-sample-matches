<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zpool_1.py &amp; archive_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zpool_1.py &amp; archive_1.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zpool_1.py (1.0942761%)<th>archive_1.py (1.0433387%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1055-1097)<td><a href="#" name="0">(557-588)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zpool_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.path
from salt.utils.odict import OrderedDict
log = logging.getLogger(__name__)
__virtualname__ = "zpool"
__func_alias__ = {
    "import_": "import",
    "list_": "list",
}
def __virtual__():
    if __grains__.get("zfs_support"):
        return __virtualname__
    else:
        return False, "The zpool module cannot be loaded: zfs not supported"
def _clean_vdev_config(config):
    cln_config = OrderedDict()
    for label, sub_config in config.items():
        if label not in ["state", "read", "write", "cksum"]:
            sub_config = _clean_vdev_config(sub_config)
            if sub_config and isinstance(cln_config, list):
                cln_config.append(OrderedDict([(label, sub_config)]))
            elif sub_config and isinstance(cln_config, OrderedDict):
                cln_config[label] = sub_config
            elif isinstance(cln_config, list):
                cln_config.append(label)
            elif isinstance(cln_config, OrderedDict):
                new_config = []
                for old_label, old_config in cln_config.items():
                    new_config.append(OrderedDict([(old_label, old_config)]))
                new_config.append(label)
                cln_config = new_config
            else:
                cln_config = [label]
    return cln_config
def healthy():
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"]("status", flags=["-x"]),
        python_shell=False,
    )
    return res["stdout"] == "all pools are healthy"
def status(zpool=None):
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"]("status", target=zpool),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    current_pool = None
    current_prop = None
    for zpd in res["stdout"].splitlines():
        if zpd.strip() == "":
            continue
        if ":" in zpd and zpd[0] != "\t":
            prop = zpd.split(":")[0].strip()
            value = ":".join(zpd.split(":")[1:]).strip()
            if prop == "pool" and current_pool != value:
                current_pool = value
                ret[current_pool] = OrderedDict()
            if prop != "pool":
                ret[current_pool][prop] = value
            current_prop = prop
        else:
            ret[current_pool][current_prop] = "{}\n{}".format(
                ret[current_pool][current_prop], zpd
            )
    for pool in ret:
        if "config" not in ret[pool]:
            continue
        header = None
        root_vdev = None
        vdev = None
        dev = None
        rdev = None
        config = ret[pool]["config"]
        config_data = OrderedDict()
        for line in config.splitlines():
            if not header:
                header = line.strip().lower()
                header = [x for x in header.split(" ") if x not in [""]]
                continue
            if line[0] == "\t":
                line = line[1:]
            stat_data = OrderedDict(
                list(
                    zip(
                        header,
                        [x for x in line.strip().split(" ") if x not in [""]],
                    )
                )
            )
            stat_data = __utils__["zfs.from_auto_dict"](stat_data)
            if line.startswith(" " * 6):
                rdev = stat_data["name"]
                config_data[root_vdev][vdev][dev][rdev] = stat_data
            elif line.startswith(" " * 4):
                rdev = None
                dev = stat_data["name"]
                config_data[root_vdev][vdev][dev] = stat_data
            elif line.startswith(" " * 2):
                rdev = dev = None
                vdev = stat_data["name"]
                config_data[root_vdev][vdev] = stat_data
            else:
                rdev = dev = vdev = None
                root_vdev = stat_data["name"]
                config_data[root_vdev] = stat_data
            del stat_data["name"]
        ret[pool]["config"] = config_data
    return ret
def iostat(zpool=None, sample_time=5, parsable=True):
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="iostat", flags=["-v"], target=[zpool, sample_time, 2]
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    header = [
        "name",
        "capacity-alloc",
        "capacity-free",
        "operations-read",
        "operations-write",
        "bandwidth-read",
        "bandwidth-write",
    ]
    root_vdev = None
    vdev = None
    dev = None
    current_data = OrderedDict()
    for line in res["stdout"].splitlines():
        if line.strip() == "" or line.strip().split()[-1] in ["write", "bandwidth"]:
            continue
        if line.startswith("-") and line.endswith("-"):
            ret.update(current_data)
            current_data = OrderedDict()
            continue
        io_data = OrderedDict(
            list(
                zip(
                    header,
                    [x for x in line.strip().split(" ") if x not in [""]],
                )
            )
        )
        if parsable:
            io_data = __utils__["zfs.from_auto_dict"](io_data)
        else:
            io_data = __utils__["zfs.to_auto_dict"](io_data)
        if line.startswith(" " * 4):
            dev = io_data["name"]
            current_data[root_vdev][vdev][dev] = io_data
        elif line.startswith(" " * 2):
            dev = None
            vdev = io_data["name"]
            current_data[root_vdev][vdev] = io_data
        else:
            dev = vdev = None
            root_vdev = io_data["name"]
            current_data[root_vdev] = io_data
        del io_data["name"]
    return ret
def list_(properties="size,alloc,free,cap,frag,health", zpool=None, parsable=True):
    ret = OrderedDict()
    if not isinstance(properties, list):
        properties = properties.split(",")
    while "name" in properties:
        properties.remove("name")
    properties.insert(0, "name")
    if not __utils__["zfs.has_feature_flags"]():
        while "frag" in properties:
            properties.remove("frag")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="list",
            flags=["-H"],
            opts={"-o": ",".join(properties)},
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    for line in res["stdout"].splitlines():
        zpool_data = OrderedDict(
            list(
                zip(
                    properties,
                    line.strip().split("\t"),
                )
            )
        )
        if parsable:
            zpool_data = __utils__["zfs.from_auto_dict"](zpool_data)
        else:
            zpool_data = __utils__["zfs.to_auto_dict"](zpool_data)
        ret[zpool_data["name"]] = zpool_data
        del ret[zpool_data["name"]]["name"]
    return ret
def get(zpool, prop=None, show_source=False, parsable=True):
    ret = OrderedDict()
    value_properties = ["name", "property", "value", "source"]
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="get",
            flags=["-H"],
            property_name=prop if prop else "all",
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    for line in res["stdout"].splitlines():
        prop_data = OrderedDict(
            list(
                zip(
                    value_properties,
                    [x for x in line.strip().split("\t") if x not in [""]],
                )
            )
        )
        del prop_data["name"]
        if parsable:
            prop_data["value"] = __utils__["zfs.from_auto"](
                prop_data["property"], prop_data["value"]
            )
        else:
            prop_data["value"] = __utils__["zfs.to_auto"](
                prop_data["property"], prop_data["value"]
            )
        if show_source:
            ret[prop_data["property"]] = prop_data
            del ret[prop_data["property"]]["property"]
        else:
            ret[prop_data["property"]] = prop_data["value"]
    return ret
def set(zpool, prop, value):
    ret = OrderedDict()
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="set",
            property_name=prop,
            property_value=value,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "set")
def exists(zpool):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="list",
            target=zpool,
        ),
        python_shell=False,
        ignore_retcode=True,
    )
    return res["retcode"] == 0
def destroy(zpool, force=False):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="destroy",
            flags=["-f"] if force else None,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "destroyed")
def scrub(zpool, stop=False, pause=False):
    if stop:
        action = ["-s"]
    elif pause:
        action = ["-p"]
    else:
        action = None
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="scrub",
            flags=action,
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res, "scrubbing")
    ret = OrderedDict()
    if stop or pause:
        ret["scrubbing"] = False
    else:
        ret["scrubbing"] = True
    return ret
def create(zpool, *vdevs, **kwargs):
    flags = []
    opts = {}
    target = []
    pool_properties = kwargs.get("properties", {})
    filesystem_properties = kwargs.get("filesystem_properties", {})
    if kwargs.get("force", False):
        flags.append("-f")
    if kwargs.get("createboot", False) or "bootsize" in pool_properties:
        flags.append("-B")
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    if kwargs.get("mountpoint", False):
        opts["-m"] = kwargs.get("mountpoint")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="create",
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            filesystem_properties=filesystem_properties,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "created")
    if ret["created"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def add(zpool, *vdevs, **kwargs):
    flags = []
    target = []
    if kwargs.get("force", False):
        flags.append("-f")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="add",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "added")
    if ret["added"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def attach(zpool, device, new_device, force=False):
    flags = []
    target = []
    if force:
        flags.append("-f")
    target.append(zpool)
    target.append(device)
    target.append(new_device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="attach",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "attached")
    if ret["attached"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def detach(zpool, device):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="detach",
            target=[zpool, device],
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "detatched")
    if ret["detatched"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
def split(zpool, newzpool, **kwargs):
    opts = {}
    pool_properties = kwargs.get("properties", {})
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="split",
            opts=opts,
            pool_properties=pool_properties,
            target=[zpool, newzpool],
        ),
        python_shell=False,
    )
<a name="0"></a>    return __utils__["zfs.parse_command_result"](res, "split")
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def replace(zpool, old_device, new_device=None, force=False):
    flags = []
    target = []
    if force:
        flags.append("-f")
    target.append(zpool)
    target.append(</b></font>old_device)
    if new_device:
        target.append(new_device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="replace",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    ret = __utils__["zfs.parse_command_result"](res, "replaced")
    if ret["replaced"]:
        ret["vdevs"] = _clean_vdev_config(
            __salt__["zpool.status"](zpool=zpool)[zpool]["config"][zpool],
        )
    return ret
@salt.utils.decorators.path.which("mkfile")
def create_file_vdev(size, *vdevs):
    ret = OrderedDict()
    err = OrderedDict()
    _mkfile_cmd = salt.utils.path.which("mkfile")
    for vdev in vdevs:
        if os.path.isfile(vdev):
            ret[vdev] = "existed"
        else:
            res = __salt__["cmd.run_all"](
                "{mkfile} {size} {vdev}".format(
                    mkfile=_mkfile_cmd,
                    size=size,
                    vdev=vdev,
                ),
                python_shell=False,
            )
            if res["retcode"] != 0:
                if "stderr" in res and ":" in res["stderr"]:
                    ret[vdev] = "failed"
                    err[vdev] = ":".join(res["stderr"].strip().split(":")[1:])
            else:
                ret[vdev] = "created"
    if err:
        ret["error"] = err
    return ret
def export(*pools, **kwargs):
    flags = []
    targets = []
    if kwargs.get("force", False):
        flags.append("-f")
    targets = list(pools)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="export",
            flags=flags,
            target=targets,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "exported")
def import_(zpool=None, new_name=None, **kwargs):
    flags = []
    opts = {}
    target = []
    pool_properties = kwargs.get("properties", {})
    if kwargs.get("force", False) or kwargs.get("only_destroyed", False):
        flags.append("-f")
    if kwargs.get("only_destroyed", False):
        flags.append("-D")
    if kwargs.get("no_mount", False):
        flags.append("-N")
    if kwargs.get("altroot", False):
        opts["-R"] = kwargs.get("altroot")
    if kwargs.get("mntopts", False):
        opts["-o"] = kwargs.get("mntopts")
    if kwargs.get("dir", False):
        opts["-d"] = kwargs.get("dir").split(",")
    if kwargs.get("recovery", False) and __utils__["zfs.has_feature_flags"]():
        recovery = kwargs.get("recovery")
        if recovery in [True, "test"]:
            flags.append("-F")
        if recovery == "test":
            flags.append("-n")
        if recovery == "nolog":
            flags.append("-m")
    if zpool:
        target.append(zpool)
        target.append(new_name)
    else:
        flags.append("-a")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="import",
            flags=flags,
            opts=opts,
            pool_properties=pool_properties,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "imported")
def online(zpool, *vdevs, **kwargs):
    flags = []
    target = []
    if kwargs.get("expand", False):
        flags.append("-e")
    target.append(zpool)
    if vdevs:
        target.extend(vdevs)
    flags = []
    target = []
    if kwargs.get("expand", False):
        flags.append("-e")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="online",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "onlined")
def offline(zpool, *vdevs, **kwargs):
    flags = []
    target = []
    if kwargs.get("temporary", False):
        flags.append("-t")
    target.append(zpool)
    target.extend(vdevs)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="offline",
            flags=flags,
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "offlined")
def labelclear(device, force=False):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="labelclear",
            flags=["-f"] if force else None,
            target=device,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "labelcleared")
def clear(zpool, device=None):
    target = []
    target.append(zpool)
    target.append(device)
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="clear",
            target=target,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "cleared")
def reguid(zpool):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="reguid",
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "reguided")
def reopen(zpool):
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="reopen",
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "reopened")
def upgrade(zpool=None, version=None):
    flags = []
    opts = {}
    if version:
        opts["-V"] = version
    if not zpool:
        flags.append("-a")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="upgrade",
            flags=flags,
            opts=opts,
            target=zpool,
        ),
        python_shell=False,
    )
    return __utils__["zfs.parse_command_result"](res, "upgraded")
def history(zpool=None, internal=False, verbose=False):
    ret = OrderedDict()
    flags = []
    if verbose:
        flags.append("-l")
    if internal:
        flags.append("-i")
    res = __salt__["cmd.run_all"](
        __utils__["zfs.zpool_command"](
            command="history",
            flags=flags,
            target=zpool,
        ),
        python_shell=False,
    )
    if res["retcode"] != 0:
        return __utils__["zfs.parse_command_result"](res)
    else:
        pool = "unknown"
        for line in res["stdout"].splitlines():
            if line.startswith("History for"):
                pool = line[13:-2]
                ret[pool] = OrderedDict()
            else:
                if line == "":
                    continue
                log_timestamp = line[0:19]
                log_command = line[20:]
                ret[pool][log_timestamp] = log_command
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import contextlib
import copy
import errno
import glob
import logging
import os
import re
import shlex
import stat
import subprocess
import tarfile
import urllib.parse
import zipfile
import salt.utils.decorators
import salt.utils.decorators.path
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
from salt.exceptions import CommandExecutionError, SaltInvocationError
try:
    import rarfile
    HAS_RARFILE = True
except ImportError:
    HAS_RARFILE = False
if salt.utils.platform.is_windows():
    import win32file
__func_alias__ = {"zip_": "zip", "list_": "list"}
log = logging.getLogger(__name__)
def list_(
    name,
    archive_format=None,
    options=None,
    strip_components=None,
    clean=False,
    verbose=False,
    saltenv="base",
    source_hash=None,
    use_etag=False,
):
    def _list_tar(name, cached, decompress_cmd, failhard=False):
        dirs = []
        files = []
        links = []
        try:
            open_kwargs = (
                {"name": cached}
                if not isinstance(cached, subprocess.Popen)
                else {"fileobj": cached.stdout, "mode": "r|"}
            )
            with contextlib.closing(tarfile.open(**open_kwargs)) as tar_archive:
                for member in tar_archive.getmembers():
                    _member = salt.utils.data.decode(member.name)
                    if member.issym():
                        links.append(_member)
                    elif member.isdir():
                        dirs.append(_member + "/")
                    else:
                        files.append(_member)
            return dirs, files, links
        except tarfile.ReadError:
            if failhard:
                if isinstance(cached, subprocess.Popen):
                    stderr = cached.communicate()[1]
                    if cached.returncode != 0:
                        raise CommandExecutionError(
                            "Failed to decompress {}".format(name),
                            info={"error": stderr},
                        )
            else:
                if not salt.utils.path.which("tar"):
                    raise CommandExecutionError("'tar' command not available")
                if decompress_cmd is not None and isinstance(decompress_cmd, str):
                    try:
                        decompress_cmd = [
                            shlex.quote(x) for x in shlex.split(decompress_cmd)
                        ]
                    except AttributeError:
                        raise CommandExecutionError("Invalid CLI options")
                else:
                    if (
                        salt.utils.path.which("xz")
                        and __salt__["cmd.retcode"](
                            ["xz", "-t", cached],
                            python_shell=False,
                            ignore_retcode=True,
                        )
                        == 0
                    ):
                        decompress_cmd = ["xz", "--decompress", "--stdout"]
                if decompress_cmd:
                    decompressed = subprocess.Popen(
                        decompress_cmd + [shlex.quote(cached)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                    )
                    return _list_tar(name, decompressed, None, True)
        raise CommandExecutionError(
            "Unable to list contents of {}. If this is an XZ-compressed tar "
            "archive, install XZ Utils to enable listing its contents. If it "
            "is compressed using something other than XZ, it may be necessary "
            "to specify CLI options to decompress the archive. See the "
            "documentation for details.".format(name)
        )
    def _list_zip(name, cached):
        dirs = set()
        files = []
        links = []
        try:
            with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
                for member in zip_archive.infolist():
                    path = member.filename
                    if salt.utils.platform.is_windows():
                        if path.endswith("/"):
                            dirs.add(path)
                        else:
                            files.append(path)
                    else:
                        mode = member.external_attr &gt;&gt; 16
                        if stat.S_ISLNK(mode):
                            links.append(path)
                        elif stat.S_ISDIR(mode):
                            dirs.add(path)
                        else:
                            files.append(path)
                _files = copy.deepcopy(files)
                for path in _files:
                    dirname = "".join(path.rpartition("/")[:2])
                    if dirname:
                        dirs.add(dirname)
                        if dirname in files:
                            files.remove(dirname)
            return list(dirs), files, links
        except zipfile.BadZipfile:
            raise CommandExecutionError("{} is not a ZIP file".format(name))
    def _list_rar(name, cached):
        dirs = []
        files = []
        if HAS_RARFILE:
            with rarfile.RarFile(cached) as rf:
                for member in rf.infolist():
                    path = member.filename.replace("\\", "/")
                    if member.isdir():
                        dirs.append(path + "/")
                    else:
                        files.append(path)
        else:
            if not salt.utils.path.which("rar"):
                raise CommandExecutionError(
                    "rar command not available, is it installed?"
                )
            output = __salt__["cmd.run"](
                ["rar", "lt", name], python_shell=False, ignore_retcode=False
            )
            matches = re.findall(r"Name:\s*([^\n]+)\s*Type:\s*([^\n]+)", output)
            for path, type_ in matches:
                if type_ == "Directory":
                    dirs.append(path + "/")
                else:
                    files.append(path)
            if not dirs and not files:
                raise CommandExecutionError(
                    "Failed to list {}, is it a rar file? If so, the "
                    "installed version of rar may be too old to list data in "
                    "a parsable format. Installing the rarfile Python module "
                    "may be an easier workaround if newer rar is not readily "
                    "available.".format(name),
                    info={"error": output},
                )
        return dirs, files, []
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    try:
        if strip_components:
            try:
                int(strip_components)
            except ValueError:
                strip_components = -1
            if strip_components &lt;= 0:
                raise CommandExecutionError(
                    "'strip_components' must be a positive integer"
                )
        parsed = urllib.parse.urlparse(name)
        path = parsed.path or parsed.netloc
        def _unsupported_format(archive_format):
            if archive_format is None:
                raise CommandExecutionError(
                    "Unable to guess archive format, please pass an "
                    "'archive_format' argument."
                )
            raise CommandExecutionError(
                "Unsupported archive format '{}'".format(archive_format)
            )
        if not archive_format:
            guessed_format = salt.utils.files.guess_archive_type(path)
            if guessed_format is None:
                _unsupported_format(archive_format)
            archive_format = guessed_format
        func = locals().get("_list_" + archive_format)
        if not hasattr(func, "__call__"):
            _unsupported_format(archive_format)
        args = (options,) if archive_format == "tar" else ()
        try:
            dirs, files, links = func(name, cached, *args)
        except OSError as exc:
            raise CommandExecutionError(
                "Failed to list contents of {}: {}".format(name, exc.__str__())
            )
        except CommandExecutionError as exc:
            raise
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                "Uncaught exception '{}' when listing contents of {}".format(exc, name)
            )
        if clean:
            try:
                os.remove(cached)
                log.debug("Cleaned cached archive %s", cached)
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    log.warning(
                        "Failed to clean cached archive %s: %s", cached, exc.__str__()
                    )
        if strip_components:
            for item in (dirs, files, links):
                for index, path in enumerate(item):
                    try:
                        item[index] = item[index].split(os.sep, strip_components)[
                            strip_components
                        ]
                    except IndexError:
                        item[index] = ""
                item[:] = (x for x in item if x)
                item.sort()
        if verbose:
            ret = {
                "dirs": sorted(salt.utils.data.decode_list(dirs)),
                "files": sorted(salt.utils.data.decode_list(files)),
                "links": sorted(salt.utils.data.decode_list(links)),
            }
            ret["top_level_dirs"] = [x for x in ret["dirs"] if x.count("/") == 1]
            ret["top_level_files"] = [x for x in ret["files"] if x.count("/") == 0]
            ret["top_level_links"] = [x for x in ret["links"] if x.count("/") == 0]
        else:
            ret = sorted(dirs + files + links)
        return ret
    except CommandExecutionError as exc:
        info = exc.info or {}
        info["archive location"] = cached
        raise CommandExecutionError(exc.error, info=info)
_glob_wildcards = re.compile("[*?[]")
def _glob(pathname):
    if _glob_wildcards.search(pathname) is None:
        return [pathname]
    else:
        return glob.glob(pathname)
def _expand_sources(sources):
    if sources is None:
        return []
    if isinstance(sources, str):
        sources = [x.strip() for x in sources.split(",")]
    elif isinstance(sources, (float, int)):
        sources = [str(sources)]
    return [path for source in sources for path in _glob(source)]
@salt.utils.decorators.path.which("tar")
def tar(options, tarfile, sources=None, dest=None, cwd=None, template=None, runas=None):
    if not options:
        raise SaltInvocationError("Tar options can not be empty")
    cmd = ["tar"]
    if options:
        cmd.extend(options.split())
    cmd.extend(["{}".format(tarfile)])
    cmd.extend(_expand_sources(sources))
    if dest:
        cmd.extend(["-C", "{}".format(dest)])
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
<a name="0"></a>
@salt.utils.decorators.path.which("gzip")
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def gzip(sourcefile, template=None, runas=None, options=None):
    cmd = ["gzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(</b></font>sourcefile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("gunzip")
def gunzip(gzipfile, template=None, runas=None, options=None):
    cmd = ["gunzip"]
    if options:
        cmd.append(options)
    cmd.append("{}".format(gzipfile))
    return __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which("zip")
def cmd_zip(zip_file, sources, template=None, cwd=None, runas=None):
    cmd = ["zip", "-r"]
    cmd.append("{}".format(zip_file))
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.depends("zipfile", fallback_function=cmd_zip)
def zip_(zip_file, sources, template=None, cwd=None, runas=None, zip64=False):
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, sources = _render_filenames(zip_file, sources, None, template)
    sources = _expand_sources(sources)
    if not cwd:
        for src in sources:
            if not os.path.isabs(src):
                raise SaltInvocationError("Relative paths require the 'cwd' parameter")
    else:
        err_msg = "cwd must be absolute"
        try:
            if not os.path.isabs(cwd):
                raise SaltInvocationError(err_msg)
        except AttributeError:
            raise SaltInvocationError(err_msg)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        exc = None
        archived_files = []
        with contextlib.closing(
            zipfile.ZipFile(zip_file, "w", zipfile.ZIP_DEFLATED, zip64)
        ) as zfile:
            for src in sources:
                if cwd:
                    src = os.path.join(cwd, src)
                if os.path.exists(src):
                    if os.path.isabs(src):
                        rel_root = "/"
                    else:
                        rel_root = cwd if cwd is not None else "/"
                    if os.path.isdir(src):
                        for dir_name, sub_dirs, files in salt.utils.path.os_walk(src):
                            if cwd and dir_name.startswith(cwd):
                                arc_dir = os.path.relpath(dir_name, cwd)
                            else:
                                arc_dir = os.path.relpath(dir_name, rel_root)
                            if arc_dir:
                                archived_files.append(arc_dir + "/")
                                zfile.write(dir_name, arc_dir)
                            for filename in files:
                                abs_name = os.path.join(dir_name, filename)
                                arc_name = os.path.join(arc_dir, filename)
                                archived_files.append(arc_name)
                                zfile.write(abs_name, arc_name)
                    else:
                        if cwd and src.startswith(cwd):
                            arc_name = os.path.relpath(src, cwd)
                        else:
                            arc_name = os.path.relpath(src, rel_root)
                        archived_files.append(arc_name)
                        zfile.write(src, arc_name)
    except Exception as exc:  # pylint: disable=broad-except
        pass
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        if exc is not None:
            if exc == zipfile.LargeZipFile:
                raise CommandExecutionError(
                    "Resulting zip file too large, would require ZIP64 support"
                    "which has not been enabled. Rerun command with zip64=True"
                )
            else:
                raise CommandExecutionError(
                    "Exception encountered creating zipfile: {}".format(exc)
                )
    return archived_files
@salt.utils.decorators.path.which("unzip")
def cmd_unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
):
    if isinstance(excludes, str):
        excludes = [x.strip() for x in excludes.split(",")]
    elif isinstance(excludes, (float, int)):
        excludes = [str(excludes)]
    cmd = ["unzip"]
    if password:
        cmd.extend(["-P", password])
    if options:
        cmd.extend(shlex.split(options))
    cmd.extend(["{}".format(zip_file), "-d", "{}".format(dest)])
    if excludes is not None:
        cmd.append("-x")
        cmd.extend(excludes)
    result = __salt__["cmd.run_all"](
        cmd,
        template=template,
        runas=runas,
        python_shell=False,
        redirect_stderr=True,
        output_loglevel="quiet" if password else "debug",
    )
    if result["retcode"] != 0:
        raise CommandExecutionError(result["stdout"])
    return _trim_files(result["stdout"].splitlines(), trim_output)
def unzip(
    zip_file,
    dest,
    excludes=None,
    options=None,
    template=None,
    runas=None,
    trim_output=False,
    password=None,
    extract_perms=True,
):
    if not excludes:
        excludes = []
    if runas:
        euid = os.geteuid()
        egid = os.getegid()
        uinfo = __salt__["user.info"](runas)
        if not uinfo:
            raise SaltInvocationError("User '{}' does not exist".format(runas))
    zip_file, dest = _render_filenames(zip_file, dest, None, template)
    if runas and (euid != uinfo["uid"] or egid != uinfo["gid"]):
        os.setegid(uinfo["gid"])
        os.seteuid(uinfo["uid"])
    try:
        cleaned_files = []
        with contextlib.closing(zipfile.ZipFile(zip_file, "r")) as zfile:
            files = zfile.namelist()
            if isinstance(excludes, str):
                excludes = [x.strip() for x in excludes.split(",")]
            elif isinstance(excludes, (float, int)):
                excludes = [str(excludes)]
            cleaned_files.extend([x for x in files if x not in excludes])
            for target in cleaned_files:
                if target not in excludes:
                    if salt.utils.platform.is_windows() is False:
                        info = zfile.getinfo(target)
                        if stat.S_ISLNK(info.external_attr &gt;&gt; 16):
                            source = zfile.read(target)
                            os.symlink(source, os.path.join(dest, target))
                            continue
                    zfile.extract(target, dest, password)
                    if extract_perms:
                        if not salt.utils.platform.is_windows():
                            perm = zfile.getinfo(target).external_attr &gt;&gt; 16
                            if perm == 0:
                                umask_ = salt.utils.files.get_umask()
                                if target.endswith("/"):
                                    perm = 0o777 &amp; ~umask_
                                else:
                                    perm = 0o666 &amp; ~umask_
                            os.chmod(os.path.join(dest, target), perm)
                        else:
                            win32_attr = zfile.getinfo(target).external_attr &amp; 0xFF
                            win32file.SetFileAttributes(
                                os.path.join(dest, target), win32_attr
                            )
    except Exception as exc:  # pylint: disable=broad-except
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
        raise CommandExecutionError(
            "Exception encountered unpacking zipfile: {}".format(exc)
        )
    finally:
        if runas:
            os.seteuid(euid)
            os.setegid(egid)
    return _trim_files(cleaned_files, trim_output)
def is_encrypted(name, clean=False, saltenv="base", source_hash=None, use_etag=False):
    cached = __salt__["cp.cache_file"](
        name, saltenv, source_hash=source_hash, use_etag=use_etag
    )
    if not cached:
        raise CommandExecutionError("Failed to cache {}".format(name))
    archive_info = {"archive location": cached}
    try:
        with contextlib.closing(zipfile.ZipFile(cached)) as zip_archive:
            zip_archive.testzip()
    except RuntimeError:
        ret = True
    except zipfile.BadZipfile:
        raise CommandExecutionError(
            "{} is not a ZIP file".format(name), info=archive_info
        )
    except Exception as exc:  # pylint: disable=broad-except
        raise CommandExecutionError(exc.__str__(), info=archive_info)
    else:
        ret = False
    if clean:
        try:
            os.remove(cached)
            log.debug("Cleaned cached archive %s", cached)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                log.warning(
                    "Failed to clean cached archive %s: %s", cached, exc.__str__()
                )
    return ret
@salt.utils.decorators.path.which("rar")
def rar(rarfile, sources, template=None, cwd=None, runas=None):
    cmd = ["rar", "a", "-idp", "{}".format(rarfile)]
    cmd.extend(_expand_sources(sources))
    return __salt__["cmd.run"](
        cmd, cwd=cwd, template=template, runas=runas, python_shell=False
    ).splitlines()
@salt.utils.decorators.path.which_bin(("unrar", "rar"))
def unrar(rarfile, dest, excludes=None, template=None, runas=None, trim_output=False):
    if isinstance(excludes, str):
        excludes = [entry.strip() for entry in excludes.split(",")]
    cmd = [
        salt.utils.path.which_bin(("unrar", "rar")),
        "x",
        "-idp",
        "{}".format(rarfile),
    ]
    if excludes is not None:
        for exclude in excludes:
            cmd.extend(["-x", "{}".format(exclude)])
    cmd.append("{}".format(dest))
    files = __salt__["cmd.run"](
        cmd, template=template, runas=runas, python_shell=False
    ).splitlines()
    return _trim_files(files, trim_output)
def _render_filenames(filenames, zip_file, saltenv, template):
    if not template:
        return (filenames, zip_file)
    if template not in salt.utils.templates.TEMPLATE_REGISTRY:
        raise CommandExecutionError(
            "Attempted to render file paths with unavailable engine {}".format(template)
        )
    kwargs = {}
    kwargs["salt"] = __salt__
    kwargs["pillar"] = __pillar__
    kwargs["grains"] = __grains__
    kwargs["opts"] = __opts__
    kwargs["saltenv"] = saltenv
    def _render(contents):
        tmp_path_fn = salt.utils.files.mkstemp()
        with salt.utils.files.fopen(tmp_path_fn, "w+") as fp_:
            fp_.write(salt.utils.stringutils.to_str(contents))
        data = salt.utils.templates.TEMPLATE_REGISTRY[template](
            tmp_path_fn, to_str=True, **kwargs
        )
        salt.utils.files.safe_rm(tmp_path_fn)
        if not data["result"]:
            raise CommandExecutionError(
                "Failed to render file path with error: {}".format(data["data"])
            )
        else:
            return data["data"]
    filenames = _render(filenames)
    zip_file = _render(zip_file)
    return (filenames, zip_file)
def _trim_files(files, trim_output):
    count = 100
    if not isinstance(trim_output, bool):
        count = trim_output
    if (
        not (isinstance(trim_output, bool) and trim_output is False)
        and len(files) &gt; count
    ):
        files = files[:count]
        files.append("List trimmed after {} files.".format(count))
    return files
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
