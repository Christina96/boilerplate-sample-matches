<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win.py &amp; netacl.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win.py &amp; netacl.py
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win.py (2.667457%)<th>netacl.py (25.714285%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(108-139)<td><a href="#" name="0">(454-659)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(84-103)<td><a href="#" name="1">(96-425)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1293-1309)<td><a href="#" name="2">(683-698)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import collections
2 import ctypes
3 import logging
4 import os
5 from ctypes import wintypes
6 import ntsecuritycon
7 import psutil
8 import win32api
9 import win32con
10 import win32process
11 import win32security
12 import win32service
13 log = logging.getLogger(__name__)
14 ntdll = ctypes.WinDLL("ntdll")
15 secur32 = ctypes.WinDLL("secur32")
16 kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
17 advapi32 = ctypes.WinDLL("advapi32", use_last_error=True)
18 userenv = ctypes.WinDLL("userenv", use_last_error=True)
19 SYSTEM_SID = "S-1-5-18"
20 LOCAL_SRV_SID = "S-1-5-19"
21 NETWORK_SRV_SID = "S-1-5-19"
22 LOGON_WITH_PROFILE = 0x00000001
23 WINSTA_ALL = (
24     win32con.WINSTA_ACCESSCLIPBOARD
25     | win32con.WINSTA_ACCESSGLOBALATOMS
26     | win32con.WINSTA_CREATEDESKTOP
27     | win32con.WINSTA_ENUMDESKTOPS
28     | win32con.WINSTA_ENUMERATE
29     | win32con.WINSTA_EXITWINDOWS
30     | win32con.WINSTA_READATTRIBUTES
31     | win32con.WINSTA_READSCREEN
32     | win32con.WINSTA_WRITEATTRIBUTES
33     | win32con.DELETE
34     | win32con.READ_CONTROL
35     | win32con.WRITE_DAC
36     | win32con.WRITE_OWNER
37 )
38 DESKTOP_ALL = (
39     win32con.DESKTOP_CREATEMENU
40     | win32con.DESKTOP_CREATEWINDOW
41     | win32con.DESKTOP_ENUMERATE
42     | win32con.DESKTOP_HOOKCONTROL
43     | win32con.DESKTOP_JOURNALPLAYBACK
44     | win32con.DESKTOP_JOURNALRECORD
45     | win32con.DESKTOP_READOBJECTS
46     | win32con.DESKTOP_SWITCHDESKTOP
47     | win32con.DESKTOP_WRITEOBJECTS
48     | win32con.DELETE
49     | win32con.READ_CONTROL
50     | win32con.WRITE_DAC
51     | win32con.WRITE_OWNER
52 )
53 MAX_COMPUTER_NAME_LENGTH = 15
54 SECURITY_LOGON_TYPE = wintypes.ULONG
55 Interactive = 2
56 Network = 3
57 Batch = 4
58 Service = 5
59 PROFILE_BUFFER_TYPE = wintypes.ULONG
60 MsV1_0InteractiveLogon <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= 2
61 MsV1_0Lm20Logon = 3
62 MsV1_0NetworkLogon = 4
63 MsV1_0WorkstationUnlockLogon = 7
64 MsV1_0S4ULogon = 12
65 MsV1_0NoElevationLogon = 82
66 KerbInteractiveLogon = 2
67 KerbWorkstationUnlockLogon = 7
68 KerbS4ULogon = 12
69 MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS = 0x2
70 KERB_S4U_LOGON_FLAG_CHECK_LOGONHOURS = 0x2
71 KERB_S4U_LOGON_FLAG_IDENTITY = 0x8
72 TOKEN_SOURCE_LENGTH = 8
73 NEGOTIATE_PACKAGE_NAME = b"Negotiate"
74 MICROSOFT_KERBEROS_NAME =</b></font> b"Kerberos"
75 MSV1_0_PACKAGE_NAME = b"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
76 DELETE = 0x00010000
77 READ_CONTROL = 0x00020000
78 WRITE_DAC <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= 0x00040000
79 WRITE_OWNER = 0x00080000
80 STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
81 TOKEN_ASSIGN_PRIMARY = 0x0001
82 TOKEN_DUPLICATE = 0x0002
83 TOKEN_IMPERSONATE = 0x0004
84 TOKEN_QUERY = 0x0008
85 TOKEN_QUERY_SOURCE = 0x0010
86 TOKEN_ADJUST_PRIVILEGES = 0x0020
87 TOKEN_ADJUST_GROUPS = 0x0040
88 TOKEN_ADJUST_DEFAULT = 0x0080
89 TOKEN_ADJUST_SESSIONID = 0x0100
90 TOKEN_ALL_ACCESS = (
91     STANDARD_RIGHTS_REQUIRED
92     | TOKEN_ASSIGN_PRIMARY
93     | TOKEN_DUPLICATE
94     | TOKEN_IMPERSONATE
95     | TOKEN_QUERY
96     | TOKEN_QUERY_SOURCE
97     | TOKEN_ADJUST_PRIVILEGES
98     | TOKEN_ADJUST_GROUPS
99     | TOKEN_ADJUST_DEFAULT
100     | TOKEN_ADJUST_SESSIONID
101 )
102 DUPLICATE_CLOSE_SOURCE = 0x00000001
103 DUPLICATE_SAME_ACCESS = 0x00000002
104 TOKEN_TYPE = wintypes.</b></font>ULONG
105 TokenPrimary = 1
106 TokenImpersonation = 2
107 SECURITY_IMPERSONATION_LEVEL = wintypes.ULONG
108 SecurityAnonymous = 0
109 SecurityIdentification = 1
110 SecurityImpersonation = 2
111 SecurityDelegation = 3
112 class NTSTATUS(wintypes.LONG):
113     def to_error(self):
114         return ntdll.RtlNtStatusToDosError(self)
115     def __repr__(self):
116         name = self.__class__.__name__
117         status = wintypes.ULONG.from_buffer(self)
118         return "{}({})".format(name, status.value)
119 PNTSTATUS = ctypes.POINTER(NTSTATUS)
120 class BOOL(wintypes.BOOL):
121     def __repr__(self):
122         name = self.__class__.__name__
123         return "{}({})".format(name, bool(self))
124 class HANDLE(wintypes.HANDLE):
125     __slots__ = ("closed",)
126     def __int__(self):
127         return self.value or 0
128     def Detach(self):
129         if not getattr(self, "closed", False):
130             self.closed = True
131             value = int(self)
132             self.value = None
133             return value
134         raise ValueError("already closed")
135     def Close(self, CloseHandle=kernel32.CloseHandle):
136         if self and not getattr(self, "closed", False):
137             CloseHandle(self.Detach())
138     __del__ = Close
139     def __repr__(self):
140         return "{}({})".format(self.__class__.__name__, int(self))
141 class LARGE_INTEGER(wintypes.LARGE_INTEGER):
142     ntdll.RtlSecondsSince1970ToTime.restype = None
143     _unix_epoch = wintypes.LARGE_INTEGER()
144     ntdll.RtlSecondsSince1970ToTime(0, ctypes.byref(_unix_epoch))
145     _unix_epoch = _unix_epoch.value
146     def __int__(self):
147         return self.value
148     def __repr__(self):
149         name = self.__class__.__name__
150         return "{}({})".format(name, self.value)
151     def as_time(self):
152         time100ns = self.value - self._unix_epoch
153         if time100ns &gt;= 0:
154             return time100ns / 1e7
155         raise ValueError("value predates the Unix epoch")
156     @classmethod
157     def from_time(cls, t):
158         time100ns = int(t * 10 ** 7)
159         return cls(time100ns + cls._unix_epoch)
160 CHAR = ctypes.c_char
161 WCHAR = ctypes.c_wchar
162 PCHAR = ctypes.POINTER(CHAR)
163 PWCHAR = ctypes.POINTER(WCHAR)
164 class STRING(ctypes.Structure):
165     _fields_ = (
166         ("Length", wintypes.USHORT),
167         ("MaximumLength", wintypes.USHORT),
168         ("Buffer", PCHAR),
169     )
170 LPSTRING = ctypes.POINTER(STRING)
171 class UNICODE_STRING(ctypes.Structure):
172     _fields_ = (
173         ("Length", wintypes.USHORT),
174         ("MaximumLength", wintypes.USHORT),
175         ("Buffer", PWCHAR),
176     )
177 LPUNICODE_STRING = ctypes.POINTER(UNICODE_STRING)
178 class LUID(ctypes.Structure):
179     _fields_ = (
180         ("LowPart", wintypes.DWORD),
181         ("HighPart", wintypes.LONG),
182     )
183     def __new__(cls, value=0):
184         return cls.from_buffer_copy(ctypes.c_ulonglong(value))
185     def __int__(self):
186         return ctypes.c_ulonglong.from_buffer(self).value
187     def __repr__(self):
188         name = self.__class__.__name__
189         return "{}({})".format(name, int(self))
190 LPLUID = ctypes.POINTER(LUID)
191 PSID = wintypes.LPVOID
192 class SID_AND_ATTRIBUTES(ctypes.Structure):
193     _fields_ = (
194         ("Sid", PSID),
195         ("Attributes", wintypes.DWORD),
196     )
197 LPSID_AND_ATTRIBUTES = ctypes.POINTER(SID_AND_ATTRIBUTES)
198 class TOKEN_GROUPS(ctypes.Structure):
199     _fields_ = (
200         ("GroupCount", wintypes.DWORD),
201         ("Groups", SID_AND_ATTRIBUTES * 1),
202     )
203 LPTOKEN_GROUPS = ctypes.POINTER(TOKEN_GROUPS)
204 class TOKEN_SOURCE(ctypes.Structure):
205     _fields_ = (
206         ("SourceName", CHAR * TOKEN_SOURCE_LENGTH),
207         ("SourceIdentifier", LUID),
208     )
209     def __init__(self, SourceName=None, SourceIdentifier=None):
210         super().__init__()
211         if SourceName is not None:
212             if not isinstance(SourceName, bytes):
213                 SourceName = SourceName.encode("mbcs")
214             self.SourceName = SourceName
215         if SourceIdentifier is None:
216             luid = self.SourceIdentifier
217             ntdll.NtAllocateLocallyUniqueId(ctypes.byref(luid))
218         else:
219             self.SourceIdentifier = SourceIdentifier
220 LPTOKEN_SOURCE = ctypes.POINTER(TOKEN_SOURCE)
221 py_source_context = TOKEN_SOURCE(b"PYTHON  ")
222 py_origin_name = __name__.encode()
223 py_logon_process_name = "{}-{}".format(py_origin_name, os.getpid())
224 SIZE_T = ctypes.c_size_t
225 class QUOTA_LIMITS(ctypes.Structure):
226     _fields_ = (
227         ("PagedPoolLimit", SIZE_T),
228         ("NonPagedPoolLimit", SIZE_T),
229         ("MinimumWorkingSetSize", SIZE_T),
230         ("MaximumWorkingSetSize", SIZE_T),
231         ("PagefileLimit", SIZE_T),
232         ("TimeLimit", wintypes.LARGE_INTEGER),
233     )
234 LPQUOTA_LIMITS = ctypes.POINTER(QUOTA_LIMITS)
235 LPULONG = ctypes.POINTER(wintypes.ULONG)
236 LSA_OPERATIONAL_MODE = wintypes.ULONG
237 LPLSA_OPERATIONAL_MODE = LPULONG
238 LPHANDLE = ctypes.POINTER(wintypes.HANDLE)
239 LPLPVOID = ctypes.POINTER(wintypes.LPVOID)
240 LPDWORD = ctypes.POINTER(wintypes.DWORD)
241 class ContiguousUnicode(ctypes.Structure):
242     def __init__(self, *args, **kwargs):  # pylint: disable=useless-super-delegation
243         super().__init__(*args, **kwargs)
244     def _get_unicode_string(self, name):
245         wchar_size = ctypes.sizeof(WCHAR)
246         s = getattr(self, "_{}".format(name))
247         length = s.Length // wchar_size
248         buf = s.Buffer
249         if buf:
250             return buf[:length]
251         return None
252     def _set_unicode_buffer(self, values):
253         cls = type(self)
254         wchar_size = ctypes.sizeof(WCHAR)
255         bufsize = (len("\x00".join(values)) + 1) * wchar_size
256         ctypes.resize(self, ctypes.sizeof(cls) + bufsize)
257         addr = ctypes.addressof(self) + ctypes.sizeof(cls)
258         for value in values:
259             bufsize = (len(value) + 1) * wchar_size
260             ctypes.memmove(addr, value, bufsize)
261             addr += bufsize
262     def _set_unicode_string(self, name, value):
263         values = []
264         for n in self._string_names_:
265             if n == name:
266                 values.append(value or "")
267             else:
268                 values.append(getattr(self, n) or "")
269         self._set_unicode_buffer(values)
270         cls = type(self)
271         wchar_size = ctypes.sizeof(WCHAR)
272         addr = ctypes.addressof(self) + ctypes.sizeof(cls)
273         for n, v in zip(self._string_names_, values):
274             ptr = ctypes.cast(addr, PWCHAR)
275             ustr = getattr(self, "_{}".format(n))
276             length = ustr.Length = len(v) * wchar_size
277             full_length = length + wchar_size
278             if (n == name and value is None) or (
279                 n != name and not (length or ustr.Buffer)
280             ):
281                 ustr.Buffer = None
282                 ustr.MaximumLength = 0
283             else:
284                 ustr.Buffer = ptr
285                 ustr.MaximumLength = full_length
286             addr += full_length
287     def __getattr__(self, name):
288         if name not in self._string_names_:
289             raise AttributeError
290         return self._get_unicode_string(name)
291     def __setattr__(self, name, value):
292         if name in self._string_names_:
293             self._set_unicode_string(name, value)
294         else:
295             super().__setattr__(name, value)
296     @classmethod
297     def from_address_copy(cls, address, size=None):
298         x = ctypes.Structure.__new__(cls)
299         if size is not None:
300             ctypes.resize(x, size)
301         ctypes.memmove(ctypes.byref(x), address, ctypes.sizeof(x))
302         delta = ctypes.addressof(x) - address
303         for n in cls._string_names_:
304             ustr = getattr(x, "_{}".format(n))
305             addr = ctypes.c_void_p.from_buffer(ustr.Buffer)
306             if addr:
307                 addr.value += delta
308         return x
309 class AuthInfo(ContiguousUnicode):
310     def __init__(self):
311         super().__init__()
312         self.MessageType = self._message_type_
313 class MSV1_0_INTERACTIVE_LOGON(AuthInfo):
314     _message_type_ = MsV1_0InteractiveLogon
315     _string_names_ = "LogonDomainName", "UserName", "Password"
316     _fields_ = (
317         ("MessageType", LOGON_SUBMIT_TYPE),
318         ("_LogonDomainName", UNICODE_STRING),
319         ("_UserName", UNICODE_STRING),
320         ("_Password", UNICODE_STRING),
321     )
322     def __init__(self, UserName=None, Password=None, LogonDomainName=None):
323         super().__init__()
324         if LogonDomainName is not None:
325             self.LogonDomainName = LogonDomainName
326         if UserName is not None:
327             self.UserName = UserName
328         if Password is not None:
329             self.Password = Password
330 class S4ULogon(AuthInfo):
331     _string_names_ = "UserPrincipalName", "DomainName"
332     _fields_ = (
333         ("MessageType", LOGON_SUBMIT_TYPE),
334         ("Flags", wintypes.ULONG),
335         ("_UserPrincipalName", UNICODE_STRING),
336         ("_DomainName", UNICODE_STRING),
337     )
338     def __init__(self, UserPrincipalName=None, DomainName=None, Flags=0):
339         super().__init__()
340         self.Flags = Flags
341         if UserPrincipalName is not None:
342             self.UserPrincipalName = UserPrincipalName
343         if DomainName is not None:
344             self.DomainName = DomainName
345 class MSV1_0_S4U_LOGON(S4ULogon):
346     _message_type_ = MsV1_0S4ULogon
347 class KERB_S4U_LOGON(S4ULogon):
348     _message_type_ = KerbS4ULogon
349 PMSV1_0_S4U_LOGON = ctypes.POINTER(MSV1_0_S4U_LOGON)
350 PKERB_S4U_LOGON = ctypes.POINTER(KERB_S4U_LOGON)
351 class ProfileBuffer(ContiguousUnicode):
352     def __init__(self):
353         super().__init__()
354         self.MessageType = self._message_type_
355 class MSV1_0_INTERACTIVE_PROFILE(ProfileBuffer):
356     _message_type_ = MsV1_0InteractiveLogon
357     _string_names_ = (
358         "LogonScript",
359         "HomeDirectory",
360         "FullName",
361         "ProfilePath",
362         "HomeDirectoryDrive",
363         "LogonServer",
364     )
365     _fields_ = (
366         ("MessageType", PROFILE_BUFFER_TYPE),
367         ("LogonCount", wintypes.USHORT),
368         ("BadPasswordCount", wintypes.USHORT),
369         ("LogonTime", LARGE_INTEGER),
370         ("LogoffTime", LARGE_INTEGER),
371         ("KickOffTime", LARGE_INTEGER),
372         ("PasswordLastSet", LARGE_INTEGER),
373         ("PasswordCanChange", LARGE_INTEGER),
374         ("PasswordMustChange", LARGE_INTEGER),
375         ("_LogonScript", UNICODE_STRING),
376         ("_HomeDirectory", UNICODE_STRING),
377         ("_FullName", UNICODE_STRING),
378         ("_ProfilePath", UNICODE_STRING),
379         ("_HomeDirectoryDrive", UNICODE_STRING),
380         ("_LogonServer", UNICODE_STRING),
381         ("UserFlags", wintypes.ULONG),
382     )
383 def _check_status(result, func, args):
384     if result.value &lt; 0:
385         raise ctypes.WinError(result.to_error())
386     return args
387 def _check_bool(result, func, args):
388     if not result:
389         raise ctypes.WinError(ctypes.get_last_error())
390     return args
391 INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value
392 INVALID_DWORD_VALUE = wintypes.DWORD(-1).value  # ~WinAPI
393 INFINITE = INVALID_DWORD_VALUE
394 STD_INPUT_HANDLE = wintypes.DWORD(-10).value
395 STD_OUTPUT_HANDLE = wintypes.DWORD(-11).value
396 STD_ERROR_HANDLE = wintypes.DWORD(-12).value
397 class SECURITY_ATTRIBUTES(ctypes.Structure):
398     _fields_ = (
399         ("nLength", wintypes.DWORD),
400         ("lpSecurityDescriptor", wintypes.LPVOID),
401         ("bInheritHandle", wintypes.BOOL),
402     )
403     def __init__(self, **kwds):
404         self.nLength = ctypes.sizeof(self)
405         super().__init__(**kwds)
406 LPSECURITY_ATTRIBUTES = ctypes.POINTER(SECURITY_ATTRIBUTES)
407 LPBYTE = ctypes.POINTER(wintypes.BYTE)
408 LPHANDLE = PHANDLE = ctypes.POINTER(ctypes.c_void_p)
409 LPDWORD = ctypes.POINTER(ctypes.c_ulong)
410 class STARTUPINFO(ctypes.Structure):
411     _fields_ = (
412         ("cb", wintypes.DWORD),
413         ("lpReserved", wintypes.LPWSTR),
414         ("lpDesktop", wintypes.LPWSTR),
415         ("lpTitle", wintypes.LPWSTR),
416         ("dwX", wintypes.DWORD),
417         ("dwY", wintypes.DWORD),
418         ("dwXSize", wintypes.DWORD),
419         ("dwYSize", wintypes.DWORD),
420         ("dwXCountChars", wintypes.DWORD),
421         ("dwYCountChars", wintypes.DWORD),
422         ("dwFillAttribute", wintypes.DWORD),
423         ("dwFlags", wintypes.DWORD),
424         ("wShowWindow", wintypes.WORD),
425         ("cbReserved2", wintypes.WORD),
426         ("lpReserved2", LPBYTE),
427         ("hStdInput", wintypes.HANDLE),
428         ("hStdOutput", wintypes.HANDLE),
429         ("hStdError", wintypes.HANDLE),
430     )
431     def __init__(self, **kwds):
432         self.cb = ctypes.sizeof(self)
433         super().__init__(**kwds)
434 LPSTARTUPINFO = ctypes.POINTER(STARTUPINFO)
435 class PROC_THREAD_ATTRIBUTE_LIST(ctypes.Structure):
436     pass
437 PPROC_THREAD_ATTRIBUTE_LIST = ctypes.POINTER(PROC_THREAD_ATTRIBUTE_LIST)
438 class STARTUPINFOEX(STARTUPINFO):
439     _fields_ = (("lpAttributeList", PPROC_THREAD_ATTRIBUTE_LIST),)
440 LPSTARTUPINFOEX = ctypes.POINTER(STARTUPINFOEX)
441 class PROCESS_INFORMATION(ctypes.Structure):
442     _fields_ = (
443         ("hProcess", wintypes.HANDLE),
444         ("hThread", wintypes.HANDLE),
445         ("dwProcessId", wintypes.DWORD),
446         ("dwThreadId", wintypes.DWORD),
447     )
448 LPPROCESS_INFORMATION = ctypes.POINTER(PROCESS_INFORMATION)
449 class HANDLE_IHV(wintypes.HANDLE):
450     pass
451 def errcheck_ihv(result, func, args):
452     if result.value == INVALID_HANDLE_VALUE:
453         raise ctypes.WinError(ctypes.get_last_error())
454     return result.value
455 class DWORD_IDV(wintypes.DWORD):
456     pass
457 def errcheck_idv(result, func, args):
458     if result.value == INVALID_DWORD_VALUE:
459         raise ctypes.WinError(ctypes.get_last_error())
460     return result.value
461 def errcheck_bool(result, func, args):
462     if not result:
463         raise ctypes.WinError(ctypes.get_last_error())
464     return args
465 def _win(func, restype, *argtypes):
466     func.restype = restype
467     func.argtypes = argtypes
468     if issubclass(restype, NTSTATUS):
469         func.errcheck = _check_status
470     elif issubclass(restype, BOOL):
471         func.errcheck = _check_bool
472     elif issubclass(restype, HANDLE_IHV):
473         func.errcheck = errcheck_ihv
474     elif issubclass(restype, DWORD_IDV):
475         func.errcheck = errcheck_idv
476     else:
477         func.errcheck = errcheck_bool
478 _win(kernel32.GetStdHandle, HANDLE_IHV, wintypes.DWORD)  # _In_ nStdHandle
479 _win(kernel32.CloseHandle, wintypes.BOOL, wintypes.HANDLE)  # _In_ hObject
480 _win(
481     kernel32.SetHandleInformation,
482     wintypes.BOOL,
483     wintypes.HANDLE,  # _In_ hObject
484     wintypes.DWORD,  # _In_ dwMask
485     wintypes.DWORD,
486 )  # _In_ dwFlags
487 _win(
488     kernel32.DuplicateHandle,
489     wintypes.BOOL,
490     wintypes.HANDLE,  # _In_  hSourceProcessHandle,
491     wintypes.HANDLE,  # _In_  hSourceHandle,
492     wintypes.HANDLE,  # _In_  hTargetProcessHandle,
493     LPHANDLE,  # _Out_ lpTargetHandle,
494     wintypes.DWORD,  # _In_  dwDesiredAccess,
495     wintypes.BOOL,  # _In_  bInheritHandle,
496     wintypes.DWORD,
497 )  # _In_  dwOptions
498 _win(kernel32.GetCurrentProcess, wintypes.HANDLE)
499 _win(
500     kernel32.GetExitCodeProcess,
501     wintypes.BOOL,
502     wintypes.HANDLE,  # _In_  hProcess,
503     LPDWORD,
504 )  # _Out_ lpExitCode
505 _win(
506     kernel32.CreatePipe,
507     wintypes.BOOL,
508     PHANDLE,  # _Out_    hReadPipe,
509     PHANDLE,  # _Out_    hWritePipe,
510     LPSECURITY_ATTRIBUTES,  # _In_opt_ lpPipeAttributes,
511     wintypes.DWORD,
512 )  # _In_     nSize
513 _win(
514     advapi32.CreateProcessWithLogonW,
515     wintypes.BOOL,
516     wintypes.LPCWSTR,  # _In_        lpUsername
517     wintypes.LPCWSTR,  # _In_opt_    lpDomain
518     wintypes.LPCWSTR,  # _In_        lpPassword
519     wintypes.DWORD,  # _In_        dwLogonFlags
520     wintypes.LPCWSTR,  # _In_opt_    lpApplicationName
521     wintypes.LPWSTR,  # _Inout_opt_ lpCommandLine
522     wintypes.DWORD,  # _In_        dwCreationFlags
523     wintypes.LPCWSTR,  # _In_opt_    lpEnvironment
524     wintypes.LPCWSTR,  # _In_opt_    lpCurrentDirectory
525     LPSTARTUPINFO,  # _In_        lpStartupInfo
526     LPPROCESS_INFORMATION,
527 )  # _Out_       lpProcessInformation
528 _win(kernel32.GetCurrentProcess, wintypes.HANDLE)
529 _win(
530     kernel32.DuplicateHandle,
531     BOOL,
532     wintypes.HANDLE,  # _In_  hSourceProcessHandle
533     wintypes.HANDLE,  # _In_  hSourceHandle
534     wintypes.HANDLE,  # _In_  hTargetProcessHandle
535     LPHANDLE,  # _Out_ lpTargetHandle
536     wintypes.DWORD,  # _In_  dwDesiredAccess
537     wintypes.BOOL,  # _In_  bInheritHandle
538     wintypes.DWORD,
539 )  # _In_  dwOptions
540 _win(
541     kernel32.GetComputerNameW, BOOL, wintypes.LPWSTR, LPDWORD  # _Out_   lpBuffer
542 )  # _Inout_ lpnSize
543 _win(
544     advapi32.OpenProcessToken,
545     BOOL,
546     wintypes.HANDLE,  # _In_  ProcessHandle
547     wintypes.DWORD,  # _In_  DesiredAccess
548     LPHANDLE,
549 )  # _Out_ TokenHandle
550 _win(
551     advapi32.DuplicateTokenEx,
552     BOOL,
553     wintypes.HANDLE,  # _In_     hExistingToken
554     wintypes.DWORD,  # _In_     dwDesiredAccess
555     LPSECURITY_ATTRIBUTES,  # _In_opt_ lpTokenAttributes
556     SECURITY_IMPERSONATION_LEVEL,  # _In_     ImpersonationLevel
557     TOKEN_TYPE,  # _In_     TokenType
558     LPHANDLE,
559 )  # _Out_    phNewToken
560 _win(ntdll.NtAllocateLocallyUniqueId, NTSTATUS, LPLUID)  # _Out_ LUID
561 _win(
562     secur32.LsaFreeReturnBuffer,
563     NTSTATUS,
564     wintypes.LPVOID,
565 )  # _In_ Buffer
566 _win(
567     secur32.LsaConnectUntrusted,
568     NTSTATUS,
569     LPHANDLE,
570 )  # _Out_ LsaHandle
571 _win(
572     secur32.LsaRegisterLogonProcess,
573     NTSTATUS,
574     LPSTRING,  # _In_  LogonProcessName
575     LPHANDLE,  # _Out_ LsaHandle
576     LPLSA_OPERATIONAL_MODE,
577 )  # _Out_ SecurityMode
578 _win(secur32.LsaDeregisterLogonProcess, NTSTATUS, wintypes.HANDLE)  # _In_ LsaHandle
579 _win(
580     secur32.LsaLookupAuthenticationPackage,
581     NTSTATUS,
582     wintypes.HANDLE,  # _In_  LsaHandle
583     LPSTRING,  # _In_  PackageName
584     LPULONG,
585 )  # _Out_ AuthenticationPackage
586 _win(
587     secur32.LsaLogonUser,
588     NTSTATUS,
589     wintypes.HANDLE,  # _In_     LsaHandle
590     LPSTRING,  # _In_     OriginName
591     SECURITY_LOGON_TYPE,  # _In_     LogonType
592     wintypes.ULONG,  # _In_     AuthenticationPackage
593     wintypes.LPVOID,  # _In_     AuthenticationInformation
594     wintypes.ULONG,  # _In_     AuthenticationInformationLength
595     LPTOKEN_GROUPS,  # _In_opt_ LocalGroups
596     LPTOKEN_SOURCE,  # _In_     SourceContext
597     LPLPVOID,  # _Out_    ProfileBuffer
598     LPULONG,  # _Out_    ProfileBufferLength
599     LPLUID,  # _Out_    LogonId
600     LPHANDLE,  # _Out_    Token
601     LPQUOTA_LIMITS,  # _Out_    Quotas
602     PNTSTATUS,
603 )  # _Out_    SubStatus
604 def duplicate_token(
605     source_token=None,
606     access=TOKEN_ALL_ACCESS,
607     impersonation_level=SecurityImpersonation,
608     token_type=TokenPrimary,
609     attributes=None,
610 ):
611     close_source = False
612     if source_token is None:
613         close_source = True
614         source_token = HANDLE()
615         advapi32.OpenProcessToken(
616             kernel32.GetCurrentProcess(), TOKEN_ALL_ACCESS, ctypes.byref(source_token)
617         )
618     token = HANDLE()
619     try:
620         advapi32.DuplicateTokenEx(
621             source_token,
622             access,
623             attributes,
624             impersonation_level,
625             token_type,
626             ctypes.byref(token),
627         )
628     finally:
629         if close_source:
630             source_token.Close()
631     return token
632 def lsa_connect_untrusted():
633     handle = wintypes.HANDLE()
634     secur32.LsaConnectUntrusted(ctypes.byref(handle))
635     return handle.value
636 def lsa_register_logon_process(logon_process_name):
637     if not isinstance(logon_process_name, bytes):
638         logon_process_name = logon_process_name.encode("mbcs")
639     logon_process_name = logon_process_name[:127]
640     buf = ctypes.create_string_buffer(logon_process_name, 128)
641     name = STRING(len(logon_process_name), len(buf), buf)
642     handle = wintypes.HANDLE()
643     mode = LSA_OPERATIONAL_MODE()
644     secur32.LsaRegisterLogonProcess(
645         ctypes.byref(name), ctypes.byref(handle), ctypes.byref(mode)
646     )
647     return handle.value
648 def lsa_lookup_authentication_package(lsa_handle, package_name):
649     if not isinstance(package_name, bytes):
650         package_name = package_name.encode("mbcs")
651     package_name = package_name[:127]
652     buf = ctypes.create_string_buffer(package_name)
653     name = STRING(len(package_name), len(buf), buf)
654     package = wintypes.ULONG()
655     secur32.LsaLookupAuthenticationPackage(
656         lsa_handle, ctypes.byref(name), ctypes.byref(package)
657     )
658     return package.value
659 LOGONINFO = collections.namedtuple(
660     "LOGONINFO", ("Token", "LogonId", "Profile", "Quotas")
661 )
662 def lsa_logon_user(
663     auth_info,
664     local_groups=None,
665     origin_name=py_origin_name,
666     source_context=None,
667     auth_package=None,
668     logon_type=None,
669     lsa_handle=None,
670 ):
671     if local_groups is None:
672         plocal_groups = LPTOKEN_GROUPS()
673     else:
674         plocal_groups = ctypes.byref(local_groups)
675     if source_context is None:
676         source_context = py_source_context
677     if not isinstance(origin_name, bytes):
678         origin_name = origin_name.encode("mbcs")
679     buf = ctypes.create_string_buffer(origin_name)
680     origin_name = STRING(len(origin_name), len(buf), buf)
681     if auth_package is None:
682         if isinstance(auth_info, MSV1_0_S4U_LOGON):
683             auth_package = NEGOTIATE_PACKAGE_NAME
684         elif isinstance(auth_info, KERB_S4U_LOGON):
685             auth_package = MICROSOFT_KERBEROS_NAME
686         else:
687             auth_package = MSV1_0_PACKAGE_NAME
688     if logon_type is None:
689         if isinstance(auth_info, S4ULogon):
690             logon_type = win32con.LOGON32_LOGON_NETWORK
691         else:
692             logon_type = Interactive
693     profile_buffer = wintypes.LPVOID()
694     profile_buffer_length = wintypes.ULONG()
695     profile = None
696     logonid = LUID()
697     htoken = HANDLE()
698     quotas = QUOTA_LIMITS()
699     substatus = NTSTATUS()
700     deregister = False
701     if lsa_handle is None:
702         lsa_handle = lsa_connect_untrusted()
703         deregister = True
704     try:
705         if isinstance(auth_package, (str, bytes)):
706             auth_package = lsa_lookup_authentication_package(lsa_handle, auth_package)
707         try:
708             secur32.LsaLogonUser(
709                 lsa_handle,
710                 ctypes.byref(origin_name),
711                 logon_type,
712                 auth_package,
713                 ctypes.byref(auth_info),
714                 ctypes.sizeof(auth_info),
715                 plocal_groups,
716                 ctypes.byref(source_context),
717                 ctypes.byref(profile_buffer),
718                 ctypes.byref(profile_buffer_length),
719                 ctypes.byref(logonid),
720                 ctypes.byref(htoken),
721                 ctypes.byref(quotas),
722                 ctypes.byref(substatus),
723             )
724         except OSError:
725             if substatus.value:
726                 raise ctypes.WinError(substatus.to_error())
727             raise
728         finally:
729             if profile_buffer:
730                 address = profile_buffer.value
731                 buftype = PROFILE_BUFFER_TYPE.from_address(address).value
732                 if buftype == MsV1_0InteractiveLogon:
733                     profile = MSV1_0_INTERACTIVE_PROFILE.from_address_copy(
734                         address, profile_buffer_length.value
735                     )
736                 secur32.LsaFreeReturnBuffer(address)
737     finally:
738         if deregister:
739             secur32.LsaDeregisterLogonProcess(lsa_handle)
740     return LOGONINFO(htoken, logonid, profile, quotas)
741 def logon_msv1(
742     name,
743     password,
744     domain=None,
745     local_groups=None,
746     origin_name=py_origin_name,
747     source_context=None,
748 ):
749     return lsa_logon_user(
750         MSV1_0_INTERACTIVE_LOGON(name, password, domain),
751         local_groups,
752         origin_name,
753         source_context,
754     )
755 def logon_msv1_s4u(
756     name, local_groups=None, origin_name=py_origin_name, source_context=None
757 ):
758     domain = ctypes.create_unicode_buffer(MAX_COMPUTER_NAME_LENGTH + 1)
759     length = wintypes.DWORD(len(domain))
760     kernel32.GetComputerNameW(domain, ctypes.byref(length))
761     return lsa_logon_user(
762         MSV1_0_S4U_LOGON(name, domain.value), local_groups, origin_name, source_context
763     )
764 def logon_kerb_s4u(
765     name,
766     realm=None,
767     local_groups=None,
768     origin_name=py_origin_name,
769     source_context=None,
770     logon_process_name=py_logon_process_name,
771 ):
772     lsa_handle = lsa_register_logon_process(logon_process_name)
773     try:
774         return lsa_logon_user(
775             KERB_S4U_LOGON(name, realm),
776             local_groups,
777             origin_name,
778             source_context,
779             lsa_handle=lsa_handle,
780         )
781     finally:
782         secur32.LsaDeregisterLogonProcess(lsa_handle)
783 def DuplicateHandle(
784     hsrc=kernel32.GetCurrentProcess(),
785     srchandle=kernel32.GetCurrentProcess(),
786     htgt=kernel32.GetCurrentProcess(),
787     access=0,
788     inherit=False,
789     options=win32con.DUPLICATE_SAME_ACCESS,
790 ):
791     tgthandle = wintypes.HANDLE()
792     kernel32.DuplicateHandle(
793         hsrc, srchandle, htgt, ctypes.byref(tgthandle), access, inherit, options
794     )
795     return tgthandle.value
796 def CreatePipe(inherit_read=False, inherit_write=False):
797     read, write = wintypes.HANDLE(), wintypes.HANDLE()
798     kernel32.CreatePipe(ctypes.byref(read), ctypes.byref(write), None, 0)
799     if inherit_read:
800         kernel32.SetHandleInformation(
801             read, win32con.HANDLE_FLAG_INHERIT, win32con.HANDLE_FLAG_INHERIT
802         )
803     if inherit_write:
804         kernel32.SetHandleInformation(
805             write, win32con.HANDLE_FLAG_INHERIT, win32con.HANDLE_FLAG_INHERIT
806         )
807     return read.value, write.value
808 def set_user_perm(obj, perm, sid):
809     info = (
810         win32security.OWNER_SECURITY_INFORMATION
811         | win32security.GROUP_SECURITY_INFORMATION
812         | win32security.DACL_SECURITY_INFORMATION
813     )
814     sd = win32security.GetUserObjectSecurity(obj, info)
815     dacl = sd.GetSecurityDescriptorDacl()
816     ace_cnt = dacl.GetAceCount()
817     found = False
818     for idx in range(0, ace_cnt):
819         (aceType, aceFlags), ace_mask, ace_sid = dacl.GetAce(idx)
820         ace_exists = (
821             aceType == ntsecuritycon.ACCESS_ALLOWED_ACE_TYPE
822             and ace_mask == perm
823             and ace_sid == sid
824         )
825         if ace_exists:
826             break
827     else:
828         dacl.AddAccessAllowedAce(dacl.GetAclRevision(), perm, sid)
829         sd.SetSecurityDescriptorDacl(1, dacl, 0)
830         win32security.SetUserObjectSecurity(obj, info, sd)
831 def grant_winsta_and_desktop(th):
832     current_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]
833     winsta = win32process.GetProcessWindowStation()
834     set_user_perm(winsta, WINSTA_ALL, current_sid)
835     desktop = win32service.GetThreadDesktop(win32api.GetCurrentThreadId())
836     set_user_perm(desktop, DESKTOP_ALL, current_sid)
837 def environment_string(env):
838     senv = ""
839     for k, v in env.items():
840         senv += k + "=" + v + "\0"
841     senv += "\0"
842     return ctypes.create_unicode_buffer(senv)
843 def CreateProcessWithTokenW(
844     token,
845     logonflags=0,
846     applicationname=None,
847     commandline=None,
848     creationflags=0,
849     environment=None,
850     currentdirectory=None,
851     startupinfo=None,
852 ):
853     creationflags |= win32con.CREATE_UNICODE_ENVIRONMENT
854     if commandline is not None:
855         commandline = ctypes.create_unicode_buffer(commandline)
856     if startupinfo is None:
857         startupinfo = STARTUPINFO()
858     if currentdirectory is not None:
859         currentdirectory = ctypes.create_unicode_buffer(currentdirectory)
860     if environment is not None:
861         environment = ctypes.pointer(environment_string(environment))
862     process_info = PROCESS_INFORMATION()
863     ret = advapi32.CreateProcessWithTokenW(
864         token,
865         logonflags,
866         applicationname,
867         commandline,
868         creationflags,
869         environment,
870         currentdirectory,
871         ctypes.byref(startupinfo),
872         ctypes.byref(process_info),
873     )
874     if ret == 0:
875         winerr = win32api.GetLastError()
876         exc = OSError(win32api.FormatMessage(winerr))
877         exc.winerror = winerr
878         raise exc
879     return process_info
880 def enumerate_tokens(sid=None, session_id=None, privs=None):
881     for p in psutil.process_iter():
882         if p.pid == 0:
883             continue
884         try:
885             ph = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, 0, p.pid)
886         except win32api.error as exc:
887             if exc.winerror == 5:
888                 log.debug("Unable to OpenProcess pid=%d name=%s", p.pid, p.name())
889                 continue
890             raise exc
891         try:
892             access = (
893                 win32security.TOKEN_DUPLICATE
894                 | win32security.TOKEN_QUERY
895                 | win32security.TOKEN_IMPERSONATE
896                 | win32security.TOKEN_ASSIGN_PRIMARY
897             )
898             th = win32security.OpenProcessToken(ph, access)
899         except Exception as exc:  # pylint: disable=broad-except
900             log.debug(
901                 "OpenProcessToken failed pid=%d name=%s user%s",
902                 p.pid,
903                 p.name(),
904                 p.username(),
905             )
906             continue
907         try:
908             process_sid = win32security.GetTokenInformation(
909                 th, win32security.TokenUser
910             )[0]
911         except Exception as exc:  # pylint: disable=broad-except
912             log.exception(
913                 "GetTokenInformation pid=%d name=%s user%s",
914                 p.pid,
915                 p.name(),
916                 p.username(),
917             )
918             continue
919         proc_sid = win32security.ConvertSidToStringSid(process_sid)
920         if sid and sid != proc_sid:
921             log.debug("Token for pid does not match user sid: %s", sid)
922             continue
923         if (
924             session_id
925             and win32security.GetTokenInformation(th, win32security.TokenSessionId)
926             != session_id
927         ):
928             continue
929         def has_priv(tok, priv):
930             luid = win32security.LookupPrivilegeValue(None, priv)
931             for priv_luid, flags in win32security.GetTokenInformation(
932                 tok, win32security.TokenPrivileges
933             ):
934                 if priv_luid == luid:
935                     return True
936             return False
937         if privs:
938             has_all = True
939             for name in privs:
940                 if not has_priv(th, name):
941                     has_all = False
942             if not has_all:
943                 continue
944         yield dup_token(th)
945 def impersonate_sid(sid, session_id=None, privs=None):
946     for tok in enumerate_tokens(sid, session_id, privs):
947         tok = dup_token(tok)
948         elevate_token(tok)
949         if win32security.ImpersonateLoggedOnUser(tok) == 0:
950             raise OSError("Impersonation failure")
951         return tok
952     raise OSError("Impersonation failure")
953 def dup_token(th):
954     sec_attr = win32security.SECURITY_ATTRIBUTES()
955     sec_attr.bInheritHandle = True
956     return win32security.DuplicateTokenEx(
957         th,
958         win32security.SecurityImpersonation,
959         win32con.MAXIMUM_ALLOWED,
960         win32security.TokenPrimary,
961         sec_attr,
962     )
963 def elevate_token(th):
964     privileges = win32security.GetTokenInformation(th, win32security.TokenPrivileges)
965     enable_privs = set()
966     for luid, flags in privileges:
967         enable_privs.add((luid, win32con.SE_PRIVILEGE_ENABLED))
968     if win32security.AdjustTokenPrivileges(th, 0, enable_privs) == 0:
969         raise OSError(win32api.FormatMessage(win32api.GetLastError()))
970 def make_inheritable(token):
971     return win32api.DuplicateHandle(
972         win32api.GetCurrentProcess(),
973         token,
974         0,
975         1,
976         win32con.<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>DUPLICATE_SAME_ACCESS,
977     )
978 def CreateProcessWithLogonW(
979     username=None,
980     domain=None,
981     password=None,
982     logonflags=0,
983     applicationname=None,
984     commandline=None,
985     creationflags=0,
986     environment=None,
987     currentdirectory=None,
988     startupinfo=None,
989 ):
990     creationflags |=</b></font> win32con.CREATE_UNICODE_ENVIRONMENT
991     if commandline is not None:
992         commandline = ctypes.create_unicode_buffer(commandline)
993     if startupinfo is None:
994         startupinfo = STARTUPINFO()
995     if environment is not None:
996         environment = ctypes.pointer(environment_string(environment))
997     process_info = PROCESS_INFORMATION()
998     advapi32.CreateProcessWithLogonW(
999         username,
1000         domain,
1001         password,
1002         logonflags,
1003         applicationname,
1004         commandline,
1005         creationflags,
1006         environment,
1007         currentdirectory,
1008         ctypes.byref(startupinfo),
1009         ctypes.byref(process_info),
1010     )
1011     return process_info
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>netacl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.napalm
3 log = logging.getLogger(__file__)
4 try:
5     import capirca
6     import capirca.aclgen
7     import capirca.lib.policy
8     import capirca.lib.aclgenerator
9     HAS_CAPIRCA = True
10 except ImportError:
11     HAS_CAPIRCA = False
12 __virtualname__ = "netacl"
13 def __virtual__():
14     if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):
15         return __virtualname__
16     else:
17         return (
18             False,
19             "The netacl state cannot be loaded: Please install capirca and napalm.",
20         )
21 def term(
22     filter_name,
23     term_name,
24     filter_options<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
25     pillar_key="acl",
26     pillarenv=None,
27     saltenv=None,
28     merge_pillar=False,
29     revision_id=None,
30     revision_no=None,
31     revision_date=True,
32     revision_date_format="%Y/%m/%d",
33     test=False,
34     commit=True,
35     debug=False,
36     source_service=None,
37     destination_service=None,
38     **term_fields
39 ):
40     ret =</b></font> salt.utils.napalm.default_ret(name)
41     test = __opts__["test"] or test
42     if not filter_options:
43         filter_options = []
44     loaded = __salt__["netacl.load_term_config"](
45         filter_name,
46         term_name,
47         filter_options=filter_options,
48         pillar_key=pillar_key,
49         pillarenv=pillarenv,
50         saltenv=saltenv,
51         merge_pillar=merge_pillar,
52         revision_id=revision_id if revision_id else name,
53         revision_no=revision_no,
54         revision_date=revision_date,
55         revision_date_format=revision_date_format,
56         source_service=source_service,
57         destination_service=destination_service,
58         test=test,
59         commit=commit,
60         debug=debug,
61         **term_fields
62     )
63     return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)
64     name,  # pylint: disable=redefined-builtin
65     filter_name,
66     filter_options<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
67     terms=None,
68     prepend=True,
69     pillar_key="acl",
70     pillarenv=None,
71     saltenv=None,
72     merge_pillar=False,
73     only_lower_merge=False,
74     revision_id=None,
75     revision_no=None,
76     revision_date=True,
77     revision_date_format="%Y/%m/%d",
78     test=False,
79     commit=True,
80     debug=False,
81 ):
82     ret = salt.</b></font>utils.napalm.default_ret(name)
83     test = __opts__["test"] or test
84     if not filter_options:
85         filter_options = []
86     if not terms:
87         terms = []
88     loaded = __salt__["netacl.load_filter_config"](
89         filter_name,
90         filter_options=filter_options,
91         terms=terms,
92         prepend=prepend,
93         pillar_key=pillar_key,
94         pillarenv=pillarenv,
95         saltenv=saltenv,
96         merge_pillar=merge_pillar,
97         only_lower_merge=only_lower_merge,
98         revision_id=revision_id if revision_id else name,
99         revision_no=revision_no,
100         revision_date=revision_date,
101         revision_date_format=revision_date_format,
102         test=test,
103         debug=debug,
104     )
105     return salt.utils.napalm.loaded_ret(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ret, loaded, test, debug)
106 def managed(
107     name,
108     filters=None,
109     prepend=True,
110     pillar_key="acl",
111     pillarenv=None,
112     saltenv=None,
113     merge_pillar=False,
114     only_lower_merge=False,
115     revision_id=None,
116     revision_no=None,
117     revision_date=True,
118     revision_date_format=</b></font>"%Y/%m/%d",
119     test=False,
120     commit=True,
121     debug=False,
122 ):
123     ret = salt.utils.napalm.default_ret(name)
124     test = __opts__["test"] or test
125     if not filters:
126         filters = []
127     loaded = __salt__["netacl.load_policy_config"](
128         filters=filters,
129         prepend=prepend,
130         pillar_key=pillar_key,
131         pillarenv=pillarenv,
132         saltenv=saltenv,
133         merge_pillar=merge_pillar,
134         only_lower_merge=only_lower_merge,
135         revision_id=revision_id if revision_id else name,
136         revision_no=revision_no,
137         revision_date=revision_date,
138         revision_date_format=revision_date_format,
139         test=test,
140         commit=commit,
141         debug=debug,
142     )
143     return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
