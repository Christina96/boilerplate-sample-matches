<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win.py &amp; netacl.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win.py &amp; netacl.py
      </h3>
<h1 align="center">
        4.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win.py (2.667457%)<th>netacl.py (25.714285%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(108-139)<td><a href="#" name="0">(454-659)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(84-103)<td><a href="#" name="1">(96-425)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1293-1309)<td><a href="#" name="2">(683-698)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import collections
2 import ctypes
3 import logging
4 import os
5 from ctypes import wintypes
6 import ntsecuritycon
7 import psutil
8 import win32api
9 import win32con
10 import win32process
11 import win32security
12 import win32service
13 log = logging.getLogger(__name__)
14 ntdll = ctypes.WinDLL("ntdll")
15 secur32 = ctypes.WinDLL("secur32")
16 kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)
17 advapi32 = ctypes.WinDLL("advapi32", use_last_error=True)
18 userenv = ctypes.WinDLL("userenv", use_last_error=True)
19 SYSTEM_SID = "S-1-5-18"
20 LOCAL_SRV_SID = "S-1-5-19"
21 NETWORK_SRV_SID = "S-1-5-19"
22 LOGON_WITH_PROFILE = 0x00000001
23 WINSTA_ALL = (
24     win32con.WINSTA_ACCESSCLIPBOARD
25     | win32con.WINSTA_ACCESSGLOBALATOMS
26     | win32con.WINSTA_CREATEDESKTOP
27     | win32con.WINSTA_ENUMDESKTOPS
28     | win32con.WINSTA_ENUMERATE
29     | win32con.WINSTA_EXITWINDOWS
30     | win32con.WINSTA_READATTRIBUTES
31     | win32con.WINSTA_READSCREEN
32     | win32con.WINSTA_WRITEATTRIBUTES
33     | win32con.DELETE
34     | win32con.READ_CONTROL
35     | win32con.WRITE_DAC
36     | win32con.WRITE_OWNER
37 )
38 DESKTOP_ALL = (
39     win32con.DESKTOP_CREATEMENU
40     | win32con.DESKTOP_CREATEWINDOW
41     | win32con.DESKTOP_ENUMERATE
42     | win32con.DESKTOP_HOOKCONTROL
43     | win32con.DESKTOP_JOURNALPLAYBACK
44     | win32con.DESKTOP_JOURNALRECORD
45     | win32con.DESKTOP_READOBJECTS
46     | win32con.DESKTOP_SWITCHDESKTOP
47     | win32con.DESKTOP_WRITEOBJECTS
48     | win32con.DELETE
49     | win32con.READ_CONTROL
50     | win32con.WRITE_DAC
51     | win32con.WRITE_OWNER
52 )
53 MAX_COMPUTER_NAME_LENGTH = 15
54 SECURITY_LOGON_TYPE = wintypes.ULONG
55 Interactive = 2
56 Network = 3
57 Batch = 4
58 Service = 5
59 <a name="1"></a>LOGON_SUBMIT_TYPE = wintypes.ULONG
60 PROFILE_BUFFER_TYPE = wintypes.ULONG
61 MsV1_0InteractiveLogon <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= 2
62 MsV1_0Lm20Logon = 3
63 MsV1_0NetworkLogon = 4
64 MsV1_0WorkstationUnlockLogon = 7
65 MsV1_0S4ULogon = 12
66 MsV1_0NoElevationLogon = 82
67 KerbInteractiveLogon = 2
68 KerbWorkstationUnlockLogon = 7
69 KerbS4ULogon = 12
70 MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS = 0x2
71 KERB_S4U_LOGON_FLAG_CHECK_LOGONHOURS = 0x2
72 KERB_S4U_LOGON_FLAG_IDENTITY = 0x8
73 TOKEN_SOURCE_LENGTH = 8
74 NEGOTIATE_PACKAGE_NAME = b"Negotiate"
75 MICROSOFT_KERBEROS_NAME =</b></font> b"Kerberos"
76 MSV1_0_PACKAGE_NAME = b"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
77 <a name="0"></a>
78 DELETE = 0x00010000
79 READ_CONTROL = 0x00020000
80 WRITE_DAC <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= 0x00040000
81 WRITE_OWNER = 0x00080000
82 STANDARD_RIGHTS_REQUIRED = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER
83 TOKEN_ASSIGN_PRIMARY = 0x0001
84 TOKEN_DUPLICATE = 0x0002
85 TOKEN_IMPERSONATE = 0x0004
86 TOKEN_QUERY = 0x0008
87 TOKEN_QUERY_SOURCE = 0x0010
88 TOKEN_ADJUST_PRIVILEGES = 0x0020
89 TOKEN_ADJUST_GROUPS = 0x0040
90 TOKEN_ADJUST_DEFAULT = 0x0080
91 TOKEN_ADJUST_SESSIONID = 0x0100
92 TOKEN_ALL_ACCESS = (
93     STANDARD_RIGHTS_REQUIRED
94     | TOKEN_ASSIGN_PRIMARY
95     | TOKEN_DUPLICATE
96     | TOKEN_IMPERSONATE
97     | TOKEN_QUERY
98     | TOKEN_QUERY_SOURCE
99     | TOKEN_ADJUST_PRIVILEGES
100     | TOKEN_ADJUST_GROUPS
101     | TOKEN_ADJUST_DEFAULT
102     | TOKEN_ADJUST_SESSIONID
103 )
104 DUPLICATE_CLOSE_SOURCE = 0x00000001
105 DUPLICATE_SAME_ACCESS = 0x00000002
106 TOKEN_TYPE = wintypes.</b></font>ULONG
107 TokenPrimary = 1
108 TokenImpersonation = 2
109 SECURITY_IMPERSONATION_LEVEL = wintypes.ULONG
110 SecurityAnonymous = 0
111 SecurityIdentification = 1
112 SecurityImpersonation = 2
113 SecurityDelegation = 3
114 class NTSTATUS(wintypes.LONG):
115     def to_error(self):
116         return ntdll.RtlNtStatusToDosError(self)
117     def __repr__(self):
118         name = self.__class__.__name__
119         status = wintypes.ULONG.from_buffer(self)
120         return "{}({})".format(name, status.value)
121 PNTSTATUS = ctypes.POINTER(NTSTATUS)
122 class BOOL(wintypes.BOOL):
123     def __repr__(self):
124         name = self.__class__.__name__
125         return "{}({})".format(name, bool(self))
126 class HANDLE(wintypes.HANDLE):
127     __slots__ = ("closed",)
128     def __int__(self):
129         return self.value or 0
130     def Detach(self):
131         if not getattr(self, "closed", False):
132             self.closed = True
133             value = int(self)
134             self.value = None
135             return value
136         raise ValueError("already closed")
137     def Close(self, CloseHandle=kernel32.CloseHandle):
138         if self and not getattr(self, "closed", False):
139             CloseHandle(self.Detach())
140     __del__ = Close
141     def __repr__(self):
142         return "{}({})".format(self.__class__.__name__, int(self))
143 class LARGE_INTEGER(wintypes.LARGE_INTEGER):
144     ntdll.RtlSecondsSince1970ToTime.restype = None
145     _unix_epoch = wintypes.LARGE_INTEGER()
146     ntdll.RtlSecondsSince1970ToTime(0, ctypes.byref(_unix_epoch))
147     _unix_epoch = _unix_epoch.value
148     def __int__(self):
149         return self.value
150     def __repr__(self):
151         name = self.__class__.__name__
152         return "{}({})".format(name, self.value)
153     def as_time(self):
154         time100ns = self.value - self._unix_epoch
155         if time100ns &gt;= 0:
156             return time100ns / 1e7
157         raise ValueError("value predates the Unix epoch")
158     @classmethod
159     def from_time(cls, t):
160         time100ns = int(t * 10 ** 7)
161         return cls(time100ns + cls._unix_epoch)
162 CHAR = ctypes.c_char
163 WCHAR = ctypes.c_wchar
164 PCHAR = ctypes.POINTER(CHAR)
165 PWCHAR = ctypes.POINTER(WCHAR)
166 class STRING(ctypes.Structure):
167     _fields_ = (
168         ("Length", wintypes.USHORT),
169         ("MaximumLength", wintypes.USHORT),
170         ("Buffer", PCHAR),
171     )
172 LPSTRING = ctypes.POINTER(STRING)
173 class UNICODE_STRING(ctypes.Structure):
174     _fields_ = (
175         ("Length", wintypes.USHORT),
176         ("MaximumLength", wintypes.USHORT),
177         ("Buffer", PWCHAR),
178     )
179 LPUNICODE_STRING = ctypes.POINTER(UNICODE_STRING)
180 class LUID(ctypes.Structure):
181     _fields_ = (
182         ("LowPart", wintypes.DWORD),
183         ("HighPart", wintypes.LONG),
184     )
185     def __new__(cls, value=0):
186         return cls.from_buffer_copy(ctypes.c_ulonglong(value))
187     def __int__(self):
188         return ctypes.c_ulonglong.from_buffer(self).value
189     def __repr__(self):
190         name = self.__class__.__name__
191         return "{}({})".format(name, int(self))
192 LPLUID = ctypes.POINTER(LUID)
193 PSID = wintypes.LPVOID
194 class SID_AND_ATTRIBUTES(ctypes.Structure):
195     _fields_ = (
196         ("Sid", PSID),
197         ("Attributes", wintypes.DWORD),
198     )
199 LPSID_AND_ATTRIBUTES = ctypes.POINTER(SID_AND_ATTRIBUTES)
200 class TOKEN_GROUPS(ctypes.Structure):
201     _fields_ = (
202         ("GroupCount", wintypes.DWORD),
203         ("Groups", SID_AND_ATTRIBUTES * 1),
204     )
205 LPTOKEN_GROUPS = ctypes.POINTER(TOKEN_GROUPS)
206 class TOKEN_SOURCE(ctypes.Structure):
207     _fields_ = (
208         ("SourceName", CHAR * TOKEN_SOURCE_LENGTH),
209         ("SourceIdentifier", LUID),
210     )
211     def __init__(self, SourceName=None, SourceIdentifier=None):
212         super().__init__()
213         if SourceName is not None:
214             if not isinstance(SourceName, bytes):
215                 SourceName = SourceName.encode("mbcs")
216             self.SourceName = SourceName
217         if SourceIdentifier is None:
218             luid = self.SourceIdentifier
219             ntdll.NtAllocateLocallyUniqueId(ctypes.byref(luid))
220         else:
221             self.SourceIdentifier = SourceIdentifier
222 LPTOKEN_SOURCE = ctypes.POINTER(TOKEN_SOURCE)
223 py_source_context = TOKEN_SOURCE(b"PYTHON  ")
224 py_origin_name = __name__.encode()
225 py_logon_process_name = "{}-{}".format(py_origin_name, os.getpid())
226 SIZE_T = ctypes.c_size_t
227 class QUOTA_LIMITS(ctypes.Structure):
228     _fields_ = (
229         ("PagedPoolLimit", SIZE_T),
230         ("NonPagedPoolLimit", SIZE_T),
231         ("MinimumWorkingSetSize", SIZE_T),
232         ("MaximumWorkingSetSize", SIZE_T),
233         ("PagefileLimit", SIZE_T),
234         ("TimeLimit", wintypes.LARGE_INTEGER),
235     )
236 LPQUOTA_LIMITS = ctypes.POINTER(QUOTA_LIMITS)
237 LPULONG = ctypes.POINTER(wintypes.ULONG)
238 LSA_OPERATIONAL_MODE = wintypes.ULONG
239 LPLSA_OPERATIONAL_MODE = LPULONG
240 LPHANDLE = ctypes.POINTER(wintypes.HANDLE)
241 LPLPVOID = ctypes.POINTER(wintypes.LPVOID)
242 LPDWORD = ctypes.POINTER(wintypes.DWORD)
243 class ContiguousUnicode(ctypes.Structure):
244     def __init__(self, *args, **kwargs):  # pylint: disable=useless-super-delegation
245         super().__init__(*args, **kwargs)
246     def _get_unicode_string(self, name):
247         wchar_size = ctypes.sizeof(WCHAR)
248         s = getattr(self, "_{}".format(name))
249         length = s.Length // wchar_size
250         buf = s.Buffer
251         if buf:
252             return buf[:length]
253         return None
254     def _set_unicode_buffer(self, values):
255         cls = type(self)
256         wchar_size = ctypes.sizeof(WCHAR)
257         bufsize = (len("\x00".join(values)) + 1) * wchar_size
258         ctypes.resize(self, ctypes.sizeof(cls) + bufsize)
259         addr = ctypes.addressof(self) + ctypes.sizeof(cls)
260         for value in values:
261             bufsize = (len(value) + 1) * wchar_size
262             ctypes.memmove(addr, value, bufsize)
263             addr += bufsize
264     def _set_unicode_string(self, name, value):
265         values = []
266         for n in self._string_names_:
267             if n == name:
268                 values.append(value or "")
269             else:
270                 values.append(getattr(self, n) or "")
271         self._set_unicode_buffer(values)
272         cls = type(self)
273         wchar_size = ctypes.sizeof(WCHAR)
274         addr = ctypes.addressof(self) + ctypes.sizeof(cls)
275         for n, v in zip(self._string_names_, values):
276             ptr = ctypes.cast(addr, PWCHAR)
277             ustr = getattr(self, "_{}".format(n))
278             length = ustr.Length = len(v) * wchar_size
279             full_length = length + wchar_size
280             if (n == name and value is None) or (
281                 n != name and not (length or ustr.Buffer)
282             ):
283                 ustr.Buffer = None
284                 ustr.MaximumLength = 0
285             else:
286                 ustr.Buffer = ptr
287                 ustr.MaximumLength = full_length
288             addr += full_length
289     def __getattr__(self, name):
290         if name not in self._string_names_:
291             raise AttributeError
292         return self._get_unicode_string(name)
293     def __setattr__(self, name, value):
294         if name in self._string_names_:
295             self._set_unicode_string(name, value)
296         else:
297             super().__setattr__(name, value)
298     @classmethod
299     def from_address_copy(cls, address, size=None):
300         x = ctypes.Structure.__new__(cls)
301         if size is not None:
302             ctypes.resize(x, size)
303         ctypes.memmove(ctypes.byref(x), address, ctypes.sizeof(x))
304         delta = ctypes.addressof(x) - address
305         for n in cls._string_names_:
306             ustr = getattr(x, "_{}".format(n))
307             addr = ctypes.c_void_p.from_buffer(ustr.Buffer)
308             if addr:
309                 addr.value += delta
310         return x
311 class AuthInfo(ContiguousUnicode):
312     def __init__(self):
313         super().__init__()
314         self.MessageType = self._message_type_
315 class MSV1_0_INTERACTIVE_LOGON(AuthInfo):
316     _message_type_ = MsV1_0InteractiveLogon
317     _string_names_ = "LogonDomainName", "UserName", "Password"
318     _fields_ = (
319         ("MessageType", LOGON_SUBMIT_TYPE),
320         ("_LogonDomainName", UNICODE_STRING),
321         ("_UserName", UNICODE_STRING),
322         ("_Password", UNICODE_STRING),
323     )
324     def __init__(self, UserName=None, Password=None, LogonDomainName=None):
325         super().__init__()
326         if LogonDomainName is not None:
327             self.LogonDomainName = LogonDomainName
328         if UserName is not None:
329             self.UserName = UserName
330         if Password is not None:
331             self.Password = Password
332 class S4ULogon(AuthInfo):
333     _string_names_ = "UserPrincipalName", "DomainName"
334     _fields_ = (
335         ("MessageType", LOGON_SUBMIT_TYPE),
336         ("Flags", wintypes.ULONG),
337         ("_UserPrincipalName", UNICODE_STRING),
338         ("_DomainName", UNICODE_STRING),
339     )
340     def __init__(self, UserPrincipalName=None, DomainName=None, Flags=0):
341         super().__init__()
342         self.Flags = Flags
343         if UserPrincipalName is not None:
344             self.UserPrincipalName = UserPrincipalName
345         if DomainName is not None:
346             self.DomainName = DomainName
347 class MSV1_0_S4U_LOGON(S4ULogon):
348     _message_type_ = MsV1_0S4ULogon
349 class KERB_S4U_LOGON(S4ULogon):
350     _message_type_ = KerbS4ULogon
351 PMSV1_0_S4U_LOGON = ctypes.POINTER(MSV1_0_S4U_LOGON)
352 PKERB_S4U_LOGON = ctypes.POINTER(KERB_S4U_LOGON)
353 class ProfileBuffer(ContiguousUnicode):
354     def __init__(self):
355         super().__init__()
356         self.MessageType = self._message_type_
357 class MSV1_0_INTERACTIVE_PROFILE(ProfileBuffer):
358     _message_type_ = MsV1_0InteractiveLogon
359     _string_names_ = (
360         "LogonScript",
361         "HomeDirectory",
362         "FullName",
363         "ProfilePath",
364         "HomeDirectoryDrive",
365         "LogonServer",
366     )
367     _fields_ = (
368         ("MessageType", PROFILE_BUFFER_TYPE),
369         ("LogonCount", wintypes.USHORT),
370         ("BadPasswordCount", wintypes.USHORT),
371         ("LogonTime", LARGE_INTEGER),
372         ("LogoffTime", LARGE_INTEGER),
373         ("KickOffTime", LARGE_INTEGER),
374         ("PasswordLastSet", LARGE_INTEGER),
375         ("PasswordCanChange", LARGE_INTEGER),
376         ("PasswordMustChange", LARGE_INTEGER),
377         ("_LogonScript", UNICODE_STRING),
378         ("_HomeDirectory", UNICODE_STRING),
379         ("_FullName", UNICODE_STRING),
380         ("_ProfilePath", UNICODE_STRING),
381         ("_HomeDirectoryDrive", UNICODE_STRING),
382         ("_LogonServer", UNICODE_STRING),
383         ("UserFlags", wintypes.ULONG),
384     )
385 def _check_status(result, func, args):
386     if result.value &lt; 0:
387         raise ctypes.WinError(result.to_error())
388     return args
389 def _check_bool(result, func, args):
390     if not result:
391         raise ctypes.WinError(ctypes.get_last_error())
392     return args
393 INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value
394 INVALID_DWORD_VALUE = wintypes.DWORD(-1).value  # ~WinAPI
395 INFINITE = INVALID_DWORD_VALUE
396 STD_INPUT_HANDLE = wintypes.DWORD(-10).value
397 STD_OUTPUT_HANDLE = wintypes.DWORD(-11).value
398 STD_ERROR_HANDLE = wintypes.DWORD(-12).value
399 class SECURITY_ATTRIBUTES(ctypes.Structure):
400     _fields_ = (
401         ("nLength", wintypes.DWORD),
402         ("lpSecurityDescriptor", wintypes.LPVOID),
403         ("bInheritHandle", wintypes.BOOL),
404     )
405     def __init__(self, **kwds):
406         self.nLength = ctypes.sizeof(self)
407         super().__init__(**kwds)
408 LPSECURITY_ATTRIBUTES = ctypes.POINTER(SECURITY_ATTRIBUTES)
409 LPBYTE = ctypes.POINTER(wintypes.BYTE)
410 LPHANDLE = PHANDLE = ctypes.POINTER(ctypes.c_void_p)
411 LPDWORD = ctypes.POINTER(ctypes.c_ulong)
412 class STARTUPINFO(ctypes.Structure):
413     _fields_ = (
414         ("cb", wintypes.DWORD),
415         ("lpReserved", wintypes.LPWSTR),
416         ("lpDesktop", wintypes.LPWSTR),
417         ("lpTitle", wintypes.LPWSTR),
418         ("dwX", wintypes.DWORD),
419         ("dwY", wintypes.DWORD),
420         ("dwXSize", wintypes.DWORD),
421         ("dwYSize", wintypes.DWORD),
422         ("dwXCountChars", wintypes.DWORD),
423         ("dwYCountChars", wintypes.DWORD),
424         ("dwFillAttribute", wintypes.DWORD),
425         ("dwFlags", wintypes.DWORD),
426         ("wShowWindow", wintypes.WORD),
427         ("cbReserved2", wintypes.WORD),
428         ("lpReserved2", LPBYTE),
429         ("hStdInput", wintypes.HANDLE),
430         ("hStdOutput", wintypes.HANDLE),
431         ("hStdError", wintypes.HANDLE),
432     )
433     def __init__(self, **kwds):
434         self.cb = ctypes.sizeof(self)
435         super().__init__(**kwds)
436 LPSTARTUPINFO = ctypes.POINTER(STARTUPINFO)
437 class PROC_THREAD_ATTRIBUTE_LIST(ctypes.Structure):
438     pass
439 PPROC_THREAD_ATTRIBUTE_LIST = ctypes.POINTER(PROC_THREAD_ATTRIBUTE_LIST)
440 class STARTUPINFOEX(STARTUPINFO):
441     _fields_ = (("lpAttributeList", PPROC_THREAD_ATTRIBUTE_LIST),)
442 LPSTARTUPINFOEX = ctypes.POINTER(STARTUPINFOEX)
443 class PROCESS_INFORMATION(ctypes.Structure):
444     _fields_ = (
445         ("hProcess", wintypes.HANDLE),
446         ("hThread", wintypes.HANDLE),
447         ("dwProcessId", wintypes.DWORD),
448         ("dwThreadId", wintypes.DWORD),
449     )
450 LPPROCESS_INFORMATION = ctypes.POINTER(PROCESS_INFORMATION)
451 class HANDLE_IHV(wintypes.HANDLE):
452     pass
453 def errcheck_ihv(result, func, args):
454     if result.value == INVALID_HANDLE_VALUE:
455         raise ctypes.WinError(ctypes.get_last_error())
456     return result.value
457 class DWORD_IDV(wintypes.DWORD):
458     pass
459 def errcheck_idv(result, func, args):
460     if result.value == INVALID_DWORD_VALUE:
461         raise ctypes.WinError(ctypes.get_last_error())
462     return result.value
463 def errcheck_bool(result, func, args):
464     if not result:
465         raise ctypes.WinError(ctypes.get_last_error())
466     return args
467 def _win(func, restype, *argtypes):
468     func.restype = restype
469     func.argtypes = argtypes
470     if issubclass(restype, NTSTATUS):
471         func.errcheck = _check_status
472     elif issubclass(restype, BOOL):
473         func.errcheck = _check_bool
474     elif issubclass(restype, HANDLE_IHV):
475         func.errcheck = errcheck_ihv
476     elif issubclass(restype, DWORD_IDV):
477         func.errcheck = errcheck_idv
478     else:
479         func.errcheck = errcheck_bool
480 _win(kernel32.GetStdHandle, HANDLE_IHV, wintypes.DWORD)  # _In_ nStdHandle
481 _win(kernel32.CloseHandle, wintypes.BOOL, wintypes.HANDLE)  # _In_ hObject
482 _win(
483     kernel32.SetHandleInformation,
484     wintypes.BOOL,
485     wintypes.HANDLE,  # _In_ hObject
486     wintypes.DWORD,  # _In_ dwMask
487     wintypes.DWORD,
488 )  # _In_ dwFlags
489 _win(
490     kernel32.DuplicateHandle,
491     wintypes.BOOL,
492     wintypes.HANDLE,  # _In_  hSourceProcessHandle,
493     wintypes.HANDLE,  # _In_  hSourceHandle,
494     wintypes.HANDLE,  # _In_  hTargetProcessHandle,
495     LPHANDLE,  # _Out_ lpTargetHandle,
496     wintypes.DWORD,  # _In_  dwDesiredAccess,
497     wintypes.BOOL,  # _In_  bInheritHandle,
498     wintypes.DWORD,
499 )  # _In_  dwOptions
500 _win(kernel32.GetCurrentProcess, wintypes.HANDLE)
501 _win(
502     kernel32.GetExitCodeProcess,
503     wintypes.BOOL,
504     wintypes.HANDLE,  # _In_  hProcess,
505     LPDWORD,
506 )  # _Out_ lpExitCode
507 _win(
508     kernel32.CreatePipe,
509     wintypes.BOOL,
510     PHANDLE,  # _Out_    hReadPipe,
511     PHANDLE,  # _Out_    hWritePipe,
512     LPSECURITY_ATTRIBUTES,  # _In_opt_ lpPipeAttributes,
513     wintypes.DWORD,
514 )  # _In_     nSize
515 _win(
516     advapi32.CreateProcessWithLogonW,
517     wintypes.BOOL,
518     wintypes.LPCWSTR,  # _In_        lpUsername
519     wintypes.LPCWSTR,  # _In_opt_    lpDomain
520     wintypes.LPCWSTR,  # _In_        lpPassword
521     wintypes.DWORD,  # _In_        dwLogonFlags
522     wintypes.LPCWSTR,  # _In_opt_    lpApplicationName
523     wintypes.LPWSTR,  # _Inout_opt_ lpCommandLine
524     wintypes.DWORD,  # _In_        dwCreationFlags
525     wintypes.LPCWSTR,  # _In_opt_    lpEnvironment
526     wintypes.LPCWSTR,  # _In_opt_    lpCurrentDirectory
527     LPSTARTUPINFO,  # _In_        lpStartupInfo
528     LPPROCESS_INFORMATION,
529 )  # _Out_       lpProcessInformation
530 _win(kernel32.GetCurrentProcess, wintypes.HANDLE)
531 _win(
532     kernel32.DuplicateHandle,
533     BOOL,
534     wintypes.HANDLE,  # _In_  hSourceProcessHandle
535     wintypes.HANDLE,  # _In_  hSourceHandle
536     wintypes.HANDLE,  # _In_  hTargetProcessHandle
537     LPHANDLE,  # _Out_ lpTargetHandle
538     wintypes.DWORD,  # _In_  dwDesiredAccess
539     wintypes.BOOL,  # _In_  bInheritHandle
540     wintypes.DWORD,
541 )  # _In_  dwOptions
542 _win(
543     kernel32.GetComputerNameW, BOOL, wintypes.LPWSTR, LPDWORD  # _Out_   lpBuffer
544 )  # _Inout_ lpnSize
545 _win(
546     advapi32.OpenProcessToken,
547     BOOL,
548     wintypes.HANDLE,  # _In_  ProcessHandle
549     wintypes.DWORD,  # _In_  DesiredAccess
550     LPHANDLE,
551 )  # _Out_ TokenHandle
552 _win(
553     advapi32.DuplicateTokenEx,
554     BOOL,
555     wintypes.HANDLE,  # _In_     hExistingToken
556     wintypes.DWORD,  # _In_     dwDesiredAccess
557     LPSECURITY_ATTRIBUTES,  # _In_opt_ lpTokenAttributes
558     SECURITY_IMPERSONATION_LEVEL,  # _In_     ImpersonationLevel
559     TOKEN_TYPE,  # _In_     TokenType
560     LPHANDLE,
561 )  # _Out_    phNewToken
562 _win(ntdll.NtAllocateLocallyUniqueId, NTSTATUS, LPLUID)  # _Out_ LUID
563 _win(
564     secur32.LsaFreeReturnBuffer,
565     NTSTATUS,
566     wintypes.LPVOID,
567 )  # _In_ Buffer
568 _win(
569     secur32.LsaConnectUntrusted,
570     NTSTATUS,
571     LPHANDLE,
572 )  # _Out_ LsaHandle
573 _win(
574     secur32.LsaRegisterLogonProcess,
575     NTSTATUS,
576     LPSTRING,  # _In_  LogonProcessName
577     LPHANDLE,  # _Out_ LsaHandle
578     LPLSA_OPERATIONAL_MODE,
579 )  # _Out_ SecurityMode
580 _win(secur32.LsaDeregisterLogonProcess, NTSTATUS, wintypes.HANDLE)  # _In_ LsaHandle
581 _win(
582     secur32.LsaLookupAuthenticationPackage,
583     NTSTATUS,
584     wintypes.HANDLE,  # _In_  LsaHandle
585     LPSTRING,  # _In_  PackageName
586     LPULONG,
587 )  # _Out_ AuthenticationPackage
588 _win(
589     secur32.LsaLogonUser,
590     NTSTATUS,
591     wintypes.HANDLE,  # _In_     LsaHandle
592     LPSTRING,  # _In_     OriginName
593     SECURITY_LOGON_TYPE,  # _In_     LogonType
594     wintypes.ULONG,  # _In_     AuthenticationPackage
595     wintypes.LPVOID,  # _In_     AuthenticationInformation
596     wintypes.ULONG,  # _In_     AuthenticationInformationLength
597     LPTOKEN_GROUPS,  # _In_opt_ LocalGroups
598     LPTOKEN_SOURCE,  # _In_     SourceContext
599     LPLPVOID,  # _Out_    ProfileBuffer
600     LPULONG,  # _Out_    ProfileBufferLength
601     LPLUID,  # _Out_    LogonId
602     LPHANDLE,  # _Out_    Token
603     LPQUOTA_LIMITS,  # _Out_    Quotas
604     PNTSTATUS,
605 )  # _Out_    SubStatus
606 def duplicate_token(
607     source_token=None,
608     access=TOKEN_ALL_ACCESS,
609     impersonation_level=SecurityImpersonation,
610     token_type=TokenPrimary,
611     attributes=None,
612 ):
613     close_source = False
614     if source_token is None:
615         close_source = True
616         source_token = HANDLE()
617         advapi32.OpenProcessToken(
618             kernel32.GetCurrentProcess(), TOKEN_ALL_ACCESS, ctypes.byref(source_token)
619         )
620     token = HANDLE()
621     try:
622         advapi32.DuplicateTokenEx(
623             source_token,
624             access,
625             attributes,
626             impersonation_level,
627             token_type,
628             ctypes.byref(token),
629         )
630     finally:
631         if close_source:
632             source_token.Close()
633     return token
634 def lsa_connect_untrusted():
635     handle = wintypes.HANDLE()
636     secur32.LsaConnectUntrusted(ctypes.byref(handle))
637     return handle.value
638 def lsa_register_logon_process(logon_process_name):
639     if not isinstance(logon_process_name, bytes):
640         logon_process_name = logon_process_name.encode("mbcs")
641     logon_process_name = logon_process_name[:127]
642     buf = ctypes.create_string_buffer(logon_process_name, 128)
643     name = STRING(len(logon_process_name), len(buf), buf)
644     handle = wintypes.HANDLE()
645     mode = LSA_OPERATIONAL_MODE()
646     secur32.LsaRegisterLogonProcess(
647         ctypes.byref(name), ctypes.byref(handle), ctypes.byref(mode)
648     )
649     return handle.value
650 def lsa_lookup_authentication_package(lsa_handle, package_name):
651     if not isinstance(package_name, bytes):
652         package_name = package_name.encode("mbcs")
653     package_name = package_name[:127]
654     buf = ctypes.create_string_buffer(package_name)
655     name = STRING(len(package_name), len(buf), buf)
656     package = wintypes.ULONG()
657     secur32.LsaLookupAuthenticationPackage(
658         lsa_handle, ctypes.byref(name), ctypes.byref(package)
659     )
660     return package.value
661 LOGONINFO = collections.namedtuple(
662     "LOGONINFO", ("Token", "LogonId", "Profile", "Quotas")
663 )
664 def lsa_logon_user(
665     auth_info,
666     local_groups=None,
667     origin_name=py_origin_name,
668     source_context=None,
669     auth_package=None,
670     logon_type=None,
671     lsa_handle=None,
672 ):
673     if local_groups is None:
674         plocal_groups = LPTOKEN_GROUPS()
675     else:
676         plocal_groups = ctypes.byref(local_groups)
677     if source_context is None:
678         source_context = py_source_context
679     if not isinstance(origin_name, bytes):
680         origin_name = origin_name.encode("mbcs")
681     buf = ctypes.create_string_buffer(origin_name)
682     origin_name = STRING(len(origin_name), len(buf), buf)
683     if auth_package is None:
684         if isinstance(auth_info, MSV1_0_S4U_LOGON):
685             auth_package = NEGOTIATE_PACKAGE_NAME
686         elif isinstance(auth_info, KERB_S4U_LOGON):
687             auth_package = MICROSOFT_KERBEROS_NAME
688         else:
689             auth_package = MSV1_0_PACKAGE_NAME
690     if logon_type is None:
691         if isinstance(auth_info, S4ULogon):
692             logon_type = win32con.LOGON32_LOGON_NETWORK
693         else:
694             logon_type = Interactive
695     profile_buffer = wintypes.LPVOID()
696     profile_buffer_length = wintypes.ULONG()
697     profile = None
698     logonid = LUID()
699     htoken = HANDLE()
700     quotas = QUOTA_LIMITS()
701     substatus = NTSTATUS()
702     deregister = False
703     if lsa_handle is None:
704         lsa_handle = lsa_connect_untrusted()
705         deregister = True
706     try:
707         if isinstance(auth_package, (str, bytes)):
708             auth_package = lsa_lookup_authentication_package(lsa_handle, auth_package)
709         try:
710             secur32.LsaLogonUser(
711                 lsa_handle,
712                 ctypes.byref(origin_name),
713                 logon_type,
714                 auth_package,
715                 ctypes.byref(auth_info),
716                 ctypes.sizeof(auth_info),
717                 plocal_groups,
718                 ctypes.byref(source_context),
719                 ctypes.byref(profile_buffer),
720                 ctypes.byref(profile_buffer_length),
721                 ctypes.byref(logonid),
722                 ctypes.byref(htoken),
723                 ctypes.byref(quotas),
724                 ctypes.byref(substatus),
725             )
726         except OSError:
727             if substatus.value:
728                 raise ctypes.WinError(substatus.to_error())
729             raise
730         finally:
731             if profile_buffer:
732                 address = profile_buffer.value
733                 buftype = PROFILE_BUFFER_TYPE.from_address(address).value
734                 if buftype == MsV1_0InteractiveLogon:
735                     profile = MSV1_0_INTERACTIVE_PROFILE.from_address_copy(
736                         address, profile_buffer_length.value
737                     )
738                 secur32.LsaFreeReturnBuffer(address)
739     finally:
740         if deregister:
741             secur32.LsaDeregisterLogonProcess(lsa_handle)
742     return LOGONINFO(htoken, logonid, profile, quotas)
743 def logon_msv1(
744     name,
745     password,
746     domain=None,
747     local_groups=None,
748     origin_name=py_origin_name,
749     source_context=None,
750 ):
751     return lsa_logon_user(
752         MSV1_0_INTERACTIVE_LOGON(name, password, domain),
753         local_groups,
754         origin_name,
755         source_context,
756     )
757 def logon_msv1_s4u(
758     name, local_groups=None, origin_name=py_origin_name, source_context=None
759 ):
760     domain = ctypes.create_unicode_buffer(MAX_COMPUTER_NAME_LENGTH + 1)
761     length = wintypes.DWORD(len(domain))
762     kernel32.GetComputerNameW(domain, ctypes.byref(length))
763     return lsa_logon_user(
764         MSV1_0_S4U_LOGON(name, domain.value), local_groups, origin_name, source_context
765     )
766 def logon_kerb_s4u(
767     name,
768     realm=None,
769     local_groups=None,
770     origin_name=py_origin_name,
771     source_context=None,
772     logon_process_name=py_logon_process_name,
773 ):
774     lsa_handle = lsa_register_logon_process(logon_process_name)
775     try:
776         return lsa_logon_user(
777             KERB_S4U_LOGON(name, realm),
778             local_groups,
779             origin_name,
780             source_context,
781             lsa_handle=lsa_handle,
782         )
783     finally:
784         secur32.LsaDeregisterLogonProcess(lsa_handle)
785 def DuplicateHandle(
786     hsrc=kernel32.GetCurrentProcess(),
787     srchandle=kernel32.GetCurrentProcess(),
788     htgt=kernel32.GetCurrentProcess(),
789     access=0,
790     inherit=False,
791     options=win32con.DUPLICATE_SAME_ACCESS,
792 ):
793     tgthandle = wintypes.HANDLE()
794     kernel32.DuplicateHandle(
795         hsrc, srchandle, htgt, ctypes.byref(tgthandle), access, inherit, options
796     )
797     return tgthandle.value
798 def CreatePipe(inherit_read=False, inherit_write=False):
799     read, write = wintypes.HANDLE(), wintypes.HANDLE()
800     kernel32.CreatePipe(ctypes.byref(read), ctypes.byref(write), None, 0)
801     if inherit_read:
802         kernel32.SetHandleInformation(
803             read, win32con.HANDLE_FLAG_INHERIT, win32con.HANDLE_FLAG_INHERIT
804         )
805     if inherit_write:
806         kernel32.SetHandleInformation(
807             write, win32con.HANDLE_FLAG_INHERIT, win32con.HANDLE_FLAG_INHERIT
808         )
809     return read.value, write.value
810 def set_user_perm(obj, perm, sid):
811     info = (
812         win32security.OWNER_SECURITY_INFORMATION
813         | win32security.GROUP_SECURITY_INFORMATION
814         | win32security.DACL_SECURITY_INFORMATION
815     )
816     sd = win32security.GetUserObjectSecurity(obj, info)
817     dacl = sd.GetSecurityDescriptorDacl()
818     ace_cnt = dacl.GetAceCount()
819     found = False
820     for idx in range(0, ace_cnt):
821         (aceType, aceFlags), ace_mask, ace_sid = dacl.GetAce(idx)
822         ace_exists = (
823             aceType == ntsecuritycon.ACCESS_ALLOWED_ACE_TYPE
824             and ace_mask == perm
825             and ace_sid == sid
826         )
827         if ace_exists:
828             break
829     else:
830         dacl.AddAccessAllowedAce(dacl.GetAclRevision(), perm, sid)
831         sd.SetSecurityDescriptorDacl(1, dacl, 0)
832         win32security.SetUserObjectSecurity(obj, info, sd)
833 def grant_winsta_and_desktop(th):
834     current_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]
835     winsta = win32process.GetProcessWindowStation()
836     set_user_perm(winsta, WINSTA_ALL, current_sid)
837     desktop = win32service.GetThreadDesktop(win32api.GetCurrentThreadId())
838     set_user_perm(desktop, DESKTOP_ALL, current_sid)
839 def environment_string(env):
840     senv = ""
841     for k, v in env.items():
842         senv += k + "=" + v + "\0"
843     senv += "\0"
844     return ctypes.create_unicode_buffer(senv)
845 def CreateProcessWithTokenW(
846     token,
847     logonflags=0,
848     applicationname=None,
849     commandline=None,
850     creationflags=0,
851     environment=None,
852     currentdirectory=None,
853     startupinfo=None,
854 ):
855     creationflags |= win32con.CREATE_UNICODE_ENVIRONMENT
856     if commandline is not None:
857         commandline = ctypes.create_unicode_buffer(commandline)
858     if startupinfo is None:
859         startupinfo = STARTUPINFO()
860     if currentdirectory is not None:
861         currentdirectory = ctypes.create_unicode_buffer(currentdirectory)
862     if environment is not None:
863         environment = ctypes.pointer(environment_string(environment))
864     process_info = PROCESS_INFORMATION()
865     ret = advapi32.CreateProcessWithTokenW(
866         token,
867         logonflags,
868         applicationname,
869         commandline,
870         creationflags,
871         environment,
872         currentdirectory,
873         ctypes.byref(startupinfo),
874         ctypes.byref(process_info),
875     )
876     if ret == 0:
877         winerr = win32api.GetLastError()
878         exc = OSError(win32api.FormatMessage(winerr))
879         exc.winerror = winerr
880         raise exc
881     return process_info
882 def enumerate_tokens(sid=None, session_id=None, privs=None):
883     for p in psutil.process_iter():
884         if p.pid == 0:
885             continue
886         try:
887             ph = win32api.OpenProcess(win32con.PROCESS_ALL_ACCESS, 0, p.pid)
888         except win32api.error as exc:
889             if exc.winerror == 5:
890                 log.debug("Unable to OpenProcess pid=%d name=%s", p.pid, p.name())
891                 continue
892             raise exc
893         try:
894             access = (
895                 win32security.TOKEN_DUPLICATE
896                 | win32security.TOKEN_QUERY
897                 | win32security.TOKEN_IMPERSONATE
898                 | win32security.TOKEN_ASSIGN_PRIMARY
899             )
900             th = win32security.OpenProcessToken(ph, access)
901         except Exception as exc:  # pylint: disable=broad-except
902             log.debug(
903                 "OpenProcessToken failed pid=%d name=%s user%s",
904                 p.pid,
905                 p.name(),
906                 p.username(),
907             )
908             continue
909         try:
910             process_sid = win32security.GetTokenInformation(
911                 th, win32security.TokenUser
912             )[0]
913         except Exception as exc:  # pylint: disable=broad-except
914             log.exception(
915                 "GetTokenInformation pid=%d name=%s user%s",
916                 p.pid,
917                 p.name(),
918                 p.username(),
919             )
920             continue
921         proc_sid = win32security.ConvertSidToStringSid(process_sid)
922         if sid and sid != proc_sid:
923             log.debug("Token for pid does not match user sid: %s", sid)
924             continue
925         if (
926             session_id
927             and win32security.GetTokenInformation(th, win32security.TokenSessionId)
928             != session_id
929         ):
930             continue
931         def has_priv(tok, priv):
932             luid = win32security.LookupPrivilegeValue(None, priv)
933             for priv_luid, flags in win32security.GetTokenInformation(
934                 tok, win32security.TokenPrivileges
935             ):
936                 if priv_luid == luid:
937                     return True
938             return False
939         if privs:
940             has_all = True
941             for name in privs:
942                 if not has_priv(th, name):
943                     has_all = False
944             if not has_all:
945                 continue
946         yield dup_token(th)
947 def impersonate_sid(sid, session_id=None, privs=None):
948     for tok in enumerate_tokens(sid, session_id, privs):
949         tok = dup_token(tok)
950         elevate_token(tok)
951         if win32security.ImpersonateLoggedOnUser(tok) == 0:
952             raise OSError("Impersonation failure")
953         return tok
954     raise OSError("Impersonation failure")
955 def dup_token(th):
956     sec_attr = win32security.SECURITY_ATTRIBUTES()
957     sec_attr.bInheritHandle = True
958     return win32security.DuplicateTokenEx(
959         th,
960         win32security.SecurityImpersonation,
961         win32con.MAXIMUM_ALLOWED,
962         win32security.TokenPrimary,
963         sec_attr,
964     )
965 def elevate_token(th):
966     privileges = win32security.GetTokenInformation(th, win32security.TokenPrivileges)
967     enable_privs = set()
968     for luid, flags in privileges:
969         enable_privs.add((luid, win32con.SE_PRIVILEGE_ENABLED))
970     if win32security.AdjustTokenPrivileges(th, 0, enable_privs) == 0:
971         raise OSError(win32api.FormatMessage(win32api.GetLastError()))
972 def make_inheritable(token):
973     return win32api.DuplicateHandle(
974         win32api.GetCurrentProcess(),
975         token,
976 <a name="2"></a>        win32api.GetCurrentProcess(),
977         0,
978         1,
979         win32con.<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>DUPLICATE_SAME_ACCESS,
980     )
981 def CreateProcessWithLogonW(
982     username=None,
983     domain=None,
984     password=None,
985     logonflags=0,
986     applicationname=None,
987     commandline=None,
988     creationflags=0,
989     environment=None,
990     currentdirectory=None,
991     startupinfo=None,
992 ):
993     creationflags |=</b></font> win32con.CREATE_UNICODE_ENVIRONMENT
994     if commandline is not None:
995         commandline = ctypes.create_unicode_buffer(commandline)
996     if startupinfo is None:
997         startupinfo = STARTUPINFO()
998     if environment is not None:
999         environment = ctypes.pointer(environment_string(environment))
1000     process_info = PROCESS_INFORMATION()
1001     advapi32.CreateProcessWithLogonW(
1002         username,
1003         domain,
1004         password,
1005         logonflags,
1006         applicationname,
1007         commandline,
1008         creationflags,
1009         environment,
1010         currentdirectory,
1011         ctypes.byref(startupinfo),
1012         ctypes.byref(process_info),
1013     )
1014     return process_info
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>netacl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.napalm
3 log = logging.getLogger(__file__)
4 try:
5     import capirca
6     import capirca.aclgen
7     import capirca.lib.policy
8     import capirca.lib.aclgenerator
9     HAS_CAPIRCA = True
10 except ImportError:
11     HAS_CAPIRCA = False
12 __virtualname__ = "netacl"
13 def __virtual__():
14     if HAS_CAPIRCA and salt.utils.napalm.virtual(__opts__, __virtualname__, __file__):
15         return __virtualname__
16     else:
17         return (
18             False,
19             "The netacl state cannot be loaded: Please install capirca and napalm.",
20         )
21 def term(
22 <a name="1"></a>    name,
23     filter_name,
24     term_name,
25     filter_options<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
26     pillar_key="acl",
27     pillarenv=None,
28     saltenv=None,
29     merge_pillar=False,
30     revision_id=None,
31     revision_no=None,
32     revision_date=True,
33     revision_date_format="%Y/%m/%d",
34     test=False,
35     commit=True,
36     debug=False,
37     source_service=None,
38     destination_service=None,
39     **term_fields
40 ):
41     ret =</b></font> salt.utils.napalm.default_ret(name)
42     test = __opts__["test"] or test
43     if not filter_options:
44         filter_options = []
45     loaded = __salt__["netacl.load_term_config"](
46         filter_name,
47         term_name,
48         filter_options=filter_options,
49         pillar_key=pillar_key,
50         pillarenv=pillarenv,
51         saltenv=saltenv,
52         merge_pillar=merge_pillar,
53         revision_id=revision_id if revision_id else name,
54         revision_no=revision_no,
55         revision_date=revision_date,
56         revision_date_format=revision_date_format,
57         source_service=source_service,
58         destination_service=destination_service,
59         test=test,
60         commit=commit,
61         debug=debug,
62         **term_fields
63     )
64     return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)
65 <a name="0"></a>def filter(
66     name,  # pylint: disable=redefined-builtin
67     filter_name,
68     filter_options<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
69     terms=None,
70     prepend=True,
71     pillar_key="acl",
72     pillarenv=None,
73     saltenv=None,
74     merge_pillar=False,
75     only_lower_merge=False,
76     revision_id=None,
77     revision_no=None,
78     revision_date=True,
79     revision_date_format="%Y/%m/%d",
80     test=False,
81     commit=True,
82     debug=False,
83 ):
84     ret = salt.</b></font>utils.napalm.default_ret(name)
85     test = __opts__["test"] or test
86     if not filter_options:
87         filter_options = []
88     if not terms:
89         terms = []
90     loaded = __salt__["netacl.load_filter_config"](
91         filter_name,
92         filter_options=filter_options,
93         terms=terms,
94         prepend=prepend,
95         pillar_key=pillar_key,
96         pillarenv=pillarenv,
97         saltenv=saltenv,
98         merge_pillar=merge_pillar,
99         only_lower_merge=only_lower_merge,
100         revision_id=revision_id if revision_id else name,
101         revision_no=revision_no,
102         revision_date=revision_date,
103         revision_date_format=revision_date_format,
104         test=test,
105 <a name="2"></a>        commit=commit,
106         debug=debug,
107     )
108     return salt.utils.napalm.loaded_ret(<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ret, loaded, test, debug)
109 def managed(
110     name,
111     filters=None,
112     prepend=True,
113     pillar_key="acl",
114     pillarenv=None,
115     saltenv=None,
116     merge_pillar=False,
117     only_lower_merge=False,
118     revision_id=None,
119     revision_no=None,
120     revision_date=True,
121     revision_date_format=</b></font>"%Y/%m/%d",
122     test=False,
123     commit=True,
124     debug=False,
125 ):
126     ret = salt.utils.napalm.default_ret(name)
127     test = __opts__["test"] or test
128     if not filters:
129         filters = []
130     loaded = __salt__["netacl.load_policy_config"](
131         filters=filters,
132         prepend=prepend,
133         pillar_key=pillar_key,
134         pillarenv=pillarenv,
135         saltenv=saltenv,
136         merge_pillar=merge_pillar,
137         only_lower_merge=only_lower_merge,
138         revision_id=revision_id if revision_id else name,
139         revision_no=revision_no,
140         revision_date=revision_date,
141         revision_date_format=revision_date_format,
142         test=test,
143         commit=commit,
144         debug=debug,
145     )
146     return salt.utils.napalm.loaded_ret(ret, loaded, test, debug)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
