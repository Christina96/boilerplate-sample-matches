<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for versions.py &amp; test_docker_network.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for versions.py &amp; test_docker_network.py
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>versions.py (2.6726058%)<th>test_docker_network.py (1.7467248%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-28)<td><a href="#" name="0">(14-24)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>versions.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
3 import inspect
4 import logging
5 import numbers
6 import sys
7 import warnings
8 from distutils.version import LooseVersion as _LooseVersion
9 from distutils.version import StrictVersion as _StrictVersion
10 import salt.version
11 log = logging.getLogger(</b></font>__name__)
12 class StrictVersion(_StrictVersion):
13     def parse(self, vstring):
14         _StrictVersion.parse(self, vstring)
15     def _cmp(self, other):
16         if isinstance(other, str):
17             other = StrictVersion(other)
18         return _StrictVersion._cmp(self, other)
19 class LooseVersion(_LooseVersion):
20     def parse(self, vstring):
21         _LooseVersion.parse(self, vstring)
22         self._str_version = [
23             str(vp).zfill(8) if isinstance(vp, int) else vp for vp in self.version
24         ]
25     def _cmp(self, other):
26         if isinstance(other, str):
27             other = LooseVersion(other)
28         string_in_version = False
29         for part in self.version + other.version:
30             if not isinstance(part, int):
31                 string_in_version = True
32                 break
33         if string_in_version is False:
34             return _LooseVersion._cmp(self, other)
35         if self._str_version == other._str_version:
36             return 0
37         if self._str_version &lt; other._str_version:
38             return -1
39         if self._str_version &gt; other._str_version:
40             return 1
41 def _format_warning(message, category, filename, lineno, line=None):
42     """
43     Replacement for warnings.formatwarning that disables the echoing of
44     the 'line' parameter.
45     """
46     return "{}:{}: {}: {}\n".format(filename, lineno, category.__name__, message)
47 def warn_until(
48     version,
49     message,
50     category=DeprecationWarning,
51     stacklevel=None,
52     _version_info_=None,
53     _dont_call_warnings=False,
54 ):
55     """
56     Helper function to raise a warning, by default, a ``DeprecationWarning``,
57     until the provided ``version``, after which, a ``RuntimeError`` will
58     be raised to remind the developers to remove the warning because the
59     target version has been reached.
60     :param version: The version info or name after which the warning becomes a ``RuntimeError``.
61                     For example ``(2019, 2)``, ``3000``, ``Hydrogen`` or an instance of
62                     :class:`salt.version.SaltStackVersion` or :class:`salt.version.SaltVersion`.
63     :param message: The warning message to be displayed.
64     :param category: The warning class to be thrown, by default
65                      ``DeprecationWarning``
66     :param stacklevel: There should be no need to set the value of
67                        ``stacklevel``. Salt should be able to do the right thing.
68     :param _version_info_: In order to reuse this function for other SaltStack
69                            projects, they need to be able to provide the
70                            version info to compare to.
71     :param _dont_call_warnings: This parameter is used just to get the
72                                 functionality until the actual error is to be
73                                 issued. When we're only after the salt version
74                                 checks to raise a ``RuntimeError``.
75     """
76     if isinstance(version, salt.version.SaltVersion):
77         version = salt.version.SaltStackVersion(*version.info)
78     elif isinstance(version, int):
79         version = salt.version.SaltStackVersion(version)
80     elif isinstance(version, tuple):
81         version = salt.version.SaltStackVersion(*version)
82     elif isinstance(version, str):
83         if version.lower() not in salt.version.SaltStackVersion.LNAMES:
84             raise RuntimeError(
85                 "Incorrect spelling for the release name in the warn_utils "
86                 "call. Expecting one of these release names: {}".format(
87                     [vs.name for vs in salt.version.SaltVersionsInfo.versions()]
88                 )
89             )
90         version = salt.version.SaltStackVersion.from_name(version)
91     elif not isinstance(version, salt.version.SaltStackVersion):
92         raise RuntimeError(
93             "The 'version' argument should be passed as a tuple, integer, string or "
94             "an instance of 'salt.version.SaltVersion' or "
95             "'salt.version.SaltStackVersion'."
96         )
97     if stacklevel is None:
98         stacklevel = 2
99     if _version_info_ is None:
100         _version_info_ = salt.version.__version_info__
101     _version_ = salt.version.SaltStackVersion(*_version_info_)
102     if _version_ &gt;= version:
103         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
104         raise RuntimeError(
105             "The warning triggered on filename '{filename}', line number "
106             "{lineno}, is supposed to be shown until version "
107             "{until_version} is released. Current version is now "
108             "{salt_version}. Please remove the warning.".format(
109                 filename=caller.filename,
110                 lineno=caller.lineno,
111                 until_version=version.formatted_version,
112                 salt_version=_version_.formatted_version,
113             ),
114         )
115     if _dont_call_warnings is False:
116         warnings.warn(
117             message.format(version=version.formatted_version),
118             category,
119             stacklevel=stacklevel,
120         )
121 def warn_until_date(
122     date,
123     message,
124     category=DeprecationWarning,
125     stacklevel=None,
126     _current_date=None,
127     _dont_call_warnings=False,
128 ):
129     """
130     Helper function to raise a warning, by default, a ``DeprecationWarning``,
131     until the provided ``date``, after which, a ``RuntimeError`` will
132     be raised to remind the developers to remove the warning because the
133     target date has been reached.
134     :param date: A ``datetime.date`` or ``datetime.datetime`` instance.
135     :param message: The warning message to be displayed.
136     :param category: The warning class to be thrown, by default
137                      ``DeprecationWarning``
138     :param stacklevel: There should be no need to set the value of
139                        ``stacklevel``. Salt should be able to do the right thing.
140     :param _dont_call_warnings: This parameter is used just to get the
141                                 functionality until the actual error is to be
142                                 issued. When we're only after the date
143                                 checks to raise a ``RuntimeError``.
144     """
145     _strptime_fmt = "%Y%m%d"
146     if not isinstance(date, (str, datetime.date, datetime.datetime)):
147         raise RuntimeError(
148             "The 'date' argument should be passed as a 'datetime.date()' or "
149             "'datetime.datetime()' objects or as string parserable by "
150             "'datetime.datetime.strptime()' with the following format '{}'.".format(
151                 _strptime_fmt
152             )
153         )
154     elif isinstance(date, str):
155         date = datetime.datetime.strptime(date, _strptime_fmt)
156     if isinstance(date, datetime.datetime):
157         date = date.date()
158     if stacklevel is None:
159         stacklevel = 2
160     today = _current_date or datetime.datetime.utcnow().date()
161     if today &gt;= date:
162         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
163         raise RuntimeError(
164             "{message} This warning(now exception) triggered on "
165             "filename '{filename}', line number {lineno}, is "
166             "supposed to be shown until {date}. Today is {today}. "
167             "Please remove the warning.".format(
168                 message=message.format(date=date.isoformat(), today=today.isoformat()),
169                 filename=caller.filename,
170                 lineno=caller.lineno,
171                 date=date.isoformat(),
172                 today=today.isoformat(),
173             ),
174         )
175     if _dont_call_warnings is False:
176         warnings.warn(
177             message.format(date=date.isoformat(), today=today.isoformat()),
178             category,
179             stacklevel=stacklevel,
180         )
181 def kwargs_warn_until(
182     kwargs,
183     version,
184     category=DeprecationWarning,
185     stacklevel=None,
186     _version_info_=None,
187     _dont_call_warnings=False,
188 ):
189     """
190     Helper function to raise a warning (by default, a ``DeprecationWarning``)
191     when unhandled keyword arguments are passed to function, until the
192     provided ``version_info``, after which, a ``RuntimeError`` will be raised
193     to remind the developers to remove the ``**kwargs`` because the target
194     version has been reached.
195     This function is used to help deprecate unused legacy ``**kwargs`` that
196     were added to function parameters lists to preserve backwards compatibility
197     when removing a parameter. See
198     :ref:`the deprecation development docs &lt;deprecations&gt;`
199     for the modern strategy for deprecating a function parameter.
200     :param kwargs: The caller's ``**kwargs`` argument value (a ``dict``).
201     :param version: The version info or name after which the warning becomes a
202                     ``RuntimeError``. For example ``(0, 17)`` or ``Hydrogen``
203                     or an instance of :class:`salt.version.SaltStackVersion`.
204     :param category: The warning class to be thrown, by default
205                      ``DeprecationWarning``
206     :param stacklevel: There should be no need to set the value of
207                        ``stacklevel``. Salt should be able to do the right thing.
208     :param _version_info_: In order to reuse this function for other SaltStack
209                            projects, they need to be able to provide the
210                            version info to compare to.
211     :param _dont_call_warnings: This parameter is used just to get the
212                                 functionality until the actual error is to be
213                                 issued. When we're only after the salt version
214                                 checks to raise a ``RuntimeError``.
215     """
216     if not isinstance(version, (tuple, str, salt.version.SaltStackVersion)):
217         raise RuntimeError(
218             "The 'version' argument should be passed as a tuple, string or "
219             "an instance of 'salt.version.SaltStackVersion'."
220         )
221     elif isinstance(version, tuple):
222         version = salt.version.SaltStackVersion(*version)
223     elif isinstance(version, str):
224         version = salt.version.SaltStackVersion.from_name(version)
225     if stacklevel is None:
226         stacklevel = 3
227     if _version_info_ is None:
228         _version_info_ = salt.version.__version_info__
229     _version_ = salt.version.SaltStackVersion(*_version_info_)
230     if kwargs or _version_.info &gt;= version.info:
231         arg_names = ", ".join("'{}'".format(key) for key in kwargs)
232         warn_until(
233             version,
234             message=(
235                 "The following parameter(s) have been deprecated and "
236                 "will be removed in '{}': {}.".format(version.string, arg_names)
237             ),
238             category=category,
239             stacklevel=stacklevel,
240             _version_info_=_version_.info,
241             _dont_call_warnings=_dont_call_warnings,
242         )
243 def version_cmp(pkg1, pkg2, ignore_epoch=False):
244     """
245     Compares two version strings using salt.utils.versions.LooseVersion. This
246     is a fallback for providers which don't have a version comparison utility
247     built into them.  Return -1 if version1 &lt; version2, 0 if version1 ==
248     version2, and 1 if version1 &gt; version2. Return None if there was a problem
249     making the comparison.
250     """
251     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
252     pkg1 = normalize(pkg1)
253     pkg2 = normalize(pkg2)
254     try:
255         if LooseVersion(pkg1) &lt; LooseVersion(pkg2):
256             return -1
257         elif LooseVersion(pkg1) == LooseVersion(pkg2):
258             return 0
259         elif LooseVersion(pkg1) &gt; LooseVersion(pkg2):
260             return 1
261     except Exception as exc:  # pylint: disable=broad-except
262         log.exception(exc)
263     return None
264 def compare(ver1="", oper="==", ver2="", cmp_func=None, ignore_epoch=False):
265     """
266     Compares two version numbers. Accepts a custom function to perform the
267     cmp-style version comparison, otherwise uses version_cmp().
268     """
269     cmp_map = {"&lt;": (-1,), "&lt;=": (-1, 0), "==": (0,), "&gt;=": (0, 1), "&gt;": (1,)}
270     if oper not in ("!=",) and oper not in cmp_map:
271         log.error("Invalid operator '%s' for version comparison", oper)
272         return False
273     if cmp_func is None:
274         cmp_func = version_cmp
275     cmp_result = cmp_func(ver1, ver2, ignore_epoch=ignore_epoch)
276     if cmp_result is None:
277         return False
278     if not isinstance(cmp_result, numbers.Integral):
279         log.error("The version comparison function did not return an integer/long.")
280         return False
281     if oper == "!=":
282         return cmp_result not in cmp_map["=="]
283     else:
284         if cmp_result &lt; -1:
285             cmp_result = -1
286         elif cmp_result &gt; 1:
287             cmp_result = 1
288         return cmp_result in cmp_map[oper]
289 def check_boto_reqs(
290     boto_ver=None, boto3_ver=None, botocore_ver=None, check_boto=True, check_boto3=True
291 ):
292     """
293     Checks for the version of various required boto libs in one central location. Most
294     boto states and modules rely on a single version of the boto, boto3, or botocore libs.
295     However, some require newer versions of any of these dependencies. This function allows
296     the module to pass in a version to override the default minimum required version.
297     This function is useful in centralizing checks for ``__virtual__()`` functions in the
298     various, and many, boto modules and states.
299     boto_ver
300         The minimum required version of the boto library. Defaults to ``2.0.0``.
301     boto3_ver
302         The minimum required version of the boto3 library. Defaults to ``1.2.6``.
303     botocore_ver
304         The minimum required version of the botocore library. Defaults to ``1.3.23``.
305     check_boto
306         Boolean defining whether or not to check for boto deps. This defaults to ``True`` as
307         most boto modules/states rely on boto, but some do not.
308     check_boto3
309         Boolean defining whether or not to check for boto3 (and therefore botocore) deps.
310         This defaults to ``True`` as most boto modules/states rely on boto3/botocore, but
311         some do not.
312     """
313     if check_boto is True:
314         try:
315             import boto
316             has_boto = True
317         except ImportError:
318             has_boto = False
319         if boto_ver is None:
320             boto_ver = "2.0.0"
321         if not has_boto or version_cmp(boto.__version__, boto_ver) == -1:
322             return False, "A minimum version of boto {} is required.".format(boto_ver)
323     if check_boto3 is True:
324         try:
325             import boto3
326             import botocore
327             has_boto3 = True
328         except ImportError:
329             has_boto3 = False
330         if boto3_ver is None:
331             boto3_ver = "1.2.6"
332         if botocore_ver is None:
333             botocore_ver = "1.3.23"
334         if not has_boto3 or version_cmp(boto3.__version__, boto3_ver) == -1:
335             return (
336                 False,
337                 "A minimum version of boto3 {} is required.".format(boto3_ver),
338             )
339         elif version_cmp(botocore.__version__, botocore_ver) == -1:
340             return (
341                 False,
342                 "A minimum version of botocore {} is required".format(botocore_ver),
343             )
344     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_docker_network.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Integration tests for the docker_network states
3 """
4 import errno
5 import functools
6 import logging
7 import os
8 import subprocess
9 import tempfile
10 import pytest
11 import salt.utils.files
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.network
13 import salt.utils.path
14 from salt.exceptions import CommandExecutionError
15 from tests.support.case import ModuleCase
16 from tests.support.docker import random_name, with_network
17 from tests.support.helpers import requires_system_grains
18 from tests.support.mixins import SaltReturnAssertsMixin
19 from tests.support.runtests import RUNTIME_VARS
20 from tests.support.unit import skipIf
21 log = logging.getLogger(</b></font>__name__)
22 IMAGE_NAME = random_name(prefix="salt_busybox_")
23 IPV6_ENABLED = bool(salt.utils.network.ip_addrs6(include_loopback=True))
24 def network_name(func):
25     """
26     Generate a randomized name for a network and clean it up afterward
27     """
28     @functools.wraps(func)
29     def wrapper(self, *args, **kwargs):
30         name = random_name(prefix="salt_net_")
31         try:
32             return func(self, name, *args, **kwargs)
33         finally:
34             self.run_function("docker.disconnect_all_containers_from_network", [name])
35             try:
36                 self.run_function("docker.remove_network", [name])
37             except CommandExecutionError as exc:
38                 if "No such network" not in exc.__str__():
39                     raise
40     return wrapper
41 def container_name(func):
42     """
43     Generate a randomized name for a container and clean it up afterward
44     """
45     def build_image():
46         image_build_rootdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
47         script_path = os.path.join(RUNTIME_VARS.BASE_FILES, "mkimage-busybox-static")
48         cmd = [script_path, image_build_rootdir, IMAGE_NAME]
49         log.debug("Running '%s' to build busybox image", " ".join(cmd))
50         process = subprocess.Popen(
51             cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
52         )
53         output = process.communicate()[0]
54         log.debug("Output from mkimge-busybox-static:\n%s", output)
55         if process.returncode != 0:
56             raise Exception("Failed to build image")
57         try:
58             salt.utils.files.rm_rf(image_build_rootdir)
59         except OSError as exc:
60             if exc.errno != errno.ENOENT:
61                 raise
62     @functools.wraps(func)
63     def wrapper(self, *args, **kwargs):
64         try:
65             self.run_function("docker.inspect_image", [IMAGE_NAME])
66         except CommandExecutionError:
67             pass
68         else:
69             build_image()
70         name = random_name(prefix="salt_test_")
71         self.run_function(
72             "docker.create",
73             name=name,
74             image=IMAGE_NAME,
75             command="sleep 600",
76             start=True,
77         )
78         try:
79             return func(self, name, *args, **kwargs)
80         finally:
81             try:
82                 self.run_function("docker.rm", [name], force=True)
83             except CommandExecutionError as exc:
84                 if "No such container" not in exc.__str__():
85                     raise
86     return wrapper
87 @pytest.mark.destructive_test
88 @pytest.mark.slow_test
89 @skipIf(salt.utils.platform.is_freebsd(), "No Docker on FreeBSD available")
90 @skipIf(not salt.utils.path.which("dockerd"), "Docker not installed")
91 class DockerNetworkTestCase(ModuleCase, SaltReturnAssertsMixin):
92     """
93     Test docker_network states
94     """
95     @classmethod
96     def tearDownClass(cls):
97         """
98         Remove test image if present. Note that this will run a docker rmi even
99         if no test which required the image was run.
100         """
101         cmd = ["docker", "rmi", "--force", IMAGE_NAME]
102         log.debug("Running '%s' to destroy busybox image", " ".join(cmd))
103         process = subprocess.Popen(
104             cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
105         )
106         output = process.communicate()[0]
107         log.debug("Output from %s:\n%s", " ".join(cmd), output)
108         if process.returncode != 0 and "No such image" not in str(output):
109             raise Exception("Failed to destroy image")
110     def run_state(self, function, **kwargs):
111         ret = super().run_state(function, **kwargs)
112         log.debug("ret = %s", ret)
113         return ret
114     @with_network(create=False)
115     @pytest.mark.slow_test
116     def test_absent(self, net):
117         self.assertSaltTrueReturn(
118             self.run_state("docker_network.present", name=net.name)
119         )
120         ret = self.run_state("docker_network.absent", name=net.name)
121         self.assertSaltTrueReturn(ret)
122         ret = ret[next(iter(ret))]
123         self.assertEqual(ret["changes"], {"removed": True})
124         self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))
125     @container_name
126     @with_network(create=False)
127     @pytest.mark.slow_test
128     @pytest.mark.skipif(
129         salt.utils.platform.is_photonos() is True,
130         reason="Skip on PhotonOS.  No busybox available.",
131     )
132     def test_absent_with_disconnected_container(self, net, container_name):
133         self.assertSaltTrueReturn(
134             self.run_state(
135                 "docker_network.present", name=net.name, containers=[container_name]
136             )
137         )
138         ret = self.run_state("docker_network.absent", name=net.name)
139         self.assertSaltTrueReturn(ret)
140         ret = ret[next(iter(ret))]
141         self.assertEqual(
142             ret["changes"], {"removed": True, "disconnected": [container_name]}
143         )
144         self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))
145     @with_network(create=False)
146     @pytest.mark.slow_test
147     def test_absent_when_not_present(self, net):
148         ret = self.run_state("docker_network.absent", name=net.name)
149         self.assertSaltTrueReturn(ret)
150         ret = ret[next(iter(ret))]
151         self.assertEqual(ret["changes"], {})
152         self.assertEqual(ret["comment"], "Network '{}' already absent".format(net.name))
153     @with_network(create=False)
154     @pytest.mark.slow_test
155     def test_present(self, net):
156         ret = self.run_state("docker_network.present", name=net.name)
157         self.assertSaltTrueReturn(ret)
158         ret = ret[next(iter(ret))]
159         self.assertEqual(ret["changes"], {"created": True})
160         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
161         self.run_function("docker.inspect_network", [net.name])
162     @container_name
163     @with_network(create=False)
164     @pytest.mark.slow_test
165     @pytest.mark.skipif(
166         salt.utils.platform.is_photonos() is True,
167         reason="Skip on PhotonOS.  No busybox available.",
168     )
169     def test_present_with_containers(self, net, container_name):
170         ret = self.run_state(
171             "docker_network.present", name=net.name, containers=[container_name]
172         )
173         self.assertSaltTrueReturn(ret)
174         ret = ret[next(iter(ret))]
175         self.assertEqual(
176             ret["changes"], {"created": True, "connected": [container_name]}
177         )
178         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
179         self.run_function("docker.inspect_network", [net.name])
180     def _test_present_reconnect(self, net, container_name, reconnect=True):
181         ret = self.run_state("docker_network.present", name=net.name, driver="bridge")
182         self.assertSaltTrueReturn(ret)
183         ret = ret[next(iter(ret))]
184         self.assertEqual(ret["changes"], {"created": True})
185         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
186         self.run_function(
187             "docker.connect_container_to_network", [container_name, net.name]
188         )
189         ret = self.run_state(
190             "docker_network.present",
191             name=net.name,
192             driver="macvlan",
193             reconnect=reconnect,
194         )
195         self.assertSaltTrueReturn(ret)
196         ret = ret[next(iter(ret))]
197         self.assertEqual(
198             ret["changes"],
199             {
200                 "recreated": True,
201                 "reconnected" if reconnect else "disconnected": [container_name],
202                 net.name: {"Driver": {"old": "bridge", "new": "macvlan"}},
203             },
204         )
205         self.assertEqual(
206             ret["comment"],
207             "Network '{}' was replaced with updated config".format(net.name),
208         )
209     @container_name
210     @with_network(create=False)
211     @pytest.mark.slow_test
212     @pytest.mark.skipif(
213         salt.utils.platform.is_photonos() is True,
214         reason="Skip on PhotonOS.  No busybox available.",
215     )
216     def test_present_with_reconnect(self, net, container_name):
217         """
218         Test reconnecting with containers not passed to state
219         """
220         self._test_present_reconnect(net, container_name, reconnect=True)
221     @container_name
222     @with_network(create=False)
223     @pytest.mark.slow_test
224     @pytest.mark.skipif(
225         salt.utils.platform.is_photonos() is True,
226         reason="Skip on PhotonOS.  No busybox available.",
227     )
228     def test_present_with_no_reconnect(self, net, container_name):
229         """
230         Test reconnecting with containers not passed to state
231         """
232         self._test_present_reconnect(net, container_name, reconnect=False)
233     @with_network()
234     @pytest.mark.slow_test
235     def test_present_internal(self, net):
236         self.assertSaltTrueReturn(
237             self.run_state(
238                 "docker_network.present",
239                 name=net.name,
240                 internal=True,
241             )
242         )
243         net_info = self.run_function("docker.inspect_network", [net.name])
244         self.assertIs(net_info["Internal"], True)
245     @with_network()
246     @pytest.mark.slow_test
247     def test_present_labels(self, net):
248         self.assertSaltTrueReturn(
249             self.run_state(
250                 "docker_network.present",
251                 name=net.name,
252                 labels=["foo", "bar=baz", {"hello": "world"}],
253             )
254         )
255         net_info = self.run_function("docker.inspect_network", [net.name])
256         self.assertEqual(
257             net_info["Labels"],
258             {"foo": "", "bar": "baz", "hello": "world"},
259         )
260     @with_network(subnet="fe3f:2180:26:1::/123")
261     @with_network(subnet="10.247.197.96/27")
262     @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
263     @pytest.mark.slow_test
264     def test_present_enable_ipv6(self, net1, net2):
265         self.assertSaltTrueReturn(
266             self.run_state(
267                 "docker_network.present",
268                 name=net1.name,
269                 enable_ipv6=True,
270                 ipam_pools=[{"subnet": net1.subnet}, {"subnet": net2.subnet}],
271             )
272         )
273         net_info = self.run_function("docker.inspect_network", [net1.name])
274         self.assertIs(net_info["EnableIPv6"], True)
275     @requires_system_grains
276     @with_network()
277     @pytest.mark.slow_test
278     def test_present_attachable(self, net, grains):
279         if grains["os_family"] == "RedHat" and grains.get("osmajorrelease", 0) &lt;= 7:
280             self.skipTest("Cannot reliably manage attachable on RHEL &lt;= 7")
281         self.assertSaltTrueReturn(
282             self.run_state(
283                 "docker_network.present",
284                 name=net.name,
285                 attachable=True,
286             )
287         )
288         net_info = self.run_function("docker.inspect_network", [net.name])
289         self.assertIs(net_info["Attachable"], True)
290     @skipIf(True, "Skip until we can set up docker swarm testing")
291     @with_network()
292     def test_present_scope(self, net):
293         self.assertSaltTrueReturn(
294             self.run_state(
295                 "docker_network.present",
296                 name=net.name,
297                 scope="global",
298             )
299         )
300         net_info = self.run_function("docker.inspect_network", [net.name])
301         self.assertIs(net_info["Scope"], "global")
302     @skipIf(True, "Skip until we can set up docker swarm testing")
303     @with_network()
304     def test_present_ingress(self, net):
305         self.assertSaltTrueReturn(
306             self.run_state(
307                 "docker_network.present",
308                 name=net.name,
309                 ingress=True,
310             )
311         )
312         net_info = self.run_function("docker.inspect_network", [net.name])
313         self.assertIs(net_info["Ingress"], True)
314     @with_network(subnet="10.247.197.128/27")
315     @with_network(subnet="10.247.197.96/27")
316     @pytest.mark.slow_test
317     def test_present_with_custom_ipv4(self, net1, net2):
318         self.assertSaltTrueReturn(
319             self.run_state(
320                 "docker_network.present",
321                 name=net1.name,
322                 subnet=net1.subnet,
323                 gateway=net1.gateway,
324             )
325         )
326         ret = self.run_state(
327             "docker_network.present",
328             name=net1.name,  # We want to keep the same network name
329             ipam_pools=[{"subnet": net2.subnet, "gateway": net2.gateway}],
330         )
331         self.assertSaltTrueReturn(ret)
332         ret = ret[next(iter(ret))]
333         expected = {
334             "recreated": True,
335             net1.name: {
336                 "IPAM": {
337                     "Config": {
338                         "old": [{"Subnet": net1.subnet, "Gateway": net1.gateway}],
339                         "new": [{"Subnet": net2.subnet, "Gateway": net2.gateway}],
340                     }
341                 }
342             },
343         }
344         self.assertEqual(ret["changes"], expected)
345         self.assertEqual(
346             ret["comment"],
347             "Network '{}' was replaced with updated config".format(net1.name),
348         )
349     @with_network(subnet="fe3f:2180:26:1::20/123")
350     @with_network(subnet="fe3f:2180:26:1::/123")
351     @with_network(subnet="10.247.197.96/27")
352     @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
353     @pytest.mark.slow_test
354     def test_present_with_custom_ipv6(self, ipv4_net, ipv6_net1, ipv6_net2):
355         self.assertSaltTrueReturn(
356             self.run_state(
357                 "docker_network.present",
358                 name=ipv4_net.name,
359                 enable_ipv6=True,
360                 ipam_pools=[
361                     {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
362                     {"subnet": ipv6_net1.subnet, "gateway": ipv6_net1.gateway},
363                 ],
364             )
365         )
366         ret = self.run_state(
367             "docker_network.present",
368             name=ipv4_net.name,  # We want to keep the same network name
369             enable_ipv6=True,
370             ipam_pools=[
371                 {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
372                 {"subnet": ipv6_net2.subnet, "gateway": ipv6_net2.gateway},
373             ],
374         )
375         self.assertSaltTrueReturn(ret)
376         ret = ret[next(iter(ret))]
377         expected = {
378             "recreated": True,
379             ipv4_net.name: {
380                 "IPAM": {
381                     "Config": {
382                         "old": [
383                             {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
384                             {"Subnet": ipv6_net1.subnet, "Gateway": ipv6_net1.gateway},
385                         ],
386                         "new": [
387                             {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
388                             {"Subnet": ipv6_net2.subnet, "Gateway": ipv6_net2.gateway},
389                         ],
390                     }
391                 }
392             },
393         }
394         self.assertEqual(ret["changes"], expected)
395         self.assertEqual(
396             ret["comment"],
397             "Network '{}' was replaced with updated config".format(ipv4_net.name),
398         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
