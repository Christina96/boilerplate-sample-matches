<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for versions.py &amp; test_docker_network.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for versions.py &amp; test_docker_network.py
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>versions.py (2.6726058%)<th>test_docker_network.py (1.7467248%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-28)<td><a href="#" name="0">(14-24)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>versions.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
2 import inspect
3 import logging
4 import numbers
5 import sys
6 import warnings
7 from distutils.version import LooseVersion as _LooseVersion
8 from distutils.version import StrictVersion as _StrictVersion
9 import salt.version
10 log = logging.getLogger(</b></font>__name__)
11 class StrictVersion(_StrictVersion):
12     def parse(self, vstring):
13         _StrictVersion.parse(self, vstring)
14     def _cmp(self, other):
15         if isinstance(other, str):
16             other = StrictVersion(other)
17         return _StrictVersion._cmp(self, other)
18 class LooseVersion(_LooseVersion):
19     def parse(self, vstring):
20         _LooseVersion.parse(self, vstring)
21         self._str_version = [
22             str(vp).zfill(8) if isinstance(vp, int) else vp for vp in self.version
23         ]
24     def _cmp(self, other):
25         if isinstance(other, str):
26             other = LooseVersion(other)
27         string_in_version = False
28         for part in self.version + other.version:
29             if not isinstance(part, int):
30                 string_in_version = True
31                 break
32         if string_in_version is False:
33             return _LooseVersion._cmp(self, other)
34         if self._str_version == other._str_version:
35             return 0
36         if self._str_version &lt; other._str_version:
37             return -1
38         if self._str_version &gt; other._str_version:
39             return 1
40 def _format_warning(message, category, filename, lineno, line=None):
41     return "{}:{}: {}: {}\n".format(filename, lineno, category.__name__, message)
42 def warn_until(
43     version,
44     message,
45     category=DeprecationWarning,
46     stacklevel=None,
47     _version_info_=None,
48     _dont_call_warnings=False,
49 ):
50     if isinstance(version, salt.version.SaltVersion):
51         version = salt.version.SaltStackVersion(*version.info)
52     elif isinstance(version, int):
53         version = salt.version.SaltStackVersion(version)
54     elif isinstance(version, tuple):
55         version = salt.version.SaltStackVersion(*version)
56     elif isinstance(version, str):
57         if version.lower() not in salt.version.SaltStackVersion.LNAMES:
58             raise RuntimeError(
59                 "Incorrect spelling for the release name in the warn_utils "
60                 "call. Expecting one of these release names: {}".format(
61                     [vs.name for vs in salt.version.SaltVersionsInfo.versions()]
62                 )
63             )
64         version = salt.version.SaltStackVersion.from_name(version)
65     elif not isinstance(version, salt.version.SaltStackVersion):
66         raise RuntimeError(
67             "The 'version' argument should be passed as a tuple, integer, string or "
68             "an instance of 'salt.version.SaltVersion' or "
69             "'salt.version.SaltStackVersion'."
70         )
71     if stacklevel is None:
72         stacklevel = 2
73     if _version_info_ is None:
74         _version_info_ = salt.version.__version_info__
75     _version_ = salt.version.SaltStackVersion(*_version_info_)
76     if _version_ &gt;= version:
77         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
78         raise RuntimeError(
79             "The warning triggered on filename '{filename}', line number "
80             "{lineno}, is supposed to be shown until version "
81             "{until_version} is released. Current version is now "
82             "{salt_version}. Please remove the warning.".format(
83                 filename=caller.filename,
84                 lineno=caller.lineno,
85                 until_version=version.formatted_version,
86                 salt_version=_version_.formatted_version,
87             ),
88         )
89     if _dont_call_warnings is False:
90         warnings.warn(
91             message.format(version=version.formatted_version),
92             category,
93             stacklevel=stacklevel,
94         )
95 def warn_until_date(
96     date,
97     message,
98     category=DeprecationWarning,
99     stacklevel=None,
100     _current_date=None,
101     _dont_call_warnings=False,
102 ):
103     _strptime_fmt = "%Y%m%d"
104     if not isinstance(date, (str, datetime.date, datetime.datetime)):
105         raise RuntimeError(
106             "The 'date' argument should be passed as a 'datetime.date()' or "
107             "'datetime.datetime()' objects or as string parserable by "
108             "'datetime.datetime.strptime()' with the following format '{}'.".format(
109                 _strptime_fmt
110             )
111         )
112     elif isinstance(date, str):
113         date = datetime.datetime.strptime(date, _strptime_fmt)
114     if isinstance(date, datetime.datetime):
115         date = date.date()
116     if stacklevel is None:
117         stacklevel = 2
118     today = _current_date or datetime.datetime.utcnow().date()
119     if today &gt;= date:
120         caller = inspect.getframeinfo(sys._getframe(stacklevel - 1))
121         raise RuntimeError(
122             "{message} This warning(now exception) triggered on "
123             "filename '{filename}', line number {lineno}, is "
124             "supposed to be shown until {date}. Today is {today}. "
125             "Please remove the warning.".format(
126                 message=message.format(date=date.isoformat(), today=today.isoformat()),
127                 filename=caller.filename,
128                 lineno=caller.lineno,
129                 date=date.isoformat(),
130                 today=today.isoformat(),
131             ),
132         )
133     if _dont_call_warnings is False:
134         warnings.warn(
135             message.format(date=date.isoformat(), today=today.isoformat()),
136             category,
137             stacklevel=stacklevel,
138         )
139 def kwargs_warn_until(
140     kwargs,
141     version,
142     category=DeprecationWarning,
143     stacklevel=None,
144     _version_info_=None,
145     _dont_call_warnings=False,
146 ):
147     if not isinstance(version, (tuple, str, salt.version.SaltStackVersion)):
148         raise RuntimeError(
149             "The 'version' argument should be passed as a tuple, string or "
150             "an instance of 'salt.version.SaltStackVersion'."
151         )
152     elif isinstance(version, tuple):
153         version = salt.version.SaltStackVersion(*version)
154     elif isinstance(version, str):
155         version = salt.version.SaltStackVersion.from_name(version)
156     if stacklevel is None:
157         stacklevel = 3
158     if _version_info_ is None:
159         _version_info_ = salt.version.__version_info__
160     _version_ = salt.version.SaltStackVersion(*_version_info_)
161     if kwargs or _version_.info &gt;= version.info:
162         arg_names = ", ".join("'{}'".format(key) for key in kwargs)
163         warn_until(
164             version,
165             message=(
166                 "The following parameter(s) have been deprecated and "
167                 "will be removed in '{}': {}.".format(version.string, arg_names)
168             ),
169             category=category,
170             stacklevel=stacklevel,
171             _version_info_=_version_.info,
172             _dont_call_warnings=_dont_call_warnings,
173         )
174 def version_cmp(pkg1, pkg2, ignore_epoch=False):
175     normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
176     pkg1 = normalize(pkg1)
177     pkg2 = normalize(pkg2)
178     try:
179         if LooseVersion(pkg1) &lt; LooseVersion(pkg2):
180             return -1
181         elif LooseVersion(pkg1) == LooseVersion(pkg2):
182             return 0
183         elif LooseVersion(pkg1) &gt; LooseVersion(pkg2):
184             return 1
185     except Exception as exc:  # pylint: disable=broad-except
186         log.exception(exc)
187     return None
188 def compare(ver1="", oper="==", ver2="", cmp_func=None, ignore_epoch=False):
189     cmp_map = {"&lt;": (-1,), "&lt;=": (-1, 0), "==": (0,), "&gt;=": (0, 1), "&gt;": (1,)}
190     if oper not in ("!=",) and oper not in cmp_map:
191         log.error("Invalid operator '%s' for version comparison", oper)
192         return False
193     if cmp_func is None:
194         cmp_func = version_cmp
195     cmp_result = cmp_func(ver1, ver2, ignore_epoch=ignore_epoch)
196     if cmp_result is None:
197         return False
198     if not isinstance(cmp_result, numbers.Integral):
199         log.error("The version comparison function did not return an integer/long.")
200         return False
201     if oper == "!=":
202         return cmp_result not in cmp_map["=="]
203     else:
204         if cmp_result &lt; -1:
205             cmp_result = -1
206         elif cmp_result &gt; 1:
207             cmp_result = 1
208         return cmp_result in cmp_map[oper]
209 def check_boto_reqs(
210     boto_ver=None, boto3_ver=None, botocore_ver=None, check_boto=True, check_boto3=True
211 ):
212     if check_boto is True:
213         try:
214             import boto
215             has_boto = True
216         except ImportError:
217             has_boto = False
218         if boto_ver is None:
219             boto_ver = "2.0.0"
220         if not has_boto or version_cmp(boto.__version__, boto_ver) == -1:
221             return False, "A minimum version of boto {} is required.".format(boto_ver)
222     if check_boto3 is True:
223         try:
224             import boto3
225             import botocore
226             has_boto3 = True
227         except ImportError:
228             has_boto3 = False
229         if boto3_ver is None:
230             boto3_ver = "1.2.6"
231         if botocore_ver is None:
232             botocore_ver = "1.3.23"
233         if not has_boto3 or version_cmp(boto3.__version__, boto3_ver) == -1:
234             return (
235                 False,
236                 "A minimum version of boto3 {} is required.".format(boto3_ver),
237             )
238         elif version_cmp(botocore.__version__, botocore_ver) == -1:
239             return (
240                 False,
241                 "A minimum version of botocore {} is required".format(botocore_ver),
242             )
243     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_docker_network.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import functools
3 import logging
4 import os
5 import subprocess
6 import tempfile
7 <a name="0"></a>
8 import pytest
9 import salt.utils.files
10 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.network
11 import salt.utils.path
12 from salt.exceptions import CommandExecutionError
13 from tests.support.case import ModuleCase
14 from tests.support.docker import random_name, with_network
15 from tests.support.helpers import requires_system_grains
16 from tests.support.mixins import SaltReturnAssertsMixin
17 from tests.support.runtests import RUNTIME_VARS
18 from tests.support.unit import skipIf
19 log = logging.getLogger(</b></font>__name__)
20 IMAGE_NAME = random_name(prefix="salt_busybox_")
21 IPV6_ENABLED = bool(salt.utils.network.ip_addrs6(include_loopback=True))
22 def network_name(func):
23     @functools.wraps(func)
24     def wrapper(self, *args, **kwargs):
25         name = random_name(prefix="salt_net_")
26         try:
27             return func(self, name, *args, **kwargs)
28         finally:
29             self.run_function("docker.disconnect_all_containers_from_network", [name])
30             try:
31                 self.run_function("docker.remove_network", [name])
32             except CommandExecutionError as exc:
33                 if "No such network" not in exc.__str__():
34                     raise
35     return wrapper
36 def container_name(func):
37     def build_image():
38         image_build_rootdir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
39         script_path = os.path.join(RUNTIME_VARS.BASE_FILES, "mkimage-busybox-static")
40         cmd = [script_path, image_build_rootdir, IMAGE_NAME]
41         log.debug("Running '%s' to build busybox image", " ".join(cmd))
42         process = subprocess.Popen(
43             cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
44         )
45         output = process.communicate()[0]
46         log.debug("Output from mkimge-busybox-static:\n%s", output)
47         if process.returncode != 0:
48             raise Exception("Failed to build image")
49         try:
50             salt.utils.files.rm_rf(image_build_rootdir)
51         except OSError as exc:
52             if exc.errno != errno.ENOENT:
53                 raise
54     @functools.wraps(func)
55     def wrapper(self, *args, **kwargs):
56         try:
57             self.run_function("docker.inspect_image", [IMAGE_NAME])
58         except CommandExecutionError:
59             pass
60         else:
61             build_image()
62         name = random_name(prefix="salt_test_")
63         self.run_function(
64             "docker.create",
65             name=name,
66             image=IMAGE_NAME,
67             command="sleep 600",
68             start=True,
69         )
70         try:
71             return func(self, name, *args, **kwargs)
72         finally:
73             try:
74                 self.run_function("docker.rm", [name], force=True)
75             except CommandExecutionError as exc:
76                 if "No such container" not in exc.__str__():
77                     raise
78     return wrapper
79 @pytest.mark.destructive_test
80 @pytest.mark.slow_test
81 @skipIf(salt.utils.platform.is_freebsd(), "No Docker on FreeBSD available")
82 @skipIf(not salt.utils.path.which("dockerd"), "Docker not installed")
83 class DockerNetworkTestCase(ModuleCase, SaltReturnAssertsMixin):
84     @classmethod
85     def tearDownClass(cls):
86         cmd = ["docker", "rmi", "--force", IMAGE_NAME]
87         log.debug("Running '%s' to destroy busybox image", " ".join(cmd))
88         process = subprocess.Popen(
89             cmd, close_fds=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT
90         )
91         output = process.communicate()[0]
92         log.debug("Output from %s:\n%s", " ".join(cmd), output)
93         if process.returncode != 0 and "No such image" not in str(output):
94             raise Exception("Failed to destroy image")
95     def run_state(self, function, **kwargs):
96         ret = super().run_state(function, **kwargs)
97         log.debug("ret = %s", ret)
98         return ret
99     @with_network(create=False)
100     @pytest.mark.slow_test
101     def test_absent(self, net):
102         self.assertSaltTrueReturn(
103             self.run_state("docker_network.present", name=net.name)
104         )
105         ret = self.run_state("docker_network.absent", name=net.name)
106         self.assertSaltTrueReturn(ret)
107         ret = ret[next(iter(ret))]
108         self.assertEqual(ret["changes"], {"removed": True})
109         self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))
110     @container_name
111     @with_network(create=False)
112     @pytest.mark.slow_test
113     @pytest.mark.skipif(
114         salt.utils.platform.is_photonos() is True,
115         reason="Skip on PhotonOS.  No busybox available.",
116     )
117     def test_absent_with_disconnected_container(self, net, container_name):
118         self.assertSaltTrueReturn(
119             self.run_state(
120                 "docker_network.present", name=net.name, containers=[container_name]
121             )
122         )
123         ret = self.run_state("docker_network.absent", name=net.name)
124         self.assertSaltTrueReturn(ret)
125         ret = ret[next(iter(ret))]
126         self.assertEqual(
127             ret["changes"], {"removed": True, "disconnected": [container_name]}
128         )
129         self.assertEqual(ret["comment"], "Removed network '{}'".format(net.name))
130     @with_network(create=False)
131     @pytest.mark.slow_test
132     def test_absent_when_not_present(self, net):
133         ret = self.run_state("docker_network.absent", name=net.name)
134         self.assertSaltTrueReturn(ret)
135         ret = ret[next(iter(ret))]
136         self.assertEqual(ret["changes"], {})
137         self.assertEqual(ret["comment"], "Network '{}' already absent".format(net.name))
138     @with_network(create=False)
139     @pytest.mark.slow_test
140     def test_present(self, net):
141         ret = self.run_state("docker_network.present", name=net.name)
142         self.assertSaltTrueReturn(ret)
143         ret = ret[next(iter(ret))]
144         self.assertEqual(ret["changes"], {"created": True})
145         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
146         self.run_function("docker.inspect_network", [net.name])
147     @container_name
148     @with_network(create=False)
149     @pytest.mark.slow_test
150     @pytest.mark.skipif(
151         salt.utils.platform.is_photonos() is True,
152         reason="Skip on PhotonOS.  No busybox available.",
153     )
154     def test_present_with_containers(self, net, container_name):
155         ret = self.run_state(
156             "docker_network.present", name=net.name, containers=[container_name]
157         )
158         self.assertSaltTrueReturn(ret)
159         ret = ret[next(iter(ret))]
160         self.assertEqual(
161             ret["changes"], {"created": True, "connected": [container_name]}
162         )
163         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
164         self.run_function("docker.inspect_network", [net.name])
165     def _test_present_reconnect(self, net, container_name, reconnect=True):
166         ret = self.run_state("docker_network.present", name=net.name, driver="bridge")
167         self.assertSaltTrueReturn(ret)
168         ret = ret[next(iter(ret))]
169         self.assertEqual(ret["changes"], {"created": True})
170         self.assertEqual(ret["comment"], "Network '{}' created".format(net.name))
171         self.run_function(
172             "docker.connect_container_to_network", [container_name, net.name]
173         )
174         ret = self.run_state(
175             "docker_network.present",
176             name=net.name,
177             driver="macvlan",
178             reconnect=reconnect,
179         )
180         self.assertSaltTrueReturn(ret)
181         ret = ret[next(iter(ret))]
182         self.assertEqual(
183             ret["changes"],
184             {
185                 "recreated": True,
186                 "reconnected" if reconnect else "disconnected": [container_name],
187                 net.name: {"Driver": {"old": "bridge", "new": "macvlan"}},
188             },
189         )
190         self.assertEqual(
191             ret["comment"],
192             "Network '{}' was replaced with updated config".format(net.name),
193         )
194     @container_name
195     @with_network(create=False)
196     @pytest.mark.slow_test
197     @pytest.mark.skipif(
198         salt.utils.platform.is_photonos() is True,
199         reason="Skip on PhotonOS.  No busybox available.",
200     )
201     def test_present_with_reconnect(self, net, container_name):
202         self._test_present_reconnect(net, container_name, reconnect=True)
203     @container_name
204     @with_network(create=False)
205     @pytest.mark.slow_test
206     @pytest.mark.skipif(
207         salt.utils.platform.is_photonos() is True,
208         reason="Skip on PhotonOS.  No busybox available.",
209     )
210     def test_present_with_no_reconnect(self, net, container_name):
211         self._test_present_reconnect(net, container_name, reconnect=False)
212     @with_network()
213     @pytest.mark.slow_test
214     def test_present_internal(self, net):
215         self.assertSaltTrueReturn(
216             self.run_state(
217                 "docker_network.present",
218                 name=net.name,
219                 internal=True,
220             )
221         )
222         net_info = self.run_function("docker.inspect_network", [net.name])
223         self.assertIs(net_info["Internal"], True)
224     @with_network()
225     @pytest.mark.slow_test
226     def test_present_labels(self, net):
227         self.assertSaltTrueReturn(
228             self.run_state(
229                 "docker_network.present",
230                 name=net.name,
231                 labels=["foo", "bar=baz", {"hello": "world"}],
232             )
233         )
234         net_info = self.run_function("docker.inspect_network", [net.name])
235         self.assertEqual(
236             net_info["Labels"],
237             {"foo": "", "bar": "baz", "hello": "world"},
238         )
239     @with_network(subnet="fe3f:2180:26:1::/123")
240     @with_network(subnet="10.247.197.96/27")
241     @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
242     @pytest.mark.slow_test
243     def test_present_enable_ipv6(self, net1, net2):
244         self.assertSaltTrueReturn(
245             self.run_state(
246                 "docker_network.present",
247                 name=net1.name,
248                 enable_ipv6=True,
249                 ipam_pools=[{"subnet": net1.subnet}, {"subnet": net2.subnet}],
250             )
251         )
252         net_info = self.run_function("docker.inspect_network", [net1.name])
253         self.assertIs(net_info["EnableIPv6"], True)
254     @requires_system_grains
255     @with_network()
256     @pytest.mark.slow_test
257     def test_present_attachable(self, net, grains):
258         if grains["os_family"] == "RedHat" and grains.get("osmajorrelease", 0) &lt;= 7:
259             self.skipTest("Cannot reliably manage attachable on RHEL &lt;= 7")
260         self.assertSaltTrueReturn(
261             self.run_state(
262                 "docker_network.present",
263                 name=net.name,
264                 attachable=True,
265             )
266         )
267         net_info = self.run_function("docker.inspect_network", [net.name])
268         self.assertIs(net_info["Attachable"], True)
269     @skipIf(True, "Skip until we can set up docker swarm testing")
270     @with_network()
271     def test_present_scope(self, net):
272         self.assertSaltTrueReturn(
273             self.run_state(
274                 "docker_network.present",
275                 name=net.name,
276                 scope="global",
277             )
278         )
279         net_info = self.run_function("docker.inspect_network", [net.name])
280         self.assertIs(net_info["Scope"], "global")
281     @skipIf(True, "Skip until we can set up docker swarm testing")
282     @with_network()
283     def test_present_ingress(self, net):
284         self.assertSaltTrueReturn(
285             self.run_state(
286                 "docker_network.present",
287                 name=net.name,
288                 ingress=True,
289             )
290         )
291         net_info = self.run_function("docker.inspect_network", [net.name])
292         self.assertIs(net_info["Ingress"], True)
293     @with_network(subnet="10.247.197.128/27")
294     @with_network(subnet="10.247.197.96/27")
295     @pytest.mark.slow_test
296     def test_present_with_custom_ipv4(self, net1, net2):
297         self.assertSaltTrueReturn(
298             self.run_state(
299                 "docker_network.present",
300                 name=net1.name,
301                 subnet=net1.subnet,
302                 gateway=net1.gateway,
303             )
304         )
305         ret = self.run_state(
306             "docker_network.present",
307             name=net1.name,  # We want to keep the same network name
308             ipam_pools=[{"subnet": net2.subnet, "gateway": net2.gateway}],
309         )
310         self.assertSaltTrueReturn(ret)
311         ret = ret[next(iter(ret))]
312         expected = {
313             "recreated": True,
314             net1.name: {
315                 "IPAM": {
316                     "Config": {
317                         "old": [{"Subnet": net1.subnet, "Gateway": net1.gateway}],
318                         "new": [{"Subnet": net2.subnet, "Gateway": net2.gateway}],
319                     }
320                 }
321             },
322         }
323         self.assertEqual(ret["changes"], expected)
324         self.assertEqual(
325             ret["comment"],
326             "Network '{}' was replaced with updated config".format(net1.name),
327         )
328     @with_network(subnet="fe3f:2180:26:1::20/123")
329     @with_network(subnet="fe3f:2180:26:1::/123")
330     @with_network(subnet="10.247.197.96/27")
331     @skipIf(not IPV6_ENABLED, "IPv6 not enabled")
332     @pytest.mark.slow_test
333     def test_present_with_custom_ipv6(self, ipv4_net, ipv6_net1, ipv6_net2):
334         self.assertSaltTrueReturn(
335             self.run_state(
336                 "docker_network.present",
337                 name=ipv4_net.name,
338                 enable_ipv6=True,
339                 ipam_pools=[
340                     {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
341                     {"subnet": ipv6_net1.subnet, "gateway": ipv6_net1.gateway},
342                 ],
343             )
344         )
345         ret = self.run_state(
346             "docker_network.present",
347             name=ipv4_net.name,  # We want to keep the same network name
348             enable_ipv6=True,
349             ipam_pools=[
350                 {"subnet": ipv4_net.subnet, "gateway": ipv4_net.gateway},
351                 {"subnet": ipv6_net2.subnet, "gateway": ipv6_net2.gateway},
352             ],
353         )
354         self.assertSaltTrueReturn(ret)
355         ret = ret[next(iter(ret))]
356         expected = {
357             "recreated": True,
358             ipv4_net.name: {
359                 "IPAM": {
360                     "Config": {
361                         "old": [
362                             {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
363                             {"Subnet": ipv6_net1.subnet, "Gateway": ipv6_net1.gateway},
364                         ],
365                         "new": [
366                             {"Subnet": ipv4_net.subnet, "Gateway": ipv4_net.gateway},
367                             {"Subnet": ipv6_net2.subnet, "Gateway": ipv6_net2.gateway},
368                         ],
369                     }
370                 }
371             },
372         }
373         self.assertEqual(ret["changes"], expected)
374         self.assertEqual(
375             ret["comment"],
376             "Network '{}' was replaced with updated config".format(ipv4_net.name),
377         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
