
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, &quot;images&quot;, &quot;efuse&quot;)
10  S_IMAGES_DIR = os.path.join(TEST_DIR, &quot;secure_images&quot;)
11  EFUSE_S_DIR = os.path.join(TEST_DIR, &quot;efuse_scripts&quot;)
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f&quot;{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}&quot;)
24  print(f&quot;\nHost tests of espefuse.py for {arg_chip}:&quot;)
25  print(&quot;Running espefuse.py tests...&quot;)
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
33                  f&quot;--virt --path-efuse-file {self.efuse_file.name} -d&quot;
34              )
35          else:
36              self.base_cmd = (
37                  f&quot;{sys.executable} -m espefuse --chip {arg_chip} &quot;
38                  f&quot;--port {arg_port} -d&quot;
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py(&quot;burn_efuse CODING_SCHEME 1&quot;)
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, &quot;rb&quot;) as f:
72              data = BitStream(&quot;0x00&quot;) * offset + BitStream(f)
73              blk = data.readlist(f&quot;{data.len // 8}*uint:8&quot;)
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = &quot; &quot;.join(f&quot;{num:02x}&quot; for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = &quot; &quot;.join((f&quot;{sys.executable} -m espefuse&quot;, cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = &quot; &quot;.join(
82              [self.base_cmd, &quot;--do-not-confirm&quot; if do_not_confirm else &quot;&quot;, cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              &quot; &quot;.join([self.base_cmd, &quot;check_error&quot;]), &quot;No errors detected&quot;, 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py(&quot;--help&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;)
114          self.espefuse_not_virt_py(f&quot;--chip {arg_chip} --help&quot;)
115      def test_help2(self):
116          self.espefuse_not_virt_py(&quot;&quot;, check_msg=&quot;usage: __main__.py [-h]&quot;, ret_code=1)
117      def test_dump(self):
118          self.espefuse_py(&quot;dump -h&quot;)
119          self.espefuse_py(&quot;dump&quot;)
120      def test_summary(self):
121          self.espefuse_py(&quot;summary -h&quot;)
122          self.espefuse_py(&quot;summary&quot;)
123      def test_summary_json(self):
124          self.espefuse_py(&quot;summary --format json&quot;)
125      def test_get_custom_mac(self):
126          self.espefuse_py(&quot;get_custom_mac -h&quot;)
127          if arg_chip == &quot;esp32&quot;:
128              right_msg = &quot;Custom MAC Address is not set in the device.&quot;
129          else:
130              right_msg = &quot;Custom MAC Address: 00:00:00:00:00:00 (OK)&quot;
131          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=right_msg)
132      def test_adc_info(self):
133          self.espefuse_py(&quot;adc_info -h&quot;)
134          self.espefuse_py(&quot;adc_info&quot;)
135      def test_check_error(self):
136          self.espefuse_py(&quot;check_error -h&quot;)
137          self.espefuse_py(&quot;check_error&quot;)
138          self.espefuse_py(&quot;check_error --recovery&quot;)
139  class TestReadProtectionCommands(EfuseTestCase):
140      def test_read_protect_efuse(self):
141          self.espefuse_py(&quot;read_protect_efuse -h&quot;)
142          if arg_chip == &quot;esp32&quot;:
143              cmd = &quot;read_protect_efuse \
144                     CODING_SCHEME \
145                     MAC_VERSION \
146                     BLOCK1 \
147                     BLOCK2 \
148                     BLOCK3&quot;
149              count_protects = 5
150          elif arg_chip == &quot;esp32c2&quot;:
151              cmd = &quot;read_protect_efuse \
152                     BLOCK_KEY0_LOW_128&quot;
153              count_protects = 1
154          else:
155              self.espefuse_py(
156                  &quot;burn_efuse \
157                  KEY_PURPOSE_0 HMAC_UP \
158                  KEY_PURPOSE_1 XTS_AES_128_KEY \
159                  KEY_PURPOSE_2 XTS_AES_128_KEY \
160                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
161                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
162                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE&quot;
163              )
164              cmd = &quot;read_protect_efuse \
165                     BLOCK_KEY0 \
166                     BLOCK_KEY1 \
167                     BLOCK_KEY2 \
168                     BLOCK_KEY3 \
169                     BLOCK_KEY4 \
170                     BLOCK_KEY5&quot;
171              count_protects = 6
172          self.espefuse_py(cmd)
173          output = self.espefuse_py(cmd)
174          assert count_protects == output.count(&quot;is already read protected&quot;)
175      def test_read_protect_efuse2(self):
176          self.espefuse_py(&quot;write_protect_efuse RD_DIS&quot;)
177          if arg_chip == &quot;esp32&quot;:
178              efuse_name = &quot;CODING_SCHEME&quot;
179          elif arg_chip == &quot;esp32c2&quot;:
180              efuse_name = &quot;BLOCK_KEY0_HI_128&quot;
181          else:
182              efuse_name = &quot;BLOCK_SYS_DATA2&quot;
183          self.espefuse_py(
184              f&quot;read_protect_efuse {efuse_name}&quot;,
185              check_msg=&quot;A fatal error occurred: This efuse cannot be read-disabled &quot;
186              &quot;due the to RD_DIS field is already write-disabled&quot;,
187              ret_code=2,
188          )
189      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;when the purpose of BLOCK2 is set&quot;)
190      def test_read_protect_efuse3(self):
191          self.espefuse_py(&quot;burn_efuse ABS_DONE_1 1&quot;)
192          self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
193          self.espefuse_py(
194              &quot;read_protect_efuse BLOCK2&quot;,
195              check_msg=&quot;Secure Boot V2 is on (ABS_DONE_1 = True), &quot;
196              &quot;BLOCK2 must be readable, stop this operation!&quot;,
197              ret_code=2,
198          )
199      def test_read_protect_efuse4(self):
200          if arg_chip == &quot;esp32&quot;:
201              self.espefuse_py(f&quot;burn_key BLOCK2 {IMAGES_DIR}/256bit&quot;)
202              msg = &quot;must be readable, please stop this operation!&quot;
203              self.espefuse_py(&quot;read_protect_efuse BLOCK2&quot;, check_msg=msg)
204          elif arg_chip == &quot;esp32c2&quot;:
205              self.espefuse_py(
206                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
207              )
208              self.espefuse_py(
209                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
210                  check_msg=&quot;A fatal error occurred: &quot;
211                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
212                  ret_code=2,
213              )
214          else:
215              self.espefuse_py(
216                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
217                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
218                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
219                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
220                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
221                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP&quot;
222              )
223              self.espefuse_py(
224                  &quot;read_protect_efuse BLOCK_KEY0&quot;,
225                  check_msg=&quot;A fatal error occurred: &quot;
226                  &quot;BLOCK_KEY0 must be readable, stop this operation!&quot;,
227                  ret_code=2,
228              )
229              self.espefuse_py(
230                  &quot;read_protect_efuse BLOCK_KEY1&quot;,
231                  check_msg=&quot;A fatal error occurred: &quot;
232                  &quot;BLOCK_KEY1 must be readable, stop this operation!&quot;,
233                  ret_code=2,
234              )
235              self.espefuse_py(
236                  &quot;read_protect_efuse BLOCK_KEY2&quot;,
237                  check_msg=&quot;A fatal error occurred: &quot;
238                  &quot;BLOCK_KEY2 must be readable, stop this operation!&quot;,
239                  ret_code=2,
240              )
241              self.espefuse_py(
242                  &quot;read_protect_efuse BLOCK_KEY3&quot;,
243                  check_msg=&quot;A fatal error occurred: &quot;
244                  &quot;BLOCK_KEY3 must be readable, stop this operation!&quot;,
245                  ret_code=2,
246              )
247              self.espefuse_py(
248                  &quot;read_protect_efuse BLOCK_KEY4&quot;,
249                  check_msg=&quot;A fatal error occurred: &quot;
250                  &quot;BLOCK_KEY4 must be readable, stop this operation!&quot;,
251                  ret_code=2,
252              )
253              self.espefuse_py(&quot;read_protect_efuse BLOCK_KEY5&quot;)
254      @pytest.mark.skipif(
255          arg_chip != &quot;esp32&quot;,
256          reason=&quot;system parameters efuse read-protection is supported only by esp32, &quot;
257          &quot;other chips protect whole blocks&quot;,
258      )
259      def test_burn_and_read_protect_efuse(self):
260          self.espefuse_py(
261              &quot;burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8&quot;,
262              check_msg=&quot;Efuse FLASH_CRYPT_CONFIG is read-protected. &quot;
263              &quot;Read back the burn value is not possible.&quot;,
264          )
265  class TestWriteProtectionCommands(EfuseTestCase):
266      def test_write_protect_efuse(self):
267          self.espefuse_py(&quot;write_protect_efuse -h&quot;)
268          if arg_chip == &quot;esp32&quot;:
269              efuse_lists = 
270              efuse_lists2 = &quot;WR_DIS RD_DIS&quot;
271          elif arg_chip == &quot;esp32c2&quot;:
272              efuse_lists = 
273              efuse_lists2 = &quot;RD_DIS DIS_DOWNLOAD_ICACHE&quot;
274          else:
275              efuse_lists = 
276              if arg_chip not in [&quot;esp32h2&quot;, &quot;esp32h2beta1&quot;] and arg_chip not in [
277                  &quot;esp32c6&quot;
278              ]:
279                  efuse_lists += 
280              efuse_lists2 = &quot;RD_DIS DIS_ICACHE&quot;
281          self.espefuse_py(f&quot;write_protect_efuse {efuse_lists}&quot;)
282          output = self.espefuse_py(f&quot;write_protect_efuse {efuse_lists2}&quot;)
283          assert output.count(&quot;is already write protected&quot;) == 2
284      def test_write_protect_efuse2(self):
285          if arg_chip == &quot;esp32&quot;:
286              self.espefuse_py(&quot;write_protect_efuse WR_DIS&quot;)
287              self.espefuse_py(
288                  &quot;write_protect_efuse CODING_SCHEME&quot;,
289                  check_msg=&quot;A fatal error occurred: This efuse cannot be write-disabled &quot;
290                  &quot;due to the WR_DIS field is already write-disabled&quot;,
291                  ret_code=2,
292              )
293  class TestBurnCustomMacCommands(EfuseTestCase):
294      def test_burn_custom_mac(self):
295          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
296          cmd = &quot;burn_custom_mac AA:CD:EF:11:22:33&quot;
297          mac = &quot;aa:cd:ef:11:22:33&quot;
298          if arg_chip == &quot;esp32&quot;:
299              self.espefuse_py(
300                  cmd, check_msg=f&quot;Custom MAC Address version 1: {mac} (CRC 0x63 OK)&quot;
301              )
302          else:
303              self.espefuse_py(cmd, check_msg=f&quot;Custom MAC Address: {mac} (OK)&quot;)
304      def test_burn_custom_mac2(self):
305          self.espefuse_py(
306              &quot;burn_custom_mac AA:CD:EF:11:22:33:44&quot;,
307              check_msg=&quot;A fatal error occurred: MAC Address needs to be a 6-byte &quot;
308              &quot;hexadecimal format separated by colons (:)!&quot;,
309              ret_code=2,
310          )
311      def test_burn_custom_mac3(self):
312          self.espefuse_py(
313              &quot;burn_custom_mac AB:CD:EF:11:22:33&quot;,
314              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
315              ret_code=2,
316          )
317      @pytest.mark.skipif(
318          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
319      )
320      def test_burn_custom_mac_with_34_coding_scheme(self):
321          self._set_34_coding_scheme()
322          self.espefuse_py(&quot;burn_custom_mac -h&quot;)
323          self.espefuse_py(
324              &quot;burn_custom_mac AA:CD:EF:01:02:03&quot;,
325              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
326          )
327          self.espefuse_py(
328              &quot;get_custom_mac&quot;,
329              check_msg=&quot;Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)&quot;,
330          )
331          self.espefuse_py(
332              &quot;burn_custom_mac FE:22:33:44:55:66&quot;,
333              check_msg=&quot;New value contains some bits that cannot be cleared &quot;
334              &quot;(value will be 0x675745ffeffe)&quot;,
335              ret_code=2,
336          )
337  @pytest.mark.skipif(
338      arg_chip in [&quot;esp32c2&quot;, &quot;esp32h2beta1&quot;, &quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;],
339      reason=f&quot;TODO: add support set_flash_voltage for {arg_chip}&quot;,
340  )
341  class TestSetFlashVoltageCommands(EfuseTestCase):
342      def test_set_flash_voltage_1_8v(self):
343          self.espefuse_py(&quot;set_flash_voltage -h&quot;)
344          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
345          self.espefuse_py(
346              &quot;set_flash_voltage 1.8V&quot;,
347              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
348          )
349          if arg_chip == &quot;esp32&quot;:
350              error_msg = &quot;A fatal error occurred: &quot;
351              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
352          else:
353              error_msg = &quot;A fatal error occurred: &quot;
354              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
355          self.espefuse_py(
356              &quot;set_flash_voltage 3.3V&quot;,
357              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
358          )
359          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
360      def test_set_flash_voltage_3_3v(self):
361          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
362          self.espefuse_py(
363              &quot;set_flash_voltage 3.3V&quot;,
364              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
365          )
366          if arg_chip == &quot;esp32&quot;:
367              error_msg = &quot;A fatal error occurred: &quot;
368              &quot;Can&#x27;t set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned&quot;
369          else:
370              error_msg = &quot;A fatal error occurred: &quot;
371              &quot;Can&#x27;t set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned&quot;
372          self.espefuse_py(&quot;set_flash_voltage 1.8V&quot;, check_msg=error_msg, ret_code=2)
373          if arg_chip == &quot;esp32&quot;:
374              error_msg = &quot;A fatal error occurred: &quot;
375              &quot;Can&#x27;t set flash regulator to OFF as XPD_SDIO_REG efuse is already burned&quot;
376          else:
377              error_msg = &quot;A fatal error occurred: &quot;
378              &quot;Can&#x27;t set flash regulator to OFF as VDD_SPI_XPD efuse is already burned&quot;
379          self.espefuse_py(&quot;set_flash_voltage OFF&quot;, check_msg=error_msg, ret_code=2)
380      def test_set_flash_voltage_off(self):
381          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
382          self.espefuse_py(
383              &quot;set_flash_voltage OFF&quot;,
384              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
385          )
386          self.espefuse_py(
387              &quot;set_flash_voltage 3.3V&quot;,
388              check_msg=f&quot;Enable internal flash voltage regulator ({vdd}) to 3.3V.&quot;,
389          )
390      def test_set_flash_voltage_off2(self):
391          vdd = &quot;VDD_SDIO&quot; if arg_chip == &quot;esp32&quot; else &quot;VDD_SPI&quot;
392          self.espefuse_py(
393              &quot;set_flash_voltage OFF&quot;,
394              check_msg=f&quot;Disable internal flash voltage regulator ({vdd})&quot;,
395          )
396          self.espefuse_py(
397              &quot;set_flash_voltage 1.8V&quot;,
398              check_msg=f&quot;Set internal flash voltage regulator ({vdd}) to 1.8V.&quot;,
399          )
400  @pytest.mark.skipif(arg_chip != &quot;esp32c3&quot;, reason=&quot;Not necessary fo all chips&quot;)
401  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
402      def test_efuse_is_bool_given_none(self):
403          self.espefuse_py(&quot;burn_efuse SECURE_BOOT_KEY_REVOKE0&quot;)
404      def test_efuse_is_bool_given_0(self):
405          self.espefuse_py(
406              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 0&quot;,
407              check_msg=&quot;A fatal error occurred: &quot;
408              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
409              &quot;(will always burn 0-&gt;1), given value=0&quot;,
410              ret_code=2,
411          )
412      def test_efuse_is_bool_given_2(self):
413          self.espefuse_py(
414              &quot;burn_efuse SECURE_BOOT_KEY_REVOKE0 2&quot;,
415              check_msg=&quot;A fatal error occurred: &quot;
416              &quot;New value is not accepted for efuse &#x27;SECURE_BOOT_KEY_REVOKE0&#x27; &quot;
417              &quot;(will always burn 0-&gt;1), given value=2&quot;,
418              ret_code=2,
419          )
420      def test_efuse_is_bytes_ok(self):
421          self.espefuse_py(
422              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678&quot;
423          )
424      def test_efuse_is_bytes_given_short_val(self):
425          self.espefuse_py(
426              &quot;burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678&quot;,
427              check_msg=&quot;A fatal error occurred: &quot;
428              &quot;The length of efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (128 bits) &quot;
429              &quot;(given len of the new value= 64 bits)&quot;,
430              ret_code=2,
431          )
432      def test_efuse_is_bytes_given_none(self):
433          self.espefuse_py(
434              &quot;burn_efuse OPTIONAL_UNIQUE_ID&quot;,
435              check_msg=&quot;A fatal error occurred: &quot;
436              &quot;New value required for efuse &#x27;OPTIONAL_UNIQUE_ID&#x27; (given None)&quot;,
437              ret_code=2,
438          )
439      def test_efuse_is_int_ok(self):
440          self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_D 7&quot;)
441      def test_efuse_is_int_given_out_of_range_val(self):
442          self.espefuse_py(
443              &quot;burn_efuse SPI_PAD_CONFIG_D 200&quot;,
444              check_msg=&quot;A fatal error occurred: &quot;
445              &quot;200 is too large an unsigned integer for a bitstring &quot;
446              &quot;of length 6. The allowed range is [0, 63].&quot;,
447              ret_code=2,
448          )
449      def test_efuse_is_int_given_none(self):
450          self.espefuse_py(
451              &quot;burn_efuse SPI_PAD_CONFIG_D&quot;,
452              check_msg=&quot;A fatal error occurred: &quot;
453              &quot;New value required for efuse &#x27;SPI_PAD_CONFIG_D&#x27; (given None)&quot;,
454              ret_code=2,
455          )
456      def test_efuse_is_int_given_0(self):
457          self.espefuse_py(
458              &quot;burn_efuse SPI_PAD_CONFIG_D 0&quot;,
459              check_msg=&quot;A fatal error occurred: &quot;
460              &quot;New value should not be 0 for &#x27;SPI_PAD_CONFIG_D&#x27; &quot;
461              &quot;(given value= 0)&quot;,
462              ret_code=2,
463          )
464      def test_efuse_is_bitcount_given_out_of_range_val(self):
465          self.espefuse_py(
466              &quot;burn_efuse SPI_BOOT_CRYPT_CNT 9&quot;,
467              check_msg=&quot;A fatal error occurred: &quot;
468              &quot;9 is too large an unsigned integer for a bitstring &quot;
469              &quot;of length 3. The allowed range is [0, 7].&quot;,
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_increase_over_max(self):
473          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
474          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
475          self.espefuse_py(&quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;)
476          self.espefuse_py(
477              &quot;burn_efuse SPI_BOOT_CRYPT_CNT&quot;,
478              check_msg=&quot;A fatal error occurred: &quot;
479              &quot;15 is too large an unsigned integer for a bitstring &quot;
480              &quot;of length 3. The allowed range is [0, 7].&quot;,
481              ret_code=2,
482          )
483  class TestBurnEfuseCommands(EfuseTestCase):
484      @pytest.mark.skipif(
485          arg_chip != &quot;esp32&quot;,
486          reason=&quot;IO pins 30 &amp; 31 cannot be set for SPI flash only on esp32&quot;,
487      )
488      def test_set_spi_flash_pin_efuses(self):
489          self.espefuse_py(
490              &quot;burn_efuse SPI_PAD_CONFIG_HD 30&quot;,
491              check_msg=&quot;A fatal error occurred: &quot;
492              &quot;IO pins 30 &amp; 31 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
493              ret_code=2,
494          )
495          self.espefuse_py(
496              &quot;burn_efuse SPI_PAD_CONFIG_Q 0x23&quot;,
497              check_msg=&quot;A fatal error occurred: &quot;
498              &quot;IO pin 35 cannot be set for SPI flash. 0-29, 32 &amp; 33 only.&quot;,
499              ret_code=2,
500          )
501          output = self.espefuse_py(&quot;burn_efuse SPI_PAD_CONFIG_CS0 33&quot;)
502          assert &quot;(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -&gt; 0b11111&quot; in output
503          assert &quot;BURN BLOCK0  - OK (all write block bits are set)&quot; in output
504      def test_burn_mac_custom_efuse(self):
505          crc_msg = &quot;(OK)&quot;
506          self.espefuse_py(&quot;burn_efuse -h&quot;)
507          if arg_chip == &quot;esp32&quot;:
508              self.espefuse_py(
509                  &quot;burn_efuse MAC AA:CD:EF:01:02:03&quot;,
510                  check_msg=&quot;Writing Factory MAC address is not supported&quot;,
511                  ret_code=2,
512              )
513              self.espefuse_py(&quot;burn_efuse MAC_VERSION 1&quot;)
514              crc_msg = &quot;(CRC 0x56 OK)&quot;
515          if arg_chip == &quot;esp32c2&quot;:
516              self.espefuse_py(&quot;burn_efuse CUSTOM_MAC_USED 1&quot;)
517          self.espefuse_py(&quot;burn_efuse -h&quot;)
518          self.espefuse_py(
519              &quot;burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03&quot;,
520              check_msg=&quot;A fatal error occurred: Custom MAC must be a unicast MAC!&quot;,
521              ret_code=2,
522          )
523          self.espefuse_py(&quot;burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03&quot;)
524          self.espefuse_py(&quot;get_custom_mac&quot;, check_msg=f&quot;aa:cd:ef:01:02:03 {crc_msg}&quot;)
525      def test_burn_efuse(self):
526          self.espefuse_py(&quot;burn_efuse -h&quot;)
527          if arg_chip == &quot;esp32&quot;:
528              self.espefuse_py(
529                  &quot;burn_efuse \
530                  CHIP_VER_REV2 1 \
531                  DISABLE_DL_ENCRYPT 1 \
532                  CONSOLE_DEBUG_DISABLE 1&quot;
533              )
534              blk1 = &quot;BLOCK1&quot;
535              blk2 = &quot;BLOCK2&quot;
536          elif arg_chip == &quot;esp32c2&quot;:
537              self.espefuse_py(
538                  &quot;burn_efuse \
539                  XTS_KEY_LENGTH_256 1 \
540                  UART_PRINT_CONTROL 1 \
541                  FORCE_SEND_RESUME 1&quot;
542              )
543              blk1 = &quot;BLOCK_KEY0&quot;
544              blk2 = None
545          else:
546              self.espefuse_py(
547                  &quot;burn_efuse \
548                  SECURE_BOOT_EN 1 \
549                  UART_PRINT_CONTROL 1&quot;
550              )
551              self.espefuse_py(
552                  &quot;burn_efuse \
553                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168&quot;,
554                  check_msg=&quot;-&gt; 0x2328ad5ac9145f698f843a26d6eae168&quot;,
555              )
556              output = self.espefuse_py(&quot;summary -d&quot;)
557              assert (
558                  &quot;read_regs: d6eae168 8f843a26 c9145f69 2328ad5a &quot;
559                  &quot;00000000 00000000 00000000 00000000&quot;
560              ) in output
561              assert &quot;= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W&quot; in output
562              efuse_from_blk2 = &quot;BLK_VERSION_MAJOR&quot;
563              if arg_chip == &quot;esp32s2&quot;:
564                  efuse_from_blk2 = &quot;BLK_VERSION_MINOR&quot;
565              if arg_chip != &quot;esp32c6&quot;:
566                  self.espefuse_py(
567                      f&quot;burn_efuse {efuse_from_blk2} 1&quot;,
568                      check_msg=&quot;Burn into BLOCK_SYS_DATA is forbidden &quot;
569                      &quot;(RS coding scheme does not allow this).&quot;,
570                      ret_code=2,
571                  )
572              blk1 = &quot;BLOCK_KEY1&quot;
573              blk2 = &quot;BLOCK_KEY2&quot;
574          output = self.espefuse_py(
575              f&quot;burn_efuse {blk1}&quot;
576              + &quot; 0x00010203040506070809111111111111111111111111111111110000112233FF&quot;
577          )
578          assert (
579              &quot;-&gt; 0x00010203040506070809111111111111111111111111111111110000112233ff&quot;
580              in output
581          )
582          output = self.espefuse_py(&quot;summary -d&quot;)
583          assert (
584              &quot;read_regs: 112233ff 11110000 11111111 11111111 &quot;
585              &quot;11111111 08091111 04050607 00010203&quot;
586          ) in output
587          assert (
588              &quot;= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 &quot;
589              &quot;11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W&quot;
590          ) in output
591          if blk2 is not None:
592              output = self.espefuse_py(
593                  f&quot;burn_efuse {blk2}&quot;
594                  + &quot; 00010203040506070809111111111111111111111111111111110000112233FF&quot;
595              )
596              assert (
597                  &quot;-&gt; 0xff33221100001111111111111111111111111111111109080706050403020100&quot;
598                  in output
599              )
600              output = self.espefuse_py(&quot;summary -d&quot;)
601              assert (
602                  &quot;read_regs: 03020100 07060504 11110908 11111111 &quot;
603                  &quot;11111111 11111111 00001111 ff332211&quot;
604              ) in output
605              assert (
606                  &quot;= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 &quot;
607                  &quot;11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W&quot;
608              ) in output
609      @pytest.mark.skipif(
610          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
611      )
612      def test_burn_efuse_with_34_coding_scheme(self):
613          self._set_34_coding_scheme()
614          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
615          self.espefuse_py(&quot;burn_efuse ADC1_TP_LOW 50&quot;)
616          self.espefuse_py(
617              &quot;burn_efuse ADC1_TP_HIGH 55&quot;,
618              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
619              &quot;(3/4 coding scheme does not allow this)&quot;,
620              ret_code=2,
621          )
622      @pytest.mark.skipif(
623          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
624      )
625      def test_burn_efuse_with_34_coding_scheme2(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py(&quot;burn_efuse BLK3_PART_RESERVE 1&quot;)
628          self.espefuse_py(
629              &quot;burn_efuse \
630              ADC1_TP_LOW 50 \
631              ADC1_TP_HIGH 55 \
632              ADC2_TP_LOW 40 \
633              ADC2_TP_HIGH 45&quot;
634          )
635  class TestBurnKeyCommands(EfuseTestCase):
636      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
637      def test_burn_key_3_key_blocks(self):
638          self.espefuse_py(&quot;burn_key -h&quot;)
639          self.espefuse_py(
640              f&quot;burn_key BLOCK1 {IMAGES_DIR}/192bit&quot;,
641              check_msg=&quot;A fatal error occurred: Incorrect key file size 24. &quot;
642              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
643              ret_code=2,
644          )
645          self.espefuse_py(
646              f&quot;burn_key \
647              BLOCK1 {IMAGES_DIR}/256bit \
648              BLOCK2 {IMAGES_DIR}/256bit_1 \
649              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key&quot;
650          )
651          output = self.espefuse_py(&quot;summary -d&quot;)
652          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
653          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
654          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
655          self.espefuse_py(
656              f&quot;burn_key \
657              BLOCK1 {IMAGES_DIR}/256bit \
658              BLOCK2 {IMAGES_DIR}/256bit_1 \
659              BLOCK3 {IMAGES_DIR}/256bit_2&quot;
660          )
661          output = self.espefuse_py(&quot;summary -d&quot;)
662          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
663          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
664          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
665      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
666      def test_burn_key_1_key_block(self):
667          self.espefuse_py(&quot;burn_key -h&quot;)
668          self.espefuse_py(
669              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY&quot;,
670              check_msg=&quot;A fatal error occurred: Incorrect key file size 16. &quot;
671              &quot;Key file must be 32 bytes (256 bits) of raw binary key data.&quot;,
672              ret_code=2,
673          )
674          self.espefuse_py(
675              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect&quot;
676          )
677          output = self.espefuse_py(&quot;summary -d&quot;)
678          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
679          self.espefuse_py(f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;)
680          output = self.espefuse_py(&quot;summary -d&quot;)
681          assert (
682              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
683              &quot;00000000 00000000 00000000 00000000&quot;
684          ) in output
685          assert (
686              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
687              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
688          ) in output
689      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
690      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
691          self.espefuse_py(&quot;burn_key -h&quot;)
692          self.espefuse_py(
693              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
694              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;,
695              check_msg=&quot;A fatal error occurred: These keypurposes are incompatible &quot;
696              &quot;[&#x27;XTS_AES_128_KEY&#x27;, &#x27;SECURE_BOOT_DIGEST&#x27;]&quot;,
697              ret_code=2,
698          )
699          self.espefuse_py(
700              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
701              f&quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
702              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect&quot;
703          )
704          output = self.espefuse_py(&quot;summary -d&quot;)
705          assert (
706              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
707              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
708          ) in output
709          self.espefuse_py(
710              f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
711              &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS &quot;
712              f&quot;BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST&quot;
713          )
714          output = self.espefuse_py(&quot;summary -d&quot;)
715          assert (
716              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
717              &quot;03020100 07060504 0b0a0908 0f0e0d0c&quot;
718          ) in output
719          assert (
720              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
721              &quot;00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-&quot;
722          ) in output
723          assert &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
724          assert &quot;= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-&quot; in output
725      @pytest.mark.skipif(
726          arg_chip
727          not in [
728              &quot;esp32s2&quot;,
729              &quot;esp32s3&quot;,
730              &quot;esp32s3beta1&quot;,
731              &quot;esp32c3&quot;,
732              &quot;esp32h2beta1&quot;,
733              &quot;esp32c6&quot;,
734              &quot;esp32h2&quot;,
735          ],
736          reason=&quot;Only chips with 6 keys&quot;,
737      )
738      def test_burn_key_with_6_keys(self):
739          cmd = f&quot;burn_key \
740                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
741                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
742                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY&quot;
743          if arg_chip in [&quot;esp32c3&quot;, &quot;esp32c6&quot;] or arg_chip in [
744              &quot;esp32h2&quot;,
745              &quot;esp32h2beta1&quot;,
746          ]:
747              cmd = cmd.replace(&quot;XTS_AES_256_KEY_1&quot;, &quot;XTS_AES_128_KEY&quot;)
748              cmd = cmd.replace(&quot;XTS_AES_256_KEY_2&quot;, &quot;XTS_AES_128_KEY&quot;)
749          self.espefuse_py(cmd + &quot; --no-read-protect --no-write-protect&quot;)
750          output = self.espefuse_py(&quot;summary -d&quot;)
751          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True)
752          self.check_data_block_in_log(
753              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
754          )
755          self.check_data_block_in_log(
756              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
757          )
758          self.espefuse_py(cmd)
759          output = self.espefuse_py(&quot;summary -d&quot;)
760          assert (
761              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
762              &quot;00000000 00000000 00000000 00000000&quot;
763          ) in output
764          assert (
765              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
766              &quot;00000000 00000000 00000000 00000000&quot;
767          ) in output
768          assert (
769              &quot;[6 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
770              &quot;00000000 00000000 00000000 00000000&quot;
771          ) in output
772          self.espefuse_py(
773              f&quot;burn_key \
774              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
775              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
776              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2&quot;
777          )
778          output = self.espefuse_py(&quot;summary -d&quot;)
779          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
780          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;)
781          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
782      @pytest.mark.skipif(
783          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
784      )
785      def test_burn_key_with_34_coding_scheme(self):
786          self._set_34_coding_scheme()
787          self.espefuse_py(
788              f&quot;burn_key BLOCK1 {IMAGES_DIR}/256bit&quot;,
789              check_msg=&quot;A fatal error occurred: Incorrect key file size 32. &quot;
790              &quot;Key file must be 24 bytes (192 bits) of raw binary key data.&quot;,
791              ret_code=2,
792          )
793          self.espefuse_py(
794              f&quot;burn_key \
795              BLOCK1 {IMAGES_DIR}/192bit \
796              BLOCK2 {IMAGES_DIR}/192bit_1 \
797              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key&quot;
798          )
799          output = self.espefuse_py(&quot;summary -d&quot;)
800          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
801          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
802          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
803          self.espefuse_py(
804              f&quot;burn_key \
805              BLOCK1 {IMAGES_DIR}/192bit \
806              BLOCK2 {IMAGES_DIR}/192bit_1 \
807              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
808          )
809          output = self.espefuse_py(&quot;summary -d&quot;)
810          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
811          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
812          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
813      @pytest.mark.skipif(
814          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
815          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
816      )
817      def test_burn_key_512bit(self):
818          self.espefuse_py(
819              f&quot;burn_key \
820              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
821              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
822          )
823          output = self.espefuse_py(&quot;summary -d&quot;)
824          self.check_data_block_in_log(
825              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
826          )
827          self.check_data_block_in_log(
828              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
829          )
830      @pytest.mark.skipif(
831          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
832          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
833      )
834      def test_burn_key_512bit_non_consecutive_blocks(self):
835          self.espefuse_py(
836              f&quot;burn_key \
837              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;
838          )
839          self.espefuse_py(
840              f&quot;burn_key \
841              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0&quot;
842          )
843          self.espefuse_py(
844              f&quot;burn_key \
845              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
846              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
847          )
848          self.espefuse_py(
849              f&quot;burn_key \
850              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect&quot;
851          )
852          output = self.espefuse_py(&quot;summary -d&quot;)
853          self.check_data_block_in_log(
854              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
855          )
856          self.check_data_block_in_log(
857              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
858          )
859          assert (
860              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 &quot;
861              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
862          ) in output
863          assert (
864              &quot;[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 &quot;
865              &quot;b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
866          ) in output
867      @pytest.mark.skipif(
868          arg_chip not in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
869          reason=&quot;512 bit keys are only supported on ESP32-S2 and S3&quot;,
870      )
871      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
872          self.espefuse_py(
873              f&quot;burn_key \
874              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
875              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
876              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
877              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
878              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
879              XTS_AES_256_KEY --no-read-protect --no-write-protect&quot;
880          )
881          output = self.espefuse_py(&quot;summary -d&quot;)
882          self.check_data_block_in_log(
883              output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
884          )
885          self.check_data_block_in_log(
886              output, f&quot;{IMAGES_DIR}/256bit_2&quot;, reverse_order=True
887          )
888          assert (
889              &quot;[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
890              &quot;acadaeaf a8a9aaab a4a5a6a7 11a1a2a3&quot;
891          ) in output
892          assert (
893              &quot;[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 &quot;
894              &quot;acadaeaf a8a9aaab a4a5a6a7 22a1a2a3&quot;
895          ) in output
896      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
897      def test_burn_key_ecdsa_key(self):
898          self.espefuse_py(
899              f&quot;burn_key \
900              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
901              ECDSA_KEY \
902              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
903              ECDSA_KEY&quot;
904          )
905          output = self.espefuse_py(&quot;summary -d&quot;)
906          assert 2 == output.count(
907              &quot;= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? &quot;
908              &quot;?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot;
909          )
910          assert (
911              &quot;[4 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
912              &quot;00000000 00000000 00000000 00000000&quot;
913          ) in output
914          assert (
915              &quot;[5 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
916              &quot;00000000 00000000 00000000 00000000&quot;
917          ) in output
918      @pytest.mark.skipif(arg_chip != &quot;esp32h2&quot;, reason=&quot;Only for ESP32-H2 chips&quot;)
919      def test_burn_key_ecdsa_key_check_byte_order(self):
920          self.espefuse_py(
921              f&quot;burn_key \
922              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
923              ECDSA_KEY \
924              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
925              ECDSA_KEY \
926              --no-read-protect&quot;
927          )
928          output = self.espefuse_py(&quot;summary -d&quot;)
929          assert (
930              &quot;= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 &quot;
931              &quot;cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-&quot;
932          ) in output
933          assert (
934              &quot;= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b &quot;
935              &quot;38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-&quot;
936          ) in output
937          assert (
938              &quot;[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 &quot;
939              &quot;238123cb 4f71b795 00000000 00000000&quot;
940          ) in output
941          assert (
942              &quot;[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed &quot;
943              &quot;8450c238 c39d087a 90066a66 b4548b23&quot;
944          ) in output
945  class TestBurnBlockDataCommands(EfuseTestCase):
946      def test_burn_block_data_check_args(self):
947          self.espefuse_py(&quot;burn_block_data -h&quot;)
948          blk0 = &quot;BLOCK0&quot;
949          blk1 = &quot;BLOCK1&quot;
950          self.espefuse_py(
951              f&quot;burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}&quot;,
952              check_msg=&quot;A fatal error occurred: &quot;
953              &quot;The number of block_name (2) and datafile (1) should be the same.&quot;,
954              ret_code=2,
955          )
956      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
957      def test_burn_block_data_with_3_key_blocks(self):
958          self.espefuse_py(
959              f&quot;burn_block_data \
960              BLOCK0 {IMAGES_DIR}/224bit \
961              BLOCK3 {IMAGES_DIR}/256bit&quot;
962          )
963          output = self.espefuse_py(&quot;summary -d&quot;)
964          assert (
965              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
966              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
967          ) in output
968          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
969          self.espefuse_py(
970              f&quot;burn_block_data \
971              BLOCK2 {IMAGES_DIR}/256bit_1&quot;
972          )
973          self.check_data_block_in_log(
974              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
975          )
976          self.espefuse_py(
977              f&quot;burn_block_data \
978              BLOCK1 {IMAGES_DIR}/256bit_2&quot;
979          )
980          self.check_data_block_in_log(
981              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_2&quot;
982          )
983      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
984      def test_burn_block_data_with_1_key_block(self):
985          self.espefuse_py(
986              f&quot;burn_block_data \
987              BLOCK0 {IMAGES_DIR}/64bit \
988              BLOCK1 {IMAGES_DIR}/96bit \
989              BLOCK2 {IMAGES_DIR}/256bit \
990              BLOCK3 {IMAGES_DIR}/256bit&quot;
991          )
992          output = self.espefuse_py(&quot;summary -d&quot;)
993          assert &quot;[0 ] read_regs: 00000001 0000000c&quot; in output
994          assert &quot;[1 ] read_regs: 03020100 07060504 000a0908&quot; in output
995          assert (
996              &quot;[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
997              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
998          ) in output
999          assert (
1000              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1001              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1002          ) in output
1003      @pytest.mark.skipif(
1004          arg_chip
1005          not in [
1006              &quot;esp32s2&quot;,
1007              &quot;esp32s3&quot;,
1008              &quot;esp32s3beta1&quot;,
1009              &quot;esp32c3&quot;,
1010              &quot;esp32h2beta1&quot;,
1011              &quot;esp32c6&quot;,
1012              &quot;esp32h2&quot;,
1013          ],
1014          reason=&quot;Only chip with 6 keys&quot;,
1015      )
1016      def test_burn_block_data_with_6_keys(self):
1017          self.espefuse_py(
1018              f&quot;burn_block_data \
1019              BLOCK0 {IMAGES_DIR}/192bit \
1020              BLOCK3 {IMAGES_DIR}/256bit&quot;
1021          )
1022          output = self.espefuse_py(&quot;summary -d&quot;)
1023          assert (
1024              &quot;[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1025              in output
1026          )
1027          assert (
1028              &quot;[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac &quot;
1029              &quot;b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc&quot;
1030          ) in output
1031          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1032          self.espefuse_py(
1033              f&quot;burn_block_data \
1034              BLOCK10 {IMAGES_DIR}/256bit_1&quot;
1035          )
1036          self.check_data_block_in_log(
1037              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/256bit_1&quot;
1038          )
1039          self.espefuse_py(
1040              f&quot;burn_block_data \
1041              BLOCK1 {IMAGES_DIR}/192bit \
1042              BLOCK5 {IMAGES_DIR}/256bit_1 \
1043              BLOCK6 {IMAGES_DIR}/256bit_2&quot;
1044          )
1045          output = self.espefuse_py(&quot;summary -d&quot;)
1046          assert (
1047              &quot;[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514&quot;
1048              in output
1049          )
1050          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit&quot;)
1051          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_1&quot;, 2)
1052          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/256bit_2&quot;)
1053      def test_burn_block_data_check_errors(self):
1054          self.espefuse_py(
1055              f&quot;burn_block_data \
1056              BLOCK2 {IMAGES_DIR}/192bit \
1057              BLOCK2 {IMAGES_DIR}/192bit_1&quot;,
1058              check_msg=&quot;A fatal error occurred: Found repeated&quot;,
1059              ret_code=2,
1060          )
1061          self.espefuse_py(
1062              f&quot;burn_block_data \
1063              BLOCK2 {IMAGES_DIR}/192bit \
1064              BLOCK3 {IMAGES_DIR}/192bit_1 \
1065              --offset 4&quot;,
1066              check_msg=&quot;A fatal error occurred: &quot;
1067              &quot;The &#x27;offset&#x27; option is not applicable when a few blocks are passed.&quot;,
1068              ret_code=2,
1069          )
1070          self.espefuse_py(
1071              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33&quot;,
1072              check_msg=&quot;A fatal error occurred: Invalid offset: the block0 only holds&quot;,
1073              ret_code=2,
1074          )
1075          self.espefuse_py(
1076              f&quot;burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4&quot;,
1077              check_msg=&quot;A fatal error occurred: Data does not fit:&quot;,
1078              ret_code=2,
1079          )
1080      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1081      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1082          offset = 1
1083          self.espefuse_py(
1084              f&quot;burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit&quot;
1085          )
1086          offset = 4
1087          self.espefuse_py(
1088              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1&quot;
1089          )
1090          self.check_data_block_in_log(
1091              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1092          )
1093          offset = 6
1094          self.espefuse_py(
1095              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2&quot;
1096          )
1097          self.check_data_block_in_log(
1098              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1099          )
1100          offset = 8
1101          self.espefuse_py(
1102              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1103          )
1104          self.check_data_block_in_log(
1105              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1106          )
1107      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1108      def test_burn_block_data_with_offset_1_key_block(self):
1109          offset = 4
1110          self.espefuse_py(f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit&quot;)
1111          output = self.espefuse_py(&quot;summary -d&quot;)
1112          assert &quot;[1 ] read_regs: 00000000 03020100 00060504&quot; in output
1113          offset = 6
1114          self.espefuse_py(
1115              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1&quot;
1116          )
1117          output = self.espefuse_py(&quot;summary -d&quot;)
1118          assert (
1119              &quot;[2 ] read_regs: 00000000 00110000 05000000 09080706 &quot;
1120              &quot;0d0c0b0a 11100f0e 15141312 00002116&quot;
1121          ) in output
1122          offset = 8
1123          self.espefuse_py(
1124              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1125          )
1126          self.check_data_block_in_log(
1127              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1128          )
1129      @pytest.mark.skipif(
1130          arg_chip
1131          not in [
1132              &quot;esp32s2&quot;,
1133              &quot;esp32s3&quot;,
1134              &quot;esp32s3beta1&quot;,
1135              &quot;esp32c3&quot;,
1136              &quot;esp32h2beta1&quot;,
1137              &quot;esp32c6&quot;,
1138              &quot;esp32h2&quot;,
1139          ],
1140          reason=&quot;Only chips with 6 keys&quot;,
1141      )
1142      def test_burn_block_data_with_offset_6_keys(self):
1143          offset = 4
1144          self.espefuse_py(
1145              f&quot;burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1&quot;
1146          )
1147          self.check_data_block_in_log(
1148              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_1&quot;, offset=offset
1149          )
1150          offset = 6
1151          self.espefuse_py(
1152              f&quot;burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2&quot;
1153          )
1154          self.check_data_block_in_log(
1155              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1156          )
1157          offset = 8
1158          self.espefuse_py(
1159              f&quot;burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2&quot;
1160          )
1161          self.check_data_block_in_log(
1162              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/192bit_2&quot;, offset=offset
1163          )
1164      @pytest.mark.skipif(
1165          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1166      )
1167      def test_burn_block_data_with_34_coding_scheme(self):
1168          self._set_34_coding_scheme()
1169          self.espefuse_py(
1170              f&quot;burn_block_data BLOCK1 {IMAGES_DIR}/256bit&quot;,
1171              check_msg=&quot;A fatal error occurred: Data does not fit: &quot;
1172              &quot;the block1 size is 24 bytes, data file is 32 bytes, offset 0&quot;,
1173              ret_code=2,
1174          )
1175          self.espefuse_py(
1176              f&quot;burn_block_data \
1177              BLOCK1 {IMAGES_DIR}/192bit \
1178              BLOCK2 {IMAGES_DIR}/192bit_1 \
1179              BLOCK3 {IMAGES_DIR}/192bit_2&quot;
1180          )
1181          output = self.espefuse_py(&quot;summary -d&quot;)
1182          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit&quot;)
1183          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_1&quot;)
1184          self.check_data_block_in_log(output, f&quot;{IMAGES_DIR}/192bit_2&quot;)
1185      @pytest.mark.skipif(
1186          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1187      )
1188      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1189          self._set_34_coding_scheme()
1190          offset = 4
1191          self.espefuse_py(
1192              f&quot;burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit&quot;
1193          )
1194          self.check_data_block_in_log(
1195              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1196          )
1197          offset = 6
1198          self.espefuse_py(
1199              f&quot;burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit&quot;
1200          )
1201          self.check_data_block_in_log(
1202              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1203          )
1204          offset = 8
1205          self.espefuse_py(
1206              f&quot;burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit&quot;
1207          )
1208          self.check_data_block_in_log(
1209              self.espefuse_py(&quot;summary -d&quot;), f&quot;{IMAGES_DIR}/128bit&quot;, offset=offset
1210          )
1211  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only, supports 2 key blocks&quot;)
1212  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1213      def test_burn_key_digest(self):
1214          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1215          esp = self.get_esptool()
1216          if esp.get_chip_revision() &gt;= 300:
1217              self.espefuse_py(
1218                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1219              )
1220              output = self.espefuse_py(&quot;summary -d&quot;)
1221              assert (
1222                  &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1223                  &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1224              ) in output
1225          else:
1226              self.espefuse_py(
1227                  f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1228                  check_msg=&quot;Incorrect chip revision for Secure boot v2.&quot;,
1229                  ret_code=2,
1230              )
1231      def test_burn_key_from_digest(self):
1232          self.espefuse_py(
1233              f&quot;burn_key \
1234              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key&quot;
1235          )
1236          output = self.espefuse_py(&quot;summary -d&quot;)
1237          assert 1 == output.count(
1238              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1239              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W&quot;
1240          )
1241      def test_burn_key_digest_with_34_coding_scheme(self):
1242          self._set_34_coding_scheme()
1243          self.espefuse_py(
1244              f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;,
1245              check_msg=&quot;burn_key_digest only works with &#x27;None&#x27; coding scheme&quot;,
1246              ret_code=2,
1247          )
1248  @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only, supports 1 key block&quot;)
1249  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1250      def test_burn_key_digest1(self):
1251          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1252          self.espefuse_py(
1253              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem&quot;
1254          )
1255          output = self.espefuse_py(&quot;summary -d&quot;)
1256          assert &quot; = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot; in output
1257          assert (
1258              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1259              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1260          ) in output
1261      def test_burn_key_digest2(self):
1262          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1263          self.espefuse_py(
1264              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1265          )
1266          output = self.espefuse_py(&quot;summary -d&quot;)
1267          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1268          assert (
1269              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1270              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1271          ) in output
1272      def test_burn_key_from_digest1(self):
1273          self.espefuse_py(
1274              &quot;burn_key BLOCK_KEY0 &quot;
1275              f&quot;{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1276          )
1277          output = self.espefuse_py(&quot;summary -d&quot;)
1278          assert (
1279              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1280              &quot;1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-&quot;
1281          ) in output
1282      def test_burn_key_from_digest2(self):
1283          self.espefuse_py(
1284              &quot;burn_key BLOCK_KEY0 &quot;
1285              f&quot;{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST&quot;
1286          )
1287          output = self.espefuse_py(&quot;summary -d&quot;)
1288          assert (
1289              &quot; = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 &quot;
1290              &quot;bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot;
1291          ) in output
1292  @pytest.mark.skipif(
1293      arg_chip
1294      not in [
1295          &quot;esp32s2&quot;,
1296          &quot;esp32s3&quot;,
1297          &quot;esp32s3beta1&quot;,
1298          &quot;esp32c3&quot;,
1299          &quot;esp32h2beta1&quot;,
1300          &quot;esp32c6&quot;,
1301          &quot;esp32h2&quot;,
1302      ],
1303      reason=&quot;Supports 6 key blocks&quot;,
1304  )
1305  class TestBurnKeyDigestCommands(EfuseTestCase):
1306      def test_burn_key_digest(self):
1307          self.espefuse_py(&quot;burn_key_digest -h&quot;)
1308          self.espefuse_py(
1309              f&quot;burn_key_digest \
1310              BLOCK_KEY0 \
1311              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1312              BLOCK_KEY1 \
1313              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1314              BLOCK_KEY2 &quot;,
1315              check_msg=&quot;A fatal error occurred: The number of blocks (3), &quot;
1316              &quot;datafile (2) and keypurpose (2) should be the same.&quot;,
1317              ret_code=2,
1318          )
1319          self.espefuse_py(
1320              f&quot;burn_key_digest \
1321              BLOCK_KEY0 \
1322              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1323              BLOCK_KEY1 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1325              BLOCK_KEY2 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2&quot;
1327          )
1328          output = self.espefuse_py(&quot;summary -d&quot;)
1329          assert 1 == output.count(
1330              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1331              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1332          )
1333          assert 2 == output.count(
1334              &quot; = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 &quot;
1335              &quot;6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-&quot;
1336          )
1337      def test_burn_key_from_digest(self):
1338          self.espefuse_py(
1339              f&quot;burn_key \
1340              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1341          )
1342          output = self.espefuse_py(&quot;summary -d&quot;)
1343          assert 1 == output.count(
1344              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1345              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1346          )
1347          self.espefuse_py(
1348              f&quot;burn_key_digest \
1349              BLOCK_KEY1 \
1350              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1&quot;
1351          )
1352          output = self.espefuse_py(&quot;summary -d&quot;)
1353          assert 2 == output.count(
1354              &quot; = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 &quot;
1355              &quot;22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-&quot;
1356          )
1357  class TestBurnBitCommands(EfuseTestCase):
1358      @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32-only&quot;)
1359      def test_burn_bit_for_chips_with_3_key_blocks(self):
1360          self.espefuse_py(&quot;burn_bit -h&quot;)
1361          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1362          self.espefuse_py(
1363              &quot;summary&quot;,
1364              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 &quot;
1365              &quot;00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1366          )
1367          self.espefuse_py(
1368              &quot;burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254&quot;
1369          )
1370          self.espefuse_py(
1371              &quot;summary&quot;,
1372              check_msg=&quot;ff ff 01 80 01 00 00 80 01 00 00 80 01 &quot;
1373              &quot;00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0&quot;,
1374          )
1375      @pytest.mark.skipif(arg_chip != &quot;esp32c2&quot;, reason=&quot;ESP32-C2-only&quot;)
1376      def test_burn_bit_for_chips_with_1_key_block(self):
1377          self.espefuse_py(&quot;burn_bit -h&quot;)
1378          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1379          self.espefuse_py(
1380              &quot;summary&quot;,
1381              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1382              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1383          )
1384          self.espefuse_py(
1385              &quot;burn_bit BLOCK3 100&quot;,
1386              check_msg=&quot;Burn into BLOCK_KEY0 is forbidden &quot;
1387              &quot;(RS coding scheme does not allow this)&quot;,
1388              ret_code=2,
1389          )
1390          self.espefuse_py(&quot;burn_bit BLOCK0 0 1 2&quot;)
1391          self.espefuse_py(&quot;summary&quot;, check_msg=&quot;[0 ] read_regs: 00000007 00000000&quot;)
1392      @pytest.mark.skipif(
1393          arg_chip
1394          not in [
1395              &quot;esp32s2&quot;,
1396              &quot;esp32s3&quot;,
1397              &quot;esp32s3beta1&quot;,
1398              &quot;esp32c3&quot;,
1399              &quot;esp32h2beta1&quot;,
1400              &quot;esp32c6&quot;,
1401              &quot;esp32h2&quot;,
1402          ],
1403          reason=&quot;Only chip with 6 keys&quot;,
1404      )
1405      def test_burn_bit_for_chips_with_6_key_blocks(self):
1406          self.espefuse_py(&quot;burn_bit -h&quot;)
1407          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255&quot;)
1408          self.espefuse_py(
1409              &quot;summary&quot;,
1410              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1411              &quot;00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80&quot;,
1412          )
1413          self.espefuse_py(
1414              &quot;burn_bit BLOCK3 100&quot;,
1415              check_msg=&quot;Burn into BLOCK_USR_DATA is forbidden &quot;
1416              &quot;(RS coding scheme does not allow this)&quot;,
1417              ret_code=2,
1418          )
1419          self.espefuse_py(&quot;burn_bit BLOCK0 13&quot;)
1420          self.espefuse_py(
1421              &quot;summary&quot;,
1422              check_msg=&quot;[0 ] read_regs: 00002000 00000000 00000000 &quot;
1423              &quot;00000000 00000000 00000000&quot;,
1424          )
1425          self.espefuse_py(&quot;burn_bit BLOCK0 24&quot;)
1426          self.espefuse_py(
1427              &quot;summary&quot;,
1428              check_msg=&quot;[0 ] read_regs: 01002000 00000000 00000000 &quot;
1429              &quot;00000000 00000000 00000000&quot;,
1430          )
1431      @pytest.mark.skipif(
1432          arg_chip != &quot;esp32&quot;, reason=&quot;3/4 coding scheme is only in esp32&quot;
1433      )
1434      def test_burn_bit_with_34_coding_scheme(self):
1435          self._set_34_coding_scheme()
1436          self.espefuse_py(&quot;burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191&quot;)
1437          self.espefuse_py(
1438              &quot;summary&quot;,
1439              check_msg=&quot;17 01 01 00 01 00 00 00 01 00 00 00 01 00 &quot;
1440              &quot;00 00 01 00 00 00 01 00 00 80&quot;,
1441          )
1442          self.espefuse_py(
1443              &quot;burn_bit BLOCK3 17&quot;,
1444              check_msg=&quot;Burn into BLOCK3 is forbidden &quot;
1445              &quot;(3/4 coding scheme does not allow this).&quot;,
1446              ret_code=2,
1447          )
1448  @pytest.mark.skipif(
1449      arg_chip != &quot;esp32&quot;, reason=&quot;Tests are only for esp32. (TODO: add for all chips)&quot;
1450  )
1451  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1452      def test_1_secure_boot_v1(self):
1453          if arg_chip == &quot;esp32&quot;:
1454              self.espefuse_py(
1455                  f&quot;burn_key \
1456                  flash_encryption {IMAGES_DIR}/256bit \
1457                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1458              )
1459              output = self.espefuse_py(&quot;summary -d&quot;)
1460              self.check_data_block_in_log(
1461                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1462              )
1463              self.check_data_block_in_log(
1464                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=True
1465              )
1466              self.espefuse_py(
1467                  f&quot;burn_key \
1468                  flash_encryption  {IMAGES_DIR}/256bit \
1469                  secure_boot_v1    {IMAGES_DIR}/256bit_1&quot;
1470              )
1471              output = self.espefuse_py(&quot;summary -d&quot;)
1472              assert (
1473                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1474                  &quot;00000000 00000000 00000000 00000000&quot;
1475              ) in output
1476              assert (
1477                  &quot;[2 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1478                  &quot;00000000 00000000 00000000 00000000&quot;
1479              ) in output
1480              assert (
1481                  &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1482                  &quot;00000000 00000000 00000000 00000000&quot;
1483              ) in output
1484      def test_2_secure_boot_v1(self):
1485          if arg_chip == &quot;esp32&quot;:
1486              self.espefuse_py(
1487                  f&quot;burn_key \
1488                  flash_encryption {IMAGES_DIR}/256bit \
1489                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key&quot;
1490              )
1491              output = self.espefuse_py(&quot;summary -d&quot;)
1492              self.check_data_block_in_log(
1493                  output, f&quot;{IMAGES_DIR}/256bit&quot;, reverse_order=True
1494              )
1495              self.check_data_block_in_log(
1496                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1497              )
1498              self.espefuse_py(
1499                  f&quot;burn_key \
1500                  flash_encryption {IMAGES_DIR}/256bit \
1501                  secure_boot_v2 {IMAGES_DIR}/256bit_1&quot;
1502              )
1503              output = self.espefuse_py(&quot;summary -d&quot;)
1504              assert (
1505                  &quot;[1 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1506                  &quot;00000000 00000000 00000000 00000000&quot;
1507              ) in output
1508              self.check_data_block_in_log(
1509                  output, f&quot;{IMAGES_DIR}/256bit_1&quot;, reverse_order=False
1510              )
1511  class TestExecuteScriptsCommands(EfuseTestCase):
1512      @classmethod
1513      def setup_class(self):
<span onclick='openModal()' class='match'>1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
</span>1518      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1519      def test_execute_scripts_with_check_that_only_one_burn(self):
1520          self.espefuse_py(&quot;execute_scripts -h&quot;)
1521          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1522          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1523          self.espefuse_py(&quot;execute_scripts execute_efuse_script2.py&quot;)
1524      @pytest.mark.skipif(arg_chip == &quot;esp32c2&quot;, reason=&quot;TODO: Add tests for esp32c2&quot;)
1525      def test_execute_scripts_with_check(self):
1526          self.espefuse_py(&quot;execute_scripts -h&quot;)
1527          name = arg_chip if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;] else &quot;esp32xx&quot;
1528          os.chdir(os.path.join(TEST_DIR, &quot;efuse_scripts&quot;, name))
1529          self.espefuse_py(&quot;execute_scripts execute_efuse_script.py&quot;)
1530      def test_execute_scripts_with_index_and_config(self):
1531          os.chdir(TEST_DIR)
1532          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1533              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1534              --configfiles {EFUSE_S_DIR}/esp32/config1.json&quot;
1535          else:
1536              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1537              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json&quot;
1538          self.espefuse_py(cmd)
1539          output = self.espefuse_py(&quot;summary -d&quot;)
1540          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1541              assert (
1542                  &quot;[3 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1543                  &quot;00000000 00000000 00000000 00000000&quot;
1544              ) in output
1545          else:
1546              assert (
1547                  &quot;[8 ] read_regs: e00007ff 00000000 00000000 00000000 &quot;
1548                  &quot;00000000 00000000 00000000 00000000&quot;
1549              ) in output
1550      def test_execute_scripts_nesting(self):
1551          os.chdir(TEST_DIR)
1552          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1553              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1554              --configfiles {EFUSE_S_DIR}/esp32/config2.json&quot;
1555          else:
1556              cmd = f&quot;execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1557              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json&quot;
1558          self.espefuse_py(cmd)
1559          output = self.espefuse_py(&quot;summary -d&quot;)
1560          if arg_chip in [&quot;esp32&quot;, &quot;esp32c2&quot;]:
1561              assert (
1562                  &quot;[2 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1563                  &quot;00000000 00000000 00000000 00000000&quot;
1564              ) in output
1565              assert (
1566                  &quot;[3 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1567                  &quot;00000000 00000000 00000000 00000000&quot;
1568              ) in output
1569          else:
1570              assert (
1571                  &quot;[7 ] read_regs: 10000000 00000000 00000000 00000000 &quot;
1572                  &quot;00000000 00000000 00000000 00000000&quot;
1573              ) in output
1574              assert (
1575                  &quot;[8 ] read_regs: ffffffff 00000000 00000000 00000000 &quot;
1576                  &quot;00000000 00000000 00000000 00000000&quot;
1577              ) in output
1578  class TestMultipleCommands(EfuseTestCase):
1579      def test_multiple_cmds_help(self):
1580          if arg_chip == &quot;esp32c2&quot;:
1581              command1 = (
1582                  f&quot;burn_key_digest {S_IMAGES_DIR}&quot;
1583                  &quot;/ecdsa256_secure_boot_signing_key_v2.pem&quot;
1584              )
1585              command2 = (
1586                  f&quot;burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key &quot;
1587                  &quot;XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS&quot;
1588              )
1589          elif arg_chip == &quot;esp32&quot;:
1590              command1 = f&quot;burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem&quot;
1591              command2 = f&quot;burn_key flash_encryption {IMAGES_DIR}/256bit&quot;
1592          else:
1593              command1 = f&quot;burn_key_digest BLOCK_KEY0 \
1594              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0&quot;
1595              command2 = f&quot;burn_key BLOCK_KEY0 \
1596              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0&quot;
1597          self.espefuse_py(
1598              f&quot;-h {command1} {command2}&quot;,
1599              check_msg=&quot;usage: __main__.py [-h]&quot;,
1600          )
1601          self.espefuse_py(
1602              f&quot;{command1} -h {command2}&quot;,
1603              check_msg=&quot;usage: __main__.py burn_key_digest [-h]&quot;,
1604          )
1605          self.espefuse_py(
1606              f&quot;{command1} {command2} -h&quot;,
1607              check_msg=&quot;usage: __main__.py burn_key [-h]&quot;,
1608          )
1609      @pytest.mark.skipif(
1610          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1611      )
1612      def test_1_esp32c2(self):
1613          self.espefuse_py(
1614              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1615              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1616              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1617              summary&quot;
1618          )
1619          output = self.espefuse_py(&quot;summary -d&quot;)
1620          assert (
1621              &quot;[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 &quot;
1622              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1623          ) in output
1624          assert &quot; = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-&quot; in output
1625          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1626      @pytest.mark.skipif(
1627          arg_chip != &quot;esp32c2&quot;, reason=&quot;For this chip, FE and SB keys go into one BLOCK&quot;
1628      )
1629      def test_2_esp32c2(self):
1630          self.espefuse_py(
1631              f&quot;burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1632              burn_key BLOCK_KEY0 \
1633              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1634              summary&quot;
1635          )
1636          output = self.espefuse_py(&quot;summary -d&quot;)
1637          assert (
1638              &quot;[3 ] read_regs: 00000000 00000000 00000000 00000000 &quot;
1639              &quot;f66a0fbf 8b6dd38b a9dab353 040af633&quot;
1640          ) in output
1641          assert &quot; = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-&quot; in output
1642          assert &quot; = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-&quot; in output
1643      def test_burn_bit(self):
1644          if arg_chip == &quot;esp32&quot;:
1645              self._set_34_coding_scheme()
1646          self.espefuse_py(
1647              &quot;burn_bit BLOCK2 0 1 2 3 \
1648              burn_bit BLOCK2 4 5 6 7 \
1649              burn_bit BLOCK2 8 9 10 11 \
1650              burn_bit BLOCK2 12 13 14 15 \
1651              summary&quot;
1652          )
1653          output = self.espefuse_py(&quot;summary -d&quot;)
1654          assert &quot;[2 ] read_regs: 0000ffff 00000000&quot; in output
1655      def test_not_burn_cmds(self):
1656          self.espefuse_py(
1657              &quot;summary \
1658              dump \
1659              get_custom_mac \
1660              adc_info \
1661              check_error&quot;
1662          )
1663  @pytest.mark.skipif(
1664      arg_chip not in [&quot;esp32c3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;, &quot;esp32s3&quot;],
1665      reason=&quot;These chips have a hardware bug that limits the use of the KEY5&quot;,
1666  )
1667  class TestKeyPurposes(EfuseTestCase):
1668      def test_burn_xts_aes_key_purpose(self):
1669          self.espefuse_py(
1670              &quot;burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY&quot;,
1671              check_msg=&quot;A fatal error occurred: &quot;
1672              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1673              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1674              ret_code=2,
1675          )
1676      @pytest.mark.skipif(
1677          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1678      )
1679      def test_burn_ecdsa_key_purpose(self):
1680          self.espefuse_py(
1681              &quot;burn_efuse KEY_PURPOSE_5 ECDSA_KEY&quot;,
1682              check_msg=&quot;A fatal error occurred: &quot;
1683              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1684              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1685              ret_code=2,
1686          )
1687      def test_burn_xts_aes_key(self):
1688          self.espefuse_py(
1689              f&quot;burn_key \
1690              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY&quot;,
1691              check_msg=&quot;A fatal error occurred: &quot;
1692              &quot;KEY_PURPOSE_5 can not have XTS_AES_128_KEY &quot;
1693              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1694              ret_code=2,
1695          )
1696      @pytest.mark.skipif(
1697          arg_chip != &quot;esp32h2&quot;, reason=&quot;esp32h2 can not have ECDSA key in KEY5&quot;
1698      )
1699      def test_burn_ecdsa_key(self):
1700          self.espefuse_py(
1701              f&quot;burn_key \
1702              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1703              ECDSA_KEY&quot;,
1704              check_msg=&quot;A fatal error occurred: &quot;
1705              &quot;KEY_PURPOSE_5 can not have ECDSA_KEY &quot;
1706              &quot;key due to a hardware bug (please see TRM for more details)&quot;,
1707              ret_code=2,
1708          )
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_http.py</h3>
            <pre><code>1  #!/usr/bin/env python
2  from __future__ import absolute_import
3  __author__ = &quot;jcgregorio@google.com (Joe Gregorio)&quot;
4  import io
5  from io import FileIO
6  import json
7  import logging
8  import os
9  import random
10  import socket
11  import ssl
12  import time
13  import unittest
14  from unittest import mock
15  import urllib
16  import httplib2
17  from googleapiclient.discovery import build
18  from googleapiclient.errors import BatchError, HttpError, InvalidChunkSizeError
19  from googleapiclient.http import (
20      MAX_URI_LENGTH,
21      BatchHttpRequest,
22      HttpMock,
23      HttpMockSequence,
24      HttpRequest,
25      MediaFileUpload,
26      MediaInMemoryUpload,
27      MediaIoBaseDownload,
28      MediaIoBaseUpload,
29      MediaUpload,
30      _StreamSlice,
31      build_http,
32      set_user_agent,
33  )
34  from googleapiclient.model import JsonModel
35  class MockCredentials:
36      def __init__(self, bearer_token, expired=False):
37          super(MockCredentials, self).__init__()
38          self._authorized = 0
39          self._refreshed = 0
40          self._applied = 0
41          self._bearer_token = bearer_token
42          self._access_token_expired = expired
43      @property
44      def access_token(self):
45          return self._bearer_token
46      @property
47      def access_token_expired(self):
48          return self._access_token_expired
49      def authorize(self, http):
50          self._authorized += 1
51          request_orig = http.request
52          def new_request(
53              uri,
54              method=&quot;GET&quot;,
55              body=None,
56              headers=None,
57              redirections=httplib2.DEFAULT_MAX_REDIRECTS,
58              connection_type=None,
59          ):
60              if headers is None:
61                  headers = {}
62              self.apply(headers)
63              resp, content = request_orig(
64                  uri, method, body, headers, redirections, connection_type
65              )
66              return resp, content
67          http.request = new_request
68          setattr(http.request, &quot;credentials&quot;, self)
69          return http
70      def refresh(self, http):
71          self._refreshed += 1
72      def apply(self, headers):
73          self._applied += 1
74          headers[&quot;authorization&quot;] = self._bearer_token + &quot; &quot; + str(self._refreshed)
75  class HttpMockWithErrors(object):
76      def __init__(self, num_errors, success_json, success_data):
77          self.num_errors = num_errors
78          self.success_json = success_json
79          self.success_data = success_data
80      def request(self, *args, **kwargs):
81          if not self.num_errors:
82              return httplib2.Response(self.success_json), self.success_data
83          elif self.num_errors == 5:
84              ex = ConnectionResetError  # noqa: F821
85          elif self.num_errors == 4:
86              ex = httplib2.ServerNotFoundError()
87          elif self.num_errors == 3:
88              ex = OSError()
89              ex.errno = socket.errno.EPIPE
90          elif self.num_errors == 2:
91              ex = ssl.SSLError()
92          else:
93              try:
94                  ex = OSError()
95                  ex.errno = socket.errno.WSAETIMEDOUT
96              except AttributeError:
97                  ex = socket.timeout()
98          self.num_errors -= 1
99          raise ex
100  class HttpMockWithNonRetriableErrors(object):
101      def __init__(self, num_errors, success_json, success_data):
102          self.num_errors = num_errors
103          self.success_json = success_json
104          self.success_data = success_data
105      def request(self, *args, **kwargs):
106          if not self.num_errors:
107              return httplib2.Response(self.success_json), self.success_data
108          else:
109              self.num_errors -= 1
110              ex = OSError()
111              try:
112                  ex.errno = socket.errno.WSAEHOSTUNREACH
113              except AttributeError:
114                  ex.errno = socket.errno.EHOSTUNREACH
115              raise ex
116  DATA_DIR = os.path.join(os.path.dirname(__file__), &quot;data&quot;)
117  def datafile(filename):
118      return os.path.join(DATA_DIR, filename)
119  def _postproc_none(*kwargs):
120      pass
121  class TestUserAgent(unittest.TestCase):
122      def test_set_user_agent(self):
123          http = HttpMockSequence([({&quot;status&quot;: &quot;200&quot;}, &quot;echo_request_headers&quot;)])
124          http = set_user_agent(http, &quot;my_app/5.5&quot;)
125          resp, content = http.request(&quot;http://example.com&quot;)
126          self.assertEqual(&quot;my_app/5.5&quot;, content[&quot;user-agent&quot;])
127      def test_set_user_agent_nested(self):
128          http = HttpMockSequence([({&quot;status&quot;: &quot;200&quot;}, &quot;echo_request_headers&quot;)])
129          http = set_user_agent(http, &quot;my_app/5.5&quot;)
130          http = set_user_agent(http, &quot;my_library/0.1&quot;)
131          resp, content = http.request(&quot;http://example.com&quot;)
132          self.assertEqual(&quot;my_app/5.5 my_library/0.1&quot;, content[&quot;user-agent&quot;])
133  class TestMediaUpload(unittest.TestCase):
134      def test_media_file_upload_closes_fd_in___del__(self):
135          file_desc = mock.Mock(spec=io.TextIOWrapper)
136          opener = mock.mock_open(file_desc)
137          with mock.patch(&quot;builtins.open&quot;, return_value=opener):
138              upload = MediaFileUpload(datafile(&quot;test_close&quot;), mimetype=&quot;text/plain&quot;)
139          self.assertIs(upload.stream(), file_desc)
140          del upload
141          file_desc.close.assert_called_once_with()
142      def test_media_file_upload_mimetype_detection(self):
143          upload = MediaFileUpload(datafile(&quot;small.png&quot;))
144          self.assertEqual(&quot;image/png&quot;, upload.mimetype())
145          upload = MediaFileUpload(datafile(&quot;empty&quot;))
146          self.assertEqual(&quot;application/octet-stream&quot;, upload.mimetype())
147      def test_media_file_upload_to_from_json(self):
148          upload = MediaFileUpload(datafile(&quot;small.png&quot;), chunksize=500, resumable=True)
149          self.assertEqual(&quot;image/png&quot;, upload.mimetype())
150          self.assertEqual(190, upload.size())
151          self.assertEqual(True, upload.resumable())
152          self.assertEqual(500, upload.chunksize())
153          self.assertEqual(b&quot;PNG&quot;, upload.getbytes(1, 3))
154          json = upload.to_json()
155          new_upload = MediaUpload.new_from_json(json)
156          self.assertEqual(&quot;image/png&quot;, new_upload.mimetype())
157          self.assertEqual(190, new_upload.size())
158          self.assertEqual(True, new_upload.resumable())
159          self.assertEqual(500, new_upload.chunksize())
160          self.assertEqual(b&quot;PNG&quot;, new_upload.getbytes(1, 3))
161      def test_media_file_upload_raises_on_file_not_found(self):
162          with self.assertRaises(FileNotFoundError):
163              MediaFileUpload(datafile(&quot;missing.png&quot;))
164      def test_media_file_upload_raises_on_invalid_chunksize(self):
165          self.assertRaises(
166              InvalidChunkSizeError,
167              MediaFileUpload,
168              datafile(&quot;small.png&quot;),
169              mimetype=&quot;image/png&quot;,
170              chunksize=-2,
171              resumable=True,
172          )
173      def test_media_inmemory_upload(self):
174          media = MediaInMemoryUpload(
175              b&quot;abcdef&quot;, mimetype=&quot;text/plain&quot;, chunksize=10, resumable=True
176          )
177          self.assertEqual(&quot;text/plain&quot;, media.mimetype())
178          self.assertEqual(10, media.chunksize())
179          self.assertTrue(media.resumable())
180          self.assertEqual(b&quot;bc&quot;, media.getbytes(1, 2))
181          self.assertEqual(6, media.size())
182      def test_http_request_to_from_json(self):
183          http = build_http()
184          media_upload = MediaFileUpload(
185              datafile(&quot;small.png&quot;), chunksize=500, resumable=True
186          )
187          req = HttpRequest(
188              http,
189              _postproc_none,
190              &quot;http://example.com&quot;,
191              method=&quot;POST&quot;,
192              body=&quot;{}&quot;,
193              headers={&quot;content-type&quot;: &#x27;multipart/related; boundary=&quot;---flubber&quot;&#x27;},
194              methodId=&quot;foo&quot;,
195              resumable=media_upload,
196          )
197          json = req.to_json()
198          new_req = HttpRequest.from_json(json, http, _postproc_none)
199          self.assertEqual(
200              {&quot;content-type&quot;: &#x27;multipart/related; boundary=&quot;---flubber&quot;&#x27;},
201              new_req.headers,
202          )
203          self.assertEqual(&quot;http://example.com&quot;, new_req.uri)
204          self.assertEqual(&quot;{}&quot;, new_req.body)
205          self.assertEqual(http, new_req.http)
206          self.assertEqual(media_upload.to_json(), new_req.resumable.to_json())
207          self.assertEqual(random.random, new_req._rand)
208          self.assertEqual(time.sleep, new_req._sleep)
209  class TestMediaIoBaseUpload(unittest.TestCase):
210      def test_media_io_base_upload_from_file_io(self):
211          fd = FileIO(datafile(&quot;small.png&quot;), &quot;r&quot;)
212          upload = MediaIoBaseUpload(
213              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
214          )
215          self.assertEqual(&quot;image/png&quot;, upload.mimetype())
216          self.assertEqual(190, upload.size())
217          self.assertEqual(True, upload.resumable())
218          self.assertEqual(500, upload.chunksize())
219          self.assertEqual(b&quot;PNG&quot;, upload.getbytes(1, 3))
220      def test_media_io_base_upload_from_file_object(self):
221          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
222          upload = MediaIoBaseUpload(
223              fd=f, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
224          )
225          self.assertEqual(&quot;image/png&quot;, upload.mimetype())
226          self.assertEqual(190, upload.size())
227          self.assertEqual(True, upload.resumable())
228          self.assertEqual(500, upload.chunksize())
229          self.assertEqual(b&quot;PNG&quot;, upload.getbytes(1, 3))
230          f.close()
231      def test_media_io_base_upload_serializable(self):
232          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
233          upload = MediaIoBaseUpload(fd=f, mimetype=&quot;image/png&quot;)
234          try:
235              json = upload.to_json()
236              self.fail(&quot;MediaIoBaseUpload should not be serializable.&quot;)
237          except NotImplementedError:
238              pass
239      def test_media_io_base_upload_from_bytes(self):
240          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
241          fd = io.BytesIO(f.read())
242          upload = MediaIoBaseUpload(
243              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
244          )
245          self.assertEqual(&quot;image/png&quot;, upload.mimetype())
246          self.assertEqual(190, upload.size())
247          self.assertEqual(True, upload.resumable())
248          self.assertEqual(500, upload.chunksize())
249          self.assertEqual(b&quot;PNG&quot;, upload.getbytes(1, 3))
250      def test_media_io_base_upload_raises_on_invalid_chunksize(self):
251          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
252          fd = io.BytesIO(f.read())
253          self.assertRaises(
254              InvalidChunkSizeError,
255              MediaIoBaseUpload,
256              fd,
257              &quot;image/png&quot;,
258              chunksize=-2,
259              resumable=True,
260          )
261      def test_media_io_base_upload_streamable(self):
262          fd = io.BytesIO(b&quot;stuff&quot;)
263          upload = MediaIoBaseUpload(
264              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
265          )
266          self.assertEqual(True, upload.has_stream())
267          self.assertEqual(fd, upload.stream())
268      def test_media_io_base_next_chunk_retries(self):
269          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
270          fd = io.BytesIO(f.read())
271          upload = MediaIoBaseUpload(
272              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
273          )
274          http = HttpMockSequence(
275              [
276                  ({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;),
277                  ({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;),
278                  ({&quot;status&quot;: &quot;503&quot;}, &quot;&quot;),
279                  ({&quot;status&quot;: &quot;200&quot;, &quot;location&quot;: &quot;location&quot;}, &quot;&quot;),
280                  ({&quot;status&quot;: &quot;403&quot;}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS),
281                  ({&quot;status&quot;: &quot;403&quot;}, RATE_LIMIT_EXCEEDED_RESPONSE),
282                  ({&quot;status&quot;: &quot;429&quot;}, &quot;&quot;),
283                  ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;),
284              ]
285          )
286          model = JsonModel()
287          uri = &quot;https://www.googleapis.com/someapi/v1/upload/?foo=bar&quot;
288          method = &quot;POST&quot;
289          request = HttpRequest(
290              http, model.response, uri, method=method, headers={}, resumable=upload
291          )
292          sleeptimes = []
293          request._sleep = lambda x: sleeptimes.append(x)
294          request._rand = lambda: 10
295          request.execute(num_retries=3)
296          self.assertEqual([20, 40, 80, 20, 40, 80], sleeptimes)
297      def test_media_io_base_next_chunk_no_retry_403_not_configured(self):
298          fd = io.BytesIO(b&quot;i am png&quot;)
299          upload = MediaIoBaseUpload(
300              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
301          )
302          http = HttpMockSequence(
303              [({&quot;status&quot;: &quot;403&quot;}, NOT_CONFIGURED_RESPONSE), ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)]
304          )
305          model = JsonModel()
306          uri = &quot;https://www.googleapis.com/someapi/v1/upload/?foo=bar&quot;
307          method = &quot;POST&quot;
308          request = HttpRequest(
309              http, model.response, uri, method=method, headers={}, resumable=upload
310          )
311          request._rand = lambda: 1.0
312          request._sleep = mock.MagicMock()
313          with self.assertRaises(HttpError):
314              request.execute(num_retries=3)
315          request._sleep.assert_not_called()
316      def test_media_io_base_empty_file(self):
317          fd = io.BytesIO()
318          upload = MediaIoBaseUpload(
319              fd=fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
320          )
321          http = HttpMockSequence(
322              [
323                  (
324                      {
325                          &quot;status&quot;: &quot;200&quot;,
326                          &quot;location&quot;: &quot;https://www.googleapis.com/someapi/v1/upload?foo=bar&quot;,
327                      },
328                      &quot;{}&quot;,
329                  ),
330                  (
331                      {
332                          &quot;status&quot;: &quot;200&quot;,
333                          &quot;location&quot;: &quot;https://www.googleapis.com/someapi/v1/upload?foo=bar&quot;,
334                      },
335                      &quot;{}&quot;,
336                  ),
337              ]
338          )
339          model = JsonModel()
340          uri = &quot;https://www.googleapis.com/someapi/v1/upload/?foo=bar&quot;
341          method = &quot;POST&quot;
342          request = HttpRequest(
343              http, model.response, uri, method=method, headers={}, resumable=upload
344          )
345          request.execute()
346          self.assertTrue(&quot;Content-Range&quot; not in http.request_sequence[-1][-1])
347          self.assertEqual(&quot;0&quot;, http.request_sequence[-1][-1][&quot;Content-Length&quot;])
348  class TestMediaIoBaseDownload(unittest.TestCase):
349      def setUp(self):
350          http = HttpMock(datafile(&quot;zoo.json&quot;), {&quot;status&quot;: &quot;200&quot;})
351          zoo = build(&quot;zoo&quot;, &quot;v1&quot;, http=http, static_discovery=False)
352          self.request = zoo.animals().get_media(name=&quot;Lion&quot;)
353          self.fd = io.BytesIO()
354      def test_media_io_base_download(self):
355          self.request.http = HttpMockSequence(
356              [
357                  ({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;}, b&quot;123&quot;),
358                  ({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;3-4/5&quot;}, b&quot;45&quot;),
359              ]
360          )
361          self.assertEqual(True, self.request.http.follow_redirects)
362          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
363          self.assertEqual(self.fd, download._fd)
364          self.assertEqual(3, download._chunksize)
365          self.assertEqual(0, download._progress)
366          self.assertEqual(None, download._total_size)
367          self.assertEqual(False, download._done)
368          self.assertEqual(self.request.uri, download._uri)
369          status, done = download.next_chunk()
370          self.assertEqual(self.fd.getvalue(), b&quot;123&quot;)
371          self.assertEqual(False, done)
372          self.assertEqual(3, download._progress)
373          self.assertEqual(5, download._total_size)
374          self.assertEqual(3, status.resumable_progress)
375          status, done = download.next_chunk()
376          self.assertEqual(self.fd.getvalue(), b&quot;12345&quot;)
377          self.assertEqual(True, done)
378          self.assertEqual(5, download._progress)
379          self.assertEqual(5, download._total_size)
380      def test_media_io_base_download_range_request_header(self):
381          self.request.http = HttpMockSequence(
382              [
383                  (
384                      {&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;},
385                      &quot;echo_request_headers_as_json&quot;,
386                  ),
387              ]
388          )
389          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
390          status, done = download.next_chunk()
391          result = json.loads(self.fd.getvalue().decode(&quot;utf-8&quot;))
392          self.assertEqual(result.get(&quot;range&quot;), &quot;bytes=0-2&quot;)
393      def test_media_io_base_download_custom_request_headers(self):
394          self.request.http = HttpMockSequence(
395              [
396                  (
397                      {&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;},
398                      &quot;echo_request_headers_as_json&quot;,
399                  ),
400                  (
401                      {&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;3-4/5&quot;},
402                      &quot;echo_request_headers_as_json&quot;,
403                  ),
404              ]
405          )
406          self.assertEqual(True, self.request.http.follow_redirects)
407          self.request.headers[&quot;Cache-Control&quot;] = &quot;no-store&quot;
408          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
409          self.assertEqual(download._headers.get(&quot;Cache-Control&quot;), &quot;no-store&quot;)
410          status, done = download.next_chunk()
411          result = json.loads(self.fd.getvalue().decode(&quot;utf-8&quot;))
412          self.assertEqual(result.get(&quot;Cache-Control&quot;), &quot;no-store&quot;)
413          download._fd = self.fd = io.BytesIO()
414          status, done = download.next_chunk()
415          result = json.loads(self.fd.getvalue().decode(&quot;utf-8&quot;))
416          self.assertEqual(result.get(&quot;Cache-Control&quot;), &quot;no-store&quot;)
417      def test_media_io_base_download_handle_redirects(self):
418          self.request.http = HttpMockSequence(
419              [
420                  (
421                      {
422                          &quot;status&quot;: &quot;200&quot;,
423                          &quot;content-location&quot;: &quot;https://secure.example.net/lion&quot;,
424                      },
425                      b&quot;&quot;,
426                  ),
427                  ({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;}, b&quot;abc&quot;),
428              ]
429          )
430          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
431          status, done = download.next_chunk()
432          self.assertEqual(&quot;https://secure.example.net/lion&quot;, download._uri)
433      def test_media_io_base_download_handle_4xx(self):
434          self.request.http = HttpMockSequence([({&quot;status&quot;: &quot;400&quot;}, &quot;&quot;)])
435          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
436          try:
437              status, done = download.next_chunk()
438              self.fail(&quot;Should raise an exception&quot;)
439          except HttpError:
440              pass
441          self.request.http = HttpMockSequence(
442              [({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;}, b&quot;123&quot;)]
443          )
444          status, done = download.next_chunk()
445          self.assertEqual(self.fd.getvalue(), b&quot;123&quot;)
446      def test_media_io_base_download_retries_connection_errors(self):
447          self.request.http = HttpMockWithErrors(
448              5, {&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/3&quot;}, b&quot;123&quot;
449          )
450          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
451          download._sleep = lambda _x: 0  # do nothing
452          download._rand = lambda: 10
453          status, done = download.next_chunk(num_retries=5)
454          self.assertEqual(self.fd.getvalue(), b&quot;123&quot;)
455          self.assertEqual(True, done)
456      def test_media_io_base_download_retries_5xx(self):
457          self.request.http = HttpMockSequence(
458              [
459                  ({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;),
460                  ({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;),
461                  ({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;),
462                  ({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-2/5&quot;}, b&quot;123&quot;),
463                  ({&quot;status&quot;: &quot;503&quot;}, &quot;&quot;),
464                  ({&quot;status&quot;: &quot;503&quot;}, &quot;&quot;),
465                  ({&quot;status&quot;: &quot;503&quot;}, &quot;&quot;),
466                  ({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;3-4/5&quot;}, b&quot;45&quot;),
467              ]
468          )
469          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
470          self.assertEqual(self.fd, download._fd)
471          self.assertEqual(3, download._chunksize)
472          self.assertEqual(0, download._progress)
473          self.assertEqual(None, download._total_size)
474          self.assertEqual(False, download._done)
475          self.assertEqual(self.request.uri, download._uri)
476          sleeptimes = []
477          download._sleep = lambda x: sleeptimes.append(x)
478          download._rand = lambda: 10
479          status, done = download.next_chunk(num_retries=3)
480          self.assertEqual([20, 40, 80], sleeptimes)
481          self.assertEqual(self.fd.getvalue(), b&quot;123&quot;)
482          self.assertEqual(False, done)
483          self.assertEqual(3, download._progress)
484          self.assertEqual(5, download._total_size)
485          self.assertEqual(3, status.resumable_progress)
486          del sleeptimes[0 : len(sleeptimes)]
487          status, done = download.next_chunk(num_retries=3)
488          self.assertEqual([20, 40, 80], sleeptimes)
489          self.assertEqual(self.fd.getvalue(), b&quot;12345&quot;)
490          self.assertEqual(True, done)
491          self.assertEqual(5, download._progress)
492          self.assertEqual(5, download._total_size)
493      def test_media_io_base_download_empty_file(self):
494          self.request.http = HttpMockSequence(
495              [({&quot;status&quot;: &quot;200&quot;, &quot;content-range&quot;: &quot;0-0/0&quot;}, b&quot;&quot;)]
496          )
497          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
498          self.assertEqual(self.fd, download._fd)
499          self.assertEqual(0, download._progress)
500          self.assertEqual(None, download._total_size)
501          self.assertEqual(False, download._done)
502          self.assertEqual(self.request.uri, download._uri)
503          status, done = download.next_chunk()
504          self.assertEqual(True, done)
505          self.assertEqual(0, download._progress)
506          self.assertEqual(0, download._total_size)
507          self.assertEqual(0, status.progress())
508      def test_media_io_base_download_empty_file_416_response(self):
509          self.request.http = HttpMockSequence(
510              [({&quot;status&quot;: &quot;416&quot;, &quot;content-range&quot;: &quot;0-0/0&quot;}, b&quot;&quot;)]
511          )
512          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
513          self.assertEqual(self.fd, download._fd)
514          self.assertEqual(0, download._progress)
515          self.assertEqual(None, download._total_size)
516          self.assertEqual(False, download._done)
517          self.assertEqual(self.request.uri, download._uri)
518          status, done = download.next_chunk()
519          self.assertEqual(True, done)
520          self.assertEqual(0, download._progress)
521          self.assertEqual(0, download._total_size)
522          self.assertEqual(0, status.progress())
523      def test_media_io_base_download_unknown_media_size(self):
524          self.request.http = HttpMockSequence([({&quot;status&quot;: &quot;200&quot;}, b&quot;123&quot;)])
525          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
526          self.assertEqual(self.fd, download._fd)
527          self.assertEqual(0, download._progress)
528          self.assertEqual(None, download._total_size)
529          self.assertEqual(False, download._done)
530          self.assertEqual(self.request.uri, download._uri)
531          status, done = download.next_chunk()
532          self.assertEqual(self.fd.getvalue(), b&quot;123&quot;)
533          self.assertEqual(True, done)
534          self.assertEqual(3, download._progress)
535          self.assertEqual(None, download._total_size)
536          self.assertEqual(0, status.progress())
537  EXPECTED = 
538  NO_BODY_EXPECTED = 
539  NO_BODY_EXPECTED_GET = 
540  RESPONSE = 
541  BATCH_RESPONSE = b
542  BATCH_ERROR_RESPONSE = b
543  BATCH_RESPONSE_WITH_401 = b
544  BATCH_SINGLE_RESPONSE = b
545  USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS = 
546  USER_RATE_LIMIT_EXCEEDED_RESPONSE_WITH_STATUS = 
547  RATE_LIMIT_EXCEEDED_RESPONSE = 
548  NOT_CONFIGURED_RESPONSE = 
549  LIST_NOT_CONFIGURED_RESPONSE = 
550  class Callbacks(object):
551      def __init__(self):
552          self.responses = {}
553          self.exceptions = {}
554      def f(self, request_id, response, exception):
555          self.responses[request_id] = response
556          self.exceptions[request_id] = exception
557  class TestHttpRequest(unittest.TestCase):
558      def test_unicode(self):
559          http = HttpMock(datafile(&quot;zoo.json&quot;), headers={&quot;status&quot;: &quot;200&quot;})
560          model = JsonModel()
561          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
562          method = &quot;POST&quot;
563          request = HttpRequest(
564              http,
565              model.response,
566              uri,
567              method=method,
568              body=&quot;{}&quot;,
569              headers={&quot;content-type&quot;: &quot;application/json&quot;},
570          )
571          request.execute()
572          self.assertEqual(uri, http.uri)
573          self.assertEqual(str, type(http.uri))
574          self.assertEqual(method, http.method)
575          self.assertEqual(str, type(http.method))
576      def test_empty_content_type(self):
577          http = HttpMock(None, headers={&quot;status&quot;: 200})
578          uri = &quot;https://www.googleapis.com/someapi/v1/upload/?foo=bar&quot;
579          method = &quot;POST&quot;
580          request = HttpRequest(
581              http, _postproc_none, uri, method=method, headers={&quot;content-type&quot;: &quot;&quot;}
582          )
583          request.execute()
584          self.assertEqual(&quot;&quot;, http.headers.get(&quot;content-type&quot;))
585      def test_no_retry_connection_errors(self):
586          model = JsonModel()
587          request = HttpRequest(
588              HttpMockWithNonRetriableErrors(1, {&quot;status&quot;: &quot;200&quot;}, &#x27;{&quot;foo&quot;: &quot;bar&quot;}&#x27;),
589              model.response,
590              &quot;https://www.example.com/json_api_endpoint&quot;,
591          )
592          request._sleep = lambda _x: 0  # do nothing
593          request._rand = lambda: 10
594          with self.assertRaises(OSError):
595              response = request.execute(num_retries=3)
596      def test_retry_connection_errors_non_resumable(self):
597          model = JsonModel()
598          request = HttpRequest(
599              HttpMockWithErrors(5, {&quot;status&quot;: &quot;200&quot;}, &#x27;{&quot;foo&quot;: &quot;bar&quot;}&#x27;),
600              model.response,
601              &quot;https://www.example.com/json_api_endpoint&quot;,
602          )
603          request._sleep = lambda _x: 0  # do nothing
604          request._rand = lambda: 10
605          response = request.execute(num_retries=5)
606          self.assertEqual({&quot;foo&quot;: &quot;bar&quot;}, response)
607      def test_retry_connection_errors_resumable(self):
608          with open(datafile(&quot;small.png&quot;), &quot;rb&quot;) as small_png_file:
609              small_png_fd = io.BytesIO(small_png_file.read())
610          upload = MediaIoBaseUpload(
611              fd=small_png_fd, mimetype=&quot;image/png&quot;, chunksize=500, resumable=True
612          )
613          model = JsonModel()
614          request = HttpRequest(
615              HttpMockWithErrors(
616                  5, {&quot;status&quot;: &quot;200&quot;, &quot;location&quot;: &quot;location&quot;}, &#x27;{&quot;foo&quot;: &quot;bar&quot;}&#x27;
617              ),
618              model.response,
619              &quot;https://www.example.com/file_upload&quot;,
620              method=&quot;POST&quot;,
621              resumable=upload,
622          )
623          request._sleep = lambda _x: 0  # do nothing
624          request._rand = lambda: 10
625          response = request.execute(num_retries=5)
626          self.assertEqual({&quot;foo&quot;: &quot;bar&quot;}, response)
627      def test_retry(self):
628          num_retries = 6
629          resp_seq = [({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;)] * (num_retries - 4)
630          resp_seq.append(({&quot;status&quot;: &quot;403&quot;}, RATE_LIMIT_EXCEEDED_RESPONSE))
631          resp_seq.append(
632              ({&quot;status&quot;: &quot;403&quot;}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS)
633          )
634          resp_seq.append(
635              ({&quot;status&quot;: &quot;403&quot;}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_WITH_STATUS)
636          )
637          resp_seq.append(({&quot;status&quot;: &quot;429&quot;}, &quot;&quot;))
638          resp_seq.append(({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;))
639          http = HttpMockSequence(resp_seq)
640          model = JsonModel()
641          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
642          method = &quot;POST&quot;
643          request = HttpRequest(
644              http,
645              model.response,
646              uri,
647              method=method,
648              body=&quot;{}&quot;,
649              headers={&quot;content-type&quot;: &quot;application/json&quot;},
650          )
651          sleeptimes = []
652          request._sleep = lambda x: sleeptimes.append(x)
653          request._rand = lambda: 10
654          request.execute(num_retries=num_retries)
655          self.assertEqual(num_retries, len(sleeptimes))
656          for retry_num in range(num_retries):
657              self.assertEqual(10 * 2 ** (retry_num + 1), sleeptimes[retry_num])
658      def test_no_retry_succeeds(self):
659          num_retries = 5
660          resp_seq = [({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)] * (num_retries)
661          http = HttpMockSequence(resp_seq)
662          model = JsonModel()
663          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
664          method = &quot;POST&quot;
665          request = HttpRequest(
666              http,
667              model.response,
668              uri,
669              method=method,
670              body=&quot;{}&quot;,
671              headers={&quot;content-type&quot;: &quot;application/json&quot;},
672          )
673          sleeptimes = []
674          request._sleep = lambda x: sleeptimes.append(x)
675          request._rand = lambda: 10
676          request.execute(num_retries=num_retries)
677          self.assertEqual(0, len(sleeptimes))
678      def test_no_retry_fails_fast(self):
679          http = HttpMockSequence([({&quot;status&quot;: &quot;500&quot;}, &quot;&quot;), ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)])
680          model = JsonModel()
681          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
682          method = &quot;POST&quot;
683          request = HttpRequest(
684              http,
685              model.response,
686              uri,
687              method=method,
688              body=&quot;{}&quot;,
689              headers={&quot;content-type&quot;: &quot;application/json&quot;},
690          )
691          request._rand = lambda: 1.0
692          request._sleep = mock.MagicMock()
693          with self.assertRaises(HttpError):
694              request.execute()
695          request._sleep.assert_not_called()
696      def test_no_retry_403_not_configured_fails_fast(self):
697          http = HttpMockSequence(
698              [({&quot;status&quot;: &quot;403&quot;}, NOT_CONFIGURED_RESPONSE), ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)]
699          )
700          model = JsonModel()
701          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
702          method = &quot;POST&quot;
703          request = HttpRequest(
704              http,
705              model.response,
706              uri,
707              method=method,
708              body=&quot;{}&quot;,
709              headers={&quot;content-type&quot;: &quot;application/json&quot;},
710          )
711          request._rand = lambda: 1.0
712          request._sleep = mock.MagicMock()
713          with self.assertRaises(HttpError):
714              request.execute()
715          request._sleep.assert_not_called()
716      def test_no_retry_403_fails_fast(self):
717          http = HttpMockSequence([({&quot;status&quot;: &quot;403&quot;}, &quot;&quot;), ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)])
718          model = JsonModel()
719          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
720          method = &quot;POST&quot;
721          request = HttpRequest(
722              http,
723              model.response,
724              uri,
725              method=method,
726              body=&quot;{}&quot;,
727              headers={&quot;content-type&quot;: &quot;application/json&quot;},
728          )
729          request._rand = lambda: 1.0
730          request._sleep = mock.MagicMock()
731          with self.assertRaises(HttpError):
732              request.execute()
733          request._sleep.assert_not_called()
734      def test_no_retry_401_fails_fast(self):
735          http = HttpMockSequence([({&quot;status&quot;: &quot;401&quot;}, &quot;&quot;), ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;)])
736          model = JsonModel()
737          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
738          method = &quot;POST&quot;
739          request = HttpRequest(
740              http,
741              model.response,
742              uri,
743              method=method,
744              body=&quot;{}&quot;,
745              headers={&quot;content-type&quot;: &quot;application/json&quot;},
746          )
747          request._rand = lambda: 1.0
748          request._sleep = mock.MagicMock()
749          with self.assertRaises(HttpError):
750              request.execute()
751          request._sleep.assert_not_called()
752      def test_no_retry_403_list_fails(self):
753          http = HttpMockSequence(
754              [
755                  ({&quot;status&quot;: &quot;403&quot;}, LIST_NOT_CONFIGURED_RESPONSE),
756                  ({&quot;status&quot;: &quot;200&quot;}, &quot;{}&quot;),
757              ]
758          )
759          model = JsonModel()
760          uri = &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;
761          method = &quot;POST&quot;
762          request = HttpRequest(
763              http,
764              model.response,
765              uri,
766              method=method,
767              body=&quot;{}&quot;,
768              headers={&quot;content-type&quot;: &quot;application/json&quot;},
769          )
770          request._rand = lambda: 1.0
771          request._sleep = mock.MagicMock()
772          with self.assertRaises(HttpError):
773              request.execute()
774          request._sleep.assert_not_called()
775      def test_null_postproc(self):
776          resp, content = HttpRequest.null_postproc(&quot;foo&quot;, &quot;bar&quot;)
777          self.assertEqual(resp, &quot;foo&quot;)
778          self.assertEqual(content, &quot;bar&quot;)
779  class TestBatch(unittest.TestCase):
780      def setUp(self):
781          model = JsonModel()
782          self.request1 = HttpRequest(
783              None,
784              model.response,
785              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
786              method=&quot;POST&quot;,
787              body=&quot;{}&quot;,
788              headers={&quot;content-type&quot;: &quot;application/json&quot;},
789          )
790          self.request2 = HttpRequest(
791              None,
792              model.response,
793              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
794              method=&quot;GET&quot;,
795              body=&quot;&quot;,
796              headers={&quot;content-type&quot;: &quot;application/json&quot;},
797          )
798      def test_id_to_from_content_id_header(self):
799          batch = BatchHttpRequest()
800          self.assertEqual(&quot;12&quot;, batch._header_to_id(batch._id_to_header(&quot;12&quot;)))
801      def test_invalid_content_id_header(self):
802          batch = BatchHttpRequest()
803          self.assertRaises(BatchError, batch._header_to_id, &quot;[foo+x]&quot;)
804          self.assertRaises(BatchError, batch._header_to_id, &quot;foo+1&quot;)
805          self.assertRaises(BatchError, batch._header_to_id, &quot;&lt;foo&gt;&quot;)
806      def test_serialize_request(self):
807          batch = BatchHttpRequest()
808          request = HttpRequest(
809              None,
810              None,
811              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
812              method=&quot;POST&quot;,
813              body=&quot;{}&quot;,
814              headers={&quot;content-type&quot;: &quot;application/json&quot;},
815              methodId=None,
816              resumable=None,
817          )
818          s = batch._serialize_request(request).splitlines()
819          self.assertEqual(EXPECTED.splitlines(), s)
820      def test_serialize_request_media_body(self):
821          batch = BatchHttpRequest()
822          f = open(datafile(&quot;small.png&quot;), &quot;rb&quot;)
823          body = f.read()
824          f.close()
825          request = HttpRequest(
826              None,
827              None,
828              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
829              method=&quot;POST&quot;,
830              body=body,
831              headers={&quot;content-type&quot;: &quot;application/json&quot;},
832              methodId=None,
833              resumable=None,
834          )
835          s = batch._serialize_request(request).splitlines()
836      def test_serialize_request_no_body(self):
837          batch = BatchHttpRequest()
838          request = HttpRequest(
839              None,
840              None,
841              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
842              method=&quot;POST&quot;,
843              body=b&quot;&quot;,
844              headers={&quot;content-type&quot;: &quot;application/json&quot;},
845              methodId=None,
846              resumable=None,
847          )
848          s = batch._serialize_request(request).splitlines()
849          self.assertEqual(NO_BODY_EXPECTED.splitlines(), s)
850      def test_serialize_get_request_no_body(self):
851          batch = BatchHttpRequest()
852          request = HttpRequest(
853              None,
854              None,
855              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
856              method=&quot;GET&quot;,
857              body=None,
858              headers={&quot;content-type&quot;: &quot;application/json&quot;},
859              methodId=None,
860              resumable=None,
861          )
862          s = batch._serialize_request(request).splitlines()
863          self.assertEqual(NO_BODY_EXPECTED_GET.splitlines(), s)
864      def test_deserialize_response(self):
865          batch = BatchHttpRequest()
866          resp, content = batch._deserialize_response(RESPONSE)
867          self.assertEqual(200, resp.status)
868          self.assertEqual(&quot;OK&quot;, resp.reason)
869          self.assertEqual(11, resp.version)
870          self.assertEqual(&#x27;{&quot;answer&quot;: 42}&#x27;, content)
871      def test_new_id(self):
872          batch = BatchHttpRequest()
873          id_ = batch._new_id()
874          self.assertEqual(&quot;1&quot;, id_)
875          id_ = batch._new_id()
876          self.assertEqual(&quot;2&quot;, id_)
877          batch.add(self.request1, request_id=&quot;3&quot;)
878          id_ = batch._new_id()
879          self.assertEqual(&quot;4&quot;, id_)
880      def test_add(self):
881          batch = BatchHttpRequest()
882          batch.add(self.request1, request_id=&quot;1&quot;)
883          self.assertRaises(KeyError, batch.add, self.request1, request_id=&quot;1&quot;)
884      def test_add_fail_for_over_limit(self):
885          from googleapiclient.http import MAX_BATCH_LIMIT
886          batch = BatchHttpRequest()
887          for i in range(0, MAX_BATCH_LIMIT):
888              batch.add(
889                  HttpRequest(
890                      None,
891                      None,
892                      &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
893                      method=&quot;POST&quot;,
894                      body=&quot;{}&quot;,
895                      headers={&quot;content-type&quot;: &quot;application/json&quot;},
896                  )
897              )
898          self.assertRaises(BatchError, batch.add, self.request1)
899      def test_add_fail_for_resumable(self):
900          batch = BatchHttpRequest()
901          upload = MediaFileUpload(datafile(&quot;small.png&quot;), chunksize=500, resumable=True)
902          self.request1.resumable = upload
903          with self.assertRaises(BatchError) as batch_error:
904              batch.add(self.request1, request_id=&quot;1&quot;)
905          str(batch_error.exception)
906      def test_execute_empty_batch_no_http(self):
907          batch = BatchHttpRequest()
908          ret = batch.execute()
909          self.assertEqual(None, ret)
910      def test_execute(self):
911          batch = BatchHttpRequest()
912          callbacks = Callbacks()
913          batch.add(self.request1, callback=callbacks.f)
914          batch.add(self.request2, callback=callbacks.f)
915          http = HttpMockSequence(
916              [
917                  (
918                      {
919                          &quot;status&quot;: &quot;200&quot;,
920                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
921                      },
922                      BATCH_RESPONSE,
923                  )
924              ]
925          )
926          batch.execute(http=http)
927          self.assertEqual({&quot;foo&quot;: 42}, callbacks.responses[&quot;1&quot;])
928          self.assertEqual(None, callbacks.exceptions[&quot;1&quot;])
929          self.assertEqual({&quot;baz&quot;: &quot;qux&quot;}, callbacks.responses[&quot;2&quot;])
930          self.assertEqual(None, callbacks.exceptions[&quot;2&quot;])
931      def test_execute_request_body(self):
932          batch = BatchHttpRequest()
933          batch.add(self.request1)
934          batch.add(self.request2)
935          http = HttpMockSequence(
936              [
937                  (
938                      {
939                          &quot;status&quot;: &quot;200&quot;,
940                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
941                      },
942                      &quot;echo_request_body&quot;,
943                  )
944              ]
945          )
946          try:
947              batch.execute(http=http)
948              self.fail(&quot;Should raise exception&quot;)
949          except BatchError as e:
950              boundary, _ = e.content.split(None, 1)
951              self.assertEqual(&quot;--&quot;, boundary[:2])
952              parts = e.content.split(boundary)
953              self.assertEqual(4, len(parts))
954              self.assertEqual(&quot;&quot;, parts[0])
955              self.assertEqual(&quot;--&quot;, parts[3].rstrip())
956              header = parts[1].splitlines()[1]
957              self.assertEqual(&quot;Content-Type: application/http&quot;, header)
958      def test_execute_request_body_with_custom_long_request_ids(self):
959          batch = BatchHttpRequest()
960          batch.add(self.request1, request_id=&quot;abc&quot; * 20)
961          batch.add(self.request2, request_id=&quot;def&quot; * 20)
962          http = HttpMockSequence(
963              [
964                  (
965                      {
966                          &quot;status&quot;: &quot;200&quot;,
967                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
968                      },
969                      &quot;echo_request_body&quot;,
970                  )
971              ]
972          )
973          try:
974              batch.execute(http=http)
975              self.fail(&quot;Should raise exception&quot;)
976          except BatchError as e:
977              boundary, _ = e.content.split(None, 1)
978              self.assertEqual(&quot;--&quot;, boundary[:2])
979              parts = e.content.split(boundary)
980              self.assertEqual(4, len(parts))
981              self.assertEqual(&quot;&quot;, parts[0])
982              self.assertEqual(&quot;--&quot;, parts[3].rstrip())
983              for partindex, request_id in ((1, &quot;abc&quot; * 20), (2, &quot;def&quot; * 20)):
984                  lines = parts[partindex].splitlines()
985                  for n, line in enumerate(lines):
986                      if line.startswith(&quot;Content-ID:&quot;):
987                          self.assertTrue(line.endswith(&quot;+&quot;), line)
988                          header_continuation = lines[n + 1]
989                          self.assertEqual(
990                              header_continuation,
991                              &quot; %s&gt;&quot; % request_id,
992                              header_continuation,
993                          )
994      def test_execute_initial_refresh_oauth2(self):
995          batch = BatchHttpRequest()
996          callbacks = Callbacks()
997          cred = MockCredentials(&quot;Foo&quot;, expired=True)
998          http = HttpMockSequence(
999              [
1000                  (
1001                      {
1002                          &quot;status&quot;: &quot;200&quot;,
1003                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1004                      },
1005                      BATCH_SINGLE_RESPONSE,
1006                  )
1007              ]
1008          )
1009          cred.authorize(http)
1010          batch.add(self.request1, callback=callbacks.f)
1011          batch.execute(http=http)
1012          self.assertEqual({&quot;foo&quot;: 42}, callbacks.responses[&quot;1&quot;])
1013          self.assertIsNone(callbacks.exceptions[&quot;1&quot;])
1014          self.assertEqual(1, cred._refreshed)
1015          self.assertEqual(1, cred._authorized)
1016          self.assertEqual(1, cred._applied)
1017      def test_execute_refresh_and_retry_on_401(self):
1018          batch = BatchHttpRequest()
1019          callbacks = Callbacks()
1020          cred_1 = MockCredentials(&quot;Foo&quot;)
1021          cred_2 = MockCredentials(&quot;Bar&quot;)
1022          http = HttpMockSequence(
1023              [
1024                  (
1025                      {
1026                          &quot;status&quot;: &quot;200&quot;,
1027                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1028                      },
1029                      BATCH_RESPONSE_WITH_401,
1030                  ),
1031                  (
1032                      {
1033                          &quot;status&quot;: &quot;200&quot;,
1034                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1035                      },
1036                      BATCH_SINGLE_RESPONSE,
1037                  ),
1038              ]
1039          )
1040          creds_http_1 = HttpMockSequence([])
1041          cred_1.authorize(creds_http_1)
1042          creds_http_2 = HttpMockSequence([])
1043          cred_2.authorize(creds_http_2)
1044          self.request1.http = creds_http_1
1045          self.request2.http = creds_http_2
1046          batch.add(self.request1, callback=callbacks.f)
1047          batch.add(self.request2, callback=callbacks.f)
1048          batch.execute(http=http)
1049          self.assertEqual({&quot;foo&quot;: 42}, callbacks.responses[&quot;1&quot;])
1050          self.assertEqual(None, callbacks.exceptions[&quot;1&quot;])
1051          self.assertEqual({&quot;baz&quot;: &quot;qux&quot;}, callbacks.responses[&quot;2&quot;])
1052          self.assertEqual(None, callbacks.exceptions[&quot;2&quot;])
1053          self.assertEqual(1, cred_1._refreshed)
1054          self.assertEqual(0, cred_2._refreshed)
1055          self.assertEqual(1, cred_1._authorized)
1056          self.assertEqual(1, cred_2._authorized)
1057          self.assertEqual(1, cred_2._applied)
1058          self.assertEqual(2, cred_1._applied)
1059      def test_http_errors_passed_to_callback(self):
1060          batch = BatchHttpRequest()
1061          callbacks = Callbacks()
1062          cred_1 = MockCredentials(&quot;Foo&quot;)
1063          cred_2 = MockCredentials(&quot;Bar&quot;)
1064          http = HttpMockSequence(
1065              [
1066                  (
1067                      {
1068                          &quot;status&quot;: &quot;200&quot;,
1069                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1070                      },
1071                      BATCH_RESPONSE_WITH_401,
1072                  ),
1073                  (
1074                      {
1075                          &quot;status&quot;: &quot;200&quot;,
1076                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1077                      },
1078                      BATCH_RESPONSE_WITH_401,
1079                  ),
1080              ]
1081          )
1082          creds_http_1 = HttpMockSequence([])
1083          cred_1.authorize(creds_http_1)
1084          creds_http_2 = HttpMockSequence([])
1085          cred_2.authorize(creds_http_2)
1086          self.request1.http = creds_http_1
1087          self.request2.http = creds_http_2
1088          batch.add(self.request1, callback=callbacks.f)
1089          batch.add(self.request2, callback=callbacks.f)
1090          batch.execute(http=http)
1091          self.assertEqual(None, callbacks.responses[&quot;1&quot;])
1092          self.assertEqual(401, callbacks.exceptions[&quot;1&quot;].resp.status)
1093          self.assertEqual(
1094              &quot;Authorization Required&quot;, callbacks.exceptions[&quot;1&quot;].resp.reason
1095          )
1096          self.assertEqual({&quot;baz&quot;: &quot;qux&quot;}, callbacks.responses[&quot;2&quot;])
1097          self.assertEqual(None, callbacks.exceptions[&quot;2&quot;])
1098      def test_execute_global_callback(self):
1099          callbacks = Callbacks()
1100          batch = BatchHttpRequest(callback=callbacks.f)
1101          batch.add(self.request1)
1102          batch.add(self.request2)
1103          http = HttpMockSequence(
1104              [
1105                  (
1106                      {
1107                          &quot;status&quot;: &quot;200&quot;,
1108                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1109                      },
1110                      BATCH_RESPONSE,
1111                  )
1112              ]
1113          )
1114          batch.execute(http=http)
1115          self.assertEqual({&quot;foo&quot;: 42}, callbacks.responses[&quot;1&quot;])
1116          self.assertEqual({&quot;baz&quot;: &quot;qux&quot;}, callbacks.responses[&quot;2&quot;])
1117      def test_execute_batch_http_error(self):
1118          callbacks = Callbacks()
1119          batch = BatchHttpRequest(callback=callbacks.f)
1120          batch.add(self.request1)
1121          batch.add(self.request2)
1122          http = HttpMockSequence(
1123              [
1124                  (
1125                      {
1126                          &quot;status&quot;: &quot;200&quot;,
1127                          &quot;content-type&quot;: &#x27;multipart/mixed; boundary=&quot;batch_foobarbaz&quot;&#x27;,
1128                      },
1129                      BATCH_ERROR_RESPONSE,
1130                  )
1131              ]
1132          )
1133          batch.execute(http=http)
1134          self.assertEqual({&quot;foo&quot;: 42}, callbacks.responses[&quot;1&quot;])
1135          expected = (
1136              &quot;&lt;HttpError 403 when requesting &quot;
1137              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar returned &quot;
1138              &#x27;&quot;Access Not Configured&quot;. &#x27;
1139              &quot;Details: \&quot;[{&#x27;domain&#x27;: &#x27;usageLimits&#x27;, &#x27;reason&#x27;: &#x27;accessNotConfigured&#x27;, &#x27;message&#x27;: &#x27;Access Not Configured&#x27;, &#x27;debugInfo&#x27;: &#x27;QuotaState: BLOCKED&#x27;}]\&quot;&gt;&quot;
1140          )
1141          self.assertEqual(expected, str(callbacks.exceptions[&quot;2&quot;]))
1142  class TestRequestUriTooLong(unittest.TestCase):
1143      def test_turn_get_into_post(self):
1144          def _postproc(resp, content):
1145              return content
1146          http = HttpMockSequence(
1147              [
1148                  ({&quot;status&quot;: &quot;200&quot;}, &quot;echo_request_body&quot;),
1149                  ({&quot;status&quot;: &quot;200&quot;}, &quot;echo_request_headers&quot;),
1150              ]
1151          )
1152          query = {&quot;q&quot;: &quot;a&quot; * MAX_URI_LENGTH + &quot;?&amp;&quot;}
1153          req = HttpRequest(
1154              http,
1155              _postproc,
1156              &quot;http://example.com?&quot; + urllib.parse.urlencode(query),
1157              method=&quot;GET&quot;,
1158              body=None,
1159              headers={},
1160              methodId=&quot;foo&quot;,
1161              resumable=None,
1162          )
1163          response = req.execute()
1164          self.assertEqual(b&quot;q=&quot; + b&quot;a&quot; * MAX_URI_LENGTH + b&quot;%3F%26&quot;, response)
1165          response = req.execute()
1166          self.assertEqual(&quot;GET&quot;, response[&quot;x-http-method-override&quot;])
1167          self.assertEqual(str(MAX_URI_LENGTH + 8), response[&quot;content-length&quot;])
1168          self.assertEqual(&quot;application/x-www-form-urlencoded&quot;, response[&quot;content-type&quot;])
1169  class TestStreamSlice(unittest.TestCase):
1170      def setUp(self):
1171          self.stream = io.BytesIO(b&quot;0123456789&quot;)
1172      def test_read(self):
1173          s = _StreamSlice(self.stream, 0, 4)
1174          self.assertEqual(b&quot;&quot;, s.read(0))
1175          self.assertEqual(b&quot;0&quot;, s.read(1))
1176          self.assertEqual(b&quot;123&quot;, s.read())
1177      def test_read_too_much(self):
1178          s = _StreamSlice(self.stream, 1, 4)
1179          self.assertEqual(b&quot;1234&quot;, s.read(6))
1180      def test_read_all(self):
1181          s = _StreamSlice(self.stream, 2, 1)
1182          self.assertEqual(b&quot;2&quot;, s.read(-1))
1183  class TestResponseCallback(unittest.TestCase):
1184      def test_ensure_response_callback(self):
1185          m = JsonModel()
1186          request = HttpRequest(
1187              None,
1188              m.response,
1189              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
1190              method=&quot;POST&quot;,
1191              body=&quot;{}&quot;,
1192              headers={&quot;content-type&quot;: &quot;application/json&quot;},
1193          )
1194          h = HttpMockSequence([({&quot;status&quot;: 200}, &quot;{}&quot;)])
1195          responses = []
1196          def _on_response(resp, responses=responses):
1197              responses.append(resp)
1198          request.add_response_callback(_on_response)
1199          request.execute(http=h)
1200          self.assertEqual(1, len(responses))
1201  class TestHttpMock(unittest.TestCase):
1202      def test_default_response_headers(self):
1203          http = HttpMock(datafile(&quot;zoo.json&quot;))
1204          resp, content = http.request(&quot;http://example.com&quot;)
1205          self.assertEqual(resp.status, 200)
1206      def test_error_response(self):
1207          http = HttpMock(datafile(&quot;bad_request.json&quot;), {&quot;status&quot;: &quot;400&quot;})
1208          model = JsonModel()
1209          request = HttpRequest(
1210              http,
1211              model.response,
1212              &quot;https://www.googleapis.com/someapi/v1/collection/?foo=bar&quot;,
1213              method=&quot;GET&quot;,
1214              headers={},
1215          )
1216          self.assertRaises(HttpError, request.execute)
1217  class TestHttpBuild(unittest.TestCase):
1218      original_socket_default_timeout = None
1219      @classmethod
1220      def setUpClass(cls):
<span onclick='openModal()' class='match'>1221          cls.original_socket_default_timeout = socket.getdefaulttimeout()
1222      @classmethod
1223      def tearDownClass(cls):
1224          socket.setdefaulttimeout(cls.original_socket_default_timeout)
</span>1225      def test_build_http_sets_default_timeout_if_none_specified(self):
1226          socket.setdefaulttimeout(None)
1227          http = build_http()
1228          self.assertIsInstance(http.timeout, int)
1229          self.assertGreater(http.timeout, 0)
1230      def test_build_http_default_timeout_can_be_overridden(self):
1231          socket.setdefaulttimeout(1.5)
1232          http = build_http()
1233          self.assertAlmostEqual(http.timeout, 1.5, delta=0.001)
1234      def test_build_http_default_timeout_can_be_set_to_zero(self):
1235          socket.setdefaulttimeout(0)
1236          http = build_http()
1237          self.assertEqual(http.timeout, 0)
1238      def test_build_http_default_308_is_excluded_as_redirect(self):
1239          http = build_http()
1240          self.assertTrue(308 not in http.redirect_codes)
1241  if __name__ == &quot;__main__&quot;:
1242      logging.getLogger().setLevel(logging.ERROR)
1243      unittest.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_http.py</div>
                </div>
                <div class="column column_space"><pre><code>1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
</pre></code></div>
                <div class="column column_space"><pre><code>1221          cls.original_socket_default_timeout = socket.getdefaulttimeout()
1222      @classmethod
1223      def tearDownClass(cls):
1224          socket.setdefaulttimeout(cls.original_socket_default_timeout)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    