
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.459183673469388%, Tokens: 9</h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</h3>
            <pre><code>1  import binascii
2  import sys
3  from bitstring import BitArray, BitStream, CreationError
4  import esptool
5  from . import util
6  class CheckArgValue(object):
7      def __init__(self, efuses, name):
8          self.efuses = efuses
9          self.name = name
10      def __call__(self, new_value_str):
11          def check_arg_value(efuse, new_value):
12              if efuse.efuse_type.startswith("bool"):
13                  new_value = 1 if new_value is None else int(new_value, 0)
14                  if new_value != 1:
15                      raise esptool.FatalError(
16                          "New value is not accepted for efuse '{}' "
17                          "(will always burn 0->1), given value={}".format(
18                              efuse.name, new_value
19                          )
20                      )
21              elif efuse.efuse_type.startswith(("int", "uint")):
22                  if efuse.efuse_class == "bitcount":
23                      if new_value is None:
24                          old_value = efuse.get_raw()
25                          new_value = old_value
26                          bit = 1
27                          while new_value == old_value:
28                              new_value = bit | old_value
29                              bit <<= 1
30                      else:
31                          new_value = int(new_value, 0)
32                  else:
33                      if new_value is None:
34                          raise esptool.FatalError(
35                              "New value required for efuse '{}' (given None)".format(
36                                  efuse.name
37                              )
38                          )
39                      new_value = int(new_value, 0)
40                      if new_value == 0:
41                          raise esptool.FatalError(
42                              "New value should not be 0 for '{}' "
43                              "(given value= {})".format(efuse.name, new_value)
44                          )
45              elif efuse.efuse_type.startswith("bytes"):
46                  if new_value is None:
47                      raise esptool.FatalError(
48                          "New value required for efuse '{}' "
49                          "(given None)".format(efuse.name)
50                      )
51                  if len(new_value) * 8 != efuse.bitarray.len:
52                      raise esptool.FatalError(
53                          "The length of efuse '{}' ({} bits) "
54                          "(given len of the new value= {} bits)".format(
55                              efuse.name, efuse.bitarray.len, len(new_value) * 8
56                          )
57                      )
58              else:
59                  raise esptool.FatalError(
60                      "The '{}' type for the '{}' efuse is not supported yet.".format(
61                          efuse.efuse_type, efuse.name
62                      )
63                  )
64              return new_value
65          efuse = self.efuses[self.name]
66          new_value = efuse.check_format(new_value_str)
67          return check_arg_value(efuse, new_value)
68  class EfuseProtectBase(object):
69      def get_read_disable_mask(self, blk_part=None):
70          mask = 0
71          if isinstance(self.read_disable_bit, list):
72              if blk_part is None:
73                  for i in self.read_disable_bit:
74                      mask |= 1 << i
75              else:
76                  mask |= 1 << self.read_disable_bit[blk_part]
77          else:
78              mask = 1 << self.read_disable_bit
79          return mask
80      def get_count_read_disable_bits(self):
81          return bin(self.get_read_disable_mask()).count("1")
82      def is_readable(self, blk_part=None):
83          num_bit = self.read_disable_bit
84          if num_bit is None:
85              return True  # read cannot be disabled
86          return (self.parent["RD_DIS"].get() & self.get_read_disable_mask(blk_part)) == 0
87      def disable_read(self):
88          num_bit = self.read_disable_bit
89          if num_bit is None:
90              raise esptool.FatalError("This efuse cannot be read-disabled")
91          if not self.parent["RD_DIS"].is_writeable():
92              raise esptool.FatalError(
93                  "This efuse cannot be read-disabled due the to RD_DIS field is "
94                  "already write-disabled"
95              )
96          self.parent["RD_DIS"].save(self.get_read_disable_mask())
97      def is_writeable(self):
98          num_bit = self.write_disable_bit
99          if num_bit is None:
100              return True  # write cannot be disabled
101          return (self.parent["WR_DIS"].get() & (1 << num_bit)) == 0
102      def disable_write(self):
103          num_bit = self.write_disable_bit
104          if not self.parent["WR_DIS"].is_writeable():
105              raise esptool.FatalError(
106                  "This efuse cannot be write-disabled due to the WR_DIS field is "
107                  "already write-disabled"
108              )
109          self.parent["WR_DIS"].save(1 << num_bit)
110      def check_wr_rd_protect(self):
111          if not self.is_readable():
112              error_msg = "\t{} is read-protected.".format(self.name)
113              "The written value can not be read, the efuse/block looks as all 0.\n"
114              error_msg += "\tBurn in this case may damage an already written value."
115              self.parent.print_error_msg(error_msg)
116          if not self.is_writeable():
117              error_msg = "\t{} is write-protected. Burn is not possible.".format(
118                  self.name
119              )
120              self.parent.print_error_msg(error_msg)
121  class EfuseBlockBase(EfuseProtectBase):
122      def __init__(self, parent, param, skip_read=False):
123          self.parent = parent
124          self.name = param.name
125          self.alias = param.alias
126          self.id = param.id
127          self.rd_addr = param.rd_addr
128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
131          self.len = param.len
132          self.key_purpose_name = param.key_purpose
133          bit_block_len = self.get_block_len() * 8
134          self.bitarray = BitStream(bit_block_len)
135          self.bitarray.set(0)
136          self.wr_bitarray = BitStream(bit_block_len)
137          self.wr_bitarray.set(0)
138          self.fail = False
139          self.num_errors = 0
140          if self.id == 0:
141              self.err_bitarray = BitStream(bit_block_len)
142              self.err_bitarray.set(0)
143          else:
144              self.err_bitarray = None
145          if not skip_read:
146              self.read()
147      def get_block_len(self):
148          coding_scheme = self.get_coding_scheme()
149          if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
150              return self.len * 4
151          elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
152              return (self.len * 3 // 4) * 4
153          elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
154              return self.len * 4
155          else:
156              raise esptool.FatalError(
157                  "Coding scheme (%d) not supported" % (coding_scheme)
158              )
159      def get_coding_scheme(self):
160          if self.id == 0:
161              return self.parent.REGS.CODING_SCHEME_NONE
162          else:
163              return self.parent.coding_scheme
164      def get_raw(self, from_read=True):
165          if from_read:
166              return self.bitarray.bytes
167          else:
168              return self.wr_bitarray.bytes
169      def get(self, from_read=True):
170          self.get_bitstring(from_read=from_read)
171      def get_bitstring(self, from_read=True):
172          if from_read:
173              return self.bitarray
174          else:
175              return self.wr_bitarray
176      def convert_to_bitstring(self, new_data):
177          if isinstance(new_data, BitArray):
178              return new_data
179          else:
180              return BitArray(bytes=new_data, length=len(new_data) * 8)
181      def get_words(self):
182          def get_offsets(self):
183              return [x + self.rd_addr for x in range(0, self.get_block_len(), 4)]
184          return [self.parent.read_reg(offs) for offs in get_offsets(self)]
185      def read(self):
186          words = self.get_words()
187          data = BitArray()
188          for word in reversed(words):
189              data.append("uint:32=%d" % word)
190          self.bitarray.overwrite(data, pos=0)
191          self.print_block(self.bitarray, "read_regs")
192      def print_block(self, bit_string, comment, debug=False):
193          if self.parent.debug or debug:
194              bit_string.pos = 0
195              print(
196                  "%-15s (%-16s) [%-2d] %s:"
197                  % (self.name, " ".join(self.alias)[:16], self.id, comment),
198                  " ".join(
199                      [
200                          "%08x" % word
201                          for word in bit_string.readlist(
202                              "%d*uint:32" % (bit_string.len / 32)
203                          )[::-1]
204                      ]
205                  ),
206              )
207      def check_wr_data(self):
208          wr_data = self.wr_bitarray
209          if wr_data.all(False):
210              if self.parent.debug:
211                  print("[{:02}] {:20} nothing to burn".format(self.id, self.name))
212              return False
213          if len(wr_data.bytes) != len(self.bitarray.bytes):
214              raise esptool.FatalError(
215                  "Data does not fit: the block%d size is %d bytes, data is %d bytes"
216                  % (self.id, len(self.bitarray.bytes), len(wr_data.bytes))
217              )
218          self.check_wr_rd_protect()
<span onclick='openModal()' class='match'>219          if self.get_bitstring().all(False):
220              print(
221                  "[{:02}] {:20} is empty, will burn the new value".format(
222                      self.id, self.name
</span>223                  )
224              )
225          else:
226              if self.get_bitstring() == wr_data:
227                  print(
228                      "[{:02}] {:20} is already written the same value, "
229                      "continue with EMPTY_BLOCK".format(self.id, self.name)
230                  )
231                  wr_data.set(0)
232              else:
233                  print("[{:02}] {:20} is not empty".format(self.id, self.name))
234                  print("\t(written ):", self.get_bitstring())
235                  print("\t(to write):", wr_data)
236                  mask = self.get_bitstring() & wr_data
237                  if mask == wr_data:
238                      print(
239                          "\tAll wr_data bits are set in the written block, "
240                          "continue with EMPTY_BLOCK."
241                      )
242                      wr_data.set(0)
243                  else:
244                      coding_scheme = self.get_coding_scheme()
245                      if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
246                          print("\t(coding scheme = NONE)")
247                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
248                          print("\t(coding scheme = RS)")
249                          error_msg = (
250                              "\tBurn into %s is forbidden "
251                              "(RS coding scheme does not allow this)." % (self.name)
252                          )
253                          self.parent.print_error_msg(error_msg)
254                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
255                          print("\t(coding scheme = 3/4)")
256                          data_can_not_be_burn = False
257                          for i in range(0, self.get_bitstring().len, 6 * 8):
258                              rd_chunk = self.get_bitstring()[i : i + 6 * 8 :]
259                              wr_chunk = wr_data[i : i + 6 * 8 :]
260                              if rd_chunk.any(True):
261                                  if wr_chunk.any(True):
262                                      print(
263                                          "\twritten chunk [%d] and wr_chunk "
264                                          "are not empty. " % (i // (6 * 8)),
265                                          end="",
266                                      )
267                                      if rd_chunk == wr_chunk:
268                                          print(
269                                              "wr_chunk == rd_chunk. "
270                                              "Countinue with empty chunk."
271                                          )
272                                          wr_data[i : i + 6 * 8 :].set(0)
273                                      else:
274                                          print("wr_chunk != rd_chunk. Can not burn.")
275                                          print("\twritten ", rd_chunk)
276                                          print("\tto write", wr_chunk)
277                                          data_can_not_be_burn = True
278                          if data_can_not_be_burn:
279                              error_msg = (
280                                  "\tBurn into %s is forbidden "
281                                  "(3/4 coding scheme does not allow this)." % (self.name)
282                              )
283                              self.parent.print_error_msg(error_msg)
284                      else:
285                          raise esptool.FatalError(
286                              "The coding scheme ({}) is not supported".format(
287                                  coding_scheme
288                              )
289                          )
290      def save(self, new_data):
291          data = BitStream(bytes=new_data[::-1], length=len(new_data) * 8)
292          if self.parent.debug:
293              print(
294                  "\twritten : {} ->\n\tto write: {}".format(self.get_bitstring(), data)
295              )
296          self.wr_bitarray.overwrite(self.wr_bitarray | data, pos=0)
297      def burn_words(self, words):
298          for burns in range(3):
299              self.parent.efuse_controller_setup()
300              if self.parent.debug:
301                  print("Write data to BLOCK%d" % (self.id))
302              write_reg_addr = self.wr_addr
303              for word in words:
304                  if self.parent.debug:
305                      print("Addr 0x%08x, data=0x%08x" % (write_reg_addr, word))
306                  self.parent.write_reg(write_reg_addr, word)
307                  write_reg_addr += 4
308              self.parent.write_efuses(self.id)
309              for _ in range(5):
310                  self.parent.efuse_read()
311                  self.parent.get_coding_scheme_warnings(silent=True)
312                  if self.fail or self.num_errors:
313                      print(
314                          "Error in BLOCK%d, re-burn it again (#%d), to fix it. "
315                          "fail_bit=%d, num_errors=%d"
316                          % (self.id, burns, self.fail, self.num_errors)
317                      )
318                      break
319              if not self.fail and self.num_errors == 0:
320                  break
321      def burn(self):
322          if self.wr_bitarray.all(False):
323              return
324          before_burn_bitarray = self.bitarray[:]
325          assert before_burn_bitarray is not self.bitarray
326          self.print_block(self.wr_bitarray, "to_write")
327          words = self.apply_coding_scheme()
328          self.burn_words(words)
329          self.read()
330          if not self.is_readable():
331              print(
332                  "{} ({}) is read-protected. "
333                  "Read back the burn value is not possible.".format(
334                      self.name, self.alias
335                  )
336              )
337              if self.bitarray.all(False):
338                  print("Read all '0'")
339              else:
340                  raise esptool.FatalError(
341                      "The {} is read-protected but not all '0' ({})".format(
342                          self.name, self.bitarray.hex
343                      )
344                  )
345          else:
346              if self.wr_bitarray == self.bitarray:
347                  print("BURN BLOCK%-2d - OK (write block == read block)" % self.id)
348              elif (
349                  self.wr_bitarray & self.bitarray == self.wr_bitarray
350                  and self.bitarray & before_burn_bitarray == before_burn_bitarray
351              ):
352                  print("BURN BLOCK%-2d - OK (all write block bits are set)" % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, "Expected")
355                  self.print_block(self.bitarray, "Real    ")
356                  if self.id != 0:
357                      raise esptool.FatalError(
358                          "Burn {} ({}) was not successful".format(self.name, self.alias)
359                      )
360          self.wr_bitarray.set(0)
361  class EspEfusesBase(object):
362      _esp = None
363      blocks = []
364      efuses = []
365      coding_scheme = None
366      force_write_always = None
367      batch_mode_cnt = 0
368      def __iter__(self):
369          return self.efuses.__iter__()
370      def get_crystal_freq(self):
371          return self._esp.get_crystal_freq()
372      def read_efuse(self, n):
373          return self._esp.read_efuse(n)
374      def read_reg(self, addr):
375          return self._esp.read_reg(addr)
376      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
377          return self._esp.write_reg(addr, value, mask, delay_us, delay_after_us)
378      def update_reg(self, addr, mask, new_val):
379          return self._esp.update_reg(addr, mask, new_val)
380      def efuse_controller_setup(self):
381          pass
382      def reconnect_chip(self, esp):
383          print("Re-connecting...")
384          baudrate = esp._port.baudrate
385          port = esp._port.port
386          esp._port.close()
387          return esptool.cmds.detect_chip(port, baudrate)
388      def get_index_block_by_name(self, name):
389          for block in self.blocks:
390              if block.name == name or name in block.alias:
391                  return block.id
392          return None
393      def read_blocks(self):
394          for block in self.blocks:
395              block.read()
396      def update_efuses(self):
397          for efuse in self.efuses:
398              efuse.update(self.blocks[efuse.block].bitarray)
399      def burn_all(self, check_batch_mode=False):
400          if check_batch_mode:
401              if self.batch_mode_cnt != 0:
402                  print(
403                      "\nBatch mode is enabled, "
404                      "the burn will be done at the end of the command."
405                  )
406                  return False
407          print("\nCheck all blocks for burn...")
408          print("idx, BLOCK_NAME,          Conclusion")
409          have_wr_data_for_burn = False
410          for block in self.blocks:
411              block.check_wr_data()
412              if not have_wr_data_for_burn and block.get_bitstring(from_read=False).any(
413                  True
414              ):
415                  have_wr_data_for_burn = True
416          if not have_wr_data_for_burn:
417              print("Nothing to burn, see messages above.")
418              return
419          EspEfusesBase.confirm("", self.do_not_confirm)
420          for block in reversed(self.blocks):
421              old_fail = block.fail
422              old_num_errors = block.num_errors
423              block.burn()
424              if (block.fail and old_fail != block.fail) or (
425                  block.num_errors and block.num_errors > old_num_errors
426              ):
427                  raise esptool.FatalError("Error(s) were detected in eFuses")
428          print("Reading updated efuses...")
429          self.read_coding_scheme()
430          self.read_blocks()
431          self.update_efuses()
432          return True
433      @staticmethod
434      def confirm(action, do_not_confirm):
435          print(
436              "%s%s\nThis is an irreversible operation!"
437              % (action, "" if action.endswith("\n") else ". ")
438          )
439          if not do_not_confirm:
440              print("Type 'BURN' (all capitals) to continue.")
441              sys.stdout.flush()
442              yes = input()
443              if yes != "BURN":
444                  print("Aborting.")
445                  sys.exit(0)
446      def print_error_msg(self, error_msg):
447          if self.force_write_always is not None:
448              if not self.force_write_always:
449                  error_msg += "(use '--force-write-always' option to ignore it)"
450          if self.force_write_always:
451              print(error_msg, "Skipped because '--force-write-always' option.")
452          else:
453              raise esptool.FatalError(error_msg)
454      def get_block_errors(self, block_num):
455          return self.blocks[block_num].num_errors, self.blocks[block_num].fail
456  class EfuseFieldBase(EfuseProtectBase):
457      def __init__(self, parent, param):
458          self.category = param.category
459          self.parent = parent
460          self.block = param.block
461          self.word = param.word
462          self.pos = param.pos
463          self.write_disable_bit = param.write_disable_bit
464          self.read_disable_bit = param.read_disable_bit
465          self.name = param.name
466          self.efuse_class = param.class_type
467          self.efuse_type = param.type
468          self.description = param.description
469          self.dict_value = param.dictionary
470          self.bit_len = param.bit_len
471          self.alt_names = param.alt_names
472          self.fail = False
473          self.num_errors = 0
474          self.bitarray = BitStream(self.bit_len)
475          self.bitarray.set(0)
476          self.update(self.parent.blocks[self.block].bitarray)
477      def check_format(self, new_value_str):
478          if new_value_str is None:
479              return new_value_str
480          else:
481              if self.efuse_type.startswith("bytes"):
482                  if new_value_str.startswith("0x"):
483                      return binascii.unhexlify(new_value_str[2:])[::-1]
484                  else:
485                      return binascii.unhexlify(new_value_str)
486              else:
487                  return new_value_str
488      def convert_to_bitstring(self, new_value):
489          if isinstance(new_value, BitArray):
490              return new_value
491          else:
492              if self.efuse_type.startswith("bytes"):
493                  return BitArray(bytes=new_value[::-1], length=len(new_value) * 8)
494              else:
495                  try:
496                      return BitArray(self.efuse_type + "={}".format(new_value))
497                  except CreationError as err:
498                      print(
499                          "New value '{}' is not suitable for {} ({})".format(
500                              new_value, self.name, self.efuse_type
501                          )
502                      )
503                      raise esptool.FatalError(err)
504      def check_new_value(self, bitarray_new_value):
505          bitarray_old_value = self.get_bitstring() | self.get_bitstring(from_read=False)
506          if bitarray_new_value.len != bitarray_old_value.len:
507              raise esptool.FatalError(
508                  "For {} efuse, the length of the new value is wrong, "
509                  "expected {} bits, was {} bits.".format(
510                      self.name, bitarray_old_value.len, bitarray_new_value.len
511                  )
512              )
513          if bitarray_new_value == bitarray_old_value:
514              error_msg = "\tThe same value for {} ".format(self.name)
515              error_msg += "is already burned. Do not change the efuse."
516              print(error_msg)
517              bitarray_new_value.set(0)
518          elif bitarray_new_value == self.get_bitstring(from_read=False):
519              error_msg = "\tThe same value for {} ".format(self.name)
520              error_msg += "is already prepared for the burn operation."
521              print(error_msg)
522              bitarray_new_value.set(0)
523          else:
524              if self.name not in ["WR_DIS", "RD_DIS"]:
525                  if bitarray_new_value | bitarray_old_value != bitarray_new_value:
526                      error_msg = "\tNew value contains some bits that cannot be cleared "
527                      error_msg += "(value will be {})".format(
528                          bitarray_old_value | bitarray_new_value
529                      )
530                      self.parent.print_error_msg(error_msg)
531              self.check_wr_rd_protect()
532      def save_to_block(self, bitarray_field):
533          block = self.parent.blocks[self.block]
534          wr_bitarray_temp = block.wr_bitarray.copy()
535          position = wr_bitarray_temp.length - (
536              self.word * 32 + self.pos + bitarray_field.len
537          )
538          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
539          block.wr_bitarray |= wr_bitarray_temp
540      def save(self, new_value):
541          bitarray_field = self.convert_to_bitstring(new_value)
542          self.check_new_value(bitarray_field)
543          self.save_to_block(bitarray_field)
544      def update(self, bit_array_block):
545          if self.word is None or self.pos is None:
546              self.bitarray.overwrite(self.convert_to_bitstring(self.get()), pos=0)
547              return
548          field_len = self.bitarray.len
549          bit_array_block.pos = bit_array_block.length - (
550              self.word * 32 + self.pos + field_len
551          )
552          self.bitarray.overwrite(bit_array_block.read(field_len), pos=0)
553          err_bitarray = self.parent.blocks[self.block].err_bitarray
554          if err_bitarray is not None:
555              err_bitarray.pos = err_bitarray.length - (
556                  self.word * 32 + self.pos + field_len
557              )
558              self.fail = not err_bitarray.read(field_len).all(False)
559          else:
560              self.fail = self.parent.blocks[self.block].fail
561              self.num_errors = self.parent.blocks[self.block].num_errors
562      def get_raw(self, from_read=True):
563          return self.get_bitstring(from_read).read(self.efuse_type)
564      def get(self, from_read=True):
565          if self.efuse_type.startswith("bytes"):
566              return util.hexify(self.get_bitstring(from_read).bytes[::-1], " ")
567          else:
568              return self.get_raw(from_read)
569      def get_meaning(self, from_read=True):
570          if self.dict_value:
571              try:
572                  return self.dict_value[self.get_raw(from_read)]
573              except KeyError:
574                  pass
575          return self.get(from_read)
576      def get_bitstring(self, from_read=True):
577          if from_read:
578              self.bitarray.pos = 0
579              return self.bitarray
580          else:
581              field_len = self.bitarray.len
582              block = self.parent.blocks[self.block]
583              block.wr_bitarray.pos = block.wr_bitarray.length - (
584                  self.word * 32 + self.pos + field_len
585              )
586              return block.wr_bitarray.read(self.bitarray.len)
587      def burn(self, new_value):
588          self.save(new_value)
589          self.parent.burn_all()
590      def get_info(self):
591          output = f"{self.name} (BLOCK{self.block})"
592          if self.block == 0:
593              if self.fail:
594                  output += "[error]"
595          else:
596              errs, fail = self.parent.get_block_errors(self.block)
597              if errs != 0 or fail:
598                  output += "[error]"
599          if self.efuse_class == "keyblock":
600              name = self.parent.blocks[self.block].key_purpose_name
601              if name is not None:
602                  output += f"\n  Purpose: {self.parent[name].get()}\n "
603          return output
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_http.py</h3>
            <pre><code>1  #!/usr/bin/env python
2  from __future__ import absolute_import
3  __author__ = "jcgregorio@google.com (Joe Gregorio)"
4  import io
5  from io import FileIO
6  import json
7  import logging
8  import os
9  import random
10  import socket
11  import ssl
12  import time
13  import unittest
14  from unittest import mock
15  import urllib
16  import httplib2
17  from googleapiclient.discovery import build
18  from googleapiclient.errors import BatchError, HttpError, InvalidChunkSizeError
19  from googleapiclient.http import (
20      MAX_URI_LENGTH,
21      BatchHttpRequest,
22      HttpMock,
23      HttpMockSequence,
24      HttpRequest,
25      MediaFileUpload,
26      MediaInMemoryUpload,
27      MediaIoBaseDownload,
28      MediaIoBaseUpload,
29      MediaUpload,
30      _StreamSlice,
31      build_http,
32      set_user_agent,
33  )
34  from googleapiclient.model import JsonModel
35  class MockCredentials:
36      def __init__(self, bearer_token, expired=False):
37          super(MockCredentials, self).__init__()
38          self._authorized = 0
39          self._refreshed = 0
40          self._applied = 0
41          self._bearer_token = bearer_token
42          self._access_token_expired = expired
43      @property
44      def access_token(self):
45          return self._bearer_token
46      @property
47      def access_token_expired(self):
48          return self._access_token_expired
49      def authorize(self, http):
50          self._authorized += 1
51          request_orig = http.request
52          def new_request(
53              uri,
54              method="GET",
55              body=None,
56              headers=None,
57              redirections=httplib2.DEFAULT_MAX_REDIRECTS,
58              connection_type=None,
59          ):
60              if headers is None:
61                  headers = {}
62              self.apply(headers)
63              resp, content = request_orig(
64                  uri, method, body, headers, redirections, connection_type
65              )
66              return resp, content
67          http.request = new_request
68          setattr(http.request, "credentials", self)
69          return http
70      def refresh(self, http):
71          self._refreshed += 1
72      def apply(self, headers):
73          self._applied += 1
74          headers["authorization"] = self._bearer_token + " " + str(self._refreshed)
75  class HttpMockWithErrors(object):
76      def __init__(self, num_errors, success_json, success_data):
77          self.num_errors = num_errors
78          self.success_json = success_json
79          self.success_data = success_data
80      def request(self, *args, **kwargs):
81          if not self.num_errors:
82              return httplib2.Response(self.success_json), self.success_data
83          elif self.num_errors == 5:
84              ex = ConnectionResetError  # noqa: F821
85          elif self.num_errors == 4:
86              ex = httplib2.ServerNotFoundError()
87          elif self.num_errors == 3:
88              ex = OSError()
89              ex.errno = socket.errno.EPIPE
90          elif self.num_errors == 2:
91              ex = ssl.SSLError()
92          else:
93              try:
94                  ex = OSError()
95                  ex.errno = socket.errno.WSAETIMEDOUT
96              except AttributeError:
97                  ex = socket.timeout()
98          self.num_errors -= 1
99          raise ex
100  class HttpMockWithNonRetriableErrors(object):
101      def __init__(self, num_errors, success_json, success_data):
102          self.num_errors = num_errors
103          self.success_json = success_json
104          self.success_data = success_data
105      def request(self, *args, **kwargs):
106          if not self.num_errors:
107              return httplib2.Response(self.success_json), self.success_data
108          else:
109              self.num_errors -= 1
110              ex = OSError()
111              try:
112                  ex.errno = socket.errno.WSAEHOSTUNREACH
113              except AttributeError:
114                  ex.errno = socket.errno.EHOSTUNREACH
115              raise ex
116  DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
117  def datafile(filename):
118      return os.path.join(DATA_DIR, filename)
119  def _postproc_none(*kwargs):
120      pass
121  class TestUserAgent(unittest.TestCase):
122      def test_set_user_agent(self):
123          http = HttpMockSequence([({"status": "200"}, "echo_request_headers")])
124          http = set_user_agent(http, "my_app/5.5")
125          resp, content = http.request("http://example.com")
126          self.assertEqual("my_app/5.5", content["user-agent"])
127      def test_set_user_agent_nested(self):
128          http = HttpMockSequence([({"status": "200"}, "echo_request_headers")])
129          http = set_user_agent(http, "my_app/5.5")
130          http = set_user_agent(http, "my_library/0.1")
131          resp, content = http.request("http://example.com")
132          self.assertEqual("my_app/5.5 my_library/0.1", content["user-agent"])
133  class TestMediaUpload(unittest.TestCase):
134      def test_media_file_upload_closes_fd_in___del__(self):
135          file_desc = mock.Mock(spec=io.TextIOWrapper)
136          opener = mock.mock_open(file_desc)
137          with mock.patch("builtins.open", return_value=opener):
138              upload = MediaFileUpload(datafile("test_close"), mimetype="text/plain")
139          self.assertIs(upload.stream(), file_desc)
140          del upload
141          file_desc.close.assert_called_once_with()
142      def test_media_file_upload_mimetype_detection(self):
143          upload = MediaFileUpload(datafile("small.png"))
144          self.assertEqual("image/png", upload.mimetype())
145          upload = MediaFileUpload(datafile("empty"))
146          self.assertEqual("application/octet-stream", upload.mimetype())
147      def test_media_file_upload_to_from_json(self):
148          upload = MediaFileUpload(datafile("small.png"), chunksize=500, resumable=True)
149          self.assertEqual("image/png", upload.mimetype())
150          self.assertEqual(190, upload.size())
151          self.assertEqual(True, upload.resumable())
152          self.assertEqual(500, upload.chunksize())
153          self.assertEqual(b"PNG", upload.getbytes(1, 3))
154          json = upload.to_json()
155          new_upload = MediaUpload.new_from_json(json)
156          self.assertEqual("image/png", new_upload.mimetype())
157          self.assertEqual(190, new_upload.size())
158          self.assertEqual(True, new_upload.resumable())
159          self.assertEqual(500, new_upload.chunksize())
160          self.assertEqual(b"PNG", new_upload.getbytes(1, 3))
161      def test_media_file_upload_raises_on_file_not_found(self):
162          with self.assertRaises(FileNotFoundError):
163              MediaFileUpload(datafile("missing.png"))
164      def test_media_file_upload_raises_on_invalid_chunksize(self):
165          self.assertRaises(
166              InvalidChunkSizeError,
167              MediaFileUpload,
168              datafile("small.png"),
169              mimetype="image/png",
170              chunksize=-2,
171              resumable=True,
172          )
173      def test_media_inmemory_upload(self):
174          media = MediaInMemoryUpload(
175              b"abcdef", mimetype="text/plain", chunksize=10, resumable=True
176          )
177          self.assertEqual("text/plain", media.mimetype())
178          self.assertEqual(10, media.chunksize())
179          self.assertTrue(media.resumable())
180          self.assertEqual(b"bc", media.getbytes(1, 2))
181          self.assertEqual(6, media.size())
182      def test_http_request_to_from_json(self):
183          http = build_http()
184          media_upload = MediaFileUpload(
185              datafile("small.png"), chunksize=500, resumable=True
186          )
187          req = HttpRequest(
188              http,
189              _postproc_none,
190              "http://example.com",
191              method="POST",
192              body="{}",
193              headers={"content-type": 'multipart/related; boundary="---flubber"'},
194              methodId="foo",
195              resumable=media_upload,
196          )
197          json = req.to_json()
198          new_req = HttpRequest.from_json(json, http, _postproc_none)
199          self.assertEqual(
200              {"content-type": 'multipart/related; boundary="---flubber"'},
201              new_req.headers,
202          )
203          self.assertEqual("http://example.com", new_req.uri)
204          self.assertEqual("{}", new_req.body)
205          self.assertEqual(http, new_req.http)
206          self.assertEqual(media_upload.to_json(), new_req.resumable.to_json())
207          self.assertEqual(random.random, new_req._rand)
208          self.assertEqual(time.sleep, new_req._sleep)
209  class TestMediaIoBaseUpload(unittest.TestCase):
210      def test_media_io_base_upload_from_file_io(self):
211          fd = FileIO(datafile("small.png"), "r")
212          upload = MediaIoBaseUpload(
213              fd=fd, mimetype="image/png", chunksize=500, resumable=True
214          )
215          self.assertEqual("image/png", upload.mimetype())
216          self.assertEqual(190, upload.size())
217          self.assertEqual(True, upload.resumable())
218          self.assertEqual(500, upload.chunksize())
219          self.assertEqual(b"PNG", upload.getbytes(1, 3))
220      def test_media_io_base_upload_from_file_object(self):
221          f = open(datafile("small.png"), "rb")
222          upload = MediaIoBaseUpload(
223              fd=f, mimetype="image/png", chunksize=500, resumable=True
224          )
225          self.assertEqual("image/png", upload.mimetype())
226          self.assertEqual(190, upload.size())
227          self.assertEqual(True, upload.resumable())
228          self.assertEqual(500, upload.chunksize())
229          self.assertEqual(b"PNG", upload.getbytes(1, 3))
230          f.close()
231      def test_media_io_base_upload_serializable(self):
232          f = open(datafile("small.png"), "rb")
233          upload = MediaIoBaseUpload(fd=f, mimetype="image/png")
234          try:
235              json = upload.to_json()
236              self.fail("MediaIoBaseUpload should not be serializable.")
237          except NotImplementedError:
238              pass
239      def test_media_io_base_upload_from_bytes(self):
240          f = open(datafile("small.png"), "rb")
241          fd = io.BytesIO(f.read())
242          upload = MediaIoBaseUpload(
243              fd=fd, mimetype="image/png", chunksize=500, resumable=True
244          )
245          self.assertEqual("image/png", upload.mimetype())
246          self.assertEqual(190, upload.size())
247          self.assertEqual(True, upload.resumable())
248          self.assertEqual(500, upload.chunksize())
249          self.assertEqual(b"PNG", upload.getbytes(1, 3))
250      def test_media_io_base_upload_raises_on_invalid_chunksize(self):
251          f = open(datafile("small.png"), "rb")
252          fd = io.BytesIO(f.read())
253          self.assertRaises(
254              InvalidChunkSizeError,
255              MediaIoBaseUpload,
256              fd,
257              "image/png",
258              chunksize=-2,
259              resumable=True,
260          )
261      def test_media_io_base_upload_streamable(self):
262          fd = io.BytesIO(b"stuff")
263          upload = MediaIoBaseUpload(
264              fd=fd, mimetype="image/png", chunksize=500, resumable=True
265          )
266          self.assertEqual(True, upload.has_stream())
267          self.assertEqual(fd, upload.stream())
268      def test_media_io_base_next_chunk_retries(self):
269          f = open(datafile("small.png"), "rb")
270          fd = io.BytesIO(f.read())
271          upload = MediaIoBaseUpload(
272              fd=fd, mimetype="image/png", chunksize=500, resumable=True
273          )
274          http = HttpMockSequence(
275              [
276                  ({"status": "500"}, ""),
277                  ({"status": "500"}, ""),
278                  ({"status": "503"}, ""),
279                  ({"status": "200", "location": "location"}, ""),
280                  ({"status": "403"}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS),
281                  ({"status": "403"}, RATE_LIMIT_EXCEEDED_RESPONSE),
282                  ({"status": "429"}, ""),
283                  ({"status": "200"}, "{}"),
284              ]
285          )
286          model = JsonModel()
287          uri = "https://www.googleapis.com/someapi/v1/upload/?foo=bar"
288          method = "POST"
289          request = HttpRequest(
290              http, model.response, uri, method=method, headers={}, resumable=upload
291          )
292          sleeptimes = []
293          request._sleep = lambda x: sleeptimes.append(x)
294          request._rand = lambda: 10
295          request.execute(num_retries=3)
296          self.assertEqual([20, 40, 80, 20, 40, 80], sleeptimes)
297      def test_media_io_base_next_chunk_no_retry_403_not_configured(self):
298          fd = io.BytesIO(b"i am png")
299          upload = MediaIoBaseUpload(
300              fd=fd, mimetype="image/png", chunksize=500, resumable=True
301          )
302          http = HttpMockSequence(
303              [({"status": "403"}, NOT_CONFIGURED_RESPONSE), ({"status": "200"}, "{}")]
304          )
305          model = JsonModel()
306          uri = "https://www.googleapis.com/someapi/v1/upload/?foo=bar"
307          method = "POST"
308          request = HttpRequest(
309              http, model.response, uri, method=method, headers={}, resumable=upload
310          )
311          request._rand = lambda: 1.0
312          request._sleep = mock.MagicMock()
313          with self.assertRaises(HttpError):
314              request.execute(num_retries=3)
315          request._sleep.assert_not_called()
316      def test_media_io_base_empty_file(self):
317          fd = io.BytesIO()
318          upload = MediaIoBaseUpload(
319              fd=fd, mimetype="image/png", chunksize=500, resumable=True
320          )
321          http = HttpMockSequence(
322              [
323                  (
324                      {
325                          "status": "200",
326                          "location": "https://www.googleapis.com/someapi/v1/upload?foo=bar",
327                      },
328                      "{}",
329                  ),
330                  (
331                      {
332                          "status": "200",
333                          "location": "https://www.googleapis.com/someapi/v1/upload?foo=bar",
334                      },
335                      "{}",
336                  ),
337              ]
338          )
339          model = JsonModel()
340          uri = "https://www.googleapis.com/someapi/v1/upload/?foo=bar"
341          method = "POST"
342          request = HttpRequest(
343              http, model.response, uri, method=method, headers={}, resumable=upload
344          )
345          request.execute()
346          self.assertTrue("Content-Range" not in http.request_sequence[-1][-1])
347          self.assertEqual("0", http.request_sequence[-1][-1]["Content-Length"])
348  class TestMediaIoBaseDownload(unittest.TestCase):
349      def setUp(self):
350          http = HttpMock(datafile("zoo.json"), {"status": "200"})
351          zoo = build("zoo", "v1", http=http, static_discovery=False)
352          self.request = zoo.animals().get_media(name="Lion")
353          self.fd = io.BytesIO()
354      def test_media_io_base_download(self):
355          self.request.http = HttpMockSequence(
356              [
357                  ({"status": "200", "content-range": "0-2/5"}, b"123"),
358                  ({"status": "200", "content-range": "3-4/5"}, b"45"),
359              ]
360          )
361          self.assertEqual(True, self.request.http.follow_redirects)
362          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
363          self.assertEqual(self.fd, download._fd)
364          self.assertEqual(3, download._chunksize)
365          self.assertEqual(0, download._progress)
366          self.assertEqual(None, download._total_size)
367          self.assertEqual(False, download._done)
368          self.assertEqual(self.request.uri, download._uri)
369          status, done = download.next_chunk()
370          self.assertEqual(self.fd.getvalue(), b"123")
371          self.assertEqual(False, done)
372          self.assertEqual(3, download._progress)
373          self.assertEqual(5, download._total_size)
374          self.assertEqual(3, status.resumable_progress)
375          status, done = download.next_chunk()
376          self.assertEqual(self.fd.getvalue(), b"12345")
377          self.assertEqual(True, done)
378          self.assertEqual(5, download._progress)
379          self.assertEqual(5, download._total_size)
380      def test_media_io_base_download_range_request_header(self):
381          self.request.http = HttpMockSequence(
382              [
383                  (
384                      {"status": "200", "content-range": "0-2/5"},
385                      "echo_request_headers_as_json",
386                  ),
387              ]
388          )
389          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
390          status, done = download.next_chunk()
391          result = json.loads(self.fd.getvalue().decode("utf-8"))
392          self.assertEqual(result.get("range"), "bytes=0-2")
393      def test_media_io_base_download_custom_request_headers(self):
394          self.request.http = HttpMockSequence(
395              [
396                  (
397                      {"status": "200", "content-range": "0-2/5"},
398                      "echo_request_headers_as_json",
399                  ),
400                  (
401                      {"status": "200", "content-range": "3-4/5"},
402                      "echo_request_headers_as_json",
403                  ),
404              ]
405          )
406          self.assertEqual(True, self.request.http.follow_redirects)
407          self.request.headers["Cache-Control"] = "no-store"
408          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
409          self.assertEqual(download._headers.get("Cache-Control"), "no-store")
410          status, done = download.next_chunk()
411          result = json.loads(self.fd.getvalue().decode("utf-8"))
412          self.assertEqual(result.get("Cache-Control"), "no-store")
413          download._fd = self.fd = io.BytesIO()
414          status, done = download.next_chunk()
415          result = json.loads(self.fd.getvalue().decode("utf-8"))
416          self.assertEqual(result.get("Cache-Control"), "no-store")
417      def test_media_io_base_download_handle_redirects(self):
418          self.request.http = HttpMockSequence(
419              [
420                  (
421                      {
422                          "status": "200",
423                          "content-location": "https://secure.example.net/lion",
424                      },
425                      b"",
426                  ),
427                  ({"status": "200", "content-range": "0-2/5"}, b"abc"),
428              ]
429          )
430          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
431          status, done = download.next_chunk()
432          self.assertEqual("https://secure.example.net/lion", download._uri)
433      def test_media_io_base_download_handle_4xx(self):
434          self.request.http = HttpMockSequence([({"status": "400"}, "")])
435          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
436          try:
437              status, done = download.next_chunk()
438              self.fail("Should raise an exception")
439          except HttpError:
440              pass
441          self.request.http = HttpMockSequence(
442              [({"status": "200", "content-range": "0-2/5"}, b"123")]
443          )
444          status, done = download.next_chunk()
445          self.assertEqual(self.fd.getvalue(), b"123")
446      def test_media_io_base_download_retries_connection_errors(self):
447          self.request.http = HttpMockWithErrors(
448              5, {"status": "200", "content-range": "0-2/3"}, b"123"
449          )
450          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
451          download._sleep = lambda _x: 0  # do nothing
452          download._rand = lambda: 10
453          status, done = download.next_chunk(num_retries=5)
454          self.assertEqual(self.fd.getvalue(), b"123")
455          self.assertEqual(True, done)
456      def test_media_io_base_download_retries_5xx(self):
457          self.request.http = HttpMockSequence(
458              [
459                  ({"status": "500"}, ""),
460                  ({"status": "500"}, ""),
461                  ({"status": "500"}, ""),
462                  ({"status": "200", "content-range": "0-2/5"}, b"123"),
463                  ({"status": "503"}, ""),
464                  ({"status": "503"}, ""),
465                  ({"status": "503"}, ""),
466                  ({"status": "200", "content-range": "3-4/5"}, b"45"),
467              ]
468          )
469          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
470          self.assertEqual(self.fd, download._fd)
471          self.assertEqual(3, download._chunksize)
472          self.assertEqual(0, download._progress)
473          self.assertEqual(None, download._total_size)
474          self.assertEqual(False, download._done)
475          self.assertEqual(self.request.uri, download._uri)
476          sleeptimes = []
477          download._sleep = lambda x: sleeptimes.append(x)
478          download._rand = lambda: 10
479          status, done = download.next_chunk(num_retries=3)
480          self.assertEqual([20, 40, 80], sleeptimes)
481          self.assertEqual(self.fd.getvalue(), b"123")
482          self.assertEqual(False, done)
483          self.assertEqual(3, download._progress)
484          self.assertEqual(5, download._total_size)
485          self.assertEqual(3, status.resumable_progress)
486          del sleeptimes[0 : len(sleeptimes)]
487          status, done = download.next_chunk(num_retries=3)
488          self.assertEqual([20, 40, 80], sleeptimes)
489          self.assertEqual(self.fd.getvalue(), b"12345")
490          self.assertEqual(True, done)
491          self.assertEqual(5, download._progress)
492          self.assertEqual(5, download._total_size)
493      def test_media_io_base_download_empty_file(self):
494          self.request.http = HttpMockSequence(
495              [({"status": "200", "content-range": "0-0/0"}, b"")]
496          )
497          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
498          self.assertEqual(self.fd, download._fd)
499          self.assertEqual(0, download._progress)
500          self.assertEqual(None, download._total_size)
501          self.assertEqual(False, download._done)
502          self.assertEqual(self.request.uri, download._uri)
503          status, done = download.next_chunk()
504          self.assertEqual(True, done)
505          self.assertEqual(0, download._progress)
506          self.assertEqual(0, download._total_size)
507          self.assertEqual(0, status.progress())
508      def test_media_io_base_download_empty_file_416_response(self):
509          self.request.http = HttpMockSequence(
510              [({"status": "416", "content-range": "0-0/0"}, b"")]
511          )
512          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
513          self.assertEqual(self.fd, download._fd)
514          self.assertEqual(0, download._progress)
515          self.assertEqual(None, download._total_size)
516          self.assertEqual(False, download._done)
517          self.assertEqual(self.request.uri, download._uri)
518          status, done = download.next_chunk()
519          self.assertEqual(True, done)
520          self.assertEqual(0, download._progress)
521          self.assertEqual(0, download._total_size)
522          self.assertEqual(0, status.progress())
523      def test_media_io_base_download_unknown_media_size(self):
524          self.request.http = HttpMockSequence([({"status": "200"}, b"123")])
525          download = MediaIoBaseDownload(fd=self.fd, request=self.request, chunksize=3)
526          self.assertEqual(self.fd, download._fd)
527          self.assertEqual(0, download._progress)
528          self.assertEqual(None, download._total_size)
529          self.assertEqual(False, download._done)
530          self.assertEqual(self.request.uri, download._uri)
531          status, done = download.next_chunk()
532          self.assertEqual(self.fd.getvalue(), b"123")
533          self.assertEqual(True, done)
534          self.assertEqual(3, download._progress)
535          self.assertEqual(None, download._total_size)
536          self.assertEqual(0, status.progress())
537  EXPECTED = 
538  NO_BODY_EXPECTED = 
539  NO_BODY_EXPECTED_GET = 
540  RESPONSE = 
541  BATCH_RESPONSE = b
542  BATCH_ERROR_RESPONSE = b
543  BATCH_RESPONSE_WITH_401 = b
544  BATCH_SINGLE_RESPONSE = b
545  USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS = 
546  USER_RATE_LIMIT_EXCEEDED_RESPONSE_WITH_STATUS = 
547  RATE_LIMIT_EXCEEDED_RESPONSE = 
548  NOT_CONFIGURED_RESPONSE = 
549  LIST_NOT_CONFIGURED_RESPONSE = 
550  class Callbacks(object):
551      def __init__(self):
552          self.responses = {}
553          self.exceptions = {}
554      def f(self, request_id, response, exception):
555          self.responses[request_id] = response
556          self.exceptions[request_id] = exception
557  class TestHttpRequest(unittest.TestCase):
558      def test_unicode(self):
559          http = HttpMock(datafile("zoo.json"), headers={"status": "200"})
560          model = JsonModel()
561          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
562          method = "POST"
563          request = HttpRequest(
564              http,
565              model.response,
566              uri,
567              method=method,
568              body="{}",
569              headers={"content-type": "application/json"},
570          )
571          request.execute()
572          self.assertEqual(uri, http.uri)
573          self.assertEqual(str, type(http.uri))
574          self.assertEqual(method, http.method)
575          self.assertEqual(str, type(http.method))
576      def test_empty_content_type(self):
577          http = HttpMock(None, headers={"status": 200})
578          uri = "https://www.googleapis.com/someapi/v1/upload/?foo=bar"
579          method = "POST"
580          request = HttpRequest(
581              http, _postproc_none, uri, method=method, headers={"content-type": ""}
582          )
583          request.execute()
584          self.assertEqual("", http.headers.get("content-type"))
585      def test_no_retry_connection_errors(self):
586          model = JsonModel()
587          request = HttpRequest(
588              HttpMockWithNonRetriableErrors(1, {"status": "200"}, '{"foo": "bar"}'),
589              model.response,
590              "https://www.example.com/json_api_endpoint",
591          )
592          request._sleep = lambda _x: 0  # do nothing
593          request._rand = lambda: 10
594          with self.assertRaises(OSError):
595              response = request.execute(num_retries=3)
596      def test_retry_connection_errors_non_resumable(self):
597          model = JsonModel()
598          request = HttpRequest(
599              HttpMockWithErrors(5, {"status": "200"}, '{"foo": "bar"}'),
600              model.response,
601              "https://www.example.com/json_api_endpoint",
602          )
603          request._sleep = lambda _x: 0  # do nothing
604          request._rand = lambda: 10
605          response = request.execute(num_retries=5)
606          self.assertEqual({"foo": "bar"}, response)
607      def test_retry_connection_errors_resumable(self):
608          with open(datafile("small.png"), "rb") as small_png_file:
609              small_png_fd = io.BytesIO(small_png_file.read())
610          upload = MediaIoBaseUpload(
611              fd=small_png_fd, mimetype="image/png", chunksize=500, resumable=True
612          )
613          model = JsonModel()
614          request = HttpRequest(
615              HttpMockWithErrors(
616                  5, {"status": "200", "location": "location"}, '{"foo": "bar"}'
617              ),
618              model.response,
619              "https://www.example.com/file_upload",
620              method="POST",
621              resumable=upload,
622          )
623          request._sleep = lambda _x: 0  # do nothing
624          request._rand = lambda: 10
625          response = request.execute(num_retries=5)
626          self.assertEqual({"foo": "bar"}, response)
627      def test_retry(self):
628          num_retries = 6
629          resp_seq = [({"status": "500"}, "")] * (num_retries - 4)
630          resp_seq.append(({"status": "403"}, RATE_LIMIT_EXCEEDED_RESPONSE))
631          resp_seq.append(
632              ({"status": "403"}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_NO_STATUS)
633          )
634          resp_seq.append(
635              ({"status": "403"}, USER_RATE_LIMIT_EXCEEDED_RESPONSE_WITH_STATUS)
636          )
637          resp_seq.append(({"status": "429"}, ""))
638          resp_seq.append(({"status": "200"}, "{}"))
639          http = HttpMockSequence(resp_seq)
640          model = JsonModel()
641          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
642          method = "POST"
643          request = HttpRequest(
644              http,
645              model.response,
646              uri,
647              method=method,
648              body="{}",
649              headers={"content-type": "application/json"},
650          )
651          sleeptimes = []
652          request._sleep = lambda x: sleeptimes.append(x)
653          request._rand = lambda: 10
654          request.execute(num_retries=num_retries)
655          self.assertEqual(num_retries, len(sleeptimes))
656          for retry_num in range(num_retries):
657              self.assertEqual(10 * 2 ** (retry_num + 1), sleeptimes[retry_num])
658      def test_no_retry_succeeds(self):
659          num_retries = 5
660          resp_seq = [({"status": "200"}, "{}")] * (num_retries)
661          http = HttpMockSequence(resp_seq)
662          model = JsonModel()
663          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
664          method = "POST"
665          request = HttpRequest(
666              http,
667              model.response,
668              uri,
669              method=method,
670              body="{}",
671              headers={"content-type": "application/json"},
672          )
673          sleeptimes = []
674          request._sleep = lambda x: sleeptimes.append(x)
675          request._rand = lambda: 10
676          request.execute(num_retries=num_retries)
677          self.assertEqual(0, len(sleeptimes))
678      def test_no_retry_fails_fast(self):
679          http = HttpMockSequence([({"status": "500"}, ""), ({"status": "200"}, "{}")])
680          model = JsonModel()
681          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
682          method = "POST"
683          request = HttpRequest(
684              http,
685              model.response,
686              uri,
687              method=method,
688              body="{}",
689              headers={"content-type": "application/json"},
690          )
691          request._rand = lambda: 1.0
692          request._sleep = mock.MagicMock()
693          with self.assertRaises(HttpError):
694              request.execute()
695          request._sleep.assert_not_called()
696      def test_no_retry_403_not_configured_fails_fast(self):
697          http = HttpMockSequence(
698              [({"status": "403"}, NOT_CONFIGURED_RESPONSE), ({"status": "200"}, "{}")]
699          )
700          model = JsonModel()
701          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
702          method = "POST"
703          request = HttpRequest(
704              http,
705              model.response,
706              uri,
707              method=method,
708              body="{}",
709              headers={"content-type": "application/json"},
710          )
711          request._rand = lambda: 1.0
712          request._sleep = mock.MagicMock()
713          with self.assertRaises(HttpError):
714              request.execute()
715          request._sleep.assert_not_called()
716      def test_no_retry_403_fails_fast(self):
717          http = HttpMockSequence([({"status": "403"}, ""), ({"status": "200"}, "{}")])
718          model = JsonModel()
719          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
720          method = "POST"
721          request = HttpRequest(
722              http,
723              model.response,
724              uri,
725              method=method,
726              body="{}",
727              headers={"content-type": "application/json"},
728          )
729          request._rand = lambda: 1.0
730          request._sleep = mock.MagicMock()
731          with self.assertRaises(HttpError):
732              request.execute()
733          request._sleep.assert_not_called()
734      def test_no_retry_401_fails_fast(self):
735          http = HttpMockSequence([({"status": "401"}, ""), ({"status": "200"}, "{}")])
736          model = JsonModel()
737          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
738          method = "POST"
739          request = HttpRequest(
740              http,
741              model.response,
742              uri,
743              method=method,
744              body="{}",
745              headers={"content-type": "application/json"},
746          )
747          request._rand = lambda: 1.0
748          request._sleep = mock.MagicMock()
749          with self.assertRaises(HttpError):
750              request.execute()
751          request._sleep.assert_not_called()
752      def test_no_retry_403_list_fails(self):
753          http = HttpMockSequence(
754              [
755                  ({"status": "403"}, LIST_NOT_CONFIGURED_RESPONSE),
756                  ({"status": "200"}, "{}"),
757              ]
758          )
759          model = JsonModel()
760          uri = "https://www.googleapis.com/someapi/v1/collection/?foo=bar"
761          method = "POST"
762          request = HttpRequest(
763              http,
764              model.response,
765              uri,
766              method=method,
767              body="{}",
768              headers={"content-type": "application/json"},
769          )
770          request._rand = lambda: 1.0
771          request._sleep = mock.MagicMock()
772          with self.assertRaises(HttpError):
773              request.execute()
774          request._sleep.assert_not_called()
775      def test_null_postproc(self):
776          resp, content = HttpRequest.null_postproc("foo", "bar")
777          self.assertEqual(resp, "foo")
778          self.assertEqual(content, "bar")
779  class TestBatch(unittest.TestCase):
780      def setUp(self):
781          model = JsonModel()
782          self.request1 = HttpRequest(
783              None,
784              model.response,
785              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
786              method="POST",
787              body="{}",
788              headers={"content-type": "application/json"},
789          )
790          self.request2 = HttpRequest(
791              None,
792              model.response,
793              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
794              method="GET",
795              body="",
796              headers={"content-type": "application/json"},
797          )
798      def test_id_to_from_content_id_header(self):
799          batch = BatchHttpRequest()
800          self.assertEqual("12", batch._header_to_id(batch._id_to_header("12")))
801      def test_invalid_content_id_header(self):
802          batch = BatchHttpRequest()
803          self.assertRaises(BatchError, batch._header_to_id, "[foo+x]")
804          self.assertRaises(BatchError, batch._header_to_id, "foo+1")
805          self.assertRaises(BatchError, batch._header_to_id, "<foo>")
806      def test_serialize_request(self):
807          batch = BatchHttpRequest()
808          request = HttpRequest(
809              None,
810              None,
811              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
812              method="POST",
813              body="{}",
814              headers={"content-type": "application/json"},
815              methodId=None,
816              resumable=None,
817          )
818          s = batch._serialize_request(request).splitlines()
819          self.assertEqual(EXPECTED.splitlines(), s)
820      def test_serialize_request_media_body(self):
821          batch = BatchHttpRequest()
822          f = open(datafile("small.png"), "rb")
823          body = f.read()
824          f.close()
825          request = HttpRequest(
826              None,
827              None,
828              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
829              method="POST",
830              body=body,
831              headers={"content-type": "application/json"},
832              methodId=None,
833              resumable=None,
834          )
835          s = batch._serialize_request(request).splitlines()
836      def test_serialize_request_no_body(self):
837          batch = BatchHttpRequest()
838          request = HttpRequest(
839              None,
840              None,
841              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
842              method="POST",
843              body=b"",
844              headers={"content-type": "application/json"},
845              methodId=None,
846              resumable=None,
847          )
848          s = batch._serialize_request(request).splitlines()
849          self.assertEqual(NO_BODY_EXPECTED.splitlines(), s)
850      def test_serialize_get_request_no_body(self):
851          batch = BatchHttpRequest()
852          request = HttpRequest(
853              None,
854              None,
855              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
856              method="GET",
857              body=None,
858              headers={"content-type": "application/json"},
859              methodId=None,
860              resumable=None,
861          )
862          s = batch._serialize_request(request).splitlines()
863          self.assertEqual(NO_BODY_EXPECTED_GET.splitlines(), s)
864      def test_deserialize_response(self):
865          batch = BatchHttpRequest()
866          resp, content = batch._deserialize_response(RESPONSE)
867          self.assertEqual(200, resp.status)
868          self.assertEqual("OK", resp.reason)
869          self.assertEqual(11, resp.version)
870          self.assertEqual('{"answer": 42}', content)
871      def test_new_id(self):
872          batch = BatchHttpRequest()
873          id_ = batch._new_id()
874          self.assertEqual("1", id_)
875          id_ = batch._new_id()
876          self.assertEqual("2", id_)
877          batch.add(self.request1, request_id="3")
878          id_ = batch._new_id()
879          self.assertEqual("4", id_)
880      def test_add(self):
881          batch = BatchHttpRequest()
882          batch.add(self.request1, request_id="1")
883          self.assertRaises(KeyError, batch.add, self.request1, request_id="1")
884      def test_add_fail_for_over_limit(self):
885          from googleapiclient.http import MAX_BATCH_LIMIT
886          batch = BatchHttpRequest()
887          for i in range(0, MAX_BATCH_LIMIT):
888              batch.add(
889                  HttpRequest(
890                      None,
891                      None,
892                      "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
893                      method="POST",
894                      body="{}",
895                      headers={"content-type": "application/json"},
896                  )
897              )
898          self.assertRaises(BatchError, batch.add, self.request1)
899      def test_add_fail_for_resumable(self):
900          batch = BatchHttpRequest()
901          upload = MediaFileUpload(datafile("small.png"), chunksize=500, resumable=True)
902          self.request1.resumable = upload
903          with self.assertRaises(BatchError) as batch_error:
904              batch.add(self.request1, request_id="1")
905          str(batch_error.exception)
906      def test_execute_empty_batch_no_http(self):
907          batch = BatchHttpRequest()
908          ret = batch.execute()
909          self.assertEqual(None, ret)
910      def test_execute(self):
911          batch = BatchHttpRequest()
912          callbacks = Callbacks()
913          batch.add(self.request1, callback=callbacks.f)
914          batch.add(self.request2, callback=callbacks.f)
915          http = HttpMockSequence(
916              [
917                  (
918                      {
919                          "status": "200",
920                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
921                      },
922                      BATCH_RESPONSE,
923                  )
924              ]
925          )
926          batch.execute(http=http)
927          self.assertEqual({"foo": 42}, callbacks.responses["1"])
928          self.assertEqual(None, callbacks.exceptions["1"])
929          self.assertEqual({"baz": "qux"}, callbacks.responses["2"])
930          self.assertEqual(None, callbacks.exceptions["2"])
931      def test_execute_request_body(self):
932          batch = BatchHttpRequest()
933          batch.add(self.request1)
934          batch.add(self.request2)
935          http = HttpMockSequence(
936              [
937                  (
938                      {
939                          "status": "200",
940                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
941                      },
942                      "echo_request_body",
943                  )
944              ]
945          )
946          try:
947              batch.execute(http=http)
948              self.fail("Should raise exception")
949          except BatchError as e:
950              boundary, _ = e.content.split(None, 1)
951              self.assertEqual("--", boundary[:2])
<span onclick='openModal()' class='match'>952              parts = e.content.split(boundary)
953              self.assertEqual(4, len(parts))
954              self.assertEqual("", parts[0])
955              self.assertEqual("--", parts[3].rstrip())
</span>956              header = parts[1].splitlines()[1]
957              self.assertEqual("Content-Type: application/http", header)
958      def test_execute_request_body_with_custom_long_request_ids(self):
959          batch = BatchHttpRequest()
960          batch.add(self.request1, request_id="abc" * 20)
961          batch.add(self.request2, request_id="def" * 20)
962          http = HttpMockSequence(
963              [
964                  (
965                      {
966                          "status": "200",
967                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
968                      },
969                      "echo_request_body",
970                  )
971              ]
972          )
973          try:
974              batch.execute(http=http)
975              self.fail("Should raise exception")
976          except BatchError as e:
977              boundary, _ = e.content.split(None, 1)
978              self.assertEqual("--", boundary[:2])
979              parts = e.content.split(boundary)
980              self.assertEqual(4, len(parts))
981              self.assertEqual("", parts[0])
982              self.assertEqual("--", parts[3].rstrip())
983              for partindex, request_id in ((1, "abc" * 20), (2, "def" * 20)):
984                  lines = parts[partindex].splitlines()
985                  for n, line in enumerate(lines):
986                      if line.startswith("Content-ID:"):
987                          self.assertTrue(line.endswith("+"), line)
988                          header_continuation = lines[n + 1]
989                          self.assertEqual(
990                              header_continuation,
991                              " %s>" % request_id,
992                              header_continuation,
993                          )
994      def test_execute_initial_refresh_oauth2(self):
995          batch = BatchHttpRequest()
996          callbacks = Callbacks()
997          cred = MockCredentials("Foo", expired=True)
998          http = HttpMockSequence(
999              [
1000                  (
1001                      {
1002                          "status": "200",
1003                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1004                      },
1005                      BATCH_SINGLE_RESPONSE,
1006                  )
1007              ]
1008          )
1009          cred.authorize(http)
1010          batch.add(self.request1, callback=callbacks.f)
1011          batch.execute(http=http)
1012          self.assertEqual({"foo": 42}, callbacks.responses["1"])
1013          self.assertIsNone(callbacks.exceptions["1"])
1014          self.assertEqual(1, cred._refreshed)
1015          self.assertEqual(1, cred._authorized)
1016          self.assertEqual(1, cred._applied)
1017      def test_execute_refresh_and_retry_on_401(self):
1018          batch = BatchHttpRequest()
1019          callbacks = Callbacks()
1020          cred_1 = MockCredentials("Foo")
1021          cred_2 = MockCredentials("Bar")
1022          http = HttpMockSequence(
1023              [
1024                  (
1025                      {
1026                          "status": "200",
1027                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1028                      },
1029                      BATCH_RESPONSE_WITH_401,
1030                  ),
1031                  (
1032                      {
1033                          "status": "200",
1034                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1035                      },
1036                      BATCH_SINGLE_RESPONSE,
1037                  ),
1038              ]
1039          )
1040          creds_http_1 = HttpMockSequence([])
1041          cred_1.authorize(creds_http_1)
1042          creds_http_2 = HttpMockSequence([])
1043          cred_2.authorize(creds_http_2)
1044          self.request1.http = creds_http_1
1045          self.request2.http = creds_http_2
1046          batch.add(self.request1, callback=callbacks.f)
1047          batch.add(self.request2, callback=callbacks.f)
1048          batch.execute(http=http)
1049          self.assertEqual({"foo": 42}, callbacks.responses["1"])
1050          self.assertEqual(None, callbacks.exceptions["1"])
1051          self.assertEqual({"baz": "qux"}, callbacks.responses["2"])
1052          self.assertEqual(None, callbacks.exceptions["2"])
1053          self.assertEqual(1, cred_1._refreshed)
1054          self.assertEqual(0, cred_2._refreshed)
1055          self.assertEqual(1, cred_1._authorized)
1056          self.assertEqual(1, cred_2._authorized)
1057          self.assertEqual(1, cred_2._applied)
1058          self.assertEqual(2, cred_1._applied)
1059      def test_http_errors_passed_to_callback(self):
1060          batch = BatchHttpRequest()
1061          callbacks = Callbacks()
1062          cred_1 = MockCredentials("Foo")
1063          cred_2 = MockCredentials("Bar")
1064          http = HttpMockSequence(
1065              [
1066                  (
1067                      {
1068                          "status": "200",
1069                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1070                      },
1071                      BATCH_RESPONSE_WITH_401,
1072                  ),
1073                  (
1074                      {
1075                          "status": "200",
1076                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1077                      },
1078                      BATCH_RESPONSE_WITH_401,
1079                  ),
1080              ]
1081          )
1082          creds_http_1 = HttpMockSequence([])
1083          cred_1.authorize(creds_http_1)
1084          creds_http_2 = HttpMockSequence([])
1085          cred_2.authorize(creds_http_2)
1086          self.request1.http = creds_http_1
1087          self.request2.http = creds_http_2
1088          batch.add(self.request1, callback=callbacks.f)
1089          batch.add(self.request2, callback=callbacks.f)
1090          batch.execute(http=http)
1091          self.assertEqual(None, callbacks.responses["1"])
1092          self.assertEqual(401, callbacks.exceptions["1"].resp.status)
1093          self.assertEqual(
1094              "Authorization Required", callbacks.exceptions["1"].resp.reason
1095          )
1096          self.assertEqual({"baz": "qux"}, callbacks.responses["2"])
1097          self.assertEqual(None, callbacks.exceptions["2"])
1098      def test_execute_global_callback(self):
1099          callbacks = Callbacks()
1100          batch = BatchHttpRequest(callback=callbacks.f)
1101          batch.add(self.request1)
1102          batch.add(self.request2)
1103          http = HttpMockSequence(
1104              [
1105                  (
1106                      {
1107                          "status": "200",
1108                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1109                      },
1110                      BATCH_RESPONSE,
1111                  )
1112              ]
1113          )
1114          batch.execute(http=http)
1115          self.assertEqual({"foo": 42}, callbacks.responses["1"])
1116          self.assertEqual({"baz": "qux"}, callbacks.responses["2"])
1117      def test_execute_batch_http_error(self):
1118          callbacks = Callbacks()
1119          batch = BatchHttpRequest(callback=callbacks.f)
1120          batch.add(self.request1)
1121          batch.add(self.request2)
1122          http = HttpMockSequence(
1123              [
1124                  (
1125                      {
1126                          "status": "200",
1127                          "content-type": 'multipart/mixed; boundary="batch_foobarbaz"',
1128                      },
1129                      BATCH_ERROR_RESPONSE,
1130                  )
1131              ]
1132          )
1133          batch.execute(http=http)
1134          self.assertEqual({"foo": 42}, callbacks.responses["1"])
1135          expected = (
1136              "<HttpError 403 when requesting "
1137              "https://www.googleapis.com/someapi/v1/collection/?foo=bar returned "
1138              '"Access Not Configured". '
1139              "Details: \"[{'domain': 'usageLimits', 'reason': 'accessNotConfigured', 'message': 'Access Not Configured', 'debugInfo': 'QuotaState: BLOCKED'}]\">"
1140          )
1141          self.assertEqual(expected, str(callbacks.exceptions["2"]))
1142  class TestRequestUriTooLong(unittest.TestCase):
1143      def test_turn_get_into_post(self):
1144          def _postproc(resp, content):
1145              return content
1146          http = HttpMockSequence(
1147              [
1148                  ({"status": "200"}, "echo_request_body"),
1149                  ({"status": "200"}, "echo_request_headers"),
1150              ]
1151          )
1152          query = {"q": "a" * MAX_URI_LENGTH + "?&"}
1153          req = HttpRequest(
1154              http,
1155              _postproc,
1156              "http://example.com?" + urllib.parse.urlencode(query),
1157              method="GET",
1158              body=None,
1159              headers={},
1160              methodId="foo",
1161              resumable=None,
1162          )
1163          response = req.execute()
1164          self.assertEqual(b"q=" + b"a" * MAX_URI_LENGTH + b"%3F%26", response)
1165          response = req.execute()
1166          self.assertEqual("GET", response["x-http-method-override"])
1167          self.assertEqual(str(MAX_URI_LENGTH + 8), response["content-length"])
1168          self.assertEqual("application/x-www-form-urlencoded", response["content-type"])
1169  class TestStreamSlice(unittest.TestCase):
1170      def setUp(self):
1171          self.stream = io.BytesIO(b"0123456789")
1172      def test_read(self):
1173          s = _StreamSlice(self.stream, 0, 4)
1174          self.assertEqual(b"", s.read(0))
1175          self.assertEqual(b"0", s.read(1))
1176          self.assertEqual(b"123", s.read())
1177      def test_read_too_much(self):
1178          s = _StreamSlice(self.stream, 1, 4)
1179          self.assertEqual(b"1234", s.read(6))
1180      def test_read_all(self):
1181          s = _StreamSlice(self.stream, 2, 1)
1182          self.assertEqual(b"2", s.read(-1))
1183  class TestResponseCallback(unittest.TestCase):
1184      def test_ensure_response_callback(self):
1185          m = JsonModel()
1186          request = HttpRequest(
1187              None,
1188              m.response,
1189              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
1190              method="POST",
1191              body="{}",
1192              headers={"content-type": "application/json"},
1193          )
1194          h = HttpMockSequence([({"status": 200}, "{}")])
1195          responses = []
1196          def _on_response(resp, responses=responses):
1197              responses.append(resp)
1198          request.add_response_callback(_on_response)
1199          request.execute(http=h)
1200          self.assertEqual(1, len(responses))
1201  class TestHttpMock(unittest.TestCase):
1202      def test_default_response_headers(self):
1203          http = HttpMock(datafile("zoo.json"))
1204          resp, content = http.request("http://example.com")
1205          self.assertEqual(resp.status, 200)
1206      def test_error_response(self):
1207          http = HttpMock(datafile("bad_request.json"), {"status": "400"})
1208          model = JsonModel()
1209          request = HttpRequest(
1210              http,
1211              model.response,
1212              "https://www.googleapis.com/someapi/v1/collection/?foo=bar",
1213              method="GET",
1214              headers={},
1215          )
1216          self.assertRaises(HttpError, request.execute)
1217  class TestHttpBuild(unittest.TestCase):
1218      original_socket_default_timeout = None
1219      @classmethod
1220      def setUpClass(cls):
1221          cls.original_socket_default_timeout = socket.getdefaulttimeout()
1222      @classmethod
1223      def tearDownClass(cls):
1224          socket.setdefaulttimeout(cls.original_socket_default_timeout)
1225      def test_build_http_sets_default_timeout_if_none_specified(self):
1226          socket.setdefaulttimeout(None)
1227          http = build_http()
1228          self.assertIsInstance(http.timeout, int)
1229          self.assertGreater(http.timeout, 0)
1230      def test_build_http_default_timeout_can_be_overridden(self):
1231          socket.setdefaulttimeout(1.5)
1232          http = build_http()
1233          self.assertAlmostEqual(http.timeout, 1.5, delta=0.001)
1234      def test_build_http_default_timeout_can_be_set_to_zero(self):
1235          socket.setdefaulttimeout(0)
1236          http = build_http()
1237          self.assertEqual(http.timeout, 0)
1238      def test_build_http_default_308_is_excluded_as_redirect(self):
1239          http = build_http()
1240          self.assertTrue(308 not in http.redirect_codes)
1241  if __name__ == "__main__":
1242      logging.getLogger().setLevel(logging.ERROR)
1243      unittest.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-test_http.py</div>
                </div>
                <div class="column column_space"><pre><code>219          if self.get_bitstring().all(False):
220              print(
221                  "[{:02}] {:20} is empty, will burn the new value".format(
222                      self.id, self.name
</pre></code></div>
                <div class="column column_space"><pre><code>952              parts = e.content.split(boundary)
953              self.assertEqual(4, len(parts))
954              self.assertEqual("", parts[0])
955              self.assertEqual("--", parts[3].rstrip())
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    