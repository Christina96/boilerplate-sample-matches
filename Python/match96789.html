<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cloud_4.py &amp; composer_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cloud_4.py &amp; composer_1.py
      </h3>
<h1 align="center">
        3.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cloud_4.py (1.8475751%)<th>composer_1.py (35.714287%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1414-1436)<td><a href="#" name="0">(52-72)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1932-1950)<td><a href="#" name="1">(201-279)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1124-1144)<td><a href="#" name="2">(295-311)</a><td align="center"><font color="#b60000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1204-1217)<td><a href="#" name="3">(376-389)</a><td align="center"><font color="#aa0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1437-1449)<td><a href="#" name="4">(281-293)</a><td align="center"><font color="#9d0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cloud_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import codecs
2 import copy
3 import errno
4 import hashlib
5 import logging
6 import multiprocessing
7 import os
8 import pipes
9 import re
10 import shutil
11 import socket
12 import stat
13 import subprocess
14 import tempfile
15 import time
16 import traceback
17 import uuid
18 import salt.client
19 import salt.cloud
20 import salt.config
21 import salt.crypt
22 import salt.loader
23 import salt.template
24 import salt.utils.compat
25 import salt.utils.crypt
26 import salt.utils.data
27 import salt.utils.event
28 import salt.utils.files
29 import salt.utils.msgpack
30 import salt.utils.path
31 import salt.utils.platform
32 import salt.utils.stringutils
33 import salt.utils.versions
34 import salt.utils.vt
35 import salt.utils.yaml
36 from jinja2 import Template
37 from salt.exceptions import (
38     SaltCloudConfigError,
39     SaltCloudException,
40     SaltCloudExecutionFailure,
41     SaltCloudExecutionTimeout,
42     SaltCloudPasswordError,
43     SaltCloudSystemExit,
44 )
45 from salt.utils.nb_popen import NonBlockingPopen
46 from salt.utils.validate.path import is_writeable
47 try:
48     import salt.utils.smb
49     HAS_SMB = True
50 except ImportError:
51     HAS_SMB = False
52 try:
53     from pypsexec.client import Client as PsExecClient
54     from pypsexec.scmr import Service as ScmrService
55     from pypsexec.exceptions import SCMRException
56     from smbprotocol.tree import TreeConnect
57     from smbprotocol.exceptions import SMBResponseException
58     logging.getLogger("smbprotocol").setLevel(logging.WARNING)
59     logging.getLogger("pypsexec").setLevel(logging.WARNING)
60     HAS_PSEXEC = True
61 except ImportError:
62     HAS_PSEXEC = False
63 WINRM_MIN_VER = "0.3.0"
64 try:
65     import winrm
66     from winrm.exceptions import WinRMTransportError
67     import pkg_resources  # pylint: disable=3rd-party-module-not-gated
68     winrm_pkg = pkg_resources.get_distribution("pywinrm")
69     if not salt.utils.versions.compare(winrm_pkg.version, "&gt;=", WINRM_MIN_VER):
70         HAS_WINRM = False
71     else:
72         HAS_WINRM = True
73 except ImportError:
74     HAS_WINRM = False
75 try:
76     import pwd
77 except ImportError:
78     if not salt.utils.platform.is_windows():
79         raise
80 try:
81     import getpass
82     HAS_GETPASS = True
83 except ImportError:
84     HAS_GETPASS = False
85 MSGPACK_ENCODING = "utf-8"
86 NSTATES = {
87     0: "running",
88     1: "rebooting",
89     2: "terminated",
90     3: "pending",
91 }
92 SSH_PASSWORD_PROMP_RE = re.compile(r"(?:.*)[Pp]assword(?: for .*)?:\ *$", re.M)
93 SSH_PASSWORD_PROMP_SUDO_RE = re.compile(
94     r"(?:.*sudo)(?:.*)[Pp]assword(?: for .*)?:", re.M
95 )
96 SERVER_ALIVE_INTERVAL = 60
97 SERVER_ALIVE_COUNT_MAX = 3
98 log = logging.getLogger(__name__)
99 def __render_script(path, vm_=None, opts=None, minion=""):
100     log.info("Rendering deploy script: %s", path)
101     try:
102         with salt.utils.files.fopen(path, "r") as fp_:
103             template = Template(salt.utils.stringutils.to_unicode(fp_.read()))
104             return str(template.render(opts=opts, vm=vm_, minion=minion))
105     except AttributeError:
106         with salt.utils.files.fopen(path, "r") as fp_:
107             return str(fp_.read())
108 def __ssh_gateway_config_dict(gateway):
109     extended_kwargs = {}
110     if gateway:
111         extended_kwargs["ssh_gateway"] = gateway["ssh_gateway"]
112         extended_kwargs["ssh_gateway_key"] = gateway["ssh_gateway_key"]
113         extended_kwargs["ssh_gateway_user"] = gateway["ssh_gateway_user"]
114         extended_kwargs["ssh_gateway_command"] = gateway["ssh_gateway_command"]
115     return extended_kwargs
116 def __ssh_gateway_arguments(kwargs):
117     extended_arguments = ""
118     ssh_gateway = kwargs.get("ssh_gateway", "")
119     ssh_gateway_port = 22
120     if ":" in ssh_gateway:
121         ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
122     ssh_gateway_command = kwargs.get("ssh_gateway_command", "nc -q0 %h %p")
123     if ssh_gateway:
124         ssh_gateway_port = kwargs.get("ssh_gateway_port", ssh_gateway_port)
125         ssh_gateway_key = (
126             "-i {}".format(kwargs["ssh_gateway_key"])
127             if "ssh_gateway_key" in kwargs
128             else ""
129         )
130         ssh_gateway_user = kwargs.get("ssh_gateway_user", "root")
131         extended_arguments = " ".join(
132             (
133                 "ssh",
134                 "-oStrictHostKeyChecking=no",
135                 "-oServerAliveInterval={}".format(
136                     kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
137                 ),
138                 "-oServerAliveCountMax={}".format(
139                     kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
140                 ),
141                 "-oUserKnownHostsFile=/dev/null",
142                 "-oControlPath=none",
143                 str(ssh_gateway_key),
144                 "{}@{}".format(ssh_gateway_user, ssh_gateway),
145                 "-p",
146                 str(ssh_gateway_port),
147                 str(ssh_gateway_command),
148             )
149         )
150         log.info(
151             "Using SSH gateway %s@%s:%s %s",
152             ssh_gateway_user,
153             ssh_gateway,
154             ssh_gateway_port,
155             ssh_gateway_command,
156         )
157     return extended_arguments
158 def os_script(os_, vm_=None, opts=None, minion=""):
159     if minion:
160         minion = salt_config_to_yaml(minion)
161     if os.path.isabs(os_):
162         return __render_script(os_, vm_, opts, minion)
163     if os.path.isabs("{}.sh".format(os_)):
164         return __render_script("{}.sh".format(os_), vm_, opts, minion)
165     for search_path in opts["deploy_scripts_search_path"]:
166         if os.path.isfile(os.path.join(search_path, os_)):
167             return __render_script(os.path.join(search_path, os_), vm_, opts, minion)
168         if os.path.isfile(os.path.join(search_path, "{}.sh".format(os_))):
169             return __render_script(
170                 os.path.join(search_path, "{}.sh".format(os_)), vm_, opts, minion
171             )
172     return ""
173 def gen_keys(keysize=2048):
174     if keysize &lt; 2048:
175         keysize = 2048
176     tdir = tempfile.mkdtemp()
177     salt.crypt.gen_keys(tdir, "minion", keysize)
178     priv_path = os.path.join(tdir, "minion.pem")
179     pub_path = os.path.join(tdir, "minion.pub")
180     with salt.utils.files.fopen(priv_path) as fp_:
181         priv = salt.utils.stringutils.to_unicode(fp_.read())
182     with salt.utils.files.fopen(pub_path) as fp_:
183         pub = salt.utils.stringutils.to_unicode(fp_.read())
184     shutil.rmtree(tdir)
185     return priv, pub
186 def accept_key(pki_dir, pub, id_):
187     for key_dir in "minions", "minions_pre", "minions_rejected":
188         key_path = os.path.join(pki_dir, key_dir)
189         if not os.path.exists(key_path):
190             os.makedirs(key_path)
191     key = os.path.join(pki_dir, "minions", id_)
192     with salt.utils.files.fopen(key, "w+") as fp_:
193         fp_.write(salt.utils.stringutils.to_str(pub))
194     oldkey = os.path.join(pki_dir, "minions_pre", id_)
195     if os.path.isfile(oldkey):
196         with salt.utils.files.fopen(oldkey) as fp_:
197             if fp_.read() == pub:
198                 os.remove(oldkey)
199 def remove_key(pki_dir, id_):
200     key = os.path.join(pki_dir, "minions", id_)
201     if os.path.isfile(key):
202         os.remove(key)
203         log.debug("Deleted '%s'", key)
204 def rename_key(pki_dir, id_, new_id):
205     oldkey = os.path.join(pki_dir, "minions", id_)
206     newkey = os.path.join(pki_dir, "minions", new_id)
207     if os.path.isfile(oldkey):
208         os.rename(oldkey, newkey)
209 def minion_config(opts, vm_):
210     minion = {
211         "master": "salt",
212         "log_level": "info",
213         "hash_type": "sha256",
214     }
215     minion["id"] = vm_["name"]
216     master_finger = salt.config.get_cloud_config_value("master_finger", vm_, opts)
217     if master_finger is not None:
218         minion["master_finger"] = master_finger
219     minion.update(
220         salt.config.get_cloud_config_value(
221             "minion", vm_, opts, default={}, search_global=True
222         )
223     )
224     make_master = salt.config.get_cloud_config_value("make_master", vm_, opts)
225     if "master" not in minion and make_master is not True:
226         raise SaltCloudConfigError(
227             "A master setting was not defined in the minion's configuration."
228         )
229     minion.setdefault("grains", {}).update(
230         salt.config.get_cloud_config_value(
231             "grains", vm_, opts, default={}, search_global=True
232         )
233     )
234     return minion
235 def master_config(opts, vm_):
236     master = copy.deepcopy(salt.config.DEFAULT_MASTER_OPTS)
237     master.update(log_level="info", log_level_logfile="info", hash_type="sha256")
238     master.update(
239         salt.config.get_cloud_config_value(
240             "master", vm_, opts, default={}, search_global=True
241         )
242     )
243     return master
244 def salt_config_to_yaml(configuration, line_break="\n"):
245     return salt.utils.yaml.safe_dump(
246         configuration, line_break=line_break, default_flow_style=False
247     )
248 def bootstrap(vm_, opts=None):
249     if opts is None:
250         opts = __opts__
251     deploy_config = salt.config.get_cloud_config_value(
252         "deploy", vm_, opts, default=False
253     )
254     inline_script_config = salt.config.get_cloud_config_value(
255         "inline_script", vm_, opts, default=None
256     )
257     if deploy_config is False and inline_script_config is None:
258         return {"Error": {"No Deploy": "'deploy' is not enabled. Not deploying."}}
259     if vm_.get("driver") == "saltify":
260         saltify_driver = True
261     else:
262         saltify_driver = False
263     key_filename = salt.config.get_cloud_config_value(
264         "key_filename",
265         vm_,
266         opts,
267         search_global=False,
268         default=salt.config.get_cloud_config_value(
269             "ssh_keyfile", vm_, opts, search_global=False, default=None
270         ),
271     )
272     if key_filename is not None and not os.path.isfile(key_filename):
273         raise SaltCloudConfigError(
274             "The defined ssh_keyfile '{}' does not exist".format(key_filename)
275         )
276     has_ssh_agent = False
277     if (
278         opts.get("ssh_agent", False)
279         and "SSH_AUTH_SOCK" in os.environ
280         and stat.S_ISSOCK(os.stat(os.environ["SSH_AUTH_SOCK"]).st_mode)
281     ):
282         has_ssh_agent = True
283     if (
284         key_filename is None
285         and salt.config.get_cloud_config_value("password", vm_, opts, default=None)
286         is None
287         and salt.config.get_cloud_config_value("win_password", vm_, opts, default=None)
288         is None
289         and has_ssh_agent is False
290     ):
291         raise SaltCloudSystemExit(
292             "Cannot deploy Salt in a VM if the 'key_filename' setting "
293             "is not set and there is no password set for the VM. "
294             "Check the provider docs for 'change_password' option if it "
295             "is supported by your provider."
296         )
297     ret = {}
298     minion_conf = minion_config(opts, vm_)
299     deploy_script_code = os_script(
300         salt.config.get_cloud_config_value("os", vm_, opts, default="bootstrap-salt"),
301         vm_,
302         opts,
303         minion_conf,
304     )
305     ssh_username = salt.config.get_cloud_config_value(
306         "ssh_username", vm_, opts, default="root"
307     )
308     if "file_transport" not in opts:
309         opts["file_transport"] = vm_.get("file_transport", "sftp")
310     if "pub_key" not in vm_ and "priv_key" not in vm_:
311         log.debug("Generating keys for '%s'", vm_["name"])
312         vm_["priv_key"], vm_["pub_key"] = gen_keys(
313             salt.config.get_cloud_config_value("keysize", vm_, opts)
314         )
315         key_id = vm_.get("name")
316         if "append_domain" in vm_:
317             key_id = ".".join([key_id, vm_["append_domain"]])
318         accept_key(opts["pki_dir"], vm_["pub_key"], key_id)
319     if "os" not in vm_:
320         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, opts)
321     host = salt.config.get_cloud_config_value("ssh_host", vm_, opts)
322     deploy_kwargs = {
323         "opts": opts,
324         "host": host,
325         "port": salt.config.get_cloud_config_value("ssh_port", vm_, opts, default=22),
326         "salt_host": vm_.get("salt_host", host),
327         "username": ssh_username,
328         "script": deploy_script_code,
329         "inline_script": inline_script_config,
330         "name": vm_["name"],
331         "has_ssh_agent": has_ssh_agent,
332         "tmp_dir": salt.config.get_cloud_config_value(
333             "tmp_dir", vm_, opts, default="/tmp/.saltcloud"
334         ),
335         "vm_": vm_,
336         "start_action": opts["start_action"],
337         "parallel": opts["parallel"],
338         "sock_dir": opts["sock_dir"],
339         "conf_file": opts["conf_file"],
340         "minion_pem": vm_["priv_key"],
341         "minion_pub": vm_["pub_key"],
342         "master_sign_pub_file": salt.config.get_cloud_config_value(
343             "master_sign_pub_file", vm_, opts, default=None
344         ),
345         "keep_tmp": opts["keep_tmp"],
346         "sudo": salt.config.get_cloud_config_value(
347             "sudo", vm_, opts, default=(ssh_username != "root")
348         ),
349         "sudo_password": salt.config.get_cloud_config_value(
350             "sudo_password", vm_, opts, default=None
351         ),
352         "tty": salt.config.get_cloud_config_value("tty", vm_, opts, default=True),
353         "password": salt.config.get_cloud_config_value(
354             "password", vm_, opts, search_global=False
355         ),
356         "key_filename": key_filename,
357         "script_args": salt.config.get_cloud_config_value("script_args", vm_, opts),
358         "script_env": salt.config.get_cloud_config_value("script_env", vm_, opts),
359         "minion_conf": minion_conf,
360         "force_minion_config": salt.config.get_cloud_config_value(
361             "force_minion_config", vm_, opts, default=False
362         ),
363         "preseed_minion_keys": vm_.get("preseed_minion_keys", None),
364         "display_ssh_output": salt.config.get_cloud_config_value(
365             "display_ssh_output", vm_, opts, default=True
366         ),
367         "known_hosts_file": salt.config.get_cloud_config_value(
368             "known_hosts_file", vm_, opts, default="/dev/null"
369         ),
370         "file_map": salt.config.get_cloud_config_value(
371             "file_map", vm_, opts, default=None
372         ),
373         "maxtries": salt.config.get_cloud_config_value(
374             "wait_for_passwd_maxtries", vm_, opts, default=15
375         ),
376         "preflight_cmds": salt.config.get_cloud_config_value(
377             "preflight_cmds", vm_, opts, default=[]
378         ),
379         "cloud_grains": {
380             "driver": vm_["driver"],
381             "provider": vm_["provider"],
382             "profile": vm_["profile"],
383         },
384     }
385     inline_script_kwargs = deploy_kwargs.copy()  # make a copy at this point
386     if "gateway" in vm_:
387         deploy_kwargs.update({"gateway": vm_["gateway"]})
388     if salt.config.get_cloud_config_value("make_master", vm_, opts) is True:
389         deploy_kwargs["make_master"] = True
390         deploy_kwargs["master_pub"] = vm_["master_pub"]
391         deploy_kwargs["master_pem"] = vm_["master_pem"]
392         master_conf = master_config(opts, vm_)
393         deploy_kwargs["master_conf"] = master_conf
394         if master_conf.get("syndic_master", None):
395             deploy_kwargs["make_syndic"] = True
396     deploy_kwargs["make_minion"] = salt.config.get_cloud_config_value(
397         "make_minion", vm_, opts, default=True
398     )
399     if saltify_driver:
400         deploy_kwargs[
401             "wait_for_passwd_maxtries"
402         ] = 0  # No need to wait/retry with Saltify
403     win_installer = salt.config.get_cloud_config_value("win_installer", vm_, opts)
404     if win_installer:
405         deploy_kwargs["port"] = salt.config.get_cloud_config_value(
406             "smb_port", vm_, opts, default=445
407         )
408         deploy_kwargs["win_installer"] = win_installer
409         minion = minion_config(opts, vm_)
410         deploy_kwargs["master"] = minion["master"]
411         deploy_kwargs["username"] = salt.config.get_cloud_config_value(
412             "win_username", vm_, opts, default="Administrator"
413         )
414         win_pass = salt.config.get_cloud_config_value(
415             "win_password", vm_, opts, default=""
416         )
417         if win_pass:
418             deploy_kwargs["password"] = win_pass
419         deploy_kwargs["use_winrm"] = salt.config.get_cloud_config_value(
420             "use_winrm", vm_, opts, default=False
421         )
422         deploy_kwargs["winrm_port"] = salt.config.get_cloud_config_value(
423             "winrm_port", vm_, opts, default=5986
424         )
425         deploy_kwargs["winrm_use_ssl"] = salt.config.get_cloud_config_value(
426             "winrm_use_ssl", vm_, opts, default=True
427         )
428         deploy_kwargs["winrm_verify_ssl"] = salt.config.get_cloud_config_value(
429             "winrm_verify_ssl", vm_, opts, default=True
430         )
431         if saltify_driver:
432             deploy_kwargs["port_timeout"] = 1  # No need to wait/retry with Saltify
433     event_kwargs = copy.deepcopy(deploy_kwargs)
434     del event_kwargs["opts"]
435     del event_kwargs["minion_pem"]
436     del event_kwargs["minion_pub"]
437     del event_kwargs["sudo_password"]
438     if "password" in event_kwargs:
439         del event_kwargs["password"]
440     ret["deploy_kwargs"] = event_kwargs
441     fire_event(
442         "event",
443         "executing deploy script",
444         "salt/cloud/{}/deploying".format(vm_["name"]),
445         args={"kwargs": salt.utils.data.simple_types_filter(event_kwargs)},
446         sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
447         transport=opts.get("transport", "zeromq"),
448     )
449     if inline_script_config and deploy_config is False:
450         inline_script_deployed = run_inline_script(**inline_script_kwargs)
451         if inline_script_deployed is not False:
452             log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
453         ret["deployed"] = False
454         return ret
455     else:
456         if win_installer:
457             deployed = deploy_windows(**deploy_kwargs)
458         else:
459             deployed = deploy_script(**deploy_kwargs)
460         if inline_script_config:
461             inline_script_deployed = run_inline_script(**inline_script_kwargs)
462             if inline_script_deployed is not False:
463                 log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
464         if deployed is not False:
465             ret["deployed"] = True
466             if deployed is not True:
467                 ret.update(deployed)
468             log.info("Salt installed on %s", vm_["name"])
469             return ret
470     log.error("Failed to start Salt on host %s", vm_["name"])
471     return {
472         "Error": {"Not Deployed": "Failed to start Salt on host {}".format(vm_["name"])}
473     }
474 def ssh_usernames(vm_, opts, default_users=None):
475     if default_users is None:
476         default_users = ["root"]
477     usernames = salt.config.get_cloud_config_value("ssh_username", vm_, opts)
478     if not isinstance(usernames, list):
479         usernames = [usernames]
480     usernames = [x for x in usernames if x]
481     initial = usernames[:]
482     for name in default_users:
483         if name not in usernames:
484             usernames.append(name)
485     usernames.extend(initial)
486     return usernames
487 def wait_for_fun(fun, timeout=900, **kwargs):
488     start = time.time()
489     log.debug("Attempting function %s", fun)
490     trycount = 0
491     while True:
492         trycount += 1
493         try:
494             response = fun(**kwargs)
495             if not isinstance(response, bool):
496                 return response
497         except Exception as exc:  # pylint: disable=broad-except
498             log.debug("Caught exception in wait_for_fun: %s", exc)
499             time.sleep(1)
500             log.debug("Retrying function %s on  (try %s)", fun, trycount)
501         if time.time() - start &gt; timeout:
502             log.error("Function timed out: %s", timeout)
503             return False
504 def wait_for_port(
505     host,
506     port=22,
507     timeout=900,
508     gateway=None,
509     server_alive_interval=SERVER_ALIVE_INTERVAL,
510     server_alive_count_max=SERVER_ALIVE_COUNT_MAX,
511 ):
512     start = time.time()
513     test_ssh_host = host
514     test_ssh_port = port
515     if gateway:
516         ssh_gateway = gateway["ssh_gateway"]
517         ssh_gateway_port = 22
518         if ":" in ssh_gateway:
519             ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
520         if "ssh_gateway_port" in gateway:
521             ssh_gateway_port = gateway["ssh_gateway_port"]
522         test_ssh_host = ssh_gateway
523         test_ssh_port = ssh_gateway_port
524         log.debug(
525             "Attempting connection to host %s on port %s via gateway %s on port %s",
526             host,
527             port,
528             ssh_gateway,
529             ssh_gateway_port,
530         )
531     else:
532         log.debug("Attempting connection to host %s on port %s", host, port)
533     trycount = 0
534     while True:
535         trycount += 1
536         try:
537             if socket.inet_pton(socket.AF_INET6, host):
538                 sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
539             else:
540                 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
541         except OSError:
542             sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
543         try:
544             sock.settimeout(5)
545             sock.connect((test_ssh_host, int(test_ssh_port)))
546             sock.shutdown(socket.SHUT_RDWR)
547             sock.close()
548             break
549         except OSError as exc:
550             log.debug("Caught exception in wait_for_port: %s", exc)
551             time.sleep(1)
552             if time.time() - start &gt; timeout:
553                 log.error("Port connection timed out: %s", timeout)
554                 return False
555             log.debug(
556                 "Retrying connection to %s %s on port %s (try %s)",
557                 "gateway" if gateway else "host",
558                 test_ssh_host,
559                 test_ssh_port,
560                 trycount,
561             )
562     if not gateway:
563         return True
564     log.debug("Gateway %s on port %s is reachable.", test_ssh_host, test_ssh_port)
565     ssh_args = []
566     ssh_args.extend(
567         [
568             "-oStrictHostKeyChecking=no",
569             "-oServerAliveInterval={}".format(server_alive_interval),
570             "-oServerAliveCountMax={}".format(server_alive_count_max),
571             "-oUserKnownHostsFile=/dev/null",
572             "-oControlPath=none",
573         ]
574     )
575     if "ssh_gateway_key" in gateway:
576         ssh_args.extend(
577             [
578                 "-oPasswordAuthentication=no",
579                 "-oChallengeResponseAuthentication=no",
580                 "-oPubkeyAuthentication=yes",
581                 "-oIdentitiesOnly=yes",
582                 "-oKbdInteractiveAuthentication=no",
583                 "-i {}".format(gateway["ssh_gateway_key"]),
584             ]
585         )
586     command = "nc -z -w5 -q0 {} {}".format(host, port)
587     pcmd = "ssh {} {}@{} -p {} {}".format(
588         " ".join(ssh_args),
589         gateway["ssh_gateway_user"],
590         ssh_gateway,
591         ssh_gateway_port,
592         pipes.quote("date"),
593     )
594     cmd = "ssh {} {}@{} -p {} {}".format(
595         " ".join(ssh_args),
596         gateway["ssh_gateway_user"],
597         ssh_gateway,
598         ssh_gateway_port,
599         pipes.quote(command),
600     )
601     log.debug("SSH command: '%s'", cmd)
602     kwargs = {
603         "display_ssh_output": False,
604         "password": gateway.get("ssh_gateway_password", None),
605     }
606     trycount = 0
607     usable_gateway = False
608     gateway_retries = 5
609     while True:
610         trycount += 1
611         if not usable_gateway:
612             pstatus = _exec_ssh_cmd(pcmd, allow_failure=True, **kwargs)
613             if pstatus == 0:
614                 usable_gateway = True
615             else:
616                 gateway_retries -= 1
617                 log.error(
618                     "Gateway usage seems to be broken, password error ? Tries left: %s",
619                     gateway_retries,
620                 )
621             if not gateway_retries:
622                 raise SaltCloudExecutionFailure(
623                     "SSH gateway is reachable but we can not login"
624                 )
625         if usable_gateway:
626             status = _exec_ssh_cmd(cmd, allow_failure=True, **kwargs)
627             if status == 0:
628                 return True
629         time.sleep(1)
630         if time.time() - start &gt; timeout:
631             log.error("Port connection timed out: %s", timeout)
632             return False
633         log.debug(
634             "Retrying connection to host %s on port %s "
635             "via gateway %s on port %s. (try %s)",
636             host,
637             port,
638             ssh_gateway,
639             ssh_gateway_port,
640             trycount,
641         )
642 class Client:
643     def __init__(
644         self,
645         server,
646         username=None,
647         password=None,
648         port=445,
649         encrypt=True,
650         service_name=None,
651     ):
652         self.service_name = service_name
653         self._exe_file = "{}.exe".format(self.service_name)
654         self._client = PsExecClient(server, username, password, port, encrypt)
655         self._client._service = ScmrService(self.service_name, self._client.session)
656     def connect(self):
657         return self._client.connect()
658     def disconnect(self):
659         return self._client.disconnect()
660     def create_service(self):
661         return self._client.create_service()
662     def run_executable(self, *args, **kwargs):
663         return self._client.run_executable(*args, **kwargs)
664     def remove_service(self, wait_timeout=10, sleep_wait=1):
665         log.debug("Deleting PAExec service at the end of the process")
666         wait_start = time.time()
667         while True:
668             try:
669                 self._client._service.delete()
670             except SCMRException as exc:
671                 log.debug("Exception encountered while deleting service %s", repr(exc))
672                 if time.time() - wait_start &gt; wait_timeout:
673                     raise exc
674                 time.sleep(sleep_wait)
675                 continue
676             break
677         smb_tree = TreeConnect(
678             self._client.session,
679             r"\\{}\ADMIN$".format(self._client.connection.server_name),
680         )
681         log.info("Connecting to SMB Tree %s", smb_tree.share_name)
682         smb_tree.connect()
683         wait_start = time.time()
684         while True:
685             try:
686                 log.info("Creating open to PAExec file with delete on close flags")
687                 self._client._delete_file(smb_tree, self._exe_file)
688             except SMBResponseException as exc:
689                 log.debug("Exception deleting file %s %s", self._exe_file, repr(exc))
690                 if time.time() - wait_start &gt; wait_timeout:
691                     raise exc
692                 time.sleep(sleep_wait)
693                 continue
694             break
695         log.info("Disconnecting from SMB Tree %s", smb_tree.share_name)
696         smb_tree.disconnect()
697 def run_winexe_command(cmd, args, host, username, password, port=445):
698     creds = "-U '{}%{}' //{}".format(username, password, host)
699     logging_creds = "-U '{}%XXX-REDACTED-XXX' //{}".format(username, host)
700     cmd = "winexe {} {} {}".format(creds, cmd, args)
701     logging_cmd = "winexe {} {} {}".format(logging_creds, cmd, args)
702     return win_cmd(cmd, logging_command=logging_cmd)
703 def run_psexec_command(cmd, args, host, username, password, port=445):
704     service_name = "PS-Exec-{}".format(uuid.uuid4())
705     stdout, stderr, ret_code = "", "", None
706     client = Client(
707         host, username, password, port=port, encrypt=False, service_name=service_name
708     )
709     client.connect()
710     try:
711         client.create_service()
712         stdout, stderr, ret_code = client.run_executable(cmd, args)
713     finally:
714         client.remove_service()
715         client.disconnect()
716     return stdout, stderr, ret_code
717 def wait_for_winexe(host, port, username, password, timeout=900):
718     start = time.time()
719     log.debug("Attempting winexe connection to host %s on port %s", host, port)
720     try_count = 0
721     while True:
722         try_count += 1
723         try:
724             ret_code = run_winexe_command(
725                 "sc", "query winexesvc", host, username, password, port
726             )
727             if ret_code == 0:
728                 log.debug("winexe connected...")
729                 return True
730             log.debug("Return code was %s", ret_code)
731         except OSError as exc:
732             log.debug("Caught exception in wait_for_winexesvc: %s", exc)
733         if time.time() - start &gt; timeout:
734             return False
735         time.sleep(1)
736 def wait_for_psexecsvc(host, port, username, password, timeout=900):
737     start = time.time()
738     try_count = 0
739     while True:
740         try_count += 1
741         ret_code = 1
742         try:
743             stdout, stderr, ret_code = run_psexec_command(
744                 "cmd.exe", "/c hostname", host, username, password, port=port
745             )
746         except Exception as exc:  # pylint: disable=broad-except
747             log.exception("Unable to execute command")
748         if ret_code == 0:
749             log.debug("psexec connected...")
750             return True
751         if time.time() - start &gt; timeout:
752             return False
753         log.debug(
754             "Retrying psexec connection to host %s on port %s (try %s)",
755             host,
756             port,
757             try_count,
758         )
759         time.sleep(1)
760 def wait_for_winrm(
761     host, port, username, password, timeout=900, use_ssl=True, verify=True
762 ):
763     wait_for_port(host=host, port=port, timeout=timeout)
764     start = time.time()
765     log.debug("Attempting WinRM connection to host %s on port %s", host, port)
766     transport = "ssl"
767     if not use_ssl:
768         transport = "ntlm"
769     trycount = 0
770     while True:
771         trycount += 1
772         try:
773             winrm_kwargs = {
774                 "target": host,
775                 "auth": (username, password),
776                 "transport": transport,
777             }
778             if not verify:
779                 log.debug("SSL validation for WinRM disabled.")
780                 winrm_kwargs["server_cert_validation"] = "ignore"
781             s = winrm.Session(**winrm_kwargs)
782             if hasattr(s.protocol, "set_timeout"):
783                 s.protocol.set_timeout(15)
784             log.trace("WinRM endpoint url: %s", s.url)
785             r = s.run_cmd("sc query winrm")
786             if r.status_code == 0:
787                 log.debug("WinRM session connected...")
788                 return s
789             log.debug("Return code was %s", r.status_code)
790         except WinRMTransportError as exc:
791             log.debug("Caught exception in wait_for_winrm: %s", exc)
792         if time.time() - start &gt; timeout:
793             log.error("WinRM connection timed out: %s", timeout)
794             return None
795         log.debug(
796             "Retrying WinRM connection to host %s on port %s (try %s)",
797             host,
798             port,
799             trycount,
800         )
801         time.sleep(1)
802 def validate_windows_cred_winexe(
803     host, username="Administrator", password=None, retries=10, retry_delay=1
804 ):
805     cmd = "winexe -U '{}%{}' //{} \"hostname\"".format(username, password, host)
806     logging_cmd = "winexe -U '{}%XXX-REDACTED-XXX' //{} \"hostname\"".format(
807         username, host
808     )
809     for i in range(retries):
810         ret_code = win_cmd(cmd, logging_command=logging_cmd)
811     return ret_code == 0
812 def validate_windows_cred(
813     host, username="Administrator", password=None, retries=10, retry_delay=1
814 ):
815     for i in range(retries):
816         ret_code = 1
817         try:
818             stdout, stderr, ret_code = run_psexec_command(
819                 "cmd.exe", "/c hostname", host, username, password, port=445
820             )
821         except Exception as exc:  # pylint: disable=broad-except
822             log.exception("Exceoption while executing psexec")
823             break
824         time.sleep(retry_delay)
825     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret_code == 0
826 def wait_for_passwd(
827     host,
828     port=22,
829     ssh_timeout=15,
830     username="root",
831     password=None,
832     key_filename=None,
833     maxtries=15,
834     trysleep=1,
835     display_ssh_output=True,
836     gateway=None,
837     known_hosts_file="/dev/null",
838     hard_timeout=None,
839 ):
840     trycount =</b></font> 0
841     while trycount &lt; maxtries:
842         connectfail = False
843         try:
844             kwargs = {
845                 "hostname": host,
846                 "port": port,
847                 "username": username,
848                 "password_retries": maxtries,
849                 "timeout": ssh_timeout,
850                 "display_ssh_output": display_ssh_output,
851                 "known_hosts_file": known_hosts_file,
852                 "ssh_timeout": ssh_timeout,
853                 "hard_timeout": hard_timeout,
854             }
855             kwargs.update(__ssh_gateway_config_dict(gateway))
856             if key_filename:
857                 if not os.path.isfile(key_filename):
858                     raise SaltCloudConfigError(
859                         "The defined key_filename '{}' does not exist".format(
860                             key_filename
861                         )
862                     )
863                 kwargs["key_filename"] = key_filename
864                 log.debug("Using %s as the key_filename", key_filename)
865             elif password:
866                 kwargs["password"] = password
867                 log.debug("Using password authentication")
868             trycount += 1
869             log.debug(
870                 "Attempting to authenticate as %s (try %s of %s)",
871                 username,
872                 trycount,
873                 maxtries,
874             )
875             status = root_cmd("date", tty=False, sudo=False, **kwargs)
876             if status != 0:
877                 connectfail = True
878                 if trycount &lt; maxtries:
879                     time.sleep(trysleep)
880                     continue
881                 log.error("Authentication failed: status code %s", status)
882                 return False
883             if connectfail is False:
884                 return True
885             return False
886         except SaltCloudPasswordError:
887             raise
888         except Exception:  # pylint: disable=broad-except
889             if trycount &gt;= maxtries:
890                 return False
891             time.sleep(trysleep)
892 def deploy_windows(
893     host,
894     port<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=445,
895     timeout=900,
896     username="Administrator",
897     password=None,
898     name=None,
899     sock_dir=None,
900     conf_file=None,
901     start_action=None,
902     parallel=False,
903     minion_pub=None,
904     minion_pem=None,
905     minion_conf=None,
906     keep_tmp=False,
907     script_args=</b></font>None,
908     script_env=None,
909     port_timeout=15,
910     preseed_minion_keys=None,
911     win_installer=None,
912     master=None,
913     tmp_dir="C:\\salttmp",
914     opts=None,
915     master_sign_pub_file=None,
916     use_winrm=False,
917     winrm_port=5986,
918     winrm_use_ssl=True,
919     winrm_verify_ssl=True,
920     **kwargs
921 ):
922     if not isinstance(opts, dict):
923         opts = {}
924     if use_winrm and not HAS_WINRM:
925         log.error(
926             "WinRM requested but module winrm could not be imported. "
927             "Ensure you are using version %s or higher.",
928             WINRM_MIN_VER,
929         )
930         return False
931     starttime = time.mktime(time.localtime())
932     log.debug("Deploying %s at %s (Windows)", host, starttime)
933     log.trace("HAS_WINRM: %s, use_winrm: %s", HAS_WINRM, use_winrm)
934     port_available = wait_for_port(host=host, port=port, timeout=port_timeout * 60)
935     if not port_available:
936         return False
937     service_available = False
938     winrm_session = None
939     if HAS_WINRM and use_winrm:
940         winrm_session = wait_for_winrm(
941             host=host,
942             port=winrm_port,
943             username=username,
944             password=password,
945             timeout=port_timeout * 60,
946             use_ssl=winrm_use_ssl,
947             verify=winrm_verify_ssl,
948         )
949         if winrm_session is not None:
950             service_available = True
951     else:
952         service_available = wait_for_psexecsvc(
953             host=host,
954             port=port,
955             username=username,
956             password=password,
957             timeout=port_timeout * 60,
958         )
959     if port_available and service_available:
960         log.debug("SMB port %s on %s is available", port, host)
961         log.debug("Logging into %s:%s as %s", host, port, username)
962         smb_conn = salt.utils.smb.get_conn(host, username, password, port)
963         if smb_conn is False:
964             log.error("Please install smbprotocol to enable SMB functionality")
965             return False
966         salt.utils.smb.mkdirs("salttemp", conn=smb_conn)
967         salt.utils.smb.mkdirs("salt/conf/pki/minion", conn=smb_conn)
968         if minion_pub:
969             salt.utils.smb.put_str(
970                 minion_pub, "salt\\conf\\pki\\minion\\minion.pub", conn=smb_conn
971             )
972         if minion_pem:
973             salt.utils.smb.put_str(
974                 minion_pem, "salt\\conf\\pki\\minion\\minion.pem", conn=smb_conn
975             )
976         if master_sign_pub_file:
977             log.debug(
978                 "Copying master_sign.pub file from %s to minion", master_sign_pub_file
979             )
980             try:
981                 salt.utils.smb.put_file(
982                     master_sign_pub_file,
983                     "salt\\conf\\pki\\minion\\master_sign.pub",
984                     "C$",
985                     conn=smb_conn,
986                 )
987             except Exception as e:  # pylint: disable=broad-except
988                 log.debug(
989                     "Exception copying master_sign.pub file %s to minion",
990                     master_sign_pub_file,
991                 )
992         comps = win_installer.split("/")
993         local_path = "/".join(comps[:-1])
994         installer = comps[-1]
995         salt.utils.smb.put_file(
996             win_installer,
997             "salttemp\\{}".format(installer),
998             "C$",
999             conn=smb_conn,
1000         )
1001         if use_winrm:
1002             winrm_cmd(
1003                 winrm_session,
1004                 "c:\\salttemp\\{}".format(installer),
1005                 ["/S", "/master={}".format(master), "/minion-name={}".format(name)],
1006             )
1007         else:
1008             cmd = "c:\\salttemp\\{}".format(installer)
1009             args = "/S /master={} /minion-name={}".format(master, name)
1010             stdout, stderr, ret_code = run_psexec_command(
1011                 cmd, args, host, username, password
1012             )
1013             if ret_code != 0:
1014                 raise Exception("Fail installer {}".format(ret_code))
1015         if minion_conf:
1016             if not isinstance(minion_conf, dict):
1017                 raise DeprecationWarning(
1018                     "`salt.utils.cloud.deploy_windows` now only accepts "
1019                     "dictionaries for its `minion_conf` parameter. "
1020                     "Loading YAML..."
1021                 )
1022             minion_grains = minion_conf.pop("grains", {})
1023             if minion_grains:
1024                 salt.utils.smb.put_str(
1025                     salt_config_to_yaml(minion_grains, line_break="\r\n"),
1026                     "salt\\conf\\grains",
1027                     conn=smb_conn,
1028                 )
1029             windows_minion_conf = {
1030                 "ipc_mode": "tcp",
1031                 "root_dir": "c:\\salt",
1032                 "pki_dir": "/conf/pki/minion",
1033                 "multiprocessing": False,
1034             }
1035             minion_conf = dict(minion_conf, **windows_minion_conf)
1036             salt.utils.smb.put_str(
1037                 salt_config_to_yaml(minion_conf, line_break="\r\n"),
1038                 "salt\\conf\\minion",
1039                 conn=smb_conn,
1040             )
1041         if not keep_tmp:
1042             if use_winrm:
1043                 winrm_cmd(winrm_session, "rmdir", ["/Q", "/S", "C:\\salttemp\\"])
1044             else:
1045                 salt.utils.smb.delete_file(
1046                     "salttemp\\{}".format(installer), "C$", conn=smb_conn
1047                 )
1048                 salt.utils.smb.delete_directory("salttemp", "C$", conn=smb_conn)
1049         if use_winrm:
1050             winrm_cmd(winrm_session, "net", ["stop", "salt-minion"])
1051             winrm_cmd(winrm_session, "net", ["start", "salt-minion"])
1052         else:
1053             stdout, stderr, ret_code = run_psexec_command(
1054                 "cmd.exe", "/c net stop salt-minion", host, username, password
1055             )
1056             if ret_code != 0:
1057                 return False
1058             log.debug("Run psexec: sc start salt-minion")
1059             stdout, stderr, ret_code = run_psexec_command(
1060                 "cmd.exe", "/c net start salt-minion", host, username, password
1061             )
1062             if ret_code != 0:
1063                 return False
1064         fire_event(
1065             "event",
1066             "{} has been deployed at {}".format(name, host),
1067             args={"name": name},
1068             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
1069             transport=opts<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("transport", "zeromq"),
1070         )
1071         return True
1072     return False
1073 def deploy_script(
1074     host,
1075     port=22,
1076     timeout=900,
1077     username="root",
1078     password=None,
1079     key_filename=None,
1080     script=None,
1081     name=None,
1082     sock_dir=None,
1083     provider=None,
1084     conf_file=None,
1085     start_action=None,
1086     master_pub=None,
1087     master_pem=</b></font>None,
1088     master_conf<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
1089     minion_pub=None,
1090     minion_pem=None,
1091     minion_conf=None,
1092     keep_tmp=False,
1093     script_args=None,
1094     script_env=None,
1095     ssh_timeout=15,
1096     maxtries=15,
1097     make_syndic=False,
1098     make_minion=True,
1099     display_ssh_output=True,
1100     preseed_minion_keys=</b></font>None,
1101     parallel=False,
1102     sudo_password=None,
1103     sudo=False,
1104     tty=None,
1105     vm_=None,
1106     opts=None,
1107     tmp_dir="/tmp/.saltcloud",
1108     file_map=None,
1109     master_sign_pub_file=None,
1110     cloud_grains=None,
1111     force_minion_config=False,
1112     **kwargs
1113 ):
1114     if not isinstance(opts, dict):
1115         opts = {}
1116     vm_ = vm_ or {}  # if None, default to empty dict
1117     cloud_grains = cloud_grains or {}
1118     tmp_dir = "{}-{}".format(tmp_dir.rstrip("/"), uuid.uuid4())
1119     deploy_command = salt.config.get_cloud_config_value(
1120         "deploy_command", vm_, opts, default=os.path.join(tmp_dir, "deploy.sh")
1121     )
1122     if key_filename is not None and not os.path.isfile(key_filename):
1123         raise SaltCloudConfigError(
1124             "The defined key_filename '{}' does not exist".format(key_filename)
1125         )
1126     gateway = None
1127     if "gateway" in kwargs:
1128         gateway = kwargs["gateway"]
1129     starttime = time.localtime()
1130     log.debug("Deploying %s at %s", host, time.strftime("%Y-%m-%d %H:%M:%S", starttime))
1131     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1132     hard_timeout = opts.get("hard_timeout", None)
1133     if wait_for_port(host=host, port=port, gateway=gateway):
1134         log.debug("SSH port %s on %s is available", port, host)
1135         if wait_for_passwd(
1136             host,
1137             port=port,
1138             username=username,
1139             password=password,
1140             key_filename=key_filename,
1141             ssh_timeout=ssh_timeout,
1142             display_ssh_output=display_ssh_output,
1143             gateway=gateway,
1144             known_hosts_file=known_hosts_file,
1145             maxtries=maxtries,
1146             hard_timeout=hard_timeout,
1147         ):
1148             log.debug("Logging into %s:%s as %s", host, port, username)
1149             ssh_kwargs = {
1150                 "hostname": host,
1151                 "port": port,
1152                 "username": username,
1153                 "timeout": ssh_timeout,
1154                 "ssh_timeout": ssh_timeout,
1155                 "display_ssh_output": display_ssh_output,
1156                 "sudo_password": sudo_password,
1157                 "sftp": opts.get("use_sftp", False),
1158             }
1159             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1160             if key_filename:
1161                 log.debug("Using %s as the key_filename", key_filename)
1162                 ssh_kwargs["key_filename"] = key_filename
1163             elif password and kwargs.get("has_ssh_agent", False) is False:
1164                 ssh_kwargs["password"] = password
1165             if root_cmd(
1166                 "test -e '{}'".format(tmp_dir),
1167                 tty,
1168                 sudo,
1169                 allow_failure=True,
1170                 **ssh_kwargs
1171             ):
1172                 ret = root_cmd(
1173                     "sh -c \"( mkdir -p -m 700 '{}' )\"".format(tmp_dir),
1174                     tty,
1175                     sudo,
1176                     **ssh_kwargs
1177                 )
1178                 if ret:
1179                     raise SaltCloudSystemExit(
1180                         "Can't create temporary directory in {} !".format(tmp_dir)
1181                     )
1182             if sudo:
1183                 comps = tmp_dir.lstrip("/").rstrip("/").split("/")
1184                 if comps:
1185                     if len(comps) &gt; 1 or comps[0] != "tmp":
1186                         ret = root_cmd(
1187                             'chown {} "{}"'.format(username, tmp_dir),
1188                             tty,
1189                             sudo,
1190                             **ssh_kwargs
1191                         )
1192                         if ret:
1193                             raise SaltCloudSystemExit(
1194                                 "Cant set {} ownership on {}".format(username, tmp_dir)
1195                             )
1196             if not isinstance(file_map, dict):
1197                 file_map = {}
1198             remote_dirs = []
1199             file_map_success = []
1200             file_map_fail = []
1201             for map_item in file_map:
1202                 local_file = map_item
1203                 remote_file = file_map[map_item]
1204                 if not os.path.exists(map_item):
1205                     log.error(
1206                         'The local file "%s" does not exist, and will not be '
1207                         'copied to "%s" on the target system',
1208                         local_file,
1209                         remote_file,
1210                     )
1211                     file_map_fail.append({local_file: remote_file})
1212                     continue
1213                 if os.path.isdir(local_file):
1214                     dir_name = os.path.basename(local_file)
1215                     remote_dir = os.path.join(os.path.dirname(remote_file), dir_name)
1216                 else:
1217                     remote_dir = os.path.dirname(remote_file)
1218                 if remote_dir not in remote_dirs:
1219                     root_cmd(
1220                         "mkdir -p '{}'".format(remote_dir), tty, sudo, **ssh_kwargs
1221                     )
1222                     if ssh_kwargs["username"] != "root":
1223                         root_cmd(
1224                             "chown {} '{}'".format(ssh_kwargs["username"], remote_dir),
1225                             tty,
1226                             sudo,
1227                             **ssh_kwargs
1228                         )
1229                     remote_dirs.append(remote_dir)
1230                 ssh_file(opts, remote_file, kwargs=ssh_kwargs, local_file=local_file)
1231                 file_map_success.append({local_file: remote_file})
1232             if minion_pem:
1233                 ssh_file(opts, "{}/minion.pem".format(tmp_dir), minion_pem, ssh_kwargs)
1234                 ret = root_cmd(
1235                     "chmod 600 '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1236                 )
1237                 if ret:
1238                     raise SaltCloudSystemExit(
1239                         "Can't set perms on {}/minion.pem".format(tmp_dir)
1240                     )
1241             if minion_pub:
1242                 ssh_file(opts, "{}/minion.pub".format(tmp_dir), minion_pub, ssh_kwargs)
1243             if master_sign_pub_file:
1244                 ssh_file(
1245                     opts,
1246                     "{}/master_sign.pub".format(tmp_dir),
1247                     kwargs=ssh_kwargs,
1248                     local_file=master_sign_pub_file,
1249                 )
1250             if minion_conf:
1251                 if not isinstance(minion_conf, dict):
1252                     raise DeprecationWarning(
1253                         "`salt.utils.cloud.deploy_script now only accepts "
1254                         "dictionaries for it's `minion_conf` parameter. "
1255                         "Loading YAML..."
1256                     )
1257                 minion_grains = minion_conf.pop("grains", {})
1258                 if minion_grains:
1259                     ssh_file(
1260                         opts,
1261                         "{}/grains".format(tmp_dir),
1262                         salt_config_to_yaml(minion_grains),
1263                         ssh_kwargs,
1264                     )
1265                 if cloud_grains and opts.get("enable_cloud_grains", True):
1266                     minion_conf["grains"] = {"salt-cloud": cloud_grains}
1267                 ssh_file(
1268                     opts,
1269                     "{}/minion".format(tmp_dir),
1270                     salt_config_to_yaml(minion_conf),
1271                     ssh_kwargs,
1272                 )
1273             if master_pem:
1274                 ssh_file(opts, "{}/master.pem".format(tmp_dir), master_pem, ssh_kwargs)
1275                 ret = root_cmd(
1276                     "chmod 600 '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1277                 )
1278                 if ret:
1279                     raise SaltCloudSystemExit(
1280                         "Cant set perms on {}/master.pem".format(tmp_dir)
1281                     )
1282             if master_pub:
1283                 ssh_file(opts, "{}/master.pub".format(tmp_dir), master_pub, ssh_kwargs)
1284             if master_conf:
1285                 if not isinstance(master_conf, dict):
1286                     raise DeprecationWarning(
1287                         "`salt.utils.cloud.deploy_script now only accepts "
1288                         "dictionaries for it's `master_conf` parameter. "
1289                         "Loading from YAML ..."
1290                     )
1291                 ssh_file(
1292                     opts,
1293                     "{}/master".format(tmp_dir),
1294                     salt_config_to_yaml(master_conf),
1295                     ssh_kwargs,
1296                 )
1297             preseed_minion_keys_tempdir = "{}/preseed-minion-keys".format(tmp_dir)
1298             if preseed_minion_keys is not None:
1299                 ret = root_cmd(
1300                     "mkdir '{}'".format(preseed_minion_keys_tempdir),
1301                     tty,
1302                     sudo,
1303                     **ssh_kwargs
1304                 )
1305                 if ret:
1306                     raise SaltCloudSystemExit(
1307                         "Cant create {}".format(preseed_minion_keys_tempdir)
1308                     )
1309                 ret = root_cmd(
1310                     "chmod 700 '{}'".format(preseed_minion_keys_tempdir),
1311                     tty,
1312                     sudo,
1313                     **ssh_kwargs
1314                 )
1315                 if ret:
1316                     raise SaltCloudSystemExit(
1317                         "Can't set perms on {}".format(preseed_minion_keys_tempdir)
1318                     )
1319                 if ssh_kwargs["username"] != "root":
1320                     root_cmd(
1321                         "chown {} '{}'".format(
1322                             ssh_kwargs["username"], preseed_minion_keys_tempdir
1323                         ),
1324                         tty,
1325                         sudo,
1326                         **ssh_kwargs
1327                     )
1328                 for minion_id, minion_key in preseed_minion_keys.items():
1329                     rpath = os.path.join(preseed_minion_keys_tempdir, minion_id)
1330                     ssh_file(opts, rpath, minion_key, ssh_kwargs)
1331                 if ssh_kwargs["username"] != "root":
1332                     root_cmd(
1333                         "chown -R root '{}'".format(preseed_minion_keys_tempdir),
1334                         tty,
1335                         sudo,
1336                         **ssh_kwargs
1337                     )
1338                     if ret:
1339                         raise SaltCloudSystemExit(
1340                             "Can't set ownership for {}".format(
1341                                 preseed_minion_keys_tempdir
1342                             )
1343                         )
1344             preflight_cmds = kwargs.get("preflight_cmds", [])
1345             for command in preflight_cmds:
1346                 cmd_ret = root_cmd(command, tty, sudo, **ssh_kwargs)
1347                 if cmd_ret:
1348                     raise SaltCloudSystemExit(
1349                         "Pre-flight command failed: '{}'".format(command)
1350                     )
1351             if script:
1352                 ssh_file(opts, "{}/deploy.sh".format(tmp_dir), script, ssh_kwargs)
1353                 ret = root_cmd(
1354                     "sh -c \"( chmod +x '{}/deploy.sh' )\";exit $?".format(tmp_dir),
1355                     tty,
1356                     sudo,
1357                     **ssh_kwargs
1358                 )
1359                 if ret:
1360                     raise SaltCloudSystemExit(
1361                         "Can't set perms on {}/deploy.sh".format(tmp_dir)
1362                     )
1363             time_used = time.mktime(time.localtime()) - time.mktime(starttime)
1364             newtimeout = timeout - time_used
1365             queue = None
1366             process = None
1367             if start_action and not parallel:
1368                 queue = multiprocessing.Queue()
1369                 process = multiprocessing.Process(
1370                     target=check_auth,
1371                     kwargs=dict(
1372                         name=name, sock_dir=sock_dir, timeout=newtimeout, queue=queue
1373                     ),
1374                     name="DeployScriptCheckAuth({})".format(name),
1375                 )
1376                 log.debug("Starting new process to wait for salt-minion")
1377                 process.start()
1378             if script:
1379                 if "bootstrap-salt" in script:
1380                     deploy_command += " -c '{}'".format(tmp_dir)
1381                     if force_minion_config:
1382                         deploy_command += " -F"
1383                     if make_syndic is True:
1384                         deploy_command += " -S"
1385                     if make_master is True:
1386                         deploy_command += " -M"
1387                     if make_minion is False:
1388                         deploy_command += " -N"
1389                     if keep_tmp is True:
1390                         deploy_command += " -K"
1391                     if preseed_minion_keys is not None:
1392                         deploy_command += " -k '{}'".format(preseed_minion_keys_tempdir)
1393                 if script_args:
1394                     deploy_command += " {}".format(script_args)
1395                 if script_env:
1396                     if not isinstance(script_env, dict):
1397                         raise SaltCloudSystemExit(
1398                             "The 'script_env' configuration setting NEEDS "
1399                             "to be a dictionary not a {}".format(type(script_env))
1400                         )
1401                     environ_script_contents = ["#!/bin/sh"]
1402                     for key, value in script_env.items():
1403                         environ_script_contents.append(
1404                             "setenv {0} '{1}' &gt;/dev/null 2&gt;&amp;1 || "
1405                             "export {0}='{1}'".format(key, value)
1406                         )
1407                     environ_script_contents.append(deploy_command)
1408                     ssh_file(
1409                         opts,
1410                         "{}/environ-deploy-wrapper.sh".format(tmp_dir),
1411                         "\n".join(environ_script_contents),
1412                         ssh_kwargs,
1413                     )
1414                     root_cmd(
1415                         "chmod +x '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1416                         tty,
1417                         sudo,
1418                         **ssh_kwargs
1419                     )
1420                     deploy_command = "'{}/environ-deploy-wrapper.sh'".format(
1421                         tmp_dir,
1422                     )
1423                 if root_cmd(deploy_command, tty, sudo, **ssh_kwargs) != 0:
1424                     raise SaltCloudSystemExit(
1425                         "Executing the command '{}' failed".format(deploy_command)
1426                     )
1427                 log.debug("Executed command '%s'", deploy_command)
1428                 if not keep_tmp:
1429                     root_cmd(
1430                         "rm -f '{}/deploy.sh'".format(tmp_dir), tty, sudo, **ssh_kwargs
1431                     )
1432                     log.debug("Removed %s/deploy.sh", tmp_dir)
1433                     if script_env:
1434                         root_cmd(
1435                             "rm -f '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1436                             tty,
1437                             sudo,
1438                             **ssh_kwargs
1439                         )
1440                         log.debug("Removed %s/environ-deploy-wrapper.sh", tmp_dir)
1441             if keep_tmp:
1442                 log.debug("Not removing deployment files from %s/", tmp_dir)
1443             else:
1444                 if minion_pub:
1445                     root_cmd(
1446                         "rm -f '{}/minion.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1447                     )
1448                     log.debug("Removed %s/minion.pub", tmp_dir)
1449                 if minion_pem:
1450                     root_cmd(
1451                         "rm -f '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1452                     )
1453                     log.debug("Removed %s/minion.pem", tmp_dir)
1454                 if minion_conf:
1455                     root_cmd(
1456                         "rm -f '{}/grains'".format(tmp_dir), tty, sudo, **ssh_kwargs
1457                     )
1458                     log.debug("Removed %s/grains", tmp_dir)
1459                     root_cmd(
1460                         "rm -f '{}/minion'".format(tmp_dir), tty, sudo, **ssh_kwargs
1461                     )
1462                     log.debug("Removed %s/minion", tmp_dir)
1463                 if master_sign_pub_file:
1464                     root_cmd(
1465                         "rm -f {}/master_sign.pub".format(tmp_dir),
1466                         tty,
1467                         sudo,
1468                         **ssh_kwargs
1469                     )
1470                     log.debug("Removed %s/master_sign.pub", tmp_dir)
1471                 if master_pub:
1472                     root_cmd(
1473                         "rm -f '{}/master.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1474                     )
1475                     log.debug("Removed %s/master.pub", tmp_dir)
1476                 if master_pem:
1477                     root_cmd(
1478                         "rm -f '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1479                     )
1480                     log.debug("Removed %s/master.pem", tmp_dir)
1481                 if master_conf:
1482                     root_cmd(
1483                         "rm -f '{}/master'".format(tmp_dir), tty, sudo, **ssh_kwargs
1484                     )
1485                     log.debug("Removed %s/master", tmp_dir)
1486                 if preseed_minion_keys is not None:
1487                     root_cmd(
1488                         "rm -rf '{}'".format(preseed_minion_keys_tempdir),
1489                         tty,
1490                         sudo,
1491                         **ssh_kwargs
1492                     )
1493                     log.debug("Removed %s", preseed_minion_keys_tempdir)
1494             if start_action and not parallel:
1495                 queuereturn = queue.get()
1496                 process.join()
1497                 if queuereturn and start_action:
1498                     log.info("Executing %s on the salt-minion", start_action)
1499                     root_cmd(
1500                         "salt-call {}".format(start_action), tty, sudo, **ssh_kwargs
1501                     )
1502                     log.info("Finished executing %s on the salt-minion", start_action)
1503             fire_event(
1504                 "event",
1505                 "{} has been deployed at {}".format(name, host),
1506                 "salt/cloud/{}/deploy_script".format(name),
1507                 args={"name": name, "host": host},
1508                 sock_dir=opts.get(
1509                     "sock_dir", os.path.join(__opts__["sock_dir"], "master")
1510                 ),
1511                 transport=opts.get("transport", "zeromq"),
1512             )
1513             if file_map_fail or file_map_success:
1514                 return {
1515                     "File Upload Failure": file_map_fail,
1516                 }
1517             re<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn True
1518     return False
1519 def run_inline_script(
1520     host,
1521     name=None,
1522     port=22,
1523     timeout=900,
1524     username="root",
1525     key_filename=None,
1526     inline_script=None,
1527     ssh_timeout=15,
1528     display_ssh_output=True,
1529     parallel=False,
1530     sudo_password=None,
1531     sudo=False,
1532     password=None,
1533     tty=</b></font>None,
1534     opts=None,
1535     tmp_dir="/tmp/.saltcloud-inline_script",
1536     **kwargs
1537 ):
1538     gateway = None
1539     if "gateway" in kwargs:
1540         gateway = kwargs["gateway"]
1541     starttime = time.mktime(time.localtime())
1542     log.debug("Deploying %s at %s", host, starttime)
1543     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1544     if wait_for_port(host=host, port=port, gateway=gateway):
1545         log.debug("SSH port %s on %s is available", port, host)
1546         newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1547         if wait_for_passwd(
1548             host,
1549             port=port,
1550             username=username,
1551             password=password,
1552             key_filename=key_filename,
1553             ssh_timeout=ssh_timeout,
1554             display_ssh_output=display_ssh_output,
1555             gateway=gateway,
1556             known_hosts_file=known_hosts_file,
1557         ):
1558             log.debug("Logging into %s:%s as %s", host, port, username)
1559             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1560             ssh_kwargs = {
1561                 "hostname": host,
1562                 "port": port,
1563                 "username": username,
1564                 "timeout": ssh_timeout,
1565                 "display_ssh_output": display_ssh_output,
1566                 "sudo_password": sudo_password,
1567                 "sftp": opts.get("use_sftp", False),
1568             }
1569             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1570             if key_filename:
1571                 log.debug("Using %s as the key_filename", key_filename)
1572                 ssh_kwargs["key_filename"] = key_filename
1573             elif (
1574                 password
1575                 and "has_ssh_agent" in kwargs
1576                 and kwargs["has_ssh_agent"] is False
1577             ):
1578                 ssh_kwargs["password"] = password
1579             if (
1580                 root_cmd(
1581                     'test -e \\"{}\\"'.format(tmp_dir),
1582                     tty,
1583                     sudo,
1584                     allow_failure=True,
1585                     **ssh_kwargs
1586                 )
1587                 and inline_script
1588             ):
1589                 log.debug("Found inline script to execute.")
1590                 for cmd_line in inline_script:
1591                     log.info("Executing inline command: %s", cmd_line)
1592                     ret = root_cmd(
1593                         'sh -c "( {} )"'.format(cmd_line),
1594                         tty,
1595                         sudo,
1596                         allow_failure=True,
1597                         **ssh_kwargs
1598                     )
1599                     if ret:
1600                         log.info("[%s] Output: %s", cmd_line, ret)
1601     return True
1602 def filter_event(tag, data, defaults):
1603     ret = {}
1604     keys = []
1605     use_defaults = True
1606     for ktag in __opts__.get("filter_events", {}):
1607         if tag != ktag:
1608             continue
1609         keys = __opts__["filter_events"][ktag]["keys"]
1610         use_defaults = __opts__["filter_events"][ktag].get("use_defaults", True)
1611     if use_defaults is False:
1612         defaults = []
1613     if not isinstance(defaults, list):
1614         defaults = list(defaults)
1615     defaults = list(set(defaults + keys))
1616     for key in defaults:
1617         if key in data:
1618             ret[key] = data[key]
1619     return ret
1620 def fire_event(key, msg, tag, sock_dir, args=None, transport="zeromq"):
1621     with salt.utils.event.get_event("master", sock_dir, listen=False) as event:
1622         try:
1623             event.fire_event(msg, tag)
1624         except ValueError:
1625             if isinstance(args, dict):
1626                 args[key] = msg
1627             else:
1628                 args = {key: msg}
1629             event.fire_event(args, tag)
1630         time.sleep(0.025)
1631 def _exec_ssh_cmd(cmd, error_msg=None, allow_failure=False, **kwargs):
1632     if error_msg is None:
1633         error_msg = "A wrong password has been issued while establishing ssh session."
1634     password_retries = kwargs.get("password_retries", 3)
1635     try:
1636         stdout, stderr = None, None
1637         proc = salt.utils.vt.Terminal(
1638             cmd,
1639             shell=True,
1640             log_stdout=True,
1641             log_stderr=True,
1642             stream_stdout=kwargs.get("display_ssh_output", True),
1643             stream_stderr=kwargs.get("display_ssh_output", True),
1644         )
1645         sent_password = 0
1646         while proc.has_unread_data:
1647             stdout, stderr = proc.recv()
1648             if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):
1649                 if (
1650                     "key_filename" in kwargs
1651                     and kwargs["key_filename"]
1652                     and SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)
1653                 ):
1654                     proc.sendline(kwargs["sudo_password"])
1655                 elif kwargs.get("password", None) and (
1656                     sent_password &lt; password_retries
1657                 ):
1658                     sent_password += 1
1659                     proc.sendline(kwargs["password"])
1660                 else:
1661                     raise SaltCloudPasswordError(error_msg)
1662             time.sleep(0.5)
1663         if proc.exitstatus != 0 and allow_failure is False:
1664             raise SaltCloudSystemExit(
1665                 "Command '{}' failed. Exit code: {}".format(cmd, proc.exitstatus)
1666             )
1667         return proc.exitstatus
1668     except salt.utils.vt.TerminalException as err:
1669         trace = traceback.format_exc()
1670         log.error(
1671             error_msg.format(cmd, err, trace)
1672         )  # pylint: disable=str-format-in-logging
1673     finally:
1674         proc.close(terminate=True, kill=True)
1675     return 1
1676 def scp_file(dest_path, contents=None, kwargs=None, local_file=None):
1677     file_to_upload = None
1678     try:
1679         if contents is not None:
1680             try:
1681                 tmpfd, file_to_upload = tempfile.mkstemp()
1682                 os.write(tmpfd, contents)
1683             finally:
1684                 try:
1685                     os.close(tmpfd)
1686                 except OSError as exc:
1687                     if exc.errno != errno.EBADF:
1688                         raise
1689         log.debug("Uploading %s to %s", dest_path, kwargs["hostname"])
1690         ssh_args = [
1691             "-oStrictHostKeyChecking=no",
1692             "-oServerAliveInterval={}".format(
1693                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1694             ),
1695             "-oServerAliveCountMax={}".format(
1696                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1697             ),
1698             "-oUserKnownHostsFile=/dev/null",
1699             "-oControlPath=none",
1700         ]
1701         if local_file is not None:
1702             file_to_upload = local_file
1703             if os.path.isdir(local_file):
1704                 ssh_args.append("-r")
1705         if "key_filename" in kwargs:
1706             ssh_args.extend(
1707                 [
1708                     "-oPasswordAuthentication=no",
1709                     "-oChallengeResponseAuthentication=no",
1710                     "-oPubkeyAuthentication=yes",
1711                     "-oIdentitiesOnly=yes",
1712                     "-oKbdInteractiveAuthentication=no",
1713                     "-i {}".format(kwargs["key_filename"]),
1714                 ]
1715             )
1716         if "port" in kwargs:
1717             ssh_args.append("-oPort={}".format(kwargs["port"]))
1718         ssh_args.append(__ssh_gateway_arguments(kwargs))
1719         try:
1720             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1721                 ipaddr = "[{}]".format(kwargs["hostname"])
1722             else:
1723                 ipaddr = kwargs["hostname"]
1724         except OSError:
1725             ipaddr = kwargs["hostname"]
1726         if file_to_upload is None:
1727             log.warning(
1728                 "No source file to upload. Please make sure that either file "
1729                 "contents or the path to a local file are provided."
1730             )
1731         cmd = (
1732             "scp {0} {1} {2[username]}@{4}:{3} || "
1733             'echo "put {1} {3}" | sftp {0} {2[username]}@{4} || '
1734             'rsync -avz -e "ssh {0}" {1} {2[username]}@{2[hostname]}:{3}'.format(
1735                 " ".join(ssh_args), file_to_upload, kwargs, dest_path, ipaddr
1736             )
1737         )
1738         log.debug("SCP command: '%s'", cmd)
1739         retcode = _exec_ssh_cmd(
1740             cmd,
1741             error_msg="Failed to upload file '{0}': {1}\n{2}",
1742             password_retries=3,
1743             **kwargs
1744         )
1745     finally:
1746         if contents is not None:
1747             try:
1748                 os.remove(file_to_upload)
1749             except OSError as exc:
1750                 if exc.errno != errno.ENOENT:
1751                     raise
1752     return retcode
1753 def ssh_file(opts, dest_path, contents=None, kwargs=None, local_file=None):
1754     if opts.get("file_transport", "sftp") == "sftp":
1755         return sftp_file(dest_path, contents, kwargs, local_file)
1756     return scp_file(dest_path, contents, kwargs, local_file)
1757 def sftp_file(dest_path, contents=None, kwargs=None, local_file=None):
1758     put_args = []
1759     if kwargs is None:
1760         kwargs = {}
1761     file_to_upload = None
1762     try:
1763         if contents is not None:
1764             try:
1765                 tmpfd, file_to_upload = tempfile.mkstemp()
1766                 if isinstance(contents, str):
1767                     os.write(tmpfd, contents.encode(__salt_system_encoding__))
1768                 else:
1769                     os.write(tmpfd, contents)
1770             finally:
1771                 try:
1772                     os.close(tmpfd)
1773                 except OSError as exc:
1774                     if exc.errno != errno.EBADF:
1775                         raise
1776         if local_file is not None:
1777             file_to_upload = local_file
1778             if os.path.isdir(local_file):
1779                 put_args = ["-r"]
1780         log.debug("Uploading %s to %s (sftp)", dest_path, kwargs.get("hostname"))
1781         ssh_args = [
1782             "-oStrictHostKeyChecking=no",
1783             "-oServerAliveInterval={}".format(
1784                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1785             ),
1786             "-oServerAliveCountMax={}".format(
1787                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1788             ),
1789             "-oUserKnownHostsFile=/dev/null",
1790             "-oControlPath=none",
1791         ]
1792         if "key_filename" in kwargs:
1793             ssh_args.extend(
1794                 [
1795                     "-oPasswordAuthentication=no",
1796                     "-oChallengeResponseAuthentication=no",
1797                     "-oPubkeyAuthentication=yes",
1798                     "-oIdentitiesOnly=yes",
1799                     "-oKbdInteractiveAuthentication=no",
1800                     "-oIdentityFile={}".format(kwargs["key_filename"]),
1801                 ]
1802             )
1803         if "port" in kwargs:
1804             ssh_args.append("-oPort={}".format(kwargs["port"]))
1805         ssh_args.append(__ssh_gateway_arguments(kwargs))
1806         try:
1807             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1808                 ipaddr = "[{}]".format(kwargs["hostname"])
1809             else:
1810                 ipaddr = kwargs["hostname"]
1811         except OSError:
1812             ipaddr = kwargs["hostname"]
1813         if file_to_upload is None:
1814             log.warning(
1815                 "No source file to upload. Please make sure that either file "
1816                 "contents or the path to a local file are provided."
1817             )
1818         cmd = 'echo "put {0} {1} {2}" | sftp {3} {4[username]}@{5}'.format(
1819             " ".join(put_args),
1820             file_to_upload,
1821             dest_path,
1822             " ".join(ssh_args),
1823             kwargs,
1824             ipaddr,
1825         )
1826         log.debug("SFTP command: '%s'", cmd)
1827         retcode = _exec_ssh_cmd(
1828             cmd,
1829             error_msg="Failed to upload file '{0}': {1}\n{2}",
1830             password_retries=3,
1831             **kwargs
1832         )
1833     finally:
1834         if contents is not None:
1835             try:
1836                 os.remove(file_to_upload)
1837             except OSError as exc:
1838                 if exc.errno != errno.ENOENT:
1839                     raise
1840     return retcode
1841 def win_cmd(command, **kwargs):
1842     logging_command = kwargs.get("logging_command", None)
1843     try:
1844         proc = NonBlockingPopen(
1845             command,
1846             shell=True,
1847             stderr=subprocess.PIPE,
1848             stdout=subprocess.PIPE,
1849             stream_stds=kwargs.get("display_ssh_output", True),
1850             logging_command=logging_command,
1851         )
1852         if logging_command is None:
1853             log.debug("Executing command(PID %s): '%s'", proc.pid, command)
1854         else:
1855             log.debug("Executing command(PID %s): '%s'", proc.pid, logging_command)
1856         proc.poll_and_read_until_finish()
1857         proc.communicate()
1858         return proc.returncode
1859     except Exception as err:  # pylint: disable=broad-except
1860         log.exception("Failed to execute command '%s'", logging_command)
1861     return 1
1862 def winrm_cmd(session, command, flags, **kwargs):
1863     log.debug("Executing WinRM command: %s %s", command, flags)
1864     r = session.run_cmd(command, flags)
1865     return r.status_code
1866 def root_cmd(command, tty, sudo, allow_failure=False, **kwargs):
1867     logging_command = command
1868     sudo_password = kwargs.get("sudo_password", None)
1869     if sudo:
1870         if sudo_password is None:
1871             command = "sudo {}".format(command)
1872             logging_command = command
1873         else:
1874             logging_command = 'sudo -S "XXX-REDACTED-XXX" {}'.format(command)
1875             command = "sudo -S {}".format(command)
1876         log.debug("Using sudo to run command %s", logging_command)
1877     ssh_args = []
1878     if tty:
1879         ssh_args.extend(["-t", "-t"])
1880     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1881     host_key_checking = "no"
1882     if known_hosts_file != "/dev/null":
1883         host_key_checking = "yes"
1884     ssh_args.extend(
1885         [
1886             "-oStrictHostKeyChecking={}".format(host_key_checking),
1887             "-oUserKnownHostsFile={}".format(known_hosts_file),
1888             "-oControlPath=none",
1889         ]
1890     )
1891     if "key_filename" in kwargs:
1892         ssh_args.extend(
1893             [
1894                 "-oPasswordAuthentication=no",
1895                 "-oChallengeResponseAuthentication=no",
1896                 "-oPubkeyAuthentication=yes",
1897                 "-oIdentitiesOnly=yes",
1898                 "-oKbdInteractiveAuthentication=no",
1899                 "-i {}".format(kwargs["key_filename"]),
1900             ]
1901         )
1902     if "ssh_timeout" in kwargs:
1903         ssh_args.extend(["-oConnectTimeout={}".format(kwargs["ssh_timeout"])])
1904     ssh_args.extend([__ssh_gateway_arguments(kwargs)])
1905     if "port" in kwargs:
1906         ssh_args.extend(["-p {}".format(kwargs["port"])])
1907     cmd = "ssh {0} {1[username]}@{1[hostname]} ".format(" ".join(ssh_args), kwargs)
1908     logging_command = cmd + logging_command
1909     cmd = cmd + pipes.quote(command)
1910     hard_timeout = kwargs.get("hard_timeout")
1911     if hard_timeout is not None:
1912         logging_command = "timeout {} {}".format(hard_timeout, logging_command)
1913         cmd = "timeout {} {}".format(hard_timeout, cmd)
1914     log.debug("SSH command: '%s'", logging_command)
1915     retcode = _exec_ssh_cmd(cmd, allow_failure=allow_failure, **kwargs)
1916     return retcode
1917 def check_auth(name, sock_dir=None, queue=None, timeout=300):
1918     with salt.utils.event.SaltEvent("master", sock_dir, listen=True) as event:
1919         starttime = time.mktime(time.localtime())
1920         newtimeout = timeout
1921         log.debug("In check_auth, waiting for %s to become available", name)
1922         while newtimeout &gt; 0:
1923             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1924             ret = event.get_event(full=True)
1925             if ret is None:
1926                 continue
1927             if ret["tag"] == "salt/minion/{}/start".format(name):
1928                 queue.put(name)
1929                 newtimeout = 0
1930                 log.debug("Minion %s is ready to receive commands", name)
1931 def ip_to_int(ip):
1932     ret = 0
1933     for octet in ip.split("."):
1934         ret = ret * 256 + int(octet)
1935     return ret
1936 def is_public_ip(ip):
1937     if ":" in ip:
1938         if ip.startswith("fe80:"):
1939             return False
1940         return True
1941     addr = ip_to_int(ip)
1942     if 167772160 &lt; addr &lt; 184549375:
1943         return False
1944     elif 3232235520 &lt; addr &lt; 3232301055:
1945         return False
1946     elif 2886729728 &lt; addr &lt; 2887778303:
1947         return False
1948     elif 2130706432 &lt; addr &lt; 2147483647:
1949         return False
1950     return True
1951 def check_name(name, safe_chars):
1952     regexp = re.compile("[^{}]".format(safe_chars))
1953     if regexp.search(name):
1954         raise SaltCloudException(
1955             "{} contains characters not supported by this cloud provider. "
1956             "Valid characters are: {}".format(name, safe_chars)
1957         )
1958 def remove_sshkey(host, known_hosts=None):
1959     if known_hosts is None:
1960         if "HOME" in os.environ:
1961             known_hosts = "{}/.ssh/known_hosts".format(os.environ["HOME"])
1962         else:
1963             try:
1964                 known_hosts = "{}/.ssh/known_hosts".format(
1965                     pwd.getpwuid(os.getuid()).pwd_dir
1966                 )
1967             except Exception:  # pylint: disable=broad-except
1968                 pass
1969     if known_hosts is not None:
1970         log.debug("Removing ssh key for %s from known hosts file %s", host, known_hosts)
1971     else:
1972         log.debug("Removing ssh key for %s from known hosts file", host)
1973     subprocess.call(["ssh-keygen", "-R", host])
1974 def wait_for_ip(
1975     update_callback,
1976     update_args=None,
1977     update_kwargs=None,
1978     timeout=5 * 60,
1979     interval=5,
1980     interval_multiplier=1,
1981     max_failures=10,
1982 ):
1983     if update_args is None:
1984         update_args = ()
1985     if update_kwargs is None:
1986         update_kwargs = {}
1987     duration = timeout
1988     while True:
1989         log.debug(
1990             "Waiting for VM IP. Giving up in 00:%02d:%02d.",
1991             int(timeout // 60),
1992             int(timeout % 60),
1993         )
1994         data = update_callback(*update_args, **update_kwargs)
1995         if data is False:
1996             log.debug(
1997                 "'update_callback' has returned 'False', which is "
1998                 "considered a failure. Remaining Failures: %s.",
1999                 max_failures,
2000             )
2001             max_failures -= 1
2002             if max_failures &lt;= 0:
2003                 raise SaltCloudExecutionFailure(
2004                     "Too many failures occurred while waiting for the IP address."
2005                 )
2006         elif data is not None:
2007             return data
2008         if timeout &lt; 0:
2009             raise SaltCloudExecutionTimeout(
2010                 "Unable to get IP for 00:{:02d}:{:02d}.".format(
2011                     int(duration // 60), int(duration % 60)
2012                 )
2013             )
2014         time.sleep(interval)
2015         timeout -= interval
2016         if interval_multiplier &gt; 1:
2017             interval *= interval_multiplier
2018             if interval &gt; timeout:
2019                 interval = timeout + 1
2020             log.info("Interval multiplier in effect; interval is now %ss.", interval)
2021 def list_nodes_select(nodes, selection, call=None):
2022     if call == "action":
2023         raise SaltCloudSystemExit(
2024             "The list_nodes_select function must be called with -f or --function."
2025         )
2026     if "error" in nodes:
2027         raise SaltCloudSystemExit(
2028             "An error occurred while listing nodes: {}".format(
2029                 nodes["error"]["Errors"]["Error"]["Message"]
2030             )
2031         )
2032     ret = {}
2033     for node in nodes:
2034         pairs = {}
2035         data = nodes[node]
2036         for key in data:
2037             if str(key) in selection:
2038                 value = data[key]
2039                 pairs[key] = value
2040         ret[node] = pairs
2041     return ret
2042 def lock_file(filename, interval=0.5, timeout=15):
2043     log.trace("Attempting to obtain lock for %s", filename)
2044     lock = filename + ".lock"
2045     start = time.time()
2046     while True:
2047         if os.path.exists(lock):
2048             if time.time() - start &gt;= timeout:
2049                 log.warning("Unable to obtain lock for %s", filename)
2050                 return False
2051             time.sleep(interval)
2052         else:
2053             break
2054     with salt.utils.files.fopen(lock, "a"):
2055         pass
2056 def unlock_file(filename):
2057     log.trace("Removing lock for %s", filename)
2058     lock = filename + ".lock"
2059     try:
2060         os.remove(lock)
2061     except OSError as exc:
2062         log.trace("Unable to remove lock for %s: %s", filename, exc)
2063 def cachedir_index_add(minion_id, profile, driver, provider, base=None):
2064     base = init_cachedir(base)
2065     index_file = os.path.join(base, "index.p")
2066     lock_file(index_file)
2067     if os.path.exists(index_file):
2068         with salt.utils.files.fopen(index_file, "rb") as fh_:
2069             index = salt.utils.data.decode(
2070                 salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2071             )
2072     else:
2073         index = {}
2074     prov_comps = provider.split(":")
2075     index.update(
2076         {
2077             minion_id: {
2078                 "id": minion_id,
2079                 "profile": profile,
2080                 "driver": driver,
2081                 "provider": prov_comps[0],
2082             }
2083         }
2084     )
2085     with salt.utils.files.fopen(index_file, "wb") as fh_:
2086         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2087     unlock_file(index_file)
2088 def cachedir_index_del(minion_id, base=None):
2089     base = init_cachedir(base)
2090     index_file = os.path.join(base, "index.p")
2091     lock_file(index_file)
2092     if os.path.exists(index_file):
2093         with salt.utils.files.fopen(index_file, "rb") as fh_:
2094             index = salt.utils.data.decode(
2095                 salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2096             )
2097     else:
2098         return
2099     if minion_id in index:
2100         del index[minion_id]
2101     with salt.utils.files.fopen(index_file, "wb") as fh_:
2102         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2103     unlock_file(index_file)
2104 def init_cachedir(base=None):
2105     if base is None:
2106         base = __opts__["cachedir"]
2107     needed_dirs = (base, os.path.join(base, "requested"), os.path.join(base, "active"))
2108     for dir_ in needed_dirs:
2109         if not os.path.exists(dir_):
2110             os.makedirs(dir_)
2111         os.chmod(base, 0o755)
2112     return base
2113 def request_minion_cachedir(
2114     minion_id,
2115     opts=None,
2116     fingerprint="",
2117     pubkey=None,
2118     provider=None,
2119     base=None,
2120 ):
2121     if base is None:
2122         base = __opts__["cachedir"]
2123     if not fingerprint and pubkey is not None:
2124         fingerprint = salt.utils.crypt.pem_finger(
2125             key=pubkey, sum_type=(opts and opts.get("hash_type") or "sha256")
2126         )
2127     init_cachedir(base)
2128     data = {
2129         "minion_id": minion_id,
2130         "fingerprint": fingerprint,
2131         "provider": provider,
2132     }
2133     fname = "{}.p".format(minion_id)
2134     path = os.path.join(base, "requested", fname)
2135     with salt.utils.files.fopen(path, "wb") as fh_:
2136         salt.utils.msgpack.dump(data, fh_, encoding=MSGPACK_ENCODING)
2137 def change_minion_cachedir(
2138     minion_id,
2139     cachedir,
2140     data=None,
2141     base=None,
2142 ):
2143     if not isinstance(data, dict):
2144         return False
2145     if base is None:
2146         base = __opts__["cachedir"]
2147     fname = "{}.p".format(minion_id)
2148     path = os.path.join(base, cachedir, fname)
2149     with salt.utils.files.fopen(path, "r") as fh_:
2150         cache_data = salt.utils.data.decode(
2151             salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2152         )
2153     cache_data.update(data)
2154     with salt.utils.files.fopen(path, "w") as fh_:
2155         salt.utils.msgpack.dump(cache_data, fh_, encoding=MSGPACK_ENCODING)
2156 def activate_minion_cachedir(minion_id, base=None):
2157     if base is None:
2158         base = __opts__["cachedir"]
2159     fname = "{}.p".format(minion_id)
2160     src = os.path.join(base, "requested", fname)
2161     dst = os.path.join(base, "active")
2162     shutil.move(src, dst)
2163 def delete_minion_cachedir(minion_id, provider, opts, base=None):
2164     if isinstance(opts, dict):
2165         __opts__.update(opts)
2166     if __opts__.get("update_cachedir", False) is False:
2167         return
2168     if base is None:
2169         base = __opts__["cachedir"]
2170     driver = next(iter(__opts__["providers"][provider].keys()))
2171     fname = "{}.p".format(minion_id)
2172     for cachedir in "requested", "active":
2173         path = os.path.join(base, cachedir, driver, provider, fname)
2174         log.debug("path: %s", path)
2175         if os.path.exists(path):
2176             os.remove(path)
2177 def list_cache_nodes_full(opts=None, provider=None, base=None):
2178     if opts is None:
2179         opts = __opts__
2180     if opts.get("update_cachedir", False) is False:
2181         return
2182     if base is None:
2183         base = os.path.join(opts["cachedir"], "active")
2184     minions = {}
2185     for driver in os.listdir(base):
2186         minions[driver] = {}
2187         prov_dir = os.path.join(base, driver)
2188         for prov in os.listdir(prov_dir):
2189             if provider and provider != prov:
2190                 continue
2191             minions[driver][prov] = {}
2192             min_dir = os.path.join(prov_dir, prov)
2193             for fname in os.listdir(min_dir):
2194                 fpath = os.path.join(min_dir, fname)
2195                 minion_id = fname[:-2]  # strip '.p' from end of msgpack filename
2196                 with salt.utils.files.fopen(fpath, "rb") as fh_:
2197                     minions[driver][prov][minion_id] = salt.utils.data.decode(
2198                         salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2199                     )
2200     return minions
2201 def update_bootstrap(config, url=None):
2202     default_url = config.get("bootstrap_script_url", "https://bootstrap.saltstack.com")
2203     if not url:
2204         url = default_url
2205     if not url:
2206         raise ValueError("Cant get any source to update")
2207     if url.startswith("http") or "://" in url:
2208         log.debug("Updating the bootstrap-salt.sh script to latest stable")
2209         try:
2210             import requests
2211         except ImportError:
2212             return {
2213                 "error": (
2214                     "Updating the bootstrap-salt.sh script requires the "
2215                     "Python requests library to be installed"
2216                 )
2217             }
2218         req = requests.get(url)
2219         if req.status_code != 200:
2220             return {
2221                 "error": (
2222                     "Failed to download the latest stable version of the "
2223                     "bootstrap-salt.sh script from {}. HTTP error: "
2224                     "{}".format(url, req.status_code)
2225                 )
2226             }
2227         script_content = req.text
2228         if url == default_url:
2229             script_name = "bootstrap-salt.sh"
2230         else:
2231             script_name = os.path.basename(url)
2232     elif os.path.exists(url):
2233         with salt.utils.files.fopen(url) as fic:
2234             script_content = salt.utils.stringutils.to_unicode(fic.read())
2235         script_name = os.path.basename(url)
2236     else:
2237         script_content = url
2238         script_name = "{}.sh".format(hashlib.sha1(script_content).hexdigest())
2239     if not script_content:
2240         raise ValueError("No content in bootstrap script !")
2241     builtin_deploy_dir = os.path.join(os.path.dirname(__file__), "deploy")
2242     deploy_d_from_conf_file = os.path.join(
2243         os.path.dirname(config["conf_file"]), "cloud.deploy.d"
2244     )
2245     deploy_d_from_syspaths = os.path.join(config["config_dir"], "cloud.deploy.d")
2246     deploy_scripts_search_paths = []
2247     for entry in config.get("deploy_scripts_search_path", []):
2248         if entry.startswith(builtin_deploy_dir):
2249             continue
2250         if entry in (deploy_d_from_conf_file, deploy_d_from_syspaths):
2251             deploy_scripts_search_paths.append((entry, True))
2252         else:
2253             deploy_scripts_search_paths.append((entry, False))
2254     if deploy_d_from_conf_file not in deploy_scripts_search_paths:
2255         deploy_scripts_search_paths.append((deploy_d_from_conf_file, True))
2256     if deploy_d_from_syspaths not in deploy_scripts_search_paths:
2257         deploy_scripts_search_paths.append((deploy_d_from_syspaths, True))
2258     finished = []
2259     finished_full = []
2260     for entry, makedirs in deploy_scripts_search_paths:
2261         if entry in finished:
2262             continue
2263         else:
2264             finished.append(entry)
2265         if makedirs and not os.path.isdir(entry):
2266             try:
2267                 os.makedirs(entry)
2268             except OSError as err:
2269                 log.info("Failed to create directory '%s'", entry)
2270                 continue
2271         if not is_writeable(entry):
2272             log.debug("The '%s' is not writeable. Continuing...", entry)
2273             continue
2274         deploy_path = os.path.join(entry, script_name)
2275         try:
2276             finished_full.append(deploy_path)
2277             with salt.utils.files.fopen(deploy_path, "w") as fp_:
2278                 fp_.write(salt.utils.stringutils.to_str(script_content))
2279         except OSError as err:
2280             log.debug("Failed to write the updated script: %s", err)
2281             continue
2282     return {"Success": {"Files updated": finished_full}}
2283 def cache_node_list(nodes, provider, opts):
2284     if "update_cachedir" not in opts or not opts["update_cachedir"]:
2285         return
2286     base = os.path.join(init_cachedir(), "active")
2287     driver = next(iter(opts["providers"][provider].keys()))
2288     prov_dir = os.path.join(base, driver, provider)
2289     if not os.path.exists(prov_dir):
2290         os.makedirs(prov_dir)
2291     missing_node_cache(prov_dir, nodes, provider, opts)
2292     for node in nodes:
2293         diff_node_cache(prov_dir, node, nodes[node], opts)
2294         path = os.path.join(prov_dir, "{}.p".format(node))
2295         with salt.utils.files.fopen(path, "wb") as fh_:
2296             salt.utils.msgpack.dump(nodes[node], fh_, encoding=MSGPACK_ENCODING)
2297 def cache_node(node, provider, opts):
2298     if isinstance(opts, dict):
2299         __opts__.update(opts)
2300     if "update_cachedir" not in __opts__ or not __opts__["update_cachedir"]:
2301         return
2302     if not os.path.exists(os.path.join(__opts__["cachedir"], "active")):
2303         init_cachedir()
2304     base = os.path.join(__opts__["cachedir"], "active")
2305     provider, driver = provider.split(":")
2306     prov_dir = os.path.join(base, driver, provider)
2307     if not os.path.exists(prov_dir):
2308         os.makedirs(prov_dir)
2309     path = os.path.join(prov_dir, "{}.p".format(node["name"]))
2310     with salt.utils.files.fopen(path, "wb") as fh_:
2311         salt.utils.msgpack.dump(node, fh_, encoding=MSGPACK_ENCODING)
2312 def missing_node_cache(prov_dir, node_list, provider, opts):
2313     cached_nodes = []
2314     for node in os.listdir(prov_dir):
2315         cached_nodes.append(os.path.splitext(node)[0])
2316     for node in cached_nodes:
2317         if node not in node_list:
2318             delete_minion_cachedir(node, provider, opts)
2319             if "diff_cache_events" in opts and opts["diff_cache_events"]:
2320                 fire_event(
2321                     "event",
2322                     "cached node missing from provider",
2323                     "salt/cloud/{}/cache_node_missing".format(node),
2324                     args={"missing node": node},
2325                     sock_dir=opts.get(
2326                         "sock_dir", os.path.join(__opts__["sock_dir"], "master")
2327                     ),
2328                     transport=opts.get("transport", "zeromq"),
2329                 )
2330 def diff_node_cache(prov_dir, node, new_data, opts):
2331     if "diff_cache_events" not in opts or not opts["diff_cache_events"]:
2332         return
2333     if node is None:
2334         return
2335     path = "{}.p".format(os.path.join(prov_dir, node))
2336     if not os.path.exists(path):
2337         event_data = _strip_cache_events(new_data, opts)
2338         fire_event(
2339             "event",
2340             "new node found",
2341             "salt/cloud/{}/cache_node_new".format(node),
2342             args={"new_data": event_data},
2343             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2344             transport=opts.get("transport", "zeromq"),
2345         )
2346         return
2347     with salt.utils.files.fopen(path, "r") as fh_:
2348         try:
2349             cache_data = salt.utils.data.decode(
2350                 salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2351             )
2352         except ValueError:
2353             log.warning("Cache for %s was corrupt: Deleting", node)
2354             cache_data = {}
2355     diff = salt.utils.compat.cmp(new_data, cache_data)
2356     if diff != 0:
2357         fire_event(
2358             "event",
2359             "node data differs",
2360             "salt/cloud/{}/cache_node_diff".format(node),
2361             args={
2362                 "new_data": _strip_cache_events(new_data, opts),
2363                 "cache_data": _strip_cache_events(cache_data, opts),
2364             },
2365             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2366             transport=opts.get("transport", "zeromq"),
2367         )
2368 def _strip_cache_events(data, opts):
2369     event_data = copy.deepcopy(data)
2370     strip_fields = opts.get("cache_event_strip_fields", [])
2371     for field in strip_fields:
2372         if field in event_data:
2373             del event_data[field]
2374     return event_data
2375 def _salt_cloud_force_ascii(exc):
2376     if not isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):
2377         raise TypeError("Can't handle {}".format(exc))
2378     unicode_trans = {
2379         "\xa0": " ",
2380         "\u2013": "-",
2381     }
2382     if exc.object[exc.start : exc.end] in unicode_trans:
2383         return unicode_trans[exc.object[exc.start : exc.end]], exc.end
2384     raise exc
2385 codecs.register_error("salt-cloud-force-ascii", _salt_cloud_force_ascii)
2386 def retrieve_password_from_keyring(credential_id, username):
2387     try:
2388         import keyring  # pylint: disable=import-error
2389         return keyring.get_password(credential_id, username)
2390     except ImportError:
2391         log.error(
2392             "USE_KEYRING configured as a password, but no keyring module is installed"
2393         )
2394         return False
2395 def _save_password_in_keyring(credential_id, username, password):
2396     try:
2397         import keyring  # pylint: disable=import-error
2398         return keyring.set_password(credential_id, username, password)
2399     except ImportError:
2400         log.error(
2401             "Tried to store password in keyring, but no keyring module is installed"
2402         )
2403         return False
2404 def store_password_in_keyring(credential_id, username, password=None):
2405     try:
2406         import keyring
2407         import keyring.errors
2408         if password is None:
2409             prompt = "Please enter password for {}: ".format(credential_id)
2410             try:
2411                 password = getpass.getpass(prompt)
2412             except EOFError:
2413                 password = None
2414             if not password:
2415                 raise RuntimeError("Invalid password provided.")
2416         try:
2417             _save_password_in_keyring(credential_id, username, password)
2418         except keyring.errors.PasswordSetError as exc:
2419             log.debug("Problem saving password in the keyring: %s", exc)
2420     except ImportError:
2421         log.error(
2422             "Tried to store password in keyring, but no keyring module is installed"
2423         )
2424         return False
2425 def _unwrap_dict(dictionary, index_string):
2426     index = index_string.split(",")
2427     for k in index:
2428         dictionary = dictionary[k]
2429     return dictionary
2430 def run_func_until_ret_arg(
2431     fun,
2432     kwargs,
2433     fun_call=None,
2434     argument_being_watched=None,
2435     required_argument_response=None,
2436 ):
2437     status = None
2438     while status != required_argument_response:
2439         f_result = fun(kwargs, call=fun_call)
2440         r_set = {}
2441         for d in f_result:
2442             if isinstance(d, list):
2443                 d0 = d[0]
2444                 if isinstance(d0, dict):
2445                     for k, v in d0.items():
2446                         r_set[k] = v
2447         status = _unwrap_dict(r_set, argument_being_watched)
2448         log.debug(
2449             "Function: %s, Watched arg: %s, Response: %s",
2450             str(fun).split(" ")[1],
2451             argument_being_watched,
2452             status,
2453         )
2454         time.sleep(5)
2455     return True
2456 def get_salt_interface(vm_, opts):
2457     salt_host = salt.config.get_cloud_config_value(
2458         "salt_interface", vm_, opts, default=False, search_global=False
2459     )
2460     if salt_host is False:
2461         salt_host = salt.config.get_cloud_config_value(
2462             "ssh_interface", vm_, opts, default="public_ips", search_global=False
2463         )
2464     return salt_host
2465 def check_key_path_and_mode(provider, key_path):
2466     if not os.path.exists(key_path):
2467         log.error(
2468             "The key file '%s' used in the '%s' provider configuration "
2469             "does not exist.\n",
2470             key_path,
2471             provider,
2472         )
2473         return False
2474     key_mode = stat.S_IMODE(os.stat(key_path).st_mode)
2475     if key_mode not in (0o400, 0o600):
2476         log.error(
2477             "The key file '%s' used in the '%s' provider configuration "
2478             "needs to be set to mode 0400 or 0600.\n",
2479             key_path,
2480             provider,
2481         )
2482         return False
2483     return True
2484 def userdata_template(opts, vm_, userdata):
2485     if userdata is None:
2486         return userdata
2487     userdata_template = salt.config.get_cloud_config_value(
2488         "userdata_template", vm_, opts, search_global=False, default=None
2489     )
2490     if userdata_template is False:
2491         return userdata
2492     renderer = (
2493         opts.get("userdata_template")
2494         if userdata_template is None
2495         else userdata_template
2496     )
2497     if renderer is None:
2498         return userdata
2499     else:
2500         render_opts = opts.copy()
2501         render_opts.update(vm_)
2502         rend = salt.loader.render(render_opts, {})
2503         blacklist = opts["renderer_blacklist"]
2504         whitelist = opts["renderer_whitelist"]
2505         templated = salt.template.compile_template(
2506             ":string:",
2507             rend,
2508             renderer,
2509             blacklist,
2510             whitelist,
2511             input_data=userdata,
2512         )
2513         if not isinstance(templated, str):
2514             try:
2515                 templated = "".join(templated.readlines())
2516             except AttributeError:
2517                 log.warning(
2518                     "Templated userdata resulted in non-string result (%s), "
2519                     "converting to string",
2520                     templated,
2521                 )
2522                 templated = str(templated)
2523         return templated
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>composer_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os.path
3 import salt.utils.args
4 import salt.utils.path
5 from salt.exceptions import (
6     CommandExecutionError,
7     CommandNotFoundError,
8     SaltInvocationError,
9 )
10 log = logging.getLogger(__name__)
11 __func_alias__ = {"list_": "list"}
12 def __virtual__():
13     return True
14 def _valid_composer(composer):
15     if salt.utils.path.which(composer):
16         return True
17     return False
18 def did_composer_install(dir):
19     lockFile = "{}/vendor".format(dir)
20     if os.path<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.exists(lockFile):
21         return True
22     return False
23 def _run_composer(
24     action,
25     directory=None,
26     composer=None,
27     php=None,
28     runas=None,
29     prefer_source=None,
30     prefer_dist=None,
31     no_scripts=None,
32     no_plugins=None,
33     optimize=None,
34     no_dev=None,
35     quiet=False,
36     composer_home="/root",
37     extra_flags=None,
38     env=</b></font>None,
39 ):
40     if composer is not None:
41         if php is None:
42             php = "php"
43     else:
44         composer = "composer"
45     if not _valid_composer(composer):
46         raise CommandNotFoundError(
47             "'composer.{}' is not available. Couldn't find '{}'.".format(
48                 action, composer
49             )
50         )
51     if action is None:
52         raise SaltInvocationError("The 'action' argument is required")
53     if directory is None and action != "selfupdate":
54         raise SaltInvocationError(
55             "The 'directory' argument is required for composer.{}".format(action)
56         )
57     cmd = [composer, action, "--no-interaction", "--no-ansi"]
58     if extra_flags is not None:
59         cmd.extend(salt.utils.args.shlex_split(extra_flags))
60     if php is not None:
61         cmd = [php] + cmd
62     if directory is not None:
63         cmd.extend(["--working-dir", directory])
64     if quiet is True:
65         cmd.append("--quiet")
66     if no_dev is True:
67         cmd.append("--no-dev")
68     if prefer_source is True:
69         cmd.append("--prefer-source")
70     if prefer_dist is True:
71         cmd.append("--prefer-dist")
72     if no_scripts is True:
73         cmd.append("--no-scripts")
74     if no_plugins is True:
75         cmd.append("--no-plugins")
76     if optimize is True:
77         cmd.append("--optimize-autoloader")
78     if env is not None:
79         env = salt.utils.data.repack_dictlist(env)
80         env["COMPOSER_HOME"] = composer_home
81     else:
82         env = {"COMPOSER_HOME": composer_home}
83     result = __salt__["cmd.run_all"](cmd, runas=runas, env=env, python_shell=False)
84     if result["retcode"] != 0:
85     if quiet is True:
86         r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn True
87     return result
88 def install(
89     directory,
90     composer=None,
91     php=None,
92     runas=None,
93     prefer_source=None,
94     prefer_dist=None,
95     no_scripts=None,
96     no_plugins=None,
97     optimize=None,
98     no_dev=None,
99     quiet=False,
100     composer_home="/root",
101     env=None,
102 ):
103     """
104     result =</b></font> _run_composer(
105         "install",
106         directory<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=directory,
107         composer=composer,
108         php=php,
109         runas=runas,
110         prefer_source=prefer_source,
111         prefer_dist=prefer_dist,
112         no_scripts=no_scripts,
113         no_plugins=no_plugins,
114         optimize=optimize,
115         no_dev=no_dev,
116         quiet=quiet,
117         env=</b></font>env,
118     )
119     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return result
120 def update(
121     directory,
122     composer=None,
123     php=None,
124     runas=None,
125     prefer_source=None,
126     prefer_dist=None,
127     no_scripts=None,
128     no_plugins=None,
129     optimize=None,
130     no_dev=None,
131     quiet=False,
132     composer_home="/root",
133     env=</b></font>None,
134 ):
135     """
136     Update composer dependencies for a directory.
137     If `composer install` has not yet been run, this runs `composer install`
138     instead.
139     If composer has not been installed globally making it available in the
140     system PATH &amp; making it executable, the ``composer`` and ``php`` parameters
141     will need to be set to the location of the executables.
142     directory
143         Directory location of the composer.json file.
144     composer
145         Location of the composer.phar file. If not set composer will
146         just execute "composer" as if it is installed globally.
147         (i.e. /path/to/composer.phar)
148     php
149         Location of the php executable to use with composer.
150         (i.e. /usr/bin/php)
151     runas
152         Which system user to run composer as.
153     prefer_source
154         --prefer-source option of composer.
155     prefer_dist
156         --prefer-dist option of composer.
157     no_scripts
158         --no-scripts option of composer.
159     no_plugins
160         --no-plugins option of composer.
161     optimize
162         --optimize-autoloader option of composer. Recommended for production.
163     no_dev
164         --no-dev option for composer. Recommended for production.
165     quiet
166         --quiet option for composer. Whether or not to return output from composer.
167     composer_home
168         $COMPOSER_HOME environment variable
169     env
170         A list of environment variables to be set prior to execution.
171     CLI Example:
172     .. code-block:: bash
173         salt '*' composer.update /var/www/application
174         salt '*' composer.update /var/www/application \
175             no_dev=True optimize=True
176     result = _run_composer(
177         "update",
178         directory<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=directory,
179         extra_flags="--no-progress",
180         composer=composer,
181         php=php,
182         runas=runas,
183         prefer_source=prefer_source,
184         prefer_dist=prefer_dist,
185         no_scripts=no_scripts,
186         no_plugins=no_plugins,
187         optimize=optimize,
188         no_dev=no_dev,
189         quiet=quiet,
190         composer_home=composer_home,
191         env=</b></font>env,
192     )
193     return result
194 def selfupdate(composer=None, php=None, runas=None, quiet=False, composer_home="/root"):
195     """
196     Update composer itself.
197     If composer has not been installed globally making it available in the
198     system PATH &amp; making it executable, the ``composer`` and ``php`` parameters
199     will need to be set to the location of the executables.
200     composer
201         Location of the composer.phar file. If not set composer will
202         just execute "composer" as if it is installed globally.
203         (i.e. /path/to/composer.phar)
204     php
205         Location of the php executable to use with composer.
206         (i.e. /usr/bin/php)
207     runas
208         Which system user to run composer as.
209     quiet
210         --quiet option for composer. Whether or not to return output from composer.
211     composer_home
212         $COMPOSER_HOME environment variable
213     CLI Example:
214     .. code-block:: bash
215         salt '*' composer.selfupdate
216     """
217     result = _run_composer(
218         "selfupdate",
219         extra_flags="--no-progress",
220         composer=composer,
221         php=php,
222         runas=runas,
223         quiet=quiet,
224         composer_home=composer_home,
225     )
226     return result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
