<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_lgpo_1.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_lgpo_1.py &amp; virt_1.py
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_lgpo_1.py (5.3507195%)<th>virt_1.py (6.136393%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(436-486)<td><a href="#" name="0">(5947-5954)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-93)<td><a href="#" name="1">(2000-2792)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(10482-10489)<td><a href="#" name="2">(7727-7813)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(104-110)<td><a href="#" name="3">(2948-2957)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(39-59)<td><a href="#" name="4">(122-142)</a><td align="center"><font color="#d40000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(5109-5112)<td><a href="#" name="5">(6661-6666)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(111-116)<td><a href="#" name="6">(2883-2888)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(341-375)<td><a href="#" name="7">(6025-6029)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(9144-9154)<td><a href="#" name="8">(1453-1463)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(7613-7618)<td><a href="#" name="9">(8762-8770)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(7521-7544)<td><a href="#" name="10">(8336-8339)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(6641-6648)<td><a href="#" name="11">(8658-8668)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(6600-6614)<td><a href="#" name="12">(8982-9010)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(7544-7552)<td><a href="#" name="13">(6469-6474)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(7339-7345)<td><a href="#" name="14">(6646-6651)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(7042-7048)<td><a href="#" name="15">(4486-4492)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(6039-6043)<td><a href="#" name="16">(637-643)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(4997-5000)<td><a href="#" name="17">(6846-6849)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(805-834)<td><a href="#" name="18">(3987-4003)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(10151-10167)<td><a href="#" name="19">(1946-1951)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(8464-8469)<td><a href="#" name="20">(167-173)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(7718-7723)<td><a href="#" name="21">(4807-4833)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(7648-7650)<td><a href="#" name="22">(6759-6763)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(7645-7647)<td><a href="#" name="23">(4499-4501)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(7634-7641)<td><a href="#" name="24">(5563-5565)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(7320-7324)<td><a href="#" name="25">(1465-1472)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(6513-6519)<td><a href="#" name="26">(6776-6784)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(6427-6433)<td><a href="#" name="27">(6418-6421)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(6245-6249)<td><a href="#" name="28">(3202-3204)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(5888-5891)<td><a href="#" name="29">(3420-3425)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(5079-5083)<td><a href="#" name="30">(1147-1149)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(134-153)<td><a href="#" name="31">(8238-8245)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(120-129)<td><a href="#" name="32">(8948-8952)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from</b></font> salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ = "lgpo"
23 __func_alias__ = {"set_": "set"}
24 <a name="1"></a>
25 UUID = uuid.uuid4().hex
26 adm_policy_name_map = {True: {}, False: {}}
27 HAS_WINDOWS_MODULES <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= False
28 TRUE_VALUE_XPATH = None
29 FALSE_VALUE_XPATH = None
30 ELEMENTS_XPATH = None
31 ENABLED_VALUE_XPATH = None
32 DISABLED_VALUE_XPATH = None
33 ENABLED_LIST_XPATH = None
34 DISABLED_LIST_XPATH = None
35 VALUE_XPATH = None
36 TRUE_LIST_XPATH = None
37 FALSE_LIST_XPATH = None
38 REGKEY_XPATH = None
39 POLICY_ANCESTOR_XPATH = None
40 ALL_CLASS_POLICY_XPATH = None
41 ADML_DISPLAY_NAME_XPATH = None
42 VALUE_LIST_XPATH = None
43 ENUM_ITEM_DISPLAY_NAME_XPATH = None
44 ADMX_SEARCH_XPATH = None
45 ADML_SEARCH_XPATH = None
46 ADMX_DISPLAYNAME_SEARCH_XPATH = None
47 PRESENTATION_ANCESTOR_XPATH = None
48 TEXT_ELEMENT_XPATH = None
49 try</b></font>:
50     import struct
51     import lxml
52     import win32net
53     import win32security
54     from lxml import etree
55 <a name="3"></a>    from salt.utils.win_reg import Registry
56     HAS_WINDOWS_MODULES = True
57     TRUE_VALUE_XPATH <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath('.//*[local-name() = "trueValue"]')
58     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
59     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
60     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
61 <a name="6"></a>    DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
62     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
63     DISABLED_LIST_XPATH = etree.XPath(</b></font>'.//*[local-name() = "disabledList"]')
64     VALUE_XPATH <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath('.//*[local-name() = "value"]')
65     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
66     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
67     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
68     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
69     ALL_CLASS_POLICY_XPATH = etree.XPath(</b></font>
70 <a name="32"></a>        '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
71         ' @*[local-name() = "class"] = $registry_class)]'
72     )
73     ADML_DISPLAY_NAME_XPATH <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath(
74         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
75         " $displayNameId]"
76     )
77     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
78     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
79         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
80         " $display_name]]"
81     )
82     ADMX_SEARCH_XPATH = etree.XPath(</b></font>
83         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
84 <a name="31"></a>        ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
85         " $registry_class)]"
86     )
87     ADML_SEARCH_XPATH = etree<font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.XPath(
88         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
89     )
90     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
91         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
92         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
93         ' "class"] = $registry_class) ]'
94     )
95     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
96         'ancestor::*[local-name() = "presentation"]'
97     )
98     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
99     windll =</b></font> ctypes.windll.kernel32
100     INSTALL_LANGUAGE = locale.windows_locale.get(
101         windll.GetSystemDefaultUILanguage(), "en_US"
102     ).replace("_", "-")
103 except ImportError:
104     HAS_WINDOWS_MODULES = False
105 class _policy_info:
106     r"""
107     Policy Helper Class
108     ===================
109     The format of the policy dict is as follows:
110     The top most two key/value pairs in the dict divide the policies object into
111     the two sections of local group policy, using the keys "Machine" and "User".
112     The value make-up of these dicts are described below in "Policy Section
113     Definition"
114     Policy Section Definition
115     -------------------------
116     A policy section dict has two required key/value pairs:
117     ============  ==============================================================
118     Key
119     ============  ==============================================================
120     lgpo_section  String matching how the policy section is displayed in the mmc
121                   snap-in ("Computer Configuration" for "Machine" and "User
122                   Configuration" for "User")
123     policies      a dict containing the non-Administrative template policy
124                   definitions, the key for each item is a short/unique
125                   identifier for the policy, the value is described below in
126                   "Policies Definition"
127     ============  ==============================================================
128     Policies Definition
129     -------------------
130     A policies definition item describes the particular policy. There are three
131     child key/value pairs shared with all policy types:
132     ============  ==============================================================
133     Key           Value
134     ============  ==============================================================
135     lgpo_section  A list containing the hierarchical path to the policy in the
136                   gpedit mmc snap-in.
137     Policy        A string containing the name of the policy in the gpedit mmc
138                   snap-in
139     Settings      An object which describes valid settings for the policy. This
140                   can be None for no validation, a list of possible settings, or
141                   a dict with the following key/value pairs:
142                   - **Function:** The class function to use to validate the
143                     setting
144                   - **Args:** A dict of kwargs to pass to the class function
145     ============  ==============================================================
146     Additionally, each policies definition will contain a key/value pair that
147     defines the mechanism that will be used to configure the policy. The
148     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
149     Registry Mechanism
150     ------------------
151     Some policies simply set values in the Windows registry. The value of this
152     key is a dict with the following make-up:
153     =====  =====================================================================
154     Key    Value
155     =====  =====================================================================
156     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
157     Path   A string containing the registry key path, such as
158            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
159     Value  A string containing the name of the registry value, such as
160            **restrictanonymous**
161     Type   A string containing the registry type of the value, such as
162            ``REG_DWORD``
163     =====  =====================================================================
164     Secedit Mechanism
165     -----------------
166     Some policies are configurable via the "secedit.exe" executable. The value
167     of this key is a dict with the following make-up:
168     =======  ===================================================================
169     Key      Value
170     =======  ===================================================================
171     Option   A string containing the name of the policy as it appears in an
172              export from secedit, such as **PasswordComplexity**
173     Section  A string containing the name of the section in which the "Option"
174              value appears in an export from ``secedit``, such as "System
175              Access"
176     =======  ===================================================================
177     LsaRights Mechanism
178     -------------------
179     LSA Rights policies are configured via the LsaRights mechanism. The value of
180     this key is a dict with the following make-up:
181     ======  ====================================================================
182     Key     Value
183     ======  ====================================================================
184     Option  A string containing the programmatic name of the Lsa Right, such as
185             **SeNetworkLogonRight**
186     ======  ====================================================================
187     NetUserModal Mechanism
188     ----------------------
189     Some policies are configurable by the **NetUserModalGet** and
190     **NetUserModalSet** function from pywin32.  The value of this key is a dict
191     with the following make-up:
192     ======  ====================================================================
193     Key     Value
194     ======  ====================================================================
195     Modal   The modal "level" that the particular option is specified in (0-3),
196             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
197             aa370656(v=vs.85).aspx&gt;`_
198     Option  The name of the structure member which contains the data for the
199             policy, for example **max_passwd_age**
200     ======  ====================================================================
201     NetSH Mechanism
202     ---------------
203     The firewall policies are configured by the ``netsh.exe`` executable. The
204     value of this key is a dict with the following make-up:
205     =======  ===================================================================
206     Key      Value
207     =======  ===================================================================
208     Profile  The firewall profile to modify. Can be one of Domain, Private, or
209              Public
210     Section  The section of the firewall to modify. Can be one of state,
211              firewallpolicy, settings, or logging.
212     Option   The setting within that section
213     Value    The value of the setting
214     =======  ===================================================================
215     More information can be found in the advfirewall context in netsh. This can
216     be access by opening a netsh prompt. At a command prompt type the following:
217     c:\&gt;netsh
218     netsh&gt;advfirewall
219     netsh advfirewall&gt;set help
220     netsh advfirewall&gt;set domain help
221     AdvAudit Mechanism
222     ------------------
223     The Advanced Audit Policies are configured using a combination of the
224     auditpol command-line utility and modifying the audit.csv file in two
225     locations. The value of this key is a dict with the following make-up:
226     ======  ===================================
227     Key     Value
228     ======  ===================================
229     Option  The Advanced Audit Policy to modify
230     ======  ===================================
231     Transforms
232     ----------
233     Optionally, each policy definition can contain a "Transform" key. The
234     Transform key is used to handle data that is stored and viewed differently.
235     This key's value is a dict with the following key/value pairs:
236     ===  =======================================================================
237     Key  Value
238     ===  =======================================================================
239     Get  The name of the class function to use to transform the data from the
240          stored value to how the value is displayed in the GUI
241     Put The name of the class function to use to transform the data supplied by
242         the user to the correct value that the policy is stored in
243     ===  =======================================================================
244     For example, "Minimum password age" is stored in seconds, but is displayed
245     in days.  Thus the "Get" and "Put" functions for this policy do these
246     conversions so the user is able to set and view the policy using the same
247     data that is shown in the GUI.
248 <a name="7"></a>    """
249     def __init__(self):
250         self<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.audit_lookup = {
251             0: "No auditing",
252             1: "Success",
253             2: "Failure",
254             3: "Success, Failure",
255             "Not Defined": "Not Defined",
256             None: "Not Defined",
257         }
258         self.advanced_audit_lookup = {
259             0: "No Auditing",
260             1: "Success",
261             2: "Failure",
262             3: "Success and Failure",
263             None: "Not Configured",
264         }
265         self.sc_removal_lookup = {
266             "0": "No Action",
267             "1": "Lock Workstation",
268             "2": "Force Logoff",
269             "3": "Disconnect if a Remote Desktop Services session",
270             None: "Not Defined",
271             "(value not set)": "Not Defined",
272         }
273         self.uac_admin_prompt_lookup = {
274             0: "Elevate without prompting",
275             1: "Prompt for credentials on the secure desktop",
276             2: "Prompt for consent on the secure desktop",
277             3: "Prompt for credentials",
278             4: "Prompt for consent",
279             5: "Prompt for consent for non-Windows binaries",
280             None: "Not Defined",
281             "(value not set)": "Not Defined",
282         }
283         self.uac_user_prompt_lookup = {
284             0</b></font>: "Automatically deny elevation requests",
285             1: "Prompt for credentials on the secure desktop",
286             3: "Prompt for credentials",
287             None: "Not Defined",
288             "(value not set)": "Not Defined",
289         }
290         self.enabled_one_disabled_zero = {
291             0: "Disabled",
292             1: "Enabled",
293             None: "Not Defined",
294             "(value not set)": "Not Defined",
295         }
296         self.enabled_one_disabled_zero_transform = {
297             "Get": "_dict_lookup",
298             "Put": "_dict_lookup",
299             "GetArgs": {
300                 "lookup": self.enabled_one_disabled_zero,
301                 "value_lookup": False,
302             },
303             "PutArgs": {
304                 "lookup": self.enabled_one_disabled_zero,
305                 "value_lookup": True,
306             },
307         }
308         self.s4u2self_options = {
309             0: "Default",
310             1: "Enabled",
311             2: "Disabled",
312             None: "Not Defined",
313             "(value not set)": "Not Defined",
314         }
315         self.audit_transform = {
316             "Get": "_dict_lookup",
317             "Put": "_dict_lookup",
318             "GetArgs": {"lookup": self.audit_lookup, "value_lookup": False},
319             "PutArgs": {"lookup": self.audit_lookup, "value_lookup": True},
320         }
321         self.advanced_audit_transform = {
322             "Get": "_dict_lookup",
323             "Put": "_dict_lookup",
324             "GetArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": False},
325             "PutArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": True},
326         }
327         self.enabled_one_disabled_zero_strings = {
328             "0": "Disabled",
329             "1": "Enabled",
330             None: "Not Defined",
331             "(value not set)": "Not Defined",
332         }
333         self.enabled_one_disabled_zero_strings_transform = {
334             "Get": "_dict_lookup",
335             "Put": "_dict_lookup",
336             "GetArgs": {
337                 "lookup": self.enabled_one_disabled_zero_strings,
338                 "value_lookup": False,
339             },
340             "PutArgs": {
341                 "lookup": self.enabled_one_disabled_zero_strings,
342 <a name="0"></a>                "value_lookup": True,
343             },
344         }
345         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.security_options_gpedit_path = [
346             "Computer Configuration",
347             "Windows Settings",
348             "Security Settings",
349             "Local Policies",
350             "Security Options",
351         ]
352         self.windows_firewall_gpedit_path = [
353             "Computer Configuration",
354             "Windows Settings",
355             "Security Settings",
356             "Windows Firewall with Advanced Security",
357             "Windows Firewall with Advanced Security - Local Group Policy Object",
358         ]
359         self.password_policy_gpedit_path = [
360             "Computer Configuration",
361             "Windows Settings",
362             "Security Settings",
363             "Account Policies",
364             "Password Policy",
365         ]
366         self.audit_policy_gpedit_path = [
367             "Computer Configuration",
368             "Windows Settings",
369             "Security Settings",
370             "Local Policies",
371             "Audit Policy",
372         ]
373         self.advanced_audit_policy_gpedit_path = [
374             "Computer Configuration",
375             "Windows Settings",
376             "Security Settings",
377             "Advanced Audit Policy Configuration",
378             "System Audit Policies - Local Group Policy Object",
379         ]
380         self.account_lockout_policy_gpedit_path = [
381             "Computer Configuration",
382             "Windows Settings",
383             "Security Settings",
384             "Account Policies",
385             "Account Lockout Policy",
386         ]
387         self.user_rights_assignment_gpedit_path = [
388             "Computer Configuration",
389             "Windows Settings",
390             "Security Settings",
391             "Local Policies",
392             "User Rights Assignment",
393         ]
394         self.block_ms_accounts = {
395             0</b></font>: "This policy is disabled",
396             1: "Users can't add Microsoft accounts",
397             3: "Users can't add or log on with Microsoft accounts",
398             None: "Not Defined",
399             "(value not set)": "Not Defined",
400         }
401         self.ldap_server_signing_requirements = {
402             1: "None",
403             2: "Require signing",
404             None: "Not Defined",
405             "(value not set)": "Not Defined",
406         }
407         self.smb_server_name_hardening_levels = {
408             0: "Off",
409             1: "Accept if provided by client",
410             2: "Required from client",
411             None: "Not Defined",
412             "(value not set)": "Not Defined",
413         }
414         self.locked_session_user_info = {
415             1: "User display name, domain and user names",
416             2: "User display name only",
417             3: "Do not display user information",
418             None: "Not Defined",
419             "(value not set)": "Not Defined",
420         }
421         self.force_guest = {
422             0: "Classic - local users authenticate as themselves",
423             1: "Guest only - local users authenticate as Guest",
424             None: "Not Defined",
425             "(value not set)": "Not Defined",
426         }
427         self.force_key_protection = {
428             0: "User input is not required when new keys are stored and used",
429             1: "User is prompted when the key is first used",
430             2: "User must enter a password each time they use a key",
431             None: "Not Defined",
432             "(value not set)": "Not Defined",
433         }
434         self.firewall_inbound_connections = {
435             "blockinbound": "Block (default)",
436             "blockinboundalways": "Block all connections",
437             "allowinbound": "Allow",
438             "notconfigured": "Not configured",
439         }
440         self.firewall_outbound_connections = {
441             "blockoutbound": "Block",
442             "allowoutbound": "Allow (default)",
443             "notconfigured": "Not configured",
444         }
445         self.firewall_rule_merging = {
446             "enable": "Yes (default)",
447             "disable": "No",
448             "notconfigured": "Not configured",
449         }
450         self.firewall_log_packets_connections = {
451             "enable": "Yes",
452             "disable": "No (default)",
453             "notconfigured": "Not configured",
454         }
455         self.firewall_notification = {
456             "enable": "Yes",
457             "disable": "No",
458             "notconfigured": "Not configured",
459         }
460         self.firewall_state = {
461             "on": "On (recommended)",
462             "off": "Off",
463             "notconfigured": "Not configured",
464         }
465         self.krb_encryption_types = {
466             0: "No minimum",
467             1: "DES_CBC_CRC",
468             2: "DES_CBD_MD5",
469             4: "RC4_HMAC_MD5",
470             8: "AES128_HMAC_SHA1",
471             16: "AES256_HMAC_SHA1",
472             2147483616: "Future Encryption Types",
473             None: "Not Defined",
474             "(value not set)": "Not Defined",
475         }
476         self.lm_compat_levels = {
477             0: "Send LM &amp; NTLM response",
478             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
479             2: "Send NTLM response only",
480             3: "Send NTLMv2 response only",
481             4: "Send NTLMv2 response only. Refuse LM",
482             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
483             None: "Not Defined",
484             "(value not set)": "Not Defined",
485         }
486         self.ldap_signing_reqs = {
487             0: "None",
488             1: "Negotiate signing",
489             2: "Require signing",
490             None: "Not Defined",
491             "(value not set)": "Not Defined",
492         }
493         self.ntlm_session_security_levels = {
494             0: "No minimum",
495             524288: "Require NTLMv2 session security",
496             536870912: "Require 128-bit encryption",
497             None: "Not Defined",
498             "(value not set)": "Not Defined",
499         }
500         self.ntlm_audit_settings = {
501             0: "Disable",
502             1: "Enable auditing for domain accounts",
503             2: "Enable auditing for all accounts",
504             None: "Not Defined",
505             "(value not set)": "Not Defined",
506         }
507         self.ntlm_domain_audit_settings = {
508             0: "Disable",
509             1: "Enable for domain accounts to domain servers",
510             3: "Enable for domain accounts",
511             5: "Enable for domain servers",
512             7: "Enable all",
513             None: "Not Defined",
514             "(value not set)": "Not Defined",
515         }
516         self.incoming_ntlm_settings = {
517             0: "Allow all",
518             1: "Deny all domain accounts",
519             2: "Deny all accounts",
520             None: "Not Defined",
521             "(value not set)": "Not Defined",
522         }
523         self.ntlm_domain_auth_settings = {
524             0: "Disable",
525             1: "Deny for domain accounts to domain servers",
526             3: "Deny for domain accounts",
527             5: "Deny for domain servers",
528             7: "Deny all",
529             None: "Not Defined",
530             "(value not set)": "Not Defined",
531         }
532         self.outgoing_ntlm_settings = {
533             0: "Allow all",
534             1: "Audit all",
535             2: "Deny all",
536             None: "Not Defined",
537             "(value not set)": "Not Defined",
538         }
539         self.enabled_one_disabled_zero_no_not_defined = {
540             0: "Disabled",
541             1: "Enabled",
542         }
543         self.enabled_one_disabled_zero_no_not_defined_transform = {
544             "Get": "_dict_lookup",
545             "Put": "_dict_lookup",
546             "GetArgs": {
547                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
548                 "value_lookup": False,
549             },
550             "PutArgs": {
551                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
552                 "value_lookup": True,
553             },
554         }
555         self.policies = {
556             "Machine": {
557                 "lgpo_section": "Computer Configuration",
558                 "policies": {
559                     "StartupScripts": {
560                         "Policy": "Startup Scripts",
561                         "lgpo_section": [
562                             "Computer Configuration",
563                             "Windows Settings",
564                             "Scripts (Startup/Shutdown)",
565                             "Startup",
566                         ],
567                         "ScriptIni": {
568                             "Section": "Startup",
569                             "IniPath": os.path.join(
570                                 os.getenv("WINDIR"),
571                                 "System32",
572                                 "GroupPolicy",
573                                 "Machine",
574                                 "Scripts",
575                                 "scripts.ini",
576                             ),
577                         },
578                     },
579                     "StartupPowershellScripts": {
580                         "Policy": "Startup Powershell Scripts",
581                         "lgpo_section": [
582                             "Computer Configuration",
583                             "Windows Settings",
584                             "Scripts (Startup/Shutdown)",
585                             "Startup",
586                         ],
587                         "ScriptIni": {
588                             "Section": "Startup",
589                             "IniPath": os.path.join(
590                                 os.getenv("WINDIR"),
591                                 "System32",
592                                 "GroupPolicy",
593                                 "Machine",
594                                 "Scripts",
595                                 "psscripts.ini",
596                             ),
597                         },
598                     },
599                     "StartupPowershellScriptOrder": {
600                         "Policy": (
601                             "Startup - For this GPO, run scripts in the following order"
602                         ),
603                         "lgpo_section": [
604                             "Computer Configuration",
605                             "Windows Settings",
606                             "Scripts (Startup/Shutdown)",
607                             "Startup",
608                         ],
609                         "ScriptIni": {
610                             "IniPath": os.path.join(
611                                 os.getenv("WINDIR"),
612                                 "System32",
613                                 "GroupPolicy",
614                                 "Machine",
615                                 "Scripts",
616                                 "psscripts.ini",
617                             ),
618                             "Section": "ScriptsConfig",
619                             "SettingName": "StartExecutePSFirst",
620                             "Settings": ["true", "false", None],
621                         },
622                         "Transform": {
623                             "Get": "_powershell_script_order_conversion",
624                             "Put": "_powershell_script_order_reverse_conversion",
625                         },
626                     },
627                     "ShutdownScripts": {
628                         "Policy": "Shutdown Scripts",
629                         "lgpo_section": [
630                             "Computer Configuration",
631                             "Windows Settings",
632                             "Scripts (Startup/Shutdown)",
633                             "Shutdown",
634                         ],
635                         "ScriptIni": {
636                             "Section": "Shutdown",
637                             "IniPath": os.path.join(
638                                 os.getenv("WINDIR"),
639                                 "System32",
640                                 "GroupPolicy",
641                                 "Machine",
642                                 "Scripts",
643                                 "scripts.ini",
644                             ),
645                         },
646                     },
647                     "ShutdownPowershellScripts": {
648                         "Policy": "Shutdown Powershell Scripts",
649                         "lgpo_section": [
650                             "Computer Configuration",
651                             "Windows Settings",
652                             "Scripts (Startup/Shutdown)",
653                             "Shutdown",
654                         ],
655                         "ScriptIni": {
656                             "Section": "Shutdown",
657                             "IniPath": os.path.join(
658                                 os.getenv("WINDIR"),
659                                 "System32",
660                                 "GroupPolicy",
661                                 "Machine",
662                                 "Scripts",
663                                 "psscripts.ini",
664                             ),
665                         },
666                     },
667                     "ShutdownPowershellScriptOrder": {
668                         "Policy": (
669                             "Shutdown - For this GPO, run scripts in the "
670                             "following order"
671                         ),
672                         "lgpo_section": [
673                             "Computer Configuration",
674                             "Windows Settings",
675                             "Scripts (Startup/Shutdown)",
676                             "Shutdown",
677                         ],
678                         "ScriptIni": {
679                             "IniPath": os.path.join(
680                                 os.getenv("WINDIR"),
681                                 "System32",
682                                 "GroupPolicy",
683                                 "Machine",
684                                 "Scripts",
685                                 "psscripts.ini",
686                             ),
687                             "Section": "ScriptsConfig",
688                             "SettingName": "EndExecutePSFirst",
689                             "Settings": ["true", "false", None],
690                         },
691                         "Transform": {
692                             "Get": "_powershell_script_order_conversion",
693                             "Put": "_powershell_script_order_reverse_conversion",
694                         },
695                     },
696                     "LSAAnonymousNameLookup": {
697                         "Policy": (
698                             "Network access: Allow anonymous SID/Name translation"
699                         ),
700                         "lgpo_section": self.password_policy_gpedit_path,
701                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
702                         "Secedit": {
703                             "Option": "LSAAnonymousNameLookup",
704                             "Section": "System Access",
705                         },
706                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
707                     },
708                     "RestrictAnonymousSam": {
709                         "Policy": (
710                             "Network access: Do not allow anonymous "
711 <a name="18"></a>                            "enumeration of SAM accounts"
712                         ),
713                         "lgpo_section": self.security_options_gpedit_path,
714                         "Settings": self.enabled_one_disabled_zero<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.keys(),
715                         "Registry": {
716                             "Hive": "HKEY_LOCAL_MACHINE",
717                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
718                             "Value": "RestrictAnonymousSam",
719                             "Type": "REG_DWORD",
720                         },
721                         "Transform": self.enabled_one_disabled_zero_transform,
722                     },
723                     "RestrictRemoteSAM": {
724                         "Policy": (
725                             "Network access: Restrict clients allowed to "
726                             "make remote calls to SAM"
727                         ),
728                         "lgpo_section": self.security_options_gpedit_path,
729                         "Registry": {
730                             "Hive": "HKEY_LOCAL_MACHINE",
731                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
732                             "Value": "RestrictRemoteSAM",
733                             "Type": "REG_SZ",
734                         },
735                         "Transform": {"Put": "_string_put_transform"},
736                     },
737                     "RestrictAnonymous": {
738                         "Policy": (
739                             "Network access: Do not allow anonymous "
740                             "enumeration of SAM accounts and shares"
741                         ),
742                         "lgpo_section": self.security_options_gpedit_path,
743                         "Settings": self.enabled_one_disabled_zero.keys(</b></font>),
744                         "Registry": {
745                             "Hive": "HKEY_LOCAL_MACHINE",
746                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
747                             "Value": "RestrictAnonymous",
748                             "Type": "REG_DWORD",
749                         },
750                         "Transform": self.enabled_one_disabled_zero_transform,
751                     },
752                     "DisableDomainCreds": {
753                         "Policy": (
754                             "Network access: Do not allow storage of "
755                             "passwords and credentials for network "
756                             "authentication"
757                         ),
758                         "lgpo_section": self.security_options_gpedit_path,
759                         "Settings": self.enabled_one_disabled_zero.keys(),
760                         "Registry": {
761                             "Hive": "HKEY_LOCAL_MACHINE",
762                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
763                             "Value": "DisableDomainCreds",
764                             "Type": "REG_DWORD",
765                         },
766                         "Transform": self.enabled_one_disabled_zero_transform,
767                     },
768                     "EveryoneIncludesAnonymous": {
769                         "Policy": (
770                             "Network access: Let Everyone permissions "
771                             "apply to anonymous users"
772                         ),
773                         "lgpo_section": self.security_options_gpedit_path,
774                         "Settings": self.enabled_one_disabled_zero.keys(),
775                         "Registry": {
776                             "Hive": "HKEY_LOCAL_MACHINE",
777                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
778                             "Value": "everyoneincludesanonymous",
779                             "Type": "REG_DWORD",
780                         },
781                         "Transform": self.enabled_one_disabled_zero_transform,
782                     },
783                     "NullSessionPipes": {
784                         "Policy": (
785                             "Network access: Named Pipes that can be "
786                             "accessed anonymously"
787                         ),
788                         "lgpo_section": self.security_options_gpedit_path,
789                         "Registry": {
790                             "Hive": "HKEY_LOCAL_MACHINE",
791                             "Path": (
792                                 "SYSTEM\\CurrentControlSet\\Services\\"
793                                 "LanmanServer\\Parameters"
794                             ),
795                             "Value": "NullSessionPipes",
796                             "Type": "REG_MULTI_SZ",
797                         },
798                         "Transform": {
799                             "Put": "_multi_string_put_transform",
800                             "Get": "_multi_string_get_transform",
801                         },
802                     },
803                     "RemoteRegistryExactPaths": {
804                         "Policy": "Network access: Remotely accessible registry paths",
805                         "lgpo_section": self.security_options_gpedit_path,
806                         "Registry": {
807                             "Hive": "HKEY_LOCAL_MACHINE",
808                             "Path": (
809                                 "SYSTEM\\CurrentControlSet\\Control\\"
810                                 "SecurePipeServers\\winreg\\"
811                                 "AllowedExactPaths"
812                             ),
813                             "Value": "Machine",
814                             "Type": "REG_MULTI_SZ",
815                         },
816                         "Transform": {
817                             "Put": "_multi_string_put_transform",
818                             "Get": "_multi_string_get_transform",
819                         },
820                     },
821                     "RemoteRegistryPaths": {
822                         "Policy": (
823                             "Network access: Remotely accessible "
824                             "registry paths and sub-paths"
825                         ),
826                         "lgpo_section": self.security_options_gpedit_path,
827                         "Registry": {
828                             "Hive": "HKEY_LOCAL_MACHINE",
829                             "Path": (
830                                 "SYSTEM\\CurrentControlSet\\Control\\"
831                                 "SecurePipeServers\\winreg\\AllowedPaths"
832                             ),
833                             "Value": "Machine",
834                             "Type": "REG_MULTI_SZ",
835                         },
836                         "Transform": {
837                             "Put": "_multi_string_put_transform",
838                             "Get": "_multi_string_get_transform",
839                         },
840                     },
841                     "RestrictNullSessAccess": {
842                         "Policy": (
843                             "Network access: Restrict anonymous access "
844                             "to Named Pipes and Shares"
845                         ),
846                         "lgpo_section": self.security_options_gpedit_path,
847                         "Settings": self.enabled_one_disabled_zero.keys(),
848                         "Registry": {
849                             "Hive": "HKEY_LOCAL_MACHINE",
850                             "Path": (
851                                 "System\\CurrentControlSet\\Services\\"
852                                 "LanmanServer\\Parameters"
853                             ),
854                             "Value": "RestrictNullSessAccess",
855                             "Type": "REG_DWORD",
856                         },
857                         "Transform": self.enabled_one_disabled_zero_transform,
858                     },
859                     "NullSessionShares": {
860                         "Policy": (
861                             "Network access: Shares that can be accessed anonymously"
862                         ),
863                         "lgpo_section": self.security_options_gpedit_path,
864                         "Registry": {
865                             "Hive": "HKEY_LOCAL_MACHINE",
866                             "Path": (
867                                 "SYSTEM\\CurrentControlSet\\Services\\"
868                                 "LanmanServer\\Parameters"
869                             ),
870                             "Value": "NullSessionShares",
871                             "Type": "REG_MULTI_SZ",
872                         },
873                         "Transform": {
874                             "Put": "_multi_string_put_transform",
875                             "Get": "_multi_string_get_transform",
876                         },
877                     },
878                     "ForceGuest": {
879                         "Policy": (
880                             "Network access: Sharing and security model "
881                             "for local accounts"
882                         ),
883                         "lgpo_section": self.security_options_gpedit_path,
884                         "Settings": self.force_guest.keys(),
885                         "Registry": {
886                             "Hive": "HKEY_LOCAL_MACHINE",
887                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
888                             "Value": "ForceGuest",
889                             "Type": "REG_DWORD",
890                         },
891                         "Transform": {
892                             "Get": "_dict_lookup",
893                             "Put": "_dict_lookup",
894                             "GetArgs": {
895                                 "lookup": self.force_guest,
896                                 "value_lookup": False,
897                             },
898                             "PutArgs": {
899                                 "lookup": self.force_guest,
900                                 "value_lookup": True,
901                             },
902                         },
903                     },
904                     "WfwDomainState": {
905                         "Policy": "Network firewall: Domain: State",
906                         "lgpo_section": self.windows_firewall_gpedit_path,
907                         "Settings": self.firewall_state.keys(),
908                         "NetSH": {
909                             "Profile": "domain",
910                             "Section": "state",
911                             "Option": "State",  # Unused, but needed
912                         },
913                         "Transform": {
914                             "Get": "_dict_lookup",
915                             "Put": "_dict_lookup",
916                             "GetArgs": {
917                                 "lookup": self.firewall_state,
918                                 "value_lookup": False,
919                             },
920                             "PutArgs": {
921                                 "lookup": self.firewall_state,
922                                 "value_lookup": True,
923                             },
924                         },
925                     },
926                     "WfwPrivateState": {
927                         "Policy": "Network firewall: Private: State",
928                         "lgpo_section": self.windows_firewall_gpedit_path,
929                         "Settings": self.firewall_state.keys(),
930                         "NetSH": {
931                             "Profile": "private",
932                             "Section": "state",
933                             "Option": "State",  # Unused, but needed
934                         },
935                         "Transform": {
936                             "Get": "_dict_lookup",
937                             "Put": "_dict_lookup",
938                             "GetArgs": {
939                                 "lookup": self.firewall_state,
940                                 "value_lookup": False,
941                             },
942                             "PutArgs": {
943                                 "lookup": self.firewall_state,
944                                 "value_lookup": True,
945                             },
946                         },
947                     },
948                     "WfwPublicState": {
949                         "Policy": "Network firewall: Public: State",
950                         "lgpo_section": self.windows_firewall_gpedit_path,
951                         "Settings": self.firewall_state.keys(),
952                         "NetSH": {
953                             "Profile": "public",
954                             "Section": "state",
955                             "Option": "State",  # Unused, but needed
956                         },
957                         "Transform": {
958                             "Get": "_dict_lookup",
959                             "Put": "_dict_lookup",
960                             "GetArgs": {
961                                 "lookup": self.firewall_state,
962                                 "value_lookup": False,
963                             },
964                             "PutArgs": {
965                                 "lookup": self.firewall_state,
966                                 "value_lookup": True,
967                             },
968                         },
969                     },
970                     "WfwDomainInboundConnections": {
971                         "Policy": "Network firewall: Domain: Inbound connections",
972                         "lgpo_section": self.windows_firewall_gpedit_path,
973                         "Settings": self.firewall_inbound_connections.keys(),
974                         "NetSH": {
975                             "Profile": "domain",
976                             "Section": "firewallpolicy",
977                             "Option": "Inbound",
978                         },
979                         "Transform": {
980                             "Get": "_dict_lookup",
981                             "Put": "_dict_lookup",
982                             "GetArgs": {
983                                 "lookup": self.firewall_inbound_connections,
984                                 "value_lookup": False,
985                             },
986                             "PutArgs": {
987                                 "lookup": self.firewall_inbound_connections,
988                                 "value_lookup": True,
989                             },
990                         },
991                     },
992                     "WfwPrivateInboundConnections": {
993                         "Policy": "Network firewall: Private: Inbound connections",
994                         "lgpo_section": self.windows_firewall_gpedit_path,
995                         "Settings": self.firewall_inbound_connections.keys(),
996                         "NetSH": {
997                             "Profile": "private",
998                             "Section": "firewallpolicy",
999                             "Option": "Inbound",
1000                         },
1001                         "Transform": {
1002                             "Get": "_dict_lookup",
1003                             "Put": "_dict_lookup",
1004                             "GetArgs": {
1005                                 "lookup": self.firewall_inbound_connections,
1006                                 "value_lookup": False,
1007                             },
1008                             "PutArgs": {
1009                                 "lookup": self.firewall_inbound_connections,
1010                                 "value_lookup": True,
1011                             },
1012                         },
1013                     },
1014                     "WfwPublicInboundConnections": {
1015                         "Policy": "Network firewall: Public: Inbound connections",
1016                         "lgpo_section": self.windows_firewall_gpedit_path,
1017                         "Settings": self.firewall_inbound_connections.keys(),
1018                         "NetSH": {
1019                             "Profile": "public",
1020                             "Section": "firewallpolicy",
1021                             "Option": "Inbound",
1022                         },
1023                         "Transform": {
1024                             "Get": "_dict_lookup",
1025                             "Put": "_dict_lookup",
1026                             "GetArgs": {
1027                                 "lookup": self.firewall_inbound_connections,
1028                                 "value_lookup": False,
1029                             },
1030                             "PutArgs": {
1031                                 "lookup": self.firewall_inbound_connections,
1032                                 "value_lookup": True,
1033                             },
1034                         },
1035                     },
1036                     "WfwDomainOutboundConnections": {
1037                         "Policy": "Network firewall: Domain: Outbound connections",
1038                         "lgpo_section": self.windows_firewall_gpedit_path,
1039                         "Settings": self.firewall_outbound_connections.keys(),
1040                         "NetSH": {
1041                             "Profile": "domain",
1042                             "Section": "firewallpolicy",
1043                             "Option": "Outbound",
1044                         },
1045                         "Transform": {
1046                             "Get": "_dict_lookup",
1047                             "Put": "_dict_lookup",
1048                             "GetArgs": {
1049                                 "lookup": self.firewall_outbound_connections,
1050                                 "value_lookup": False,
1051                             },
1052                             "PutArgs": {
1053                                 "lookup": self.firewall_outbound_connections,
1054                                 "value_lookup": True,
1055                             },
1056                         },
1057                     },
1058                     "WfwPrivateOutboundConnections": {
1059                         "Policy": "Network firewall: Private: Outbound connections",
1060                         "lgpo_section": self.windows_firewall_gpedit_path,
1061                         "Settings": self.firewall_outbound_connections.keys(),
1062                         "NetSH": {
1063                             "Profile": "private",
1064                             "Section": "firewallpolicy",
1065                             "Option": "Outbound",
1066                         },
1067                         "Transform": {
1068                             "Get": "_dict_lookup",
1069                             "Put": "_dict_lookup",
1070                             "GetArgs": {
1071                                 "lookup": self.firewall_outbound_connections,
1072                                 "value_lookup": False,
1073                             },
1074                             "PutArgs": {
1075                                 "lookup": self.firewall_outbound_connections,
1076                                 "value_lookup": True,
1077                             },
1078                         },
1079                     },
1080                     "WfwPublicOutboundConnections": {
1081                         "Policy": "Network firewall: Public: Outbound connections",
1082                         "lgpo_section": self.windows_firewall_gpedit_path,
1083                         "Settings": self.firewall_outbound_connections.keys(),
1084                         "NetSH": {
1085                             "Profile": "public",
1086                             "Section": "firewallpolicy",
1087                             "Option": "Outbound",
1088                         },
1089                         "Transform": {
1090                             "Get": "_dict_lookup",
1091                             "Put": "_dict_lookup",
1092                             "GetArgs": {
1093                                 "lookup": self.firewall_outbound_connections,
1094                                 "value_lookup": False,
1095                             },
1096                             "PutArgs": {
1097                                 "lookup": self.firewall_outbound_connections,
1098                                 "value_lookup": True,
1099                             },
1100                         },
1101                     },
1102                     "WfwDomainSettingsNotification": {
1103                         "Policy": (
1104                             "Network firewall: Domain: Settings: Display a notification"
1105                         ),
1106                         "lgpo_section": self.windows_firewall_gpedit_path,
1107                         "Settings": self.firewall_notification.keys(),
1108                         "NetSH": {
1109                             "Profile": "domain",
1110                             "Section": "settings",
1111                             "Option": "InboundUserNotification",
1112                         },
1113                         "Transform": {
1114                             "Get": "_dict_lookup",
1115                             "Put": "_dict_lookup",
1116                             "GetArgs": {
1117                                 "lookup": self.firewall_notification,
1118                                 "value_lookup": False,
1119                             },
1120                             "PutArgs": {
1121                                 "lookup": self.firewall_notification,
1122                                 "value_lookup": True,
1123                             },
1124                         },
1125                     },
1126                     "WfwPrivateSettingsNotification": {
1127                         "Policy": (
1128                             "Network firewall: Private: Settings: Display a"
1129                             " notification"
1130                         ),
1131                         "lgpo_section": self.windows_firewall_gpedit_path,
1132                         "Settings": self.firewall_notification.keys(),
1133                         "NetSH": {
1134                             "Profile": "private",
1135                             "Section": "settings",
1136                             "Option": "InboundUserNotification",
1137                         },
1138                         "Transform": {
1139                             "Get": "_dict_lookup",
1140                             "Put": "_dict_lookup",
1141                             "GetArgs": {
1142                                 "lookup": self.firewall_notification,
1143                                 "value_lookup": False,
1144                             },
1145                             "PutArgs": {
1146                                 "lookup": self.firewall_notification,
1147                                 "value_lookup": True,
1148                             },
1149                         },
1150                     },
1151                     "WfwPublicSettingsNotification": {
1152                         "Policy": (
1153                             "Network firewall: Public: Settings: Display a notification"
1154                         ),
1155                         "lgpo_section": self.windows_firewall_gpedit_path,
1156                         "Settings": self.firewall_notification.keys(),
1157                         "NetSH": {
1158                             "Profile": "public",
1159                             "Section": "settings",
1160                             "Option": "InboundUserNotification",
1161                         },
1162                         "Transform": {
1163                             "Get": "_dict_lookup",
1164                             "Put": "_dict_lookup",
1165                             "GetArgs": {
1166                                 "lookup": self.firewall_notification,
1167                                 "value_lookup": False,
1168                             },
1169                             "PutArgs": {
1170                                 "lookup": self.firewall_notification,
1171                                 "value_lookup": True,
1172                             },
1173                         },
1174                     },
1175                     "WfwDomainSettingsLocalFirewallRules": {
1176                         "Policy": (
1177                             "Network firewall: Domain: Settings: Apply "
1178                             "local firewall rules"
1179                         ),
1180                         "lgpo_section": self.windows_firewall_gpedit_path,
1181                         "Settings": self.firewall_rule_merging.keys(),
1182                         "NetSH": {
1183                             "Profile": "domain",
1184                             "Section": "settings",
1185                             "Option": "LocalFirewallRules",
1186                         },
1187                         "Transform": {
1188                             "Get": "_dict_lookup",
1189                             "Put": "_dict_lookup",
1190                             "GetArgs": {
1191                                 "lookup": self.firewall_rule_merging,
1192                                 "value_lookup": False,
1193                             },
1194                             "PutArgs": {
1195                                 "lookup": self.firewall_rule_merging,
1196                                 "value_lookup": True,
1197                             },
1198                         },
1199                     },
1200                     "WfwPrivateSettingsLocalFirewallRules": {
1201                         "Policy": (
1202                             "Network firewall: Private: Settings: Apply "
1203                             "local firewall rules"
1204                         ),
1205                         "lgpo_section": self.windows_firewall_gpedit_path,
1206                         "Settings": self.firewall_rule_merging.keys(),
1207                         "NetSH": {
1208                             "Profile": "private",
1209                             "Section": "settings",
1210                             "Option": "LocalFirewallRules",
1211                         },
1212                         "Transform": {
1213                             "Get": "_dict_lookup",
1214                             "Put": "_dict_lookup",
1215                             "GetArgs": {
1216                                 "lookup": self.firewall_rule_merging,
1217                                 "value_lookup": False,
1218                             },
1219                             "PutArgs": {
1220                                 "lookup": self.firewall_rule_merging,
1221                                 "value_lookup": True,
1222                             },
1223                         },
1224                     },
1225                     "WfwPublicSettingsLocalFirewallRules": {
1226                         "Policy": (
1227                             "Network firewall: Public: Settings: Apply "
1228                             "local firewall rules"
1229                         ),
1230                         "lgpo_section": self.windows_firewall_gpedit_path,
1231                         "Settings": self.firewall_rule_merging.keys(),
1232                         "NetSH": {
1233                             "Profile": "public",
1234                             "Section": "settings",
1235                             "Option": "LocalFirewallRules",
1236                         },
1237                         "Transform": {
1238                             "Get": "_dict_lookup",
1239                             "Put": "_dict_lookup",
1240                             "GetArgs": {
1241                                 "lookup": self.firewall_rule_merging,
1242                                 "value_lookup": False,
1243                             },
1244                             "PutArgs": {
1245                                 "lookup": self.firewall_rule_merging,
1246                                 "value_lookup": True,
1247                             },
1248                         },
1249                     },
1250                     "WfwDomainSettingsLocalConnectionRules": {
1251                         "Policy": (
1252                             "Network firewall: Domain: Settings: Apply "
1253                             "local connection security rules"
1254                         ),
1255                         "lgpo_section": self.windows_firewall_gpedit_path,
1256                         "Settings": self.firewall_rule_merging.keys(),
1257                         "NetSH": {
1258                             "Profile": "domain",
1259                             "Section": "settings",
1260                             "Option": "LocalConSecRules",
1261                         },
1262                         "Transform": {
1263                             "Get": "_dict_lookup",
1264                             "Put": "_dict_lookup",
1265                             "GetArgs": {
1266                                 "lookup": self.firewall_rule_merging,
1267                                 "value_lookup": False,
1268                             },
1269                             "PutArgs": {
1270                                 "lookup": self.firewall_rule_merging,
1271                                 "value_lookup": True,
1272                             },
1273                         },
1274                     },
1275                     "WfwPrivateSettingsLocalConnectionRules": {
1276                         "Policy": (
1277                             "Network firewall: Private: Settings: Apply "
1278                             "local connection security rules"
1279                         ),
1280                         "lgpo_section": self.windows_firewall_gpedit_path,
1281                         "Settings": self.firewall_rule_merging.keys(),
1282                         "NetSH": {
1283                             "Profile": "private",
1284                             "Section": "settings",
1285                             "Option": "LocalConSecRules",
1286                         },
1287                         "Transform": {
1288                             "Get": "_dict_lookup",
1289                             "Put": "_dict_lookup",
1290                             "GetArgs": {
1291                                 "lookup": self.firewall_rule_merging,
1292                                 "value_lookup": False,
1293                             },
1294                             "PutArgs": {
1295                                 "lookup": self.firewall_rule_merging,
1296                                 "value_lookup": True,
1297                             },
1298                         },
1299                     },
1300                     "WfwPublicSettingsLocalConnectionRules": {
1301                         "Policy": (
1302                             "Network firewall: Public: Settings: Apply "
1303                             "local connection security rules"
1304                         ),
1305                         "lgpo_section": self.windows_firewall_gpedit_path,
1306                         "Settings": self.firewall_rule_merging.keys(),
1307                         "NetSH": {
1308                             "Profile": "public",
1309                             "Section": "settings",
1310                             "Option": "LocalConSecRules",
1311                         },
1312                         "Transform": {
1313                             "Get": "_dict_lookup",
1314                             "Put": "_dict_lookup",
1315                             "GetArgs": {
1316                                 "lookup": self.firewall_rule_merging,
1317                                 "value_lookup": False,
1318                             },
1319                             "PutArgs": {
1320                                 "lookup": self.firewall_rule_merging,
1321                                 "value_lookup": True,
1322                             },
1323                         },
1324                     },
1325                     "WfwDomainLoggingName": {
1326                         "Policy": "Network firewall: Domain: Logging: Name",
1327                         "lgpo_section": self.windows_firewall_gpedit_path,
1328                         "Settings": None,
1329                         "NetSH": {
1330                             "Profile": "domain",
1331                             "Section": "logging",
1332                             "Option": "FileName",
1333                         },
1334                     },
1335                     "WfwPrivateLoggingName": {
1336                         "Policy": "Network firewall: Private: Logging: Name",
1337                         "lgpo_section": self.windows_firewall_gpedit_path,
1338                         "Settings": None,
1339                         "NetSH": {
1340                             "Profile": "private",
1341                             "Section": "logging",
1342                             "Option": "FileName",
1343                         },
1344                     },
1345                     "WfwPublicLoggingName": {
1346                         "Policy": "Network firewall: Public: Logging: Name",
1347                         "lgpo_section": self.windows_firewall_gpedit_path,
1348                         "Settings": None,
1349                         "NetSH": {
1350                             "Profile": "public",
1351                             "Section": "logging",
1352                             "Option": "FileName",
1353                         },
1354                     },
1355                     "WfwDomainLoggingMaxFileSize": {
1356                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1357                         "lgpo_section": self.windows_firewall_gpedit_path,
1358                         "Settings": None,
1359                         "NetSH": {
1360                             "Profile": "domain",
1361                             "Section": "logging",
1362                             "Option": "MaxFileSize",
1363                         },
1364                     },
1365                     "WfwPrivateLoggingMaxFileSize": {
1366                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1367                         "lgpo_section": self.windows_firewall_gpedit_path,
1368                         "Settings": None,
1369                         "NetSH": {
1370                             "Profile": "private",
1371                             "Section": "logging",
1372                             "Option": "MaxFileSize",
1373                         },
1374                     },
1375                     "WfwPublicLoggingMaxFileSize": {
1376                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1377                         "lgpo_section": self.windows_firewall_gpedit_path,
1378                         "Settings": None,
1379                         "NetSH": {
1380                             "Profile": "public",
1381                             "Section": "logging",
1382                             "Option": "MaxFileSize",
1383                         },
1384                     },
1385                     "WfwDomainLoggingAllowedConnections": {
1386                         "Policy": (
1387                             "Network firewall: Domain: Logging: Log successful"
1388                             " connections"
1389                         ),
1390                         "lgpo_section": self.windows_firewall_gpedit_path,
1391                         "Settings": self.firewall_log_packets_connections.keys(),
1392                         "NetSH": {
1393                             "Profile": "domain",
1394                             "Section": "logging",
1395                             "Option": "LogAllowedConnections",
1396                         },
1397                         "Transform": {
1398                             "Get": "_dict_lookup",
1399                             "Put": "_dict_lookup",
1400                             "GetArgs": {
1401                                 "lookup": self.firewall_log_packets_connections,
1402                                 "value_lookup": False,
1403                             },
1404                             "PutArgs": {
1405                                 "lookup": self.firewall_log_packets_connections,
1406                                 "value_lookup": True,
1407                             },
1408                         },
1409                     },
1410                     "WfwPrivateLoggingAllowedConnections": {
1411                         "Policy": (
1412                             "Network firewall: Private: Logging: Log successful"
1413                             " connections"
1414                         ),
1415                         "lgpo_section": self.windows_firewall_gpedit_path,
1416                         "Settings": self.firewall_log_packets_connections.keys(),
1417                         "NetSH": {
1418                             "Profile": "private",
1419                             "Section": "logging",
1420                             "Option": "LogAllowedConnections",
1421                         },
1422                         "Transform": {
1423                             "Get": "_dict_lookup",
1424                             "Put": "_dict_lookup",
1425                             "GetArgs": {
1426                                 "lookup": self.firewall_log_packets_connections,
1427                                 "value_lookup": False,
1428                             },
1429                             "PutArgs": {
1430                                 "lookup": self.firewall_log_packets_connections,
1431                                 "value_lookup": True,
1432                             },
1433                         },
1434                     },
1435                     "WfwPublicLoggingAllowedConnections": {
1436                         "Policy": (
1437                             "Network firewall: Public: Logging: Log successful"
1438                             " connections"
1439                         ),
1440                         "lgpo_section": self.windows_firewall_gpedit_path,
1441                         "Settings": self.firewall_log_packets_connections.keys(),
1442                         "NetSH": {
1443                             "Profile": "public",
1444                             "Section": "logging",
1445                             "Option": "LogAllowedConnections",
1446                         },
1447                         "Transform": {
1448                             "Get": "_dict_lookup",
1449                             "Put": "_dict_lookup",
1450                             "GetArgs": {
1451                                 "lookup": self.firewall_log_packets_connections,
1452                                 "value_lookup": False,
1453                             },
1454                             "PutArgs": {
1455                                 "lookup": self.firewall_log_packets_connections,
1456                                 "value_lookup": True,
1457                             },
1458                         },
1459                     },
1460                     "WfwDomainLoggingDroppedConnections": {
1461                         "Policy": (
1462                             "Network firewall: Domain: Logging: Log dropped packets"
1463                         ),
1464                         "lgpo_section": self.windows_firewall_gpedit_path,
1465                         "Settings": self.firewall_log_packets_connections.keys(),
1466                         "NetSH": {
1467                             "Profile": "domain",
1468                             "Section": "logging",
1469                             "Option": "LogDroppedConnections",
1470                         },
1471                         "Transform": {
1472                             "Get": "_dict_lookup",
1473                             "Put": "_dict_lookup",
1474                             "GetArgs": {
1475                                 "lookup": self.firewall_log_packets_connections,
1476                                 "value_lookup": False,
1477                             },
1478                             "PutArgs": {
1479                                 "lookup": self.firewall_log_packets_connections,
1480                                 "value_lookup": True,
1481                             },
1482                         },
1483                     },
1484                     "WfwPrivateLoggingDroppedConnections": {
1485                         "Policy": (
1486                             "Network firewall: Private: Logging: Log dropped packets"
1487                         ),
1488                         "lgpo_section": self.windows_firewall_gpedit_path,
1489                         "Settings": self.firewall_log_packets_connections.keys(),
1490                         "NetSH": {
1491                             "Profile": "private",
1492                             "Section": "logging",
1493                             "Option": "LogDroppedConnections",
1494                         },
1495                         "Transform": {
1496                             "Get": "_dict_lookup",
1497                             "Put": "_dict_lookup",
1498                             "GetArgs": {
1499                                 "lookup": self.firewall_log_packets_connections,
1500                                 "value_lookup": False,
1501                             },
1502                             "PutArgs": {
1503                                 "lookup": self.firewall_log_packets_connections,
1504                                 "value_lookup": True,
1505                             },
1506                         },
1507                     },
1508                     "WfwPublicLoggingDroppedConnections": {
1509                         "Policy": (
1510                             "Network firewall: Public: Logging: Log dropped packets"
1511                         ),
1512                         "lgpo_section": self.windows_firewall_gpedit_path,
1513                         "Settings": self.firewall_log_packets_connections.keys(),
1514                         "NetSH": {
1515                             "Profile": "public",
1516                             "Section": "logging",
1517                             "Option": "LogDroppedConnections",
1518                         },
1519                         "Transform": {
1520                             "Get": "_dict_lookup",
1521                             "Put": "_dict_lookup",
1522                             "GetArgs": {
1523                                 "lookup": self.firewall_log_packets_connections,
1524                                 "value_lookup": False,
1525                             },
1526                             "PutArgs": {
1527                                 "lookup": self.firewall_log_packets_connections,
1528                                 "value_lookup": True,
1529                             },
1530                         },
1531                     },
1532                     "PasswordHistory": {
1533                         "Policy": "Enforce password history",
1534                         "lgpo_section": self.password_policy_gpedit_path,
1535                         "Settings": {
1536                             "Function": "_in_range_inclusive",
1537                             "Args": {"min": 0, "max": 24},
1538                         },
1539                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1540                     },
1541                     "MaxPasswordAge": {
1542                         "Policy": "Maximum password age",
1543                         "lgpo_section": self.password_policy_gpedit_path,
1544                         "Settings": {
1545                             "Function": "_in_range_inclusive",
1546                             "Args": {
1547                                 "min": 1,
1548                                 "max": 86313600,
1549                                 "zero_value": 0xFFFFFFFF,
1550                             },
1551                         },
1552                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1553                         "Transform": {
1554                             "Get": "_seconds_to_days",
1555                             "Put": "_days_to_seconds",
1556                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1557                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1558                         },
1559                     },
1560                     "MinPasswordAge": {
1561                         "Policy": "Minimum password age",
1562                         "lgpo_section": self.password_policy_gpedit_path,
1563                         "Settings": {
1564                             "Function": "_in_range_inclusive",
1565                             "Args": {"min": 0, "max": 86313600},
1566                         },
1567                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1568                         "Transform": {
1569                             "Get": "_seconds_to_days",
1570                             "Put": "_days_to_seconds",
1571                         },
1572                     },
1573                     "MinPasswordLen": {
1574                         "Policy": "Minimum password length",
1575                         "lgpo_section": self.password_policy_gpedit_path,
1576                         "Settings": {
1577                             "Function": "_in_range_inclusive",
1578                             "Args": {"min": 0, "max": 14},
1579                         },
1580                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1581                     },
1582                     "PasswordComplexity": {
1583                         "Policy": "Password must meet complexity requirements",
1584                         "lgpo_section": self.password_policy_gpedit_path,
1585                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1586                         "Secedit": {
1587                             "Option": "PasswordComplexity",
1588                             "Section": "System Access",
1589                         },
1590                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1591                     },
1592                     "ClearTextPasswords": {
1593                         "Policy": "Store passwords using reversible encryption",
1594                         "lgpo_section": self.password_policy_gpedit_path,
1595                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1596                         "Secedit": {
1597                             "Option": "ClearTextPassword",
1598                             "Section": "System Access",
1599                         },
1600                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1601                     },
1602                     "AdminAccountStatus": {
1603                         "Policy": "Accounts: Administrator account status",
1604                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1605                         "lgpo_section": self.security_options_gpedit_path,
1606                         "Secedit": {
1607                             "Option": "EnableAdminAccount",
1608                             "Section": "System Access",
1609                         },
1610                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1611                     },
1612                     "NoConnectedUser": {
1613                         "Policy": "Accounts: Block Microsoft accounts",
1614                         "Settings": self.block_ms_accounts.keys(),
1615                         "lgpo_section": self.security_options_gpedit_path,
1616                         "Registry": {
1617                             "Hive": "HKEY_LOCAL_MACHINE",
1618                             "Path": (
1619                                 "SOFTWARE\\Microsoft\\Windows\\"
1620                                 "CurrentVersion\\policies\\system"
1621                             ),
1622                             "Value": "NoConnectedUser",
1623                             "Type": "REG_DWORD",
1624                         },
1625                         "Transform": {
1626                             "Get": "_dict_lookup",
1627                             "Put": "_dict_lookup",
1628                             "GetArgs": {
1629                                 "lookup": self.block_ms_accounts,
1630                                 "value_lookup": False,
1631                             },
1632                             "PutArgs": {
1633                                 "lookup": self.block_ms_accounts,
1634                                 "value_lookup": True,
1635                             },
1636                         },
1637                     },
1638                     "GuestAccountStatus": {
1639                         "Policy": "Accounts: Guest account status",
1640                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1641                         "lgpo_section": self.security_options_gpedit_path,
1642                         "Secedit": {
1643                             "Option": "EnableGuestAccount",
1644                             "Section": "System Access",
1645                         },
1646                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1647                     },
1648                     "LimitBlankPasswordUse": {
1649                         "Policy": (
1650                             "Accounts: Limit local account use of blank "
1651                             "passwords to console logon only"
1652                         ),
1653                         "lgpo_section": self.security_options_gpedit_path,
1654                         "Settings": self.enabled_one_disabled_zero.keys(),
1655                         "Registry": {
1656                             "Hive": "HKEY_LOCAL_MACHINE",
1657                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1658                             "Value": "limitblankpassworduse",
1659                             "Type": "REG_DWORD",
1660                         },
1661                         "Transform": self.enabled_one_disabled_zero_transform,
1662                     },
1663                     "RenameAdministratorAccount": {
1664                         "Policy": "Accounts: Rename administrator account",
1665                         "Settings": None,
1666                         "lgpo_section": self.security_options_gpedit_path,
1667                         "Secedit": {
1668                             "Option": "NewAdministratorName",
1669                             "Section": "System Access",
1670                         },
1671                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1672                     },
1673                     "RenameGuestAccount": {
1674                         "Policy": "Accounts: Rename guest account",
1675                         "Settings": None,
1676                         "lgpo_section": self.security_options_gpedit_path,
1677                         "Secedit": {
1678                             "Option": "NewGuestName",
1679                             "Section": "System Access",
1680                         },
1681                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1682                     },
1683                     "AuditBaseObjects": {
1684                         "Policy": "Audit: Audit the access of global system objects",
1685                         "Settings": self.enabled_one_disabled_zero.keys(),
1686                         "lgpo_section": self.security_options_gpedit_path,
1687                         "Registry": {
1688                             "Hive": "HKEY_LOCAL_MACHINE",
1689                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1690                             "Value": "AuditBaseObjects",
1691                             "Type": "REG_DWORD",
1692                         },
1693                         "Transform": self.enabled_one_disabled_zero_transform,
1694                     },
1695                     "SceNoApplyLegacyAuditPolicy": {
1696                         "Policy": (
1697                             "Audit: Force audit policy subcategory "
1698                             "settings (Windows Vista or later) to "
1699                             "override audit policy category settings"
1700                         ),
1701                         "Settings": self.enabled_one_disabled_zero.keys(),
1702                         "lgpo_section": self.security_options_gpedit_path,
1703                         "Registry": {
1704                             "Hive": "HKEY_LOCAL_MACHINE",
1705                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1706                             "Value": "SCENoApplyLegacyAuditPolicy",
1707                             "Type": "REG_DWORD",
1708                         },
1709                         "Transform": self.enabled_one_disabled_zero_transform,
1710                     },
1711                     "DontDisplayLastUserName": {
1712                         "Policy": "Interactive logon: Do not display last user name",
1713                         "Settings": self.enabled_one_disabled_zero.keys(),
1714                         "lgpo_section": self.security_options_gpedit_path,
1715                         "Registry": {
1716                             "Hive": "HKEY_LOCAL_MACHINE",
1717                             "Path": (
1718                                 "Software\\Microsoft\\Windows\\"
1719                                 "CurrentVersion\\Policies\\System"
1720                             ),
1721                             "Value": "DontDisplayLastUserName",
1722                             "Type": "REG_DWORD",
1723                         },
1724                         "Transform": self.enabled_one_disabled_zero_transform,
1725                     },
1726                     "CachedLogonsCount": {
1727                         "Policy": (
1728                             "Interactive logon: Number of previous "
1729                             "logons to cache (in case domain controller "
1730                             "is not available)"
1731                         ),
1732                         "Settings": {
1733                             "Function": "_in_range_inclusive",
1734                             "Args": {"min": 0, "max": 50},
1735                         },
1736                         "lgpo_section": self.security_options_gpedit_path,
1737                         "Registry": {
1738                             "Hive": "HKEY_LOCAL_MACHINE",
1739                             "Path": (
1740                                 "Software\\Microsoft\\Windows NT\\"
1741                                 "CurrentVersion\\Winlogon"
1742                             ),
1743                             "Value": "CachedLogonsCount",
1744                             "Type": "REG_SZ",
1745                         },
1746                     },
1747                     "ForceUnlockLogon": {
1748                         "Policy": (
1749                             "Interactive logon: Require Domain "
1750                             "Controller authentication to unlock "
1751                             "workstation"
1752                         ),
1753                         "Settings": self.enabled_one_disabled_zero.keys(),
1754                         "lgpo_section": self.security_options_gpedit_path,
1755                         "Registry": {
1756                             "Hive": "HKEY_LOCAL_MACHINE",
1757                             "Path": (
1758                                 "Software\\Microsoft\\Windows NT\\"
1759                                 "CurrentVersion\\Winlogon"
1760                             ),
1761                             "Value": "ForceUnlockLogon",
1762                             "Type": "REG_DWORD",
1763                         },
1764                         "Transform": self.enabled_one_disabled_zero_transform,
1765                     },
1766                     "ScRemoveOption": {
1767                         "Policy": "Interactive logon: Smart card removal behavior",
1768                         "Settings": self.sc_removal_lookup.keys(),
1769                         "lgpo_section": self.security_options_gpedit_path,
1770                         "Registry": {
1771                             "Hive": "HKEY_LOCAL_MACHINE",
1772                             "Path": (
1773                                 "Software\\Microsoft\\Windows NT\\"
1774                                 "CurrentVersion\\Winlogon"
1775                             ),
1776                             "Value": "ScRemoveOption",
1777                             "Type": "REG_SZ",
1778                         },
1779                         "Transform": {
1780                             "Get": "_dict_lookup",
1781                             "Put": "_dict_lookup",
1782                             "GetArgs": {
1783                                 "lookup": self.sc_removal_lookup,
1784                                 "value_lookup": False,
1785                             },
1786                             "PutArgs": {
1787                                 "lookup": self.sc_removal_lookup,
1788                                 "value_lookup": True,
1789                             },
1790                         },
1791                     },
1792                     "DisableCAD": {
1793                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1794                         "Settings": self.enabled_one_disabled_zero.keys(),
1795                         "lgpo_section": self.security_options_gpedit_path,
1796                         "Registry": {
1797                             "Hive": "HKEY_LOCAL_MACHINE",
1798                             "Path": (
1799                                 "Software\\Microsoft\\Windows\\"
1800                                 "CurrentVersion\\Policies\\System"
1801                             ),
1802                             "Value": "DisableCAD",
1803                             "Type": "REG_DWORD",
1804                         },
1805                         "Transform": self.enabled_one_disabled_zero_transform,
1806                     },
1807                     "FilterAdministratorToken": {
1808                         "Policy": (
1809                             "User Account Control: Admin Approval Mode "
1810                             "for the built-in Administrator account"
1811                         ),
1812                         "Settings": self.enabled_one_disabled_zero.keys(),
1813                         "lgpo_section": self.security_options_gpedit_path,
1814                         "Registry": {
1815                             "Hive": "HKEY_LOCAL_MACHINE",
1816                             "Path": (
1817                                 "Software\\Microsoft\\Windows\\"
1818                                 "CurrentVersion\\Policies\\System"
1819                             ),
1820                             "Value": "FilterAdministratorToken",
1821                             "Type": "REG_DWORD",
1822                         },
1823                         "Transform": self.enabled_one_disabled_zero_transform,
1824                     },
1825                     "EnableUIADesktopToggle": {
1826                         "Policy": (
1827                             "User Account Control: Allow UIAccess "
1828                             "applications to prompt for elevation "
1829                             "without using the secure desktop"
1830                         ),
1831                         "Settings": self.enabled_one_disabled_zero.keys(),
1832                         "lgpo_section": self.security_options_gpedit_path,
1833                         "Registry": {
1834                             "Hive": "HKEY_LOCAL_MACHINE",
1835                             "Path": (
1836                                 "Software\\Microsoft\\Windows\\"
1837                                 "CurrentVersion\\Policies\\System"
1838                             ),
1839                             "Value": "EnableUIADesktopToggle",
1840                             "Type": "REG_DWORD",
1841                         },
1842                         "Transform": self.enabled_one_disabled_zero_transform,
1843                     },
1844                     "ConsentPromptBehaviorAdmin": {
1845                         "Policy": (
1846                             "User Account Control: Behavior of the "
1847                             "elevation prompt for administrators in "
1848                             "Admin Approval Mode"
1849                         ),
1850                         "Settings": self.uac_admin_prompt_lookup.keys(),
1851                         "lgpo_section": self.security_options_gpedit_path,
1852                         "Registry": {
1853                             "Hive": "HKEY_LOCAL_MACHINE",
1854                             "Path": (
1855                                 "Software\\Microsoft\\Windows\\"
1856                                 "CurrentVersion\\Policies\\System"
1857                             ),
1858                             "Value": "ConsentPromptBehaviorAdmin",
1859                             "Type": "REG_DWORD",
1860                         },
1861                         "Transform": {
1862                             "Get": "_dict_lookup",
1863                             "Put": "_dict_lookup",
1864                             "GetArgs": {
1865                                 "lookup": self.uac_admin_prompt_lookup,
1866                                 "value_lookup": False,
1867                             },
1868                             "PutArgs": {
1869                                 "lookup": self.uac_admin_prompt_lookup,
1870                                 "value_lookup": True,
1871                             },
1872                         },
1873                     },
1874                     "ConsentPromptBehaviorUser": {
1875                         "Policy": (
1876                             "User Account Control: Behavior of the "
1877                             "elevation prompt for standard users"
1878                         ),
1879                         "Settings": self.uac_user_prompt_lookup.keys(),
1880                         "lgpo_section": self.security_options_gpedit_path,
1881                         "Registry": {
1882                             "Hive": "HKEY_LOCAL_MACHINE",
1883                             "Path": (
1884                                 "Software\\Microsoft\\Windows\\"
1885                                 "CurrentVersion\\Policies\\System"
1886                             ),
1887                             "Value": "ConsentPromptBehaviorUser",
1888                             "Type": "REG_DWORD",
1889                         },
1890                         "Transform": {
1891                             "Get": "_dict_lookup",
1892                             "Put": "_dict_lookup",
1893                             "GetArgs": {
1894                                 "lookup": self.uac_user_prompt_lookup,
1895                                 "value_lookup": False,
1896                             },
1897                             "PutArgs": {
1898                                 "lookup": self.uac_user_prompt_lookup,
1899                                 "value_lookup": True,
1900                             },
1901                         },
1902                     },
1903                     "EnableInstallerDetection": {
1904                         "Policy": (
1905                             "User Account Control: Detect application "
1906                             "installations and prompt for elevation"
1907                         ),
1908                         "Settings": self.enabled_one_disabled_zero.keys(),
1909                         "lgpo_section": self.security_options_gpedit_path,
1910                         "Registry": {
1911                             "Hive": "HKEY_LOCAL_MACHINE",
1912                             "Path": (
1913                                 "Software\\Microsoft\\Windows\\"
1914                                 "CurrentVersion\\Policies\\System"
1915                             ),
1916                             "Value": "EnableInstallerDetection",
1917                             "Type": "REG_DWORD",
1918                         },
1919                         "Transform": self.enabled_one_disabled_zero_transform,
1920                     },
1921                     "ValidateAdminCodeSignatures": {
1922                         "Policy": (
1923                             "User Account Control: Only elevate "
1924                             "executables that are signed and validated"
1925                         ),
1926                         "Settings": self.enabled_one_disabled_zero.keys(),
1927                         "lgpo_section": self.security_options_gpedit_path,
1928                         "Registry": {
1929                             "Hive": "HKEY_LOCAL_MACHINE",
1930                             "Path": (
1931                                 "Software\\Microsoft\\Windows\\"
1932                                 "CurrentVersion\\Policies\\System"
1933                             ),
1934                             "Value": "ValidateAdminCodeSignatures",
1935                             "Type": "REG_DWORD",
1936                         },
1937                         "Transform": self.enabled_one_disabled_zero_transform,
1938                     },
1939                     "EnableSecureUIAPaths": {
1940                         "Policy": (
1941                             "User Account Control: Only elevate UIAccess "
1942                             "applications that are installed in secure "
1943                             "locations"
1944                         ),
1945                         "Settings": self.enabled_one_disabled_zero.keys(),
1946                         "lgpo_section": self.security_options_gpedit_path,
1947                         "Registry": {
1948                             "Hive": "HKEY_LOCAL_MACHINE",
1949                             "Path": (
1950                                 "Software\\Microsoft\\Windows\\"
1951                                 "CurrentVersion\\Policies\\System"
1952                             ),
1953                             "Value": "EnableSecureUIAPaths",
1954                             "Type": "REG_DWORD",
1955                         },
1956                         "Transform": self.enabled_one_disabled_zero_transform,
1957                     },
1958                     "EnableLUA": {
1959                         "Policy": (
1960                             "User Account Control: Run all "
1961                             "administrators in Admin Approval Mode"
1962                         ),
1963                         "Settings": self.enabled_one_disabled_zero.keys(),
1964                         "lgpo_section": self.security_options_gpedit_path,
1965                         "Registry": {
1966                             "Hive": "HKEY_LOCAL_MACHINE",
1967                             "Path": (
1968                                 "Software\\Microsoft\\Windows\\"
1969                                 "CurrentVersion\\Policies\\System"
1970                             ),
1971                             "Value": "EnableLUA",
1972                             "Type": "REG_DWORD",
1973                         },
1974                         "Transform": self.enabled_one_disabled_zero_transform,
1975                     },
1976                     "PromptOnSecureDesktop": {
1977                         "Policy": (
1978                             "User Account Control: Switch to the secure "
1979                             "desktop when prompting for elevation"
1980                         ),
1981                         "Settings": self.enabled_one_disabled_zero.keys(),
1982                         "lgpo_section": self.security_options_gpedit_path,
1983                         "Registry": {
1984                             "Hive": "HKEY_LOCAL_MACHINE",
1985                             "Path": (
1986                                 "Software\\Microsoft\\Windows\\"
1987                                 "CurrentVersion\\Policies\\System"
1988                             ),
1989                             "Value": "PromptOnSecureDesktop",
1990                             "Type": "REG_DWORD",
1991                         },
1992                         "Transform": self.enabled_one_disabled_zero_transform,
1993                     },
1994                     "EnableVirtualization": {
1995                         "Policy": (
1996                             "User Account Control: Virtualize file and "
1997                             "registry write failures to per-user "
1998                             "locations"
1999                         ),
2000                         "Settings": self.enabled_one_disabled_zero.keys(),
2001                         "lgpo_section": self.security_options_gpedit_path,
2002                         "Registry": {
2003                             "Hive": "HKEY_LOCAL_MACHINE",
2004                             "Path": (
2005                                 "Software\\Microsoft\\Windows\\"
2006                                 "CurrentVersion\\Policies\\System"
2007                             ),
2008                             "Value": "EnableVirtualization",
2009                             "Type": "REG_DWORD",
2010                         },
2011                         "Transform": self.enabled_one_disabled_zero_transform,
2012                     },
2013                     "PasswordExpiryWarning": {
2014                         "Policy": (
2015                             "Interactive logon: Prompt user to change "
2016                             "password before expiration"
2017                         ),
2018                         "Settings": {
2019                             "Function": "_in_range_inclusive",
2020                             "Args": {"min": 0, "max": 999},
2021                         },
2022                         "lgpo_section": self.security_options_gpedit_path,
2023                         "Registry": {
2024                             "Hive": "HKEY_LOCAL_MACHINE",
2025                             "Path": (
2026                                 "Software\\Microsoft\\Windows NT\\"
2027                                 "CurrentVersion\\Winlogon"
2028                             ),
2029                             "Value": "PasswordExpiryWarning",
2030                             "Type": "REG_DWORD",
2031                         },
2032                     },
2033                     "MaxDevicePasswordFailedAttempts": {
2034                         "Policy": (
2035                             "Interactive logon: Machine account lockout threshold"
2036                         ),
2037                         "Settings": {
2038                             "Function": "_in_range_inclusive",
2039                             "Args": {"min": 0, "max": 999},
2040                         },
2041                         "lgpo_section": self.security_options_gpedit_path,
2042                         "Registry": {
2043                             "Hive": "HKEY_LOCAL_MACHINE",
2044                             "Path": (
2045                                 "SOFTWARE\\Microsoft\\Windows\\"
2046                                 "CurrentVersion\\policies\\system"
2047                             ),
2048                             "Value": "MaxDevicePasswordFailedAttempts",
2049                             "Type": "REG_DWORD",
2050                         },
2051                     },
2052                     "InactivityTimeoutSecs": {
2053                         "Policy": "Interactive logon: Machine inactivity limit",
2054                         "Settings": {
2055                             "Function": "_in_range_inclusive",
2056                             "Args": {"min": 0, "max": 599940},
2057                         },
2058                         "lgpo_section": self.security_options_gpedit_path,
2059                         "Registry": {
2060                             "Hive": "HKEY_LOCAL_MACHINE",
2061                             "Path": (
2062                                 "SOFTWARE\\Microsoft\\Windows\\"
2063                                 "CurrentVersion\\policies\\system"
2064                             ),
2065                             "Value": "InactivityTimeoutSecs",
2066                             "Type": "REG_DWORD",
2067                         },
2068                     },
2069                     "legalnoticetext": {
2070                         "Policy": (
2071                             "Interactive logon: Message text for users "
2072                             "attempting to log on"
2073                         ),
2074                         "lgpo_section": self.security_options_gpedit_path,
2075                         "Registry": {
2076                             "Hive": "HKEY_LOCAL_MACHINE",
2077                             "Path": (
2078                                 "SOFTWARE\\Microsoft\\Windows\\"
2079                                 "CurrentVersion\\policies\\system"
2080                             ),
2081                             "Value": "legalnoticetext",
2082                             "Type": "REG_SZ",
2083                         },
2084                         "Transform": {"Put": "_string_put_transform"},
2085                     },
2086                     "legalnoticecaption": {
2087                         "Policy": (
2088                             "Interactive logon: Message title for users "
2089                             "attempting to log on"
2090                         ),
2091                         "lgpo_section": self.security_options_gpedit_path,
2092                         "Registry": {
2093                             "Hive": "HKEY_LOCAL_MACHINE",
2094                             "Path": (
2095                                 "SOFTWARE\\Microsoft\\Windows\\"
2096                                 "CurrentVersion\\policies\\system"
2097                             ),
2098                             "Value": "legalnoticecaption",
2099                             "Type": "REG_SZ",
2100                         },
2101                         "Transform": {"Put": "_string_put_transform"},
2102                     },
2103                     "DontDisplayLockedUserId": {
2104                         "Policy": (
2105                             "Interactive logon: Display user information "
2106                             "when the session is locked"
2107                         ),
2108                         "Settings": self.locked_session_user_info.keys(),
2109                         "lgpo_section": self.security_options_gpedit_path,
2110                         "Registry": {
2111                             "Hive": "HKEY_LOCAL_MACHINE",
2112                             "Path": (
2113                                 "SOFTWARE\\Microsoft\\Windows\\"
2114                                 "CurrentVersion\\policies\\system"
2115                             ),
2116                             "Value": "DontDisplayLockedUserId",
2117                             "Type": "REG_DWORD",
2118                         },
2119                         "Transform": {
2120                             "Get": "_dict_lookup",
2121                             "Put": "_dict_lookup",
2122                             "GetArgs": {
2123                                 "lookup": self.locked_session_user_info,
2124                                 "value_lookup": False,
2125                             },
2126                             "PutArgs": {
2127                                 "lookup": self.locked_session_user_info,
2128                                 "value_lookup": True,
2129                             },
2130                         },
2131                     },
2132                     "ScForceOption": {
2133                         "Policy": "Interactive logon: Require smart card",
2134                         "Settings": self.enabled_one_disabled_zero.keys(),
2135                         "lgpo_section": self.security_options_gpedit_path,
2136                         "Registry": {
2137                             "Hive": "HKEY_LOCAL_MACHINE",
2138                             "Path": (
2139                                 "Software\\Microsoft\\Windows\\"
2140                                 "CurrentVersion\\Policies\\System"
2141                             ),
2142                             "Value": "ScForceOption",
2143                             "Type": "REG_DWORD",
2144                         },
2145                         "Transform": self.enabled_one_disabled_zero_transform,
2146                     },
2147                     "Client_RequireSecuritySignature": {
2148                         "Policy": (
2149                             "Microsoft network client: Digitally sign "
2150                             "communications (always)"
2151                         ),
2152                         "Settings": self.enabled_one_disabled_zero.keys(),
2153                         "lgpo_section": self.security_options_gpedit_path,
2154                         "Registry": {
2155                             "Hive": "HKEY_LOCAL_MACHINE",
2156                             "Path": (
2157                                 "SYSTEM\\CurrentControlSet\\Services\\"
2158                                 "LanmanWorkstation\\Parameters"
2159                             ),
2160                             "Value": "RequireSecuritySignature",
2161                             "Type": "REG_DWORD",
2162                         },
2163                         "Transform": self.enabled_one_disabled_zero_transform,
2164                     },
2165                     "Client_EnableSecuritySignature": {
2166                         "Policy": (
2167                             "Microsoft network client: Digitally sign "
2168                             "communications (if server agrees)"
2169                         ),
2170                         "Settings": self.enabled_one_disabled_zero.keys(),
2171                         "lgpo_section": self.security_options_gpedit_path,
2172                         "Registry": {
2173                             "Hive": "HKEY_LOCAL_MACHINE",
2174                             "Path": (
2175                                 "SYSTEM\\CurrentControlSet\\Services\\"
2176                                 "LanmanWorkstation\\Parameters"
2177                             ),
2178                             "Value": "EnableSecuritySignature",
2179                             "Type": "REG_DWORD",
2180                         },
2181                         "Transform": self.enabled_one_disabled_zero_transform,
2182                     },
2183                     "EnablePlainTextPassword": {
2184                         "Policy": (
2185                             "Microsoft network client: Send unencrypted "
2186                             "password to third-party SMB servers"
2187                         ),
2188                         "Settings": self.enabled_one_disabled_zero.keys(),
2189                         "lgpo_section": self.security_options_gpedit_path,
2190                         "Registry": {
2191                             "Hive": "HKEY_LOCAL_MACHINE",
2192                             "Path": (
2193                                 "SYSTEM\\CurrentControlSet\\Services\\"
2194                                 "LanmanWorkstation\\Parameters"
2195                             ),
2196                             "Value": "EnablePlainTextPassword",
2197                             "Type": "REG_DWORD",
2198                         },
2199                         "Transform": self.enabled_one_disabled_zero_transform,
2200                     },
2201                     "AutoDisconnect": {
2202                         "Policy": (
2203                             "Microsoft network server: Amount of idle "
2204                             "time required before suspending session"
2205                         ),
2206                         "Settings": {
2207                             "Function": "_in_range_inclusive",
2208                             "Args": {"min": 0, "max": 99999},
2209                         },
2210                         "lgpo_section": self.security_options_gpedit_path,
2211                         "Registry": {
2212                             "Hive": "HKEY_LOCAL_MACHINE",
2213                             "Path": (
2214                                 "System\\CurrentControlSet\\Services\\"
2215                                 "LanmanServer\\Parameters"
2216                             ),
2217                             "Value": "AutoDisconnect",
2218                             "Type": "REG_DWORD",
2219                         },
2220                     },
2221                     "EnableS4U2SelfForClaims": {
2222                         "Policy": (
2223                             "Microsoft network server: Attempt S4U2Self "
2224                             "to obtain claim information"
2225                         ),
2226                         "Settings": self.s4u2self_options.keys(),
2227                         "lgpo_section": self.security_options_gpedit_path,
2228                         "Registry": {
2229                             "Hive": "HKEY_LOCAL_MACHINE",
2230                             "Path": (
2231                                 "System\\CurrentControlSet\\Services\\"
2232                                 "LanmanServer\\Parameters"
2233                             ),
2234                             "Value": "EnableS4U2SelfForClaims",
2235                             "Type": "REG_DWORD",
2236                         },
2237                         "Transform": {
2238                             "Get": "_dict_lookup",
2239                             "Put": "_dict_lookup",
2240                             "GetArgs": {
2241                                 "lookup": self.s4u2self_options,
2242                                 "value_lookup": False,
2243                             },
2244                             "PutArgs": {
2245                                 "lookup": self.s4u2self_options,
2246                                 "value_lookup": True,
2247                             },
2248                         },
2249                     },
2250                     "Server_RequireSecuritySignature": {
2251                         "Policy": (
2252                             "Microsoft network server: Digitally sign "
2253                             "communications (always)"
2254                         ),
2255                         "Settings": self.enabled_one_disabled_zero.keys(),
2256                         "lgpo_section": self.security_options_gpedit_path,
2257                         "Registry": {
2258                             "Hive": "HKEY_LOCAL_MACHINE",
2259                             "Path": (
2260                                 "SYSTEM\\CurrentControlSet\\Services\\"
2261                                 "LanmanServer\\Parameters"
2262                             ),
2263                             "Value": "RequireSecuritySignature",
2264                             "Type": "REG_DWORD",
2265                         },
2266                         "Transform": self.enabled_one_disabled_zero_transform,
2267                     },
2268                     "Server_EnableSecuritySignature": {
2269                         "Policy": (
2270                             "Microsoft network server: Digitally sign "
2271                             "communications (if client agrees)"
2272                         ),
2273                         "Settings": self.enabled_one_disabled_zero.keys(),
2274                         "lgpo_section": self.security_options_gpedit_path,
2275                         "Registry": {
2276                             "Hive": "HKEY_LOCAL_MACHINE",
2277                             "Path": (
2278                                 "SYSTEM\\CurrentControlSet\\Services\\"
2279                                 "LanmanServer\\Parameters"
2280                             ),
2281                             "Value": "EnableSecuritySignature",
2282                             "Type": "REG_DWORD",
2283                         },
2284                         "Transform": self.enabled_one_disabled_zero_transform,
2285                     },
2286                     "EnableForcedLogoff": {
2287                         "Policy": (
2288                             "Microsoft network server: Disconnect "
2289                             "clients when logon hours expire"
2290                         ),
2291                         "Settings": self.enabled_one_disabled_zero.keys(),
2292                         "lgpo_section": self.security_options_gpedit_path,
2293                         "Registry": {
2294                             "Hive": "HKEY_LOCAL_MACHINE",
2295                             "Path": (
2296                                 "SYSTEM\\CurrentControlSet\\Services\\"
2297                                 "LanmanServer\\Parameters"
2298                             ),
2299                             "Value": "EnableForcedLogoff",
2300                             "Type": "REG_DWORD",
2301                         },
2302                         "Transform": self.enabled_one_disabled_zero_transform,
2303                     },
2304                     "SmbServerNameHardeningLevel": {
2305                         "Policy": (
2306                             "Microsoft network server: Server SPN target "
2307                             "name validation level"
2308                         ),
2309                         "Settings": self.smb_server_name_hardening_levels.keys(),
2310                         "lgpo_section": self.security_options_gpedit_path,
2311                         "Registry": {
2312                             "Hive": "HKEY_LOCAL_MACHINE",
2313                             "Path": (
2314                                 "System\\CurrentControlSet\\Services\\"
2315                                 "LanmanServer\\Parameters"
2316                             ),
2317                             "Value": "SmbServerNameHardeningLevel",
2318                             "Type": "REG_DWORD",
2319                         },
2320                         "Transform": {
2321                             "Get": "_dict_lookup",
2322                             "Put": "_dict_lookup",
2323                             "GetArgs": {
2324                                 "lookup": self.smb_server_name_hardening_levels,
2325                                 "value_lookup": False,
2326                             },
2327                             "PutArgs": {
2328                                 "lookup": self.smb_server_name_hardening_levels,
2329                                 "value_lookup": True,
2330                             },
2331                         },
2332                     },
2333                     "FullPrivilegeAuditing": {
2334                         "Policy": (
2335                             "Audit: Audit the use of Backup and Restore privilege"
2336                         ),
2337                         "Settings": [chr(0), chr(1)],
2338                         "lgpo_section": self.security_options_gpedit_path,
2339                         "Registry": {
2340                             "Hive": "HKEY_LOCAL_MACHINE",
2341                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2342                             "Value": "FullPrivilegeAuditing",
2343                             "Type": "REG_BINARY",
2344                         },
2345                         "Transform": {
2346                             "Get": "_binary_enable_zero_disable_one_conversion",
2347                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2348                         },
2349                     },
2350                     "CrashOnAuditFail": {
2351                         "Policy": (
2352                             "Audit: Shut down system immediately if "
2353                             "unable to log security audits"
2354                         ),
2355                         "Settings": self.enabled_one_disabled_zero.keys(),
2356                         "lgpo_section": self.security_options_gpedit_path,
2357                         "Registry": {
2358                             "Hive": "HKEY_LOCAL_MACHINE",
2359                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2360                             "Value": "CrashOnAuditFail",
2361                             "Type": "REG_DWORD",
2362                         },
2363                         "Transform": self.enabled_one_disabled_zero_transform,
2364                     },
2365                     "UndockWithoutLogon": {
2366                         "Policy": "Devices: Allow undock without having to log on",
2367                         "Settings": self.enabled_one_disabled_zero.keys(),
2368                         "lgpo_section": self.security_options_gpedit_path,
2369                         "Registry": {
2370                             "Hive": "HKEY_LOCAL_MACHINE",
2371                             "Path": (
2372                                 "Software\\Microsoft\\Windows\\"
2373                                 "CurrentVersion\\Policies\\System"
2374                             ),
2375                             "Value": "UndockWithoutLogon",
2376                             "Type": "REG_DWORD",
2377                         },
2378                         "Transform": self.enabled_one_disabled_zero_transform,
2379                     },
2380                     "AddPrinterDrivers": {
2381                         "Policy": (
2382                             "Devices: Prevent users from installing printer drivers"
2383                         ),
2384                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2385                         "lgpo_section": self.security_options_gpedit_path,
2386                         "Registry": {
2387                             "Hive": "HKEY_LOCAL_MACHINE",
2388                             "Path": (
2389                                 "System\\CurrentControlSet\\Control\\"
2390                                 "Print\\Providers\\LanMan Print Services\\"
2391                                 "Servers"
2392                             ),
2393                             "Value": "AddPrinterDrivers",
2394                             "Type": "REG_DWORD",
2395                         },
2396                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2397                     },
2398                     "AllocateDASD": {
2399                         "Policy": (
2400                             "Devices: Allowed to format and eject removable media"
2401                         ),
2402                         "Settings": ["9999", "0", "1", "2"],
2403                         "lgpo_section": self.security_options_gpedit_path,
2404                         "Registry": {
2405                             "Hive": "HKEY_LOCAL_MACHINE",
2406                             "Path": (
2407                                 "Software\\Microsoft\\Windows NT\\"
2408                                 "CurrentVersion\\Winlogon"
2409                             ),
2410                             "Value": "AllocateDASD",
2411                             "Type": "REG_SZ",
2412                         },
2413                         "Transform": {
2414                             "Get": "_dasd_conversion",
2415                             "Put": "_dasd_reverse_conversion",
2416                         },
2417                     },
2418                     "AllocateCDRoms": {
2419                         "Policy": (
2420                             "Devices: Restrict CD-ROM access to locally "
2421                             "logged-on user only"
2422                         ),
2423                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2424                         "lgpo_section": self.security_options_gpedit_path,
2425                         "Registry": {
2426                             "Hive": "HKEY_LOCAL_MACHINE",
2427                             "Path": (
2428                                 "Software\\Microsoft\\Windows NT\\"
2429                                 "CurrentVersion\\Winlogon"
2430                             ),
2431                             "Value": "AllocateCDRoms",
2432                             "Type": "REG_SZ",
2433                         },
2434                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2435                     },
2436                     "AllocateFloppies": {
2437                         "Policy": (
2438                             "Devices: Restrict floppy access to locally "
2439                             "logged-on user only"
2440                         ),
2441                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2442                         "lgpo_section": self.security_options_gpedit_path,
2443                         "Registry": {
2444                             "Hive": "HKEY_LOCAL_MACHINE",
2445                             "Path": (
2446                                 "Software\\Microsoft\\Windows NT\\"
2447                                 "CurrentVersion\\Winlogon"
2448                             ),
2449                             "Value": "AllocateFloppies",
2450                             "Type": "REG_SZ",
2451                         },
2452                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2453                     },
2454                     "DriverSigningPolicy": {
2455                         "Policy": "Devices: Unsigned driver installation behavior",
2456                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2457                         "lgpo_section": self.security_options_gpedit_path,
2458                         "Secedit": {
2459                             "Option": (
2460                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2461                             ),
2462                             "Section": "Registry Values",
2463                         },
2464                         "Transform": {
2465                             "Get": "_driver_signing_reg_conversion",
2466                             "Put": "_driver_signing_reg_reverse_conversion",
2467                         },
2468                     },
2469                     "SubmitControl": {
2470                         "Policy": (
2471                             "Domain controller: Allow server operators "
2472                             "to schedule tasks"
2473                         ),
2474                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2475                         "lgpo_section": self.security_options_gpedit_path,
2476                         "Registry": {
2477                             "Hive": "HKEY_LOCAL_MACHINE",
2478                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2479                             "Value": "SubmitControl",
2480                             "Type": "REG_DWORD",
2481                         },
2482                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2483                     },
2484                     "LDAPServerIntegrity": {
2485                         "Policy": "Domain controller: LDAP server signing requirements",
2486                         "Settings": self.ldap_server_signing_requirements.keys(),
2487                         "lgpo_section": self.security_options_gpedit_path,
2488                         "Registry": {
2489                             "Hive": "HKEY_LOCAL_MACHINE",
2490                             "Path": (
2491                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2492                             ),
2493                             "Value": "LDAPServerIntegrity",
2494                             "Type": "REG_DWORD",
2495                         },
2496                         "Transform": {
2497                             "Get": "_dict_lookup",
2498                             "Put": "_dict_lookup",
2499                             "GetArgs": {
2500                                 "lookup": self.ldap_server_signing_requirements,
2501                                 "value_lookup": False,
2502                             },
2503                             "PutArgs": {
2504                                 "lookup": self.ldap_server_signing_requirements,
2505                                 "value_lookup": True,
2506                             },
2507                         },
2508                     },
2509                     "RefusePasswordChange": {
2510                         "Policy": (
2511                             "Domain controller: Refuse machine account password changes"
2512                         ),
2513                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2514                         "lgpo_section": self.security_options_gpedit_path,
2515                         "Registry": {
2516                             "Hive": "HKEY_LOCAL_MACHINE",
2517                             "Path": (
2518                                 "SYSTEM\\CurrentControlSet\\Services\\"
2519                                 "Netlogon\\Parameters"
2520                             ),
2521                             "Value": "RefusePasswordChange",
2522                             "Type": "REG_DWORD",
2523                         },
2524                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2525                     },
2526                     "RequireSignOrSeal": {
2527                         "Policy": (
2528                             "Domain member: Digitally encrypt or sign "
2529                             "secure channel data (always)"
2530                         ),
2531                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2532                         "lgpo_section": self.security_options_gpedit_path,
2533                         "Registry": {
2534                             "Hive": "HKEY_LOCAL_MACHINE",
2535                             "Path": (
2536                                 "System\\CurrentControlSet\\Services\\"
2537                                 "Netlogon\\Parameters"
2538                             ),
2539                             "Value": "RequireSignOrSeal",
2540                             "Type": "REG_DWORD",
2541                         },
2542                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2543                     },
2544                     "SealSecureChannel": {
2545                         "Policy": (
2546                             "Domain member: Digitally encrypt secure "
2547                             "channel data (when possible)"
2548                         ),
2549                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2550                         "lgpo_section": self.security_options_gpedit_path,
2551                         "Registry": {
2552                             "Hive": "HKEY_LOCAL_MACHINE",
2553                             "Path": (
2554                                 "System\\CurrentControlSet\\Services\\"
2555                                 "Netlogon\\Parameters"
2556                             ),
2557                             "Value": "SealSecureChannel",
2558                             "Type": "REG_DWORD",
2559                         },
2560                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2561                     },
2562                     "SignSecureChannel": {
2563                         "Policy": (
2564                             "Domain member: Digitally sign secure "
2565                             "channel data (when possible)"
2566                         ),
2567                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2568                         "lgpo_section": self.security_options_gpedit_path,
2569                         "Registry": {
2570                             "Hive": "HKEY_LOCAL_MACHINE",
2571                             "Path": (
2572                                 "System\\CurrentControlSet\\Services\\"
2573                                 "Netlogon\\Parameters"
2574                             ),
2575                             "Value": "SignSecureChannel",
2576                             "Type": "REG_DWORD",
2577                         },
2578                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2579                     },
2580                     "DisablePasswordChange": {
2581                         "Policy": (
2582                             "Domain member: Disable machine account password changes"
2583                         ),
2584                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2585                         "lgpo_section": self.security_options_gpedit_path,
2586                         "Registry": {
2587                             "Hive": "HKEY_LOCAL_MACHINE",
2588                             "Path": (
2589                                 "System\\CurrentControlSet\\Services\\"
2590                                 "Netlogon\\Parameters"
2591                             ),
2592                             "Value": "DisablePasswordChange",
2593                             "Type": "REG_DWORD",
2594                         },
2595                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2596                     },
2597                     "MaximumPasswordAge": {
2598                         "Policy": "Domain member: Maximum machine account password age",
2599                         "Settings": {
2600                             "Function": "_in_range_inclusive",
2601                             "Args": {"min": 0, "max": 999},
2602                         },
2603                         "lgpo_section": self.security_options_gpedit_path,
2604                         "Registry": {
2605                             "Hive": "HKEY_LOCAL_MACHINE",
2606                             "Path": (
2607                                 "System\\CurrentControlSet\\Services\\"
2608                                 "Netlogon\\Parameters"
2609                             ),
2610                             "Value": "MaximumPasswordAge",
2611                             "Type": "REG_DWORD",
2612                         },
2613                     },
2614                     "RequireStrongKey": {
2615                         "Policy": (
2616                             "Domain member: Require strong (Windows 2000 "
2617                             "or later) session key"
2618                         ),
2619                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2620                         "lgpo_section": self.security_options_gpedit_path,
2621                         "Registry": {
2622                             "Hive": "HKEY_LOCAL_MACHINE",
2623                             "Path": (
2624                                 "System\\CurrentControlSet\\Services\\"
2625                                 "Netlogon\\Parameters"
2626                             ),
2627                             "Value": "RequireStrongKey",
2628                             "Type": "REG_DWORD",
2629                         },
2630                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2631                     },
2632                     "LockoutDuration": {
2633                         "Policy": "Account lockout duration",
2634                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2635                         "Settings": {
2636                             "Function": "_in_range_inclusive",
2637                             "Args": {
2638                                 "min": 0,
2639                                 "max": 6000000,
2640                                 "zero_value": 0xFFFFFFFF,
2641                             },
2642                         },
2643                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2644                         "Transform": {
2645                             "Get": "_seconds_to_minutes",
2646                             "Put": "_minutes_to_seconds",
2647                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2648                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2649                         },
2650                     },
2651                     "LockoutThreshold": {
2652                         "Policy": "Account lockout threshold",
2653                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2654                         "Settings": {
2655                             "Function": "_in_range_inclusive",
2656                             "Args": {"min": 0, "max": 1000},
2657                         },
2658                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2659                     },
2660                     "LockoutWindow": {
2661                         "Policy": "Reset account lockout counter after",
2662                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2663                         "Settings": {
2664                             "Function": "_in_range_inclusive",
2665                             "Args": {"min": 0, "max": 6000000},
2666                         },
2667                         "NetUserModal": {
2668                             "Modal": 3,
2669                             "Option": "lockout_observation_window",
2670                         },
2671                         "Transform": {
2672                             "Get": "_seconds_to_minutes",
2673                             "Put": "_minutes_to_seconds",
2674                         },
2675                     },
2676                     "AuditAccountLogon": {
2677                         "Policy": "Audit account logon events",
2678                         "lgpo_section": self.audit_policy_gpedit_path,
2679                         "Settings": self.audit_lookup.keys(),
2680                         "Secedit": {
2681                             "Option": "AuditAccountLogon",
2682                             "Section": "Event Audit",
2683                         },
2684                         "Transform": self.audit_transform,
2685                     },
2686                     "AuditAccountManage": {
2687                         "Policy": "Audit account management",
2688                         "lgpo_section": self.audit_policy_gpedit_path,
2689                         "Settings": self.audit_lookup.keys(),
2690                         "Secedit": {
2691                             "Option": "AuditAccountManage",
2692                             "Section": "Event Audit",
2693                         },
2694                         "Transform": self.audit_transform,
2695                     },
2696                     "AuditDSAccess": {
2697                         "Policy": "Audit directory service access",
2698                         "lgpo_section": self.audit_policy_gpedit_path,
2699                         "Settings": self.audit_lookup.keys(),
2700                         "Secedit": {
2701                             "Option": "AuditDSAccess",
2702                             "Section": "Event Audit",
2703                         },
2704                         "Transform": self.audit_transform,
2705                     },
2706                     "AuditLogonEvents": {
2707                         "Policy": "Audit logon events",
2708                         "lgpo_section": self.audit_policy_gpedit_path,
2709                         "Settings": self.audit_lookup.keys(),
2710                         "Secedit": {
2711                             "Option": "AuditLogonEvents",
2712                             "Section": "Event Audit",
2713                         },
2714                         "Transform": self.audit_transform,
2715                     },
2716                     "AuditObjectAccess": {
2717                         "Policy": "Audit object access",
2718                         "lgpo_section": self.audit_policy_gpedit_path,
2719                         "Settings": self.audit_lookup.keys(),
2720                         "Secedit": {
2721                             "Option": "AuditObjectAccess",
2722                             "Section": "Event Audit",
2723                         },
2724                         "Transform": self.audit_transform,
2725                     },
2726                     "AuditPolicyChange": {
2727                         "Policy": "Audit policy change",
2728                         "lgpo_section": self.audit_policy_gpedit_path,
2729                         "Settings": self.audit_lookup.keys(),
2730                         "Secedit": {
2731                             "Option": "AuditPolicyChange",
2732                             "Section": "Event Audit",
2733                         },
2734                         "Transform": self.audit_transform,
2735                     },
2736                     "AuditPrivilegeUse": {
2737                         "Policy": "Audit privilege use",
2738                         "lgpo_section": self.audit_policy_gpedit_path,
2739                         "Settings": self.audit_lookup.keys(),
2740                         "Secedit": {
2741                             "Option": "AuditPrivilegeUse",
2742                             "Section": "Event Audit",
2743                         },
2744                         "Transform": self.audit_transform,
2745                     },
2746                     "AuditProcessTracking": {
2747                         "Policy": "Audit process tracking",
2748                         "lgpo_section": self.audit_policy_gpedit_path,
2749                         "Settings": self.audit_lookup.keys(),
2750                         "Secedit": {
2751                             "Option": "AuditProcessTracking",
2752                             "Section": "Event Audit",
2753                         },
2754                         "Transform": self.audit_transform,
2755                     },
2756                     "AuditSystemEvents": {
2757                         "Policy": "Audit system events",
2758                         "lgpo_section": self.audit_policy_gpedit_path,
2759                         "Settings": self.audit_lookup.keys(),
2760                         "Secedit": {
2761                             "Option": "AuditSystemEvents",
2762                             "Section": "Event Audit",
2763                         },
2764                         "Transform": self.audit_transform,
2765                     },
2766                     "AuditCredentialValidation": {
2767                         "Policy": "Audit Credential Validation",
2768                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2769                         "Settings": self.advanced_audit_lookup.keys(),
2770                         "AdvAudit": {"Option": "Audit Credential Validation"},
2771                         "Transform": self.advanced_audit_transform,
2772                     },
2773                     "AuditKerberosAuthenticationService": {
2774                         "Policy": "Audit Kerberos Authentication Service",
2775                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2776                         "Settings": self.advanced_audit_lookup.keys(),
2777                         "AdvAudit": {
2778                             "Option": "Audit Kerberos Authentication Service",
2779                         },
2780                         "Transform": self.advanced_audit_transform,
2781                     },
2782                     "AuditKerberosServiceTicketOperations": {
2783                         "Policy": "Audit Kerberos Service Ticket Operations",
2784                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2785                         "Settings": self.advanced_audit_lookup.keys(),
2786                         "AdvAudit": {
2787                             "Option": "Audit Kerberos Service Ticket Operations",
2788                         },
2789                         "Transform": self.advanced_audit_transform,
2790                     },
2791                     "AuditOtherAccountLogonEvents": {
2792                         "Policy": "Audit Other Account Logon Events",
2793                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2794                         "Settings": self.advanced_audit_lookup.keys(),
2795                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2796                         "Transform": self.advanced_audit_transform,
2797                     },
2798                     "AuditApplicationGroupManagement": {
2799                         "Policy": "Audit Application Group Management",
2800                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2801                         "Settings": self.advanced_audit_lookup.keys(),
2802                         "AdvAudit": {"Option": "Audit Application Group Management"},
2803                         "Transform": self.advanced_audit_transform,
2804                     },
2805                     "AuditComputerAccountManagement": {
2806                         "Policy": "Audit Computer Account Management",
2807                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2808                         "Settings": self.advanced_audit_lookup.keys(),
2809                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2810                         "Transform": self.advanced_audit_transform,
2811                     },
2812                     "AuditDistributionGroupManagement": {
2813                         "Policy": "Audit Distribution Group Management",
2814                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2815                         "Settings": self.advanced_audit_lookup.keys(),
2816                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2817                         "Transform": self.advanced_audit_transform,
2818                     },
2819                     "AuditOtherAccountManagementEvents": {
2820                         "Policy": "Audit Other Account Management Events",
2821                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2822                         "Settings": self.advanced_audit_lookup.keys(),
2823                         "AdvAudit": {
2824                             "Option": "Audit Other Account Management Events",
2825                         },
2826                         "Transform": self.advanced_audit_transform,
2827                     },
2828                     "AuditSecurityGroupManagement": {
2829                         "Policy": "Audit Security Group Management",
2830                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2831                         "Settings": self.advanced_audit_lookup.keys(),
2832                         "AdvAudit": {"Option": "Audit Security Group Management"},
2833                         "Transform": self.advanced_audit_transform,
2834                     },
2835                     "AuditUserAccountManagement": {
2836                         "Policy": "Audit User Account Management",
2837                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2838                         "Settings": self.advanced_audit_lookup.keys(),
2839                         "AdvAudit": {"Option": "Audit User Account Management"},
2840                         "Transform": self.advanced_audit_transform,
2841                     },
2842                     "AuditDPAPIActivity": {
2843                         "Policy": "Audit DPAPI Activity",
2844                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2845                         "Settings": self.advanced_audit_lookup.keys(),
2846                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2847                         "Transform": self.advanced_audit_transform,
2848                     },
2849                     "AuditPNPActivity": {
2850                         "Policy": "Audit PNP Activity",
2851                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2852                         "Settings": self.advanced_audit_lookup.keys(),
2853                         "AdvAudit": {"Option": "Audit PNP Activity"},
2854                         "Transform": self.advanced_audit_transform,
2855                     },
2856                     "AuditProcessCreation": {
2857                         "Policy": "Audit Process Creation",
2858                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2859                         "Settings": self.advanced_audit_lookup.keys(),
2860                         "AdvAudit": {"Option": "Audit Process Creation"},
2861                         "Transform": self.advanced_audit_transform,
2862                     },
2863                     "AuditProcessTermination": {
2864                         "Policy": "Audit Process Termination",
2865                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2866                         "Settings": self.advanced_audit_lookup.keys(),
2867                         "AdvAudit": {"Option": "Audit Process Termination"},
2868                         "Transform": self.advanced_audit_transform,
2869                     },
2870                     "AuditRPCEvents": {
2871                         "Policy": "Audit RPC Events",
2872                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2873                         "Settings": self.advanced_audit_lookup.keys(),
2874                         "AdvAudit": {"Option": "Audit RPC Events"},
2875                         "Transform": self.advanced_audit_transform,
2876                     },
2877                     "AuditTokenRightAdjusted": {
2878                         "Policy": "Audit Token Right Adjusted",
2879                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2880                         "Settings": self.advanced_audit_lookup.keys(),
2881                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2882                         "Transform": self.advanced_audit_transform,
2883                     },
2884                     "AuditDetailedDirectoryServiceReplication": {
2885                         "Policy": "Audit Detailed Directory Service Replication",
2886                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2887                         "Settings": self.advanced_audit_lookup.keys(),
2888                         "AdvAudit": {
2889                             "Option": "Audit Detailed Directory Service Replication",
2890                         },
2891                         "Transform": self.advanced_audit_transform,
2892                     },
2893                     "AuditDirectoryServiceAccess": {
2894                         "Policy": "Audit Directory Service Access",
2895                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2896                         "Settings": self.advanced_audit_lookup.keys(),
2897                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2898                         "Transform": self.advanced_audit_transform,
2899                     },
2900                     "AuditDirectoryServiceChanges": {
2901                         "Policy": "Audit Directory Service Changes",
2902                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2903                         "Settings": self.advanced_audit_lookup.keys(),
2904                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2905                         "Transform": self.advanced_audit_transform,
2906                     },
2907                     "AuditDirectoryServiceReplication": {
2908                         "Policy": "Audit Directory Service Replication",
2909                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2910                         "Settings": self.advanced_audit_lookup.keys(),
2911                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2912                         "Transform": self.advanced_audit_transform,
2913                     },
2914                     "AuditAccountLockout": {
2915                         "Policy": "Audit Account Lockout",
2916                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2917                         "Settings": self.advanced_audit_lookup.keys(),
2918                         "AdvAudit": {"Option": "Audit Account Lockout"},
2919                         "Transform": self.advanced_audit_transform,
2920                     },
2921                     "AuditUserDeviceClaims": {
2922                         "Policy": "Audit User / Device Claims",
2923                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2924                         "Settings": self.advanced_audit_lookup.keys(),
2925                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2926                         "Transform": self.advanced_audit_transform,
2927                     },
2928                     "AuditGroupMembership": {
2929                         "Policy": "Audit Group Membership",
2930                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2931                         "Settings": self.advanced_audit_lookup.keys(),
2932                         "AdvAudit": {"Option": "Audit Group Membership"},
2933                         "Transform": self.advanced_audit_transform,
2934                     },
2935                     "AuditIPsecExtendedMode": {
2936                         "Policy": "Audit IPsec Extended Mode",
2937                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2938                         "Settings": self.advanced_audit_lookup.keys(),
2939                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2940                         "Transform": self.advanced_audit_transform,
2941                     },
2942                     "AuditIPsecMainMode": {
2943                         "Policy": "Audit IPsec Main Mode",
2944                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2945                         "Settings": self.advanced_audit_lookup.keys(),
2946                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2947                         "Transform": self.advanced_audit_transform,
2948                     },
2949                     "AuditIPsecQuickMode": {
2950                         "Policy": "Audit IPsec Quick Mode",
2951                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2952                         "Settings": self.advanced_audit_lookup.keys(),
2953                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2954                         "Transform": self.advanced_audit_transform,
2955                     },
2956                     "AuditLogoff": {
2957                         "Policy": "Audit Logoff",
2958                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2959                         "Settings": self.advanced_audit_lookup.keys(),
2960                         "AdvAudit": {"Option": "Audit Logoff"},
2961                         "Transform": self.advanced_audit_transform,
2962                     },
2963                     "AuditLogon": {
2964                         "Policy": "Audit Logon",
2965                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2966                         "Settings": self.advanced_audit_lookup.keys(),
2967                         "AdvAudit": {"Option": "Audit Logon"},
2968                         "Transform": self.advanced_audit_transform,
2969                     },
2970                     "AuditNetworkPolicyServer": {
2971                         "Policy": "Audit Network Policy Server",
2972                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2973                         "Settings": self.advanced_audit_lookup.keys(),
2974                         "AdvAudit": {"Option": "Audit Network Policy Server"},
2975                         "Transform": self.advanced_audit_transform,
2976                     },
2977                     "AuditOtherLogonLogoffEvents": {
2978                         "Policy": "Audit Other Logon/Logoff Events",
2979                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2980                         "Settings": self.advanced_audit_lookup.keys(),
2981                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
2982                         "Transform": self.advanced_audit_transform,
2983                     },
2984                     "AuditSpecialLogon": {
2985                         "Policy": "Audit Special Logon",
2986                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2987                         "Settings": self.advanced_audit_lookup.keys(),
2988                         "AdvAudit": {"Option": "Audit Special Logon"},
2989                         "Transform": self.advanced_audit_transform,
2990                     },
2991                     "AuditApplicationGenerated": {
2992                         "Policy": "Audit Application Generated",
2993                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2994                         "Settings": self.advanced_audit_lookup.keys(),
2995                         "AdvAudit": {"Option": "Audit Application Generated"},
2996                         "Transform": self.advanced_audit_transform,
2997                     },
2998                     "AuditCertificationServices": {
2999                         "Policy": "Audit Certification Services",
3000                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3001                         "Settings": self.advanced_audit_lookup.keys(),
3002                         "AdvAudit": {"Option": "Audit Certification Services"},
3003                         "Transform": self.advanced_audit_transform,
3004                     },
3005                     "AuditDetailedFileShare": {
3006                         "Policy": "Audit Detailed File Share",
3007                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3008                         "Settings": self.advanced_audit_lookup.keys(),
3009                         "AdvAudit": {"Option": "Audit Detailed File Share"},
3010                         "Transform": self.advanced_audit_transform,
3011                     },
3012                     "AuditFileShare": {
3013                         "Policy": "Audit File Share",
3014                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3015                         "Settings": self.advanced_audit_lookup.keys(),
3016                         "AdvAudit": {"Option": "Audit File Share"},
3017                         "Transform": self.advanced_audit_transform,
3018                     },
3019                     "AuditFileSystem": {
3020                         "Policy": "Audit File System",
3021                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3022                         "Settings": self.advanced_audit_lookup.keys(),
3023                         "AdvAudit": {"Option": "Audit File System"},
3024                         "Transform": self.advanced_audit_transform,
3025                     },
3026                     "AuditFilteringPlatformConnection": {
3027                         "Policy": "Audit Filtering Platform Connection",
3028                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3029                         "Settings": self.advanced_audit_lookup.keys(),
3030                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
3031                         "Transform": self.advanced_audit_transform,
3032                     },
3033                     "AuditFilteringPlatformPacketDrop": {
3034                         "Policy": "Audit Filtering Platform Packet Drop",
3035                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3036                         "Settings": self.advanced_audit_lookup.keys(),
3037                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
3038                         "Transform": self.advanced_audit_transform,
3039                     },
3040                     "AuditHandleManipulation": {
3041                         "Policy": "Audit Handle Manipulation",
3042                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3043                         "Settings": self.advanced_audit_lookup.keys(),
3044                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
3045                         "Transform": self.advanced_audit_transform,
3046                     },
3047                     "AuditKernelObject": {
3048                         "Policy": "Audit Kernel Object",
3049                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3050                         "Settings": self.advanced_audit_lookup.keys(),
3051                         "AdvAudit": {"Option": "Audit Kernel Object"},
3052                         "Transform": self.advanced_audit_transform,
3053                     },
3054                     "AuditOtherObjectAccessEvents": {
3055                         "Policy": "Audit Other Object Access Events",
3056                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3057                         "Settings": self.advanced_audit_lookup.keys(),
3058                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
3059                         "Transform": self.advanced_audit_transform,
3060                     },
3061                     "AuditRegistry": {
3062                         "Policy": "Audit Registry",
3063                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3064                         "Settings": self.advanced_audit_lookup.keys(),
3065                         "AdvAudit": {"Option": "Audit Registry"},
3066                         "Transform": self.advanced_audit_transform,
3067                     },
3068                     "AuditRemovableStorage": {
3069                         "Policy": "Audit Removable Storage",
3070                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3071                         "Settings": self.advanced_audit_lookup.keys(),
3072                         "AdvAudit": {"Option": "Audit Removable Storage"},
3073                         "Transform": self.advanced_audit_transform,
3074                     },
3075                     "AuditSAM": {
3076                         "Policy": "Audit SAM",
3077                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3078                         "Settings": self.advanced_audit_lookup.keys(),
3079                         "AdvAudit": {"Option": "Audit SAM"},
3080                         "Transform": self.advanced_audit_transform,
3081                     },
3082                     "AuditCentralAccessPolicyStaging": {
3083                         "Policy": "Audit Central Access Policy Staging",
3084                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3085                         "Settings": self.advanced_audit_lookup.keys(),
3086                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
3087                         "Transform": self.advanced_audit_transform,
3088                     },
3089                     "AuditAuditPolicyChange": {
3090                         "Policy": "Audit Audit Policy Change",
3091                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3092                         "Settings": self.advanced_audit_lookup.keys(),
3093                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3094                         "Transform": self.advanced_audit_transform,
3095                     },
3096                     "AuditAuthenticationPolicyChange": {
3097                         "Policy": "Audit Authentication Policy Change",
3098                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3099                         "Settings": self.advanced_audit_lookup.keys(),
3100                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3101                         "Transform": self.advanced_audit_transform,
3102                     },
3103                     "AuditAuthorizationPolicyChange": {
3104                         "Policy": "Audit Authorization Policy Change",
3105                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3106                         "Settings": self.advanced_audit_lookup.keys(),
3107                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3108                         "Transform": self.advanced_audit_transform,
3109                     },
3110                     "AuditFilteringPlatformPolicyChange": {
3111                         "Policy": "Audit Filtering Platform Policy Change",
3112                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3113                         "Settings": self.advanced_audit_lookup.keys(),
3114                         "AdvAudit": {
3115                             "Option": "Audit Filtering Platform Policy Change",
3116                         },
3117                         "Transform": self.advanced_audit_transform,
3118                     },
3119                     "AuditMPSSVCRuleLevelPolicyChange": {
3120                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3121                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3122                         "Settings": self.advanced_audit_lookup.keys(),
3123                         "AdvAudit": {
3124                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3125                         },
3126                         "Transform": self.advanced_audit_transform,
3127                     },
3128                     "AuditOtherPolicyChangeEvents": {
3129                         "Policy": "Audit Other Policy Change Events",
3130                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3131                         "Settings": self.advanced_audit_lookup.keys(),
3132                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3133                         "Transform": self.advanced_audit_transform,
3134                     },
3135                     "AuditNonSensitivePrivilegeUse": {
3136                         "Policy": "Audit Non Sensitive Privilege Use",
3137                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3138                         "Settings": self.advanced_audit_lookup.keys(),
3139                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3140                         "Transform": self.advanced_audit_transform,
3141                     },
3142                     "AuditOtherPrivilegeUseEvents": {
3143                         "Policy": "Audit Other Privilege Use Events",
3144                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3145                         "Settings": self.advanced_audit_lookup.keys(),
3146                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3147                         "Transform": self.advanced_audit_transform,
3148                     },
3149                     "AuditSensitivePrivilegeUse": {
3150                         "Policy": "Audit Sensitive Privilege Use",
3151                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3152                         "Settings": self.advanced_audit_lookup.keys(),
3153                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3154                         "Transform": self.advanced_audit_transform,
3155                     },
3156                     "AuditIPsecDriver": {
3157                         "Policy": "Audit IPsec Driver",
3158                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3159                         "Settings": self.advanced_audit_lookup.keys(),
3160                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3161                         "Transform": self.advanced_audit_transform,
3162                     },
3163                     "AuditOtherSystemEvents": {
3164                         "Policy": "Audit Other System Events",
3165                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3166                         "Settings": self.advanced_audit_lookup.keys(),
3167                         "AdvAudit": {"Option": "Audit Other System Events"},
3168                         "Transform": self.advanced_audit_transform,
3169                     },
3170                     "AuditSecurityStateChange": {
3171                         "Policy": "Audit Security State Change",
3172                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3173                         "Settings": self.advanced_audit_lookup.keys(),
3174                         "AdvAudit": {"Option": "Audit Security State Change"},
3175                         "Transform": self.advanced_audit_transform,
3176                     },
3177                     "AuditSecuritySystemExtension": {
3178                         "Policy": "Audit Security System Extension",
3179                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3180                         "Settings": self.advanced_audit_lookup.keys(),
3181                         "AdvAudit": {"Option": "Audit Security System Extension"},
3182                         "Transform": self.advanced_audit_transform,
3183                     },
3184                     "AuditSystemIntegrity": {
3185                         "Policy": "Audit System Integrity",
3186                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3187                         "Settings": self.advanced_audit_lookup.keys(),
3188                         "AdvAudit": {"Option": "Audit System Integrity"},
3189                         "Transform": self.advanced_audit_transform,
3190                     },
3191                     "SeTrustedCredManAccessPrivilege": {
3192                         "Policy": "Access Credential Manager as a trusted caller",
3193                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3194                         "rights_assignment": True,
3195                         "Settings": None,
3196                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3197                         "Transform": {
3198                             "Get": "_sidConversion",
3199                             "Put": "_usernamesToSidObjects",
3200                         },
3201                     },
3202                     "SeNetworkLogonRight": {
3203                         "Policy": "Access this computer from the network",
3204                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3205                         "rights_assignment": True,
3206                         "Settings": None,
3207                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3208                         "Transform": {
3209                             "Get": "_sidConversion",
3210                             "Put": "_usernamesToSidObjects",
3211                         },
3212                     },
3213                     "SeTcbPrivilege": {
3214                         "Policy": "Act as part of the operating system",
3215                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3216                         "rights_assignment": True,
3217                         "Settings": None,
3218                         "LsaRights": {"Option": "SeTcbPrivilege"},
3219                         "Transform": {
3220                             "Get": "_sidConversion",
3221                             "Put": "_usernamesToSidObjects",
3222                         },
3223                     },
3224                     "SeMachineAccountPrivilege": {
3225                         "Policy": "Add workstations to domain",
3226                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3227                         "rights_assignment": True,
3228                         "Settings": None,
3229                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3230                         "Transform": {
3231                             "Get": "_sidConversion",
3232                             "Put": "_usernamesToSidObjects",
3233                         },
3234                     },
3235                     "SeIncreaseQuotaPrivilege": {
3236                         "Policy": "Adjust memory quotas for a process",
3237                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3238                         "rights_assignment": True,
3239                         "Settings": None,
3240                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3241                         "Transform": {
3242                             "Get": "_sidConversion",
3243                             "Put": "_usernamesToSidObjects",
3244                         },
3245                     },
3246                     "SeInteractiveLogonRight": {
3247                         "Policy": "Allow log on locally",
3248                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3249                         "rights_assignment": True,
3250                         "Settings": None,
3251                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3252                         "Transform": {
3253                             "Get": "_sidConversion",
3254                             "Put": "_usernamesToSidObjects",
3255                         },
3256                     },
3257                     "SeRemoteInteractiveLogonRight": {
3258                         "Policy": "Allow log on through Remote Desktop Services",
3259                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3260                         "rights_assignment": True,
3261                         "Settings": None,
3262                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3263                         "Transform": {
3264                             "Get": "_sidConversion",
3265                             "Put": "_usernamesToSidObjects",
3266                         },
3267                     },
3268                     "SeBackupPrivilege": {
3269                         "Policy": "Backup files and directories",
3270                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3271                         "rights_assignment": True,
3272                         "Settings": None,
3273                         "LsaRights": {"Option": "SeBackupPrivilege"},
3274                         "Transform": {
3275                             "Get": "_sidConversion",
3276                             "Put": "_usernamesToSidObjects",
3277                         },
3278                     },
3279                     "SeChangeNotifyPrivilege": {
3280                         "Policy": "Bypass traverse checking",
3281                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3282                         "rights_assignment": True,
3283                         "Settings": None,
3284                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3285                         "Transform": {
3286                             "Get": "_sidConversion",
3287                             "Put": "_usernamesToSidObjects",
3288                         },
3289                     },
3290                     "SeSystemtimePrivilege": {
3291                         "Policy": "Change the system time",
3292                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3293                         "rights_assignment": True,
3294                         "Settings": None,
3295                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3296                         "Transform": {
3297                             "Get": "_sidConversion",
3298                             "Put": "_usernamesToSidObjects",
3299                         },
3300                     },
3301                     "SeTimeZonePrivilege": {
3302                         "Policy": "Change the time zone",
3303                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3304                         "rights_assignment": True,
3305                         "Settings": None,
3306                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3307                         "Transform": {
3308                             "Get": "_sidConversion",
3309                             "Put": "_usernamesToSidObjects",
3310                         },
3311                     },
3312                     "SeCreatePagefilePrivilege": {
3313                         "Policy": "Create a pagefile",
3314                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3315                         "rights_assignment": True,
3316                         "Settings": None,
3317                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3318                         "Transform": {
3319                             "Get": "_sidConversion",
3320                             "Put": "_usernamesToSidObjects",
3321                         },
3322                     },
3323                     "SeCreateTokenPrivilege": {
3324                         "Policy": "Create a token object",
3325                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3326                         "rights_assignment": True,
3327                         "Settings": None,
3328                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3329                         "Transform": {
3330                             "Get": "_sidConversion",
3331                             "Put": "_usernamesToSidObjects",
3332                         },
3333                     },
3334                     "SeCreateGlobalPrivilege": {
3335                         "Policy": "Create global objects",
3336                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3337                         "rights_assignment": True,
3338                         "Settings": None,
3339                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3340                         "Transform": {
3341                             "Get": "_sidConversion",
3342                             "Put": "_usernamesToSidObjects",
3343                         },
3344                     },
3345                     "SeCreatePermanentPrivilege": {
3346                         "Policy": "Create permanent shared objects",
3347                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3348                         "rights_assignment": True,
3349                         "Settings": None,
3350                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3351                         "Transform": {
3352                             "Get": "_sidConversion",
3353                             "Put": "_usernamesToSidObjects",
3354                         },
3355                     },
3356                     "SeCreateSymbolicLinkPrivilege": {
3357                         "Policy": "Create symbolic links",
3358                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3359                         "rights_assignment": True,
3360                         "Settings": None,
3361                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3362                         "Transform": {
3363                             "Get": "_sidConversion",
3364                             "Put": "_usernamesToSidObjects",
3365                         },
3366                     },
3367                     "SeDebugPrivilege": {
3368                         "Policy": "Debug programs",
3369                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3370                         "rights_assignment": True,
3371                         "Settings": None,
3372                         "LsaRights": {"Option": "SeDebugPrivilege"},
3373                         "Transform": {
3374                             "Get": "_sidConversion",
3375                             "Put": "_usernamesToSidObjects",
3376                         },
3377                     },
3378                     "SeDenyNetworkLogonRight": {
3379                         "Policy": "Deny access to this computer from the network",
3380                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3381                         "rights_assignment": True,
3382                         "Settings": None,
3383                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3384                         "Transform": {
3385                             "Get": "_sidConversion",
3386                             "Put": "_usernamesToSidObjects",
3387                         },
3388                     },
3389                     "SeDenyBatchLogonRight": {
3390                         "Policy": "Deny log on as a batch job",
3391                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3392                         "rights_assignment": True,
3393                         "Settings": None,
3394                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3395                         "Transform": {
3396                             "Get": "_sidConversion",
3397                             "Put": "_usernamesToSidObjects",
3398                         },
3399                     },
3400                     "SeDenyServiceLogonRight": {
3401                         "Policy": "Deny log on as a service",
3402                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3403                         "rights_assignment": True,
3404                         "Settings": None,
3405                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3406                         "Transform": {
3407                             "Get": "_sidConversion",
3408                             "Put": "_usernamesToSidObjects",
3409                         },
3410                     },
3411                     "SeDenyInteractiveLogonRight": {
3412                         "Policy": "Deny log on locally",
3413                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3414                         "rights_assignment": True,
3415                         "Settings": None,
3416                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3417                         "Transform": {
3418                             "Get": "_sidConversion",
3419                             "Put": "_usernamesToSidObjects",
3420                         },
3421                     },
3422                     "SeDenyRemoteInteractiveLogonRight": {
3423                         "Policy": "Deny log on through Remote Desktop Services",
3424                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3425                         "rights_assignment": True,
3426                         "Settings": None,
3427                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3428                         "Transform": {
3429                             "Get": "_sidConversion",
3430                             "Put": "_usernamesToSidObjects",
3431                         },
3432                     },
3433                     "SeEnableDelegationPrivilege": {
3434                         "Policy": (
3435                             "Enable computer and user accounts to be "
3436                             "trusted for delegation"
3437                         ),
3438                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3439                         "rights_assignment": True,
3440                         "Settings": None,
3441                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3442                         "Transform": {
3443                             "Get": "_sidConversion",
3444                             "Put": "_usernamesToSidObjects",
3445                         },
3446                     },
3447                     "SeRemoteShutdownPrivilege": {
3448                         "Policy": "Force shutdown from a remote system",
3449                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3450                         "rights_assignment": True,
3451                         "Settings": None,
3452                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3453                         "Transform": {
3454                             "Get": "_sidConversion",
3455                             "Put": "_usernamesToSidObjects",
3456                         },
3457                     },
3458                     "SeAuditPrivilege": {
3459                         "Policy": "Generate security audits",
3460                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3461                         "rights_assignment": True,
3462                         "Settings": None,
3463                         "LsaRights": {"Option": "SeAuditPrivilege"},
3464                         "Transform": {
3465                             "Get": "_sidConversion",
3466                             "Put": "_usernamesToSidObjects",
3467                         },
3468                     },
3469                     "SeImpersonatePrivilege": {
3470                         "Policy": "Impersonate a client after authentication",
3471                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3472                         "rights_assignment": True,
3473                         "Settings": None,
3474                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3475                         "Transform": {
3476                             "Get": "_sidConversion",
3477                             "Put": "_usernamesToSidObjects",
3478                         },
3479                     },
3480                     "SeIncreaseWorkingSetPrivilege": {
3481                         "Policy": "Increase a process working set",
3482                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3483                         "rights_assignment": True,
3484                         "Settings": None,
3485                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3486                         "Transform": {
3487                             "Get": "_sidConversion",
3488                             "Put": "_usernamesToSidObjects",
3489                         },
3490                     },
3491                     "SeIncreaseBasePriorityPrivilege": {
3492                         "Policy": "Increase scheduling priority",
3493                         "rights_assignment": True,
3494                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3495                         "Settings": None,
3496                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3497                         "Transform": {
3498                             "Get": "_sidConversion",
3499                             "Put": "_usernamesToSidObjects",
3500                         },
3501                     },
3502                     "SeLoadDriverPrivilege": {
3503                         "Policy": "Load and unload device drivers",
3504                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3505                         "rights_assignment": True,
3506                         "Settings": None,
3507                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3508                         "Transform": {
3509                             "Get": "_sidConversion",
3510                             "Put": "_usernamesToSidObjects",
3511                         },
3512                     },
3513                     "SeLockMemoryPrivilege": {
3514                         "Policy": "Lock pages in memory",
3515                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3516                         "rights_assignment": True,
3517                         "Settings": None,
3518                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3519                         "Transform": {
3520                             "Get": "_sidConversion",
3521                             "Put": "_usernamesToSidObjects",
3522                         },
3523                     },
3524                     "SeBatchLogonRight": {
3525                         "Policy": "Log on as a batch job",
3526                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3527                         "rights_assignment": True,
3528                         "Settings": None,
3529                         "LsaRights": {"Option": "SeBatchLogonRight"},
3530                         "Transform": {
3531                             "Get": "_sidConversion",
3532                             "Put": "_usernamesToSidObjects",
3533                         },
3534                     },
3535                     "SeServiceLogonRight": {
3536                         "Policy": "Log on as a service",
3537                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3538                         "rights_assignment": True,
3539                         "Settings": None,
3540                         "LsaRights": {"Option": "SeServiceLogonRight"},
3541                         "Transform": {
3542                             "Get": "_sidConversion",
3543                             "Put": "_usernamesToSidObjects",
3544                         },
3545                     },
3546                     "SeSecurityPrivilege": {
3547                         "Policy": "Manage auditing and security log",
3548                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3549                         "rights_assignment": True,
3550                         "Settings": None,
3551                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3552                         "Transform": {
3553                             "Get": "_sidConversion",
3554                             "Put": "_usernamesToSidObjects",
3555                         },
3556                     },
3557                     "SeRelabelPrivilege": {
3558                         "Policy": "Modify an object label",
3559                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3560                         "rights_assignment": True,
3561                         "Settings": None,
3562                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3563                         "Transform": {
3564                             "Get": "_sidConversion",
3565                             "Put": "_usernamesToSidObjects",
3566                         },
3567                     },
3568                     "SeSystemEnvironmentPrivilege": {
3569                         "Policy": "Modify firmware environment values",
3570                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3571                         "rights_assignment": True,
3572                         "Settings": None,
3573                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3574                         "Transform": {
3575                             "Get": "_sidConversion",
3576                             "Put": "_usernamesToSidObjects",
3577                         },
3578                     },
3579                     "SeManageVolumePrivilege": {
3580                         "Policy": "Perform volume maintenance tasks",
3581                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3582                         "rights_assignment": True,
3583                         "Settings": None,
3584                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3585                         "Transform": {
3586                             "Get": "_sidConversion",
3587                             "Put": "_usernamesToSidObjects",
3588                         },
3589                     },
3590                     "SeProfileSingleProcessPrivilege": {
3591                         "Policy": "Profile single process",
3592                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3593                         "rights_assignment": True,
3594                         "Settings": None,
3595                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3596                         "Transform": {
3597                             "Get": "_sidConversion",
3598                             "Put": "_usernamesToSidObjects",
3599                         },
3600                     },
3601                     "SeSystemProfilePrivilege": {
3602                         "Policy": "Profile system performance",
3603                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3604                         "rights_assignment": True,
3605                         "Settings": None,
3606                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3607                         "Transform": {
3608                             "Get": "_sidConversion",
3609                             "Put": "_usernamesToSidObjects",
3610                         },
3611                     },
3612                     "SeUndockPrivilege": {
3613                         "Policy": "Remove computer from docking station",
3614                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3615                         "rights_assignment": True,
3616                         "Settings": None,
3617                         "LsaRights": {"Option": "SeUndockPrivilege"},
3618                         "Transform": {
3619                             "Get": "_sidConversion",
3620                             "Put": "_usernamesToSidObjects",
3621                         },
3622                     },
3623                     "SeAssignPrimaryTokenPrivilege": {
3624                         "Policy": "Replace a process level token",
3625                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3626                         "rights_assignment": True,
3627                         "Settings": None,
3628                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3629                         "Transform": {
3630                             "Get": "_sidConversion",
3631                             "Put": "_usernamesToSidObjects",
3632                         },
3633                     },
3634                     "SeRestorePrivilege": {
3635                         "Policy": "Restore files and directories",
3636                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3637                         "rights_assignment": True,
3638                         "Settings": None,
3639                         "LsaRights": {"Option": "SeRestorePrivilege"},
3640                         "Transform": {
3641                             "Get": "_sidConversion",
3642                             "Put": "_usernamesToSidObjects",
3643                         },
3644                     },
3645                     "SeShutdownPrivilege": {
3646                         "Policy": "Shut down the system",
3647                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3648                         "rights_assignment": True,
3649                         "Settings": None,
3650                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3651                         "Transform": {
3652                             "Get": "_sidConversion",
3653                             "Put": "_usernamesToSidObjects",
3654                         },
3655                     },
3656                     "SeSyncAgentPrivilege": {
3657                         "Policy": "Synchronize directory service data",
3658                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3659                         "rights_assignment": True,
3660                         "Settings": None,
3661                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3662                         "Transform": {
3663                             "Get": "_sidConversion",
3664                             "Put": "_usernamesToSidObjects",
3665                         },
3666                     },
3667                     "SeTakeOwnershipPrivilege": {
3668                         "Policy": "Take ownership of files or other objects",
3669                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3670                         "rights_assignment": True,
3671                         "Settings": None,
3672                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3673                         "Transform": {
3674                             "Get": "_sidConversion",
3675                             "Put": "_usernamesToSidObjects",
3676                         },
3677                     },
3678                     "RecoveryConsoleSecurityLevel": {
3679                         "Policy": (
3680                             "Recovery console: Allow automatic administrative logon"
3681                         ),
3682                         "Settings": self.enabled_one_disabled_zero.keys(),
3683                         "lgpo_section": self.security_options_gpedit_path,
3684                         "Registry": {
3685                             "Hive": "HKEY_LOCAL_MACHINE",
3686                             "Path": (
3687                                 "Software\\Microsoft\\Windows NT\\"
3688                                 "CurrentVersion\\Setup\\RecoveryConsole"
3689                             ),
3690                             "Value": "SecurityLevel",
3691                             "Type": "REG_DWORD",
3692                         },
3693                         "Transform": self.enabled_one_disabled_zero_transform,
3694                     },
3695                     "RecoveryConsoleSetCommand": {
3696                         "Policy": (
3697                             "Recovery console: Allow floppy copy and "
3698                             "access to all drives and all folders"
3699                         ),
3700                         "Settings": self.enabled_one_disabled_zero.keys(),
3701                         "lgpo_section": self.security_options_gpedit_path,
3702                         "Registry": {
3703                             "Hive": "HKEY_LOCAL_MACHINE",
3704                             "Path": (
3705                                 "Software\\Microsoft\\Windows NT\\"
3706                                 "CurrentVersion\\Setup\\RecoveryConsole"
3707                             ),
3708                             "Value": "SetCommand",
3709                             "Type": "REG_DWORD",
3710                         },
3711                         "Transform": self.enabled_one_disabled_zero_transform,
3712                     },
3713                     "ForceKeyProtection": {
3714                         "Policy": (
3715                             "System Cryptography: Force strong key protection for "
3716                             "user keys stored on the computer"
3717                         ),
3718                         "Settings": self.force_key_protection.keys(),
3719                         "lgpo_section": self.security_options_gpedit_path,
3720                         "Registry": {
3721                             "Hive": "HKEY_LOCAL_MACHINE",
3722                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3723                             "Value": "ForceKeyProtection",
3724                             "Type": "REG_DWORD",
3725                         },
3726                         "Transform": {
3727                             "Get": "_dict_lookup",
3728                             "Put": "_dict_lookup",
3729                             "GetArgs": {
3730                                 "lookup": self.force_key_protection,
3731                                 "value_lookup": False,
3732                             },
3733                             "PutArgs": {
3734                                 "lookup": self.force_key_protection,
3735                                 "value_lookup": True,
3736                             },
3737                         },
3738                     },
3739                     "FIPSAlgorithmPolicy": {
3740                         "Policy": (
3741                             "System Cryptography: Use FIPS compliant algorithms "
3742                             "for encryption, hashing, and signing"
3743                         ),
3744                         "Settings": self.enabled_one_disabled_zero.keys(),
3745                         "lgpo_section": self.security_options_gpedit_path,
3746                         "Registry": {
3747                             "Hive": "HKEY_LOCAL_MACHINE",
3748                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3749                             "Value": "Enabled",
3750                             "Type": "REG_DWORD",
3751                         },
3752                         "Transform": self.enabled_one_disabled_zero_transform,
3753                     },
3754                     "MachineAccessRestriction": {
3755                         "Policy": (
3756                             "DCOM: Machine Access Restrictions in Security Descriptor "
3757                             "Definition Language (SDDL) syntax"
3758                         ),
3759                         "Settings": None,
3760                         "lgpo_section": self.security_options_gpedit_path,
3761                         "Registry": {
3762                             "Hive": "HKEY_LOCAL_MACHINE",
3763                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3764                             "Value": "MachineAccessRestriction",
3765                             "Type": "REG_SZ",
3766                         },
3767                         "Transform": {"Put": "_string_put_transform"},
3768                     },
3769                     "MachineLaunchRestriction": {
3770                         "Policy": (
3771                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3772                             "Definition Language (SDDL) syntax"
3773                         ),
3774                         "Settings": None,
3775                         "lgpo_section": self.security_options_gpedit_path,
3776                         "Registry": {
3777                             "Hive": "HKEY_LOCAL_MACHINE",
3778                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3779                             "Value": "MachineLaunchRestriction",
3780                             "Type": "REG_SZ",
3781                         },
3782                         "Transform": {"Put": "_string_put_transform"},
3783                     },
3784                     "UseMachineId": {
3785                         "Policy": (
3786                             "Network security: Allow Local System to use computer "
3787                             "identity for NTLM"
3788                         ),
3789                         "Settings": self.enabled_one_disabled_zero.keys(),
3790                         "lgpo_section": self.security_options_gpedit_path,
3791                         "Registry": {
3792                             "Hive": "HKEY_LOCAL_MACHINE",
3793                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3794                             "Value": "UseMachineId",
3795                             "Type": "REG_DWORD",
3796                         },
3797                         "Transform": self.enabled_one_disabled_zero_transform,
3798                     },
3799                     "allownullsessionfallback": {
3800                         "Policy": (
3801                             "Network security: Allow LocalSystem NULL session fallback"
3802                         ),
3803                         "Settings": self.enabled_one_disabled_zero.keys(),
3804                         "lgpo_section": self.security_options_gpedit_path,
3805                         "Registry": {
3806                             "Hive": "HKEY_LOCAL_MACHINE",
3807                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3808                             "Value": "allownullsessionfallback",
3809                             "Type": "REG_DWORD",
3810                         },
3811                         "Transform": self.enabled_one_disabled_zero_transform,
3812                     },
3813                     "AllowOnlineID": {
3814                         "Policy": (
3815                             "Network security: Allow PKU2U authentication requests "
3816                             "to this computer to use online identities."
3817                         ),
3818                         "Settings": self.enabled_one_disabled_zero.keys(),
3819                         "lgpo_section": self.security_options_gpedit_path,
3820                         "Registry": {
3821                             "Hive": "HKEY_LOCAL_MACHINE",
3822                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3823                             "Value": "AllowOnlineID",
3824                             "Type": "REG_DWORD",
3825                         },
3826                         "Transform": self.enabled_one_disabled_zero_transform,
3827                     },
3828                     "KrbSupportedEncryptionTypes": {
3829                         "Policy": (
3830                             "Network security: Configure encryption types allowed "
3831                             "for Kerberos"
3832                         ),
3833                         "Settings": None,
3834                         "lgpo_section": self.security_options_gpedit_path,
3835                         "Registry": {
3836                             "Hive": "HKEY_LOCAL_MACHINE",
3837                             "Path": (
3838                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3839                                 "\\system\\Kerberos\\Parameters"
3840                             ),
3841                             "Value": "SupportedEncryptionTypes",
3842                             "Type": "REG_DWORD",
3843                         },
3844                         "Transform": {
3845                             "Get": "_dict_lookup_bitwise_add",
3846                             "Put": "_dict_lookup_bitwise_add",
3847                             "GetArgs": {
3848                                 "lookup": self.krb_encryption_types,
3849                                 "value_lookup": False,
3850                             },
3851                             "PutArgs": {
3852                                 "lookup": self.krb_encryption_types,
3853                                 "value_lookup": True,
3854                             },
3855                         },
3856                     },
3857                     "NoLMHash": {
3858                         "Policy": (
3859                             "Network security: Do not store LAN Manager hash value "
3860                             "on next password change"
3861                         ),
3862                         "Settings": self.enabled_one_disabled_zero.keys(),
3863                         "lgpo_section": self.security_options_gpedit_path,
3864                         "Registry": {
3865                             "Hive": "HKEY_LOCAL_MACHINE",
3866                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3867                             "Value": "NoLMHash",
3868                             "Type": "REG_DWORD",
3869                         },
3870                         "Transform": self.enabled_one_disabled_zero_transform,
3871                     },
3872                     "ForceLogoffWhenHourExpire": {
3873                         "Policy": (
3874                             "Network security: Force logoff when logon hours expire"
3875                         ),
3876                         "lgpo_section": self.security_options_gpedit_path,
3877                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3878                         "Secedit": {
3879                             "Option": "ForceLogoffWhenHourExpire",
3880                             "Section": "System Access",
3881                         },
3882                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3883                     },
3884                     "LmCompatibilityLevel": {
3885                         "Policy": "Network security: LAN Manager authentication level",
3886                         "Settings": self.lm_compat_levels.keys(),
3887                         "lgpo_section": self.security_options_gpedit_path,
3888                         "Registry": {
3889                             "Hive": "HKEY_LOCAL_MACHINE",
3890                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3891                             "Value": "LmCompatibilityLevel",
3892                             "Type": "REG_DWORD",
3893                         },
3894                         "Transform": {
3895                             "Get": "_dict_lookup",
3896                             "Put": "_dict_lookup",
3897                             "GetArgs": {
3898                                 "lookup": self.lm_compat_levels,
3899                                 "value_lookup": False,
3900                             },
3901                             "PutArgs": {
3902                                 "lookup": self.lm_compat_levels,
3903                                 "value_lookup": True,
3904                             },
3905                         },
3906                     },
3907                     "LDAPClientIntegrity": {
3908                         "Policy": "Network security: LDAP client signing requirements",
3909                         "Settings": self.ldap_signing_reqs.keys(),
3910                         "lgpo_section": self.security_options_gpedit_path,
3911                         "Registry": {
3912                             "Hive": "HKEY_LOCAL_MACHINE",
3913                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3914                             "Value": "LDAPClientIntegrity",
3915                             "Type": "REG_DWORD",
3916                         },
3917                         "Transform": {
3918                             "Get": "_dict_lookup",
3919                             "Put": "_dict_lookup",
3920                             "GetArgs": {
3921                                 "lookup": self.ldap_signing_reqs,
3922                                 "value_lookup": False,
3923                             },
3924                             "PutArgs": {
3925                                 "lookup": self.ldap_signing_reqs,
3926                                 "value_lookup": True,
3927                             },
3928                         },
3929                     },
3930                     "NTLMMinClientSec": {
3931                         "Policy": (
3932                             "Network security: Minimum session security for NTLM SSP"
3933                             " based (including secure RPC) clients"
3934                         ),
3935                         "Settings": None,
3936                         "lgpo_section": self.security_options_gpedit_path,
3937                         "Registry": {
3938                             "Hive": "HKEY_LOCAL_MACHINE",
3939                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3940                             "Value": "NTLMMinClientSec",
3941                             "Type": "REG_DWORD",
3942                         },
3943                         "Transform": {
3944                             "Get": "_dict_lookup_bitwise_add",
3945                             "Put": "_dict_lookup_bitwise_add",
3946                             "GetArgs": {
3947                                 "lookup": self.ntlm_session_security_levels,
3948                                 "value_lookup": False,
3949                             },
3950                             "PutArgs": {
3951                                 "lookup": self.ntlm_session_security_levels,
3952                                 "value_lookup": True,
3953                             },
3954                         },
3955                     },
3956                     "NTLMMinServerSec": {
3957                         "Policy": (
3958                             "Network security: Minimum session security for NTLM SSP"
3959                             " based (including secure RPC) servers"
3960                         ),
3961                         "Settings": None,
3962                         "lgpo_section": self.security_options_gpedit_path,
3963                         "Registry": {
3964                             "Hive": "HKEY_LOCAL_MACHINE",
3965                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3966                             "Value": "NTLMMinServerSec",
3967                             "Type": "REG_DWORD",
3968                         },
3969                         "Transform": {
3970                             "Get": "_dict_lookup_bitwise_add",
3971                             "Put": "_dict_lookup_bitwise_add",
3972                             "GetArgs": {
3973                                 "lookup": self.ntlm_session_security_levels,
3974                                 "value_lookup": False,
3975                             },
3976                             "PutArgs": {
3977                                 "lookup": self.ntlm_session_security_levels,
3978                                 "value_lookup": True,
3979                             },
3980                         },
3981                     },
3982                     "ClientAllowedNTLMServers": {
3983                         "Policy": (
3984                             "Network security: Restrict NTLM: Add remote server"
3985                             " exceptions for NTLM authentication"
3986                         ),
3987                         "lgpo_section": self.security_options_gpedit_path,
3988                         "Registry": {
3989                             "Hive": "HKEY_LOCAL_MACHINE",
3990                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3991                             "Value": "ClientAllowedNTLMServers",
3992                             "Type": "REG_MULTI_SZ",
3993                         },
3994                         "Transform": {
3995                             "Put": "_multi_string_put_transform",
3996                             "Get": "_multi_string_get_transform",
3997                         },
3998                     },
3999                     "DCAllowedNTLMServers": {
4000                         "Policy": (
4001                             "Network security: Restrict NTLM: Add server exceptions"
4002                             " in this domain"
4003                         ),
4004                         "lgpo_section": self.security_options_gpedit_path,
4005                         "Registry": {
4006                             "Hive": "HKEY_LOCAL_MACHINE",
4007                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4008                             "Value": "DCAllowedNTLMServers",
4009                             "Type": "REG_MULTI_SZ",
4010                         },
4011                         "Transform": {
4012                             "Put": "_multi_string_put_transform",
4013                             "Get": "_multi_string_get_transform",
4014                         },
4015                     },
4016                     "AuditReceivingNTLMTraffic": {
4017                         "Policy": (
4018                             "Network security: Restrict NTLM: Audit Incoming NTLM"
4019                             " Traffic"
4020                         ),
4021                         "Settings": self.ntlm_audit_settings.keys(),
4022                         "lgpo_section": self.security_options_gpedit_path,
4023                         "Registry": {
4024                             "Hive": "HKEY_LOCAL_MACHINE",
4025                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4026                             "Value": "AuditReceivingNTLMTraffic",
4027                             "Type": "REG_DWORD",
4028                         },
4029                         "Transform": {
4030                             "Get": "_dict_lookup",
4031                             "Put": "_dict_lookup",
4032                             "GetArgs": {
4033                                 "lookup": self.ntlm_audit_settings,
4034                                 "value_lookup": False,
4035                             },
4036                             "PutArgs": {
4037                                 "lookup": self.ntlm_audit_settings,
4038                                 "value_lookup": True,
4039                             },
4040                         },
4041                     },
4042                     "AuditNTLMInDomain": {
4043                         "Policy": (
4044                             "Network security: Restrict NTLM: Audit NTLM "
4045                             "authentication in this domain"
4046                         ),
4047                         "Settings": self.ntlm_domain_audit_settings.keys(),
4048                         "lgpo_section": self.security_options_gpedit_path,
4049                         "Registry": {
4050                             "Hive": "HKEY_LOCAL_MACHINE",
4051                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4052                             "Value": "AuditNTLMInDomain",
4053                             "Type": "REG_DWORD",
4054                         },
4055                         "Transform": {
4056                             "Get": "_dict_lookup",
4057                             "Put": "_dict_lookup",
4058                             "GetArgs": {
4059                                 "lookup": self.ntlm_domain_audit_settings,
4060                                 "value_lookup": False,
4061                             },
4062                             "PutArgs": {
4063                                 "lookup": self.ntlm_domain_audit_settings,
4064                                 "value_lookup": True,
4065                             },
4066                         },
4067                     },
4068                     "RestrictReceivingNTLMTraffic": {
4069                         "Policy": (
4070                             "Network security: Restrict NTLM: Incoming NTLM traffic"
4071                         ),
4072                         "Settings": self.incoming_ntlm_settings.keys(),
4073                         "lgpo_section": self.security_options_gpedit_path,
4074                         "Registry": {
4075                             "Hive": "HKEY_LOCAL_MACHINE",
4076                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4077                             "Value": "RestrictReceivingNTLMTraffic",
4078                             "Type": "REG_DWORD",
4079                         },
4080                         "Transform": {
4081                             "Get": "_dict_lookup",
4082                             "Put": "_dict_lookup",
4083                             "GetArgs": {
4084                                 "lookup": self.incoming_ntlm_settings,
4085                                 "value_lookup": False,
4086                             },
4087                             "PutArgs": {
4088                                 "lookup": self.incoming_ntlm_settings,
4089                                 "value_lookup": True,
4090                             },
4091                         },
4092                     },
4093                     "RestrictNTLMInDomain": {
4094                         "Policy": (
4095                             "Network security: Restrict NTLM: NTLM "
4096                             "authentication in this domain"
4097                         ),
4098                         "Settings": self.ntlm_domain_auth_settings.keys(),
4099                         "lgpo_section": self.security_options_gpedit_path,
4100                         "Registry": {
4101                             "Hive": "HKEY_LOCAL_MACHINE",
4102                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4103                             "Value": "RestrictNTLMInDomain",
4104                             "Type": "REG_DWORD",
4105                         },
4106                         "Transform": {
4107                             "Get": "_dict_lookup",
4108                             "Put": "_dict_lookup",
4109                             "GetArgs": {
4110                                 "lookup": self.ntlm_domain_auth_settings,
4111                                 "value_lookup": False,
4112                             },
4113                             "PutArgs": {
4114                                 "lookup": self.ntlm_domain_auth_settings,
4115                                 "value_lookup": True,
4116                             },
4117                         },
4118                     },
4119                     "RestrictSendingNTLMTraffic": {
4120                         "Policy": (
4121                             "Network security: Restrict NTLM: Outgoing NTLM"
4122                             " traffic to remote servers"
4123                         ),
4124                         "Settings": self.outgoing_ntlm_settings.keys(),
4125                         "lgpo_section": self.security_options_gpedit_path,
4126                         "Registry": {
4127                             "Hive": "HKEY_LOCAL_MACHINE",
4128                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4129                             "Value": "RestrictSendingNTLMTraffic",
4130                             "Type": "REG_DWORD",
4131                         },
4132                         "Transform": {
4133                             "Get": "_dict_lookup",
4134                             "Put": "_dict_lookup",
4135                             "GetArgs": {
4136                                 "lookup": self.outgoing_ntlm_settings,
4137                                 "value_lookup": False,
4138                             },
4139                             "PutArgs": {
4140                                 "lookup": self.outgoing_ntlm_settings,
4141                                 "value_lookup": True,
4142                             },
4143                         },
4144                     },
4145                     "ShutdownWithoutLogon": {
4146                         "Policy": (
4147                             "Shutdown: Allow system to be shut down "
4148                             "without having to log on"
4149                         ),
4150                         "Settings": self.enabled_one_disabled_zero.keys(),
4151                         "lgpo_section": self.security_options_gpedit_path,
4152                         "Registry": {
4153                             "Hive": "HKEY_LOCAL_MACHINE",
4154                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4155                             "Value": "ShutdownWithoutLogon",
4156                             "Type": "REG_DWORD",
4157                         },
4158                         "Transform": self.enabled_one_disabled_zero_transform,
4159                     },
4160                     "ClearPageFileAtShutdown": {
4161                         "Policy": "Shutdown: Clear virtual memory pagefile",
4162                         "Settings": self.enabled_one_disabled_zero.keys(),
4163                         "lgpo_section": self.security_options_gpedit_path,
4164                         "Registry": {
4165                             "Hive": "HKEY_LOCAL_MACHINE",
4166                             "Path": (
4167                                 "System\\CurrentControlSet\\Control\\"
4168                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4169                             ),
4170                             "Value": "ClearPageFileAtShutdown",
4171                             "Type": "REG_DWORD",
4172                         },
4173                         "Transform": self.enabled_one_disabled_zero_transform,
4174                     },
4175                     "ObCaseInsensitive": {
4176                         "Policy": (
4177                             "System objects: Require case insensitivity for "
4178                             "non-Windows subsystems"
4179                         ),
4180                         "Settings": self.enabled_one_disabled_zero.keys(),
4181                         "lgpo_section": self.security_options_gpedit_path,
4182                         "Registry": {
4183                             "Hive": "HKEY_LOCAL_MACHINE",
4184                             "Path": (
4185                                 "System\\CurrentControlSet\\Control\\"
4186                                 "SESSION MANAGER\\Kernel"
4187                             ),
4188                             "Value": "ObCaseInsensitive",
4189                             "Type": "REG_DWORD",
4190                         },
4191                         "Transform": self.enabled_one_disabled_zero_transform,
4192                     },
4193                     "ProtectionMode": {
4194                         "Policy": (
4195                             "System objects: Strengthen default permissions of "
4196                             "internal system objects (e.g. Symbolic Links)"
4197                         ),
4198                         "Settings": self.enabled_one_disabled_zero.keys(),
4199                         "lgpo_section": self.security_options_gpedit_path,
4200                         "Registry": {
4201                             "Hive": "HKEY_LOCAL_MACHINE",
4202                             "Path": (
4203                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4204                             ),
4205                             "Value": "ProtectionMode",
4206                             "Type": "REG_DWORD",
4207                         },
4208                         "Transform": self.enabled_one_disabled_zero_transform,
4209                     },
4210                     "OptionalSubsystems": {
4211                         "Policy": "System settings: Optional subsystems",
4212                         "lgpo_section": self.security_options_gpedit_path,
4213                         "Registry": {
4214                             "Hive": "HKEY_LOCAL_MACHINE",
4215                             "Path": (
4216                                 "System\\CurrentControlSet\\Control\\"
4217                                 "SESSION MANAGER\\SubSystems"
4218                             ),
4219                             "Value": "optional",
4220                             "Type": "REG_MULTI_SZ",
4221                         },
4222                         "Transform": {
4223                             "Put": "_multi_string_put_transform",
4224                             "Get": "_multi_string_get_transform",
4225                         },
4226                     },
4227                     "AuthenticodeEnabled": {
4228                         "Policy": (
4229                             "System settings: Use Certificate Rules on Windows"
4230                             " Executables for Software Restriction Policies"
4231                         ),
4232                         "Settings": self.enabled_one_disabled_zero.keys(),
4233                         "lgpo_section": self.security_options_gpedit_path,
4234                         "Registry": {
4235                             "Hive": "HKEY_LOCAL_MACHINE",
4236                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4237                             "Value": "AuthenticodeEnabled",
4238                             "Type": "REG_DWORD",
4239                         },
4240                         "Transform": self.enabled_one_disabled_zero_transform,
4241                     },
4242                 },
4243             },
4244             "User": {"lgpo_section": "User Configuration", "policies": {}},
4245         }
4246         self.admx_registry_classes = {
4247             "User": {
4248                 "policy_path": os.path.join(
4249                     os.getenv("WINDIR"),
4250                     "System32",
4251                     "GroupPolicy",
4252                     "User",
4253                     "Registry.pol",
4254                 ),
4255                 "hive": "HKEY_USERS",
4256                 "lgpo_section": "User Configuration",
4257                 "gpt_extension_location": "gPCUserExtensionNames",
4258                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4259             },
4260             "Machine": {
4261                 "policy_path": os.path.join(
4262                     os.getenv("WINDIR"),
4263                     "System32",
4264                     "GroupPolicy",
4265                     "Machine",
4266                     "Registry.pol",
4267                 ),
4268                 "hive": "HKEY_LOCAL_MACHINE",
4269                 "lgpo_section": "Computer Configuration",
4270                 "gpt_extension_location": "gPCMachineExtensionNames",
4271                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4272             },
4273         }
4274         self.reg_pol_header = "\u5250\u6765\x01\x00"
4275         self.gpt_ini_path = os.path.join(
4276             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4277         )
4278     @classmethod
4279     def _notEmpty(cls, val, **kwargs):
4280         if val:
4281             return True
4282         else:
4283             return False
4284     @classmethod
4285     def _seconds_to_days(cls, val, **kwargs):
4286         zero_value = kwargs.get("zero_value", 0)
4287         if val is not None:
4288             if val == zero_value:
4289                 return 0
4290             return val / 86400
4291         else:
4292             return "Not Defined"
4293     @classmethod
4294     def _days_to_seconds(cls, val, **kwargs):
4295         zero_value = kwargs.get("zero_value", 0)
4296         if val is not None:
4297             if val == 0:
4298                 return zero_value
4299             return val * 86400
4300         else:
4301             return "Not Defined"
4302     @classmethod
4303     def _seconds_to_minutes(cls, val, **kwargs):
4304         zero_value = kwargs.get("zero_value", 0)
4305         if val is not None:
4306             if val == zero_value:
4307                 return 0
4308             return val / 60
4309         else:
4310             return "Not Defined"
4311     @classmethod
4312     def _minutes_to_seconds(cls, val, **kwargs):
4313         zero_value = kwargs.get("zero_value", 0)
4314         if val is not None:
4315             if val == 0:
4316                 return zero_value
4317             return val * 60
4318         else:
4319             return "Not Defined"
4320     @classmethod
4321     def _strip_quotes(cls, val, **kwargs):
4322         return val.replace('"', "")
4323     @classmethod
4324     def _add_quotes(cls, val, **kwargs):
4325         return '"{}"'.format(val)
4326     @classmethod
4327     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4328         try:
4329             if val is not None:
4330                 if ord(val) == 0:
4331                     return "Disabled"
4332                 elif ord(val) == 1:
4333                     return "Enabled"
4334                 else:
4335                     return "Invalid Value: {!r}".format(val)
4336             else:
4337                 return "Not Defined"
4338         except TypeError:
4339             return "Invalid Value"
4340     @classmethod
4341     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4342         if val is not None:
4343             if val.upper() == "DISABLED":
4344                 return chr(0)
4345             elif val.upper() == "ENABLED":
4346                 return chr(1)
4347             else:
4348                 return None
4349         else:
4350             return None
4351     @classmethod
4352     def _dasd_conversion(cls, val, **kwargs):
4353         if val is not None:
4354             if val == "0" or val == 0 or val == "":
4355                 return "Administrators"
4356             elif val == "1" or val == 1:
4357                 return "Administrators and Power Users"
4358             elif val == "2" or val == 2:
4359                 return "Administrators and Interactive Users"
4360             else:
4361                 return "Not Defined"
4362         else:
4363             return "Not Defined"
4364     @classmethod
4365     def _dasd_reverse_conversion(cls, val, **kwargs):
4366         if val is not None:
4367             if val.upper() == "ADMINISTRATORS":
4368                 return "0"
4369             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4370                 return "1"
4371             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4372                 return "2"
4373             elif val.upper() == "NOT DEFINED":
4374                 return "9999"
4375             else:
4376                 return "Invalid Value"
4377         else:
4378             return "Not Defined"
4379     @classmethod
4380     def _in_range_inclusive(cls, val, **kwargs):
4381         minimum = kwargs.get("min", 0)
4382         maximum = kwargs.get("max", 1)
4383         zero_value = kwargs.get("zero_value", 0)
4384         if isinstance(val, str):
4385             if val.lower() == "not defined":
4386                 return True
4387             else:
4388                 try:
4389                     val = int(val)
4390                 except ValueError:
4391                     return False
4392         if val is not None:
4393             if minimum &lt;= val &lt;= maximum or val == zero_value:
4394                 return True
4395             else:
4396                 return False
4397         else:
4398             return False
4399     @classmethod
4400     def _driver_signing_reg_conversion(cls, val, **kwargs):
4401         log.trace("we have %s for the driver signing value", val)
4402         if val is not None:
4403             _val = val.split(",")
4404             if len(_val) == 2:
4405                 if _val[1] == "0":
4406                     return "Silently Succeed"
4407                 elif _val[1] == "1":
4408                     return "Warn but allow installation"
4409                 elif _val[1] == "2":
4410                     return "Do not allow installation"
4411                 elif _val[1] == "Not Defined":
4412                     return "Not Defined"
4413                 else:
4414                     return "Invalid Value"
4415             else:
4416                 return "Not Defined"
4417         else:
4418             return "Not Defined"
4419     @classmethod
4420     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4421         if val is not None:
4422             if val.upper() == "SILENTLY SUCCEED":
4423                 return ",".join(["3", "0"])
4424             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4425                 return ",".join(["3", chr(1)])
4426             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4427                 return ",".join(["3", chr(2)])
4428             else:
4429                 return "Invalid Value"
4430         else:
4431             return "Not Defined"
4432     @classmethod
4433     def _sidConversion(cls, val, **kwargs):
4434         if isinstance(val, str):
4435             val = val.split(",")
4436         usernames = []
4437         for _sid in val:
4438             try:
4439                 userSid = win32security.LookupAccountSid("", _sid)
4440                 if userSid[1]:
4441                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4442                 else:
4443                     userSid = "{}".format(userSid[0])
4444             except Exception:  # pylint: disable=broad-except
4445                 userSid = win32security.ConvertSidToStringSid(_sid)
4446                 log.warning(
4447                     "Unable to convert SID '%s' to a friendly name. "
4448                     "The SID will be displayed instead of a user/group name.",
4449                     userSid,
4450                 )
4451             usernames.append(userSid)
4452         return usernames
4453     @classmethod
4454     def _usernamesToSidObjects(cls, val, **kwargs):
4455         if not val:
4456             return val
4457         if isinstance(val, str):
4458             val = val.split(",")
4459         sids = []
4460         for _user in val:
4461             try:
4462                 sid = win32security.LookupAccountName("", _user)[0]
4463                 sids.append(sid)
4464             except Exception as e:  # pylint: disable=broad-except
4465                 log.exception("Handle this explicitly")
4466                 raise CommandExecutionError(
4467                     'There was an error obtaining the SID of user "{}". Error '
4468                     "returned: {}".format(_user, e)
4469                 )
4470         return sids
4471     @classmethod
4472     def _powershell_script_order_conversion(cls, val, **kwargs):
4473         log.trace("script order value = %s", val)
4474         if val is None or val == "None":
4475             return "Not Configured"
4476         elif val == "true":
4477             return "Run Windows PowerShell scripts first"
4478         elif val == "false":
4479             return "Run Windows PowerShell scripts last"
4480         else:
4481             return "Invalid Value"
4482     @classmethod
4483     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4484         if val.upper() == "Run Windows PowerShell scripts first".upper():
4485             return "true"
4486         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4487             return "false"
4488         elif val == "Not Configured":
4489             return None
4490         else:
4491             return "Invalid Value"
4492     @classmethod
4493     def _dict_lookup(cls, item, **kwargs):
4494         log.trace("item == %s", item)
4495         value_lookup = kwargs.get("value_lookup", False)
4496         if "lookup" in kwargs:
4497             for k, v in kwargs["lookup"].items():
4498                 if value_lookup:
4499                     if str(v).lower() == str(item).lower():
4500                         log.trace("returning key %s", k)
4501                         return k
4502                 else:
4503                     if str(k).lower() == str(item).lower():
4504                         log.trace("returning value %s", v)
4505                         return v
4506         return "Invalid Value"
4507     @classmethod
4508     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4509         value_lookup = kwargs.get("value_lookup", False)
4510         test_zero = kwargs.get("test_zero", False)
4511         ret_val = None
4512         if str(item).lower() == "not defined":
4513             return None
4514         if value_lookup:
4515             if not isinstance(item, list):
4516                 return "Invalid Value"
4517             ret_val = 0
4518         else:
4519             if not isinstance(item, int):
4520                 return "Invalid Value"
4521             ret_val = []
4522         if "lookup" in kwargs:
4523             for k, v in kwargs["lookup"].items():
4524                 if value_lookup:
4525                     if str(v).lower() in [z.lower() for z in item]:
4526                         ret_val = ret_val + k
4527                 else:
4528                     do_test = True
4529                     if not test_zero:
4530                         if k == 0:
4531                             do_test = False
4532                     if do_test and isinstance(k, int) and item &amp; k == k:
4533                         ret_val.append(v)
4534         else:
4535             return "Invalid Value"
4536         return ret_val
4537     @classmethod
4538     def _multi_string_put_transform(cls, item, **kwargs):
4539         if isinstance(item, list):
4540             return item
4541         elif isinstance(item, str):
4542             if item.lower() == "not defined":
4543                 return None
4544             else:
4545                 return item.split(",")
4546         else:
4547             return "Invalid Value"
4548     @classmethod
4549     def _multi_string_get_transform(cls, item, **kwargs):
4550         if isinstance(item, list):
4551             return item
4552         elif item is None:
4553             return "Not Defined"
4554         else:
4555             return "Invalid Value"
4556     @classmethod
4557     def _string_put_transform(cls, item, **kwargs):
4558         if isinstance(item, str):
4559             if item.lower() == "not defined":
4560                 return None
4561             else:
4562                 return item
4563 def __virtual__():
4564     if not salt.utils.platform.is_windows():
4565         return False, "win_lgpo: Not a Windows System"
4566     if not HAS_WINDOWS_MODULES:
4567         return False, "win_lgpo: Required modules failed to load"
4568     return __virtualname__
4569 def _updateNamespace(item, new_namespace):
4570     temp_item = ""
4571     i = item.tag.find("}")
4572     if i &gt;= 0:
4573         temp_item = item.tag[i + 1 :]
4574     else:
4575         temp_item = item.tag
4576     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4577     for child in item.getiterator():
4578         if isinstance(child.tag, str):
4579             temp_item = ""
4580             i = child.tag.find("}")
4581             if i &gt;= 0:
4582                 temp_item = child.tag[i + 1 :]
4583             else:
4584                 temp_item = child.tag
4585             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4586     return item
4587 def _updatePolicyElements(policy_item, regkey):
4588     for child in policy_item.getiterator():
4589         if "valueName" in child.attrib:
4590             if "key" not in child.attrib:
4591                 child.attrib["key"] = regkey
4592     return policy_item
4593 def _remove_unicode_encoding(xml_file):
4594     <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(xml_file, "rb") as f:
4595         xml_content = f.read()
4596     modified_xml = re.sub(
4597         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.</b></font>decode("utf-16"), count=1
4598     )
4599     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4600     return xml_tree
4601 def _remove_invalid_xmlns(xml_file):
4602     with salt.utils.files.fopen(xml_file, "rb") as f:
4603         xml_content = f.read()
4604     modified_xml = re.sub(
4605         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4606     )
4607     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4608     return xml_tree
4609 def _parse_xml(adm_file):
4610     parser = lxml.etree.XMLParser(remove_comments=True)
4611     modified_xml = ""
4612     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4613         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4614     name, ext = os.path.splitext(os.path.basename(adm_file))
4615     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4616     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4617     if not os.path.exists(cache_dir):
4618         os.makedirs(cache_dir)
4619     out_file = os.path.join(cache_dir, hashed_filename)
4620     if not os.path.isfile(out_file):
4621         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4622         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4623         for file_path in file_list:
4624             os.remove(file_path)
4625         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4626             encoding = "utf-8"
4627             raw = rfh.read()
4628             try:
4629                 raw = raw.decode(encoding)
4630             except UnicodeDecodeError:
4631                 log.trace("LGPO: Detecting encoding")
4632                 encoding = "utf-16"
4633                 raw = raw.decode(encoding)
4634             for line in raw.split("\r\n"):
4635                 if 'key="' in line:
4636                     start = line.index('key="')
4637                     q1 = line[start:].index('"') + start
4638                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4639                     line = line.replace(line[start:q2], line[start:q2].lower())
4640                     found_key = True
4641 <a name="30"></a>                modified_xml += line + "\r\n"
4642         modified_xml = modified_xml.replace("\u201c", '"')<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.replace("\u201d", '"')
4643         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4644         modified_xml = modified_xml.replace("\u2013", "-").replace(</b></font>"\u2014", "-")
4645         with salt.utils.files.fopen(out_file, "wb") as wfh:
4646             wfh.write(modified_xml.encode(encoding))
4647     try:
4648         xml_tree = lxml.etree.parse(out_file, parser=parser)
4649     except lxml.etree.XMLSyntaxError:
4650         try:
4651             xml_tree = _remove_unicode_encoding(out_file)
4652         except lxml.etree.XMLSyntaxError:
4653             xml_tree = _remove_invalid_xmlns(out_file)
4654     return xml_tree
4655 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4656     t_policy_definitions = lxml<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.etree.Element("policyDefinitions")
4657     t_policy_definitions.append(lxml.etree.Element("categories"))
4658     t_policy_definitions.append(lxml.etree.Element("policies"))
4659     t_policy_definitions.append(lxml.etree.Element(</b></font>"policyNamespaces"))
4660     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4661     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4662     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4663     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4664     policydefs_resources_localname_xpath = etree.XPath(
4665         '//*[local-name() = "policyDefinitionResources"]/*'
4666     )
4667     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4668     for root, dirs, files in salt.utils.path.os_walk(path):
4669         if root == path:
4670             for t_admx_file in files:
4671                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4672                 if not admx_file_ext == ".admx":
4673                     log.debug("%s is not an ADMX file", t_admx_file)
4674                     continue
4675                 admx_file = os.path.join(root, t_admx_file)
4676                 try:
4677                     xml_tree = _parse_xml(admx_file)
4678                 except lxml.etree.XMLSyntaxError:
4679                     log.error(
4680                         "An error was found while processing admx "
4681                         "file %s, all policies from this file will "
4682                         "be unavailable via this module",
4683                         admx_file,
4684                     )
4685                     continue
4686                 namespaces = xml_tree.getroot().nsmap
4687                 namespace_string = ""
4688                 if None in namespaces:
4689                     namespaces["None"] = namespaces[None]
4690                     namespaces.pop(None)
4691                     namespace_string = "None:"
4692                 this_namespace = xml_tree.xpath(
4693                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4694                         namespace_string
4695                     ),
4696                     namespaces=namespaces,
4697                 )[0]
4698                 categories = xml_tree.xpath(
4699                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4700                         namespace_string
4701                     ),
4702                     namespaces=namespaces,
4703                 )
4704                 for category in categories:
4705                     temp_cat = category
4706                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4707                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4708                         temp_cat
4709                     )
4710                 policies = xml_tree.xpath(
4711                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4712                         namespace_string
4713                     ),
4714                     namespaces=namespaces,
4715                 )
4716                 for policy in policies:
4717                     temp_pol = policy
4718                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4719                     if "key" in temp_pol.attrib:
4720                         temp_pol = _updatePolicyElements(
4721                             temp_pol, temp_pol.attrib["key"]
4722                         )
4723                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4724                 policy_namespaces = xml_tree.xpath(
4725                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4726                         namespace_string
4727                     ),
4728                     namespaces=namespaces,
4729                 )
4730                 for policy_ns in policy_namespaces:
4731                     temp_ns = policy_ns
4732                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4733                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4734                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4735                 if not __salt__["file.file_exists"](adml_file):
4736                     log.info(
4737                         "An ADML file in the specified ADML language "
4738                         '"%s" does not exist for the ADMX "%s", the '
4739                         "the abbreviated language code will be tried.",
4740                         language,
4741                         t_admx_file,
4742                     )
4743                     adml_file = os.path.join(
4744                         root, language.split("-")[0], admx_file_name + ".adml"
4745                     )
4746                     if not __salt__["file.file_exists"](adml_file):
4747                         log.info(
4748                             "An ADML file in the specified ADML language "
4749                             'code %s does not exist for the ADMX "%s", '
4750                             "the fallback language will be tried.",
4751                             language[:2],
4752                             t_admx_file,
4753                         )
4754                         adml_file = os.path.join(
4755                             root, display_language_fallback, admx_file_name + ".adml"
4756                         )
4757                         if not __salt__["file.file_exists"](adml_file):
4758                             log.info(
4759                                 "An ADML file in the specified ADML "
4760                                 'fallback language "%s" '
4761                                 'does not exist for the ADMX "%s" '
4762                                 "the abbreviated fallback language code "
4763                                 "will be tried.",
4764                                 display_language_fallback,
4765                                 t_admx_file,
4766                             )
4767                             adml_file = os.path.join(
4768                                 root,
4769                                 display_language_fallback.split("-")[0],
4770                                 admx_file_name + ".adml",
4771                             )
4772                             if not __salt__["file.file_exists"](adml_file):
4773                                 raise SaltInvocationError(
4774                                     "An ADML file in the specified ADML language "
4775                                     '"{}" and the fallback language "{}" do not '
4776                                     'exist for the ADMX "{}".'.format(
4777                                         language, display_language_fallback, t_admx_file
4778                                     )
4779                                 )
4780                 try:
4781                     xml_tree = _parse_xml(adml_file)
4782                 except lxml.etree.XMLSyntaxError:
4783                     log.error(
4784                         "An error was found while processing adml "
4785                         "file %s, all policies from this file will "
4786                         "be unavailable via this module",
4787                         adml_file,
4788                     )
4789                     continue
4790                 if None in namespaces:
4791                     namespaces["None"] = namespaces[None]
4792                     namespaces.pop(None)
4793                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4794                 for policydefs_resource in policydefs_resources:
4795                     t_poldef = policydefs_resource
4796                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4797                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4798                         t_poldef
4799                     )
4800     __context__["lgpo.policy_definitions"] = t_policy_definitions
4801     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4802 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4803     if "lgpo.policy_definitions" not in __context__:
4804         log.debug("LGPO: Loading policy definitions")
4805         _load_policy_definitions(path=path, language=language)
4806     return __context__["lgpo.policy_definitions"]
4807 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4808     if "lgpo.policy_resources" not in __context__:
4809         log.debug("LGPO: Loading policy resources")
4810         _load_policy_definitions(path=path, language=language)
4811     return __context__["lgpo.policy_resources"]
4812 def _buildElementNsmap(using_elements):
4813     thisMap = {}
4814     for e in using_elements:
4815         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4816     return thisMap
4817 def _get_advaudit_defaults(option=None):
4818     if "lgpo.audit_defaults" not in __context__:
4819         log.debug("Loading auditpol defaults into __context__")
4820         dump = __utils__["auditpol.get_auditpol_dump"]()
4821         reader = csv.DictReader(dump)
4822         audit_defaults = {"fieldnames": reader.fieldnames}
4823         for row in reader:
4824             row["Machine Name"] = ""
4825             row["Auditpol Name"] = row["Subcategory"]
4826             if row["Subcategory"] == "Central Policy Staging":
4827                 row["Subcategory"] = "Audit Central Access Policy Staging"
4828             elif row["Subcategory"] == "Plug and Play Events":
4829                 row["Subcategory"] = "Audit PNP Activity"
4830             elif row["Subcategory"] == "Token Right Adjusted Events":
4831                 row["Subcategory"] = "Audit Token Right Adjusted"
4832             else:
4833                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
4834             audit_defaults[row["Subcategory"]] = row
4835         __context__["lgpo.audit_defaults"] = audit_defaults
4836     if option:
4837         return __context__["lgpo.audit_defaults"][option]
4838     else:
4839         return __context__["lgpo.audit_defaults"]
4840 def _advaudit_check_csv():
4841     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4842     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4843     f_audit_gpo = os.path.join(
4844         system_root,
4845         "System32",
4846         "GroupPolicy",
4847         "Machine",
4848         "Microsoft",
4849         "Windows NT",
4850         "Audit",
4851         "audit.csv",
4852     )
4853     if not __salt__["file.file_exists"](f_audit):
4854         if __salt__["file.file_exists"](f_audit_gpo):
4855             __salt__["file.copy"](f_audit_gpo, f_audit)
4856         else:
4857             field_names = _get_advaudit_defaults("fieldnames")
4858             __salt__["file.makedirs"](f_audit)
4859             __salt__["file.write"](f_audit, ",".join(field_names))
4860 def _get_advaudit_value(option, refresh=False):
4861     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
4862         system_root = os.environ.get("SystemRoot", "C:\\Windows")
4863         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4864         _advaudit_check_csv()
4865         audit_settings = {}
4866         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4867             reader = csv.DictReader(csv_file)
4868             for row in reader:
4869                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
4870         __context__["lgpo.adv_audit_data"] = audit_settings
4871     return __context__["lgpo.adv_audit_data"].get(option, None)
4872 def _set_advaudit_file_data(option, value):
4873     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4874     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4875     f_audit_gpo = os.path.join(
4876         system_root,
4877         "System32",
4878         "GroupPolicy",
4879         "Machine",
4880         "Microsoft",
4881         "Windows NT",
4882         "Audit",
4883         "audit.csv",
4884     )
4885     f_temp = tempfile.NamedTemporaryFile(
4886         mode="w", delete=False, suffix=".csv", prefix="audit"
4887     )
4888     auditpol_values = {
4889         "None": "No Auditing",
4890         "0": "No Auditing",
4891         "1": "Success",
4892         "2": "Failure",
4893         "3": "Success and Failure",
4894     }
4895     _advaudit_check_csv()
4896     try:
4897         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4898             reader = csv.DictReader(csv_file)
4899             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
4900                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
4901                 writer.writeheader()
4902                 value_written = False
4903                 for row in reader:
4904                     if row["Subcategory"] == option:
4905                         if not value == "None":
4906                             row["Inclusion Setting"] = auditpol_values[value]
4907                             row["Setting Value"] = value
4908                             log.trace("LGPO: Setting %s to %s", option, value)
4909                             writer.writerow(row)
4910                         else:
4911                             log.trace("LGPO: Removing %s", option)
4912                         value_written = True
4913                     else:
4914                         writer.writerow(row)
4915                 if not value_written:
4916                     if not value == "None":
4917                         log.trace("LGPO: Setting %s to %s", option, value)
4918                         defaults = _get_advaudit_defaults(option)
4919                         writer.writerow(
4920                             {
4921                                 "Machine Name": defaults["Machine Name"],
4922                                 "Policy Target": defaults["Policy Target"],
4923                                 "Subcategory": defaults["Subcategory"],
4924                                 "Subcategory GUID": defaults["Subcategory GUID"],
4925                                 "Inclusion Setting": auditpol_values[value],
4926                                 "Exclusion Setting": defaults["Exclusion Setting"],
4927                                 "Setting Value": value,
4928                             }
4929                         )
4930                     value_written = True
4931         if value_written:
4932             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
4933             __salt__["file.makedirs"](f_audit_gpo)
4934             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
4935     finally:
4936         f_temp.close()
4937         __salt__["file.remove"](f_temp.name)
4938     return value_written
4939 def _set_advaudit_pol_data(option, value):
4940     auditpol_values = {
4941         "None": "No Auditing",
4942         "0": "No Auditing",
4943         "1": "Success",
4944         "2": "Failure",
4945         "3": "Success and Failure",
4946     }
4947     defaults = _get_advaudit_defaults(option)
4948     return __utils__["auditpol.set_setting"](
4949         name=defaults["Auditpol Name"], value=auditpol_values[value]
4950     )
4951 def _set_advaudit_value(option, value):
4952     if not _set_advaudit_file_data(option=option, value=value):
4953         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
4954     if not _set_advaudit_pol_data(option=option, value=value):
4955         log.error(
4956             "Failed to apply audit setting: %s\n"
4957             "Policy will take effect on next GPO update",
4958             option,
4959         )
4960     if "lgpo.adv_audit_data" not in __context__:
4961         _get_advaudit_value(option)
4962     if value is None:
4963         log.debug("LGPO: Removing Advanced Audit data: %s", option)
4964         __context__["lgpo.adv_audit_data"].pop(option)
4965     else:
4966         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
4967         __context__["lgpo.adv_audit_data"][option] = value
4968     return True
4969 def _get_netsh_value(profile, option):
4970     if "lgpo.netsh_data" not in __context__:
4971         __context__["lgpo.netsh_data"] = {}
4972     if profile not in __context__["lgpo.netsh_data"]:
4973         log.debug("LGPO: Loading netsh data for %s profile", profile)
4974         settings = salt.utils.win_lgpo_netsh.get_all_settings(
4975             profile=profile, store="lgpo"
4976         )
4977         __context__["lgpo.netsh_data"].update({profile: settings})
4978     log.trace(
4979         "LGPO: netsh returning value: %s",
4980         __context__["lgpo.netsh_data"][profile][option],
4981     )
4982     return __context__["lgpo.netsh_data"][profile][option]
4983 def _set_netsh_value(profile, section, option, value):
4984     if section not in ("firewallpolicy", "settings", "logging", "state"):
4985         raise ValueError("LGPO: Invalid section: {}".format(section))
4986     log.trace(
4987         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
4988         profile,
4989         section,
4990         option,
4991         value,
4992     )
4993     if section == "firewallpolicy":
4994         salt.utils.win_lgpo_netsh.set_firewall_settings(
4995             profile=profile,
4996             inbound=value if option == "Inbound" else None,
4997             outbound=value if option == "Outbound" else None,
4998             store="lgpo",
4999         )
5000     if section == "settings":
5001         salt.utils.win_lgpo_netsh.set_settings(
5002             profile=profile, setting=option, value=value, store="lgpo"
5003         )
5004     if section == "state":
5005         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
5006     if section == "logging":
5007         if option in ("FileName", "MaxFileSize"):
5008             if value == "Not configured":
5009                 value = "notconfigured"
5010         if option.startswith("Log"):
5011             option = option[3:]
5012         salt.utils.win_lgpo_netsh.set_logging_settings(
5013             profile=profile, setting=option, value=value, store="lgpo"
5014         )
5015     log.trace("LGPO: Clearing netsh data for %s profile", profile)
5016     __context__["lgpo.netsh_data"].pop(profile)
5017     return True
5018 def _load_secedit_data():
5019     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
5020     try:
5021         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
5022         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
5023             secedit_data = fp.readlines()
5024         return secedit_data
5025     finally:
5026         if __salt__["file.file_exists"](f_exp):
5027             __salt__["file.remove"](f_exp)
5028 def _get_secedit_data(refresh=False):
5029     if "lgpo.secedit_data" not in __context__ or refresh is True:
5030         log.debug("LGPO: Loading secedit data")
5031         __context__["lgpo.secedit_data"] = _load_secedit_data()
5032     return __context__["lgpo.secedit_data"]
5033 def _get_secedit_value(option):
5034     secedit_data = _get_secedit_data()
5035     for _line in secedit_data:
5036         if _line.startswith(option):
5037             return _line.split("=")[1].strip()
5038     return "Not Defined"
5039 def _write_secedit_data(inf_data):
5040     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
5041     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
5042     try:
5043         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
5044             fp.write(inf_data)
5045         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
5046         retcode = __salt__["cmd.retcode"](cmd)
5047         if not retcode == 0:
5048             log.debug("Secedit failed to import template data")
5049             return False
5050         cmd = ["secedit", "/configure", "/db", f_sdb]
5051         retcode = __salt__["cmd.retcode"](cmd)
5052         if not retcode == 0:
5053             log.debug("Secedit failed to apply security database")
5054             return False
5055         __context__.pop("lgpo.secedit_data", None)
5056         return True
5057     finally:
5058         if __salt__["file.file_exists"](f_inf):
5059             __salt__["file.remove"](f_inf)
5060 def _transform_value(value, policy, transform_type):
5061     t_kwargs = {}
5062     if "Transform" in policy:
5063         if transform_type in policy["Transform"]:
5064             _policydata = _policy_info()
5065             if transform_type + "Args" in policy["Transform"]:
5066                 t_kwargs = policy["Transform"][transform_type + "Args"]
5067             return getattr(_policydata, policy["Transform"][transform_type])(
5068                 value, **t_kwargs
5069             )
5070         else:
5071             return value
5072     else:
5073         if "Registry" in policy:
5074             if value == "(value not set)":
5075                 return "Not Defined"
5076         return value
5077 def _validateSetting(value, policy):
5078     log.debug("validating %s for policy %s", value, policy)
5079     if "Settings" in policy:
5080         if policy["Settings"]:
5081             if isinstance(policy["Settings"], list):
5082                 if value not in policy["Settings"]:
5083                     return False
5084             elif isinstance(policy["Settings"], dict):
5085                 _policydata = _policy_info()
5086                 if not getattr(_policydata, policy["Settings"]["Function"])(
5087                     value, **policy["Settings"]["Args"]
5088                 ):
5089                     return False
5090     else:
5091         return True
5092     return True
5093 def _addAccountRights(sidObject, user_right):
5094     try:
5095         if sidObject:
5096             _polHandle = win32security.LsaOpenPolicy(
5097                 None, win32security.POLICY_ALL_ACCESS
5098             )
5099             user_rights_list = [user_right]
5100             _ret = win32security.LsaAddAccountRights(
5101                 _polHandle, sidObject, user_rights_list
5102             )
5103         return True
5104     except Exception as e:  # pylint: disable=broad-except
5105         log.exception("Error attempting to add account right, exception was %s", e)
5106         return False
5107 def _delAccountRights(sidObject, user_right):
5108     try:
5109         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5110         user_rights_list = [user_right]
5111         _ret = win32security.LsaRemoveAccountRights(
5112             _polHandle, sidObject, False, user_rights_list
5113         )
5114         return True
5115     except Exception as e:  # pylint: disable=broad-except
5116         log.exception("Error attempting to delete account right")
5117         return False
5118 def _getRightsAssignments(user_right):
5119     sids = []
5120     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5121     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5122     return sids
5123 def _getAdmlDisplayName(adml_xml_data, display_name):
5124     if display_name<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.startswith("$(") and display_name.endswith(")"):
5125         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5126         display_name = display_name.split(".")
5127         displayname_type = display_name[</b></font>0]
5128         displayname_id = display_name[1]
5129         search_results = ADML_DISPLAY_NAME_XPATH(
5130             adml_xml_data,
5131             displayNameType=displayname_type,
5132             displayNameId=displayname_id,
5133         )
5134         if search_results:
5135             for result in search_results:
5136                 return result.text.strip()
5137     return None
5138 def _getAdmlPresentationRefId(adml_data, ref_id):
5139     search_results = adml_data.xpath(
5140         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5141     )
5142     alternate_label = ""
5143     if search_results:
5144         for result in search_results:
5145             the_localname = etree.QName(result.tag).localname
5146             if result.text is None:
5147                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5148                 if presentation_element:
5149                     presentation_element = presentation_element[0]
5150                     if TEXT_ELEMENT_XPATH(presentation_element):
5151                         for p_item in presentation_element:
5152                             if p_item == result:
5153                                 break
5154                             if etree.QName(p_item.tag).localname == "text":
5155                                 if getattr(p_item, "text"):
5156                                     alternate_label = getattr(p_item, "text").rstrip()
5157                         if alternate_label.endswith("."):
5158                             alternate_label = ""
5159             if the_localname in ["textBox", "comboBox"]:
5160                 label_items = result.xpath('.//*[local-name() = "label"]')
5161                 for label_item in label_items:
5162                     if label_item.text:
5163                         return label_item.text.rstrip().rstrip(":")
5164             elif the_localname in [
5165                 "decimalTextBox",
5166                 "longDecimalTextBox",
5167                 "dropdownList",
5168                 "listBox",
5169                 "checkBox",
5170                 "text",
5171                 "multiTextBox",
5172             ]:
5173                 if result.text:
5174                     return result.text.rstrip().rstrip(":")
5175                 else:
5176                     return alternate_label.rstrip(":")
5177     return None
5178 def _getFullPolicyName(
5179     policy_item, policy_name, return_full_policy_names, adml_language
5180 ):
5181     if policy_name in adm_policy_name_map[return_full_policy_names]:
5182         return adm_policy_name_map[return_full_policy_names][policy_name]
5183     adml_data = _get_policy_resources(language=adml_language)
5184     if return_full_policy_names and "displayName" in policy_item.attrib:
5185         fullPolicyName = _getAdmlDisplayName(
5186             adml_data, policy_item.attrib["displayName"]
5187         )
5188         if fullPolicyName:
5189             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5190             policy_name = fullPolicyName
5191     elif return_full_policy_names and "id" in policy_item.attrib:
5192         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5193         if fullPolicyName:
5194             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5195             policy_name = fullPolicyName
5196     policy_name = policy_name.rstrip(":").rstrip()
5197     return policy_name
5198 def _regexSearchRegPolData(search_string, policy_data):
5199     if policy_data:
5200         if search_string:
5201             match = re.search(search_string, policy_data, re.IGNORECASE)
5202             if match:
5203                 return True
5204     return False
5205 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5206     value = None
5207     values = []
5208     encoded_semicolon = ";".encode("utf-16-le")
5209     if return_value_name:
5210         values = {}
5211     if search_string:
5212         registry = Registry()
5213         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5214             vtype = registry.vtype_reverse[
5215                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5216             ]
5217         else:
5218             vtype = None
5219         search_string = re.escape(search_string)
5220         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5221 <a name="16"></a>        matches = [m for m in matches]
5222         if matches:
5223             for match in matches:
5224                 pol_entry <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= policy_data[
5225                     match.start() : (
5226                         policy_data.index("]".encode("utf-16-le"), match.end())
5227                     )
5228                 ].split(</b></font>encoded_semicolon, 4)
5229                 if len(pol_entry) &gt;= 2:
5230                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5231                 if len(pol_entry) &gt;= 5:
5232                     value = encoded_semicolon.join(pol_entry[4:])
5233                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5234                         if value:
5235                             if vtype == "REG_DWORD":
5236                                 for v in struct.unpack(b"I", value):
5237                                     value = v
5238                             elif vtype == "REG_QWORD":
5239                                 for v in struct.unpack(b"Q", value):
5240                                     value = v
5241                         else:
5242                             value = 0
5243                     elif vtype == "REG_MULTI_SZ":
5244                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5245                     else:
5246                         value = value.decode("utf-16-le").rstrip(chr(0))
5247                 if return_value_name:
5248                     log.trace("we want value names and the value")
5249                     values[valueName] = value
5250                 elif len(matches) &gt; 1:
5251                     log.trace("we have multiple matches, we will return a list")
5252                     values.append(value)
5253     if values:
5254         value = values
5255     return value
5256 def _checkListItem(
5257     policy_element,
5258     policy_name,
5259     policy_key,
5260     xpath_object,
5261     policy_file_data,
5262     test_items=True,
5263 ):
5264     xpath_string = (
5265         './/*[local-name() = "decimal" or local-name() = "delete"'
5266         ' or local-name() = "longDecimal" or local-name() = "string"]'
5267     )
5268     value_item_child_xpath = etree.XPath(xpath_string)
5269     expected_strings = []
5270     for list_element in xpath_object(policy_element):
5271         configured_items = 0
5272         required_items = 0
5273         for item in list_element:
5274             required_items = required_items + 1
5275             if "key" in item.attrib:
5276                 item_key = item.attrib["key"]
5277             else:
5278                 item_key = policy_key
5279             if "valueName" in item.attrib:
5280                 item_valuename = item.attrib["valueName"]
5281             else:
5282                 log.error(
5283                     "%s item with attributes %s in policy %s does not "
5284                     'have the required "valueName" attribute',
5285                     etree.QName(list_element).localname,
5286                     item.attrib,
5287                     policy_element.attrib,
5288                 )
5289                 break
5290             for value_item in value_item_child_xpath(item):
5291                 search_string = _processValueItem(
5292                     value_item, item_key, item_valuename, policy_element, item
5293                 )
5294                 if test_items:
5295                     if _regexSearchRegPolData(
5296                         re.escape(search_string), policy_file_data
5297                     ):
5298                         configured_items = configured_items + 1
5299                         log.trace(
5300                             "found the search string in the pol file,"
5301                             "%s of %s items for policy %s are "
5302                             "configured in registry.pol",
5303                             configured_items,
5304                             required_items,
5305                             policy_name,
5306                         )
5307                 else:
5308                     expected_strings.append(search_string)
5309         if test_items:
5310             if required_items &gt; 0 and required_items == configured_items:
5311                 log.trace("%s all items are set", policy_name)
5312                 return True
5313     if test_items:
5314         return False
5315     else:
5316         return expected_strings
5317 def _checkValueItemParent(
5318     policy_element,
5319     policy_name,
5320     policy_key,
5321     policy_valueName,
5322     xpath_object,
5323     policy_file_data,
5324     check_deleted=False,
5325     test_item=True,
5326 ):
5327     for element in xpath_object(policy_element):
5328         for value_item in element:
5329             search_string = _processValueItem(
5330                 value_item,
5331                 policy_key,
5332                 policy_valueName,
5333                 policy_element,
5334                 element,
5335                 check_deleted=check_deleted,
5336             )
5337             if not test_item:
5338                 return search_string
5339             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5340                 log.trace(
5341                     "found the search string in the pol file, %s is configured",
5342                     policy_name,
5343                 )
5344                 return True
5345     return False
5346 def _encode_string(value):
5347     encoded_null = chr(0).encode("utf-16-le")
5348     if value is None:
5349         return encoded_null
5350     elif not isinstance(value, str):
5351         raise TypeError(
5352             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5353         )
5354     return b"".join([value.encode("utf-16-le"), encoded_null])
5355 def _buildKnownDataSearchString(
5356     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5357 ):
5358     registry = Registry()
5359     this_element_value = None
5360     expected_string = b""
5361     encoded_semicolon = ";".encode("utf-16-le")
5362     encoded_null = chr(0).encode("utf-16-le")
5363     if reg_key:
5364         reg_key = reg_key.encode("utf-16-le")
5365     if reg_valueName:
5366         reg_valueName = reg_valueName.encode("utf-16-le")
5367     if reg_data and not check_deleted:
5368         if reg_vtype == "REG_DWORD":
5369             this_element_value = struct.pack(b"I", int(reg_data))
5370         elif reg_vtype == "REG_QWORD":
5371             this_element_value = struct.pack(b"Q", int(reg_data))
5372         elif reg_vtype == "REG_SZ":
5373             this_element_value = _encode_string(reg_data)
5374     if check_deleted:
5375         reg_vtype = "REG_SZ"
5376         expected_string = b"".join(
5377             [
5378                 "[".encode("utf-16-le"),
5379                 reg_key,
5380                 encoded_null,
5381                 encoded_semicolon,
5382                 "**del.".encode("utf-16-le"),
5383 <a name="28"></a>                reg_valueName,
5384                 encoded_null,
5385                 encoded_semicolon,
5386                 chr(registry.vtype[reg_vtype]).encode<font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("utf-32-le"),
5387                 encoded_semicolon,
5388                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
5389                 encoded_semicolon,
5390                 " ".encode(</b></font>"utf-16-le"),
5391                 encoded_null,
5392                 "]".encode("utf-16-le"),
5393             ]
5394         )
5395     else:
5396         expected_string = b"".join(
5397             [
5398                 "[".encode("utf-16-le"),
5399                 reg_key,
5400                 encoded_null,
5401                 encoded_semicolon,
5402                 reg_valueName,
5403                 encoded_null,
5404                 encoded_semicolon,
5405                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5406                 encoded_semicolon,
5407                 chr(len(this_element_value)).encode("utf-32-le"),
5408                 encoded_semicolon,
5409                 this_element_value,
5410                 "]".encode("utf-16-le"),
5411             ]
5412         )
5413     return expected_string
5414 def _processValueItem(
5415     element,
5416     reg_key,
5417     reg_valuename,
5418     policy,
5419     parent_element,
5420     check_deleted=False,
5421     this_element_value=None,
5422 ):
5423     registry = Registry()
5424     expected_string = None
5425     this_vtype = "REG_SZ"
5426     encoded_semicolon = ";".encode("utf-16-le")
5427     encoded_null = chr(0).encode("utf-16-le")
5428     if reg_key:
5429         reg_key = reg_key.encode("utf-16-le")
5430     if reg_valuename:
5431         reg_valuename = reg_valuename.encode("utf-16-le")
5432     if (
5433         etree.QName(element).localname == "decimal"
5434         and etree.QName(parent_element).localname != "elements"
5435     ):
5436         this_vtype = "REG_DWORD"
5437         if "value" in element.attrib:
5438             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5439         else:
5440             log.error(
5441                 "The %s child %s element for the policy with "
5442                 'attributes: %s does not have the required "value" '
5443                 "attribute. The element attributes are: %s",
5444                 etree.QName(parent_element).localname,
5445                 etree.QName(element).localname,
5446                 policy.attrib,
5447                 element.attrib,
5448             )
5449             return None
5450     elif (
5451         etree.QName(element).localname == "longDecimal"
5452         and etree.QName(parent_element).localname != "elements"
5453     ):
5454         this_vtype = "REG_QWORD"
5455         if "value" in element.attrib:
5456             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5457         else:
5458             log.error(
5459                 "The %s child %s element for the policy with "
5460                 'attributes: %s does not have the required "value" '
5461                 "attribute. The element attributes are: %s",
5462                 etree.QName(parent_element).localname,
5463                 etree.QName(element).localname,
5464                 policy.attrib,
5465                 element.attrib,
5466             )
5467             return None
5468     elif etree.QName(element).localname == "string":
5469         this_vtype = "REG_SZ"
5470         this_element_value = _encode_string(element.text)
5471     elif etree.QName(parent_element).localname == "elements":
5472         standard_element_expected_string = True
5473         if etree.QName(element).localname == "boolean":
5474             if this_element_value is False:
5475                 check_deleted = True
5476             if not check_deleted:
5477                 this_vtype = "REG_DWORD"
5478             this_element_value = struct.pack("I", 1)
5479             standard_element_expected_string = False
5480         elif etree.QName(element).localname == "decimal":
5481             this_vtype = "REG_DWORD"
5482             requested_val = this_element_value
5483             if this_element_value is not None:
5484                 this_element_value = struct.pack(b"I", int(this_element_value))
5485             if "storeAsText" in element.attrib:
5486                 if element.attrib["storeAsText"].lower() == "true":
5487                     this_vtype = "REG_SZ"
5488                     if requested_val is not None:
5489                         this_element_value = str(requested_val).encode("utf-16-le")
5490             if check_deleted:
5491                 this_vtype = "REG_SZ"
5492         elif etree.QName(element).localname == "longDecimal":
5493             this_vtype = "REG_QWORD"
5494             requested_val = this_element_value
5495             if this_element_value is not None:
5496                 this_element_value = struct.pack(b"Q", int(this_element_value))
5497             if "storeAsText" in element.attrib:
5498                 if element.attrib["storeAsText"].lower() == "true":
5499                     this_vtype = "REG_SZ"
5500                     if requested_val is not None:
5501                         this_element_value = str(requested_val).encode("utf-16-le")
5502         elif etree.QName(element).localname == "text":
5503             this_vtype = "REG_SZ"
5504             if "expandable" in element.attrib:
5505                 if element.attrib["expandable"].lower() == "true":
5506                     this_vtype = "REG_EXPAND_SZ"
5507             if this_element_value is not None:
5508                 this_element_value = _encode_string(this_element_value)
5509         elif etree.QName(element).localname == "multiText":
5510             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5511             if this_element_value is not None:
5512                 this_element_value = "{0}{1}{1}".format(
5513                     chr(0).join(this_element_value), chr(0)
5514                 )
5515         elif etree.QName(element).localname == "list":
5516             standard_element_expected_string = False
5517             del_keys = b""
5518             element_valuenames = []
5519             element_values = this_element_value
5520             if this_element_value is not None:
5521                 element_valuenames = [
5522                     str(z) for z in range(1, len(this_element_value) + 1)
5523                 ]
5524             if "additive" in element.attrib:
5525                 if element.attrib["additive"].lower() == "false":
5526                     del_keys = b"".join(
5527                         [
5528                             "[".encode("utf-16-le"),
5529                             reg_key,
5530                             encoded_null,
5531                             encoded_semicolon,
5532                             "**delvals.".encode("utf-16-le"),
5533                             encoded_null,
5534 <a name="27"></a>                            encoded_semicolon,
5535                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5536                             encoded_semicolon,
5537                             chr(len<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5538                                 "utf-32-le"
5539                             ),
5540                             encoded_semicolon,
5541                             " ".encode("utf-16-le"),
5542                             encoded_null,
5543                             "]".encode(</b></font>"utf-16-le"),
5544                         ]
5545                     )
5546             if "expandable" in element.attrib:
5547                 this_vtype = "REG_EXPAND_SZ"
5548             if element.attrib.get("explicitValue", "false").lower() == "true":
5549                 if this_element_value is not None:
5550                     element_valuenames = [str(k) for k in this_element_value.keys()]
5551                     element_values = [str(v) for v in this_element_value.values()]
5552             elif "valuePrefix" in element.attrib:
5553                 if element.attrib["valuePrefix"] != "":
5554                     if this_element_value is not None:
5555                         element_valuenames = [
5556                             "{}{}".format(element.attrib["valuePrefix"], k)
5557                             for k in element_valuenames
5558                         ]
5559             else:
5560                 if element_values is not None:
5561                     element_valuenames = [str(z) for z in element_values]
5562             if not check_deleted:
5563                 if this_element_value is not None:
5564                     log.trace(
5565                         "_processValueItem has an explicit element_value of %s",
5566                         this_element_value,
5567                     )
5568                     expected_string = del_keys
5569                     log.trace(
5570                         "element_valuenames == %s and element_values == %s",
5571                         element_valuenames,
5572                         element_values,
5573                     )
5574                     for i, item in enumerate(element_valuenames):
5575                         expected_string = expected_string + b"".join(
5576                             [
5577                                 "[".encode("utf-16-le"),
5578                                 reg_key,
5579                                 encoded_null,
5580                                 encoded_semicolon,
5581                                 element_valuenames[i].encode("utf-16-le"),
5582                                 encoded_null,
5583                                 encoded_semicolon,
5584                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5585                                 encoded_semicolon,
5586                                 chr(
5587                                     len(
5588                                         "{}{}".format(element_values[i], chr(0)).encode(
5589                                             "utf-16-le"
5590                                         )
5591                                     )
5592                                 ).encode("utf-32-le"),
5593                                 encoded_semicolon,
5594                                 _encode_string(element_values[i]),
5595                                 "]".encode("utf-16-le"),
5596                             ]
5597                         )
5598                 else:
5599                     expected_string = del_keys + b"".join(
5600                         [
5601                             "[".encode("utf-16-le"),
5602                             reg_key,
5603                             encoded_null,
5604                             encoded_semicolon,
5605                         ]
5606                     )
5607             else:
5608                 expected_string = b"".join(
5609                     [
5610                         "[".encode("utf-16-le"),
5611                         reg_key,
5612                         encoded_null,
5613                         encoded_semicolon,
5614                         "**delvals.".encode("utf-16-le"),
5615                         encoded_null,
5616 <a name="26"></a>                        encoded_semicolon,
5617                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5618                         encoded_semicolon,
5619                         chr(len<font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5620                             "utf-32-le"
5621                         ),
5622                         encoded_semicolon,
5623                         " ".encode("utf-16-le"),
5624                         encoded_null,
5625                         "]".encode(</b></font>"utf-16-le"),
5626                     ]
5627                 )
5628         elif etree.QName(element).localname == "enum":
5629             if this_element_value is not None:
5630                 pass
5631         if standard_element_expected_string and not check_deleted:
5632             if this_element_value is not None:
5633                 if isinstance(this_element_value, str):
5634                     log.debug("Converting %s to bytes", this_element_value)
5635                     this_element_value = this_element_value.encode("utf-32-le")
5636                 expected_string = b"".join(
5637                     [
5638                         "[".encode("utf-16-le"),
5639                         reg_key,
5640                         encoded_null,
5641                         encoded_semicolon,
5642                         reg_valuename,
5643                         encoded_null,
5644                         encoded_semicolon,
5645                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5646                         encoded_semicolon,
5647                         chr(len(this_element_value)).encode("utf-32-le"),
5648                         encoded_semicolon,
5649                         this_element_value,
5650                         "]".encode("utf-16-le"),
5651                     ]
5652                 )
5653             else:
5654                 expected_string = b"".join(
5655                     [
5656                         "[".encode("utf-16-le"),
5657                         reg_key,
5658                         encoded_null,
5659                         encoded_semicolon,
5660                         reg_valuename,
5661                         encoded_null,
5662                         encoded_semicolon,
5663                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5664                         encoded_semicolon,
5665                     ]
5666                 )
5667     if not expected_string:
5668         if etree.QName(element).localname == "delete" or check_deleted:
5669             expected_string = b"".join(
5670                 [
5671                     "[".encode("utf-16-le"),
5672                     reg_key,
5673                     encoded_null,
5674                     encoded_semicolon,
5675                     "**del.".encode("utf-16-le"),
5676                     reg_valuename,
5677                     encoded_null,
5678                     encoded_semicolon,
5679                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5680                     encoded_semicolon,
5681                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5682                         "utf-32-le"
5683                     ),
5684                     encoded_semicolon,
5685                     " ".encode("utf-16-le"),
5686                     encoded_null,
5687                     "]".encode("utf-16-le"),
5688                 ]
5689             )
5690         else:
5691             expected_string = b"".join(
5692                 [
5693                     "[".encode("utf-16-le"),
5694                     reg_key,
5695                     encoded_null,
5696                     encoded_semicolon,
5697                     reg_valuename,
5698                     encoded_null,
5699 <a name="12"></a>                    encoded_semicolon,
5700                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5701                     encoded_semicolon,
5702                     chr(len<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(this_element_value)).encode("utf-32-le"),
5703                     encoded_semicolon,
5704                     this_element_value,
5705                     "]".encode("utf-16-le"),
5706                 ]
5707             )
5708     return expected_string
5709 def _checkAllAdmxPolicies(
5710     policy_class,
5711     adml_language="en-US",
5712     return_full_policy_names=False,
5713     hierarchical_return=False,
5714     return_not_configured=</b></font>False,
5715 ):
5716     log.trace("POLICY CLASS == %s", policy_class)
5717     module_policy_data = _policy_info()
5718     policy_file_data = _read_regpol_file(
5719         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
5720     )
5721     admx_policies = []
5722     policy_vals = {}
5723     hierarchy = {}
5724     full_names = {}
5725     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5726     adml_policy_resources = _get_policy_resources(language=adml_language)
5727     if policy_file_data:
5728         log.trace("POLICY CLASS %s has file data", policy_class)
5729         policy_filedata_split = re.sub(
5730             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
5731             b"",
5732 <a name="11"></a>            re.sub(
5733                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
5734                 b"",
5735                 re<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.sub(
5736                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
5737                     b"",
5738                     policy_file_data,
5739                 ),
5740             ),
5741         ).split("][".encode("utf-16-le"))
5742         log.trace("Searching %s policies...", len(</b></font>policy_filedata_split))
5743         start_time = time.time()
5744         for policy_item in policy_filedata_split:
5745             policy_item_key = (
5746                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
5747                 .decode("utf-16-le")
5748                 .lower()
5749             )
5750             if policy_item_key:
5751                 admx_items = REGKEY_XPATH(
5752                     admx_policy_definitions, keyvalue=policy_item_key
5753                 )
5754                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
5755                 for admx_item in admx_items:
5756                     if etree.QName(admx_item).localname == "policy":
5757                         if admx_item not in admx_policies:
5758                             admx_policies.append(admx_item)
5759                     else:
5760                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
5761                             if policy_item not in admx_policies:
5762                                 admx_policies.append(policy_item)
5763         log.trace("Search complete: %s seconds", time.time() - start_time)
5764         if return_not_configured:
5765             log.trace("Gathering non configured policies")
5766             start_time = time.time()
5767             not_configured_policies = ALL_CLASS_POLICY_XPATH(
5768                 admx_policy_definitions, registry_class=policy_class
5769             )
5770             for policy_item in admx_policies:
5771                 if policy_item in not_configured_policies:
5772                     not_configured_policies.remove(policy_item)
5773             for not_configured_policy in not_configured_policies:
5774                 not_configured_policy_namespace = not_configured_policy.nsmap[
5775                     not_configured_policy.prefix
5776                 ]
5777                 if not_configured_policy_namespace not in policy_vals:
5778                     policy_vals[not_configured_policy_namespace] = {}
5779                 policy_vals[not_configured_policy_namespace][
5780                     not_configured_policy.attrib["name"]
5781                 ] = "Not Configured"
5782                 if return_full_policy_names:
5783                     if not_configured_policy_namespace not in full_names:
5784                         full_names[not_configured_policy_namespace] = {}
5785                     full_names[not_configured_policy_namespace][
5786                         not_configured_policy.attrib["name"]
5787                     ] = _getFullPolicyName(
5788                         policy_item=not_configured_policy,
5789                         policy_name=not_configured_policy.attrib["name"],
5790                         return_full_policy_names=return_full_policy_names,
5791                         adml_language=adml_language,
5792                     )
5793                 log.trace(
5794                     "building hierarchy for non-configured item %s",
5795                     not_configured_policy.attrib["name"],
5796                 )
5797                 if not_configured_policy_namespace not in hierarchy:
5798                     hierarchy[not_configured_policy_namespace] = {}
5799                 hierarchy[not_configured_policy_namespace][
5800                     not_configured_policy.attrib["name"]
5801                 ] = _build_parent_list(
5802                     policy_definition=not_configured_policy,
5803                     return_full_policy_names=return_full_policy_names,
5804                     adml_language=adml_language,
5805                 )
5806             log.trace("Gathering complete: %s seconds", time.time() - start_time)
5807         log.trace("Examining %s policies...", len(admx_policies))
5808         start_time = time.time()
5809         for admx_policy in admx_policies:
5810             this_valuename = None
5811             this_policy_setting = "Not Configured"
5812             element_only_enabled_disabled = True
5813             explicit_enable_disable_value_setting = False
5814             if "key" in admx_policy.attrib:
5815                 this_key = admx_policy.attrib["key"]
5816             else:
5817                 log.error(
5818                     'policy item %s does not have the required "key" attribute',
5819                     admx_policy.attrib,
5820                 )
5821                 break
5822             if "valueName" in admx_policy.attrib:
5823                 this_valuename = admx_policy.attrib["valueName"]
5824             if "name" in admx_policy.attrib:
5825                 this_policyname = admx_policy.attrib["name"]
5826             else:
5827                 log.error(
5828                     'policy item %s does not have the required "name" attribute',
5829                     admx_policy.attrib,
5830                 )
5831                 break
5832             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
5833             if (
5834                 ENABLED_VALUE_XPATH(admx_policy)
5835                 and this_policy_setting == "Not Configured"
5836             ):
5837                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
5838                     admx_policy
5839                 ):
5840                     element_only_enabled_disabled = False
5841                     explicit_enable_disable_value_setting = True
5842                 if _checkValueItemParent(
5843                     admx_policy,
5844                     this_policyname,
5845                     this_key,
5846                     this_valuename,
5847                     ENABLED_VALUE_XPATH,
5848                     policy_file_data,
5849                 ):
5850                     this_policy_setting = "Enabled"
5851                     log.trace(
5852                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
5853                     )
5854                     if this_policynamespace not in policy_vals:
5855                         policy_vals[this_policynamespace] = {}
5856                     policy_vals[this_policynamespace][
5857                         this_policyname
5858                     ] = this_policy_setting
5859             if (
5860                 DISABLED_VALUE_XPATH(admx_policy)
5861                 and this_policy_setting == "Not Configured"
5862             ):
5863                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
5864                     element_only_enabled_disabled = False
5865                     explicit_enable_disable_value_setting = True
5866                 if _checkValueItemParent(
5867                     admx_policy,
5868                     this_policyname,
5869                     this_key,
5870                     this_valuename,
5871                     DISABLED_VALUE_XPATH,
5872                     policy_file_data,
5873                 ):
5874                     this_policy_setting = "Disabled"
5875                     log.trace(
5876                         "%s is disabled by detected DISABLED_VALUE_XPATH",
5877                         this_policyname,
5878                     )
5879                     if this_policynamespace not in policy_vals:
5880                         policy_vals[this_policynamespace] = {}
5881                     policy_vals[this_policynamespace][
5882                         this_policyname
5883                     ] = this_policy_setting
5884             if (
5885                 ENABLED_LIST_XPATH(admx_policy)
5886                 and this_policy_setting == "Not Configured"
5887             ):
5888                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
5889                     admx_policy
5890                 ):
5891                     element_only_enabled_disabled = False
5892                     explicit_enable_disable_value_setting = True
5893                 if _checkListItem(
5894                     admx_policy,
5895                     this_policyname,
5896                     this_key,
5897                     ENABLED_LIST_XPATH,
5898                     policy_file_data,
5899                 ):
5900                     this_policy_setting = "Enabled"
5901                     log.trace(
5902                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
5903                     )
5904                     if this_policynamespace not in policy_vals:
5905                         policy_vals[this_policynamespace] = {}
5906                     policy_vals[this_policynamespace][
5907                         this_policyname
5908                     ] = this_policy_setting
5909             if (
5910                 DISABLED_LIST_XPATH(admx_policy)
5911                 and this_policy_setting == "Not Configured"
5912             ):
5913                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
5914                     element_only_enabled_disabled = False
5915                     explicit_enable_disable_value_setting = True
5916                 if _checkListItem(
5917                     admx_policy,
5918                     this_policyname,
5919                     this_key,
5920                     DISABLED_LIST_XPATH,
5921                     policy_file_data,
5922                 ):
5923                     this_policy_setting = "Disabled"
5924                     log.trace(
5925                         "%s is disabled by detected DISABLED_LIST_XPATH",
5926                         this_policyname,
5927                     )
5928                     if this_policynamespace not in policy_vals:
5929                         policy_vals[this_policynamespace] = {}
5930                     policy_vals[this_policynamespace][
5931                         this_policyname
5932                     ] = this_policy_setting
5933             if not explicit_enable_disable_value_setting and this_valuename:
5934                 if _regexSearchRegPolData(
5935                     re.escape(
5936                         _buildKnownDataSearchString(
5937                             this_key, this_valuename, "REG_DWORD", "1"
5938                         )
5939                     ),
5940                     policy_file_data,
5941                 ):
5942                     this_policy_setting = "Enabled"
5943                     log.trace(
5944                         "%s is enabled by no explicit enable/disable list or value",
5945                         this_policyname,
5946                     )
5947                     if this_policynamespace not in policy_vals:
5948                         policy_vals[this_policynamespace] = {}
5949                     policy_vals[this_policynamespace][
5950                         this_policyname
5951                     ] = this_policy_setting
5952                 elif _regexSearchRegPolData(
5953                     re.escape(
5954                         _buildKnownDataSearchString(
5955                             this_key,
5956                             this_valuename,
5957                             "REG_DWORD",
5958                             None,
5959                             check_deleted=True,
5960                         )
5961                     ),
5962                     policy_file_data,
5963                 ):
5964                     this_policy_setting = "Disabled"
5965                     log.trace(
5966                         "%s is disabled by no explicit enable/disable list or value",
5967                         this_policyname,
5968                     )
5969                     if this_policynamespace not in policy_vals:
5970                         policy_vals[this_policynamespace] = {}
5971                     policy_vals[this_policynamespace][
5972                         this_policyname
5973                     ] = this_policy_setting
5974             if ELEMENTS_XPATH(admx_policy):
5975                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
5976                     required_elements = {}
5977                     configured_elements = {}
5978                     policy_disabled_elements = 0
5979                     for elements_item in ELEMENTS_XPATH(admx_policy):
5980                         for child_item in elements_item:
5981                             this_element_name = _getFullPolicyName(
5982                                 policy_item=child_item,
5983                                 policy_name=child_item.attrib["id"],
5984                                 return_full_policy_names=return_full_policy_names,
5985                                 adml_language=adml_language,
5986                             )
5987                             required_elements[this_element_name] = None
5988                             child_key = child_item.attrib.get("key", this_key)
5989                             child_valuename = child_item.attrib.get(
5990                                 "valueName", this_valuename
5991                             )
5992                             if etree.QName(child_item).localname == "boolean":
5993                                 if child_item is not None:
5994                                     if (
5995                                         TRUE_VALUE_XPATH(child_item)
5996                                         and this_element_name not in configured_elements
5997                                     ):
5998                                         if _checkValueItemParent(
5999                                             child_item,
6000                                             this_policyname,
6001                                             child_key,
6002                                             child_valuename,
6003                                             TRUE_VALUE_XPATH,
6004                                             policy_file_data,
6005                                         ):
6006                                             configured_elements[
6007                                                 this_element_name
6008                                             ] = True
6009                                             log.trace(
6010                                                 "element %s is configured true",
6011                                                 child_item.attrib["id"],
6012                                             )
6013                                     if (
6014                                         FALSE_VALUE_XPATH(child_item)
6015                                         and this_element_name not in configured_elements
6016                                     ):
6017                                         if _checkValueItemParent(
6018                                             child_item,
6019                                             this_policyname,
6020                                             child_key,
6021                                             child_valuename,
6022                                             FALSE_VALUE_XPATH,
6023                                             policy_file_data,
6024                                         ):
6025                                             configured_elements[
6026                                                 this_element_name
6027                                             ] = False
6028                                             policy_disabled_elements = (
6029                                                 policy_disabled_elements + 1
6030                                             )
6031                                             log.trace(
6032                                                 "element %s is configured false",
6033                                                 child_item.attrib["id"],
6034                                             )
6035                                     if (
6036                                         TRUE_LIST_XPATH(child_item)
6037                                         and this_element_name not in configured_elements
6038                                     ):
6039                                         log.trace("checking trueList")
6040                                         if _checkListItem(
6041                                             child_item,
6042                                             this_policyname,
6043                                             this_key,
6044                                             TRUE_LIST_XPATH,
6045                                             policy_file_data,
6046                                         ):
6047                                             configured_elements[
6048                                                 this_element_name
6049                                             ] = True
6050                                             log.trace(
6051                                                 "element %s is configured true",
6052                                                 child_item.attrib["id"],
6053                                             )
6054                                     if (
6055                                         FALSE_LIST_XPATH(child_item)
6056                                         and this_element_name not in configured_elements
6057                                     ):
6058                                         log.trace("checking falseList")
6059                                         if _checkListItem(
6060                                             child_item,
6061                                             this_policyname,
6062                                             this_key,
6063                                             FALSE_LIST_XPATH,
6064                                             policy_file_data,
6065                                         ):
6066                                             configured_elements[
6067                                                 this_element_name
6068                                             ] = False
6069                                             policy_disabled_elements = (
6070                                                 policy_disabled_elements + 1
6071                                             )
6072                                             log.trace(
6073                                                 "element %s is configured false",
6074                                                 child_item.attrib["id"],
6075                                             )
6076                                 else:
6077                                     if _regexSearchRegPolData(
6078                                         re.escape(
6079                                             _processValueItem(
6080                                                 child_item,
6081                                                 child_key,
6082                                                 child_valuename,
6083                                                 admx_policy,
6084                                                 elements_item,
6085                                                 check_deleted=True,
6086                                             )
6087                                         ),
6088                                         policy_file_data,
6089                                     ):
6090                                         configured_elements[this_element_name] = False
6091                                         policy_disabled_elements = (
6092                                             policy_disabled_elements + 1
6093                                         )
6094                                         log.trace(
6095                                             "element %s is configured false",
6096                                             child_item.attrib["id"],
6097                                         )
6098                                     elif _regexSearchRegPolData(
6099                                         re.escape(
6100                                             _processValueItem(
6101                                                 child_item,
6102                                                 child_key,
6103                                                 child_valuename,
6104                                                 admx_policy,
6105                                                 elements_item,
6106                                                 check_deleted=False,
6107                                             )
6108                                         ),
6109                                         policy_file_data,
6110                                     ):
6111 <a name="15"></a>                                        configured_elements[this_element_name] = True
6112                                         log.trace(
6113                                             "element %s is configured true",
6114                                             child_item.attrib["<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>id"],
6115                                         )
6116                             elif (
6117                                 etree.QName(child_item).localname == "decimal"
6118                                 or etree.QName(child_item).localname == "text"
6119                                 or etree.QName(child_item).localname == "longDecimal"
6120                                 or etree.QName(child_item).</b></font>localname == "multiText"
6121                             ):
6122                                 if _regexSearchRegPolData(
6123                                     re.escape(
6124                                         _processValueItem(
6125                                             child_item,
6126                                             child_key,
6127                                             child_valuename,
6128                                             admx_policy,
6129                                             elements_item,
6130                                             check_deleted=True,
6131                                         )
6132                                     ),
6133                                     policy_file_data,
6134                                 ):
6135                                     configured_elements[this_element_name] = "Disabled"
6136                                     policy_disabled_elements = (
6137                                         policy_disabled_elements + 1
6138                                     )
6139                                     log.trace(
6140                                         "element %s is disabled",
6141                                         child_item.attrib["id"],
6142                                     )
6143                                 elif _regexSearchRegPolData(
6144                                     re.escape(
6145                                         _processValueItem(
6146                                             child_item,
6147                                             child_key,
6148                                             child_valuename,
6149                                             admx_policy,
6150                                             elements_item,
6151                                             check_deleted=False,
6152                                         )
6153                                     ),
6154                                     policy_file_data,
6155                                 ):
6156                                     configured_value = _getDataFromRegPolData(
6157                                         _processValueItem(
6158                                             child_item,
6159                                             child_key,
6160                                             child_valuename,
6161                                             admx_policy,
6162                                             elements_item,
6163                                             check_deleted=False,
6164                                         ),
6165                                         policy_file_data,
6166                                     )
6167                                     configured_elements[
6168                                         this_element_name
6169                                     ] = configured_value
6170                                     log.trace(
6171                                         "element %s is enabled, value == %s",
6172                                         child_item.attrib["id"],
6173                                         configured_value,
6174                                     )
6175                             elif etree.QName(child_item).localname == "enum":
6176                                 if _regexSearchRegPolData(
6177                                     re.escape(
6178                                         _processValueItem(
6179                                             child_item,
6180                                             child_key,
6181                                             child_valuename,
6182                                             admx_policy,
6183                                             elements_item,
6184                                             check_deleted=True,
6185                                         )
6186                                     ),
6187                                     policy_file_data,
6188                                 ):
6189                                     log.trace(
6190                                         "enum element %s is disabled",
6191                                         child_item.attrib["id"],
6192                                     )
6193                                     configured_elements[this_element_name] = "Disabled"
6194                                     policy_disabled_elements = (
6195                                         policy_disabled_elements + 1
6196                                     )
6197                                 else:
6198                                     for enum_item in child_item:
6199                                         if _checkValueItemParent(
6200                                             enum_item,
6201                                             child_item.attrib["id"],
6202                                             child_key,
6203                                             child_valuename,
6204                                             VALUE_XPATH,
6205                                             policy_file_data,
6206                                         ):
6207                                             if VALUE_LIST_XPATH(enum_item):
6208                                                 log.trace("enum item has a valueList")
6209                                                 if _checkListItem(
6210                                                     enum_item,
6211                                                     this_policyname,
6212                                                     child_key,
6213                                                     VALUE_LIST_XPATH,
6214                                                     policy_file_data,
6215                                                 ):
6216                                                     log.trace(
6217                                                         "all valueList items exist in"
6218                                                         " file"
6219                                                     )
6220                                                     configured_elements[
6221                                                         this_element_name
6222                                                     ] = _getAdmlDisplayName(
6223                                                         adml_policy_resources,
6224                                                         enum_item.attrib["displayName"],
6225                                                     )
6226                                                     break
6227                                             else:
6228                                                 configured_elements[
6229                                                     this_element_name
6230                                                 ] = _getAdmlDisplayName(
6231                                                     adml_policy_resources,
6232                                                     enum_item.attrib["displayName"],
6233                                                 )
6234                                                 break
6235                             elif etree.QName(child_item).localname == "list":
6236                                 return_value_name = False
6237                                 if (
6238                                     "explicitValue" in child_item.attrib
6239                                     and child_item.attrib["explicitValue"].lower()
6240                                     == "true"
6241                                 ):
6242                                     log.trace(
6243                                         "explicitValue list, we will return value names"
6244                                     )
6245                                     return_value_name = True
6246                                 regex_str = [
6247                                     r"(?!\*",
6248                                     r"\*",
6249                                     "D",
6250                                     "e",
6251                                     "l",
6252                                     "V",
6253                                     "a",
6254                                     "l",
6255                                     "s",
6256                                     r"\.",
6257                                     ")",
6258                                 ]
6259                                 delvals_regex = "\x00".join(regex_str)
6260                                 delvals_regex = salt.utils.stringutils.to_bytes(
6261                                     delvals_regex
6262                                 )
6263                                 if _regexSearchRegPolData(
6264                                     re.escape(
6265                                         _processValueItem(
6266                                             child_item,
6267                                             child_key,
6268                                             child_valuename,
6269                                             admx_policy,
6270                                             elements_item,
6271                                             check_deleted=False,
6272                                         )
6273                                     )
6274                                     + delvals_regex,
6275                                     policy_file_data,
6276                                 ):
6277                                     configured_value = _getDataFromRegPolData(
6278                                         _processValueItem(
6279                                             child_item,
6280                                             child_key,
6281                                             child_valuename,
6282                                             admx_policy,
6283                                             elements_item,
6284                                             check_deleted=False,
6285                                         ),
6286                                         policy_file_data,
6287                                         return_value_name=return_value_name,
6288                                     )
6289                                     configured_elements[
6290                                         this_element_name
6291                                     ] = configured_value
6292                                     log.trace(
6293                                         "element %s is enabled values: %s",
6294                                         child_item.attrib["id"],
6295                                         configured_value,
6296                                     )
6297                                 elif _regexSearchRegPolData(
6298                                     re.escape(
6299                                         _processValueItem(
6300                                             child_item,
6301                                             child_key,
6302                                             child_valuename,
6303                                             admx_policy,
6304                                             elements_item,
6305                                             check_deleted=True,
6306                                         )
6307                                     ),
6308                                     policy_file_data,
6309                                 ):
6310                                     configured_elements[this_element_name] = "Disabled"
6311                                     policy_disabled_elements = (
6312                                         policy_disabled_elements + 1
6313                                     )
6314                                     log.trace(
6315                                         "element %s is disabled",
6316                                         child_item.attrib["id"],
6317                                     )
6318                     if element_only_enabled_disabled:
6319                         if len(required_elements.keys()) &gt; 0 and len(
6320                             configured_elements.keys()
6321                         ) == len(required_elements.keys()):
6322                             if policy_disabled_elements == len(
6323                                 required_elements.keys()
6324                             ):
6325                                 log.trace(
6326                                     "%s is disabled by all enum elements",
6327                                     this_policyname,
6328                                 )
6329                                 if this_policynamespace not in policy_vals:
6330                                     policy_vals[this_policynamespace] = {}
6331                                 policy_vals[this_policynamespace][
6332                                     this_policyname
6333                                 ] = "Disabled"
6334                             else:
6335                                 if this_policynamespace not in policy_vals:
6336                                     policy_vals[this_policynamespace] = {}
6337                                 policy_vals[this_policynamespace][
6338                                     this_policyname
6339                                 ] = configured_elements
6340                                 log.trace(
6341                                     "%s is enabled by enum elements", this_policyname
6342                                 )
6343                     else:
6344                         if this_policy_setting == "Enabled":
6345                             if this_policynamespace not in policy_vals:
6346                                 policy_vals[this_policynamespace] = {}
6347                             policy_vals[this_policynamespace][
6348                                 this_policyname
6349                             ] = configured_elements
6350             if (
6351                 return_full_policy_names
6352                 and this_policynamespace in policy_vals
6353                 and this_policyname in policy_vals[this_policynamespace]
6354             ):
6355                 if this_policynamespace not in full_names:
6356                     full_names[this_policynamespace] = {}
6357                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6358                     policy_item=admx_policy,
6359                     policy_name=admx_policy.attrib["name"],
6360                     return_full_policy_names=return_full_policy_names,
6361                     adml_language=adml_language,
6362                 )
6363                 if (
6364                     this_policyname
6365                     in policy_vals[this_policynamespace][this_policyname]
6366                 ):
6367                     full_name = full_names[this_policynamespace][this_policyname]
6368                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6369                         this_policyname
6370                     )
6371                     policy_vals[this_policynamespace][this_policyname][
6372                         full_name
6373                     ] = setting
6374             if (
6375                 this_policynamespace in policy_vals
6376                 and this_policyname in policy_vals[this_policynamespace]
6377             ):
6378                 if this_policynamespace not in hierarchy:
6379                     hierarchy[this_policynamespace] = {}
6380                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6381                     policy_definition=admx_policy,
6382 <a name="25"></a>                    return_full_policy_names=return_full_policy_names,
6383                     adml_language=adml_language,
6384                 )
6385         log<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("Examination complete: %s seconds", time.time() - start_time)
6386     if policy_vals and return_full_policy_names and not hierarchical_return:
6387         log.debug("Compiling non hierarchical return...")
6388         start_time = time.time()
6389         unpathed_dict =</b></font> {}
6390         pathed_dict = {}
6391         for policy_namespace in list(policy_vals):
6392             for policy_item in list(policy_vals[policy_namespace]):
6393                 if (
6394                     full_names[policy_namespace][policy_item]
6395                     in policy_vals[policy_namespace]
6396                 ):
6397                     full_path_list = hierarchy[policy_namespace][policy_item]
6398                     full_path_list.reverse()
6399                     full_path_list.append(full_names[policy_namespace][policy_item])
6400 <a name="14"></a>                    policy_vals["\\".join(full_path_list)] = policy_vals[
6401                         policy_namespace
6402                     ].pop(policy_item)
6403                     pathed_dict[full_names[policy_namespace][policy_item]] <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= True
6404                 else:
6405                     policy_vals[policy_namespace][
6406                         full_names[policy_namespace][policy_item]
6407                     ] = policy_vals[policy_namespace].pop(policy_item)
6408                     if policy_namespace not in unpathed_dict:
6409                         unpathed_dict[policy_namespace] =</b></font> {}
6410                     unpathed_dict[policy_namespace][
6411                         full_names[policy_namespace][policy_item]
6412                     ] = policy_item
6413             if policy_namespace in unpathed_dict:
6414                 for path_needed in unpathed_dict[policy_namespace]:
6415                     full_path_list = hierarchy[policy_namespace][
6416                         unpathed_dict[policy_namespace][path_needed]
6417                     ]
6418                     full_path_list.reverse()
6419                     full_path_list.append(path_needed)
6420                     log.trace("full_path_list == %s", full_path_list)
6421                     policy_vals["\\".join(full_path_list)] = policy_vals[
6422                         policy_namespace
6423                     ].pop(path_needed)
6424         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6425     for policy_namespace in list(policy_vals):
6426         if policy_vals[policy_namespace] == {}:
6427             policy_vals.pop(policy_namespace)
6428     if policy_vals and hierarchical_return:
6429         if hierarchy:
6430             log.debug("Compiling hierarchical return...")
6431             start_time = time.time()
6432             for policy_namespace in hierarchy:
6433                 for hierarchy_item in hierarchy[policy_namespace]:
6434                     if hierarchy_item in policy_vals[policy_namespace]:
6435                         tdict = {}
6436                         first_item = True
6437                         for item in hierarchy[policy_namespace][hierarchy_item]:
6438                             newdict = {}
6439                             if first_item:
6440                                 h_policy_name = hierarchy_item
6441                                 if return_full_policy_names:
6442                                     h_policy_name = full_names[policy_namespace][
6443                                         hierarchy_item
6444                                     ]
6445                                 newdict[item] = {
6446                                     h_policy_name: policy_vals[policy_namespace].pop(
6447                                         hierarchy_item
6448                                     )
6449                                 }
6450                                 first_item = False
6451                             else:
6452                                 newdict[item] = tdict
6453                             tdict = newdict
6454                         if tdict:
6455                             policy_vals = dictupdate.update(policy_vals, tdict)
6456                 if (
6457                     policy_namespace in policy_vals
6458                     and policy_vals[policy_namespace] == {}
6459                 ):
6460                     policy_vals.pop(policy_namespace)
6461             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6462         policy_vals = {
6463             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6464                 "Administrative Templates": policy_vals
6465             }
6466         }
6467     return policy_vals
6468 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6469     parent_list = []
6470     policy_namespace = next(iter(policy_definition.nsmap))
6471     parent_category = policy_definition.xpath(
6472         "{}:parentCategory/@ref".format(policy_namespace),
6473         namespaces=policy_definition.nsmap,
6474     )
6475     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6476     if parent_category:
6477         parent_category = parent_category[0]
6478         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6479             policy_namespace
6480         )
6481         this_namespace_map = _buildElementNsmap(
6482             admx_policy_definitions.xpath(
6483                 nsmap_xpath, namespaces=policy_definition.nsmap
6484             )
6485         )
6486         this_namespace_map = dictupdate.update(
6487             this_namespace_map, policy_definition.nsmap
6488         )
6489         parent_list = _admx_policy_parent_walk(
6490             path=parent_list,
6491             policy_namespace=policy_namespace,
6492             parent_category=parent_category,
6493             policy_nsmap=this_namespace_map,
6494             return_full_policy_names=return_full_policy_names,
6495             adml_language=adml_language,
6496         )
6497     return parent_list
6498 def _admx_policy_parent_walk(
6499     path,
6500     policy_namespace,
6501     parent_category,
6502     policy_nsmap,
6503     return_full_policy_names,
6504     adml_language,
6505 ):
6506     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6507     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6508     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6509     if parent_category.find(":") &gt;= 0:
6510         policy_namespace = parent_category.split(":")[0]
6511         parent_category = parent_category.split(":")[1]
6512         using_xpath_string = using_xpath_string.format(policy_namespace)
6513         policy_nsmap = dictupdate.update(
6514             policy_nsmap,
6515             _buildElementNsmap(
6516                 admx_policy_definitions.xpath(
6517                     using_xpath_string, namespaces=policy_nsmap
6518                 )
6519             ),
6520         )
6521     category_xpath_string = category_xpath_string.format(
6522         policy_namespace, parent_category
6523     )
6524     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6525         tparent_category = admx_policy_definitions.xpath(
6526             category_xpath_string, namespaces=policy_nsmap
6527         )[0]
6528         this_parent_name = _getFullPolicyName(
6529             policy_item=tparent_category,
6530             policy_name=tparent_category.attrib["name"],
6531             return_full_policy_names=return_full_policy_names,
6532             adml_language=adml_language,
6533         )
6534         path.append(this_parent_name)
6535         if tparent_category.xpath(
6536             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6537         ):
6538             path = _admx_policy_parent_walk(
6539                 path=path,
6540                 policy_namespace=policy_namespace,
6541                 parent_category=tparent_category.xpath(
6542                     "{}:parentCategory/@ref".format(policy_namespace),
6543                     namespaces=policy_nsmap,
6544                 )[0],
6545                 policy_nsmap=policy_nsmap,
6546                 return_full_policy_names=return_full_policy_names,
6547                 adml_language=adml_language,
6548             )
6549     return path
6550 def _read_regpol_file(reg_pol_path):
6551     returndata = None
6552     if os.path.exists(reg_pol_path):
6553         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6554             returndata = pol_file.read()
6555     return returndata
6556 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6557     if policy_data:
6558         regex_str <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= [
6559             r"(\*",
6560             r"\*",
6561             "D",
6562             "e",
6563             "l",
6564             r"\.",
6565             r"|\*",
6566             r"\*",
6567             "D",
6568             "e",
6569             "l",
6570             "V",
6571             "a",
6572             "l",
6573             "s",
6574             r"\.",
6575             "){0,1}",
6576         ]
6577         specialValueRegex = "\x00".join(regex_str)
6578 <a name="13"></a>        specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
6579         _thisSearch = b"".join(
6580             [
6581                 salt</b></font><font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.stringutils.to_bytes(r"\["),
6582                 re.escape(policy_regpath),
6583                 b"\x00;\x00",
6584                 specialValueRegex,
6585                 re.escape(policy_regkey.lstrip(b"\x00")),
6586                 b"\x00;",
6587             ]
6588         )
6589         match = re.search(</b></font>_thisSearch, policy_data, re.IGNORECASE)
6590         if match:
6591             return policy_data[
6592                 match.start() : (policy_data.index(b"]", match.end())) + 2
6593             ]
6594     return None
6595 def _write_regpol_data(
6596     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6597 ):
6598     if not os.path.exists(policy_file_path):
6599         __salt__["file.makedirs"](policy_file_path)
6600     try:
6601         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
6602             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
6603             if not data_to_write.startswith(reg_pol_header):
6604                 pol_file.write(reg_pol_header)
6605             pol_file.write(data_to_write)
6606     except Exception as e:  # pylint: disable=broad-except
6607         msg = (
6608             "An error occurred attempting to write to {}, the exception was: {}".format(
6609                 policy_file_path, e
6610             )
6611         )
6612         log.exception(msg)
6613         raise CommandExecutionError(msg)
6614     gpt_ini_data = ""
6615     if os.path.exists(gpt_ini_path):
6616         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
6617             gpt_ini_data = gpt_file.read()
6618         gpt_ini_data = (
6619             gpt_ini_data.replace("\r\n", "_|-")
6620             .replace("\n", "_|-")
6621             .replace("_|-", "\r\n")
6622         )
6623     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
6624 <a name="9"></a>        gpt_ini_data = "[General]\r\n" + gpt_ini_data
6625     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
6626         gpt_ext_loc <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= re.search(
6627             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
6628             gpt_ini_data,
6629             re.IGNORECASE | re.MULTILINE,
6630         )
6631         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.</b></font>end()]
6632         if not _regexSearchRegPolData(
6633             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
6634         ):
6635             gpt_ext_str = gpt_ext_str.split("=")
6636             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
6637             gpt_ext_str = "=".join(gpt_ext_str)
6638             gpt_ini_data = (
6639                 gpt_ini_data[0 : gpt_ext_loc.start()]
6640                 + gpt_ext_str
6641                 + gpt_ini_data[gpt_ext_loc.end() :]
6642             )
6643     else:
6644 <a name="24"></a>        general_location = re.search(
6645             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6646         )
6647         gpt_ini_data = "{}{}={}\r\n{}"<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(
6648             gpt_ini_data[general_location.start() : general_location.end()],
6649             gpt_extension,
6650             gpt_extension_guid,
6651             gpt_ini_data[general_location.end() :],
6652         )
6653     if</b></font> _regexSearchRegPolData(r"Version=", gpt_ini_data):
6654 <a name="23"></a>        version_loc = re.search(
6655             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6656         )
6657 <a name="22"></a>        version_str = gpt_ini_data[version_loc<font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.start() : version_loc.end()]
6658         version_str = version_str.split("=")
6659         version_nums = struct.unpack(b"&gt;2H", struct.pack(</b></font>b"&gt;I", int(version_str[1])))
6660         if gpt_extension<font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.lower() == "gPCMachineExtensionNames".lower():
6661             version_nums = (version_nums[0], version_nums[1] + 1)
6662         elif gpt_extension.lower() == "gPCUserExtensionNames".lower(</b></font>):
6663             version_nums = (version_nums[0] + 1, version_nums[1])
6664         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
6665         gpt_ini_data = "{}{}={}\r\n{}".format(
6666             gpt_ini_data[0 : version_loc.start()],
6667             "Version",
6668             version_num,
6669             gpt_ini_data[version_loc.end() :],
6670         )
6671     else:
6672         general_location = re.search(
6673             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6674         )
6675         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6676             version_nums = (0, 1)
6677         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6678             version_nums = (1, 0)
6679         gpt_ini_data = "{}{}={}\r\n{}".format(
6680             gpt_ini_data[general_location.start() : general_location.end()],
6681             "Version",
6682             int(
6683                 "{}{}".format(
6684                     str(version_nums[0]).zfill(4),
6685                     str(version_nums[1]).zfill(4),
6686                 ),
6687                 16,
6688             ),
6689             gpt_ini_data[general_location.end() :],
6690         )
6691     if gpt_ini_data:
6692         try:
6693             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
6694                 gpt_file.write(gpt_ini_data)
6695         except Exception as e:  # pylint: disable=broad-except
6696             msg = (
6697                 "An error occurred attempting to write the gpg.ini file.\n"
6698                 "path: {}\n"
6699                 "exception: {}".format(gpt_ini_path, e)
6700             )
6701             log.exception(msg)
6702             raise CommandExecutionError(msg)
6703 def _policyFileReplaceOrAppendList(string_list, policy_data):
6704     if not policy_data:
6705         policy_data = b""
6706     specialValueRegex = salt.utils.stringutils.to_bytes(
6707         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6708     )
6709     for this_string in string_list:
6710         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6711         list_item_value_name = re.sub(
6712             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6713         )
6714         log.trace("item value name is %s", list_item_value_name)
6715         data_to_replace = _regexSearchKeyValueCombo(
6716             policy_data, list_item_key, list_item_value_name
6717         )
6718         if data_to_replace:
6719 <a name="21"></a>            log.trace("replacing %s with %s", data_to_replace, this_string)
6720             policy_data = policy_data.replace(data_to_replace, this_string)
6721         else:
6722             log<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("appending %s", this_string)
6723             policy_data = b"".join([policy_data, this_string])
6724     return policy_data
6725 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=</b></font>False):
6726     if not policy_data:
6727         policy_data = b""
6728     specialValueRegex = salt.utils.stringutils.to_bytes(
6729         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6730     )
6731     item_key = None
6732     item_value_name = None
6733     data_to_replace = None
6734     if not append_only:
6735         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6736         item_value_name = re.sub(
6737             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6738         )
6739         log.trace("item value name is %s", item_value_name)
6740         data_to_replace = _regexSearchKeyValueCombo(
6741             policy_data, item_key, item_value_name
6742         )
6743     if data_to_replace:
6744         log.trace("replacing %s with %s", data_to_replace, this_string)
6745         policy_data = policy_data.replace(data_to_replace, this_string)
6746     else:
6747         log.trace("appending %s", this_string)
6748         policy_data = b"".join([policy_data, this_string])
6749     return policy_data
6750 def _writeAdminTemplateRegPolFile(
6751     admtemplate_data, adml_language="en-US", registry_class="Machine"
6752 ):
6753     r"""
6754     helper function to prep/write adm template data to the Registry.pol file
6755     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
6756     REGISTRY_FILE_VERSION (u'\x01\00')
6757     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
6758     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
6759     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
6760     """
6761     existing_data = b""
6762     policy_data = _policy_info()
6763     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
6764     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6765     adml_policy_resources = _get_policy_resources(language=adml_language)
6766     base_policy_settings = _checkAllAdmxPolicies(
6767         policy_class=registry_class,
6768         adml_language=adml_language,
6769         return_full_policy_names=False,
6770         hierarchical_return=False,
6771         return_not_configured=False,
6772     )
6773     for adm_namespace in admtemplate_data:
6774         for adm_policy in admtemplate_data[adm_namespace]:
6775             if (
6776                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
6777                 == "not configured"
6778             ):
6779                 if (
6780                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
6781                     is not None
6782                 ):
6783                     log.trace('Policy "%s" removed', adm_policy)
6784             else:
6785                 log.trace("adding %s to base_policy_settings", adm_policy)
6786                 if adm_namespace not in base_policy_settings:
6787                     base_policy_settings[adm_namespace] = {}
6788                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
6789                     adm_namespace
6790                 ][adm_policy]
6791     for adm_namespace in base_policy_settings:
6792         for admPolicy in base_policy_settings[adm_namespace]:
6793             log.trace("working on admPolicy %s", admPolicy)
6794             explicit_enable_disable_value_setting = False
6795             this_key = None
6796             this_valuename = None
6797             if (
6798                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
6799                 == "disabled"
6800             ):
6801                 log.trace("time to disable %s", admPolicy)
6802                 this_policy = admx_policy_definitions.xpath(
6803                     policySearchXpath.format(admPolicy),
6804                     namespaces={"ns1": adm_namespace},
6805                 )
6806                 if this_policy:
6807                     this_policy = this_policy[0]
6808                     if "class" in this_policy.attrib:
6809                         if (
6810                             this_policy.attrib["class"] == registry_class
6811                             or this_policy.attrib["class"] == "Both"
6812                         ):
6813                             if "key" in this_policy.attrib:
6814                                 this_key = this_policy.attrib["key"]
6815                             else:
6816                                 log.error(
6817                                     "policy item %s does not have "
6818                                     'the required "key" attribute',
6819                                     this_policy.attrib,
6820                                 )
6821                                 break
6822                             if "valueName" in this_policy.attrib:
6823                                 this_valuename = this_policy.attrib["valueName"]
6824                             if DISABLED_VALUE_XPATH(this_policy):
6825                                 explicit_enable_disable_value_setting = True
6826                                 disabled_value_string = _checkValueItemParent(
6827                                     this_policy,
6828                                     admPolicy,
6829                                     this_key,
6830                                     this_valuename,
6831                                     DISABLED_VALUE_XPATH,
6832                                     None,
6833                                     check_deleted=False,
6834                                     test_item=False,
6835                                 )
6836                                 existing_data = _policyFileReplaceOrAppend(
6837                                     disabled_value_string, existing_data
6838                                 )
6839                             if DISABLED_LIST_XPATH(this_policy):
6840                                 explicit_enable_disable_value_setting = True
6841                                 disabled_list_strings = _checkListItem(
6842                                     this_policy,
6843                                     admPolicy,
6844                                     this_key,
6845                                     DISABLED_LIST_XPATH,
6846                                     None,
6847                                     test_items=False,
6848                                 )
6849                                 log.trace(
6850                                     "working with disabledList portion of %s",
6851                                     admPolicy,
6852                                 )
6853                                 existing_data = _policyFileReplaceOrAppendList(
6854                                     disabled_list_strings, existing_data
6855                                 )
6856                             if (
6857                                 not explicit_enable_disable_value_setting
6858                                 and this_valuename
6859                             ):
6860                                 disabled_value_string = _buildKnownDataSearchString(
6861                                     this_key,
6862                                     this_valuename,
6863                                     "REG_DWORD",
6864                                     None,
6865                                     check_deleted=True,
6866                                 )
6867                                 existing_data = _policyFileReplaceOrAppend(
6868                                     disabled_value_string, existing_data
6869                                 )
6870                             if ELEMENTS_XPATH(this_policy):
6871                                 log.trace("checking elements of %s", admPolicy)
6872                                 for elements_item in ELEMENTS_XPATH(this_policy):
6873                                     for child_item in elements_item:
6874                                         child_key = this_key
6875                                         child_valuename = this_valuename
6876                                         if "key" in child_item.attrib:
6877                                             child_key = child_item.attrib["key"]
6878                                         if "valueName" in child_item.attrib:
6879                                             child_valuename = child_item.attrib[
6880                                                 "valueName"
6881                                             ]
6882                                         if etree.QName(
6883                                             child_item
6884                                         ).localname == "boolean" and (
6885                                             TRUE_LIST_XPATH(child_item)
6886                                             or FALSE_LIST_XPATH(child_item)
6887                                         ):
6888                                             temp_dict = {
6889                                                 "trueList": TRUE_LIST_XPATH,
6890                                                 "falseList": FALSE_LIST_XPATH,
6891                                             }
6892                                             for this_list in temp_dict:
6893                                                 disabled_list_strings = _checkListItem(
6894                                                     child_item,
6895                                                     admPolicy,
6896                                                     child_key,
6897                                                     temp_dict[this_list],
6898                                                     None,
6899                                                     test_items=False,
6900                                                 )
6901                                                 log.trace(
6902                                                     "working with %s portion of %s",
6903                                                     admPolicy,
6904                                                     this_list,
6905                                                 )
6906                                                 existing_data = (
6907                                                     _policyFileReplaceOrAppendList(
6908                                                         disabled_list_strings,
6909                                                         existing_data,
6910                                                     )
6911                                                 )
6912                                         elif (
6913                                             etree.QName(child_item).localname
6914                                             == "boolean"
6915                                             or etree.QName(child_item).localname
6916                                             == "decimal"
6917                                             or etree.QName(child_item).localname
6918                                             == "text"
6919                                             or etree.QName(child_item).localname
6920                                             == "longDecimal"
6921                                             or etree.QName(child_item).localname
6922                                             == "multiText"
6923                                             or etree.QName(child_item).localname
6924                                             == "enum"
6925                                         ):
6926                                             disabled_value_string = _processValueItem(
6927                                                 child_item,
6928                                                 child_key,
6929                                                 child_valuename,
6930                                                 this_policy,
6931                                                 elements_item,
6932                                                 check_deleted=True,
6933                                             )
6934                                             log.trace(
6935                                                 "I have disabled value string of %s",
6936                                                 disabled_value_string,
6937                                             )
6938                                             existing_data = _policyFileReplaceOrAppend(
6939                                                 disabled_value_string, existing_data
6940                                             )
6941                                         elif (
6942                                             etree.QName(child_item).localname == "list"
6943                                         ):
6944                                             disabled_value_string = _processValueItem(
6945                                                 child_item,
6946                                                 child_key,
6947                                                 child_valuename,
6948                                                 this_policy,
6949                                                 elements_item,
6950                                                 check_deleted=True,
6951                                             )
6952                                             log.trace(
6953                                                 "I have disabled value string of %s",
6954                                                 disabled_value_string,
6955                                             )
6956                                             existing_data = _policyFileReplaceOrAppend(
6957                                                 disabled_value_string, existing_data
6958                                             )
6959                         else:
6960                             log.error(
6961                                 "policy %s was found but it does not appear to be valid"
6962                                 " for the class %s",
6963                                 admPolicy,
6964                                 registry_class,
6965                             )
6966                     else:
6967                         log.error(
6968                             'policy item %s does not have the required "class"'
6969                             " attribute",
6970                             this_policy.attrib,
6971                         )
6972             else:
6973                 log.trace('time to enable and set the policy "%s"', admPolicy)
6974                 this_policy = admx_policy_definitions.xpath(
6975                     policySearchXpath.format(admPolicy),
6976                     namespaces={"ns1": adm_namespace},
6977                 )
6978                 log.trace("found this_policy == %s", this_policy)
6979                 if this_policy:
6980                     this_policy = this_policy[0]
6981                     if "class" in this_policy.attrib:
6982                         if (
6983                             this_policy.attrib["class"] == registry_class
6984                             or this_policy.attrib["class"] == "Both"
6985                         ):
6986                             if "key" in this_policy.attrib:
6987                                 this_key = this_policy.attrib["key"]
6988                             else:
6989                                 log.error(
6990                                     'policy item %s does not have the required "key"'
6991                                     " attribute",
6992                                     this_policy.attrib,
6993                                 )
6994                                 break
6995                             if "valueName" in this_policy.attrib:
6996                                 this_valuename = this_policy.attrib["valueName"]
6997                             if ENABLED_VALUE_XPATH(this_policy):
6998                                 explicit_enable_disable_value_setting = True
6999                                 enabled_value_string = _checkValueItemParent(
7000                                     this_policy,
7001                                     admPolicy,
7002                                     this_key,
7003                                     this_valuename,
7004                                     ENABLED_VALUE_XPATH,
7005                                     None,
7006                                     check_deleted=False,
7007                                     test_item=False,
7008                                 )
7009                                 existing_data = _policyFileReplaceOrAppend(
7010                                     enabled_value_string, existing_data
7011                                 )
7012                             if ENABLED_LIST_XPATH(this_policy):
7013                                 explicit_enable_disable_value_setting = True
7014                                 enabled_list_strings = _checkListItem(
7015                                     this_policy,
7016                                     admPolicy,
7017                                     this_key,
7018                                     ENABLED_LIST_XPATH,
7019                                     None,
7020                                     test_items=False,
7021                                 )
7022                                 log.trace(
7023                                     "working with enabledList portion of %s", admPolicy
7024                                 )
7025                                 existing_data = _policyFileReplaceOrAppendList(
7026                                     enabled_list_strings, existing_data
7027                                 )
7028                             if (
7029                                 not explicit_enable_disable_value_setting
7030                                 and this_valuename
7031                             ):
7032                                 enabled_value_string = _buildKnownDataSearchString(
7033                                     this_key,
7034                                     this_valuename,
7035                                     "REG_DWORD",
7036                                     "1",
7037                                     check_deleted=False,
7038                                 )
7039                                 existing_data = _policyFileReplaceOrAppend(
7040                                     enabled_value_string, existing_data
7041                                 )
7042                             if ELEMENTS_XPATH(this_policy):
7043                                 for elements_item in ELEMENTS_XPATH(this_policy):
7044                                     for child_item in elements_item:
7045                                         child_key = this_key
7046                                         child_valuename = this_valuename
7047                                         if "key" in child_item.attrib:
7048                                             child_key = child_item.attrib["key"]
7049                                         if "valueName" in child_item.attrib:
7050                                             child_valuename = child_item.attrib[
7051                                                 "valueName"
7052                                             ]
7053                                         if (
7054                                             child_item.attrib["id"]
7055                                             in base_policy_settings[adm_namespace][
7056                                                 admPolicy
7057                                             ]
7058                                         ):
7059                                             if etree.QName(
7060                                                 child_item
7061                                             ).localname == "boolean" and (
7062                                                 TRUE_LIST_XPATH(child_item)
7063                                                 or FALSE_LIST_XPATH(child_item)
7064                                             ):
7065                                                 list_strings = []
7066                                                 if base_policy_settings[adm_namespace][
7067                                                     admPolicy
7068                                                 ][child_item.attrib["id"]]:
7069                                                     list_strings = _checkListItem(
7070                                                         child_item,
7071                                                         admPolicy,
7072                                                         child_key,
7073                                                         TRUE_LIST_XPATH,
7074                                                         None,
7075                                                         test_items=False,
7076                                                     )
7077                                                     log.trace(
7078                                                         "working with trueList portion"
7079                                                         " of %s",
7080                                                         admPolicy,
7081                                                     )
7082                                                 else:
7083                                                     list_strings = _checkListItem(
7084                                                         child_item,
7085                                                         admPolicy,
7086                                                         child_key,
7087                                                         FALSE_LIST_XPATH,
7088                                                         None,
7089                                                         test_items=False,
7090                                                     )
7091                                                 existing_data = (
7092                                                     _policyFileReplaceOrAppendList(
7093                                                         list_strings, existing_data
7094                                                     )
7095                                                 )
7096                                             elif etree.QName(
7097                                                 child_item
7098                                             ).localname == "boolean" and (
7099                                                 TRUE_VALUE_XPATH(child_item)
7100                                                 or FALSE_VALUE_XPATH(child_item)
7101                                             ):
7102                                                 value_string = ""
7103                                                 if base_policy_settings[adm_namespace][
7104                                                     admPolicy
7105                                                 ][child_item.attrib["id"]]:
7106                                                     value_string = (
7107                                                         _checkValueItemParent(
7108                                                             child_item,
7109                                                             admPolicy,
7110                                                             child_key,
7111                                                             child_valuename,
7112                                                             TRUE_VALUE_XPATH,
7113                                                             None,
7114                                                             check_deleted=False,
7115                                                             test_item=False,
7116                                                         )
7117                                                     )
7118                                                 else:
7119                                                     value_string = (
7120                                                         _checkValueItemParent(
7121                                                             child_item,
7122                                                             admPolicy,
7123                                                             child_key,
7124                                                             child_valuename,
7125                                                             FALSE_VALUE_XPATH,
7126                                                             None,
7127                                                             check_deleted=False,
7128                                                             test_item=False,
7129                                                         )
7130                                                     )
7131                                                 existing_data = (
7132                                                     _policyFileReplaceOrAppend(
7133                                                         value_string, existing_data
7134                                                     )
7135                                                 )
7136                                             elif (
7137                                                 etree.QName(child_item).localname
7138                                                 == "boolean"
7139                                                 or etree.QName(child_item).localname
7140                                                 == "decimal"
7141                                                 or etree.QName(child_item).localname
7142                                                 == "text"
7143                                                 or etree.QName(child_item).localname
7144                                                 == "longDecimal"
7145                                                 or etree.QName(child_item).localname
7146                                                 == "multiText"
7147                                             ):
7148                                                 enabled_value_string = _processValueItem(
7149                                                     child_item,
7150                                                     child_key,
7151                                                     child_valuename,
7152                                                     this_policy,
7153                                                     elements_item,
7154                                                     check_deleted=False,
7155                                                     this_element_value=base_policy_settings[
7156                                                         adm_namespace
7157                                                     ][
7158                                                         admPolicy
7159                                                     ][
7160                                                         child_item.attrib["id"]
7161                                                     ],
7162                                                 )
7163                                                 log.trace(
7164                                                     "I have enabled value string of %s",
7165                                                     enabled_value_string,
7166                                                 )
7167                                                 existing_data = (
7168                                                     _policyFileReplaceOrAppend(
7169                                                         enabled_value_string,
7170                                                         existing_data,
7171                                                     )
7172                                                 )
7173                                             elif (
7174                                                 etree.QName(child_item).localname
7175                                                 == "enum"
7176                                             ):
7177                                                 for enum_item in child_item:
7178                                                     if (
7179                                                         base_policy_settings[
7180                                                             adm_namespace
7181                                                         ][admPolicy][
7182                                                             child_item.attrib["id"]
7183                                                         ]
7184                                                         == _getAdmlDisplayName(
7185                                                             adml_policy_resources,
7186                                                             enum_item.attrib[
7187                                                                 "displayName"
7188                                                             ],
7189                                                         ).strip()
7190                                                     ):
7191                                                         enabled_value_string = (
7192                                                             _checkValueItemParent(
7193                                                                 enum_item,
7194                                                                 child_item.attrib["id"],
7195                                                                 child_key,
7196                                                                 child_valuename,
7197                                                                 VALUE_XPATH,
7198                                                                 None,
7199                                                                 check_deleted=False,
7200                                                                 test_item=False,
7201                                                             )
7202                                                         )
7203                                                         existing_data = (
7204                                                             _policyFileReplaceOrAppend(
7205                                                                 enabled_value_string,
7206                                                                 existing_data,
7207                                                             )
7208                                                         )
7209                                                         if VALUE_LIST_XPATH(enum_item):
7210                                                             enabled_list_strings = (
7211                                                                 _checkListItem(
7212                                                                     enum_item,
7213                                                                     admPolicy,
7214                                                                     child_key,
7215                                                                     VALUE_LIST_XPATH,
7216                                                                     None,
7217                                                                     test_items=False,
7218                                                                 )
7219                                                             )
7220                                                             log.trace(
7221                                                                 "working with valueList"
7222                                                                 " portion of %s",
7223                                                                 child_item.attrib["id"],
7224                                                             )
7225                                                             existing_data = _policyFileReplaceOrAppendList(
7226                                                                 enabled_list_strings,
7227                                                                 existing_data,
7228                                                             )
7229                                                         break
7230                                             elif (
7231                                                 etree.QName(child_item).localname
7232                                                 == "list"
7233                                             ):
7234                                                 enabled_value_string = _processValueItem(
7235                                                     child_item,
7236                                                     child_key,
7237                                                     child_valuename,
7238                                                     this_policy,
7239                                                     elements_item,
7240                                                     check_deleted=False,
7241                                                     this_element_value=base_policy_settings[
7242                                                         adm_namespace
7243                                                     ][
7244                                                         admPolicy
7245                                                     ][
7246                                                         child_item.attrib["id"]
7247                                                     ],
7248                                                 )
7249                                                 log.trace(
7250                                                     "I have enabled value string of %s",
7251                                                     enabled_value_string,
7252                                                 )
7253                                                 existing_data = (
7254                                                     _policyFileReplaceOrAppend(
7255                                                         enabled_value_string,
7256                                                         existing_data,
7257                                                         append_only=True,
7258                                                     )
7259                                                 )
7260     try:
7261         _write_regpol_data(
7262             existing_data,
7263             policy_data.admx_registry_classes[registry_class]["policy_path"],
7264             policy_data.gpt_ini_path,
7265             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7266             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7267         )
7268     except CommandExecutionError as exc:  # pylint: disable=broad-except
7269         log.exception(
7270             "Unhandled exception occurred while attempting to "
7271             "write Adm Template Policy File.\nException: %s",
7272             exc,
7273         )
7274         return False
7275     return True
7276 def _getScriptSettingsFromIniFile(policy_info):
7277     _existingData = None
7278     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7279         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7280             _existingData = fhr.read()
7281         if _existingData:
7282             try:
7283                 _existingData = deserialize(
7284                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7285                 )
7286                 log.trace("Have deserialized data %s", _existingData)
7287             except Exception as error:  # pylint: disable=broad-except
7288                 log.exception(
7289                     "An error occurred attempting to deserialize data for %s",
7290                     policy_info["Policy"],
7291                 )
7292                 raise CommandExecutionError(error)
7293             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7294                 "Section"
7295             ].lower() in [z.lower() for z in _existingData.keys()]:
7296                 if "SettingName" in policy_info["ScriptIni"]:
7297                     log.trace(
7298                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7299                     )
7300                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7301                         z.lower()
7302                         for z in _existingData[
7303                             policy_info["ScriptIni"]["Section"]
7304                         ].keys()
7305                     ]:
7306                         return _existingData[policy_info["ScriptIni"]["Section"]][
7307                             policy_info["ScriptIni"]["SettingName"].lower()
7308                         ]
7309                     else:
7310                         return None
7311                 else:
7312                     return _existingData[policy_info["ScriptIni"]["Section"]]
7313             else:
7314                 return None
7315     return None
7316 def _writeGpoScript(psscript=False):
7317     _machineScriptPolicyPath = os.path.join(
7318         os.getenv("WINDIR"),
7319         "System32",
7320         "GroupPolicy",
7321         "Machine",
7322         "Scripts",
7323         "scripts.ini",
7324     )
7325     _machinePowershellScriptPolicyPath = os.path.join(
7326         os.getenv("WINDIR"),
7327         "System32",
7328         "GroupPolicy",
7329         "Machine",
7330         "Scripts",
7331         "psscripts.ini",
7332     )
7333     _userScriptPolicyPath = os.path.join(
7334         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7335     )
7336     _userPowershellScriptPolicyPath = os.path.join(
7337         os.getenv("WINDIR"),
7338         "System32",
7339         "GroupPolicy",
7340         "User",
7341         "Scripts",
7342         "psscripts.ini",
7343     )
7344 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7345     policy_aliases = []
7346     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7347     adml_policy_resources = _get_policy_resources(language=adml_language)
7348     admx_search_results = ADMX_SEARCH_XPATH(
7349         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7350     )
7351     if admx_search_results:
7352         if len(admx_search_results) == 1:
7353             the_policy = admx_search_results[0]
7354             policy_display_name = _getFullPolicyName(
7355                 policy_item=the_policy,
7356                 policy_name=the_policy.attrib["name"],
7357                 return_full_policy_names=True,
7358                 adml_language=adml_language,
7359             )
7360             policy_aliases.append(policy_display_name)
7361             policy_aliases.append(the_policy.attrib["name"])
7362             full_path_list = _build_parent_list(
7363                 policy_definition=the_policy,
7364                 return_full_policy_names=True,
7365                 adml_language=adml_language,
7366             )
7367             full_path_list.reverse()
7368             full_path_list.append(policy_display_name)
7369             policy_aliases.append("\\".join(full_path_list))
7370             return True, the_policy, policy_aliases, None
7371         else:
7372             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7373             return False, None, [], msg
7374     else:
7375         adml_search_results = ADML_SEARCH_XPATH(
7376             adml_policy_resources, policy_name=policy_name
7377         )
7378         hierarchy = []
7379         hierarchy_policy_name = policy_name
7380         if not adml_search_results:
7381             log.warning("Trying another: %s", policy_name)
7382             if "\\" in policy_name:
7383                 hierarchy = policy_name.split("\\")
7384                 policy_name = hierarchy.pop()
7385                 adml_search_results = ADML_SEARCH_XPATH(
7386                     adml_policy_resources, policy_name=policy_name
7387                 )
7388         if adml_search_results:
7389             multiple_adml_entries = False
7390             suggested_policies = ""
7391             adml_to_remove = []
7392             if len(adml_search_results) &gt; 1:
7393                 log.trace(
7394                     "multiple ADML entries found matching the policy name %s",
7395                     policy_name,
7396                 )
7397                 multiple_adml_entries = True
7398                 for adml_search_result in adml_search_results:
7399                     if (
7400                         not getattr(adml_search_result, "text", "").strip()
7401                         == policy_name
7402                     ):
7403 <a name="20"></a>                        adml_to_remove.append(adml_search_result)
7404                     else:
7405                         if hierarchy:
7406                             log<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("we have hierarchy of %s", hierarchy)
7407                             display_name_searchval = "$({}.{})".format(
7408                                 adml_search_result.tag.split("}")[1],
7409                                 adml_search_result.attrib["id"],
7410                             )
7411                             policy_search_string =</b></font> (
7412                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7413                                 ' or @class = "{}") ]'.format(
7414                                     adml_search_result.prefix,
7415                                     display_name_searchval,
7416                                     policy_class,
7417                                 )
7418                             )
7419                             admx_results = []
7420                             these_admx_search_results = admx_policy_definitions.xpath(
7421                                 policy_search_string,
7422                                 namespaces=adml_search_result.nsmap,
7423                             )
7424                             if not these_admx_search_results:
7425                                 log.trace(
7426                                     "No admx was found for the adml entry %s, it will"
7427                                     " be removed",
7428                                     display_name_searchval,
7429                                 )
7430                                 adml_to_remove.append(adml_search_result)
7431                             for search_result in these_admx_search_results:
7432                                 log.trace("policy_name == %s", policy_name)
7433                                 this_hierarchy = _build_parent_list(
7434                                     policy_definition=search_result,
7435                                     return_full_policy_names=True,
7436                                     adml_language=adml_language,
7437                                 )
7438                                 this_hierarchy.reverse()
7439                                 if hierarchy != this_hierarchy:
7440                                     log.trace(
7441                                         "hierarchy %s does not match this item's"
7442                                         " hierarchy of %s",
7443                                         hierarchy,
7444                                         this_hierarchy,
7445                                     )
7446                                     if len(these_admx_search_results) == 1:
7447                                         log.trace(
7448                                             "only 1 admx was found and it does not "
7449                                             "match this adml, it is safe to remove "
7450                                             "from the list"
7451                                         )
7452                                         adml_to_remove.append(adml_search_result)
7453                                 else:
7454                                     log.trace(
7455                                         "hierarchy %s matches item's hierarchy of %s",
7456                                         hierarchy,
7457                                         this_hierarchy,
7458                                     )
7459                                     log.trace(
7460                                         "search_result %s added to results",
7461                                         search_result,
7462                                     )
7463                                     admx_results.append(search_result)
7464                             if len(admx_results) == 1:
7465                                 admx_search_results.append(admx_results[0])
7466                         else:
7467                             display_name_searchval = "$({}.{})".format(
7468                                 adml_search_result.tag.split("}")[1],
7469                                 adml_search_result.attrib["id"],
7470                             )
7471                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7472                                 admx_policy_definitions,
7473                                 display_name=display_name_searchval,
7474                                 registry_class=policy_class,
7475                             )
7476                             if not these_admx_search_results:
7477                                 adml_to_remove.append(adml_search_result)
7478             for adml in adml_to_remove:
7479                 if adml in adml_search_results:
7480                     adml_search_results.remove(adml)
7481             if len(adml_search_results) == 1 and multiple_adml_entries:
7482                 multiple_adml_entries = False
7483             for adml_search_result in adml_search_results:
7484                 log.trace(
7485                     "found an ADML entry matching the string! %s -- %s",
7486                     adml_search_result.tag,
7487                     adml_search_result.attrib,
7488                 )
7489                 display_name_searchval = "$({}.{})".format(
7490                     adml_search_result.tag.split("}")[1],
7491                     adml_search_result.attrib["id"],
7492                 )
7493                 log.trace("searching for displayName == %s", display_name_searchval)
7494                 if not admx_search_results:
7495                     log.trace(
7496                         "search for an admx entry matching display_name %s and"
7497                         " registry_class %s",
7498                         display_name_searchval,
7499                         policy_class,
7500                     )
7501                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7502                         admx_policy_definitions,
7503                         display_name=display_name_searchval,
7504                         registry_class=policy_class,
7505                     )
7506                 if admx_search_results:
7507                     log.trace(
7508                         "processing admx_search_results of %s", admx_search_results
7509                     )
7510                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7511                     if (
7512                         len(admx_search_results) == 1 or hierarchy
7513                     ) and not multiple_adml_entries:
7514                         found = False
7515                         for search_result in admx_search_results:
7516                             found = False
7517                             if hierarchy:
7518                                 this_hierarchy = _build_parent_list(
7519                                     policy_definition=search_result,
7520                                     return_full_policy_names=True,
7521                                     adml_language=adml_language,
7522                                 )
7523                                 this_hierarchy.reverse()
7524                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7525                                 if hierarchy == this_hierarchy:
7526                                     found = True
7527                             else:
7528                                 found = True
7529                             if found:
7530                                 log.trace(
7531                                     "found the ADMX policy matching "
7532                                     "the display name %s -- %s",
7533                                     search_result,
7534                                     policy_name,
7535                                 )
7536                                 if "name" in search_result.attrib:
7537                                     policy_display_name = _getFullPolicyName(
7538                                         policy_item=search_result,
7539                                         policy_name=search_result.attrib["name"],
7540                                         return_full_policy_names=True,
7541                                         adml_language=adml_language,
7542                                     )
7543                                     policy_aliases.append(policy_display_name)
7544                                     policy_aliases.append(search_result.attrib["name"])
7545                                     full_path_list = _build_parent_list(
7546                                         policy_definition=search_result,
7547                                         return_full_policy_names=True,
7548                                         adml_language=adml_language,
7549                                     )
7550                                     full_path_list.reverse()
7551                                     full_path_list.append(policy_display_name)
7552                                     policy_aliases.append("\\".join(full_path_list))
7553                                     return True, search_result, policy_aliases, None
7554                                 else:
7555                                     msg = (
7556                                         "ADMX policy with the display name {} does not"
7557                                         "have the required name attribute"
7558                                     )
7559                                     msg = msg.format(policy_name)
7560                                     return False, None, [], msg
7561                         if not found:
7562                             msg = "Unable to correlate {} to any policy".format(
7563                                 hierarchy_policy_name
7564                             )
7565                             return False, None, [], msg
7566                     else:
7567                         for possible_policy in admx_search_results:
7568                             this_parent_list = _build_parent_list(
7569                                 policy_definition=possible_policy,
7570                                 return_full_policy_names=True,
7571                                 adml_language=adml_language,
7572                             )
7573                             this_parent_list.reverse()
7574                             this_parent_list.append(policy_name)
7575                             if suggested_policies:
7576                                 suggested_policies = ", ".join(
7577                                     [suggested_policies, "\\".join(this_parent_list)]
7578                                 )
7579                             else:
7580                                 suggested_policies = "\\".join(this_parent_list)
7581             if suggested_policies:
7582                 msg = (
7583                     'ADML policy name "{}" is used as the display name for '
7584                     "multiple policies. These policies matched: {}. You can "
7585                     "utilize these long names to specify the correct policy"
7586                 )
7587                 return False, None, [], msg.format(policy_name, suggested_policies)
7588     return (
7589         False,
7590         None,
7591         [],
7592         "Unable to find {} policy {}".format(policy_class, policy_name),
7593     )
7594 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
7595     r"""
7596     Returns information about a specified policy
7597     Args:
7598         policy_name (str):
7599             The name of the policy to lookup
7600         policy_class (str):
7601             The class of policy, i.e. machine, user, both
7602         adml_language (str):
7603             The ADML language to use for Administrative Template data lookup
7604     Returns:
7605         dict: Information about the specified policy
7606     CLI Example:
7607     .. code-block:: bash
7608         salt '*' lgpo.get_policy_info 'Maximum password age' machine
7609     You can use ``lgpo.get_policy_info`` to get all the possible names that
7610     could be used in a state file or from the command line (along with elements
7611     that need to be set/etc). The key is to match the text you see in the
7612     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
7613     "full path" style is really only needed when there are multiple policies
7614     that use the same base name. For example, ``Access data sources across
7615     domains`` exists in ~10 different paths. If you put that through
7616     ``get_policy_info`` you'll get back a message that it is used for multiple
7617     policies and you need to be more specific.
7618     CLI Example:
7619     .. code-block:: bash
7620         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
7621         local:
7622             ----------
7623             message:
7624             policy_aliases:
7625                 - Turn off the "Order Prints" picture task
7626                 - ShellRemoveOrderPrints_2
7627                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7628             policy_class:
7629                 machine
7630             policy_elements:
7631             policy_found:
7632                 True
7633             policy_name:
7634                 ShellRemoveOrderPrints_2
7635             rights_assignment:
7636                 False
7637     Escaping can get tricky in cmd/Powershell. The following is an example of
7638     escaping in Powershell using backquotes:
7639     .. code-block:: bash
7640         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
7641         local:
7642             ----------
7643             message:
7644             policy_aliases:
7645                 - Turn off the "Order Prints" picture task
7646                 - ShellRemoveOrderPrints_2
7647                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7648             policy_class:
7649                 machine
7650             policy_elements:
7651             policy_found:
7652                 True
7653             policy_name:
7654                 Turn off the "Order Prints" picture task
7655             rights_assignment:
7656                 False
7657     This function can then be used to get the options available for specifying
7658     Group Policy Objects to be used in state files. Based on the above any of
7659     these *should* be usable:
7660     .. code-block:: bash
7661         internet_communications_settings:
7662           lgpo.set:
7663             - computer_policy:
7664                 Turn off the "Order Prints" picture task: Enabled
7665     .. code-block:: bash
7666         internet_communications_settings:
7667           lgpo.set:
7668             - computer_policy:
7669                 ShellRemoveOrderPrints_2: Enabled
7670     When using the full path, it might be a good idea to use single quotes
7671     around the path:
7672     .. code-block:: bash
7673         internet_communications_settings:
7674           lgpo.set:
7675             - computer_policy:
7676                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
7677     If you struggle to find the policy from ``get_policy_info`` using the name
7678     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
7679     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
7680     relationships (ADML holds what you see in the GUI, ADMX holds the more
7681     technical details), then this may be a little bit too much info, but here is
7682     an example with the above policy using Powershell:
7683     .. code-block:: bash
7684         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
7685         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
7686         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
7687         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
7688         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
7689     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
7690     string used to describe this policy, then we search for it in the ADMX:
7691     .. code-block:: bash
7692         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
7693         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7694         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7695     Now we have two to pick from. And if you notice the ``class="Machine"`` and
7696     ``class="User"`` (which details if it is a computer policy or user policy
7697     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
7698     use to pass through ``get_policy_info`` to see what the module itself is
7699     expecting.
7700     Get a policy value
7701     Args:
7702         policy_class (str):
7703             Some policies are both user and computer, by default all policies
7704             will be pulled, but this can be used to retrieve only a specific
7705             policy class User/USER/user = retrieve user policies
7706             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
7707             machine/computer policies
7708         return_full_policy_names (bool):
7709             True/False to return the policy name as it is seen in the
7710             ``gpedit.msc`` GUI or to only return the policy key/id.
7711         hierarchical_return (bool):
7712             True/False to return the policy data in the hierarchy as seen in the
7713             ``gpedit.msc`` GUI. The default of False will return data split only
7714             into User/Computer configuration sections
7715         adml_language (str):
7716             The ADML language to use for processing display/descriptive names
7717             and enumeration values of ADMX template data, defaults to en-US
7718         return_not_configured (bool):
7719             Include Administrative Template policies that are 'Not Configured'
7720             in the return data
7721     Returns:
7722         dict: A dictionary containing the policy values for the specified class
7723     CLI Example:
7724     .. code-block:: bash
7725         salt '*' lgpo.get machine return_full_policy_names=True
7726     Some policies are defined in this module and others by the ADMX/ADML files
7727     on the machine. This function loads the current values for policies defined
7728     in this module.
7729     Args:
7730         policy_definition (dict):
7731             A sub-dict of Policies property of the _policy_info() class.
7732             Basically a dictionary that defines the policy
7733     Returns:
7734         The transformed value. The transform is defined in the policy
7735         definition. It can be a list, a string, a dictionary, depending on how
7736         it's defined
7737     Usage:
7738         policy_data = _policy_info()
7739         policy_name = 'RemoteRegistryExactPaths'
7740         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
7741         policy_value = _get_policy_info_setting(policy_definition)
7742     Get the current setting for polices set via the policy templates (ADMX/ADML)
7743     files
7744     Args:
7745         admx_policy (obj):
7746             The XPath object as returned by the ``_lookup_admin_template``
7747             function
7748         policy_class (str):
7749             The policy class. Must be one of ``machine`` or ``user``
7750         adml_language (str):
7751             The language code for the adml file to use for localization. The
7752             default is ``en-US``
7753         return_full_policy_names (bool):
7754             Returns the full policy name regardless of what was passed in
7755             ``policy_name``
7756         hierarchical_return (bool):
7757             Returns a hierarchical view of the policy showing its parents
7758     Returns:
7759         dict: A dictionary containing the policy settings
7760     Usage:
7761         policy_name = 'AutoUpdateCfg'
7762         policy_class = 'machine'
7763         adml_language = 'en-US'
7764         success, policy_obj, _, _ = _lookup_admin_template(
7765             policy_name=policy_name,
7766             policy_class=policy_class,
7767             adml_language=adml_language)
7768         if success:
7769             setting = _get_policy_adm_setting(
7770                 admx_policy=policy_obj,
7771                 policy_class=policy_class,
7772                 adml_language=adml_language,
7773                 return_full_policy_names=return_full_policy_names,
7774                 hierarchical_return=hierarchical_return
7775             )
7776     this_policy_name = admx_policy.attrib<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("name", None)
7777     if this_key is None or this_policy_name is None:
7778         raise CommandExecutionError(
7779             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
7780                 admx_policy.attrib
7781             )
7782         )
7783     this_value_name = admx_policy.attrib.get("valueName", None)
7784     this_policy_setting =</b></font> "Not Configured"
7785     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
7786     element_only_enabled_disabled = True
7787     explicit_enable_disable_value_setting = False
7788     policy_data = _policy_info()
7789     policy_file_data = _read_regpol_file(
7790         policy_data.admx_registry_classes[policy_class]["policy_path"]
7791     )
7792     adml_policy_resources = _get_policy_resources(language=adml_language)
7793     policy_vals = {}
7794     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
7795         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
7796             element_only_enabled_disabled = False
7797             explicit_enable_disable_value_setting = True
7798             if _checkValueItemParent(
7799                 policy_element=admx_policy,
7800                 policy_name=this_policy_name,
7801                 policy_key=this_key,
7802                 policy_valueName=this_value_name,
7803                 xpath_object=ENABLED_VALUE_XPATH,
7804                 policy_file_data=policy_file_data,
7805             ):
7806                 log.trace(
7807                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
7808                 )
7809                 this_policy_setting = "Enabled"
7810                 policy_vals.setdefault(this_policy_namespace, {})[
7811                     this_policy_name
7812                 ] = this_policy_setting
7813     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
7814         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
7815             element_only_enabled_disabled = False
7816             explicit_enable_disable_value_setting = True
7817             if _checkValueItemParent(
7818                 policy_element=admx_policy,
7819                 policy_name=this_policy_name,
7820                 policy_key=this_key,
7821                 policy_valueName=this_value_name,
7822                 xpath_object=DISABLED_VALUE_XPATH,
7823                 policy_file_data=policy_file_data,
7824             ):
7825                 log.trace(
7826                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
7827                 )
7828                 this_policy_setting = "Disabled"
7829                 policy_vals.setdefault(this_policy_namespace, {})[
7830                     this_policy_name
7831                 ] = this_policy_setting
7832     if ENABLED_LIST_XPATH(admx_policy):
7833         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
7834             element_only_enabled_disabled = False
7835             explicit_enable_disable_value_setting = True
7836             if _checkListItem(
7837                 policy_element=admx_policy,
7838                 policy_name=this_policy_name,
7839                 policy_key=this_key,
7840                 xpath_object=ENABLED_LIST_XPATH,
7841                 policy_file_data=policy_file_data,
7842             ):
7843                 log.trace(
7844                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
7845                 )
7846                 this_policy_setting = "Enabled"
7847                 policy_vals.setdefault(this_policy_namespace, {})[
7848                     this_policy_name
7849                 ] = this_policy_setting
7850     if DISABLED_LIST_XPATH(admx_policy):
7851         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
7852             element_only_enabled_disabled = False
7853             explicit_enable_disable_value_setting = True
7854             if _checkListItem(
7855                 policy_element=admx_policy,
7856                 policy_name=this_policy_name,
7857                 policy_key=this_key,
7858                 xpath_object=DISABLED_LIST_XPATH,
7859                 policy_file_data=policy_file_data,
7860             ):
7861                 log.trace(
7862                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
7863                 )
7864                 this_policy_setting = "Disabled"
7865                 policy_vals.setdefault(this_policy_namespace, {})[
7866                     this_policy_name
7867                 ] = this_policy_setting
7868     if not explicit_enable_disable_value_setting and this_value_name:
7869         if _regexSearchRegPolData(
7870             re.escape(
7871                 _buildKnownDataSearchString(
7872                     reg_key=this_key,
7873                     reg_valueName=this_value_name,
7874                     reg_vtype="REG_DWORD",
7875                     reg_data="1",
7876                 )
7877             ),
7878             policy_file_data,
7879         ):
7880             log.trace(
7881                 "%s is enabled by no explicit enable/disable list or value",
7882                 this_policy_name,
7883             )
7884             this_policy_setting = "Enabled"
7885             policy_vals.setdefault(this_policy_namespace, {})[
7886                 this_policy_name
7887             ] = this_policy_setting
7888         elif _regexSearchRegPolData(
7889             re.escape(
7890                 _buildKnownDataSearchString(
7891                     reg_key=this_key,
7892                     reg_valueName=this_value_name,
7893                     reg_vtype="REG_DWORD",
7894                     reg_data=None,
7895                     check_deleted=True,
7896                 )
7897             ),
7898             policy_file_data,
7899         ):
7900             log.trace(
7901                 "%s is disabled by no explicit enable/disable list or value",
7902                 this_policy_name,
7903             )
7904             this_policy_setting = "Disabled"
7905             policy_vals.setdefault(this_policy_namespace, {})[
7906                 this_policy_name
7907             ] = this_policy_setting
7908     full_names = {}
7909     hierarchy = {}
7910     if ELEMENTS_XPATH(admx_policy):
7911         if element_only_enabled_disabled or this_policy_setting == "Enabled":
7912             required_elements = {}
7913             configured_elements = {}
7914             policy_disabled_elements = 0
7915             for elements_item in ELEMENTS_XPATH(admx_policy):
7916                 for child_item in elements_item:
7917                     this_element_name = _getFullPolicyName(
7918                         policy_item=child_item,
7919                         policy_name=child_item.attrib["id"],
7920                         return_full_policy_names=return_full_policy_names,
7921                         adml_language=adml_language,
7922                     )
7923                     required_elements[this_element_name] = None
7924                     child_key = child_item.attrib.get("key", this_key)
7925                     child_value_name = child_item.attrib.get(
7926                         "valueName", this_value_name
7927                     )
7928                     if etree.QName(child_item).localname == "boolean":
7929                         if child_item is not None:
7930                             if (
7931                                 TRUE_VALUE_XPATH(child_item)
7932                                 and this_element_name not in configured_elements
7933                             ):
7934                                 if _checkValueItemParent(
7935                                     policy_element=child_item,
7936                                     policy_name=this_policy_name,
7937                                     policy_key=child_key,
7938                                     policy_valueName=child_value_name,
7939                                     xpath_object=TRUE_VALUE_XPATH,
7940                                     policy_file_data=policy_file_data,
7941                                 ):
7942                                     configured_elements[this_element_name] = True
7943                                     log.trace(
7944                                         "element %s is configured true",
7945                                         child_item.attrib["id"],
7946                                     )
7947                             if (
7948                                 FALSE_VALUE_XPATH(child_item)
7949                                 and this_element_name not in configured_elements
7950                             ):
7951                                 if _checkValueItemParent(
7952                                     policy_element=child_item,
7953                                     policy_name=this_policy_name,
7954                                     policy_key=child_key,
7955                                     policy_valueName=child_value_name,
7956                                     xpath_object=FALSE_VALUE_XPATH,
7957                                     policy_file_data=policy_file_data,
7958                                 ):
7959                                     configured_elements[this_element_name] = False
7960                                     policy_disabled_elements = (
7961                                         policy_disabled_elements + 1
7962                                     )
7963                                     log.trace(
7964                                         "element %s is configured false",
7965                                         child_item.attrib["id"],
7966                                     )
7967                             if (
7968                                 TRUE_LIST_XPATH(child_item)
7969                                 and this_element_name not in configured_elements
7970                             ):
7971                                 log.trace("checking trueList")
7972                                 if _checkListItem(
7973                                     policy_element=child_item,
7974                                     policy_name=this_policy_name,
7975                                     policy_key=this_key,
7976                                     xpath_object=TRUE_LIST_XPATH,
7977                                     policy_file_data=policy_file_data,
7978                                 ):
7979                                     configured_elements[this_element_name] = True
7980                                     log.trace(
7981                                         "element %s is configured true",
7982                                         child_item.attrib["id"],
7983                                     )
7984                             if (
7985                                 FALSE_LIST_XPATH(child_item)
7986                                 and this_element_name not in configured_elements
7987                             ):
7988                                 log.trace("checking falseList")
7989                                 if _checkListItem(
7990                                     policy_element=child_item,
7991                                     policy_name=this_policy_name,
7992                                     policy_key=this_key,
7993                                     xpath_object=FALSE_LIST_XPATH,
7994                                     policy_file_data=policy_file_data,
7995                                 ):
7996                                     configured_elements[this_element_name] = False
7997                                     policy_disabled_elements = (
7998                                         policy_disabled_elements + 1
7999                                     )
8000                                     log.trace(
8001                                         "element %s is configured false",
8002                                         child_item.attrib["id"],
8003                                     )
8004                         else:
8005                             if _regexSearchRegPolData(
8006                                 re.escape(
8007                                     _processValueItem(
8008                                         element=child_item,
8009                                         reg_key=child_key,
8010                                         reg_valuename=child_value_name,
8011                                         policy=admx_policy,
8012                                         parent_element=elements_item,
8013                                         check_deleted=True,
8014                                     )
8015                                 ),
8016                                 policy_file_data,
8017                             ):
8018                                 configured_elements[this_element_name] = False
8019                                 policy_disabled_elements = policy_disabled_elements + 1
8020                                 log.trace(
8021                                     "element %s is configured false",
8022                                     child_item.attrib["id"],
8023                                 )
8024                             elif _regexSearchRegPolData(
8025                                 re.escape(
8026                                     _processValueItem(
8027                                         element=child_item,
8028                                         reg_key=child_key,
8029                                         reg_valuename=child_value_name,
8030                                         policy=admx_policy,
8031                                         parent_element=elements_item,
8032                                         check_deleted=False,
8033                                     )
8034                                 ),
8035                                 policy_file_data,
8036                             ):
8037                                 configured_elements[this_element_name] = True
8038                                 log.trace(
8039                                     "element %s is configured true",
8040                                     child_item.attrib["id"],
8041                                 )
8042                     elif etree.QName(child_item).localname in [
8043                         "decimal",
8044                         "text",
8045                         "longDecimal",
8046                         "multiText",
8047                     ]:
8048                         if _regexSearchRegPolData(
8049                             re.escape(
8050                                 _processValueItem(
8051                                     element=child_item,
8052                                     reg_key=child_key,
8053                                     reg_valuename=child_value_name,
8054                                     policy=admx_policy,
8055                                     parent_element=elements_item,
8056                                     check_deleted=True,
8057                                 )
8058                             ),
8059                             policy_file_data,
8060                         ):
8061                             configured_elements[this_element_name] = "Disabled"
8062                             policy_disabled_elements = policy_disabled_elements + 1
8063                             log.trace("element %s is disabled", child_item.attrib["id"])
8064                         elif _regexSearchRegPolData(
8065                             re.escape(
8066                                 _processValueItem(
8067                                     element=child_item,
8068                                     reg_key=child_key,
8069                                     reg_valuename=child_value_name,
8070                                     policy=admx_policy,
8071                                     parent_element=elements_item,
8072                                     check_deleted=False,
8073                                 )
8074                             ),
8075                             policy_data=policy_file_data,
8076                         ):
8077                             configured_value = _getDataFromRegPolData(
8078                                 _processValueItem(
8079                                     element=child_item,
8080                                     reg_key=child_key,
8081                                     reg_valuename=child_value_name,
8082                                     policy=admx_policy,
8083                                     parent_element=elements_item,
8084                                     check_deleted=False,
8085                                 ),
8086                                 policy_data=policy_file_data,
8087                             )
8088                             configured_elements[this_element_name] = configured_value
8089                             log.trace(
8090                                 "element %s is enabled, value == %s",
8091                                 child_item.attrib["id"],
8092                                 configured_value,
8093                             )
8094                     elif etree.QName(child_item).localname == "enum":
8095                         if _regexSearchRegPolData(
8096                             re.escape(
8097                                 _processValueItem(
8098                                     element=child_item,
8099                                     reg_key=child_key,
8100                                     reg_valuename=child_value_name,
8101                                     policy=admx_policy,
8102                                     parent_element=elements_item,
8103                                     check_deleted=True,
8104                                 )
8105                             ),
8106                             policy_file_data,
8107                         ):
8108                             log.trace(
8109                                 "enum element %s is disabled", child_item.attrib["id"]
8110                             )
8111                             configured_elements[this_element_name] = "Disabled"
8112                             policy_disabled_elements = policy_disabled_elements + 1
8113                         else:
8114                             for enum_item in child_item:
8115                                 if _checkValueItemParent(
8116                                     policy_element=enum_item,
8117                                     policy_name=child_item.attrib["id"],
8118                                     policy_key=child_key,
8119                                     policy_valueName=child_value_name,
8120                                     xpath_object=VALUE_XPATH,
8121                                     policy_file_data=policy_file_data,
8122                                 ):
8123                                     if VALUE_LIST_XPATH(enum_item):
8124                                         log.trace("enum item has a valueList")
8125                                         if _checkListItem(
8126                                             policy_element=enum_item,
8127                                             policy_name=this_policy_name,
8128                                             policy_key=child_key,
8129                                             xpath_object=VALUE_LIST_XPATH,
8130                                             policy_file_data=policy_file_data,
8131                                         ):
8132                                             log.trace(
8133                                                 "all valueList items exist in file"
8134                                             )
8135                                             configured_elements[
8136                                                 this_element_name
8137                                             ] = _getAdmlDisplayName(
8138                                                 adml_xml_data=adml_policy_resources,
8139                                                 display_name=enum_item.attrib[
8140                                                     "displayName"
8141                                                 ],
8142                                             )
8143                                             break
8144                                     else:
8145                                         configured_elements[
8146                                             this_element_name
8147                                         ] = _getAdmlDisplayName(
8148                                             adml_xml_data=adml_policy_resources,
8149                                             display_name=enum_item.attrib[
8150                                                 "displayName"
8151                                             ],
8152                                         )
8153                                         break
8154                     elif etree.QName(child_item).localname == "list":
8155                         return_value_name = False
8156                         if (
8157                             "explicitValue" in child_item.attrib
8158                             and child_item.attrib["explicitValue"].lower() == "true"
8159                         ):
8160                             log.trace("explicitValue list, we will return value names")
8161                             return_value_name = True
8162                         regex_str = [
8163                             r"(?!\*",
8164                             r"\*",
8165                             "D",
8166                             "e",
8167                             "l",
8168                             "V",
8169                             "a",
8170                             "l",
8171                             "s",
8172                             r"\.",
8173                             ")",
8174                         ]
8175                         delvals_regex = "\x00".join(regex_str)
8176                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
8177                         if _regexSearchRegPolData(
8178                             re.escape(
8179                                 _processValueItem(
8180                                     element=child_item,
8181                                     reg_key=child_key,
8182                                     reg_valuename=child_value_name,
8183                                     policy=admx_policy,
8184                                     parent_element=elements_item,
8185                                     check_deleted=False,
8186                                 )
8187                             )
8188                             + delvals_regex,
8189                             policy_data=policy_file_data,
8190                         ):
8191                             configured_value = _getDataFromRegPolData(
8192                                 _processValueItem(
8193                                     element=child_item,
8194                                     reg_key=child_key,
8195                                     reg_valuename=child_value_name,
8196                                     policy=admx_policy,
8197                                     parent_element=elements_item,
8198                                     check_deleted=False,
8199                                 ),
8200                                 policy_data=policy_file_data,
8201                                 return_value_name=return_value_name,
8202                             )
8203                             configured_elements[this_element_name] = configured_value
8204                             log.trace(
8205                                 "element %s is enabled values: %s",
8206                                 child_item.attrib["id"],
8207                                 configured_value,
8208                             )
8209                         elif _regexSearchRegPolData(
8210                             re.escape(
8211                                 _processValueItem(
8212                                     element=child_item,
8213                                     reg_key=child_key,
8214                                     reg_valuename=child_value_name,
8215                                     policy=admx_policy,
8216                                     parent_element=elements_item,
8217                                     check_deleted=True,
8218                                 )
8219                             ),
8220                             policy_file_data,
8221                         ):
8222                             configured_elements[this_element_name] = "Disabled"
8223                             policy_disabled_elements = policy_disabled_elements + 1
8224                             log.trace("element %s is disabled", child_item.attrib["id"])
8225             if element_only_enabled_disabled:
8226                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
8227                     if policy_disabled_elements == len(required_elements.keys()):
8228                         log.trace(
8229                             "%s is disabled by all enum elements", this_policy_name
8230                         )
8231                         policy_vals.setdefault(this_policy_namespace, {})[
8232                             this_policy_name
8233                         ] = "Disabled"
8234                     else:
8235                         log.trace("%s is enabled by enum elements", this_policy_name)
8236                         policy_vals.setdefault(this_policy_namespace, {})[
8237                             this_policy_name
8238                         ] = configured_elements
8239                 else:
8240                     policy_vals.setdefault(this_policy_namespace, {})[
8241                         this_policy_name
8242                     ] = this_policy_setting
8243             else:
8244                 if this_policy_setting == "Enabled":
8245                     policy_vals.setdefault(this_policy_namespace, {})[
8246                         this_policy_name
8247                     ] = configured_elements
8248         else:
8249             policy_vals.setdefault(this_policy_namespace, {})[
8250                 this_policy_name
8251             ] = this_policy_setting
8252     else:
8253         policy_vals.setdefault(this_policy_namespace, {})[
8254             this_policy_name
8255         ] = this_policy_setting
8256     if (
8257         return_full_policy_names
8258         and this_policy_namespace in policy_vals
8259         and this_policy_name in policy_vals[this_policy_namespace]
8260     ):
8261         full_names.setdefault(this_policy_namespace, {})
8262         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
8263             policy_item=admx_policy,
8264             policy_name=admx_policy.attrib["name"],
8265             return_full_policy_names=return_full_policy_names,
8266             adml_language=adml_language,
8267         )
8268         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
8269             full_name = full_names[this_policy_namespace][this_policy_name]
8270             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
8271                 this_policy_name
8272             )
8273             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
8274     if (
8275         this_policy_namespace in policy_vals
8276         and this_policy_name in policy_vals[this_policy_namespace]
8277     ):
8278         hierarchy.setdefault(this_policy_namespace, {})[
8279             this_policy_name
8280         ] = _build_parent_list(
8281             policy_definition=admx_policy,
8282             return_full_policy_names=return_full_policy_names,
8283             adml_language=adml_language,
8284         )
8285     if policy_vals and return_full_policy_names and not hierarchical_return:
8286         log.debug("Compiling non hierarchical return...")
8287         unpathed_dict = {}
8288         pathed_dict = {}
8289         for policy_namespace in list(policy_vals):
8290             for policy_item in list(policy_vals[policy_namespace]):
8291                 full_name = full_names[policy_namespace][policy_item]
8292                 if full_name in policy_vals[policy_namespace]:
8293                     full_path_list = hierarchy[policy_namespace][policy_item]
8294                     full_path_list.reverse()
8295                     full_path_list.append(full_names[policy_namespace][policy_item])
8296                     policy_vals["\\".join(full_path_list)] = policy_vals[
8297                         policy_namespace
8298                     ].pop(policy_item)
8299                     pathed_dict[full_name] = True
8300                 else:
8301                     policy_vals[policy_namespace][full_name] = policy_vals[
8302                         policy_namespace
8303                     ].pop(policy_item)
8304                     unpathed_dict.setdefault(policy_namespace, {})[
8305                         full_name
8306                     ] = policy_item
8307             for path_needed in unpathed_dict[policy_namespace]:
8308                 full_path_list = hierarchy[policy_namespace][
8309                     unpathed_dict[policy_namespace][path_needed]
8310                 ]
8311                 full_path_list.reverse()
8312                 full_path_list.append(path_needed)
8313                 log.trace("full_path_list == %s", full_path_list)
8314                 policy_vals["\\".join(full_path_list)] = policy_vals[
8315                     policy_namespace
8316                 ].pop(path_needed)
8317     for policy_namespace in list(policy_vals):
8318         if policy_vals[policy_namespace] == {}:
8319             policy_vals.pop(policy_namespace)
8320         elif isinstance(policy_vals[policy_namespace], dict):
8321             if this_policy_namespace == policy_namespace and not hierarchical_return:
8322                 policy_vals.update(policy_vals[policy_namespace])
8323                 policy_vals.pop(policy_namespace)
8324     if policy_vals and hierarchical_return:
8325         if hierarchy:
8326             log.debug("Compiling hierarchical return...")
8327             for policy_namespace in hierarchy:
8328                 for hierarchy_item in hierarchy[policy_namespace]:
8329                     if hierarchy_item in policy_vals[policy_namespace]:
8330                         t_dict = {}
8331                         first_item = True
8332                         for item in hierarchy[policy_namespace][hierarchy_item]:
8333                             new_dict = {}
8334                             if first_item:
8335                                 h_policy_name = hierarchy_item
8336                                 if return_full_policy_names:
8337                                     h_policy_name = full_names[policy_namespace][
8338                                         hierarchy_item
8339                                     ]
8340                                 new_dict[item] = {
8341                                     h_policy_name: policy_vals[policy_namespace].pop(
8342                                         hierarchy_item
8343                                     )
8344                                 }
8345                                 first_item = False
8346                             else:
8347                                 new_dict[item] = t_dict
8348                             t_dict = new_dict
8349                         if t_dict:
8350                             policy_vals = dictupdate.update(policy_vals, t_dict)
8351                 if (
8352                     policy_namespace in policy_vals
8353                     and policy_vals[policy_namespace] == {}
8354                 ):
8355                     policy_vals.pop(policy_namespace)
8356         policy_vals = {
8357             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
8358                 "Administrative Templates": policy_vals
8359             }
8360         }
8361     return policy_vals
8362 def get_policy(
8363     policy_name,
8364     policy_class,
8365     adml_language="en-US",
8366     return_value_only=True,
8367     return_full_policy_names=True,
8368     hierarchical_return=False,
8369 ):
8370     r"""
8371     Get the current settings for a single policy on the machine
8372     Args:
8373         policy_name (str):
8374             The name of the policy to retrieve. Can be the any of the names
8375             or alieses returned by ``lgpo.get_policy_info``
8376         policy_class (str):
8377             The policy class. Must be one of ``machine`` or ``user``
8378         adml_language (str):
8379             The language code for the adml file to use for localization. The
8380             default is ``en-US``
8381         return_value_only (bool):
8382             ``True`` will return only the value for the policy, without the
8383             name of the policy. ``return_full_policy_names`` and
8384             ``hierarchical_return`` will be ignored. Default is ``True``
8385         return_full_policy_names (bool):
8386             Returns the full policy name regardless of what was passed in
8387             ``policy_name``
8388             .. note::
8389                 This setting applies to sub-elements of the policy if they
8390                 exist. The value passed in ``policy_name`` will always be used
8391                 as the policy name when this setting is ``False``
8392         hierarchical_return (bool):
8393             Returns a hierarchical view of the policy showing its parents
8394     Returns:
8395         dict: A dictionary containing the policy settings
8396     CLI Example:
8397     .. code-block:: bash
8398         salt * lgpo.get_policy LockoutDuration machine
8399         salt * lgpo.get_policy AutoUpdateCfg machine
8400         salt * lgpo.get_policy "Account lockout duration" machine
8401         salt * lgpo.get_policy "Configure Automatic Updates" machine
8402         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
8403     Set a single computer policy
8404     Args:
8405         name (str):
8406             The name of the policy to configure
8407         setting (str):
8408             The setting to configure the named policy with
8409         cumulative_rights_assignments (bool): Determine how user rights
8410             assignment policies are configured. If True, user right assignment
8411             specifications are simply added to the existing policy. If False,
8412             only the users specified will get the right (any existing will have
8413             the right revoked)
8414         adml_language (str): The language files to use for looking up
8415             Administrative Template policy data (i.e. how the policy is
8416             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
8417     Returns:
8418         bool: True if successful, otherwise False
8419     CLI Example:
8420     .. code-block:: bash
8421         salt '*' lgpo.set_computer_policy LockoutDuration 1440
8422     Set a single user policy
8423     Args:
8424         name (str):
8425             The name of the policy to configure
8426         setting (str):
8427             The setting to configure the named policy with
8428         adml_language (str):
8429             The language files to use for looking up Administrative Template
8430             policy data (i.e. how the policy is displayed in the GUI). Defaults
8431             to 'en-US' (U.S. English).
8432     Returns:
8433         bool: True if successful, Otherwise False
8434     CLI Example:
8435     .. code-block:: bash
8436         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
8437     Set a local server policy.
8438     Args:
8439         computer_policy (dict):
8440             A dictionary of "policyname: value" pairs of computer policies to
8441             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
8442             if a setting can be 'Enabled'/'Disabled', then that should be passed
8443             Administrative Template data may require dicts within dicts, to
8444             specify each element of the Administrative Template policy.
8445             Administrative Templates policies are always cumulative.
8446             Policy names can be specified in a number of ways based on the type
8447             of policy:
8448                 Windows Settings Policies:
8449                     These policies can be specified using the GUI display name
8450                     or the key name from the _policy_info class in this module.
8451                     The GUI display name is also contained in the _policy_info
8452                     class in this module.
8453                 Administrative Template Policies:
8454                     These can be specified using the policy name as displayed in
8455                     the GUI (case sensitive). Some policies have the same name,
8456                     but a different location (for example, "Access data sources
8457                     across domains"). These can be differentiated by the "path"
8458                     in the GUI (for example, "Windows Components\\Internet
8459                     Explorer\\Internet Control Panel\\Security Page\\Internet
8460                     Zone\\Access data sources across domains").
8461                     Additionally, policies can be specified using the "name" and
8462                     "id" attributes from the ADMX files.
8463                     For Administrative Templates that have policy elements, each
8464                     element can be specified using the text string as seen in
8465                     the GUI or using the ID attribute from the ADMX file. Due to
8466                     the way some of the GUI text is laid out, some policy
8467                     element names could include descriptive text that appears
8468                     lbefore the policy element in the GUI.
8469                     Use the get_policy_info function for the policy name to view
8470                     the element ID/names that the module will accept.
8471         user_policy (dict):
8472             The same setup as the computer_policy, except with data to configure
8473             the local user policy.
8474         cumulative_rights_assignments (bool):
8475             Determine how user rights assignment policies are configured.
8476             If True, user right assignment specifications are simply added to
8477             the existing policy
8478             If False, only the users specified will get the right (any existing
8479             will have the right revoked)
8480         adml_language (str):
8481             The language files to use for looking up Administrative Template
8482             policy data (i.e. how the policy is displayed in the GUI). Defaults
8483             to 'en-US' (U.S. English).
8484     Returns:
8485         bool: True is successful, otherwise False
8486     CLI Example:
8487     .. code-block:: bash
8488         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
8489                                     "option": _pol["NetSH"]<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["Option"],
8490                                     "value": str(_value),
8491                                 },
8492                             )
8493                         elif "AdvAudit" in _pol:
8494                             _advaudits.setdefault(
8495                                 policy_name,
8496                                 {
8497                                     "option": _pol["AdvAudit"]["Option"],
8498                                     "value": str(_value),
8499                                 },
8500                             )
8501                         elif "NetUserModal" in _pol:
8502                             log.trace("%s is a NetUserModal policy", policy_name)
8503                             if _pol[</b></font>"NetUserModal"]["Modal"] not in _modal_sets:
8504                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
8505                             _modal_sets[_pol["NetUserModal"]["Modal"]][
8506                                 _pol["NetUserModal"]["Option"]
8507                             ] = _value
8508                         elif "LsaRights" in _pol:
8509                             log.trace("%s is a LsaRights policy", policy_name)
8510                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
8511                     else:
8512                         _value = policies[p_class][policy_name]
8513                         log.trace('searching for "%s" in admx data', policy_name)
8514                         (
8515                             success,
8516                             the_policy,
8517                             policy_name_list,
8518                             msg,
8519                         ) = _lookup_admin_template(
8520                             policy_name=policy_name,
8521                             policy_class=p_class,
8522                             adml_language=adml_language,
8523                         )
8524                         if success:
8525                             policy_name = the_policy.attrib["name"]
8526                             policy_namespace = the_policy.nsmap[the_policy.prefix]
8527                             if policy_namespace not in _admTemplateData:
8528                                 _admTemplateData[policy_namespace] = {}
8529                             _admTemplateData[policy_namespace][policy_name] = _value
8530                         else:
8531                             raise SaltInvocationError(msg)
8532                         if (
8533                             policy_namespace
8534                             and policy_name in _admTemplateData[policy_namespace]
8535                             and the_policy is not None
8536                         ):
8537                             log.trace(
8538                                 "setting == %s",
8539                                 str(
8540                                     _admTemplateData[policy_namespace][policy_name]
8541                                 ).lower(),
8542                             )
8543                             log.trace(
8544                                 str(
8545                                     _admTemplateData[policy_namespace][policy_name]
8546                                 ).lower()
8547                             )
8548                             if (
8549                                 str(
8550                                     _admTemplateData[policy_namespace][policy_name]
8551                                 ).lower()
8552                                 != "disabled"
8553                                 and str(
8554                                     _admTemplateData[policy_namespace][policy_name]
8555                                 ).lower()
8556                                 != "not configured"
8557                             ):
8558                                 if ELEMENTS_XPATH(the_policy):
8559                                     if isinstance(
8560                                         _admTemplateData[policy_namespace][policy_name],
8561                                         dict,
8562                                     ):
8563                                         for elements_item in ELEMENTS_XPATH(the_policy):
8564                                             for child_item in elements_item:
8565                                                 log.trace(
8566                                                     "checking element %s",
8567                                                     child_item.attrib["id"],
8568                                                 )
8569                                                 temp_element_name = None
8570                                                 this_element_name = _getFullPolicyName(
8571                                                     policy_item=child_item,
8572                                                     policy_name=child_item.attrib["id"],
8573                                                     return_full_policy_names=True,
8574                                                     adml_language=adml_language,
8575                                                 )
8576                                                 log.trace(
8577                                                     'id attribute == "%s" '
8578                                                     ' this_element_name == "%s"',
8579                                                     child_item.attrib["id"],
8580                                                     this_element_name,
8581                                                 )
8582                                                 if (
8583                                                     this_element_name
8584                                                     in _admTemplateData[
8585                                                         policy_namespace
8586                                                     ][policy_name]
8587                                                 ):
8588                                                     temp_element_name = (
8589                                                         this_element_name
8590                                                     )
8591                                                 elif (
8592                                                     child_item.attrib["id"]
8593                                                     in _admTemplateData[
8594                                                         policy_namespace
8595                                                     ][policy_name]
8596                                                 ):
8597                                                     temp_element_name = (
8598                                                         child_item.attrib["id"]
8599                                                     )
8600                                                 else:
8601                                                     raise SaltInvocationError(
8602                                                         'Element "{}" must be included'
8603                                                         " in the policy configuration"
8604                                                         " for policy {}".format(
8605                                                             this_element_name,
8606                                                             policy_name,
8607                                                         )
8608                                                     )
8609                                                 if (
8610                                                     "required" in child_item.attrib
8611                                                     and child_item.attrib[
8612                                                         "required"
8613                                                     ].lower()
8614                                                     == "true"
8615                                                 ):
8616                                                     if not _admTemplateData[
8617                                                         policy_namespace
8618                                                     ][policy_name][temp_element_name]:
8619                                                         raise SaltInvocationError(
8620                                                             'Element "{}" requires a value '
8621                                                             "to be specified".format(
8622                                                                 temp_element_name
8623                                                             )
8624                                                         )
8625                                                 if (
8626                                                     etree.QName(child_item).localname
8627                                                     == "boolean"
8628                                                 ):
8629                                                     if not isinstance(
8630                                                         _admTemplateData[
8631                                                             policy_namespace
8632                                                         ][policy_name][
8633                                                             temp_element_name
8634                                                         ],
8635                                                         bool,
8636                                                     ):
8637                                                         raise SaltInvocationError(
8638                                                             "Element {} requires a boolean "
8639                                                             "True or False".format(
8640                                                                 temp_element_name
8641                                                             )
8642                                                         )
8643                                                 elif (
8644                                                     etree.QName(child_item).localname
8645                                                     == "decimal"
8646                                                     or etree.QName(child_item).localname
8647                                                     == "longDecimal"
8648                                                 ):
8649                                                     min_val = 0
8650                                                     max_val = 9999
8651                                                     if "minValue" in child_item.attrib:
8652                                                         min_val = int(
8653                                                             child_item.attrib[
8654                                                                 "minValue"
8655                                                             ]
8656                                                         )
8657                                                     if "maxValue" in child_item.attrib:
8658                                                         max_val = int(
8659                                                             child_item.attrib[
8660                                                                 "maxValue"
8661                                                             ]
8662                                                         )
8663                                                     if (
8664                                                         int(
8665                                                             _admTemplateData[
8666                                                                 policy_namespace
8667                                                             ][policy_name][
8668                                                                 temp_element_name
8669                                                             ]
8670                                                         )
8671                                                         &lt; min_val
8672                                                         or int(
8673                                                             _admTemplateData[
8674                                                                 policy_namespace
8675                                                             ][policy_name][
8676                                                                 temp_element_name
8677                                                             ]
8678                                                         )
8679                                                         &gt; max_val
8680                                                     ):
8681                                                         raise SaltInvocationError(
8682                                                             'Element "{}" value must be between '
8683                                                             "{} and {}".format(
8684                                                                 temp_element_name,
8685                                                                 min_val,
8686                                                                 max_val,
8687                                                             )
8688                                                         )
8689                                                 elif (
8690                                                     etree.QName(child_item).localname
8691                                                     == "enum"
8692                                                 ):
8693                                                     found = False
8694                                                     for enum_item in child_item:
8695                                                         if (
8696                                                             _admTemplateData[
8697                                                                 policy_namespace
8698                                                             ][policy_name][
8699                                                                 temp_element_name
8700                                                             ]
8701                                                             == _getAdmlDisplayName(
8702                                                                 adml_policy_resources,
8703                                                                 enum_item.attrib[
8704                                                                     "displayName"
8705                                                                 ],
8706                                                             ).strip()
8707                                                         ):
8708                                                             found = True
8709                                                             break
8710                                                     if not found:
8711                                                         raise SaltInvocationError(
8712                                                             'Element "{}" does not have'
8713                                                             " a valid value".format(
8714                                                                 temp_element_name
8715                                                             )
8716                                                         )
8717                                                 elif (
8718                                                     etree.QName(child_item).localname
8719                                                     == "list"
8720                                                 ):
8721                                                     if (
8722                                                         "explicitValue"
8723                                                         in child_item.attrib
8724                                                         and child_item.attrib[
8725                                                             "explicitValue"
8726                                                         ].lower()
8727                                                         == "true"
8728                                                     ):
8729                                                         if not isinstance(
8730                                                             _admTemplateData[
8731                                                                 policy_namespace
8732                                                             ][policy_name][
8733                                                                 temp_element_name
8734                                                             ],
8735                                                             dict,
8736                                                         ):
8737                                                             raise SaltInvocationError(
8738                                                                 "Each list item of element "
8739                                                                 '"{}" requires a dict '
8740                                                                 "value".format(
8741                                                                     temp_element_name
8742                                                                 )
8743                                                             )
8744                                                     elif not isinstance(
8745                                                         _admTemplateData[
8746                                                             policy_namespace
8747                                                         ][policy_name][
8748                                                             temp_element_name
8749                                                         ],
8750                                                         list,
8751                                                     ):
8752                                                         raise SaltInvocationError(
8753                                                             'Element "{}" requires a'
8754                                                             " list value".format(
8755                                                                 temp_element_name
8756                                                             )
8757                                                         )
8758                                                 elif (
8759                                                     etree.QName(child_item).localname
8760                                                     == "multiText"
8761                                                 ):
8762                                                     if not isinstance(
8763                                                         _admTemplateData[
8764                                                             policy_namespace
8765                                                         ][policy_name][
8766                                                             temp_element_name
8767                                                         ],
8768                                                         list,
8769                                                     ):
8770                                                         raise SaltInvocationError(
8771                                                             'Element "{}" requires a'
8772                                                             " list value".format(
8773                                                                 temp_element_name
8774                                                             )
8775                                                         )
8776                                                 _admTemplateData[policy_namespace][
8777                                                     policy_name
8778                                                 ][
8779                                                     child_item.attrib["id"]
8780                                                 ] = _admTemplateData[
8781                                                     policy_namespace
8782                                                 ][
8783                                                     policy_name
8784                                                 ].pop(
8785                                                     temp_element_name
8786                                                 )
8787                                     else:
8788                                         raise SaltInvocationError(
8789                                             'The policy "{}" has elements which must be'
8790                                             " configured".format(policy_name)
8791                                         )
8792                                 else:
8793                                     if (
8794                                         str(
8795                                             _admTemplateData[policy_namespace][
8796                                                 policy_name
8797                                             ]
8798                                         ).lower()
8799                                         != "enabled"
8800                                     ):
8801                                         raise SaltInvocationError(
8802                                             'The policy {} must either be "Enabled", '
8803                                             '"Disabled", or "Not Configured"'.format(
8804                                                 policy_name
8805                                             )
8806                                         )
8807                 if _regedits:
8808                     for regedit in _regedits:
8809                         log.trace("%s is a Registry policy", regedit)
8810                         if (
8811                             _regedits[regedit]["value"] is not None
8812 <a name="2"></a>                            and _regedits[regedit]["value"] != "(value not set)"
8813                         ):
8814                             _ret = __utils__["reg.set_value"](
8815                                 _regedits<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[regedit]["policy"]["Registry"]["Hive"],
8816                                 _regedits[regedit]["policy"]["Registry"]["Path"],
8817                                 _regedits[regedit]["policy"]["Registry"]["Value"],
8818                                 _regedits[regedit]["value"],
8819                                 _regedits[regedit]["policy"]["Registry"]["Type"],
8820                             )
8821                         else:
8822                             _ret = __utils__["reg.read_value"](</b></font>
8823                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
8824                                 _regedits[regedit]["policy"]["Registry"]["Path"],
8825                                 _regedits[regedit]["policy"]["Registry"]["Value"],
8826                             )
8827                             if _ret["success"] and _ret["vdata"] != "(value not set)":
8828                                 _ret = __utils__["reg.delete_value"](
8829                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
8830                                     _regedits[regedit]["policy"]["Registry"]["Path"],
8831                                     _regedits[regedit]["policy"]["Registry"]["Value"],
8832                                 )
8833                         if not _ret:
8834                             raise CommandExecutionError(
8835                                 "Error while attempting to set policy {} via the"
8836                                 " registry.  Some changes may not be applied as"
8837                                 " expected".format(regedit)
8838                             )
8839                 if _lsarights:
8840                     for lsaright in _lsarights:
8841                         _existingUsers = None
8842                         if not cumulative_rights_assignments:
8843                             _existingUsers = _getRightsAssignments(
8844                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
8845                             )
8846                         if _lsarights[lsaright]["value"]:
8847                             for acct in _lsarights[lsaright]["value"]:
8848                                 _ret = _addAccountRights(
8849                                     acct,
8850                                     _lsarights[lsaright]["policy"]["LsaRights"][
8851                                         "Option"
8852                                     ],
8853                                 )
8854                                 if not _ret:
8855                                     raise SaltInvocationError(
8856                                         "An error occurred attempting to configure the"
8857                                         " user right {}.".format(lsaright)
8858                                     )
8859                         if _existingUsers:
8860                             for acct in _existingUsers:
8861                                 if acct not in _lsarights[lsaright]["value"]:
8862                                     _ret = _delAccountRights(
8863                                         acct,
8864                                         _lsarights[lsaright]["policy"]["LsaRights"][
8865                                             "Option"
8866                                         ],
8867                                     )
8868                                     if not _ret:
8869                                         raise SaltInvocationError(
8870                                             "An error occurred attempting to remove previously "
8871                                             "configured users with right {}.".format(
8872                                                 lsaright
8873                                             )
8874                                         )
8875                 if _secedits:
8876                     log.trace(_secedits)
8877                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
8878                     _seceditSections = [
8879                         "System Access",
8880                         "Event Audit",
8881                         "Registry Values",
8882                         "Privilege Rights",
8883                     ]
8884                     for _seceditSection in _seceditSections:
8885                         if _seceditSection in _secedits:
8886                             ini_data = "\r\n".join(
8887                                 [
8888                                     ini_data,
8889                                     "".join(["[", _seceditSection, "]"]),
8890                                     "\r\n".join(_secedits[_seceditSection]),
8891                                 ]
8892                             )
8893                     ini_data = "\r\n".join(
8894                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
8895                     )
8896                     log.trace("ini_data == %s", ini_data)
8897                     if not _write_secedit_data(ini_data):
8898                         raise CommandExecutionError(
8899                             "Error while attempting to set policies via "
8900                             "secedit. Some changes may not be applied as "
8901                             "expected"
8902                         )
8903                 if _netshs:
8904                     for setting in _netshs:
8905                         log.trace("Setting firewall policy: %s", setting)
8906                         log.trace(_netshs[setting])
8907                         _set_netsh_value(**_netshs[setting])
8908                 if _advaudits:
8909                     for setting in _advaudits:
8910                         log.trace("Setting Advanced Audit policy: %s", setting)
8911                         log.trace(_advaudits[setting])
8912                         _set_advaudit_value(**_advaudits[setting])
8913                 if _modal_sets:
8914                     log.trace(_modal_sets)
8915                     for _modal_set in _modal_sets:
8916                         try:
8917                             _existingModalData = win32net.NetUserModalsGet(
8918                                 None, _modal_set
8919                             )
8920                             _newModalSetData = dictupdate.update(
8921                                 _existingModalData, _modal_sets[_modal_set]
8922                             )
8923                             log.trace("NEW MODAL SET = %s", _newModalSetData)
8924                             _ret = win32net.NetUserModalsSet(
8925                                 None, _modal_set, _newModalSetData
8926                             )
8927                         except Exception as exc:  # pylint: disable=broad-except
8928                             msg = (
8929                                 "An unhandled exception occurred while "
8930                                 "attempting to set policy via "
8931                                 "NetUserModalSet\n{}".format(exc)
8932                             )
8933                             log.exception(msg)
8934                             raise CommandExecutionError(msg)
8935                 if _admTemplateData:
8936                     _ret = False
8937                     log.trace(
8938                         "going to write some adm template data :: %s", _admTemplateData
8939                     )
8940                     _ret = _writeAdminTemplateRegPolFile(
8941                         _admTemplateData,
8942                         adml_language=adml_language,
8943                         registry_class=p_class,
8944                     )
8945                     if not _ret:
8946                         raise CommandExecutionError(
8947                             "Error while attempting to write Administrative Template"
8948                             " Policy data.  Some changes may not be applied as expected"
8949                         )
8950         return True
8951     else:
8952         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
2 import collections
3 import copy
4 import datetime
5 import logging
6 import os
7 import re
8 import shutil
9 import string  # pylint: disable=deprecated-module
10 import subprocess
11 import sys
12 import time
13 import urllib.parse
14 from xml.etree import ElementTree
15 from xml.sax import saxutils
16 import jinja2.exceptions
17 import salt.utils.data
18 import salt.utils.files
19 import salt.utils.json
20 import</b></font> salt.utils.path
21 import salt.utils.stringutils
22 import salt.utils.templates
23 import salt.utils.virt
24 import salt.utils.xmlutil as xmlutil
25 import salt.utils.yaml
26 from salt._compat import ipaddress
27 from salt.exceptions import CommandExecutionError, SaltInvocationError
28 try:
29     import libvirt  # pylint: disable=import-error
30     from libvirt import libvirtError
31     HAS_LIBVIRT = True
32 except ImportError:
33     HAS_LIBVIRT = False
34 <a name="20"></a>log = logging.getLogger(__name__)
35 JINJA = jinja2<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Environment(
36     loader=jinja2.FileSystemLoader(
37         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
38     )
39 )
40 CACHE_DIR =</b></font> "/var/lib/libvirt/saltinst"
41 VIRT_STATE_NAME_MAP = {
42     0: "running",
43     1: "running",
44     2: "running",
45     3: "paused",
46     4: "shutdown",
47     5: "shutdown",
48     6: "crashed",
49 }
50 def __virtual__():
51     if not HAS_LIBVIRT:
52         return (False, "Unable to locate or import python libvirt library.")
53     return "virt"
54 def __get_request_auth(username, password):
55     def __request_auth(credentials, user_data):
56         for credential in credentials:
57             if credential[0] == libvirt.VIR_CRED_AUTHNAME:
58                 credential[4] = (
59                     username
60                     if username
61                     else __salt__["config.get"](
62                         "virt:connection:auth:username", credential[3]
63                     )
64                 )
65             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
66                 credential[4] = (
67                     password
68                     if password
69                     else __salt__["config.get"](
70                         "virt:connection:auth:password", credential[3]
71                     )
72                 )
73             else:
74                 log.info("Unhandled credential type: %s", credential[0])
75         return 0
76 def __get_conn(**kwargs):
77     username = kwargs.get("username", None)
78     password = kwargs.get("password", None)
79     conn_str = kwargs.get("connection", None)
80     if not conn_str:
81         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
82     try:
83         auth_types = [
84             libvirt.VIR_CRED_AUTHNAME,
85             libvirt.VIR_CRED_NOECHOPROMPT,
86             libvirt.VIR_CRED_ECHOPROMPT,
87             libvirt.VIR_CRED_PASSPHRASE,
88             libvirt.VIR_CRED_EXTERNAL,
89         ]
90         conn = libvirt.openAuth(
91             conn_str, [auth_types, __get_request_auth(username, password), None], 0
92         )
93     except Exception:  # pylint: disable=broad-except
94         raise CommandExecutionError(
95             "Sorry, {} failed to open a connection to the hypervisor "
96             "software at {}".format(__grains__["fqdn"], conn_str)
97         )
98     return conn
99 def _get_domain(conn, *vms, **kwargs):
100     ret = list()
101     lookup_vms = list()
102     all_vms = []
103     if kwargs.get("active", True):
104         for id_ in conn.listDomainsID():
105             all_vms.append(conn.lookupByID(id_).name())
106     if kwargs.get("inactive", True):
107         for id_ in conn.listDefinedDomains():
108             all_vms.append(id_)
109     if vms and not all_vms:
110         raise CommandExecutionError("No virtual machines found.")
111     if vms:
112         for name in vms:
113             if name not in all_vms:
114                 raise CommandExecutionError(
115                     'The VM "{name}" is not present'.format(name=name)
116                 )
117             else:
118                 lookup_vms.append(name)
119     else:
120         lookup_vms = list(all_vms)
121     for name in lookup_vms:
122         ret.append(conn.lookupByName(name))
123     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
124 def _parse_qemu_img_info(info):
125     raw_infos = salt.utils.json.loads(info)
126     disks = []
127     for disk_infos in raw_infos:
128         disk = {
129             "file": disk_infos["filename"],
130             "file format": disk_infos["format"],
131             "disk size": disk_infos["actual-size"],
132             "virtual size": disk_infos["virtual-size"],
133             "cluster size": disk_infos["cluster-size"]
134             if "cluster-size" in disk_infos
135             else None,
136         }
137         if "full-backing-filename" in disk_infos.keys():
138             disk["backing file"] = format(disk_infos["full-backing-filename"])
139         if "snapshots" in disk_infos.keys():
140             disk["snapshots"] = [
141                 {
142                     "id": snapshot["id"],
143                     "tag": snapshot["name"],
144                     "vmsize": snapshot["vm-state-size"],
145                     "date": datetime.datetime.fromtimestamp(
146                         float(
147                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
148                         )
149                     ).isoformat(),
150                     "vmclock": datetime.datetime.utcfromtimestamp(
151                         float(
152                             "{}.{}".format(
153                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
154                             )
155                         )
156                     )
157                     .time()
158                     .isoformat(),
159                 }
160                 for snapshot in disk_infos["snapshots"]
161             ]
162         disks.append(disk)
163     for disk in disks:
164         if "backing file" in disk.keys():
165             candidates = [
166                 info
167                 for info in disks
168                 if "file" in info.keys() and info["file"] == disk["backing file"]
169             ]
170             if candidates:
171                 disk["backing file"] = candidates[0]
172     return disks[0]
173 def _get_uuid(dom):
174     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
175 def _get_on_poweroff(dom):
176     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
177     return node.text if node is not None else ""
178 def _get_on_reboot(dom):
179     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
180     return node.text if node is not None else ""
181 def _get_on_crash(dom):
182     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
183     return node.text if node is not None else ""
184 def _get_nics(dom):
185     nics = {}
186     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
187     for iface_node in doc.findall("devices/interface"):
188         nic = {}
189         nic["type"] = iface_node.get("type")
190         for v_node in iface_node:
191             if v_node.tag == "mac":
192                 nic["mac"] = v_node.get("address")
193             if v_node.tag == "model":
194                 nic["model"] = v_node.get("type")
195             if v_node.tag == "target":
196                 nic["target"] = v_node.get("dev")
197             if re.match("(driver|source|address)", v_node.tag):
198                 temp = {}
199                 for key, value in v_node.attrib.items():
200                     temp[key] = value
201                 nic[v_node.tag] = temp
202             if v_node.tag == "virtualport":
203                 temp = {}
204                 temp["type"] = v_node.get("type")
205                 for key, value in v_node.attrib.items():
206                     temp[key] = value
207                 nic["virtualport"] = temp
208         if "mac" not in nic:
209             continue
210         nics[nic["mac"]] = nic
211     return nics
212 def _get_graphics(dom):
213     out = {
214         "autoport": "None",
215         "keymap": "None",
216         "listen": "None",
217         "port": "None",
218         "type": "None",
219     }
220     doc = ElementTree.fromstring(dom.XMLDesc(0))
221     for g_node in doc.findall("devices/graphics"):
222         for key, value in g_node.attrib.items():
223             out[key] = value
224     return out
225 def _get_loader(dom):
226     out = {"path": "None"}
227     doc = ElementTree.fromstring(dom.XMLDesc(0))
228     for g_node in doc.findall("os/loader"):
229         out["path"] = g_node.text
230         for key, value in g_node.attrib.items():
231             out[key] = value
232     return out
233 def _get_disks(conn, dom):
234     disks = {}
235     doc = ElementTree.fromstring(dom.XMLDesc(0))
236     all_volumes = _get_all_volumes_paths(conn)
237     for elem in doc.findall("devices/disk"):
238         source = elem.find("source")
239         if source is None:
240             continue
241         target = elem.find("target")
242         driver = elem.find("driver")
243         if target is None:
244             continue
245         qemu_target = None
246         extra_properties = None
247         if "dev" in target.attrib:
248             disk_type = elem.get("type")
249             def _get_disk_volume_data(pool_name, volume_name):
250                 qemu_target = "{}/{}".format(pool_name, volume_name)
251                 pool = conn.storagePoolLookupByName(pool_name)
252                 extra_properties = {}
253                 try:
254                     vol = pool.storageVolLookupByName(volume_name)
255                     vol_info = vol.info()
256                     extra_properties = {
257                         "virtual size": vol_info[1],
258                         "disk size": vol_info[2],
259                     }
260                     backing_files = [
261                         {
262                             "file": node.find("source").get("file"),
263                             "file format": node.find("format").get("type"),
264                         }
265                         for node in elem.findall(".//backingStore[source]")
266                     ]
267                     if backing_files:
268                         extra_properties["backing file"] = backing_files[0]
269                         parent = extra_properties["backing file"]
270                         for sub_backing_file in backing_files[1:]:
271                             parent["backing file"] = sub_backing_file
272                             parent = sub_backing_file
273                     else:
274                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
275                         backing_path = vol_desc.find("./backingStore/path")
276                         backing_format = vol_desc.find("./backingStore/format")
277                         if backing_path is not None:
278                             extra_properties["backing file"] = {
279                                 "file": backing_path.text
280                             }
281                             if backing_format is not None:
282                                 extra_properties["backing file"][
283                                     "file format"
284                                 ] = backing_format.get("type")
285                 except libvirt.libvirtError:
286                     log.info(
287                         "Couldn't extract all volume informations: pool is likely not"
288                         " running or refreshed"
289                     )
290                 return (qemu_target, extra_properties)
291             if disk_type == "file":
292                 qemu_target = source.get("file", "")
293                 if qemu_target.startswith("/dev/zvol/"):
294                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
295                     continue
296                 if qemu_target in all_volumes.keys():
297                     volume = all_volumes[qemu_target]
298                     qemu_target, extra_properties = _get_disk_volume_data(
299                         volume["pool"], volume["name"]
300                     )
301                 elif elem.get("device", "disk") != "cdrom":
302                     try:
303                         process = subprocess.Popen(
304                             [
305                                 "qemu-img",
306                                 "info",
307                                 "-U",
308                                 "--output",
309                                 "json",
310                                 "--backing-chain",
311                                 qemu_target,
312                             ],
313                             shell=False,
314                             stdout=subprocess.PIPE,
315                             stderr=subprocess.PIPE,
316                         )
317                         stdout, stderr = process.communicate()
318                         if process.returncode == 0:
319                             qemu_output = salt.utils.stringutils.to_str(stdout)
320                             output = _parse_qemu_img_info(qemu_output)
321                             extra_properties = output
322                         else:
323                             extra_properties = {"error": stderr}
324                     except FileNotFoundError:
325                         extra_properties = {"error": "qemu-img not found"}
326             elif disk_type == "block":
327                 qemu_target = source.get("dev", "")
328                 if qemu_target in all_volumes.keys():
329                     volume = all_volumes[qemu_target]
330                     qemu_target, extra_properties = _get_disk_volume_data(
331                         volume["pool"], volume["name"]
332                     )
333             elif disk_type == "network":
334                 qemu_target = source.get("protocol")
335                 source_name = source.get("name")
336                 if source_name:
337                     qemu_target = "{}:{}".format(qemu_target, source_name)
338                 if source.get("protocol") in ["rbd", "gluster"]:
339                     for pool_i in conn.listAllStoragePools():
340                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
341                         name_node = pool_i_xml.find("source/name")
342                         if name_node is not None and source_name.startswith(
343                             "{}/".format(name_node.text)
344                         ):
345                             qemu_target = "{}{}".format(
346                                 pool_i.name(), source_name[len(name_node.text) :]
347                             )
348                             break
349                 if elem.get("device", "disk") == "cdrom":
350                     host_node = source.find("host")
351 <a name="16"></a>                    if host_node is not None:
352                         hostname = host_node.get("name")
353                         port = host_node.get("port")
354                         qemu_target <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= urllib.parse.urlunparse(
355                             (
356                                 source.get("protocol"),
357                                 "{}:{}".format(hostname, port) if port else hostname,
358                                 source_name,
359                                 "",
360                                 saxutils.unescape(source.get(</b></font>"query", "")),
361                                 "",
362                             )
363                         )
364             elif disk_type == "volume":
365                 pool_name = source.get("pool")
366                 volume_name = source.get("volume")
367                 qemu_target, extra_properties = _get_disk_volume_data(
368                     pool_name, volume_name
369                 )
370             if not qemu_target:
371                 continue
372             disk = {
373                 "file": qemu_target,
374                 "type": elem.get("device"),
375             }
376             if driver is not None and "type" in driver.attrib:
377                 disk["file format"] = driver.get("type")
378             if extra_properties:
379                 disk.update(extra_properties)
380             disks[target.get("dev")] = disk
381     return disks
382 def _libvirt_creds():
383     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
384     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
385     try:
386         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
387         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
388     except IndexError:
389         group = "root"
390     try:
391         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
392         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
393     except IndexError:
394         user = "root"
395     return {"user": user, "group": group}
396 def _migrate(dom, dst_uri, **kwargs):
397     flags = 0
398     params = {}
399     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
400     if kwargs.get("live", True):
401         flags |= libvirt.VIR_MIGRATE_LIVE
402     if kwargs.get("persistent", True):
403         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
404     if kwargs.get("undefinesource", True):
405         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
406     max_bandwidth = kwargs.get("max_bandwidth")
407     if max_bandwidth:
408         try:
409             bandwidth_value = int(max_bandwidth)
410         except ValueError:
411             raise SaltInvocationError(
412                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
413             )
414         dom.migrateSetMaxSpeed(bandwidth_value)
415     max_downtime = kwargs.get("max_downtime")
416     if max_downtime:
417         try:
418             downtime_value = int(max_downtime)
419         except ValueError:
420             raise SaltInvocationError(
421                 "Invalid max_downtime value: {}".format(max_downtime)
422             )
423         dom.migrateSetMaxDowntime(downtime_value)
424     if kwargs.get("offline") is True:
425         flags |= libvirt.VIR_MIGRATE_OFFLINE
426         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
427     if kwargs.get("compressed") is True:
428         flags |= libvirt.VIR_MIGRATE_COMPRESSED
429     comp_methods = kwargs.get("comp_methods")
430     if comp_methods:
431         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
432     comp_options = {
433         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
434         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
435         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
436         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
437     }
438     for (comp_option, param_key) in comp_options.items():
439         comp_option_value = kwargs.get(comp_option)
440         if comp_option_value:
441             try:
442                 params[param_key] = int(comp_option_value)
443             except ValueError:
444                 raise SaltInvocationError("Invalid {} value".format(comp_option))
445     parallel_connections = kwargs.get("parallel_connections")
446     if parallel_connections:
447         try:
448             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
449                 parallel_connections
450             )
451         except ValueError:
452             raise SaltInvocationError("Invalid parallel_connections value")
453         flags |= libvirt.VIR_MIGRATE_PARALLEL
454     if __salt__["config.get"]("virt:tunnel"):
455         if parallel_connections:
456             raise SaltInvocationError(
457                 "Parallel migration isn't compatible with tunneled migration"
458             )
459         flags |= libvirt.VIR_MIGRATE_PEER2PEER
460         flags |= libvirt.VIR_MIGRATE_TUNNELLED
461     if kwargs.get("postcopy") is True:
462         flags |= libvirt.VIR_MIGRATE_POSTCOPY
463     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
464     if postcopy_bandwidth:
465         try:
466             postcopy_bandwidth_value = int(postcopy_bandwidth)
467         except ValueError:
468             raise SaltInvocationError("Invalid postcopy_bandwidth value")
469         dom.migrateSetMaxSpeed(
470             postcopy_bandwidth_value,
471             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
472         )
473     copy_storage = kwargs.get("copy_storage")
474     if copy_storage:
475         if copy_storage == "all":
476             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
477         elif copy_storage in ["inc", "incremental"]:
478             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
479         else:
480             raise SaltInvocationError("invalid copy_storage value")
481     try:
482         state = False
483         dst_conn = __get_conn(
484             connection=dst_uri,
485             username=kwargs.get("username"),
486             password=kwargs.get("password"),
487         )
488         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
489         if new_dom:
490             state = new_dom.state()
491         dst_conn.close()
492         return state and migrated_state in state
493     except libvirt.libvirtError as err:
494         dst_conn.close()
495         raise CommandExecutionError(err.get_error_message())
496 def _get_volume_path(pool, volume_name):
497     if volume_name in pool.listVolumes():
498         volume = pool.storageVolLookupByName(volume_name)
499         volume_xml = ElementTree.fromstring(volume.XMLDesc())
500         return volume_xml.find("./target/path").text
501     pool_xml = ElementTree.fromstring(pool.XMLDesc())
502     pool_path = pool_xml.find("./target/path").text
503     return pool_path + "/" + volume_name
504 def _disk_from_pool(conn, pool, pool_xml, volume_name):
505     pool_type = pool_xml.get("type")
506     disk_context = {}
507     if pool_type in ["dir", "netfs", "fs"]:
508         disk_context["type"] = "file"
509         disk_context["source_file"] = _get_volume_path(pool, volume_name)
510     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
511         disk_context["type"] = "block"
512         disk_context["format"] = "raw"
513         disk_context["source_file"] = _get_volume_path(pool, volume_name)
514     elif pool_type in ["rbd", "gluster", "sheepdog"]:
515         disk_context["type"] = "network"
516         disk_context["protocol"] = pool_type
517         disk_context["hosts"] = [
518             {"name": host.get("name"), "port": host.get("port")}
519             for host in pool_xml.findall(".//host")
520         ]
521         dir_node = pool_xml.find("./source/dir")
522         name_node = pool_xml.find("./source/name")
523         if name_node is not None:
524             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
525         auth_node = pool_xml.find("./source/auth")
526         if auth_node is not None:
527             username = auth_node.get("username")
528             secret_node = auth_node.find("./secret")
529             usage = secret_node.get("usage")
530             if not usage:
531                 uuid = secret_node.get("uuid")
532                 usage = conn.secretLookupByUUIDString(uuid).usageID()
533             disk_context["auth"] = {
534                 "type": "ceph",
535                 "username": username,
536                 "usage": usage,
537             }
538     return disk_context
539 def _handle_unit(s, def_unit="m"):
540     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
541     value = m.group("value")
542     unit = m.group("unit").lower() or def_unit
543     try:
544         value = int(value)
545     except ValueError:
546         try:
547             value = float(value)
548         except ValueError:
549             raise SaltInvocationError("invalid number")
550     dec = False
551     if re.match(r"[kmgtpezy]b$", unit):
552         dec = True
553     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
554         raise SaltInvocationError("invalid units")
555     p = "bkmgtpezy".index(unit[0])
556     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
557     return int(value)
558 def nesthash(value=None):
559     return collections.defaultdict(nesthash, value or {})
560 def _gen_xml(
561     conn,
562     name,
563     cpu,
564     mem,
565     diskp,
566     nicp,
567     hypervisor,
568     os_type,
569     arch,
570     graphics=None,
571     boot=None,
572     boot_dev=None,
573     numatune=None,
574     hypervisor_features=None,
575     clock=None,
576     serials=None,
577     consoles=None,
578     stop_on_reboot=False,
579     host_devices=None,
580     **kwargs
581 ):
582     context = {
583         "hypervisor": hypervisor,
584         "name": name,
585         "hypervisor_features": hypervisor_features or {},
586         "clock": clock or {},
587         "on_reboot": "destroy" if stop_on_reboot else "restart",
588     }
589     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
590     context["yesno"] = lambda v: "yes" if v else "no"
591     context["mem"] = nesthash()
592     if isinstance(mem, int):
593         context["mem"]["boot"] = mem
594         context["mem"]["current"] = mem
595     elif isinstance(mem, dict):
596         context["mem"] = nesthash(mem)
597     context["cpu"] = nesthash()
598     context["cputune"] = nesthash()
599     if isinstance(cpu, int):
600         context["cpu"]["maximum"] = str(cpu)
601     elif isinstance(cpu, dict):
602         context["cpu"] = nesthash(cpu)
603     if clock:
604         offset = "utc" if clock.get("utc", True) else "localtime"
605         if "timezone" in clock:
606             offset = "timezone"
607         context["clock"]["offset"] = offset
608     if hypervisor in ["qemu", "kvm"]:
609         context["numatune"] = numatune if numatune else {}
610         context["controller_model"] = False
611     elif hypervisor == "vmware":
612         context["controller_model"] = "lsilogic"
613     if graphics:
614         if "listen" not in graphics:
615             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
616         elif (
617             "address" not in graphics["listen"]
618             and graphics["listen"]["type"] == "address"
619         ):
620             graphics["listen"]["address"] = "0.0.0.0"
621         if graphics.get("type", "none") == "none":
622             graphics = None
623     context["graphics"] = graphics
624     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
625     context["boot"] = boot if boot else {}
626     efi_value = context["boot"].get("efi", None) if boot else None
627     if efi_value is True:
628         context["boot"]["os_attrib"] = "firmware='efi'"
629     elif efi_value is not None and type(efi_value) != bool:
630         raise SaltInvocationError("Invalid efi value")
631     if os_type == "xen":
632         if __grains__["os_family"] == "Suse":
633             if not boot or not boot.get("kernel", None):
634                 paths = [
635                     path
636                     for path in ["/usr/share", "/usr/lib"]
637                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
638                 ]
639                 if not paths:
640                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
641                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
642                 context["boot_dev"] = []
643     default_port = 23023
644     default_chardev_type = "tcp"
645     chardev_types = ["serial", "console"]
646     for chardev_type in chardev_types:
647         context[chardev_type + "s"] = []
648         parameter_value = locals()[chardev_type + "s"]
649         if parameter_value is not None:
650             for chardev in parameter_value:
651                 chardev_context = chardev
652                 chardev_context["type"] = chardev.get("type", default_chardev_type)
653                 if chardev_context["type"] == "tcp":
654                     chardev_context["port"] = chardev.get("port", default_port)
655                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
656                 context[chardev_type + "s"].append(chardev_context)
657     context["disks"] = []
658     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
659     targets = []
660     for i, disk in enumerate(diskp):
661         prefix = disk_bus_map.get(disk["model"], "sd")
662         disk_context = {
663             "device": disk.get("device", "disk"),
664             "target_dev": _get_disk_target(targets, len(diskp), prefix),
665             "disk_bus": disk["model"],
666             "format": disk.get("format", "raw"),
667             "index": str(i),
668             "io": disk.get("io", "native"),
669             "iothread": disk.get("iothread_id", None),
670         }
671         targets.append(disk_context["target_dev"])
672         if disk.get("source_file"):
673             url = urllib.parse.urlparse(disk["source_file"])
674             if not url.scheme or not url.hostname:
675                 disk_context["source_file"] = disk["source_file"]
676                 disk_context["type"] = "file"
677             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
678                 disk_context["type"] = "network"
679                 disk_context["protocol"] = url.scheme
680                 disk_context["volume"] = url.path
681                 disk_context["query"] = saxutils.escape(url.query)
682                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
683         elif disk.get("pool"):
684             disk_context["volume"] = disk["filename"]
685             pool = conn.storagePoolLookupByName(disk["pool"])
686             pool_xml = ElementTree.fromstring(pool.XMLDesc())
687             pool_type = pool_xml.get("type")
688             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
689                 disk_context.update(
690                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
691                 )
692             else:
693                 if pool_type in ["disk", "logical"]:
694                     disk_context["format"] = "raw"
695                 disk_context["type"] = "volume"
696                 disk_context["pool"] = disk["pool"]
697         else:
698             disk_context["type"] = "file"
699         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
700             disk_context["address"] = False
701             disk_context["driver"] = True
702         elif hypervisor in ["esxi", "vmware"]:
703             disk_context["address"] = True
704             disk_context["driver"] = False
705         context["disks"].append(disk_context)
706     context["nics"] = nicp
707     hostdev_context = []
708     try:
709         for hostdev_name in host_devices or []:
710             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
711             doc = ElementTree.fromstring(hostdevice.XMLDesc())
712             if "pci" in hostdevice.listCaps():
713                 hostdev_context.append(
714                     {
715                         "type": "pci",
716                         "domain": "0x{:04x}".format(
717                             int(doc.find("./capability[@type='pci']/domain").text)
718                         ),
719                         "bus": "0x{:02x}".format(
720                             int(doc.find("./capability[@type='pci']/bus").text)
721                         ),
722                         "slot": "0x{:02x}".format(
723                             int(doc.find("./capability[@type='pci']/slot").text)
724                         ),
725                         "function": "0x{}".format(
726                             doc.find("./capability[@type='pci']/function").text
727 <a name="30"></a>                        ),
728                     }
729                 )
730             elif "usb_device" in hostdevice<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.listCaps():
731                 vendor_id = doc.find(".//vendor").get("id")
732                 product_id = doc.find(".//product").get(</b></font>"id")
733                 hostdev_context.append(
734                     {"type": "usb", "vendor": vendor_id, "product": product_id}
735                 )
736     except libvirt.libvirtError as err:
737         conn.close()
738         raise CommandExecutionError(
739             "Failed to get host devices: " + err.get_error_message()
740         )
741     context["hostdevs"] = hostdev_context
742     context["os_type"] = os_type
743     context["arch"] = arch
744     fn_ = "libvirt_domain.jinja"
745     try:
746         template = JINJA.get_template(fn_)
747     except jinja2.exceptions.TemplateNotFound:
748         log.error("Could not load template %s", fn_)
749         return ""
750     return template.render(**context)
751 def _gen_vol_xml(
752     name,
753     size,
754     format=None,
755     allocation=0,
756     type=None,
757     permissions=None,
758     backing_store=None,
759     nocow=False,
760 ):
761     size = int(size) * 1024  # MB
762     context = {
763         "type": type,
764         "name": name,
765         "target": {"permissions": permissions, "nocow": nocow},
766         "format": format,
767         "size": str(size),
768         "allocation": str(int(allocation) * 1024),
769         "backingStore": backing_store,
770     }
771     fn_ = "libvirt_volume.jinja"
772     try:
773         template = JINJA.get_template(fn_)
774     except jinja2.exceptions.TemplateNotFound:
775         log.error("Could not load template %s", fn_)
776         return ""
777     return template.render(**context)
778 def _gen_net_xml(
779     name,
780     bridge,
781     forward,
782     vport,
783     tag=None,
784     ip_configs=None,
785     mtu=None,
786     domain=None,
787     nat=None,
788     interfaces=None,
789     addresses=None,
790     physical_function=None,
791     dns=None,
792 ):
793     if isinstance(vport, str):
794         vport_context = {"type": vport}
795     else:
796         vport_context = vport
797     if isinstance(tag, (str, int)):
798         tag_context = {"tags": [{"id": tag}]}
799     else:
800         tag_context = tag
801     addresses_context = []
802     if addresses:
803         matches = [
804             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
805             for addr in addresses.lower().split(" ")
806         ]
807         addresses_context = [
808             {
809                 "domain": m.group(1),
810                 "bus": m.group(2),
811                 "slot": m.group(3),
812                 "function": m.group(4),
813             }
814             for m in matches
815             if m
816         ]
817     context = {
818         "name": name,
819         "bridge": bridge,
820         "mtu": mtu,
821         "domain": domain,
822         "forward": forward,
823         "nat": nat,
824         "interfaces": interfaces.split(" ") if interfaces else [],
825         "addresses": addresses_context,
826         "pf": physical_function,
827         "vport": vport_context,
828         "vlan": tag_context,
829         "dns": dns,
830         "ip_configs": [
831             {
832                 "address": ipaddress.ip_network(config["cidr"]),
833                 "dhcp_ranges": config.get("dhcp_ranges", []),
834                 "hosts": config.get("hosts", {}),
835                 "bootp": config.get("bootp", {}),
836                 "tftp": config.get("tftp"),
837             }
838             for config in ip_configs or []
839         ],
840         "yesno": lambda v: "yes" if v else "no",
841     }
842     fn_ = "libvirt_network.jinja"
843     try:
844         template = JINJA.get_template(fn_)
845     except jinja2.exceptions.TemplateNotFound:
846         log.error("Could not load template %s", fn_)
847         return ""
848     return template.render(**context)
849 def _gen_pool_xml(
850     name,
851     ptype,
852     target=None,
853     permissions=None,
854     source_devices=None,
855     source_dir=None,
856     source_adapter=None,
857     source_hosts=None,
858     source_auth=None,
859     source_name=None,
860     source_format=None,
861     source_initiator=None,
862 ):
863     hosts = [host.split(":") for host in source_hosts or []]
864     source = None
865     if any(
866         [
867             source_devices,
868             source_dir,
869             source_adapter,
870             hosts,
871             source_auth,
872             source_name,
873             source_format,
874             source_initiator,
875         ]
876     ):
877         source = {
878             "devices": source_devices or [],
879             "dir": source_dir
880             if source_format != "cifs" or not source_dir
881             else source_dir.lstrip("/"),
882             "adapter": source_adapter,
883             "hosts": [
884                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
885                 for host in hosts
886             ],
887             "auth": source_auth,
888             "name": source_name,
889             "format": source_format,
890             "initiator": source_initiator,
891         }
892     context = {
893         "name": name,
894         "ptype": ptype,
895         "target": {"path": target, "permissions": permissions},
896         "source": source,
897     }
898     fn_ = "libvirt_pool.jinja"
899     try:
900         template = JINJA.get_template(fn_)
901     except jinja2.exceptions.TemplateNotFound:
902         log.error("Could not load template %s", fn_)
903         return ""
904     return template.render(**context)
905 def _gen_secret_xml(auth_type, usage, description):
906     context = {
907         "type": auth_type,
908         "usage": usage,
909         "description": description,
910     }
911     fn_ = "libvirt_secret.jinja"
912     try:
913         template = JINJA.get_template(fn_)
914     except jinja2.exceptions.TemplateNotFound:
915         log.error("Could not load template %s", fn_)
916         return ""
917     return template.render(**context)
918 def _get_images_dir():
919     img_dir = __salt__["config.get"]("virt:images")
920     log.debug("Image directory from config option `virt:images` is %s", img_dir)
921     return img_dir
922 def _zfs_image_create(
923     vm_name,
924     pool,
925     disk_name,
926     hostname_property_name,
927     sparse_volume,
928     disk_size,
929     disk_image_name,
930 ):
931     if not disk_image_name and not disk_size:
932         raise CommandExecutionError(
933             "Unable to create new disk {}, please specify"
934             " the disk image name or disk size argument".format(disk_name)
935         )
936     if not pool:
937         raise CommandExecutionError(
938             "Unable to create new disk {}, please specify the disk pool name".format(
939                 disk_name
940             )
941         )
942     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
943     log.debug("Image destination will be %s", destination_fs)
944     existing_disk = __salt__["zfs.list"](name=pool)
945     if "error" in existing_disk:
946         raise CommandExecutionError(
947             "Unable to create new disk {}. {}".format(
948                 destination_fs, existing_disk["error"]
949             )
950         )
951     elif destination_fs in existing_disk:
952         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
953         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
954         return blockdevice_path
955     properties = {}
956     if hostname_property_name:
957         properties[hostname_property_name] = vm_name
958     if disk_image_name:
959         __salt__["zfs.clone"](
960             name_a=disk_image_name, name_b=destination_fs, properties=properties
961         )
962     elif disk_size:
963         __salt__["zfs.create"](
964             name=destination_fs,
965             properties=properties,
966             volume_size=disk_size,
967             sparse=sparse_volume,
968         )
969     blockdevice_path = os.path.join(
970         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
971     )
972     log.debug("Image path will be %s", blockdevice_path)
973     return blockdevice_path
974 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
975     disk_size = disk.get("size", None)
976     disk_image = disk<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("image", None)
977     if not disk_size and not disk_image:
978         raise CommandExecutionError(
979             "Unable to create new disk {}, please specify"
980             " disk size and/or disk image argument".format(disk["filename"])
981         )
982     img_dest = disk["source_file"]
983 <a name="25"></a>    log.debug("Image destination will be %s", img_dest)
984     img_dir =</b></font> os.path.dirname(img_dest)
985     log.debug("Image destination directory is %s", img_dir)
986     if not os.path<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.exists(img_dir):
987         os.makedirs(img_dir)
988     if disk_image:
989         log.debug("Create disk from specified image %s", disk_image)
990         sfn = __salt__["cp.cache_file"](disk_image, saltenv)
991         qcow2 =</b></font> False
992         if salt.utils.path.which("qemu-img"):
993             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
994             imageinfo = salt.utils.yaml.safe_load(res)
995             qcow2 = imageinfo["file format"] == "qcow2"
996         try:
997             if create_overlay and qcow2:
998                 log.info("Cloning qcow2 image %s using copy on write", sfn)
999                 __salt__["cmd.run"](
1000                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1001                         sfn, img_dest
1002                     ).split()
1003                 )
1004             else:
1005                 log.debug("Copying %s to %s", sfn, img_dest)
1006                 salt.utils.files.copyfile(sfn, img_dest)
1007             mask = salt.utils.files.get_umask()
1008             if disk_size and qcow2:
1009                 log.debug("Resize qcow2 image to %sM", disk_size)
1010                 __salt__["cmd.run"](
1011                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1012                 )
1013             log.debug("Apply umask and remove exec bit")
1014             mode = (0o0777 ^ mask) &amp; 0o0666
1015             os.chmod(img_dest, mode)
1016         except OSError as err:
1017             raise CommandExecutionError(
1018                 "Problem while copying image. {} - {}".format(disk_image, err)
1019             )
1020     else:
1021         try:
1022             mask = salt.utils.files.get_umask()
1023             if disk_size:
1024                 log.debug("Create empty image with size %sM", disk_size)
1025                 __salt__["cmd.run"](
1026                     'qemu-img create -f {} "{}" {}M'.format(
1027                         disk.get("format", "qcow2"), img_dest, disk_size
1028                     )
1029                 )
1030             else:
1031                 raise CommandExecutionError(
1032                     "Unable to create new disk {},"
1033                     " please specify &lt;size&gt; argument".format(img_dest)
1034                 )
1035             log.debug("Apply umask and remove exec bit")
1036             mode = (0o0777 ^ mask) &amp; 0o0666
1037             os.chmod(img_dest, mode)
1038         except OSError as err:
1039             raise CommandExecutionError(
1040                 "Problem while creating volume {} - {}".format(img_dest, err)
1041             )
1042     return img_dest
1043 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1044     log.debug("Seeding image")
1045     __salt__[seed_cmd](
1046         img_path,
1047         id_=name,
1048         config=config,
1049         install=install,
1050         pub_key=pub_key,
1051         priv_key=priv_key,
1052     )
1053 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1054     if disk.get("overlay_image"):
1055         raise SaltInvocationError(
1056             "Disk overlay_image property is not supported when creating volumes,"
1057             "use backing_store_path and backing_store_format instead."
1058         )
1059     pool = conn.storagePoolLookupByName(disk["pool"])
1060     if disk["filename"] in pool.listVolumes():
1061         return
1062     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1063     backing_path = disk.get("backing_store_path")
1064     backing_format = disk.get("backing_store_format")
1065     backing_store = None
1066     if (
1067         backing_path
1068         and backing_format
1069         and (disk.get("format") == "qcow2" or pool_type == "logical")
1070     ):
1071         backing_store = {"path": backing_path, "format": backing_format}
1072     if backing_store and disk.get("image"):
1073         raise SaltInvocationError(
1074             "Using a template image with a backing store is not possible, "
1075             "choose either of them."
1076         )
1077     vol_xml = _gen_vol_xml(
1078         disk["filename"],
1079         disk.get("size", 0),
1080         format=disk.get("format"),
1081         backing_store=backing_store,
1082     )
1083     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1084     if disk.get("image"):
1085         log.debug("Caching disk template image: %s", disk.get("image"))
1086         cached_path = __salt__["cp.cache_file"](disk.get("image"), saltenv)
1087         if seeder:
1088             seeder(cached_path)
1089         _volume_upload(
1090             conn,
1091             disk["pool"],
1092             disk["filename"],
1093             cached_path,
1094             sparse=disk.get("format") == "qcow2",
1095         )
1096 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1097     default = [{"system": {"size": 8192}}]
1098     if hypervisor == "vmware":
1099         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1100     elif hypervisor in ["qemu", "kvm"]:
1101         overlay = {"device": "disk", "model": "virtio"}
1102     elif hypervisor == "xen":
1103         overlay = {"device": "disk", "model": "xen"}
1104     elif hypervisor == "bhyve":
1105         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1106     else:
1107         overlay = {}
1108     disklist = []
1109     if profile:
1110         disklist = copy.deepcopy(
1111             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1112         )
1113         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1114     if disks:
1115         for udisk in disks:
1116             if "name" in udisk:
1117                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1118                 if found:
1119                     found[0].update(udisk)
1120                 else:
1121                     disklist.append(udisk)
1122     pool_caps = _pool_capabilities(conn)
1123     for disk in disklist:
1124         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1125             disk["model"] = "ide"
1126         for key, val in overlay.items():
1127             if key not in disk:
1128                 disk[key] = val
1129         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1130             disk["filename"] = os.path.basename(disk["source_file"])
1131             if not disk.get("format"):
1132                 disk["format"] = (
1133                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1134                 )
1135         elif vm_name and disk.get("device", "disk") == "disk":
1136             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1137     return disklist
1138 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1139     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1140     base_dir = disk.get("pool", None)
1141     if hypervisor in ["qemu", "kvm", "xen"]:
1142         if not base_dir:
1143             base_dir = _get_images_dir()
1144         if base_dir not in conn.listStoragePools():
1145             if not disk.get("format"):
1146                 disk["format"] = "qcow2"
1147             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1148             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1149         else:
1150             if "pool" not in disk:
1151                 disk["pool"] = base_dir
1152             pool_obj = conn.storagePoolLookupByName(base_dir)
1153             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1154             pool_type = pool_xml.get("type")
1155             if pool_type == "disk":
1156                 device = pool_xml.find("./source/device").get("path")
1157                 all_volumes = pool_obj.listVolumes()
1158                 if disk.get("source_file") not in all_volumes:
1159                     indexes = [
1160                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1161                     ] or [0]
1162                     index = min(
1163                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1164                     )
1165                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1166             if disk.get("source_file"):
1167                 if not disk.get("source_file") in pool_obj.listVolumes():
1168                     raise SaltInvocationError(
1169                         "{} volume doesn't exist in pool {}".format(
1170                             disk.get("source_file"), base_dir
1171                         )
1172                     )
1173                 disk["filename"] = disk["source_file"]
1174                 del disk["source_file"]
1175             if not disk.get("format"):
1176                 volume_options = (
1177                     [
1178                         type_caps.get("options", {}).get("volume", {})
1179                         for type_caps in pool_caps.get("pool_types")
1180                         if type_caps["name"] == pool_type
1181                     ]
1182                     or [{}]
1183                 )[0]
1184                 if "qcow2" in volume_options.get("targetFormatType", []):
1185                     disk["format"] = "qcow2"
1186                 else:
1187                     disk["format"] = volume_options.get("default_format", None)
1188     elif hypervisor == "bhyve" and vm_name:
1189         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1190         disk["source_file"] = os.path.join(
1191             "/dev/zvol", base_dir or "", disk["filename"]
1192         )
1193     elif hypervisor in ["esxi", "vmware"]:
1194         if not base_dir:
1195             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1196         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1197         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1198 def _complete_nics(interfaces, hypervisor):
1199     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1200     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1201     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1202     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1203     overlays = {
1204         "xen": xen_overlay,
1205         "kvm": kvm_overlay,
1206         "qemu": kvm_overlay,
1207         "vmware": vmware_overlay,
1208         "bhyve": bhyve_overlay,
1209     }
1210     def _normalize_net_types(attributes):
1211         for type_ in ["bridge", "network"]:
1212             if type_ in attributes:
1213                 attributes["type"] = type_
1214                 attributes["source"] = attributes.pop(type_)
1215         attributes["type"] = attributes.get("type", None)
1216         attributes["source"] = attributes.get("source", None)
1217     def _apply_default_overlay(attributes):
1218         for key, value in overlays[hypervisor].items():
1219             if key not in attributes or not attributes[key]:
1220                 attributes[key] = value
1221     for interface in interfaces:
1222         _normalize_net_types(interface)
1223         if hypervisor in overlays:
1224             _apply_default_overlay(interface)
1225     return interfaces
1226 def _nic_profile(profile_name, hypervisor):
1227     config_data = __salt__["config.get"]("virt:nic", {}).get(
1228         profile_name, [{"eth0": {}}]
1229     )
1230     interfaces = []
1231     def append_dict_profile_to_interface_list(profile_dict):
1232         for interface_name, attributes in profile_dict.items():
1233             attributes["name"] = interface_name
1234             interfaces.append(attributes)
1235     if isinstance(config_data, dict):
1236         append_dict_profile_to_interface_list(config_data)
1237     elif isinstance(config_data, list):
1238         for interface in config_data:
1239             if isinstance(interface, dict):
1240                 if len(interface) == 1:
1241                     append_dict_profile_to_interface_list(interface)
1242                 else:
1243                     interfaces.append(interface)
1244     return _complete_nics(interfaces, hypervisor)
1245 def _get_merged_nics(hypervisor, profile, interfaces=None):
1246     nicp = _nic_profile(profile, hypervisor) if profile else []
1247     log.debug("NIC profile is %s", nicp)
1248     if interfaces:
1249         users_nics = _complete_nics(interfaces, hypervisor)
1250         for unic in users_nics:
1251             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1252             if found:
1253                 found[0].update(unic)
1254             else:
1255                 nicp.append(unic)
1256         log.debug("Merged NICs: %s", nicp)
1257     return nicp
1258 def _handle_remote_boot_params(orig_boot):
1259     saltinst_dir = None
1260     new_boot = orig_boot.copy()
1261     keys = orig_boot.keys()
1262     cases = [
1263         {"efi"},
1264         {"kernel", "initrd", "efi"},
1265         {"kernel", "initrd", "cmdline", "efi"},
1266         {"loader", "nvram"},
1267         {"kernel", "initrd"},
1268         {"kernel", "initrd", "cmdline"},
1269         {"kernel", "initrd", "loader", "nvram"},
1270         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1271     ]
1272 <a name="19"></a>    if keys in cases:
1273         for key in keys:
1274             if key == "efi" and type(orig_boot.get(key)) == bool:
1275                 new_boot[key] = orig_boot<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get(key)
1276             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1277                 orig_boot.get(key)
1278             ):
1279                 if saltinst_dir is None:
1280                     os.</b></font>makedirs(CACHE_DIR)
1281                     saltinst_dir = CACHE_DIR
1282                 new_boot[key] = salt.utils.virt.download_remote(
1283                     orig_boot.get(key), saltinst_dir
1284                 )
1285         return new_boot
1286     else:
1287         raise SaltInvocationError(
1288             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1289             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1290         )
1291 def _handle_efi_param(boot, desc):
1292     efi_value = boot.get("efi", None) if boot else None
1293     parent_tag = desc.find("os")
1294     os_attrib = parent_tag.attrib
1295     if efi_value is False and os_attrib != {}:
1296         parent_tag.attrib.pop("firmware", None)
1297         return True
1298     elif type(efi_value) == bool and os_attrib == {}:
1299         if efi_value is True and parent_tag.find("loader") is None:
1300             parent_tag.set("firmware", "efi")
1301             return True
1302         if efi_value is False and parent_tag.find("loader") is not None:
1303             parent_tag.remove(parent_tag.find("loader"))
1304             parent_tag.remove(parent_tag.find("nvram"))
1305             return True
1306     elif type(efi_value) != bool:
1307         raise SaltInvocationError("Invalid efi value")
1308     return False
1309 def init(
1310     name,
1311     cpu,
1312 <a name="1"></a>    mem,
1313     nic="default",
1314     interfaces=None,
1315     hypervisor<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
1316     start=True,  # pylint: disable=redefined-outer-name
1317     disk="default",
1318     disks=None,
1319     saltenv="base",
1320     seed=True,
1321     install=True,
1322     pub_key=None,
1323     priv_key=None,
1324     seed_cmd="seed.apply",
1325     graphics=None,
1326     os_type=None,
1327     arch=None,
1328     boot=None,
1329     boot_dev=None,
1330     numatune=None,
1331     hypervisor_features=None,
1332     clock=None,
1333     serials=None,
1334     consoles=None,
1335     stop_on_reboot=False,
1336     host_devices=None,
1337     **kwargs
1338 ):
1339     try</b></font>:
1340         conn = __get_conn(**kwargs)
1341         caps = _capabilities(conn)
1342         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
1343         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
1344         virt_hypervisor = hypervisor
1345         if not virt_hypervisor:
1346             hypervisors = sorted(
1347                 {
1348                     x
1349                     for y in [
1350                         guest["arch"]["domains"].keys() for guest in caps["guests"]
1351                     ]
1352                     for x in y
1353                 }
1354             )
1355             if len(hypervisors) == 0:
1356                 raise SaltInvocationError("No supported hypervisors were found")
1357             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
1358         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
1359         log.debug("Using hypervisor %s", virt_hypervisor)
1360         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
1361         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
1362         for _disk in diskp:
1363             if _disk.get("device", "disk") == "cdrom":
1364                 continue
1365             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
1366             if virt_hypervisor == "vmware":
1367                 if "image" in _disk:
1368                     raise SaltInvocationError(
1369                         "virt.init does not support image "
1370                         "template in conjunction with esxi hypervisor"
1371                     )
1372                 else:
1373                     log.debug("Generating libvirt XML for %s", _disk)
1374                     volume_name = "{}/{}".format(name, _disk["name"])
1375                     filename = "{}.{}".format(volume_name, _disk["format"])
1376                     vol_xml = _gen_vol_xml(
1377                         filename, _disk["size"], format=_disk["format"]
1378                     )
1379                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
1380             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
1381                 def seeder(path):
1382                     _seed_image(
1383                         seed_cmd,
1384                         path,
1385                         name,
1386                         kwargs.get("config"),
1387                         install,
1388                         pub_key,
1389                         priv_key,
1390                     )
1391                 create_overlay = _disk.get("overlay_image", False)
1392                 format = _disk.get("format")
1393                 if _disk.get("source_file"):
1394                     if os.path.exists(_disk["source_file"]):
1395                         img_dest = _disk["source_file"]
1396                     else:
1397                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
1398                 else:
1399                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
1400                     img_dest = None
1401                 if seed and img_dest and _disk.get("image", None):
1402                     seeder(img_dest)
1403 <a name="6"></a>            elif hypervisor in ["bhyve"]:
1404                 img_dest = _zfs_image_create(
1405                     vm_name=name,
1406                     pool<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=_disk.get("pool"),
1407                     disk_name=_disk.get("name"),
1408                     disk_size=_disk.get("size"),
1409                     disk_image_name=_disk.get("image"),
1410                     hostname_property_name=_disk.get("hostname_property"),
1411                     sparse_volume=_disk.get(</b></font>"sparse_volume"),
1412                 )
1413             else:
1414                 raise SaltInvocationError(
1415                     "Unsupported hypervisor when handling disk image: {}".format(
1416                         virt_hypervisor
1417                     )
1418                 )
1419         log.debug("Generating VM XML")
1420         if os_type is None:
1421             os_type = "hvm" if "hvm" in os_types else os_types[0]
1422         if arch is None:
1423             arch = "x86_64" if "x86_64" in arches else arches[0]
1424         if boot is not None:
1425             boot = _handle_remote_boot_params(boot)
1426         vm_xml = _gen_xml(
1427             conn,
1428             name,
1429             cpu,
1430             mem,
1431             diskp,
1432             nicp,
1433             virt_hypervisor,
1434             os_type,
1435             arch,
1436             graphics,
1437             boot,
1438             boot_dev,
1439             numatune,
1440             hypervisor_features,
1441             clock,
1442             serials,
1443             consoles,
1444             stop_on_reboot,
1445             host_devices,
1446             **kwargs
1447         )
1448         log.debug("New virtual machine definition: %s", vm_xml)
1449         conn.defineXML(vm_xml)
1450     except libvirt.libvirtError as err:
1451         conn.close()
1452         raise CommandExecutionError(err.get_error_message())
1453     if start:
1454         log.debug("Starting VM %s", name)
1455         _get_domain(conn, name).create()
1456     conn.close()
1457     return True
1458 def _disks_equal(disk1, disk2):
1459 <a name="3"></a>    """
1460     Test if two disk elements should be considered like the same device
1461     target1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= disk1.find("target")
1462     target2 = disk2.find("target")
1463     disk1_dict = xmlutil.to_dict(disk1, True)
1464     disk2_dict = xmlutil.to_dict(disk2, True)
1465     source1_dict = disk1_dict.get("source", {})
1466     source2_dict = disk2_dict.get("source", {})
1467     io1 = disk1_dict.get(</b></font>"driver", {}).get("io", "native")
1468     io2 = disk2_dict.get("driver", {}).get("io", "native")
1469     if source1_dict:
1470         source1_dict.pop("index", None)
1471     if source2_dict:
1472         source2_dict.pop("index", None)
1473     return (
1474         source1_dict == source2_dict
1475         and target1 is not None
1476         and target2 is not None
1477         and target1.get("bus") == target2.get("bus")
1478         and disk1.get("device", "disk") == disk2.get("device", "disk")
1479         and target1.get("dev") == target2.get("dev")
1480         and io1 == io2
1481     )
1482 def _nics_equal(nic1, nic2):
1483     def _filter_nic(nic):
1484         source_node = nic.find("source")
1485         source_attrib = source_node.attrib if source_node is not None else {}
1486         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
1487         source_getters = {
1488             "network": lambda n: n.get("network"),
1489             "bridge": lambda n: n.get("bridge"),
1490             "direct": lambda n: n.get("dev"),
1491             "hostdev": lambda n: _format_pci_address(n.find("address")),
1492         }
1493         return {
1494             "type": source_type,
1495             "source": source_getters[source_type](source_node)
1496             if source_node is not None
1497             else None,
1498             "model": nic.find("model").attrib["type"]
1499             if nic.find("model") is not None
1500             else None,
1501         }
1502     def _get_mac(nic):
1503         return (
1504             nic.find("mac").attrib["address"].lower()
1505             if nic.find("mac") is not None
1506             else None
1507         )
1508     mac1 = _get_mac(nic1)
1509     mac2 = _get_mac(nic2)
1510     macs_equal = not mac1 or not mac2 or mac1 == mac2
1511     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
1512 def _graphics_equal(gfx1, gfx2):
1513     def _filter_graphics(gfx):
1514         gfx_copy = copy.deepcopy(gfx)
1515         defaults = [
1516             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
1517             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
1518             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
1519         ]
1520         for default in defaults:
1521             node = gfx_copy.find(default["node"])
1522             attrib = default["attrib"]
1523             if node is not None and (
1524                 attrib in node.attrib and node.attrib[attrib] in default["values"]
1525             ):
1526                 node.attrib.pop(attrib)
1527         return gfx_copy
1528     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
1529         _filter_graphics(gfx2), True
1530     )
1531 def _hostdevs_equal(dev1, dev2):
1532     def _filter_hostdevs(dev):
1533         type_ = dev.get("type")
1534         definition = {
1535             "type": type_,
1536         }
1537         if type_ == "pci":
1538             address_node = dev.find("./source/address")
1539             for attr in ["domain", "bus", "slot", "function"]:
1540                 definition[attr] = address_node.get(attr)
1541         elif type_ == "usb":
1542             for attr in ["vendor", "product"]:
1543                 definition[attr] = dev.find("./source/" + attr).get("id")
1544         return definition
1545     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
1546 def _diff_lists(old, new, comparator):
1547     def _remove_indent(node):
1548         node_copy = copy.deepcopy(node)
1549         node_copy.text = None
1550         for item in node_copy.iter():
1551             item.tail = None
1552         return node_copy
1553     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
1554     old_devices = copy.deepcopy(old)
1555     for new_item in new:
1556         found = [
1557             item
1558             for item in old_devices
1559             if comparator(_remove_indent(item), _remove_indent(new_item))
1560         ]
1561         if found:
1562             old_devices.remove(found[0])
1563             diff["unchanged"].append(found[0])
1564             diff["sorted"].append(found[0])
1565         else:
1566             diff["new"].append(new_item)
1567             diff["sorted"].append(new_item)
1568     diff["deleted"] = old_devices
1569     return diff
1570 def _get_disk_target(targets, disks_count, prefix):
1571     for i in range(disks_count):
1572         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
1573         if ret not in targets:
1574             return ret
1575     return None
1576 def _diff_disk_lists(old, new):
1577     targets = []
1578     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
1579     for disk in new:
1580         target_node = disk.find("target")
1581         target = target_node.get("dev")
1582         prefix = [item for item in prefixes if target.startswith(item)][0]
1583         new_target = _get_disk_target(targets, len(new), prefix)
1584         target_node.set("dev", new_target)
1585         targets.append(new_target)
1586     return _diff_lists(old, new, _disks_equal)
1587 def _diff_interface_lists(old, new):
1588     return _diff_lists(old, new, _nics_equal)
1589 def _diff_graphics_lists(old, new):
1590     return _diff_lists(old, new, _graphics_equal)
1591 def _diff_hostdev_lists(old, new):
1592     return _diff_lists(old, new, _hostdevs_equal)
1593 def _expand_cpuset(cpuset):
1594     if cpuset is None:
1595         return None
1596     if isinstance(cpuset, int):
1597         return str(cpuset)
1598     result = set()
1599     toremove = set()
1600 <a name="28"></a>    for part in cpuset.split(","):
1601         m = re.match("([0-9]+)-([0-9]+)", part)
1602         if m:
1603             result |= set<font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(range(int(m.group(1)), int(m.group(2)) + 1))
1604         elif part.startswith("^"):
1605             toremove.add(</b></font>int(part[1:]))
1606         else:
1607             result.add(int(part))
1608     cpus = list(result - toremove)
1609     cpus.sort()
1610     cpus = [str(cpu) for cpu in cpus]
1611     return ",".join(cpus)
1612 def _normalize_cpusets(desc, data):
1613     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
1614     for xpath in xpaths:
1615         nodes = desc.findall(xpath)
1616         for node in nodes:
1617             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
1618     if not isinstance(data.get("cpu"), dict):
1619         return
1620     tuning = data["cpu"].get("tuning", {})
1621     for child in ["cachetune", "memorytune"]:
1622         if tuning.get(child):
1623             new_item = dict()
1624             for cpuset, value in tuning[child].items():
1625                 if child == "cachetune" and value.get("monitor"):
1626                     value["monitor"] = {
1627                         _expand_cpuset(monitor_cpus): monitor
1628                         for monitor_cpus, monitor in value["monitor"].items()
1629                     }
1630                 new_item[_expand_cpuset(cpuset)] = value
1631             tuning[child] = new_item
1632 def _serial_or_concole_equal(old, new):
1633     def _filter_serial_or_concole(item):
1634         return {
1635             "type": item.attrib["type"],
1636             "port": item.find("source").get("service")
1637             if item.find("source") is not None
1638             else None,
1639             "protocol": item.find("protocol").get("type")
1640             if item.find("protocol") is not None
1641             else None,
1642         }
1643     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
1644 def _diff_serial_lists(old, new):
1645     return _diff_lists(old, new, _serial_or_concole_equal)
1646 def _diff_console_lists(old, new):
1647     return _diff_lists(old, new, _serial_or_concole_equal)
1648 def _format_pci_address(node):
1649     return "{}:{}:{}.{}".format(
1650         node.get("domain").replace("0x", ""),
1651         node.get("bus").replace("0x", ""),
1652         node.get("slot").replace("0x", ""),
1653         node.get("function").replace("0x", ""),
1654     )
1655 def _almost_equal(current, new):
1656     if current is None or new is None:
1657         return False
1658     return abs(current - new) / current &lt; 1e-03
1659 def _compute_device_changes(old_xml, new_xml, to_skip):
1660     devices_node = old_xml.find("devices")
1661     changes = {}
1662     for dev_type in to_skip:
1663         changes[dev_type] = {}
1664         if not to_skip[dev_type]:
1665             old = devices_node.findall(dev_type)
1666             new = new_xml.findall("devices/{}".format(dev_type))
1667             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
1668     return changes
1669 def _get_pci_addresses(node):
1670     return {_format_pci_address(address) for address in node.findall(".//address")}
1671 def _correct_networks(conn, desc):
1672     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
1673     nics = desc.findall("devices/interface")
1674     device_map = {}
1675     for nic in nics:
1676         if nic.get("type") == "hostdev":
1677             addr = _get_pci_addresses(nic.find("source"))
1678             matching_nets = [
1679                 net
1680                 for net in networks
1681                 if net.find("forward").get("mode") == "hostdev"
1682                 and addr &amp; _get_pci_addresses(net)
1683             ]
1684             if matching_nets:
1685                 old_xml = ElementTree.tostring(nic)
1686                 nic.set("type", "network")
1687                 nic.find("source").set("network", matching_nets[0].find("name").text)
1688                 device_map[nic] = old_xml
1689     return device_map
1690 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
1691     status = {}
1692     errors = []
1693     if not domain.isActive():
1694         return status, errors
1695     commands = []
1696     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
1697         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
1698         if old_cpu != new_cpu and new_cpu is not None:
1699             commands.append(
1700                 {
1701                     "device": "cpu",
1702                     "cmd": "setVcpusFlags",
1703                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1704                 }
1705             )
1706     if mem:
1707         if isinstance(mem, dict):
1708             new_mem = (
1709                 int(_handle_unit(mem.get("current")) / 1024)
1710                 if "current" in mem
1711                 else None
1712             )
1713         elif isinstance(mem, int):
1714             new_mem = int(mem * 1024)
1715         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
1716             commands.append(
1717                 {
1718                     "device": "mem",
1719                     "cmd": "setMemoryFlags",
1720                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
1721                 }
1722             )
1723     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
1724     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
1725     changes = _compute_device_changes(old_desc, new_desc, to_skip)
1726     removable_changes = []
1727     new_disks = []
1728     for new_disk in changes["disk"].get("new", []):
1729         device = new_disk.get("device", "disk")
1730         if device not in ["cdrom", "floppy"]:
1731             new_disks.append(new_disk)
1732             continue
1733         target_dev = new_disk.find("target").get("dev")
1734         matching = [
1735             old_disk
1736             for old_disk in changes["disk"].get("deleted", [])
1737             if old_disk.get("device", "disk") == device
1738             and old_disk.find("target").get("dev") == target_dev
1739         ]
1740         if not matching:
1741             new_disks.append(new_disk)
1742 <a name="29"></a>        else:
1743             updated_disk = matching[0]
1744             changes["disk"]["deleted"]<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.remove(updated_disk)
1745             removable_changes.append(updated_disk)
1746             source_node = updated_disk.find("source")
1747             new_source_node = new_disk.find("source")
1748             source_file = (
1749                 new_source_node.</b></font>get("file") if new_source_node is not None else None
1750             )
1751             updated_disk.set("type", "file")
1752             if source_node is not None:
1753                 updated_disk.remove(source_node)
1754             if source_file:
1755                 ElementTree.SubElement(
1756                     updated_disk, "source", attrib={"file": source_file}
1757                 )
1758     changes["disk"]["new"] = new_disks
1759     for dev_type in ["disk", "interface", "hostdev"]:
1760         for added in changes[dev_type].get("new", []):
1761             commands.append(
1762                 {
1763                     "device": dev_type,
1764                     "cmd": "attachDevice",
1765                     "args": [xmlutil.element_to_str(added)],
1766                 }
1767             )
1768         for removed in changes[dev_type].get("deleted", []):
1769             removed_def = changed_devices.get(dev_type, {}).get(
1770                 removed, ElementTree.tostring(removed)
1771             )
1772             commands.append(
1773                 {
1774                     "device": dev_type,
1775                     "cmd": "detachDevice",
1776                     "args": [salt.utils.stringutils.to_str(removed_def)],
1777                 }
1778             )
1779     for updated_disk in removable_changes:
1780         commands.append(
1781             {
1782                 "device": "disk",
1783                 "cmd": "updateDeviceFlags",
1784                 "args": [xmlutil.element_to_str(updated_disk)],
1785             }
1786         )
1787     for cmd in commands:
1788         try:
1789             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
1790             device_type = cmd["device"]
1791             if device_type in ["cpu", "mem"]:
1792                 status[device_type] = not ret
1793             else:
1794                 actions = {
1795                     "attachDevice": "attached",
1796                     "detachDevice": "detached",
1797                     "updateDeviceFlags": "updated",
1798                 }
1799                 device_status = status.setdefault(device_type, {})
1800                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
1801                 cmd_status.append(cmd["args"][0])
1802         except libvirt.libvirtError as err:
1803             errors.append(str(err))
1804     return status, errors
1805 def update(
1806     name,
1807     cpu=0,
1808     mem=0,
1809     disk_profile=None,
1810     disks=None,
1811     nic_profile=None,
1812     interfaces=None,
1813     graphics=None,
1814     live=True,
1815     boot=None,
1816     numatune=None,
1817     test=False,
1818     boot_dev=None,
1819     hypervisor_features=None,
1820     clock=None,
1821     serials=None,
1822     consoles=None,
1823     stop_on_reboot=False,
1824     host_devices=None,
1825     **kwargs
1826 ):
1827     status = {
1828         "definition": False,
1829         "disk": {"attached": [], "detached": [], "updated": []},
1830         "interface": {"attached": [], "detached": []},
1831     }
1832     conn = __get_conn(**kwargs)
1833     domain = _get_domain(conn, name)
1834     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
1835     need_update = False
1836     hypervisor = desc.get("type")
1837     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
1838     if boot is not None:
1839         boot = _handle_remote_boot_params(boot)
1840         if boot.get("efi", None) is not None:
1841             need_update = _handle_efi_param(boot, desc)
1842     new_desc = ElementTree.fromstring(
1843         _gen_xml(
1844             conn,
1845             name,
1846             cpu,
1847             mem or 0,
1848             all_disks,
1849             _get_merged_nics(hypervisor, nic_profile, interfaces),
1850             hypervisor,
1851             domain.OSType(),
1852             desc.find(".//os/type").get("arch"),
1853             graphics,
1854             boot,
1855             boot_dev,
1856             numatune,
1857             serials=serials,
1858             consoles=consoles,
1859             stop_on_reboot=stop_on_reboot,
1860             host_devices=host_devices,
1861             **kwargs
1862         )
1863     )
1864     if clock:
1865         offset = "utc" if clock.get("utc", True) else "localtime"
1866         if "timezone" in clock:
1867             offset = "timezone"
1868         clock["offset"] = offset
1869     def _set_loader(node, value):
1870         salt.utils.xmlutil.set_node_text(node, value)
1871         if value is not None:
1872             node.set("readonly", "yes")
1873             node.set("type", "pflash")
1874     def _set_nvram(node, value):
1875         node.set("template", value)
1876     def _set_with_byte_unit(attr_name=None):
1877         def _setter(node, value):
1878             if attr_name:
1879                 node.set(attr_name, str(value))
1880             else:
1881                 node.text = str(value)
1882             node.set("unit", "bytes")
1883         return _setter
1884     def _get_with_unit(node):
1885         unit = node.get("unit", "KiB")
1886         unit = unit if unit != "bytes" else "b"
1887         value = node.get("memory") or node.get("size") or node.text
1888         return _handle_unit("{}{}".format(value, unit)) if value else None
1889     def _set_vcpu(node, value):
1890         node.text = str(value)
1891         node.set("current", str(value))
1892     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
1893     old_cpu = int(desc.find("./vcpu").text)
1894     def _yesno_attribute(path, xpath, attr_name, ignored=None):
1895         return xmlutil.attribute(
1896             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
1897         )
1898     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
1899         entry = {
1900             "path": path,
1901             "xpath": xpath,
1902             "convert": _handle_unit,
1903             "get": _get_with_unit,
1904             "set": _set_with_byte_unit(attr_name),
1905             "equals": _almost_equal,
1906         }
1907         if attr_name:
1908             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1909         return entry
1910     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
1911         def _set_cpuset(node, value):
1912             if attr_name:
1913                 node.set(attr_name, value)
1914             else:
1915                 node.text = value
1916         entry = {
1917             "path": path,
1918             "xpath": xpath,
1919             "convert": _expand_cpuset,
1920             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
1921             "set": _set_cpuset,
1922         }
1923         if attr_name:
1924             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
1925         return entry
1926     data = {k: v for k, v in locals().items() if bool(v)}
1927     data["stop_on_reboot"] = stop_on_reboot
1928     if boot_dev:
1929         data["boot_dev"] = boot_dev.split()
1930     timer_names = [
1931         "platform",
1932         "hpet",
1933         "kvmclock",
1934         "pit",
1935         "rtc",
1936         "tsc",
1937         "hypervclock",
1938         "armvtimer",
1939     ]
1940     if data.get("clock", {}).get("timers"):
1941         attributes = [
1942             "track",
1943             "tickpolicy",
1944             "frequency",
1945             "mode",
1946             "present",
1947             "slew",
1948             "threshold",
1949             "limit",
1950         ]
1951         for timer in data["clock"]["timers"].values():
1952             for attribute in attributes:
1953                 if attribute not in timer:
1954                     timer[attribute] = None
1955         for timer_name in timer_names:
1956             if timer_name not in data["clock"]["timers"]:
1957                 data["clock"]["timers"][timer_name] = None
1958     _normalize_cpusets(desc, data)
1959     params_mapping = [
1960         {
1961             "path": "stop_on_reboot",
1962             "xpath": "on_reboot",
1963             "convert": lambda v: "destroy" if v else "restart",
1964         },
1965         {"path": "boot:kernel", "xpath": "os/kernel"},
1966         {"path": "boot:initrd", "xpath": "os/initrd"},
1967         {"path": "boot:cmdline", "xpath": "os/cmdline"},
1968         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
1969         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
1970         _memory_parameter("mem", "memory"),
1971         _memory_parameter("mem", "currentMemory"),
1972         _memory_parameter("mem:max", "maxMemory"),
1973         _memory_parameter("mem:boot", "memory"),
1974         _memory_parameter("mem:current", "currentMemory"),
1975         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
1976         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
1977         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
1978         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
1979         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
1980         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
1981         _memory_parameter(
1982             "mem:hugepages:{id}:size",
1983             "memoryBacking/hugepages/page[$id]",
1984             "size",
1985             ["unit", "nodeset"],
1986         ),
1987         _cpuset_parameter(
1988             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
1989         ),
1990         {
1991             "path": "mem:nosharepages",
1992             "xpath": "memoryBacking/nosharepages",
1993             "get": lambda n: n is not None,
1994             "set": lambda n, v: None,
1995         },
1996         {
1997             "path": "mem:locked",
1998             "xpath": "memoryBacking/locked",
1999             "get": lambda n: n is not None,
2000             "set": lambda n, v: None,
2001         },
2002         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
2003         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
2004         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
2005         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
2006         {
2007             "path": "cpu",
2008             "xpath": "vcpu",
2009             "get": lambda n: int(n.text),
2010             "set": _set_vcpu,
2011         },
2012         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
2013         xmlutil.attribute("cpu:placement", "vcpu", "placement"),
2014         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
2015         xmlutil.attribute("cpu:current", "vcpu", "current"),
2016         xmlutil.attribute("cpu:match", "cpu", "match"),
2017         xmlutil.attribute("cpu:mode", "cpu", "mode"),
2018         xmlutil.attribute("cpu:check", "cpu", "check"),
2019         {"path": "cpu:model:name", "xpath": "cpu/model"},
2020         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
2021         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
2022         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
2023         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
2024         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
2025         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
2026         xmlutil.attribute("cpu:cache:level", "cpu/cache", "level"),
2027         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
2028         xmlutil.attribute(
2029             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
2030         ),
2031         _yesno_attribute(
2032             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
2033         ),
2034         _yesno_attribute(
2035             "cpu:vcpus:{id}:hotpluggable",
2036             "vcpus/vcpu[@id='$id']",
2037             "hotpluggable",
2038             ["id"],
2039         ),
2040         xmlutil.int_attribute(
2041             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
2042         ),
2043         _cpuset_parameter(
2044             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
2045         ),
2046         _memory_parameter(
2047             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
2048         ),
2049         _yesno_attribute(
2050             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
2051         ),
2052 <a name="18"></a>        xmlutil.attribute(
2053             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
2054         ),
2055         xmlutil<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
2056             "cpu:numa:{id}:distances:{sid}",
2057             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
2058             "value",
2059             ["id"],
2060         ),
2061         {"path": "cpu:iothreads", "xpath": "iothreads"},
2062         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
2063         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
2064         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
2065         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
2066         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
2067         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
2068         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
2069         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
2070         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
2071         _cpuset_parameter(</b></font>
2072             "cpu:tuning:vcpupin:{id}",
2073             "cputune/vcpupin[@vcpu='$id']",
2074             "cpuset",
2075             ["vcpu"],
2076         ),
2077         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
2078         _cpuset_parameter(
2079             "cpu:tuning:iothreadpin:{id}",
2080             "cputune/iothreadpin[@iothread='$id']",
2081             "cpuset",
2082             ["iothread"],
2083         ),
2084         xmlutil.attribute(
2085             "cpu:tuning:vcpusched:{id}:scheduler",
2086             "cputune/vcpusched[$id]",
2087             "scheduler",
2088             ["priority", "vcpus"],
2089         ),
2090         xmlutil.attribute(
2091             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
2092         ),
2093         _cpuset_parameter(
2094             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
2095         ),
2096         xmlutil.attribute(
2097             "cpu:tuning:iothreadsched:{id}:scheduler",
2098             "cputune/iothreadsched[$id]",
2099             "scheduler",
2100             ["priority", "iothreads"],
2101         ),
2102         xmlutil.attribute(
2103             "cpu:tuning:iothreadsched:{id}:priority",
2104             "cputune/iothreadsched[$id]",
2105             "priority",
2106         ),
2107         _cpuset_parameter(
2108             "cpu:tuning:iothreadsched:{id}:iothreads",
2109             "cputune/iothreadsched[$id]",
2110             "iothreads",
2111         ),
2112         xmlutil.attribute(
2113             "cpu:tuning:emulatorsched:scheduler",
2114             "cputune/emulatorsched",
2115             "scheduler",
2116             ["priority"],
2117         ),
2118         xmlutil.attribute(
2119             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
2120         ),
2121         xmlutil.attribute(
2122             "cpu:tuning:cachetune:{id}:monitor:{sid}",
2123             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
2124             "level",
2125             ["vcpus"],
2126         ),
2127         xmlutil.attribute(
2128             "cpu:tuning:memorytune:{id}:{sid}",
2129             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
2130             "bandwidth",
2131             ["id", "vcpus"],
2132         ),
2133         xmlutil.attribute("clock:offset", "clock", "offset"),
2134         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
2135         xmlutil.attribute("clock:timezone", "clock", "timezone"),
2136     ]
2137     for timer in timer_names:
2138         params_mapping += [
2139             xmlutil.attribute(
2140                 "clock:timers:{}:track".format(timer),
2141                 "clock/timer[@name='{}']".format(timer),
2142                 "track",
2143                 ["name"],
2144             ),
2145             xmlutil.attribute(
2146                 "clock:timers:{}:tickpolicy".format(timer),
2147                 "clock/timer[@name='{}']".format(timer),
2148                 "tickpolicy",
2149                 ["name"],
2150             ),
2151             xmlutil.int_attribute(
2152                 "clock:timers:{}:frequency".format(timer),
2153                 "clock/timer[@name='{}']".format(timer),
2154                 "frequency",
2155                 ["name"],
2156             ),
2157             xmlutil.attribute(
2158                 "clock:timers:{}:mode".format(timer),
2159                 "clock/timer[@name='{}']".format(timer),
2160                 "mode",
2161                 ["name"],
2162             ),
2163             _yesno_attribute(
2164                 "clock:timers:{}:present".format(timer),
2165                 "clock/timer[@name='{}']".format(timer),
2166                 "present",
2167                 ["name"],
2168             ),
2169         ]
2170         for attr in ["slew", "threshold", "limit"]:
2171             params_mapping.append(
2172                 xmlutil.int_attribute(
2173                     "clock:timers:{}:{}".format(timer, attr),
2174                     "clock/timer[@name='{}']/catchup".format(timer),
2175                     attr,
2176                 )
2177             )
2178     for attr in ["level", "type", "size"]:
2179         params_mapping.append(
2180             xmlutil.attribute(
2181                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
2182                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
2183                 attr,
2184                 ["id", "unit", "vcpus"],
2185             )
2186         )
2187     if hypervisor in ["qemu", "kvm"]:
2188         params_mapping += [
2189             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
2190             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
2191             xmlutil.attribute(
2192                 "numatune:memnodes:{id}:mode",
2193                 "numatune/memnode[@cellid='$id']",
2194                 "mode",
2195                 ["cellid"],
2196             ),
2197             _cpuset_parameter(
2198                 "numatune:memnodes:{id}:nodeset",
2199                 "numatune/memnode[@cellid='$id']",
2200                 "nodeset",
2201                 ["cellid"],
2202             ),
2203             xmlutil.attribute(
2204                 "hypervisor_features:kvm-hint-dedicated",
2205                 "features/kvm/hint-dedicated",
2206                 "state",
2207                 convert=lambda v: "on" if v else "off",
2208             ),
2209         ]
2210     need_update = (
2211         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
2212     )
2213     devices_node = desc.find("devices")
2214     func_locals = locals()
2215     def _skip_update(names):
2216         return all(func_locals.get(n) is None for n in names)
2217     to_skip = {
2218         "disk": _skip_update(["disks", "disk_profile"]),
2219         "interface": _skip_update(["interfaces", "nic_profile"]),
2220         "graphics": _skip_update(["graphics"]),
2221         "serial": _skip_update(["serials"]),
2222         "console": _skip_update(["consoles"]),
2223         "hostdev": _skip_update(["host_devices"]),
2224     }
2225     changes = _compute_device_changes(desc, new_desc, to_skip)
2226     for dev_type in changes:
2227         if not to_skip[dev_type]:
2228             old = devices_node.findall(dev_type)
2229             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
2230                 for item in old:
2231                     devices_node.remove(item)
2232                 devices_node.extend(changes[dev_type]["sorted"])
2233                 need_update = True
2234     if need_update:
2235         try:
2236             if changes["disk"]:
2237                 for idx, item in enumerate(changes["disk"]["sorted"]):
2238                     source_file = all_disks[idx].get("source_file")
2239                     if all_disks[idx].get("device", "disk") == "cdrom":
2240                         continue
2241                     if (
2242                         item in changes["disk"]["new"]
2243                         and source_file
2244                         and not os.path.exists(source_file)
2245                     ):
2246                         _qemu_image_create(all_disks[idx])
2247                     elif item in changes["disk"]["new"] and not source_file:
2248                         _disk_volume_create(conn, all_disks[idx])
2249             if not test:
2250                 xml_desc = xmlutil.element_to_str(desc)
2251                 log.debug("Update virtual machine definition: %s", xml_desc)
2252                 conn.defineXML(xml_desc)
2253             status["definition"] = True
2254         except libvirt.libvirtError as err:
2255             conn.close()
2256             raise err
2257     if live:
2258         live_status, errors = _update_live(
2259             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
2260         )
2261         status.update(live_status)
2262         if errors:
2263             status_errors = status.setdefault("errors", [])
2264             status_errors += errors
2265     conn.close()
2266     return status
2267 def list_domains(**kwargs):
2268     vms = []
2269     conn = __get_conn(**kwargs)
2270     for dom in _get_domain(conn, iterable=True):
2271         vms.append(dom.name())
2272     conn.close()
2273     return vms
2274 def list_active_vms(**kwargs):
2275     vms = []
2276     conn = __get_conn(**kwargs)
2277     for dom in _get_domain(conn, iterable=True, inactive=False):
2278         vms.append(dom.name())
2279     conn.close()
2280     return vms
2281 def list_inactive_vms(**kwargs):
2282     vms = []
2283     conn = __get_conn(**kwargs)
2284     for dom in _get_domain(conn, iterable=True, active=False):
2285         vms.append(dom.name())
2286     conn.close()
2287     return vms
2288 def vm_info(vm_=None, **kwargs):
2289     def _info(conn, dom):
2290         raw = dom.info()
2291         return {
2292             "cpu": raw[3],
2293             "cputime": int(raw[4]),
2294             "disks": _get_disks(conn, dom),
2295             "graphics": _get_graphics(dom),
2296             "nics": _get_nics(dom),
2297             "uuid": _get_uuid(dom),
2298             "loader": _get_loader(dom),
2299             "on_crash": _get_on_crash(dom),
2300             "on_reboot": _get_on_reboot(dom),
2301             "on_poweroff": _get_on_poweroff(dom),
2302             "maxMem": int(raw[1]),
2303             "mem": int(raw[2]),
2304             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
2305         }
2306     info = {}
2307     conn = __get_conn(**kwargs)
2308     if vm_:
2309         info[vm_] = _info(conn, _get_domain(conn, vm_))
2310     else:
2311         for domain in _get_domain(conn, iterable=True):
2312             info[domain.name()] = _info(conn, domain)
2313     conn.close()
2314     return info
2315 def vm_state(vm_=None, **kwargs):
2316     def _info(dom):
2317         state = ""
2318         raw = dom.info()
2319         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
2320         return state
2321     info = {}
2322     conn = __get_conn(**kwargs)
2323     if vm_:
2324         info[vm_] = _info(_get_domain(conn, vm_))
2325     else:
2326         for domain in _get_domain(conn, iterable=True):
2327             info[domain.name()] = _info(domain)
2328     conn.close()
2329     return info
2330 def _node_info(conn):
2331     raw = conn.getInfo()
2332     info = {
2333         "cpucores": raw[6],
2334         "cpumhz": raw[3],
2335         "cpumodel": str(raw[0]),
2336         "cpus": raw[2],
2337         "cputhreads": raw[7],
2338         "numanodes": raw[4],
2339         "phymemory": raw[1],
2340         "sockets": raw[5],
2341     }
2342     return info
2343 def node_info(**kwargs):
2344     conn = __get_conn(**kwargs)
2345     info = _node_info(conn)
2346     conn.close()
2347     return info
2348 def _node_devices(conn):
2349     devices = conn.listAllDevices()
2350     devices_infos = []
2351     for dev in devices:
2352         root = ElementTree.fromstring(dev.XMLDesc())
2353         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
2354             continue
2355         infos = {
2356             "caps": " ".join(dev.listCaps()),
2357         }
2358         if "net" in dev.listCaps():
2359 <a name="15"></a>            parent = root.find(".//parent").text
2360             if parent == "computer":
2361                 c<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ontinue
2362             infos.update(
2363                 {
2364                     "name": root.find(".//interface").text,
2365                     "address": root.find(".//address").text,
2366                     "device name": parent,
2367                     "state": root.find(".//link").</b></font>get("state"),
2368                 }
2369             )
2370             devices_infos.append(infos)
2371 <a name="23"></a>            continue
2372         vendor_node = root.find(".//vendor")
2373         vendor_id = vendor_node<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("id").lower()
2374         product_node = root.find(".//product")
2375         product_id = product_node.get("id").lower(</b></font>)
2376         infos.update(
2377             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
2378         )
2379         if vendor_node.text:
2380             infos["vendor"] = vendor_node.text
2381         if product_node.text:
2382             infos["product"] = product_node.text
2383         if "pci" in dev.listCaps():
2384             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
2385                 int(root.find(".//domain").text),
2386                 int(root.find(".//bus").text),
2387                 int(root.find(".//slot").text),
2388                 root.find(".//function").text,
2389             )
2390             class_node = root.find(".//class")
2391             if class_node is not None:
2392                 infos["PCI class"] = class_node.text
2393             vf_addresses = [
2394                 _format_pci_address(vf)
2395                 for vf in root.findall(
2396                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
2397                 )
2398             ]
2399             if vf_addresses:
2400                 infos["virtual functions"] = vf_addresses
2401             pf = root.find(
2402                 "./capability[@type='pci']/capability[@type='phys_function']/address"
2403             )
2404             if pf is not None:
2405                 infos["physical function"] = _format_pci_address(pf)
2406         elif "usb_device" in dev.listCaps():
2407             infos["address"] = "{:03}:{:03}".format(
2408                 int(root.find(".//bus").text), int(root.find(".//device").text)
2409             )
2410         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
2411             "0x0001",
2412             "0x0002",
2413             "0x0003",
2414         ]
2415         if (
2416             root.find(".//capability[@type='pci-bridge']") is None
2417             and not linux_usb_host
2418         ):
2419             devices_infos.append(infos)
2420     return devices_infos
2421 def node_devices(**kwargs):
2422     conn = __get_conn(**kwargs)
2423     devs = _node_devices(conn)
2424     conn.close()
2425     return devs
2426 def get_nics(vm_, **kwargs):
2427     conn = __get_conn(**kwargs)
2428     nics = _get_nics(_get_domain(conn, vm_))
2429     conn.close()
2430     return nics
2431 def get_macs(vm_, **kwargs):
2432     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
2433     return [node.get("address") for node in doc.findall("devices/interface/mac")]
2434 def get_graphics(vm_, **kwargs):
2435     conn = __get_conn(**kwargs)
2436     graphics = _get_graphics(_get_domain(conn, vm_))
2437     conn.close()
2438     return graphics
2439 def get_loader(vm_, **kwargs):
2440     conn = __get_conn(**kwargs)
2441     try:
2442         loader = _get_loader(_get_domain(conn, vm_))
2443         return loader
2444     finally:
2445         conn.close()
2446 def get_disks(vm_, **kwargs):
2447     conn = __get_conn(**kwargs)
2448     disks = _get_disks(conn, _get_domain(conn, vm_))
2449     conn.close()
2450     return disks
2451 def setmem(vm_, memory, config=False, **kwargs):
2452     conn = __get_conn(**kwargs)
2453     dom = _get_domain(conn, vm_)
2454     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2455         return False
2456     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
2457     if config:
2458         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2459     ret1 = dom.setMemoryFlags(memory * 1024, flags)
2460     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2461     conn.close()
2462     return ret1 == ret2 == 0
2463 def setvcpus(vm_, vcpus, config=False, **kwargs):
2464     conn = __get_conn(**kwargs)
2465     dom = _get_domain(conn, vm_)
2466     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
2467         return False
2468     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
2469     if config:
2470         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
2471     ret1 = dom.setVcpusFlags(vcpus, flags)
2472     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
2473     conn.close()
2474     return ret1 == ret2 == 0
2475 def _freemem(conn):
2476     mem = conn.getInfo()[1]
2477     mem -= 256
2478     for dom in _get_domain(conn, iterable=True):
2479         if dom<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.ID() &gt; 0:
2480             mem -= dom.info()[2] / 1024
2481     return mem
2482 def freemem(**kwargs):
2483     conn =</b></font> __get_conn(**kwargs)
2484     mem = _freemem(conn)
2485     conn.close()
2486     return mem
2487 def _freecpu(conn):
2488     cpus = conn.getInfo()[2]
2489     for dom in _get_domain(conn, iterable=True):
2490         if dom.ID() &gt; 0:
2491             cpus -= dom.info()[3]
2492     return cpus
2493 def freecpu(**kwargs):
2494     conn = __get_conn(**kwargs)
2495     cpus = _freecpu(conn)
2496     conn.close()
2497     return cpus
2498 def full_info(**kwargs):
2499     conn = __get_conn(**kwargs)
2500     info = {
2501         "freecpu": _freecpu(conn),
2502         "freemem": _freemem(conn),
2503         "node_info": _node_info(conn),
2504         "vm_info": vm_info(),
2505     }
2506     conn.close()
2507     return info
2508 def get_xml(vm_, **kwargs):
2509     conn = __get_conn(**kwargs)
2510     xml_desc = (
2511         vm_.XMLDesc(0)
2512         if isinstance(vm_, libvirt.virDomain)
2513         else _get_domain(conn, vm_).XMLDesc(0)
2514     )
2515     conn.close()
2516     return xml_desc
2517 def get_profiles(hypervisor=None, **kwargs):
2518     conn = __get_conn(**kwargs)
2519     caps = _capabilities(conn)
2520     hypervisors = sorted(
2521         {
2522             x
2523             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
2524             for x in y
2525         }
2526     )
2527     if len(hypervisors) == 0:
2528         raise SaltInvocationError("No supported hypervisors were found")
2529     if not hypervisor:
2530         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2531     ret = {
2532         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
2533         "nic": {"default": _nic_profile("default", hypervisor)},
2534     }
2535     virtconf = __salt__["config.get"]("virt", {})
2536     for profile in virtconf.get("disk", []):
2537         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
2538     for profile in virtconf.get("nic", []):
2539         ret["nic"][profile] = _nic_profile(profile, hypervisor)
2540     return ret
2541 def shutdown(vm_, **kwargs):
2542     conn = __get_conn(**kwargs)
2543     dom = _get_domain(conn, vm_)
2544     ret = dom.shutdown() == 0
2545     conn.close()
2546     return ret
2547 def pause(vm_, **kwargs):
2548     conn = __get_conn(**kwargs)
2549     dom = _get_domain(conn, vm_)
2550     ret = dom.suspend() == 0
2551     conn.close()
2552     return ret
2553 def resume(vm_, **kwargs):
2554     conn = __get_conn(**kwargs)
2555     dom = _get_domain(conn, vm_)
2556     ret = dom.resume() == 0
2557     conn.close()
2558     return ret
2559 def start(name, **kwargs):
2560     conn = __get_conn(**kwargs)
2561     ret = _get_domain(conn, name).create() == 0
2562     conn.close()
2563     return ret
2564 def stop(name, **kwargs):
2565     conn = __get_conn(**kwargs)
2566     ret = _get_domain(conn, name).destroy() == 0
2567     conn.close()
2568     return ret
2569 def reboot(name, **kwargs):
2570     conn = __get_conn(**kwargs)
2571     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
2572     conn.close()
2573     return ret
2574 def reset(vm_, **kwargs):
2575     conn = __get_conn(**kwargs)
2576     dom = _get_domain(conn, vm_)
2577     ret = dom.reset(0) == 0
2578     conn.close()
2579     return ret
2580 def ctrl_alt_del(vm_, **kwargs):
2581     conn = __get_conn(**kwargs)
2582     dom = _get_domain(conn, vm_)
2583     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
2584     conn.close()
2585     return ret
2586 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2587     conn = __get_conn(**kwargs)
2588     ret = conn.createXML(xml, 0) is not None
2589     conn.close()
2590     return ret
2591 def create_xml_path(path, **kwargs):
2592     try:
2593         with salt.utils.files.fopen(path, "r") as fp_:
2594             return create_xml_str(
2595                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2596             )
2597     except OSError:
2598         return False
2599 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
2600     conn = __get_conn(**kwargs)
2601     ret = conn.defineXML(xml) is not None
2602     conn.close()
2603     return ret
2604 def define_xml_path(path, **kwargs):
2605     try:
2606         with salt.utils.files.fopen(path, "r") as fp_:
2607             return define_xml_str(
2608                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
2609             )
2610     except OSError:
2611         return False
2612 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
2613     default_pool = "default" if conn.getType() != "ESX" else "0"
2614     poolname = (
2615         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
2616     )
2617     pool = conn.storagePoolLookupByName(str(poolname))
2618     ret = pool.createXML(xml, 0) is not None
2619     return ret
2620 def define_vol_xml_str(
2621     xml, pool=None, **kwargs
2622 ):  # pylint: disable=redefined-outer-name
2623     conn = __get_conn(**kwargs)
2624     ret = False
2625     try:
2626         ret = _define_vol_xml_str(conn, xml, pool=pool)
2627     except libvirtError as err:
2628         raise CommandExecutionError(err.get_error_message())
2629     finally:
2630         conn.close()
2631     return ret
2632 def define_vol_xml_path(path, pool=None, **kwargs):
2633     try:
2634         with salt.utils.files.fopen(path, "r") as fp_:
2635             return define_vol_xml_str(
2636                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
2637             )
2638     except OSError:
2639         return False
2640 def migrate(vm_, target, **kwargs):
2641     conn = __get_conn()
2642     dom = _get_domain(conn, vm_)
2643     if not urllib.parse.urlparse(target).scheme:
2644         proto = "qemu"
2645         dst_uri = "{}://{}/system".format(proto, target)
2646     else:
2647         dst_uri = target
2648     ret = _migrate(dom, dst_uri, **kwargs)
2649     conn.close()
2650     return ret
2651 def migrate_start_postcopy(vm_):
2652     conn = __get_conn()
2653     dom = _get_domain(conn, vm_)
2654     try:
2655         dom.migrateStartPostCopy()
2656     except libvirt.libvirtError as err:
2657         conn.close()
2658         raise CommandExecutionError(err.get_error_message())
2659     conn.close()
2660 def seed_non_shared_migrate(disks, force=False):
2661     for _, data in disks.items():
2662         fn_ = data["file"]
2663         form = data["file format"]
2664         size = data["virtual size"].split()[1][1:]
2665         if os.path.isfile(fn_) and not force:
2666             pre = salt.utils.yaml.safe_load(
2667                 subprocess.Popen(
2668                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
2669                 ).communicate()[0]
2670             )
2671             if (
2672                 pre["file format"] != data["file format"]
2673 <a name="24"></a>                and pre["virtual size"] != data["virtual size"]
2674             ):
2675                 return False
2676         if not os.path<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.isdir(os.path.dirname(fn_)):
2677             os.makedirs(os.path.dirname(fn_))
2678         if</b></font> os.path.isfile(fn_):
2679             os.remove(fn_)
2680         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
2681         creds = _libvirt_creds()
2682         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
2683     return True
2684 def set_autostart(vm_, state="on", **kwargs):
2685     conn = __get_conn(**kwargs)
2686     dom = _get_domain(conn, vm_)
2687     ret = False
2688     if state == "on":
2689         ret = dom.setAutostart(1) == 0
2690     elif state == "off":
2691         ret = dom.setAutostart(0) == 0
2692     conn.close()
2693     return ret
2694 def undefine(vm_, **kwargs):
2695     conn = __get_conn(**kwargs)
2696     dom = _get_domain(conn, vm_)
2697     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2698         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
2699     else:
2700         ret = dom.undefine() == 0
2701     conn.close()
2702     return ret
2703 def purge(vm_, dirs=False, removables=False, **kwargs):
2704     conn = __get_conn(**kwargs)
2705     dom = _get_domain(conn, vm_)
2706     disks = _get_disks(conn, dom)
2707     if (
2708         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
2709         and dom.destroy() != 0
2710     ):
2711         return False
2712     directories = set()
2713     for disk in disks:
2714         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
2715             continue
2716         if disks[disk].get("zfs", False):
2717             time.sleep(3)
2718             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
2719             log.info("Destroying VM ZFS volume %s", fs_name)
2720             __salt__["zfs.destroy"](name=fs_name, force=True)
2721         elif os.path.exists(disks[disk]["file"]):
2722             os.remove(disks[disk]["file"])
2723             directories.add(os.path.dirname(disks[disk]["file"]))
2724         else:
2725             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
2726             if matcher:
2727                 pool_name = matcher.group("pool")
2728                 pool = None
2729                 if pool_name in conn.listStoragePools():
2730                     pool = conn.storagePoolLookupByName(pool_name)
2731                 if pool and matcher.group("volume") in pool.listVolumes():
2732                     volume = pool.storageVolLookupByName(matcher.group("volume"))
2733                     volume.delete()
2734     if dirs:
2735         for dir_ in directories:
2736             shutil.rmtree(dir_)
2737     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
2738         try:
2739             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
2740         except Exception:  # pylint: disable=broad-except
2741             dom.undefine()
2742     else:
2743         dom.undefine()
2744     conn.close()
2745     return True
2746 def virt_type():
2747     return __grains__["virtual"]
2748 def _is_kvm_hyper():
2749     if not os.path.exists("/dev/kvm"):
2750         return False
2751     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2752 def _is_xen_hyper():
2753     try:
2754         if __grains__["virtual_subtype"] != "Xen Dom0":
2755             return False
2756     except KeyError:
2757         return False
2758     try:
2759         with salt.utils.files.fopen("/proc/modules") as fp_:
2760             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
2761                 return False
2762     except OSError:
2763         return False
2764     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
2765 def get_hypervisor():
2766     hypervisors = ["kvm", "xen", "bhyve"]
2767     result = [
2768         hyper
2769         for hyper in hypervisors
2770         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
2771     ]
2772     return result[0] if result else None
2773 def _is_bhyve_hyper():
2774     sysctl_cmd = "sysctl hw.vmm.create"
2775     vmm_enabled = False
2776     try:
2777         stdout = subprocess.Popen(
2778             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
2779         ).communicate()[0]
2780         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
2781     except IndexError:
2782         pass
2783     return vmm_enabled
2784 def is_hyper():
2785     if HAS_LIBVIRT:
2786         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
2787     return False
2788 def vm_cputime(vm_=None, **kwargs):
2789     conn = __get_conn(**kwargs)
2790     host_cpus = conn.getInfo()[2]
2791     def _info(dom):
2792         raw = dom.info()
2793         vcpus = int(raw[3])
2794         cputime = int(raw[4])
2795         cputime_percent = 0
2796         if cputime:
2797             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
2798         return {
2799             "cputime": int(raw[4]),
2800             "cputime_percent": int("{:.0f}".format(cputime_percent)),
2801         }
2802     info = {}
2803     if vm_:
2804         info[vm_] = _info(_get_domain(conn, vm_))
2805     else:
2806         for domain in _get_domain(conn, iterable=True):
2807             info[domain.name()] = _info(domain)
2808     conn.close()
2809     return info
2810 def vm_netstats(vm_=None, **kwargs):
2811     def _info(dom):
2812         nics = _get_nics(dom)
2813         ret = {
2814             "rx_bytes": 0,
2815             "rx_packets": 0,
2816             "rx_errs": 0,
2817             "rx_drop": 0,
2818             "tx_bytes": 0,
2819             "tx_packets": 0,
2820             "tx_errs": 0,
2821             "tx_drop": 0,
2822         }
2823         for attrs in nics.values():
2824 <a name="0"></a>            if "target" in attrs:
2825                 dev = attrs["target"]
2826                 stats = dom.interfaceStats(dev)
2827                 ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["rx_bytes"] += stats[0]
2828                 ret["rx_packets"] += stats[1]
2829                 ret["rx_errs"] += stats[2]
2830                 ret["rx_drop"] += stats[3]
2831                 ret["tx_bytes"] += stats[4]
2832                 ret["tx_packets"] += stats[5]
2833                 ret["tx_errs"] += stats[6]
2834                 ret["tx_drop"] += stats[</b></font>7]
2835         return ret
2836     info = {}
2837     conn = __get_conn(**kwargs)
2838     if vm_:
2839         info[vm_] = _info(_get_domain(conn, vm_))
2840     else:
2841         for domain in _get_domain(conn, iterable=True):
2842             info[domain.name()] = _info(domain)
2843     conn.close()
2844     return info
2845 def vm_diskstats(vm_=None, **kwargs):
2846     def get_disk_devs(dom):
2847         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
2848         return [target.get("dev") for target in doc.findall("devices/disk/target")]
2849     def _info(dom):
2850         disks = get_disk_devs(dom)
2851 <a name="7"></a>        ret = {"rd_req": 0, "rd_bytes": 0, "wr_req": 0, "wr_bytes": 0, "errs": 0}
2852         for disk in disks:
2853             stats = dom.blockStats(disk)
2854             ret<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["rd_req"] += stats[0]
2855             ret["rd_bytes"] += stats[1]
2856             ret["wr_req"] += stats[2]
2857             ret["wr_bytes"] += stats[3]
2858             ret["errs"] += stats[</b></font>4]
2859         return ret
2860     info = {}
2861     conn = __get_conn(**kwargs)
2862     if vm_:
2863         info[vm_] = _info(_get_domain(conn, vm_))
2864     else:
2865         for domain in _get_domain(conn, iterable=True, inactive=False):
2866             info[domain.name()] = _info(domain)
2867     conn.close()
2868     return info
2869 def _parse_snapshot_description(vm_snapshot, unix_time=False):
2870     ret = dict()
2871     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
2872     for node in tree:
2873         if node.tag == "name":
2874             ret["name"] = node.text
2875         elif node.tag == "creationTime":
2876             ret["created"] = (
2877                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
2878                 if not unix_time
2879                 else float(node.text)
2880             )
2881         elif node.tag == "state":
2882             ret["running"] = node.text == "running"
2883     ret["current"] = vm_snapshot.isCurrent() == 1
2884     return ret
2885 def list_snapshots(domain=None, **kwargs):
2886     ret = dict()
2887     conn = __get_conn(**kwargs)
2888     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
2889         ret[vm_domain.name()] = [
2890             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
2891         ] or "N/A"
2892     conn.close()
2893     return ret
2894 def snapshot(domain, name=None, suffix=None, **kwargs):
2895     if name and name.lower() == domain.lower():
2896         raise CommandExecutionError(
2897             "Virtual Machine {name} is already defined. "
2898             "Please choose another name for the snapshot".format(name=name)
2899         )
2900     if not name:
2901         name = "{domain}-{tsnap}".format(
2902             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
2903         )
2904     if suffix:
2905         name = "{name}-{suffix}".format(name=name, suffix=suffix)
2906     doc = ElementTree.Element("domainsnapshot")
2907     n_name = ElementTree.SubElement(doc, "name")
2908     n_name.text = name
2909     conn = __get_conn(**kwargs)
2910     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
2911     conn.close()
2912     return {"name": name}
2913 def delete_snapshots(name, *names, **kwargs):
2914     deleted = dict()
2915     conn = __get_conn(**kwargs)
2916     domain = _get_domain(conn, name)
2917     for snap in domain.listAllSnapshots():
2918         if snap.getName() in names or not names:
2919             deleted[snap.getName()] = _parse_snapshot_description(snap)
2920             snap.delete()
2921     conn.close()
2922     available = {
2923         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
2924         or "N/A"
2925     }
2926     return {"available": available, "deleted": deleted}
2927 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
2928     ret = dict()
2929     conn = __get_conn(**kwargs)
2930     domain = _get_domain(conn, name)
2931     snapshots = domain.listAllSnapshots()
2932     _snapshots = list()
2933     for snap_obj in snapshots:
2934         _snapshots.append(
2935             {
2936                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
2937                 "ptr": snap_obj,
2938             }
2939         )
2940     snapshots = [
2941         w_ptr["ptr"]
2942         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
2943     ]
2944     del _snapshots
2945     if not snapshots:
2946         conn.close()
2947         raise CommandExecutionError("No snapshots found")
2948     elif len(snapshots) == 1:
2949         conn.close()
2950         raise CommandExecutionError(
2951             "Cannot revert to itself: only one snapshot is available."
2952         )
2953     snap = None
2954     for p_snap in snapshots:
2955         if not vm_snapshot:
2956             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
2957                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
2958                 break
2959         elif p_snap.getName() == vm_snapshot:
2960             snap = p_snap
2961             break
2962     if not snap:
2963         conn.close()
2964         raise CommandExecutionError(
2965             snapshot
2966             and 'Snapshot "{}" not found'.format(vm_snapshot)
2967             or "No more previous snapshots available"
2968         )
2969     elif snap.isCurrent():
2970         conn.close()
2971         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
2972     domain.revertToSnapshot(snap)
2973     ret["reverted"] = snap.getName()
2974     if cleanup:
2975         delete = list()
2976         for p_snap in snapshots:
2977             if p_snap.getName() != snap.getName():
2978                 delete.append(p_snap.getName())
2979                 p_snap.delete()
2980             else:
2981                 break
2982         ret["deleted"] = delete
2983     else:
2984         ret["deleted"] = "N/A"
2985     conn.close()
2986     return ret
2987 def _caps_add_machine(machines, node):
2988     maxcpus = node.get("maxCpus")
2989     canonical = node.get("canonical")
2990     name = node.text
2991     alternate_name = ""
2992     if canonical:
2993         alternate_name = name
2994         name = canonical
2995     machine = machines.get(name)
2996     if not machine:
2997         machine = {"alternate_names": []}
2998         if maxcpus:
2999             machine["maxcpus"] = int(maxcpus)
3000         machines[name] = machine
3001     if alternate_name:
3002         machine["alternate_names"].append(alternate_name)
3003 def _parse_caps_guest(guest):
3004     arch_node = guest.find("arch")
3005     result = {
3006         "os_type": guest.find("os_type").text,
3007         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
3008     }
3009     child = None
3010     for child in arch_node:
3011         if child.tag == "wordsize":
3012             result["arch"]["wordsize"] = int(child.text)
3013         elif child.tag == "emulator":
3014             result["arch"]["emulator"] = child.text
3015         elif child.tag == "machine":
3016             _caps_add_machine(result["arch"]["machines"], child)
3017         elif child.tag == "domain":
3018             domain_type = child.get("type")
3019             domain = {"emulator": None, "machines": {}}
3020             emulator_node = child.find("emulator")
3021             if emulator_node is not None:
3022                 domain["emulator"] = emulator_node.text
3023             for machine in child.findall("machine"):
3024                 _caps_add_machine(domain["machines"], machine)
3025             result["arch"]["domains"][domain_type] = domain
3026     features_nodes = guest.find("features")
3027     if features_nodes is not None and child is not None:
3028         result["features"] = {
3029             child.tag: {
3030                 "toggle": child.get("toggle", "no") == "yes",
3031                 "default": child.get("default", "on") == "on",
3032             }
3033             for child in features_nodes
3034         }
3035     return result
3036 def _parse_caps_cell(cell):
3037     result = {"id": int(cell.get("id"))}
3038     mem_node = cell.find("memory")
3039     if mem_node is not None:
3040         unit = mem_node.get("unit", "KiB")
3041         memory = mem_node.text
3042         result["memory"] = "{} {}".format(memory, unit)
3043     pages = [
3044         {
3045             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
3046             "available": int(page.text),
3047         }
3048         for page in cell.findall("pages")
3049     ]
3050     if pages:
3051         result["pages"] = pages
3052     distances = {
3053         int(distance.get("id")): int(distance.get("value"))
3054         for distance in cell.findall("distances/sibling")
3055     }
3056     if distances:
3057         result["distances"] = distances
3058     cpus = []
3059     for cpu_node in cell.findall("cpus/cpu"):
3060         cpu = {"id": int(cpu_node.get("id"))}
3061         socket_id = cpu_node.get("socket_id")
3062         if socket_id:
3063             cpu["socket_id"] = int(socket_id)
3064         core_id = cpu_node.get("core_id")
3065         if core_id:
3066             cpu["core_id"] = int(core_id)
3067         siblings = cpu_node.get("siblings")
3068         if siblings:
3069             cpu["siblings"] = siblings
3070         cpus.append(cpu)
3071     if cpus:
3072         result["cpus"] = cpus
3073     return result
3074 def _parse_caps_bank(bank):
3075     result = {
3076         "id": int<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(bank.get("id")),
3077         "level": int(bank.get("level")),
3078         "type": bank.get("type"),
3079         "size": "{} {}".format(bank.get(</b></font>"size"), bank.get("unit")),
3080         "cpus": bank.get("cpus"),
3081     }
3082     controls = []
3083     for control in bank.findall("control"):
3084         unit = control.get("unit")
3085         result_control = {
3086             "granularity": "{} {}".format(control.get("granularity"), unit),
3087             "type": control.get("type"),
3088             "maxAllocs": int(control.get("maxAllocs")),
3089         }
3090         minimum = control.get("min")
3091         if minimum:
3092             result_control["min"] = "{} {}".format(minimum, unit)
3093         controls.append(result_control)
3094     if controls:
3095         result["controls"] = controls
3096     return result
3097 def _parse_caps_host(host):
3098     result = {}
3099     for child in host:
3100         if child.tag == "uuid":
3101             result["uuid"] = child.text
3102         elif child.tag == "cpu":
3103             cpu = {
3104                 "arch": child.find("arch").text
3105                 if child.find("arch") is not None
3106                 else None,
3107                 "model": child.find("model").text
3108                 if child.find("model") is not None
3109                 else None,
3110                 "vendor": child.find("vendor").text
3111                 if child.find("vendor") is not None
3112                 else None,
3113                 "features": [
3114 <a name="13"></a>                    feature.get("name") for feature in child.findall("feature")
3115                 ],
3116                 "pages": [
3117                     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
3118                     for page in child.findall("pages")
3119                 ],
3120             }
3121             microcode = child.find(</b></font>"microcode")
3122             if microcode is not None:
3123                 cpu["microcode"] = microcode.get("version")
3124             topology = child.find("topology")
3125             if topology is not None:
3126                 cpu["sockets"] = int(topology.get("sockets"))
3127                 cpu["cores"] = int(topology.get("cores"))
3128                 cpu["threads"] = int(topology.get("threads"))
3129             result["cpu"] = cpu
3130         elif child.tag == "power_management":
3131             result["power_management"] = [node.tag for node in child]
3132         elif child.tag == "migration_features":
3133             result["migration"] = {
3134                 "live": child.find("live") is not None,
3135                 "transports": [
3136                     node.text for node in child.findall("uri_transports/uri_transport")
3137                 ],
3138             }
3139         elif child.tag == "topology":
3140             result["topology"] = {
3141                 "cells": [
3142                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
3143                 ]
3144             }
3145         elif child.tag == "cache":
3146             result["cache"] = {
3147                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
3148             }
3149     result["security"] = [
3150         {
3151             "model": secmodel.find("model").text
3152             if secmodel.find("model") is not None
3153             else None,
3154             "doi": secmodel.find("doi").text
3155             if secmodel.find("doi") is not None
3156             else None,
3157             "baselabels": [
3158                 {"type": label.get("type"), "label": label.text}
3159                 for label in secmodel.findall("baselabel")
3160             ],
3161         }
3162         for secmodel in host.findall("secmodel")
3163     ]
3164     return result
3165 def _capabilities(conn):
3166     caps = ElementTree.fromstring(conn.getCapabilities())
3167     return {
3168         "host": _parse_caps_host(caps.find("host")),
3169         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
3170     }
3171 def capabilities(**kwargs):
3172     conn = __get_conn(**kwargs)
3173     try:
3174         caps = _capabilities(conn)
3175     except libvirt.libvirtError as err:
3176         raise CommandExecutionError(str(err))
3177     finally:
3178         conn.close()
3179     return caps
3180 def _parse_caps_enum(node):
3181     return (node.get("name"), [value.text for value in node.findall("value")])
3182 def _parse_caps_cpu(node):
3183     result = {}
3184     for mode in node.findall("mode"):
3185         if not mode.get("supported") == "yes":
3186             continue
3187         name = mode.get("name")
3188         if name == "host-passthrough":
3189             result[name] = True
3190         elif name == "host-model":
3191             host_model = {}
3192             model_node = mode.find("model")
3193             if model_node is not None:
3194                 model = {"name": model_node.text}
3195                 vendor_id = model_node.get("vendor_id")
3196                 if vendor_id:
3197                     model["vendor_id"] = vendor_id
3198                 fallback = model_node.get("fallback")
3199                 if fallback:
3200                     model["fallback"] = fallback
3201                 host_model["model"] = model
3202             vendor = (
3203                 mode.find("vendor").text if mode.find("vendor") is not None else None
3204             )
3205             if vendor:
3206                 host_model["vendor"] = vendor
3207             features = {
3208                 feature.get("name"): feature.get("policy")
3209                 for feature in mode.findall("feature")
3210             }
3211             if features:
3212                 host_model["features"] = features
3213             result[name] = host_model
3214         elif name == "custom":
3215             custom_model = {}
3216             models = {
3217                 model.text: model.get("usable") for model in mode.findall("model")
3218             }
3219             if models:
3220                 custom_model["models"] = models
3221             result[name] = custom_model
3222     return result
3223 def _parse_caps_devices_features(node):
3224     result = {}
3225     for child in node:
3226         if child.get("supported") == "yes":
3227             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
3228             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
3229     return result
3230 def _parse_caps_loader(node):
3231     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
3232     result <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {item[0]: item[1] for item in enums if item[0]}
3233     values = [child.text for child in node.findall("value")]
3234     if values:
3235         result["values"] =</b></font> values
3236     return result
3237 def _parse_domain_caps(caps):
3238     result = {
3239         "emulator": caps.find("path")<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.text if caps.find("path") is not None else None,
3240         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
3241         "machine": caps.find("machine").text
3242         if caps.find("machine") is not None
3243         else None,
3244         "arch": caps.find("arch").text if caps.find(</b></font>"arch") is not None else None,
3245     }
3246     for child in caps:
3247         if child.tag == "vcpu" and child.get("max"):
3248             result["max_vcpus"] = int(child.get("max"))
3249         elif child.tag == "iothreads":
3250             result["iothreads"] = child.get("supported") == "yes"
3251         elif child.tag == "os":
3252             result["os"] = {}
3253             loader_node = child.find("loader")
3254             if loader_node is not None and loader_node.get("supported") == "yes":
3255                 loader = _parse_caps_loader(loader_node)
3256                 result["os"]["loader"] = loader
3257         elif child.tag == "cpu":
3258             cpu = _parse_caps_cpu(child)
3259             if cpu:
3260                 result["cpu"] = cpu
3261         elif child.tag == "devices":
3262             devices = _parse_caps_devices_features(child)
3263             if devices:
3264                 result["devices"] = devices
3265         elif child.tag == "features":
3266             features = _parse_caps_devices_features(child)
3267             if features:
3268                 result["features"] = features
3269     return result
3270 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
3271     conn = __get_conn(**kwargs)
3272     result = []
3273     try:
3274         caps = ElementTree.fromstring(
3275             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
3276         )
3277         result = _parse_domain_caps(caps)
3278     finally:
3279         conn.close()
3280     return result
3281 def all_capabilities(**kwargs):
3282         host_caps = ElementTree<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(conn.getCapabilities())
3283         domains = [
3284             [
3285                 (
3286                     guest.get("arch", {}).get(</b></font>"name", None),
3287                     key,
3288                     guest.get("arch", {}).get("emulator", None),
3289                 )
3290                 for key in guest.get("arch", {}).get("domains", {}).keys()
3291             ]
3292             for guest in [
3293                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3294             ]
3295         ]
3296 <a name="26"></a>        flattened = [pair for item in (x for x in domains) for pair in item]
3297         result = {
3298             "host": {
3299                 "host": _parse_caps_host<font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(host_caps.find("host")),
3300                 "guests": [
3301                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
3302                 ],
3303             },
3304             "domains": [
3305                 _parse_domain_caps(
3306                     ElementTree.fromstring(
3307                         conn.getDomainCapabilities(</b></font>emulator, arch, None, domain)
3308                     )
3309                 )
3310                 for (arch, domain, emulator) in flattened
3311             ],
3312         }
3313         return result
3314     finally:
3315         conn.close()
3316 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
3317     conn = __get_conn(**kwargs)
3318     caps = ElementTree.fromstring(conn.getCapabilities())
3319     cpu = caps.find("host/cpu")
3320     host_cpu_def = xmlutil.element_to_str(cpu)
3321     log.debug("Host CPU model definition: %s", host_cpu_def)
3322     flags = 0
3323     if migratable:
3324         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
3325             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
3326         else:
3327             conn.close()
3328             raise ValueError
3329     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3330         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
3331     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
3332     conn.close()
3333 <a name="17"></a>    if full and not getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
3334         <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
3335             cpu_map = ElementTree.parse(cpu_map)
3336         cpu_model = cpu.find("model").</b></font>text
3337         while cpu_model:
3338             cpu_map_models = cpu_map.findall("arch/model")
3339             cpu_specs = [
3340                 el
3341                 for el in cpu_map_models
3342                 if el.get("name") == cpu_model and bool(len(el))
3343             ]
3344             if not cpu_specs:
3345                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
3346             elif len(cpu_specs) &gt; 1:
3347                 raise ValueError(
3348                     "Multiple models {} found in CPU map".format(cpu_model)
3349                 )
3350             cpu_specs = cpu_specs[0]
3351             model_node = cpu_specs.find("model")
3352             if model_node is None:
3353                 cpu_model = None
3354             else:
3355                 cpu_model = model_node.get("name")
3356             cpu.extend([feature for feature in cpu_specs.findall("feature")])
3357     if out == "salt":
3358         return {
3359             "model": cpu.find("model").text,
3360             "vendor": cpu.find("vendor").text,
3361             "features": [feature.get("name") for feature in cpu.findall("feature")],
3362         }
3363     return ElementTree.tostring(cpu)
3364 def network_define(
3365     name,
3366     bridge,
3367     forward,
3368     ipv4_config=None,
3369     ipv6_config=None,
3370     vport=None,
3371     tag=None,
3372     autostart=True,
3373     start=True,
3374     mtu=None,
3375     domain=None,
3376     nat=None,
3377     interfaces=None,
3378     addresses=None,
3379     physical_function=None,
3380     dns=None,
3381     **kwargs
3382 ):
3383     conn = __get_conn(**kwargs)
3384     vport = kwargs.get("vport", None)
3385     tag = kwargs.get("tag", None)
3386     net_xml = _gen_net_xml(
3387         name,
3388         bridge,
3389         forward,
3390         vport,
3391         tag=tag,
3392         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3393         mtu=mtu,
3394         domain=domain,
3395         nat=nat,
3396         interfaces=interfaces,
3397         addresses=addresses,
3398         physical_function=physical_function,
3399         dns=dns,
3400     )
3401     try:
3402         conn.networkDefineXML(net_xml)
3403     except libvirt.libvirtError as err:
3404         log.warning(err)
3405         conn.close()
3406         raise err  # a real error we should report upwards
3407     try:
3408         network = conn.networkLookupByName(name)
3409     except libvirt.libvirtError as err:
3410         log.warning(err)
3411         conn.close()
3412         raise err  # a real error we should report upwards
3413     if network is None:
3414         conn.close()
3415         return False
3416     if (start or autostart) and network.isActive() != 1:
3417         network.create()
3418     if autostart and network.autostart() != 1:
3419         network.setAutostart(int(autostart))
3420     elif not autostart and network.autostart() == 1:
3421         network.setAutostart(int(autostart))
3422     conn.close()
3423     return True
3424 def _remove_empty_xml_node(node):
3425     for child in node:
3426         if not child.tail and not child.text and not child.items() and not child:
3427             node.remove(child)
3428         else:
3429             _remove_empty_xml_node(child)
3430     return node
3431 def network_update(
3432     name,
3433     bridge,
3434     forward,
3435     ipv4_config=None,
3436     ipv6_config=None,
3437     vport=None,
3438     tag=None,
3439     mtu=None,
3440     domain=None,
3441     nat=None,
3442     interfaces=None,
3443     addresses=None,
3444     physical_function=None,
3445     dns=None,
3446     test=False,
3447     **kwargs
3448 ):
3449     conn = __get_conn(**kwargs)
3450     needs_update = False
3451     try:
3452         net = conn.networkLookupByName(name)
3453         old_xml = ElementTree.fromstring(net.XMLDesc())
3454         new_xml = ElementTree.fromstring(
3455             _gen_net_xml(
3456                 name,
3457                 bridge,
3458                 forward,
3459                 vport,
3460                 tag=tag,
3461                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
3462                 mtu=mtu,
3463                 domain=domain,
3464                 nat=nat,
3465                 interfaces=interfaces,
3466                 addresses=addresses,
3467                 physical_function=physical_function,
3468                 dns=dns,
3469             )
3470         )
3471         elements_to_copy = ["uuid", "mac"]
3472         for to_copy in elements_to_copy:
3473             element = old_xml.find(to_copy)
3474             if element is not None:
3475                 new_xml.insert(1, element)
3476         old_xml.attrib.pop("connections", None)
3477         if old_xml.find("forward/pf") is not None:
3478             forward_node = old_xml.find("forward")
3479             address_nodes = forward_node.findall("address")
3480             for node in address_nodes:
3481                 forward_node.remove(node)
3482         default_bridge_attribs = {"stp": "on", "delay": "0"}
3483         old_bridge_node = old_xml.find("bridge")
3484         if old_bridge_node is not None:
3485             for key, value in default_bridge_attribs.items():
3486                 if old_bridge_node.get(key, None) == value:
3487                     old_bridge_node.attrib.pop(key, None)
3488             old_forward = (
3489                 old_xml.find("forward").get("mode")
3490                 if old_xml.find("forward") is not None
3491                 else None
3492             )
3493             if (
3494                 old_forward == forward
3495                 and forward in ["nat", "route", "open", None]
3496                 and bridge is None
3497                 and old_bridge_node.get("name", "").startswith("virbr")
3498             ):
3499                 old_bridge_node.attrib.pop("name", None)
3500         ipv4_nodes = [
3501             node
3502             for node in old_xml.findall("ip")
3503             if node.get("family", "ipv4") == "ipv4"
3504         ]
3505         for ip_node in ipv4_nodes:
3506             netmask = ip_node.attrib.pop("netmask", None)
3507             if netmask:
3508                 address = ipaddress.ip_network(
3509                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
3510                 )
3511                 ip_node.set("prefix", str(address.prefixlen))
3512         for doc in [old_xml, new_xml]:
3513             for node in doc.findall("ip"):
3514                 if "family" not in node.keys():
3515                     node.set("family", "ipv4")
3516         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3517         xmlutil.strip_spaces(new_xml)
3518         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3519         if needs_update and not test:
3520             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
3521     finally:
3522         conn.close()
3523     return needs_update
3524 def list_networks(**kwargs):
3525     conn = __get_conn(**kwargs)
3526     try:
3527         return [net.name() for net in conn.listAllNetworks()]
3528     finally:
3529         conn.close()
3530 def network_info(name=None, **kwargs):
3531     result = {}
3532     conn = __get_conn(**kwargs)
3533     def _net_get_leases(net):
3534         leases = net.DHCPLeases()
3535         for lease in leases:
3536             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
3537                 lease["type"] = "ipv4"
3538             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
3539                 lease["type"] = "ipv6"
3540             else:
3541                 lease["type"] = "unknown"
3542         return leases
3543     def _net_get_bridge(net):
3544         try:
3545             return net.bridgeName()
3546         except libvirt.libvirtError as err:
3547             return None
3548     try:
3549         nets = [
3550             net for net in conn.listAllNetworks() if name is None or net.name() == name
3551         ]
3552         result = {
3553             net.name(): {
3554                 "uuid": net.UUIDString(),
3555                 "bridge": _net_get_bridge(net),
3556                 "autostart": net.autostart(),
3557                 "active": net.isActive(),
3558                 "persistent": net.isPersistent(),
3559                 "leases": _net_get_leases(net),
3560             }
3561             for net in nets
3562         }
3563     except libvirt.libvirtError as err:
3564         log.debug("Silenced libvirt error: %s", err)
3565     finally:
3566         conn.close()
3567     return result
3568 def network_get_xml(name, **kwargs):
3569     conn = __get_conn(**kwargs)
3570     try:
3571         return conn.networkLookupByName(name).XMLDesc()
3572     finally:
3573         conn.close()
3574 def network_start(name, **kwargs):
3575     conn = __get_conn(**kwargs)
3576     try:
3577         net = conn.networkLookupByName(name)
3578         return not bool(net.create())
3579     finally:
3580         conn.close()
3581 def network_stop(name, **kwargs):
3582     conn = __get_conn(**kwargs)
3583     try:
3584         net = conn.networkLookupByName(name)
3585         return not bool(net.destroy())
3586     finally:
3587         conn.close()
3588 def network_undefine(name, **kwargs):
3589     conn = __get_conn(**kwargs)
3590     try:
3591         net = conn.networkLookupByName(name)
3592         return not bool(net.undefine())
3593     finally:
3594         conn.close()
3595 def network_set_autostart(name, state="on", **kwargs):
3596     conn = __get_conn(**kwargs)
3597     try:
3598         net = conn.networkLookupByName(name)
3599         return not bool(net.setAutostart(1 if state == "on" else 0))
3600     finally:
3601         conn.close()
3602 def _parse_pools_caps(doc):
3603     def _parse_pool_caps(pool):
3604         pool_caps = {
3605             "name": pool.get("type"),
3606             "supported": pool.get("supported", "no") == "yes",
3607         }
3608         for option_kind in ["pool", "vol"]:
3609             options = {}
3610             default_format_node = pool.find(
3611                 "{}Options/defaultFormat".format(option_kind)
3612             )
3613             if default_format_node is not None:
3614                 options["default_format"] = default_format_node.get("type")
3615             options_enums = {
3616                 enum.get("name"): [value.text for value in enum.findall("value")]
3617                 for enum in pool.findall("{}Options/enum".format(option_kind))
3618             }
3619             if options_enums:
3620                 options.update(options_enums)
3621             if options:
3622                 if "options" not in pool_caps:
3623                     pool_caps["options"] = {}
3624                 kind = option_kind if option_kind != "vol" else "volume"
3625                 pool_caps["options"][kind] = options
3626         return pool_caps
3627     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
3628 def _pool_capabilities(conn):
3629     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
3630     if has_pool_capabilities:
3631         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
3632         pool_types = _parse_pools_caps(caps)
3633     else:
3634         all_hypervisors = ["xen", "kvm", "bhyve"]
3635         images_formats = [
3636             "none",
3637             "raw",
3638             "dir",
3639             "bochs",
3640             "cloop",
3641             "dmg",
3642             "iso",
3643             "vpc",
3644             "vdi",
3645             "fat",
3646             "vhd",
3647             "ploop",
3648             "cow",
3649             "qcow",
3650             "qcow2",
3651             "qed",
3652             "vmdk",
3653         ]
3654         common_drivers = [
3655             {
3656 <a name="2"></a>                "name": "fs",
3657                 "default_source_format": "auto",
3658                 "source_formats": [
3659                     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"auto",
3660                     "ext2",
3661                     "ext3",
3662                     "ext4",
3663                     "ufs",
3664                     "iso9660",
3665                     "udf",
3666                     "gfs",
3667                     "gfs2",
3668                     "vfat",
3669                     "hfs+",
3670                     "xfs",
3671                     "ocfs2",
3672                 ],
3673                 "default_target_format": "raw",
3674                 "target_formats": images_formats,
3675             },
3676             {
3677                 "name": "dir",
3678                 "default_target_format": "raw",
3679                 "target_formats": images_formats,
3680             },
3681             {"name": "iscsi"},
3682             {"name": "scsi"},
3683             {
3684                 "name": "logical",
3685                 "default_source_format": "lvm2",
3686                 "source_formats": ["unknown", "lvm2"],
3687             },
3688             {
3689                 "name": "netfs",
3690                 "default_source_format": "auto",
3691                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
3692                 "default_target_format": "raw",
3693                 "target_formats": images_formats,
3694             },
3695             {
3696                 "name": "disk",
3697                 "default_source_format": "unknown",
3698                 "source_formats": [
3699                     "unknown",
3700                     "dos",
3701                     "dvh",
3702                     "gpt",
3703                     "mac",
3704                     "bsd",
3705                     "pc98",
3706                     "sun",
3707                     "lvm2",
3708                 ],
3709                 "default_target_format": "none",
3710                 "target_formats": [
3711                     "none",
3712                     "linux",
3713                     "fat16",
3714                     "fat32",
3715                     "linux-swap",
3716                     "linux-lvm",
3717                     "linux-raid",
3718                     "extended",
3719                 ],
3720             },
3721             {"name": "mpath"},
3722             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
3723             {
3724                 "name": "sheepdog",
3725                 "version": 10000,
3726                 "hypervisors": ["kvm"],
3727                 "default_target_format": "raw",
3728                 "target_formats": images_formats,
3729             },
3730             {
3731                 "name": "gluster",
3732                 "version": 1002000,
3733                 "hypervisors": ["kvm"],
3734                 "default_target_format": "raw",
3735                 "target_formats": images_formats,
3736             },
3737             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
3738             {
3739                 "name": "iscsi-direct",
3740                 "version": 4007000,
3741                 "hypervisors": ["kvm", "xen"],
3742             },
3743         ]
3744         libvirt_version = conn.getLibVersion(</b></font>)
3745         hypervisor = get_hypervisor()
3746         def _get_backend_output(backend):
3747             output = {
3748                 "name": backend["name"],
3749                 "supported": (
3750                     not backend.get("version") or libvirt_version &gt;= backend["version"]
3751                 )
3752                 and hypervisor in backend.get("hypervisors", all_hypervisors),
3753                 "options": {
3754                     "pool": {
3755                         "default_format": backend.get("default_source_format"),
3756                         "sourceFormatType": backend.get("source_formats"),
3757                     },
3758                     "volume": {
3759                         "default_format": backend.get("default_target_format"),
3760                         "targetFormatType": backend.get("target_formats"),
3761                     },
3762                 },
3763             }
3764             for option_kind in ["pool", "volume"]:
3765                 if not [
3766                     value
3767                     for value in output["options"][option_kind].values()
3768                     if value is not None
3769                 ]:
3770                     del output["options"][option_kind]
3771             if not output["options"]:
3772                 del output["options"]
3773             return output
3774         pool_types = [_get_backend_output(backend) for backend in common_drivers]
3775     return {
3776         "computed": not has_pool_capabilities,
3777         "pool_types": pool_types,
3778     }
3779 def pool_capabilities(**kwargs):
3780     try:
3781         conn = __get_conn(**kwargs)
3782         return _pool_capabilities(conn)
3783     finally:
3784         conn.close()
3785 def pool_define(
3786     name,
3787     ptype,
3788     target=None,
3789     permissions=None,
3790     source_devices=None,
3791     source_dir=None,
3792     source_initiator=None,
3793     source_adapter=None,
3794     source_hosts=None,
3795     source_auth=None,
3796     source_name=None,
3797     source_format=None,
3798     transient=False,
3799     start=True,  # pylint: disable=redefined-outer-name
3800     **kwargs
3801 ):
3802     conn = __get_conn(**kwargs)
3803     auth = _pool_set_secret(conn, ptype, name, source_auth)
3804     pool_xml = _gen_pool_xml(
3805         name,
3806         ptype,
3807         target,
3808         permissions=permissions,
3809         source_devices=source_devices,
3810         source_dir=source_dir,
3811         source_adapter=source_adapter,
3812         source_hosts=source_hosts,
3813         source_auth=auth,
3814         source_name=source_name,
3815         source_format=source_format,
3816         source_initiator=source_initiator,
3817     )
3818     try:
3819         if transient:
3820             pool = conn.storagePoolCreateXML(pool_xml)
3821         else:
3822             pool = conn.storagePoolDefineXML(pool_xml)
3823             if start:
3824                 pool.create()
3825     except libvirt.libvirtError as err:
3826         raise err  # a real error we should report upwards
3827     finally:
3828         conn.close()
3829     return True
3830 def _pool_set_secret(
3831     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
3832 ):
3833     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
3834     secret_type = secret_types.get(pool_type)
3835     auth = source_auth
3836     if source_auth and "username" in source_auth and "password" in source_auth:
3837         if secret_type:
3838             secret = None
3839             try:
3840                 if usage:
3841                     usage_type = (
3842                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
3843                         if secret_type == "ceph"
3844                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
3845                     )
3846                     secret = conn.secretLookupByUsage(usage_type, usage)
3847                 elif uuid:
3848                     secret = conn.secretLookupByUUIDString(uuid)
3849             except libvirt.libvirtError as err:
3850                 log.info("Secret not found: %s", err.get_error_message())
3851             if not secret:
3852                 description = "Passphrase for {} pool created by Salt".format(pool_name)
3853                 if not usage:
3854                     usage = "pool_{}".format(pool_name)
3855                 secret_xml = _gen_secret_xml(secret_type, usage, description)
3856                 if not test:
3857                     secret = conn.secretDefineXML(secret_xml)
3858             password = auth["password"]
3859             if pool_type == "rbd":
3860                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
3861             if not test:
3862                 secret.setValue(password)
3863             auth["type"] = secret_type
3864             auth["secret"] = {
3865                 "type": "uuid" if uuid else "usage",
3866                 "value": uuid if uuid else usage,
3867             }
3868     return auth
3869 def pool_update(
3870     name,
3871     ptype,
3872     target=None,
3873     permissions=None,
3874     source_devices=None,
3875     source_dir=None,
3876     source_initiator=None,
3877     source_adapter=None,
3878     source_hosts=None,
3879     source_auth=None,
3880     source_name=None,
3881     source_format=None,
3882     test=False,
3883     **kwargs
3884 ):
3885     conn = __get_conn(**kwargs)
3886 <a name="31"></a>    needs_update = False
3887     try:
3888         pool = conn.storagePoolLookupByName(name)
3889         old_xml = ElementTree.fromstring(pool<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.XMLDesc())
3890         secret_node = old_xml.find("source/auth/secret")
3891         usage = secret_node.get("usage") if secret_node is not None else None
3892         uuid = secret_node.get("uuid") if secret_node is not None else None
3893         auth =</b></font> _pool_set_secret(
3894             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
3895         )
3896         new_xml = ElementTree.fromstring(
3897             _gen_pool_xml(
3898                 name,
3899                 ptype,
3900                 target,
3901                 permissions=permissions,
3902                 source_devices=source_devices,
3903                 source_dir=source_dir,
3904                 source_initiator=source_initiator,
3905                 source_adapter=source_adapter,
3906                 source_hosts=source_hosts,
3907                 source_auth=auth,
3908                 source_name=source_name,
3909                 source_format=source_format,
3910             )
3911         )
3912         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
3913         for to_copy in elements_to_copy:
3914             element = old_xml.find(to_copy)
3915             new_xml.insert(1, element)
3916         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
3917         xmlutil.strip_spaces(new_xml)
3918         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
3919         if needs_update and not test:
3920             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
3921     finally:
3922         conn.close()
3923     return needs_update
3924 def list_pools(**kwargs):
3925     conn = __get_conn(**kwargs)
3926     try:
3927         return [pool.name() for pool in conn.listAllStoragePools()]
3928     finally:
3929         conn.close()
3930 def pool_info(name=None, **kwargs):
3931     result = {}
3932     conn = __get_conn(**kwargs)
3933     def _pool_extract_infos(pool):
3934         states <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ["inactive", "building", "running", "degraded", "inaccessible"]
3935         infos = pool.info()
3936         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
3937         desc = ElementTree.fromstring(pool.</b></font>XMLDesc())
3938         path_node = desc.find("target/path")
3939         return {
3940             "uuid": pool.UUIDString(),
3941             "state": state,
3942             "capacity": infos[1],
3943             "allocation": infos[2],
3944             "free": infos[3],
3945             "autostart": pool.autostart(),
3946             "persistent": pool.isPersistent(),
3947             "target_path": path_node.text if path_node is not None else None,
3948             "type": desc.get("type"),
3949         }
3950     try:
3951         pools = [
3952             pool
3953             for pool in conn.listAllStoragePools()
3954             if name is None or pool.name() == name
3955         ]
3956         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
3957     except libvirt.libvirtError as err:
3958         log.debug("Silenced libvirt error: %s", err)
3959     finally:
3960         conn.close()
3961     return result
3962 def pool_get_xml(name, **kwargs):
3963     conn = __get_conn(**kwargs)
3964     try:
3965         return conn.storagePoolLookupByName(name).XMLDesc()
3966     finally:
3967         conn.close()
3968 def pool_start(name, **kwargs):
3969     conn = __get_conn(**kwargs)
3970     try:
3971         pool = conn.storagePoolLookupByName(name)
3972         return not bool(pool.create())
3973     finally:
3974         conn.close()
3975 def pool_build(name, **kwargs):
3976     conn = __get_conn(**kwargs)
3977     try:
3978         pool = conn.storagePoolLookupByName(name)
3979         return not bool(pool.build())
3980     finally:
3981         conn.close()
3982 def pool_stop(name, **kwargs):
3983     conn = __get_conn(**kwargs)
3984     try:
3985         pool = conn.storagePoolLookupByName(name)
3986         return not bool(pool.destroy())
3987     finally:
3988         conn.close()
3989 def pool_undefine(name, **kwargs):
3990     conn = __get_conn(**kwargs)
3991     try:
3992         pool = conn.storagePoolLookupByName(name)
3993         desc = ElementTree.fromstring(pool.XMLDesc())
3994         auth_node = desc.find("source/auth")
3995         if auth_node is not None:
3996             auth_types = {
3997                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
3998                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
3999             }
4000             secret_type = auth_types[auth_node.get("type")]
4001             secret_usage = auth_node.find("secret").get("usage")
4002             if secret_type and "pool_{}".format(name) == secret_usage:
4003                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
4004                 secret.undefine()
4005         return not bool(pool.undefine())
4006     finally:
4007         conn.close()
4008 def pool_delete(name, **kwargs):
4009     conn = __get_conn(**kwargs)
4010     try:
4011         pool = conn.storagePoolLookupByName(name)
4012         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
4013     finally:
4014         conn.close()
4015 def pool_refresh(name, **kwargs):
4016     conn = __get_conn(**kwargs)
4017     try:
4018         pool = conn.storagePoolLookupByName(name)
4019         return not bool(pool.refresh())
4020     finally:
4021         conn.close()
4022 def pool_set_autostart(name, state="on", **kwargs):
4023     conn = __get_conn(**kwargs)
4024     try:
4025         pool = conn.storagePoolLookupByName(name)
4026         return not bool(pool.setAutostart(1 if state == "on" else 0))
4027     finally:
4028         conn.close()
4029 def pool_list_volumes(name, **kwargs):
4030     conn = __get_conn(**kwargs)
4031     try:
4032         pool = conn.storagePoolLookupByName(name)
4033         return pool.listVolumes()
4034     finally:
4035         conn.close()
4036 def _get_storage_vol(conn, pool, vol):
4037     pool_obj = conn.storagePoolLookupByName(pool)
4038     return pool_obj.storageVolLookupByName(vol)
4039 def _is_valid_volume(vol):
4040     try:
4041         def discarder(ctxt, error):  # pylint: disable=unused-argument
4042             log.debug("Ignore libvirt error: %s", error[2])
4043         libvirt.registerErrorHandler(discarder, None)
4044         vol.info()
4045         libvirt.registerErrorHandler(None, None)
4046         return True
4047     except libvirt.libvirtError as err:
4048         return False
4049 def _get_all_volumes_paths(conn):
4050     pools = [
4051         pool
4052         for pool in conn.listAllStoragePools()
4053         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4054     ]
4055     volumes = {}
4056 <a name="11"></a>    for pool in pools:
4057         pool_volumes = {
4058             volume.path(): {
4059                 "pool": pool<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.name(),
4060                 "name": volume.name(),
4061                 "backing_stores": [
4062                     path.text
4063                     for path in ElementTree.fromstring(volume.XMLDesc()).findall(
4064                         ".//backingStore/path"
4065                     )
4066                 ],
4067             }
4068             for volume in pool.listAllVolumes()
4069             if _is_valid_volume(</b></font>volume)
4070         }
4071         volumes.update(pool_volumes)
4072     return volumes
4073 def volume_infos(pool=None, volume=None, **kwargs):
4074     result = {}
4075     conn = __get_conn(**kwargs)
4076     try:
4077         backing_stores = _get_all_volumes_paths(conn)
4078         try:
4079             domains = _get_domain(conn)
4080             domains_list = domains if isinstance(domains, list) else [domains]
4081         except CommandExecutionError:
4082             domains_list = []
4083         disks = {
4084             domain.name(): {
4085                 node.get("file")
4086                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
4087                     ".//disk/source/[@file]"
4088                 )
4089             }
4090             for domain in domains_list
4091         }
4092         def _volume_extract_infos(vol):
4093             types = ["file", "block", "dir", "network", "netdir", "ploop"]
4094             infos = vol.info()
4095             vol_xml = ElementTree.fromstring(vol.XMLDesc())
4096             backing_store_path = vol_xml.find("./backingStore/path")
4097             backing_store_format = vol_xml.find("./backingStore/format")
4098             backing_store = None
4099             if backing_store_path is not None:
4100                 backing_store = {
4101                     "path": backing_store_path.text,
4102                     "format": backing_store_format.get("type")
4103                     if backing_store_format is not None
4104                     else None,
4105                 }
4106             format_node = vol_xml.find("./target/format")
4107             used_by = []
4108             if vol.path():
4109                 as_backing_store = {
4110                     path
4111                     for (path, volume) in backing_stores.items()
4112                     if vol.path() in volume.get("backing_stores")
4113                 }
4114                 used_by = [
4115                     vm_name
4116                     for (vm_name, vm_disks) in disks.items()
4117                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
4118                 ]
4119             return {
4120                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
4121                 "key": vol.key(),
4122                 "path": vol.path(),
4123                 "capacity": infos[1],
4124                 "allocation": infos[2],
4125                 "used_by": used_by,
4126                 "backing_store": backing_store,
4127 <a name="9"></a>                "format": format_node.get("type") if format_node is not None else None,
4128             }
4129         pools <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
4130             obj
4131             for obj in conn.listAllStoragePools()
4132             if (pool is None or obj.name() == pool)
4133             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
4134         ]
4135         vols = {
4136             pool_obj.name(): {
4137                 vol</b></font>.name(): _volume_extract_infos(vol)
4138                 for vol in pool_obj.listAllVolumes()
4139                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
4140             }
4141             for pool_obj in pools
4142         }
4143         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
4144     except libvirt.libvirtError as err:
4145         log.debug("Silenced libvirt error: %s", err)
4146     finally:
4147         conn.close()
4148     return result
4149 def volume_delete(pool, volume, **kwargs):
4150     conn = __get_conn(**kwargs)
4151     try:
4152         vol = _get_storage_vol(conn, pool, volume)
4153         return not bool(vol.delete())
4154     finally:
4155         conn.close()
4156 def volume_define(
4157     pool,
4158     name,
4159     size,
4160     allocation=0,
4161     format=None,
4162     type=None,
4163     permissions=None,
4164     backing_store=None,
4165     nocow=False,
4166     **kwargs
4167 ):
4168     ret = False
4169     try:
4170         conn = __get_conn(**kwargs)
4171         pool_obj = conn.storagePoolLookupByName(pool)
4172         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
4173         new_allocation = allocation
4174         if pool_type == "logical" and size != allocation:
4175             new_allocation = size
4176         xml = _gen_vol_xml(
4177             name,
4178             size,
4179             format=format,
4180             allocation=new_allocation,
4181             type=type,
4182             permissions=permissions,
4183             backing_store=backing_store,
4184             nocow=nocow,
4185         )
4186         ret = _define_vol_xml_str(conn, xml, pool=pool)
4187     except libvirt.libvirtError as err:
4188         raise CommandExecutionError(err.get_error_message())
4189     finally:
4190         conn.close()
4191     return ret
4192 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
4193     def handler(stream, nbytes, opaque):
4194         return os.read(opaque, nbytes)
4195     def holeHandler(stream, opaque):
4196         fd = opaque
4197         cur = os.lseek(fd, 0, os.SEEK_CUR)
4198         try:
4199             data = os.lseek(fd, cur, os.SEEK_DATA)
4200         except OSError as e:
4201             if e.errno != 6:
4202                 raise e
4203             else:
4204                 data = -1
4205         if data &lt; 0:
4206             inData = False
4207             eof = os.lseek(fd, 0, os.SEEK_END)
4208             if eof &lt; cur:
4209                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
4210             sectionLen = eof - cur
4211         else:
4212             if data &gt; cur:
4213                 inData = False
4214                 sectionLen = data - cur
4215             else:
4216                 inData = True
4217                 hole = os.lseek(fd, data, os.SEEK_HOLE)
4218                 if hole &lt; 0:
4219                     raise RuntimeError("No trailing hole")
4220                 if hole == data:
4221                     raise RuntimeError("Impossible happened")
4222                 else:
4223                     sectionLen = hole - data
4224         os.lseek(fd, cur, os.SEEK_SET)
4225         return [inData, sectionLen]
4226     def skipHandler(stream, length, opaque):
4227         return os.lseek(opaque, length, os.SEEK_CUR)
4228     stream = None
4229 <a name="32"></a>    fd = None
4230     ret = False
4231     try:
4232         pool_obj <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= conn.storagePoolLookupByName(pool)
4233         vol_obj = pool_obj.storageVolLookupByName(volume)
4234         stream = conn.newStream()
4235         fd = os.open(</b></font>file, os.O_RDONLY)
4236         vol_obj.upload(
4237             stream,
4238             offset,
4239             length,
4240             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
4241         )
4242         if sparse:
4243             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
4244         else:
4245             stream.sendAll(handler, fd)
4246         ret = True
4247     except libvirt.libvirtError as err:
4248         raise CommandExecutionError(err.get_error_message())
4249     finally:
4250         if fd:
4251             try:
4252                 os.close(fd)
4253             except OSError as err:
4254                 if stream:
4255                     stream.abort()
4256                 if ret:
4257                     raise CommandExecutionError(
4258                         "Failed to close file: {}".format(err.strerror)
4259                     )
4260         if stream:
4261             try:
4262 <a name="12"></a>                stream.finish()
4263             except libvirt.libvirtError as err:
4264                 if ret:
4265                     raise CommandExecutionError<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
4266                         "Failed to finish stream: {}".format(err.get_error_message())
4267                     )
4268     return ret
4269 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
4270     conn =</b></font> __get_conn(**kwargs)
4271     ret = False
4272     try:
4273         ret = _volume_upload(
4274             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
4275         )
4276     finally:
4277         conn.close()
4278     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
