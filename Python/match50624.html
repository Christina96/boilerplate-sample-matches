<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_lgpo_1.py &amp; virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_lgpo_1.py &amp; virt_1.py
      </h3>
<h1 align="center">
        5.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_lgpo_1.py (5.3507195%)<th>virt_1.py (6.136393%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(436-486)<td><a href="#" name="0">(5947-5954)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(68-93)<td><a href="#" name="1">(2000-2792)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(10482-10489)<td><a href="#" name="2">(7727-7813)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(104-110)<td><a href="#" name="3">(2948-2957)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(39-59)<td><a href="#" name="4">(122-142)</a><td align="center"><font color="#d40000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(5109-5112)<td><a href="#" name="5">(6661-6666)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(111-116)<td><a href="#" name="6">(2883-2888)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(341-375)<td><a href="#" name="7">(6025-6029)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(9144-9154)<td><a href="#" name="8">(1453-1463)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(7613-7618)<td><a href="#" name="9">(8762-8770)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(7521-7544)<td><a href="#" name="10">(8336-8339)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(6641-6648)<td><a href="#" name="11">(8658-8668)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(6600-6614)<td><a href="#" name="12">(8982-9010)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(7544-7552)<td><a href="#" name="13">(6469-6474)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(7339-7345)<td><a href="#" name="14">(6646-6651)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(7042-7048)<td><a href="#" name="15">(4486-4492)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(6039-6043)<td><a href="#" name="16">(637-643)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(4997-5000)<td><a href="#" name="17">(6846-6849)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(805-834)<td><a href="#" name="18">(3987-4003)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(10151-10167)<td><a href="#" name="19">(1946-1951)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(8464-8469)<td><a href="#" name="20">(167-173)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(7718-7723)<td><a href="#" name="21">(4807-4833)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(7648-7650)<td><a href="#" name="22">(6759-6763)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(7645-7647)<td><a href="#" name="23">(4499-4501)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(7634-7641)<td><a href="#" name="24">(5563-5565)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(7320-7324)<td><a href="#" name="25">(1465-1472)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(6513-6519)<td><a href="#" name="26">(6776-6784)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(6427-6433)<td><a href="#" name="27">(6418-6421)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(6245-6249)<td><a href="#" name="28">(3202-3204)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(5888-5891)<td><a href="#" name="29">(3420-3425)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(5079-5083)<td><a href="#" name="30">(1147-1149)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(134-153)<td><a href="#" name="31">(8238-8245)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(120-129)<td><a href="#" name="32">(8948-8952)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from</b></font> salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ = "lgpo"
23 __func_alias__ = {"set_": "set"}
24 UUID = uuid.uuid4().hex
25 adm_policy_name_map = {True: {}, False: {}}
26 HAS_WINDOWS_MODULES <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= False
27 TRUE_VALUE_XPATH = None
28 FALSE_VALUE_XPATH = None
29 ELEMENTS_XPATH = None
30 ENABLED_VALUE_XPATH = None
31 DISABLED_VALUE_XPATH = None
32 ENABLED_LIST_XPATH = None
33 DISABLED_LIST_XPATH = None
34 VALUE_XPATH = None
35 TRUE_LIST_XPATH = None
36 FALSE_LIST_XPATH = None
37 REGKEY_XPATH = None
38 POLICY_ANCESTOR_XPATH = None
39 ALL_CLASS_POLICY_XPATH = None
40 ADML_DISPLAY_NAME_XPATH = None
41 VALUE_LIST_XPATH = None
42 ENUM_ITEM_DISPLAY_NAME_XPATH = None
43 ADMX_SEARCH_XPATH = None
44 ADML_SEARCH_XPATH = None
45 ADMX_DISPLAYNAME_SEARCH_XPATH = None
46 PRESENTATION_ANCESTOR_XPATH = None
47 TEXT_ELEMENT_XPATH = None
48 try</b></font>:
49     import struct
50     import lxml
51     import win32net
52     import win32security
53     from lxml import etree
54     HAS_WINDOWS_MODULES = True
55     TRUE_VALUE_XPATH <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath('.//*[local-name() = "trueValue"]')
56     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
57     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
58     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
59     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
60     DISABLED_LIST_XPATH = etree.XPath(</b></font>'.//*[local-name() = "disabledList"]')
61     VALUE_XPATH <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath('.//*[local-name() = "value"]')
62     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
63     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
64     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
65     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
66     ALL_CLASS_POLICY_XPATH = etree.XPath(</b></font>
67         ' @*[local-name() = "class"] = $registry_class)]'
68     )
69     ADML_DISPLAY_NAME_XPATH <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= etree.XPath(
70         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
71         " $displayNameId]"
72     )
73     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
74     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
75         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
76         " $display_name]]"
77     )
78     ADMX_SEARCH_XPATH = etree.XPath(</b></font>
79         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
80         " $registry_class)]"
81     )
82     ADML_SEARCH_XPATH = etree<font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.XPath(
83         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
84     )
85     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
86         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
87         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
88         ' "class"] = $registry_class) ]'
89     )
90     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
91         'ancestor::*[local-name() = "presentation"]'
92     )
93     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
94     windll =</b></font> ctypes.windll.kernel32
95     INSTALL_LANGUAGE = locale.windows_locale.get(
96         windll.GetSystemDefaultUILanguage(), "en_US"
97     ).replace("_", "-")
98 except ImportError:
99     HAS_WINDOWS_MODULES = False
100 class _policy_info:
101     r"""
102     Policy Helper Class
103     ===================
104     The format of the policy dict is as follows:
105     The top most two key/value pairs in the dict divide the policies object into
106     the two sections of local group policy, using the keys "Machine" and "User".
107     The value make-up of these dicts are described below in "Policy Section
108     Definition"
109     Policy Section Definition
110     -------------------------
111     A policy section dict has two required key/value pairs:
112     ============  ==============================================================
113     Key
114     ============  ==============================================================
115     lgpo_section  String matching how the policy section is displayed in the mmc
116                   snap-in ("Computer Configuration" for "Machine" and "User
117                   Configuration" for "User")
118     policies      a dict containing the non-Administrative template policy
119                   definitions, the key for each item is a short/unique
120                   identifier for the policy, the value is described below in
121                   "Policies Definition"
122     ============  ==============================================================
123     Policies Definition
124     -------------------
125     A policies definition item describes the particular policy. There are three
126     child key/value pairs shared with all policy types:
127     ============  ==============================================================
128     Key           Value
129     ============  ==============================================================
130     lgpo_section  A list containing the hierarchical path to the policy in the
131                   gpedit mmc snap-in.
132     Policy        A string containing the name of the policy in the gpedit mmc
133                   snap-in
134     Settings      An object which describes valid settings for the policy. This
135                   can be None for no validation, a list of possible settings, or
136                   a dict with the following key/value pairs:
137                   - **Function:** The class function to use to validate the
138                     setting
139                   - **Args:** A dict of kwargs to pass to the class function
140     ============  ==============================================================
141     Additionally, each policies definition will contain a key/value pair that
142     defines the mechanism that will be used to configure the policy. The
143     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
144     Registry Mechanism
145     ------------------
146     Some policies simply set values in the Windows registry. The value of this
147     key is a dict with the following make-up:
148     =====  =====================================================================
149     Key    Value
150     =====  =====================================================================
151     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
152     Path   A string containing the registry key path, such as
153            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
154     Value  A string containing the name of the registry value, such as
155            **restrictanonymous**
156     Type   A string containing the registry type of the value, such as
157            ``REG_DWORD``
158     =====  =====================================================================
159     Secedit Mechanism
160     -----------------
161     Some policies are configurable via the "secedit.exe" executable. The value
162     of this key is a dict with the following make-up:
163     =======  ===================================================================
164     Key      Value
165     =======  ===================================================================
166     Option   A string containing the name of the policy as it appears in an
167              export from secedit, such as **PasswordComplexity**
168     Section  A string containing the name of the section in which the "Option"
169              value appears in an export from ``secedit``, such as "System
170              Access"
171     =======  ===================================================================
172     LsaRights Mechanism
173     -------------------
174     LSA Rights policies are configured via the LsaRights mechanism. The value of
175     this key is a dict with the following make-up:
176     ======  ====================================================================
177     Key     Value
178     ======  ====================================================================
179     Option  A string containing the programmatic name of the Lsa Right, such as
180             **SeNetworkLogonRight**
181     ======  ====================================================================
182     NetUserModal Mechanism
183     ----------------------
184     Some policies are configurable by the **NetUserModalGet** and
185     **NetUserModalSet** function from pywin32.  The value of this key is a dict
186     with the following make-up:
187     ======  ====================================================================
188     Key     Value
189     ======  ====================================================================
190     Modal   The modal "level" that the particular option is specified in (0-3),
191             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
192             aa370656(v=vs.85).aspx&gt;`_
193     Option  The name of the structure member which contains the data for the
194             policy, for example **max_passwd_age**
195     ======  ====================================================================
196     NetSH Mechanism
197     ---------------
198     The firewall policies are configured by the ``netsh.exe`` executable. The
199     value of this key is a dict with the following make-up:
200     =======  ===================================================================
201     Key      Value
202     =======  ===================================================================
203     Profile  The firewall profile to modify. Can be one of Domain, Private, or
204              Public
205     Section  The section of the firewall to modify. Can be one of state,
206              firewallpolicy, settings, or logging.
207     Option   The setting within that section
208     Value    The value of the setting
209     =======  ===================================================================
210     More information can be found in the advfirewall context in netsh. This can
211     be access by opening a netsh prompt. At a command prompt type the following:
212     c:\&gt;netsh
213     netsh&gt;advfirewall
214     netsh advfirewall&gt;set help
215     netsh advfirewall&gt;set domain help
216     AdvAudit Mechanism
217     ------------------
218     The Advanced Audit Policies are configured using a combination of the
219     auditpol command-line utility and modifying the audit.csv file in two
220     locations. The value of this key is a dict with the following make-up:
221     ======  ===================================
222     Key     Value
223     ======  ===================================
224     Option  The Advanced Audit Policy to modify
225     ======  ===================================
226     Transforms
227     ----------
228     Optionally, each policy definition can contain a "Transform" key. The
229     Transform key is used to handle data that is stored and viewed differently.
230     This key's value is a dict with the following key/value pairs:
231     ===  =======================================================================
232     Key  Value
233     ===  =======================================================================
234     Get  The name of the class function to use to transform the data from the
235          stored value to how the value is displayed in the GUI
236     Put The name of the class function to use to transform the data supplied by
237         the user to the correct value that the policy is stored in
238     ===  =======================================================================
239     For example, "Minimum password age" is stored in seconds, but is displayed
240     in days.  Thus the "Get" and "Put" functions for this policy do these
241     conversions so the user is able to set and view the policy using the same
242     data that is shown in the GUI.
243     def __init__(self):
244         self<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.audit_lookup = {
245             0: "No auditing",
246             1: "Success",
247             2: "Failure",
248             3: "Success, Failure",
249             "Not Defined": "Not Defined",
250             None: "Not Defined",
251         }
252         self.advanced_audit_lookup = {
253             0: "No Auditing",
254             1: "Success",
255             2: "Failure",
256             3: "Success and Failure",
257             None: "Not Configured",
258         }
259         self.sc_removal_lookup = {
260             "0": "No Action",
261             "1": "Lock Workstation",
262             "2": "Force Logoff",
263             "3": "Disconnect if a Remote Desktop Services session",
264             None: "Not Defined",
265             "(value not set)": "Not Defined",
266         }
267         self.uac_admin_prompt_lookup = {
268             0: "Elevate without prompting",
269             1: "Prompt for credentials on the secure desktop",
270             2: "Prompt for consent on the secure desktop",
271             3: "Prompt for credentials",
272             4: "Prompt for consent",
273             5: "Prompt for consent for non-Windows binaries",
274             None: "Not Defined",
275             "(value not set)": "Not Defined",
276         }
277         self.uac_user_prompt_lookup = {
278             0</b></font>: "Automatically deny elevation requests",
279             1: "Prompt for credentials on the secure desktop",
280             3: "Prompt for credentials",
281             None: "Not Defined",
282             "(value not set)": "Not Defined",
283         }
284         self.enabled_one_disabled_zero = {
285             0: "Disabled",
286             1: "Enabled",
287             None: "Not Defined",
288             "(value not set)": "Not Defined",
289         }
290         self.enabled_one_disabled_zero_transform = {
291             "Get": "_dict_lookup",
292             "Put": "_dict_lookup",
293             "GetArgs": {
294                 "lookup": self.enabled_one_disabled_zero,
295                 "value_lookup": False,
296             },
297             "PutArgs": {
298                 "lookup": self.enabled_one_disabled_zero,
299                 "value_lookup": True,
300             },
301         }
302         self.s4u2self_options = {
303             0: "Default",
304             1: "Enabled",
305             2: "Disabled",
306             None: "Not Defined",
307             "(value not set)": "Not Defined",
308         }
309         self.audit_transform = {
310             "Get": "_dict_lookup",
311             "Put": "_dict_lookup",
312             "GetArgs": {"lookup": self.audit_lookup, "value_lookup": False},
313             "PutArgs": {"lookup": self.audit_lookup, "value_lookup": True},
314         }
315         self.advanced_audit_transform = {
316             "Get": "_dict_lookup",
317             "Put": "_dict_lookup",
318             "GetArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": False},
319             "PutArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": True},
320         }
321         self.enabled_one_disabled_zero_strings = {
322             "0": "Disabled",
323             "1": "Enabled",
324             None: "Not Defined",
325             "(value not set)": "Not Defined",
326         }
327         self.enabled_one_disabled_zero_strings_transform = {
328             "Get": "_dict_lookup",
329             "Put": "_dict_lookup",
330             "GetArgs": {
331                 "lookup": self.enabled_one_disabled_zero_strings,
332                 "value_lookup": False,
333             },
334             "PutArgs": {
335                 "lookup": self.enabled_one_disabled_zero_strings,
336             },
337         }
338         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.security_options_gpedit_path = [
339             "Computer Configuration",
340             "Windows Settings",
341             "Security Settings",
342             "Local Policies",
343             "Security Options",
344         ]
345         self.windows_firewall_gpedit_path = [
346             "Computer Configuration",
347             "Windows Settings",
348             "Security Settings",
349             "Windows Firewall with Advanced Security",
350             "Windows Firewall with Advanced Security - Local Group Policy Object",
351         ]
352         self.password_policy_gpedit_path = [
353             "Computer Configuration",
354             "Windows Settings",
355             "Security Settings",
356             "Account Policies",
357             "Password Policy",
358         ]
359         self.audit_policy_gpedit_path = [
360             "Computer Configuration",
361             "Windows Settings",
362             "Security Settings",
363             "Local Policies",
364             "Audit Policy",
365         ]
366         self.advanced_audit_policy_gpedit_path = [
367             "Computer Configuration",
368             "Windows Settings",
369             "Security Settings",
370             "Advanced Audit Policy Configuration",
371             "System Audit Policies - Local Group Policy Object",
372         ]
373         self.account_lockout_policy_gpedit_path = [
374             "Computer Configuration",
375             "Windows Settings",
376             "Security Settings",
377             "Account Policies",
378             "Account Lockout Policy",
379         ]
380         self.user_rights_assignment_gpedit_path = [
381             "Computer Configuration",
382             "Windows Settings",
383             "Security Settings",
384             "Local Policies",
385             "User Rights Assignment",
386         ]
387         self.block_ms_accounts = {
388             0</b></font>: "This policy is disabled",
389             1: "Users can't add Microsoft accounts",
390             3: "Users can't add or log on with Microsoft accounts",
391             None: "Not Defined",
392             "(value not set)": "Not Defined",
393         }
394         self.ldap_server_signing_requirements = {
395             1: "None",
396             2: "Require signing",
397             None: "Not Defined",
398             "(value not set)": "Not Defined",
399         }
400         self.smb_server_name_hardening_levels = {
401             0: "Off",
402             1: "Accept if provided by client",
403             2: "Required from client",
404             None: "Not Defined",
405             "(value not set)": "Not Defined",
406         }
407         self.locked_session_user_info = {
408             1: "User display name, domain and user names",
409             2: "User display name only",
410             3: "Do not display user information",
411             None: "Not Defined",
412             "(value not set)": "Not Defined",
413         }
414         self.force_guest = {
415             0: "Classic - local users authenticate as themselves",
416             1: "Guest only - local users authenticate as Guest",
417             None: "Not Defined",
418             "(value not set)": "Not Defined",
419         }
420         self.force_key_protection = {
421             0: "User input is not required when new keys are stored and used",
422             1: "User is prompted when the key is first used",
423             2: "User must enter a password each time they use a key",
424             None: "Not Defined",
425             "(value not set)": "Not Defined",
426         }
427         self.firewall_inbound_connections = {
428             "blockinbound": "Block (default)",
429             "blockinboundalways": "Block all connections",
430             "allowinbound": "Allow",
431             "notconfigured": "Not configured",
432         }
433         self.firewall_outbound_connections = {
434             "blockoutbound": "Block",
435             "allowoutbound": "Allow (default)",
436             "notconfigured": "Not configured",
437         }
438         self.firewall_rule_merging = {
439             "enable": "Yes (default)",
440             "disable": "No",
441             "notconfigured": "Not configured",
442         }
443         self.firewall_log_packets_connections = {
444             "enable": "Yes",
445             "disable": "No (default)",
446             "notconfigured": "Not configured",
447         }
448         self.firewall_notification = {
449             "enable": "Yes",
450             "disable": "No",
451             "notconfigured": "Not configured",
452         }
453         self.firewall_state = {
454             "on": "On (recommended)",
455             "off": "Off",
456             "notconfigured": "Not configured",
457         }
458         self.krb_encryption_types = {
459             0: "No minimum",
460             1: "DES_CBC_CRC",
461             2: "DES_CBD_MD5",
462             4: "RC4_HMAC_MD5",
463             8: "AES128_HMAC_SHA1",
464             16: "AES256_HMAC_SHA1",
465             2147483616: "Future Encryption Types",
466             None: "Not Defined",
467             "(value not set)": "Not Defined",
468         }
469         self.lm_compat_levels = {
470             0: "Send LM &amp; NTLM response",
471             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
472             2: "Send NTLM response only",
473             3: "Send NTLMv2 response only",
474             4: "Send NTLMv2 response only. Refuse LM",
475             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
476             None: "Not Defined",
477             "(value not set)": "Not Defined",
478         }
479         self.ldap_signing_reqs = {
480             0: "None",
481             1: "Negotiate signing",
482             2: "Require signing",
483             None: "Not Defined",
484             "(value not set)": "Not Defined",
485         }
486         self.ntlm_session_security_levels = {
487             0: "No minimum",
488             524288: "Require NTLMv2 session security",
489             536870912: "Require 128-bit encryption",
490             None: "Not Defined",
491             "(value not set)": "Not Defined",
492         }
493         self.ntlm_audit_settings = {
494             0: "Disable",
495             1: "Enable auditing for domain accounts",
496             2: "Enable auditing for all accounts",
497             None: "Not Defined",
498             "(value not set)": "Not Defined",
499         }
500         self.ntlm_domain_audit_settings = {
501             0: "Disable",
502             1: "Enable for domain accounts to domain servers",
503             3: "Enable for domain accounts",
504             5: "Enable for domain servers",
505             7: "Enable all",
506             None: "Not Defined",
507             "(value not set)": "Not Defined",
508         }
509         self.incoming_ntlm_settings = {
510             0: "Allow all",
511             1: "Deny all domain accounts",
512             2: "Deny all accounts",
513             None: "Not Defined",
514             "(value not set)": "Not Defined",
515         }
516         self.ntlm_domain_auth_settings = {
517             0: "Disable",
518             1: "Deny for domain accounts to domain servers",
519             3: "Deny for domain accounts",
520             5: "Deny for domain servers",
521             7: "Deny all",
522             None: "Not Defined",
523             "(value not set)": "Not Defined",
524         }
525         self.outgoing_ntlm_settings = {
526             0: "Allow all",
527             1: "Audit all",
528             2: "Deny all",
529             None: "Not Defined",
530             "(value not set)": "Not Defined",
531         }
532         self.enabled_one_disabled_zero_no_not_defined = {
533             0: "Disabled",
534             1: "Enabled",
535         }
536         self.enabled_one_disabled_zero_no_not_defined_transform = {
537             "Get": "_dict_lookup",
538             "Put": "_dict_lookup",
539             "GetArgs": {
540                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
541                 "value_lookup": False,
542             },
543             "PutArgs": {
544                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
545                 "value_lookup": True,
546             },
547         }
548         self.policies = {
549             "Machine": {
550                 "lgpo_section": "Computer Configuration",
551                 "policies": {
552                     "StartupScripts": {
553                         "Policy": "Startup Scripts",
554                         "lgpo_section": [
555                             "Computer Configuration",
556                             "Windows Settings",
557                             "Scripts (Startup/Shutdown)",
558                             "Startup",
559                         ],
560                         "ScriptIni": {
561                             "Section": "Startup",
562                             "IniPath": os.path.join(
563                                 os.getenv("WINDIR"),
564                                 "System32",
565                                 "GroupPolicy",
566                                 "Machine",
567                                 "Scripts",
568                                 "scripts.ini",
569                             ),
570                         },
571                     },
572                     "StartupPowershellScripts": {
573                         "Policy": "Startup Powershell Scripts",
574                         "lgpo_section": [
575                             "Computer Configuration",
576                             "Windows Settings",
577                             "Scripts (Startup/Shutdown)",
578                             "Startup",
579                         ],
580                         "ScriptIni": {
581                             "Section": "Startup",
582                             "IniPath": os.path.join(
583                                 os.getenv("WINDIR"),
584                                 "System32",
585                                 "GroupPolicy",
586                                 "Machine",
587                                 "Scripts",
588                                 "psscripts.ini",
589                             ),
590                         },
591                     },
592                     "StartupPowershellScriptOrder": {
593                         "Policy": (
594                             "Startup - For this GPO, run scripts in the following order"
595                         ),
596                         "lgpo_section": [
597                             "Computer Configuration",
598                             "Windows Settings",
599                             "Scripts (Startup/Shutdown)",
600                             "Startup",
601                         ],
602                         "ScriptIni": {
603                             "IniPath": os.path.join(
604                                 os.getenv("WINDIR"),
605                                 "System32",
606                                 "GroupPolicy",
607                                 "Machine",
608                                 "Scripts",
609                                 "psscripts.ini",
610                             ),
611                             "Section": "ScriptsConfig",
612                             "SettingName": "StartExecutePSFirst",
613                             "Settings": ["true", "false", None],
614                         },
615                         "Transform": {
616                             "Get": "_powershell_script_order_conversion",
617                             "Put": "_powershell_script_order_reverse_conversion",
618                         },
619                     },
620                     "ShutdownScripts": {
621                         "Policy": "Shutdown Scripts",
622                         "lgpo_section": [
623                             "Computer Configuration",
624                             "Windows Settings",
625                             "Scripts (Startup/Shutdown)",
626                             "Shutdown",
627                         ],
628                         "ScriptIni": {
629                             "Section": "Shutdown",
630                             "IniPath": os.path.join(
631                                 os.getenv("WINDIR"),
632                                 "System32",
633                                 "GroupPolicy",
634                                 "Machine",
635                                 "Scripts",
636                                 "scripts.ini",
637                             ),
638                         },
639                     },
640                     "ShutdownPowershellScripts": {
641                         "Policy": "Shutdown Powershell Scripts",
642                         "lgpo_section": [
643                             "Computer Configuration",
644                             "Windows Settings",
645                             "Scripts (Startup/Shutdown)",
646                             "Shutdown",
647                         ],
648                         "ScriptIni": {
649                             "Section": "Shutdown",
650                             "IniPath": os.path.join(
651                                 os.getenv("WINDIR"),
652                                 "System32",
653                                 "GroupPolicy",
654                                 "Machine",
655                                 "Scripts",
656                                 "psscripts.ini",
657                             ),
658                         },
659                     },
660                     "ShutdownPowershellScriptOrder": {
661                         "Policy": (
662                             "Shutdown - For this GPO, run scripts in the "
663                             "following order"
664                         ),
665                         "lgpo_section": [
666                             "Computer Configuration",
667                             "Windows Settings",
668                             "Scripts (Startup/Shutdown)",
669                             "Shutdown",
670                         ],
671                         "ScriptIni": {
672                             "IniPath": os.path.join(
673                                 os.getenv("WINDIR"),
674                                 "System32",
675                                 "GroupPolicy",
676                                 "Machine",
677                                 "Scripts",
678                                 "psscripts.ini",
679                             ),
680                             "Section": "ScriptsConfig",
681                             "SettingName": "EndExecutePSFirst",
682                             "Settings": ["true", "false", None],
683                         },
684                         "Transform": {
685                             "Get": "_powershell_script_order_conversion",
686                             "Put": "_powershell_script_order_reverse_conversion",
687                         },
688                     },
689                     "LSAAnonymousNameLookup": {
690                         "Policy": (
691                             "Network access: Allow anonymous SID/Name translation"
692                         ),
693                         "lgpo_section": self.password_policy_gpedit_path,
694                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
695                         "Secedit": {
696                             "Option": "LSAAnonymousNameLookup",
697                             "Section": "System Access",
698                         },
699                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
700                     },
701                     "RestrictAnonymousSam": {
702                         "Policy": (
703                             "Network access: Do not allow anonymous "
704                         ),
705                         "lgpo_section": self.security_options_gpedit_path,
706                         "Settings": self.enabled_one_disabled_zero<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.keys(),
707                         "Registry": {
708                             "Hive": "HKEY_LOCAL_MACHINE",
709                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
710                             "Value": "RestrictAnonymousSam",
711                             "Type": "REG_DWORD",
712                         },
713                         "Transform": self.enabled_one_disabled_zero_transform,
714                     },
715                     "RestrictRemoteSAM": {
716                         "Policy": (
717                             "Network access: Restrict clients allowed to "
718                             "make remote calls to SAM"
719                         ),
720                         "lgpo_section": self.security_options_gpedit_path,
721                         "Registry": {
722                             "Hive": "HKEY_LOCAL_MACHINE",
723                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
724                             "Value": "RestrictRemoteSAM",
725                             "Type": "REG_SZ",
726                         },
727                         "Transform": {"Put": "_string_put_transform"},
728                     },
729                     "RestrictAnonymous": {
730                         "Policy": (
731                             "Network access: Do not allow anonymous "
732                             "enumeration of SAM accounts and shares"
733                         ),
734                         "lgpo_section": self.security_options_gpedit_path,
735                         "Settings": self.enabled_one_disabled_zero.keys(</b></font>),
736                         "Registry": {
737                             "Hive": "HKEY_LOCAL_MACHINE",
738                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
739                             "Value": "RestrictAnonymous",
740                             "Type": "REG_DWORD",
741                         },
742                         "Transform": self.enabled_one_disabled_zero_transform,
743                     },
744                     "DisableDomainCreds": {
745                         "Policy": (
746                             "Network access: Do not allow storage of "
747                             "passwords and credentials for network "
748                             "authentication"
749                         ),
750                         "lgpo_section": self.security_options_gpedit_path,
751                         "Settings": self.enabled_one_disabled_zero.keys(),
752                         "Registry": {
753                             "Hive": "HKEY_LOCAL_MACHINE",
754                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
755                             "Value": "DisableDomainCreds",
756                             "Type": "REG_DWORD",
757                         },
758                         "Transform": self.enabled_one_disabled_zero_transform,
759                     },
760                     "EveryoneIncludesAnonymous": {
761                         "Policy": (
762                             "Network access: Let Everyone permissions "
763                             "apply to anonymous users"
764                         ),
765                         "lgpo_section": self.security_options_gpedit_path,
766                         "Settings": self.enabled_one_disabled_zero.keys(),
767                         "Registry": {
768                             "Hive": "HKEY_LOCAL_MACHINE",
769                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
770                             "Value": "everyoneincludesanonymous",
771                             "Type": "REG_DWORD",
772                         },
773                         "Transform": self.enabled_one_disabled_zero_transform,
774                     },
775                     "NullSessionPipes": {
776                         "Policy": (
777                             "Network access: Named Pipes that can be "
778                             "accessed anonymously"
779                         ),
780                         "lgpo_section": self.security_options_gpedit_path,
781                         "Registry": {
782                             "Hive": "HKEY_LOCAL_MACHINE",
783                             "Path": (
784                                 "SYSTEM\\CurrentControlSet\\Services\\"
785                                 "LanmanServer\\Parameters"
786                             ),
787                             "Value": "NullSessionPipes",
788                             "Type": "REG_MULTI_SZ",
789                         },
790                         "Transform": {
791                             "Put": "_multi_string_put_transform",
792                             "Get": "_multi_string_get_transform",
793                         },
794                     },
795                     "RemoteRegistryExactPaths": {
796                         "Policy": "Network access: Remotely accessible registry paths",
797                         "lgpo_section": self.security_options_gpedit_path,
798                         "Registry": {
799                             "Hive": "HKEY_LOCAL_MACHINE",
800                             "Path": (
801                                 "SYSTEM\\CurrentControlSet\\Control\\"
802                                 "SecurePipeServers\\winreg\\"
803                                 "AllowedExactPaths"
804                             ),
805                             "Value": "Machine",
806                             "Type": "REG_MULTI_SZ",
807                         },
808                         "Transform": {
809                             "Put": "_multi_string_put_transform",
810                             "Get": "_multi_string_get_transform",
811                         },
812                     },
813                     "RemoteRegistryPaths": {
814                         "Policy": (
815                             "Network access: Remotely accessible "
816                             "registry paths and sub-paths"
817                         ),
818                         "lgpo_section": self.security_options_gpedit_path,
819                         "Registry": {
820                             "Hive": "HKEY_LOCAL_MACHINE",
821                             "Path": (
822                                 "SYSTEM\\CurrentControlSet\\Control\\"
823                                 "SecurePipeServers\\winreg\\AllowedPaths"
824                             ),
825                             "Value": "Machine",
826                             "Type": "REG_MULTI_SZ",
827                         },
828                         "Transform": {
829                             "Put": "_multi_string_put_transform",
830                             "Get": "_multi_string_get_transform",
831                         },
832                     },
833                     "RestrictNullSessAccess": {
834                         "Policy": (
835                             "Network access: Restrict anonymous access "
836                             "to Named Pipes and Shares"
837                         ),
838                         "lgpo_section": self.security_options_gpedit_path,
839                         "Settings": self.enabled_one_disabled_zero.keys(),
840                         "Registry": {
841                             "Hive": "HKEY_LOCAL_MACHINE",
842                             "Path": (
843                                 "System\\CurrentControlSet\\Services\\"
844                                 "LanmanServer\\Parameters"
845                             ),
846                             "Value": "RestrictNullSessAccess",
847                             "Type": "REG_DWORD",
848                         },
849                         "Transform": self.enabled_one_disabled_zero_transform,
850                     },
851                     "NullSessionShares": {
852                         "Policy": (
853                             "Network access: Shares that can be accessed anonymously"
854                         ),
855                         "lgpo_section": self.security_options_gpedit_path,
856                         "Registry": {
857                             "Hive": "HKEY_LOCAL_MACHINE",
858                             "Path": (
859                                 "SYSTEM\\CurrentControlSet\\Services\\"
860                                 "LanmanServer\\Parameters"
861                             ),
862                             "Value": "NullSessionShares",
863                             "Type": "REG_MULTI_SZ",
864                         },
865                         "Transform": {
866                             "Put": "_multi_string_put_transform",
867                             "Get": "_multi_string_get_transform",
868                         },
869                     },
870                     "ForceGuest": {
871                         "Policy": (
872                             "Network access: Sharing and security model "
873                             "for local accounts"
874                         ),
875                         "lgpo_section": self.security_options_gpedit_path,
876                         "Settings": self.force_guest.keys(),
877                         "Registry": {
878                             "Hive": "HKEY_LOCAL_MACHINE",
879                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
880                             "Value": "ForceGuest",
881                             "Type": "REG_DWORD",
882                         },
883                         "Transform": {
884                             "Get": "_dict_lookup",
885                             "Put": "_dict_lookup",
886                             "GetArgs": {
887                                 "lookup": self.force_guest,
888                                 "value_lookup": False,
889                             },
890                             "PutArgs": {
891                                 "lookup": self.force_guest,
892                                 "value_lookup": True,
893                             },
894                         },
895                     },
896                     "WfwDomainState": {
897                         "Policy": "Network firewall: Domain: State",
898                         "lgpo_section": self.windows_firewall_gpedit_path,
899                         "Settings": self.firewall_state.keys(),
900                         "NetSH": {
901                             "Profile": "domain",
902                             "Section": "state",
903                             "Option": "State",  # Unused, but needed
904                         },
905                         "Transform": {
906                             "Get": "_dict_lookup",
907                             "Put": "_dict_lookup",
908                             "GetArgs": {
909                                 "lookup": self.firewall_state,
910                                 "value_lookup": False,
911                             },
912                             "PutArgs": {
913                                 "lookup": self.firewall_state,
914                                 "value_lookup": True,
915                             },
916                         },
917                     },
918                     "WfwPrivateState": {
919                         "Policy": "Network firewall: Private: State",
920                         "lgpo_section": self.windows_firewall_gpedit_path,
921                         "Settings": self.firewall_state.keys(),
922                         "NetSH": {
923                             "Profile": "private",
924                             "Section": "state",
925                             "Option": "State",  # Unused, but needed
926                         },
927                         "Transform": {
928                             "Get": "_dict_lookup",
929                             "Put": "_dict_lookup",
930                             "GetArgs": {
931                                 "lookup": self.firewall_state,
932                                 "value_lookup": False,
933                             },
934                             "PutArgs": {
935                                 "lookup": self.firewall_state,
936                                 "value_lookup": True,
937                             },
938                         },
939                     },
940                     "WfwPublicState": {
941                         "Policy": "Network firewall: Public: State",
942                         "lgpo_section": self.windows_firewall_gpedit_path,
943                         "Settings": self.firewall_state.keys(),
944                         "NetSH": {
945                             "Profile": "public",
946                             "Section": "state",
947                             "Option": "State",  # Unused, but needed
948                         },
949                         "Transform": {
950                             "Get": "_dict_lookup",
951                             "Put": "_dict_lookup",
952                             "GetArgs": {
953                                 "lookup": self.firewall_state,
954                                 "value_lookup": False,
955                             },
956                             "PutArgs": {
957                                 "lookup": self.firewall_state,
958                                 "value_lookup": True,
959                             },
960                         },
961                     },
962                     "WfwDomainInboundConnections": {
963                         "Policy": "Network firewall: Domain: Inbound connections",
964                         "lgpo_section": self.windows_firewall_gpedit_path,
965                         "Settings": self.firewall_inbound_connections.keys(),
966                         "NetSH": {
967                             "Profile": "domain",
968                             "Section": "firewallpolicy",
969                             "Option": "Inbound",
970                         },
971                         "Transform": {
972                             "Get": "_dict_lookup",
973                             "Put": "_dict_lookup",
974                             "GetArgs": {
975                                 "lookup": self.firewall_inbound_connections,
976                                 "value_lookup": False,
977                             },
978                             "PutArgs": {
979                                 "lookup": self.firewall_inbound_connections,
980                                 "value_lookup": True,
981                             },
982                         },
983                     },
984                     "WfwPrivateInboundConnections": {
985                         "Policy": "Network firewall: Private: Inbound connections",
986                         "lgpo_section": self.windows_firewall_gpedit_path,
987                         "Settings": self.firewall_inbound_connections.keys(),
988                         "NetSH": {
989                             "Profile": "private",
990                             "Section": "firewallpolicy",
991                             "Option": "Inbound",
992                         },
993                         "Transform": {
994                             "Get": "_dict_lookup",
995                             "Put": "_dict_lookup",
996                             "GetArgs": {
997                                 "lookup": self.firewall_inbound_connections,
998                                 "value_lookup": False,
999                             },
1000                             "PutArgs": {
1001                                 "lookup": self.firewall_inbound_connections,
1002                                 "value_lookup": True,
1003                             },
1004                         },
1005                     },
1006                     "WfwPublicInboundConnections": {
1007                         "Policy": "Network firewall: Public: Inbound connections",
1008                         "lgpo_section": self.windows_firewall_gpedit_path,
1009                         "Settings": self.firewall_inbound_connections.keys(),
1010                         "NetSH": {
1011                             "Profile": "public",
1012                             "Section": "firewallpolicy",
1013                             "Option": "Inbound",
1014                         },
1015                         "Transform": {
1016                             "Get": "_dict_lookup",
1017                             "Put": "_dict_lookup",
1018                             "GetArgs": {
1019                                 "lookup": self.firewall_inbound_connections,
1020                                 "value_lookup": False,
1021                             },
1022                             "PutArgs": {
1023                                 "lookup": self.firewall_inbound_connections,
1024                                 "value_lookup": True,
1025                             },
1026                         },
1027                     },
1028                     "WfwDomainOutboundConnections": {
1029                         "Policy": "Network firewall: Domain: Outbound connections",
1030                         "lgpo_section": self.windows_firewall_gpedit_path,
1031                         "Settings": self.firewall_outbound_connections.keys(),
1032                         "NetSH": {
1033                             "Profile": "domain",
1034                             "Section": "firewallpolicy",
1035                             "Option": "Outbound",
1036                         },
1037                         "Transform": {
1038                             "Get": "_dict_lookup",
1039                             "Put": "_dict_lookup",
1040                             "GetArgs": {
1041                                 "lookup": self.firewall_outbound_connections,
1042                                 "value_lookup": False,
1043                             },
1044                             "PutArgs": {
1045                                 "lookup": self.firewall_outbound_connections,
1046                                 "value_lookup": True,
1047                             },
1048                         },
1049                     },
1050                     "WfwPrivateOutboundConnections": {
1051                         "Policy": "Network firewall: Private: Outbound connections",
1052                         "lgpo_section": self.windows_firewall_gpedit_path,
1053                         "Settings": self.firewall_outbound_connections.keys(),
1054                         "NetSH": {
1055                             "Profile": "private",
1056                             "Section": "firewallpolicy",
1057                             "Option": "Outbound",
1058                         },
1059                         "Transform": {
1060                             "Get": "_dict_lookup",
1061                             "Put": "_dict_lookup",
1062                             "GetArgs": {
1063                                 "lookup": self.firewall_outbound_connections,
1064                                 "value_lookup": False,
1065                             },
1066                             "PutArgs": {
1067                                 "lookup": self.firewall_outbound_connections,
1068                                 "value_lookup": True,
1069                             },
1070                         },
1071                     },
1072                     "WfwPublicOutboundConnections": {
1073                         "Policy": "Network firewall: Public: Outbound connections",
1074                         "lgpo_section": self.windows_firewall_gpedit_path,
1075                         "Settings": self.firewall_outbound_connections.keys(),
1076                         "NetSH": {
1077                             "Profile": "public",
1078                             "Section": "firewallpolicy",
1079                             "Option": "Outbound",
1080                         },
1081                         "Transform": {
1082                             "Get": "_dict_lookup",
1083                             "Put": "_dict_lookup",
1084                             "GetArgs": {
1085                                 "lookup": self.firewall_outbound_connections,
1086                                 "value_lookup": False,
1087                             },
1088                             "PutArgs": {
1089                                 "lookup": self.firewall_outbound_connections,
1090                                 "value_lookup": True,
1091                             },
1092                         },
1093                     },
1094                     "WfwDomainSettingsNotification": {
1095                         "Policy": (
1096                             "Network firewall: Domain: Settings: Display a notification"
1097                         ),
1098                         "lgpo_section": self.windows_firewall_gpedit_path,
1099                         "Settings": self.firewall_notification.keys(),
1100                         "NetSH": {
1101                             "Profile": "domain",
1102                             "Section": "settings",
1103                             "Option": "InboundUserNotification",
1104                         },
1105                         "Transform": {
1106                             "Get": "_dict_lookup",
1107                             "Put": "_dict_lookup",
1108                             "GetArgs": {
1109                                 "lookup": self.firewall_notification,
1110                                 "value_lookup": False,
1111                             },
1112                             "PutArgs": {
1113                                 "lookup": self.firewall_notification,
1114                                 "value_lookup": True,
1115                             },
1116                         },
1117                     },
1118                     "WfwPrivateSettingsNotification": {
1119                         "Policy": (
1120                             "Network firewall: Private: Settings: Display a"
1121                             " notification"
1122                         ),
1123                         "lgpo_section": self.windows_firewall_gpedit_path,
1124                         "Settings": self.firewall_notification.keys(),
1125                         "NetSH": {
1126                             "Profile": "private",
1127                             "Section": "settings",
1128                             "Option": "InboundUserNotification",
1129                         },
1130                         "Transform": {
1131                             "Get": "_dict_lookup",
1132                             "Put": "_dict_lookup",
1133                             "GetArgs": {
1134                                 "lookup": self.firewall_notification,
1135                                 "value_lookup": False,
1136                             },
1137                             "PutArgs": {
1138                                 "lookup": self.firewall_notification,
1139                                 "value_lookup": True,
1140                             },
1141                         },
1142                     },
1143                     "WfwPublicSettingsNotification": {
1144                         "Policy": (
1145                             "Network firewall: Public: Settings: Display a notification"
1146                         ),
1147                         "lgpo_section": self.windows_firewall_gpedit_path,
1148                         "Settings": self.firewall_notification.keys(),
1149                         "NetSH": {
1150                             "Profile": "public",
1151                             "Section": "settings",
1152                             "Option": "InboundUserNotification",
1153                         },
1154                         "Transform": {
1155                             "Get": "_dict_lookup",
1156                             "Put": "_dict_lookup",
1157                             "GetArgs": {
1158                                 "lookup": self.firewall_notification,
1159                                 "value_lookup": False,
1160                             },
1161                             "PutArgs": {
1162                                 "lookup": self.firewall_notification,
1163                                 "value_lookup": True,
1164                             },
1165                         },
1166                     },
1167                     "WfwDomainSettingsLocalFirewallRules": {
1168                         "Policy": (
1169                             "Network firewall: Domain: Settings: Apply "
1170                             "local firewall rules"
1171                         ),
1172                         "lgpo_section": self.windows_firewall_gpedit_path,
1173                         "Settings": self.firewall_rule_merging.keys(),
1174                         "NetSH": {
1175                             "Profile": "domain",
1176                             "Section": "settings",
1177                             "Option": "LocalFirewallRules",
1178                         },
1179                         "Transform": {
1180                             "Get": "_dict_lookup",
1181                             "Put": "_dict_lookup",
1182                             "GetArgs": {
1183                                 "lookup": self.firewall_rule_merging,
1184                                 "value_lookup": False,
1185                             },
1186                             "PutArgs": {
1187                                 "lookup": self.firewall_rule_merging,
1188                                 "value_lookup": True,
1189                             },
1190                         },
1191                     },
1192                     "WfwPrivateSettingsLocalFirewallRules": {
1193                         "Policy": (
1194                             "Network firewall: Private: Settings: Apply "
1195                             "local firewall rules"
1196                         ),
1197                         "lgpo_section": self.windows_firewall_gpedit_path,
1198                         "Settings": self.firewall_rule_merging.keys(),
1199                         "NetSH": {
1200                             "Profile": "private",
1201                             "Section": "settings",
1202                             "Option": "LocalFirewallRules",
1203                         },
1204                         "Transform": {
1205                             "Get": "_dict_lookup",
1206                             "Put": "_dict_lookup",
1207                             "GetArgs": {
1208                                 "lookup": self.firewall_rule_merging,
1209                                 "value_lookup": False,
1210                             },
1211                             "PutArgs": {
1212                                 "lookup": self.firewall_rule_merging,
1213                                 "value_lookup": True,
1214                             },
1215                         },
1216                     },
1217                     "WfwPublicSettingsLocalFirewallRules": {
1218                         "Policy": (
1219                             "Network firewall: Public: Settings: Apply "
1220                             "local firewall rules"
1221                         ),
1222                         "lgpo_section": self.windows_firewall_gpedit_path,
1223                         "Settings": self.firewall_rule_merging.keys(),
1224                         "NetSH": {
1225                             "Profile": "public",
1226                             "Section": "settings",
1227                             "Option": "LocalFirewallRules",
1228                         },
1229                         "Transform": {
1230                             "Get": "_dict_lookup",
1231                             "Put": "_dict_lookup",
1232                             "GetArgs": {
1233                                 "lookup": self.firewall_rule_merging,
1234                                 "value_lookup": False,
1235                             },
1236                             "PutArgs": {
1237                                 "lookup": self.firewall_rule_merging,
1238                                 "value_lookup": True,
1239                             },
1240                         },
1241                     },
1242                     "WfwDomainSettingsLocalConnectionRules": {
1243                         "Policy": (
1244                             "Network firewall: Domain: Settings: Apply "
1245                             "local connection security rules"
1246                         ),
1247                         "lgpo_section": self.windows_firewall_gpedit_path,
1248                         "Settings": self.firewall_rule_merging.keys(),
1249                         "NetSH": {
1250                             "Profile": "domain",
1251                             "Section": "settings",
1252                             "Option": "LocalConSecRules",
1253                         },
1254                         "Transform": {
1255                             "Get": "_dict_lookup",
1256                             "Put": "_dict_lookup",
1257                             "GetArgs": {
1258                                 "lookup": self.firewall_rule_merging,
1259                                 "value_lookup": False,
1260                             },
1261                             "PutArgs": {
1262                                 "lookup": self.firewall_rule_merging,
1263                                 "value_lookup": True,
1264                             },
1265                         },
1266                     },
1267                     "WfwPrivateSettingsLocalConnectionRules": {
1268                         "Policy": (
1269                             "Network firewall: Private: Settings: Apply "
1270                             "local connection security rules"
1271                         ),
1272                         "lgpo_section": self.windows_firewall_gpedit_path,
1273                         "Settings": self.firewall_rule_merging.keys(),
1274                         "NetSH": {
1275                             "Profile": "private",
1276                             "Section": "settings",
1277                             "Option": "LocalConSecRules",
1278                         },
1279                         "Transform": {
1280                             "Get": "_dict_lookup",
1281                             "Put": "_dict_lookup",
1282                             "GetArgs": {
1283                                 "lookup": self.firewall_rule_merging,
1284                                 "value_lookup": False,
1285                             },
1286                             "PutArgs": {
1287                                 "lookup": self.firewall_rule_merging,
1288                                 "value_lookup": True,
1289                             },
1290                         },
1291                     },
1292                     "WfwPublicSettingsLocalConnectionRules": {
1293                         "Policy": (
1294                             "Network firewall: Public: Settings: Apply "
1295                             "local connection security rules"
1296                         ),
1297                         "lgpo_section": self.windows_firewall_gpedit_path,
1298                         "Settings": self.firewall_rule_merging.keys(),
1299                         "NetSH": {
1300                             "Profile": "public",
1301                             "Section": "settings",
1302                             "Option": "LocalConSecRules",
1303                         },
1304                         "Transform": {
1305                             "Get": "_dict_lookup",
1306                             "Put": "_dict_lookup",
1307                             "GetArgs": {
1308                                 "lookup": self.firewall_rule_merging,
1309                                 "value_lookup": False,
1310                             },
1311                             "PutArgs": {
1312                                 "lookup": self.firewall_rule_merging,
1313                                 "value_lookup": True,
1314                             },
1315                         },
1316                     },
1317                     "WfwDomainLoggingName": {
1318                         "Policy": "Network firewall: Domain: Logging: Name",
1319                         "lgpo_section": self.windows_firewall_gpedit_path,
1320                         "Settings": None,
1321                         "NetSH": {
1322                             "Profile": "domain",
1323                             "Section": "logging",
1324                             "Option": "FileName",
1325                         },
1326                     },
1327                     "WfwPrivateLoggingName": {
1328                         "Policy": "Network firewall: Private: Logging: Name",
1329                         "lgpo_section": self.windows_firewall_gpedit_path,
1330                         "Settings": None,
1331                         "NetSH": {
1332                             "Profile": "private",
1333                             "Section": "logging",
1334                             "Option": "FileName",
1335                         },
1336                     },
1337                     "WfwPublicLoggingName": {
1338                         "Policy": "Network firewall: Public: Logging: Name",
1339                         "lgpo_section": self.windows_firewall_gpedit_path,
1340                         "Settings": None,
1341                         "NetSH": {
1342                             "Profile": "public",
1343                             "Section": "logging",
1344                             "Option": "FileName",
1345                         },
1346                     },
1347                     "WfwDomainLoggingMaxFileSize": {
1348                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1349                         "lgpo_section": self.windows_firewall_gpedit_path,
1350                         "Settings": None,
1351                         "NetSH": {
1352                             "Profile": "domain",
1353                             "Section": "logging",
1354                             "Option": "MaxFileSize",
1355                         },
1356                     },
1357                     "WfwPrivateLoggingMaxFileSize": {
1358                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1359                         "lgpo_section": self.windows_firewall_gpedit_path,
1360                         "Settings": None,
1361                         "NetSH": {
1362                             "Profile": "private",
1363                             "Section": "logging",
1364                             "Option": "MaxFileSize",
1365                         },
1366                     },
1367                     "WfwPublicLoggingMaxFileSize": {
1368                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1369                         "lgpo_section": self.windows_firewall_gpedit_path,
1370                         "Settings": None,
1371                         "NetSH": {
1372                             "Profile": "public",
1373                             "Section": "logging",
1374                             "Option": "MaxFileSize",
1375                         },
1376                     },
1377                     "WfwDomainLoggingAllowedConnections": {
1378                         "Policy": (
1379                             "Network firewall: Domain: Logging: Log successful"
1380                             " connections"
1381                         ),
1382                         "lgpo_section": self.windows_firewall_gpedit_path,
1383                         "Settings": self.firewall_log_packets_connections.keys(),
1384                         "NetSH": {
1385                             "Profile": "domain",
1386                             "Section": "logging",
1387                             "Option": "LogAllowedConnections",
1388                         },
1389                         "Transform": {
1390                             "Get": "_dict_lookup",
1391                             "Put": "_dict_lookup",
1392                             "GetArgs": {
1393                                 "lookup": self.firewall_log_packets_connections,
1394                                 "value_lookup": False,
1395                             },
1396                             "PutArgs": {
1397                                 "lookup": self.firewall_log_packets_connections,
1398                                 "value_lookup": True,
1399                             },
1400                         },
1401                     },
1402                     "WfwPrivateLoggingAllowedConnections": {
1403                         "Policy": (
1404                             "Network firewall: Private: Logging: Log successful"
1405                             " connections"
1406                         ),
1407                         "lgpo_section": self.windows_firewall_gpedit_path,
1408                         "Settings": self.firewall_log_packets_connections.keys(),
1409                         "NetSH": {
1410                             "Profile": "private",
1411                             "Section": "logging",
1412                             "Option": "LogAllowedConnections",
1413                         },
1414                         "Transform": {
1415                             "Get": "_dict_lookup",
1416                             "Put": "_dict_lookup",
1417                             "GetArgs": {
1418                                 "lookup": self.firewall_log_packets_connections,
1419                                 "value_lookup": False,
1420                             },
1421                             "PutArgs": {
1422                                 "lookup": self.firewall_log_packets_connections,
1423                                 "value_lookup": True,
1424                             },
1425                         },
1426                     },
1427                     "WfwPublicLoggingAllowedConnections": {
1428                         "Policy": (
1429                             "Network firewall: Public: Logging: Log successful"
1430                             " connections"
1431                         ),
1432                         "lgpo_section": self.windows_firewall_gpedit_path,
1433                         "Settings": self.firewall_log_packets_connections.keys(),
1434                         "NetSH": {
1435                             "Profile": "public",
1436                             "Section": "logging",
1437                             "Option": "LogAllowedConnections",
1438                         },
1439                         "Transform": {
1440                             "Get": "_dict_lookup",
1441                             "Put": "_dict_lookup",
1442                             "GetArgs": {
1443                                 "lookup": self.firewall_log_packets_connections,
1444                                 "value_lookup": False,
1445                             },
1446                             "PutArgs": {
1447                                 "lookup": self.firewall_log_packets_connections,
1448                                 "value_lookup": True,
1449                             },
1450                         },
1451                     },
1452                     "WfwDomainLoggingDroppedConnections": {
1453                         "Policy": (
1454                             "Network firewall: Domain: Logging: Log dropped packets"
1455                         ),
1456                         "lgpo_section": self.windows_firewall_gpedit_path,
1457                         "Settings": self.firewall_log_packets_connections.keys(),
1458                         "NetSH": {
1459                             "Profile": "domain",
1460                             "Section": "logging",
1461                             "Option": "LogDroppedConnections",
1462                         },
1463                         "Transform": {
1464                             "Get": "_dict_lookup",
1465                             "Put": "_dict_lookup",
1466                             "GetArgs": {
1467                                 "lookup": self.firewall_log_packets_connections,
1468                                 "value_lookup": False,
1469                             },
1470                             "PutArgs": {
1471                                 "lookup": self.firewall_log_packets_connections,
1472                                 "value_lookup": True,
1473                             },
1474                         },
1475                     },
1476                     "WfwPrivateLoggingDroppedConnections": {
1477                         "Policy": (
1478                             "Network firewall: Private: Logging: Log dropped packets"
1479                         ),
1480                         "lgpo_section": self.windows_firewall_gpedit_path,
1481                         "Settings": self.firewall_log_packets_connections.keys(),
1482                         "NetSH": {
1483                             "Profile": "private",
1484                             "Section": "logging",
1485                             "Option": "LogDroppedConnections",
1486                         },
1487                         "Transform": {
1488                             "Get": "_dict_lookup",
1489                             "Put": "_dict_lookup",
1490                             "GetArgs": {
1491                                 "lookup": self.firewall_log_packets_connections,
1492                                 "value_lookup": False,
1493                             },
1494                             "PutArgs": {
1495                                 "lookup": self.firewall_log_packets_connections,
1496                                 "value_lookup": True,
1497                             },
1498                         },
1499                     },
1500                     "WfwPublicLoggingDroppedConnections": {
1501                         "Policy": (
1502                             "Network firewall: Public: Logging: Log dropped packets"
1503                         ),
1504                         "lgpo_section": self.windows_firewall_gpedit_path,
1505                         "Settings": self.firewall_log_packets_connections.keys(),
1506                         "NetSH": {
1507                             "Profile": "public",
1508                             "Section": "logging",
1509                             "Option": "LogDroppedConnections",
1510                         },
1511                         "Transform": {
1512                             "Get": "_dict_lookup",
1513                             "Put": "_dict_lookup",
1514                             "GetArgs": {
1515                                 "lookup": self.firewall_log_packets_connections,
1516                                 "value_lookup": False,
1517                             },
1518                             "PutArgs": {
1519                                 "lookup": self.firewall_log_packets_connections,
1520                                 "value_lookup": True,
1521                             },
1522                         },
1523                     },
1524                     "PasswordHistory": {
1525                         "Policy": "Enforce password history",
1526                         "lgpo_section": self.password_policy_gpedit_path,
1527                         "Settings": {
1528                             "Function": "_in_range_inclusive",
1529                             "Args": {"min": 0, "max": 24},
1530                         },
1531                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1532                     },
1533                     "MaxPasswordAge": {
1534                         "Policy": "Maximum password age",
1535                         "lgpo_section": self.password_policy_gpedit_path,
1536                         "Settings": {
1537                             "Function": "_in_range_inclusive",
1538                             "Args": {
1539                                 "min": 1,
1540                                 "max": 86313600,
1541                                 "zero_value": 0xFFFFFFFF,
1542                             },
1543                         },
1544                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1545                         "Transform": {
1546                             "Get": "_seconds_to_days",
1547                             "Put": "_days_to_seconds",
1548                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1549                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1550                         },
1551                     },
1552                     "MinPasswordAge": {
1553                         "Policy": "Minimum password age",
1554                         "lgpo_section": self.password_policy_gpedit_path,
1555                         "Settings": {
1556                             "Function": "_in_range_inclusive",
1557                             "Args": {"min": 0, "max": 86313600},
1558                         },
1559                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1560                         "Transform": {
1561                             "Get": "_seconds_to_days",
1562                             "Put": "_days_to_seconds",
1563                         },
1564                     },
1565                     "MinPasswordLen": {
1566                         "Policy": "Minimum password length",
1567                         "lgpo_section": self.password_policy_gpedit_path,
1568                         "Settings": {
1569                             "Function": "_in_range_inclusive",
1570                             "Args": {"min": 0, "max": 14},
1571                         },
1572                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1573                     },
1574                     "PasswordComplexity": {
1575                         "Policy": "Password must meet complexity requirements",
1576                         "lgpo_section": self.password_policy_gpedit_path,
1577                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1578                         "Secedit": {
1579                             "Option": "PasswordComplexity",
1580                             "Section": "System Access",
1581                         },
1582                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1583                     },
1584                     "ClearTextPasswords": {
1585                         "Policy": "Store passwords using reversible encryption",
1586                         "lgpo_section": self.password_policy_gpedit_path,
1587                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1588                         "Secedit": {
1589                             "Option": "ClearTextPassword",
1590                             "Section": "System Access",
1591                         },
1592                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1593                     },
1594                     "AdminAccountStatus": {
1595                         "Policy": "Accounts: Administrator account status",
1596                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1597                         "lgpo_section": self.security_options_gpedit_path,
1598                         "Secedit": {
1599                             "Option": "EnableAdminAccount",
1600                             "Section": "System Access",
1601                         },
1602                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1603                     },
1604                     "NoConnectedUser": {
1605                         "Policy": "Accounts: Block Microsoft accounts",
1606                         "Settings": self.block_ms_accounts.keys(),
1607                         "lgpo_section": self.security_options_gpedit_path,
1608                         "Registry": {
1609                             "Hive": "HKEY_LOCAL_MACHINE",
1610                             "Path": (
1611                                 "SOFTWARE\\Microsoft\\Windows\\"
1612                                 "CurrentVersion\\policies\\system"
1613                             ),
1614                             "Value": "NoConnectedUser",
1615                             "Type": "REG_DWORD",
1616                         },
1617                         "Transform": {
1618                             "Get": "_dict_lookup",
1619                             "Put": "_dict_lookup",
1620                             "GetArgs": {
1621                                 "lookup": self.block_ms_accounts,
1622                                 "value_lookup": False,
1623                             },
1624                             "PutArgs": {
1625                                 "lookup": self.block_ms_accounts,
1626                                 "value_lookup": True,
1627                             },
1628                         },
1629                     },
1630                     "GuestAccountStatus": {
1631                         "Policy": "Accounts: Guest account status",
1632                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1633                         "lgpo_section": self.security_options_gpedit_path,
1634                         "Secedit": {
1635                             "Option": "EnableGuestAccount",
1636                             "Section": "System Access",
1637                         },
1638                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1639                     },
1640                     "LimitBlankPasswordUse": {
1641                         "Policy": (
1642                             "Accounts: Limit local account use of blank "
1643                             "passwords to console logon only"
1644                         ),
1645                         "lgpo_section": self.security_options_gpedit_path,
1646                         "Settings": self.enabled_one_disabled_zero.keys(),
1647                         "Registry": {
1648                             "Hive": "HKEY_LOCAL_MACHINE",
1649                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1650                             "Value": "limitblankpassworduse",
1651                             "Type": "REG_DWORD",
1652                         },
1653                         "Transform": self.enabled_one_disabled_zero_transform,
1654                     },
1655                     "RenameAdministratorAccount": {
1656                         "Policy": "Accounts: Rename administrator account",
1657                         "Settings": None,
1658                         "lgpo_section": self.security_options_gpedit_path,
1659                         "Secedit": {
1660                             "Option": "NewAdministratorName",
1661                             "Section": "System Access",
1662                         },
1663                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1664                     },
1665                     "RenameGuestAccount": {
1666                         "Policy": "Accounts: Rename guest account",
1667                         "Settings": None,
1668                         "lgpo_section": self.security_options_gpedit_path,
1669                         "Secedit": {
1670                             "Option": "NewGuestName",
1671                             "Section": "System Access",
1672                         },
1673                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1674                     },
1675                     "AuditBaseObjects": {
1676                         "Policy": "Audit: Audit the access of global system objects",
1677                         "Settings": self.enabled_one_disabled_zero.keys(),
1678                         "lgpo_section": self.security_options_gpedit_path,
1679                         "Registry": {
1680                             "Hive": "HKEY_LOCAL_MACHINE",
1681                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1682                             "Value": "AuditBaseObjects",
1683                             "Type": "REG_DWORD",
1684                         },
1685                         "Transform": self.enabled_one_disabled_zero_transform,
1686                     },
1687                     "SceNoApplyLegacyAuditPolicy": {
1688                         "Policy": (
1689                             "Audit: Force audit policy subcategory "
1690                             "settings (Windows Vista or later) to "
1691                             "override audit policy category settings"
1692                         ),
1693                         "Settings": self.enabled_one_disabled_zero.keys(),
1694                         "lgpo_section": self.security_options_gpedit_path,
1695                         "Registry": {
1696                             "Hive": "HKEY_LOCAL_MACHINE",
1697                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1698                             "Value": "SCENoApplyLegacyAuditPolicy",
1699                             "Type": "REG_DWORD",
1700                         },
1701                         "Transform": self.enabled_one_disabled_zero_transform,
1702                     },
1703                     "DontDisplayLastUserName": {
1704                         "Policy": "Interactive logon: Do not display last user name",
1705                         "Settings": self.enabled_one_disabled_zero.keys(),
1706                         "lgpo_section": self.security_options_gpedit_path,
1707                         "Registry": {
1708                             "Hive": "HKEY_LOCAL_MACHINE",
1709                             "Path": (
1710                                 "Software\\Microsoft\\Windows\\"
1711                                 "CurrentVersion\\Policies\\System"
1712                             ),
1713                             "Value": "DontDisplayLastUserName",
1714                             "Type": "REG_DWORD",
1715                         },
1716                         "Transform": self.enabled_one_disabled_zero_transform,
1717                     },
1718                     "CachedLogonsCount": {
1719                         "Policy": (
1720                             "Interactive logon: Number of previous "
1721                             "logons to cache (in case domain controller "
1722                             "is not available)"
1723                         ),
1724                         "Settings": {
1725                             "Function": "_in_range_inclusive",
1726                             "Args": {"min": 0, "max": 50},
1727                         },
1728                         "lgpo_section": self.security_options_gpedit_path,
1729                         "Registry": {
1730                             "Hive": "HKEY_LOCAL_MACHINE",
1731                             "Path": (
1732                                 "Software\\Microsoft\\Windows NT\\"
1733                                 "CurrentVersion\\Winlogon"
1734                             ),
1735                             "Value": "CachedLogonsCount",
1736                             "Type": "REG_SZ",
1737                         },
1738                     },
1739                     "ForceUnlockLogon": {
1740                         "Policy": (
1741                             "Interactive logon: Require Domain "
1742                             "Controller authentication to unlock "
1743                             "workstation"
1744                         ),
1745                         "Settings": self.enabled_one_disabled_zero.keys(),
1746                         "lgpo_section": self.security_options_gpedit_path,
1747                         "Registry": {
1748                             "Hive": "HKEY_LOCAL_MACHINE",
1749                             "Path": (
1750                                 "Software\\Microsoft\\Windows NT\\"
1751                                 "CurrentVersion\\Winlogon"
1752                             ),
1753                             "Value": "ForceUnlockLogon",
1754                             "Type": "REG_DWORD",
1755                         },
1756                         "Transform": self.enabled_one_disabled_zero_transform,
1757                     },
1758                     "ScRemoveOption": {
1759                         "Policy": "Interactive logon: Smart card removal behavior",
1760                         "Settings": self.sc_removal_lookup.keys(),
1761                         "lgpo_section": self.security_options_gpedit_path,
1762                         "Registry": {
1763                             "Hive": "HKEY_LOCAL_MACHINE",
1764                             "Path": (
1765                                 "Software\\Microsoft\\Windows NT\\"
1766                                 "CurrentVersion\\Winlogon"
1767                             ),
1768                             "Value": "ScRemoveOption",
1769                             "Type": "REG_SZ",
1770                         },
1771                         "Transform": {
1772                             "Get": "_dict_lookup",
1773                             "Put": "_dict_lookup",
1774                             "GetArgs": {
1775                                 "lookup": self.sc_removal_lookup,
1776                                 "value_lookup": False,
1777                             },
1778                             "PutArgs": {
1779                                 "lookup": self.sc_removal_lookup,
1780                                 "value_lookup": True,
1781                             },
1782                         },
1783                     },
1784                     "DisableCAD": {
1785                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1786                         "Settings": self.enabled_one_disabled_zero.keys(),
1787                         "lgpo_section": self.security_options_gpedit_path,
1788                         "Registry": {
1789                             "Hive": "HKEY_LOCAL_MACHINE",
1790                             "Path": (
1791                                 "Software\\Microsoft\\Windows\\"
1792                                 "CurrentVersion\\Policies\\System"
1793                             ),
1794                             "Value": "DisableCAD",
1795                             "Type": "REG_DWORD",
1796                         },
1797                         "Transform": self.enabled_one_disabled_zero_transform,
1798                     },
1799                     "FilterAdministratorToken": {
1800                         "Policy": (
1801                             "User Account Control: Admin Approval Mode "
1802                             "for the built-in Administrator account"
1803                         ),
1804                         "Settings": self.enabled_one_disabled_zero.keys(),
1805                         "lgpo_section": self.security_options_gpedit_path,
1806                         "Registry": {
1807                             "Hive": "HKEY_LOCAL_MACHINE",
1808                             "Path": (
1809                                 "Software\\Microsoft\\Windows\\"
1810                                 "CurrentVersion\\Policies\\System"
1811                             ),
1812                             "Value": "FilterAdministratorToken",
1813                             "Type": "REG_DWORD",
1814                         },
1815                         "Transform": self.enabled_one_disabled_zero_transform,
1816                     },
1817                     "EnableUIADesktopToggle": {
1818                         "Policy": (
1819                             "User Account Control: Allow UIAccess "
1820                             "applications to prompt for elevation "
1821                             "without using the secure desktop"
1822                         ),
1823                         "Settings": self.enabled_one_disabled_zero.keys(),
1824                         "lgpo_section": self.security_options_gpedit_path,
1825                         "Registry": {
1826                             "Hive": "HKEY_LOCAL_MACHINE",
1827                             "Path": (
1828                                 "Software\\Microsoft\\Windows\\"
1829                                 "CurrentVersion\\Policies\\System"
1830                             ),
1831                             "Value": "EnableUIADesktopToggle",
1832                             "Type": "REG_DWORD",
1833                         },
1834                         "Transform": self.enabled_one_disabled_zero_transform,
1835                     },
1836                     "ConsentPromptBehaviorAdmin": {
1837                         "Policy": (
1838                             "User Account Control: Behavior of the "
1839                             "elevation prompt for administrators in "
1840                             "Admin Approval Mode"
1841                         ),
1842                         "Settings": self.uac_admin_prompt_lookup.keys(),
1843                         "lgpo_section": self.security_options_gpedit_path,
1844                         "Registry": {
1845                             "Hive": "HKEY_LOCAL_MACHINE",
1846                             "Path": (
1847                                 "Software\\Microsoft\\Windows\\"
1848                                 "CurrentVersion\\Policies\\System"
1849                             ),
1850                             "Value": "ConsentPromptBehaviorAdmin",
1851                             "Type": "REG_DWORD",
1852                         },
1853                         "Transform": {
1854                             "Get": "_dict_lookup",
1855                             "Put": "_dict_lookup",
1856                             "GetArgs": {
1857                                 "lookup": self.uac_admin_prompt_lookup,
1858                                 "value_lookup": False,
1859                             },
1860                             "PutArgs": {
1861                                 "lookup": self.uac_admin_prompt_lookup,
1862                                 "value_lookup": True,
1863                             },
1864                         },
1865                     },
1866                     "ConsentPromptBehaviorUser": {
1867                         "Policy": (
1868                             "User Account Control: Behavior of the "
1869                             "elevation prompt for standard users"
1870                         ),
1871                         "Settings": self.uac_user_prompt_lookup.keys(),
1872                         "lgpo_section": self.security_options_gpedit_path,
1873                         "Registry": {
1874                             "Hive": "HKEY_LOCAL_MACHINE",
1875                             "Path": (
1876                                 "Software\\Microsoft\\Windows\\"
1877                                 "CurrentVersion\\Policies\\System"
1878                             ),
1879                             "Value": "ConsentPromptBehaviorUser",
1880                             "Type": "REG_DWORD",
1881                         },
1882                         "Transform": {
1883                             "Get": "_dict_lookup",
1884                             "Put": "_dict_lookup",
1885                             "GetArgs": {
1886                                 "lookup": self.uac_user_prompt_lookup,
1887                                 "value_lookup": False,
1888                             },
1889                             "PutArgs": {
1890                                 "lookup": self.uac_user_prompt_lookup,
1891                                 "value_lookup": True,
1892                             },
1893                         },
1894                     },
1895                     "EnableInstallerDetection": {
1896                         "Policy": (
1897                             "User Account Control: Detect application "
1898                             "installations and prompt for elevation"
1899                         ),
1900                         "Settings": self.enabled_one_disabled_zero.keys(),
1901                         "lgpo_section": self.security_options_gpedit_path,
1902                         "Registry": {
1903                             "Hive": "HKEY_LOCAL_MACHINE",
1904                             "Path": (
1905                                 "Software\\Microsoft\\Windows\\"
1906                                 "CurrentVersion\\Policies\\System"
1907                             ),
1908                             "Value": "EnableInstallerDetection",
1909                             "Type": "REG_DWORD",
1910                         },
1911                         "Transform": self.enabled_one_disabled_zero_transform,
1912                     },
1913                     "ValidateAdminCodeSignatures": {
1914                         "Policy": (
1915                             "User Account Control: Only elevate "
1916                             "executables that are signed and validated"
1917                         ),
1918                         "Settings": self.enabled_one_disabled_zero.keys(),
1919                         "lgpo_section": self.security_options_gpedit_path,
1920                         "Registry": {
1921                             "Hive": "HKEY_LOCAL_MACHINE",
1922                             "Path": (
1923                                 "Software\\Microsoft\\Windows\\"
1924                                 "CurrentVersion\\Policies\\System"
1925                             ),
1926                             "Value": "ValidateAdminCodeSignatures",
1927                             "Type": "REG_DWORD",
1928                         },
1929                         "Transform": self.enabled_one_disabled_zero_transform,
1930                     },
1931                     "EnableSecureUIAPaths": {
1932                         "Policy": (
1933                             "User Account Control: Only elevate UIAccess "
1934                             "applications that are installed in secure "
1935                             "locations"
1936                         ),
1937                         "Settings": self.enabled_one_disabled_zero.keys(),
1938                         "lgpo_section": self.security_options_gpedit_path,
1939                         "Registry": {
1940                             "Hive": "HKEY_LOCAL_MACHINE",
1941                             "Path": (
1942                                 "Software\\Microsoft\\Windows\\"
1943                                 "CurrentVersion\\Policies\\System"
1944                             ),
1945                             "Value": "EnableSecureUIAPaths",
1946                             "Type": "REG_DWORD",
1947                         },
1948                         "Transform": self.enabled_one_disabled_zero_transform,
1949                     },
1950                     "EnableLUA": {
1951                         "Policy": (
1952                             "User Account Control: Run all "
1953                             "administrators in Admin Approval Mode"
1954                         ),
1955                         "Settings": self.enabled_one_disabled_zero.keys(),
1956                         "lgpo_section": self.security_options_gpedit_path,
1957                         "Registry": {
1958                             "Hive": "HKEY_LOCAL_MACHINE",
1959                             "Path": (
1960                                 "Software\\Microsoft\\Windows\\"
1961                                 "CurrentVersion\\Policies\\System"
1962                             ),
1963                             "Value": "EnableLUA",
1964                             "Type": "REG_DWORD",
1965                         },
1966                         "Transform": self.enabled_one_disabled_zero_transform,
1967                     },
1968                     "PromptOnSecureDesktop": {
1969                         "Policy": (
1970                             "User Account Control: Switch to the secure "
1971                             "desktop when prompting for elevation"
1972                         ),
1973                         "Settings": self.enabled_one_disabled_zero.keys(),
1974                         "lgpo_section": self.security_options_gpedit_path,
1975                         "Registry": {
1976                             "Hive": "HKEY_LOCAL_MACHINE",
1977                             "Path": (
1978                                 "Software\\Microsoft\\Windows\\"
1979                                 "CurrentVersion\\Policies\\System"
1980                             ),
1981                             "Value": "PromptOnSecureDesktop",
1982                             "Type": "REG_DWORD",
1983                         },
1984                         "Transform": self.enabled_one_disabled_zero_transform,
1985                     },
1986                     "EnableVirtualization": {
1987                         "Policy": (
1988                             "User Account Control: Virtualize file and "
1989                             "registry write failures to per-user "
1990                             "locations"
1991                         ),
1992                         "Settings": self.enabled_one_disabled_zero.keys(),
1993                         "lgpo_section": self.security_options_gpedit_path,
1994                         "Registry": {
1995                             "Hive": "HKEY_LOCAL_MACHINE",
1996                             "Path": (
1997                                 "Software\\Microsoft\\Windows\\"
1998                                 "CurrentVersion\\Policies\\System"
1999                             ),
2000                             "Value": "EnableVirtualization",
2001                             "Type": "REG_DWORD",
2002                         },
2003                         "Transform": self.enabled_one_disabled_zero_transform,
2004                     },
2005                     "PasswordExpiryWarning": {
2006                         "Policy": (
2007                             "Interactive logon: Prompt user to change "
2008                             "password before expiration"
2009                         ),
2010                         "Settings": {
2011                             "Function": "_in_range_inclusive",
2012                             "Args": {"min": 0, "max": 999},
2013                         },
2014                         "lgpo_section": self.security_options_gpedit_path,
2015                         "Registry": {
2016                             "Hive": "HKEY_LOCAL_MACHINE",
2017                             "Path": (
2018                                 "Software\\Microsoft\\Windows NT\\"
2019                                 "CurrentVersion\\Winlogon"
2020                             ),
2021                             "Value": "PasswordExpiryWarning",
2022                             "Type": "REG_DWORD",
2023                         },
2024                     },
2025                     "MaxDevicePasswordFailedAttempts": {
2026                         "Policy": (
2027                             "Interactive logon: Machine account lockout threshold"
2028                         ),
2029                         "Settings": {
2030                             "Function": "_in_range_inclusive",
2031                             "Args": {"min": 0, "max": 999},
2032                         },
2033                         "lgpo_section": self.security_options_gpedit_path,
2034                         "Registry": {
2035                             "Hive": "HKEY_LOCAL_MACHINE",
2036                             "Path": (
2037                                 "SOFTWARE\\Microsoft\\Windows\\"
2038                                 "CurrentVersion\\policies\\system"
2039                             ),
2040                             "Value": "MaxDevicePasswordFailedAttempts",
2041                             "Type": "REG_DWORD",
2042                         },
2043                     },
2044                     "InactivityTimeoutSecs": {
2045                         "Policy": "Interactive logon: Machine inactivity limit",
2046                         "Settings": {
2047                             "Function": "_in_range_inclusive",
2048                             "Args": {"min": 0, "max": 599940},
2049                         },
2050                         "lgpo_section": self.security_options_gpedit_path,
2051                         "Registry": {
2052                             "Hive": "HKEY_LOCAL_MACHINE",
2053                             "Path": (
2054                                 "SOFTWARE\\Microsoft\\Windows\\"
2055                                 "CurrentVersion\\policies\\system"
2056                             ),
2057                             "Value": "InactivityTimeoutSecs",
2058                             "Type": "REG_DWORD",
2059                         },
2060                     },
2061                     "legalnoticetext": {
2062                         "Policy": (
2063                             "Interactive logon: Message text for users "
2064                             "attempting to log on"
2065                         ),
2066                         "lgpo_section": self.security_options_gpedit_path,
2067                         "Registry": {
2068                             "Hive": "HKEY_LOCAL_MACHINE",
2069                             "Path": (
2070                                 "SOFTWARE\\Microsoft\\Windows\\"
2071                                 "CurrentVersion\\policies\\system"
2072                             ),
2073                             "Value": "legalnoticetext",
2074                             "Type": "REG_SZ",
2075                         },
2076                         "Transform": {"Put": "_string_put_transform"},
2077                     },
2078                     "legalnoticecaption": {
2079                         "Policy": (
2080                             "Interactive logon: Message title for users "
2081                             "attempting to log on"
2082                         ),
2083                         "lgpo_section": self.security_options_gpedit_path,
2084                         "Registry": {
2085                             "Hive": "HKEY_LOCAL_MACHINE",
2086                             "Path": (
2087                                 "SOFTWARE\\Microsoft\\Windows\\"
2088                                 "CurrentVersion\\policies\\system"
2089                             ),
2090                             "Value": "legalnoticecaption",
2091                             "Type": "REG_SZ",
2092                         },
2093                         "Transform": {"Put": "_string_put_transform"},
2094                     },
2095                     "DontDisplayLockedUserId": {
2096                         "Policy": (
2097                             "Interactive logon: Display user information "
2098                             "when the session is locked"
2099                         ),
2100                         "Settings": self.locked_session_user_info.keys(),
2101                         "lgpo_section": self.security_options_gpedit_path,
2102                         "Registry": {
2103                             "Hive": "HKEY_LOCAL_MACHINE",
2104                             "Path": (
2105                                 "SOFTWARE\\Microsoft\\Windows\\"
2106                                 "CurrentVersion\\policies\\system"
2107                             ),
2108                             "Value": "DontDisplayLockedUserId",
2109                             "Type": "REG_DWORD",
2110                         },
2111                         "Transform": {
2112                             "Get": "_dict_lookup",
2113                             "Put": "_dict_lookup",
2114                             "GetArgs": {
2115                                 "lookup": self.locked_session_user_info,
2116                                 "value_lookup": False,
2117                             },
2118                             "PutArgs": {
2119                                 "lookup": self.locked_session_user_info,
2120                                 "value_lookup": True,
2121                             },
2122                         },
2123                     },
2124                     "ScForceOption": {
2125                         "Policy": "Interactive logon: Require smart card",
2126                         "Settings": self.enabled_one_disabled_zero.keys(),
2127                         "lgpo_section": self.security_options_gpedit_path,
2128                         "Registry": {
2129                             "Hive": "HKEY_LOCAL_MACHINE",
2130                             "Path": (
2131                                 "Software\\Microsoft\\Windows\\"
2132                                 "CurrentVersion\\Policies\\System"
2133                             ),
2134                             "Value": "ScForceOption",
2135                             "Type": "REG_DWORD",
2136                         },
2137                         "Transform": self.enabled_one_disabled_zero_transform,
2138                     },
2139                     "Client_RequireSecuritySignature": {
2140                         "Policy": (
2141                             "Microsoft network client: Digitally sign "
2142                             "communications (always)"
2143                         ),
2144                         "Settings": self.enabled_one_disabled_zero.keys(),
2145                         "lgpo_section": self.security_options_gpedit_path,
2146                         "Registry": {
2147                             "Hive": "HKEY_LOCAL_MACHINE",
2148                             "Path": (
2149                                 "SYSTEM\\CurrentControlSet\\Services\\"
2150                                 "LanmanWorkstation\\Parameters"
2151                             ),
2152                             "Value": "RequireSecuritySignature",
2153                             "Type": "REG_DWORD",
2154                         },
2155                         "Transform": self.enabled_one_disabled_zero_transform,
2156                     },
2157                     "Client_EnableSecuritySignature": {
2158                         "Policy": (
2159                             "Microsoft network client: Digitally sign "
2160                             "communications (if server agrees)"
2161                         ),
2162                         "Settings": self.enabled_one_disabled_zero.keys(),
2163                         "lgpo_section": self.security_options_gpedit_path,
2164                         "Registry": {
2165                             "Hive": "HKEY_LOCAL_MACHINE",
2166                             "Path": (
2167                                 "SYSTEM\\CurrentControlSet\\Services\\"
2168                                 "LanmanWorkstation\\Parameters"
2169                             ),
2170                             "Value": "EnableSecuritySignature",
2171                             "Type": "REG_DWORD",
2172                         },
2173                         "Transform": self.enabled_one_disabled_zero_transform,
2174                     },
2175                     "EnablePlainTextPassword": {
2176                         "Policy": (
2177                             "Microsoft network client: Send unencrypted "
2178                             "password to third-party SMB servers"
2179                         ),
2180                         "Settings": self.enabled_one_disabled_zero.keys(),
2181                         "lgpo_section": self.security_options_gpedit_path,
2182                         "Registry": {
2183                             "Hive": "HKEY_LOCAL_MACHINE",
2184                             "Path": (
2185                                 "SYSTEM\\CurrentControlSet\\Services\\"
2186                                 "LanmanWorkstation\\Parameters"
2187                             ),
2188                             "Value": "EnablePlainTextPassword",
2189                             "Type": "REG_DWORD",
2190                         },
2191                         "Transform": self.enabled_one_disabled_zero_transform,
2192                     },
2193                     "AutoDisconnect": {
2194                         "Policy": (
2195                             "Microsoft network server: Amount of idle "
2196                             "time required before suspending session"
2197                         ),
2198                         "Settings": {
2199                             "Function": "_in_range_inclusive",
2200                             "Args": {"min": 0, "max": 99999},
2201                         },
2202                         "lgpo_section": self.security_options_gpedit_path,
2203                         "Registry": {
2204                             "Hive": "HKEY_LOCAL_MACHINE",
2205                             "Path": (
2206                                 "System\\CurrentControlSet\\Services\\"
2207                                 "LanmanServer\\Parameters"
2208                             ),
2209                             "Value": "AutoDisconnect",
2210                             "Type": "REG_DWORD",
2211                         },
2212                     },
2213                     "EnableS4U2SelfForClaims": {
2214                         "Policy": (
2215                             "Microsoft network server: Attempt S4U2Self "
2216                             "to obtain claim information"
2217                         ),
2218                         "Settings": self.s4u2self_options.keys(),
2219                         "lgpo_section": self.security_options_gpedit_path,
2220                         "Registry": {
2221                             "Hive": "HKEY_LOCAL_MACHINE",
2222                             "Path": (
2223                                 "System\\CurrentControlSet\\Services\\"
2224                                 "LanmanServer\\Parameters"
2225                             ),
2226                             "Value": "EnableS4U2SelfForClaims",
2227                             "Type": "REG_DWORD",
2228                         },
2229                         "Transform": {
2230                             "Get": "_dict_lookup",
2231                             "Put": "_dict_lookup",
2232                             "GetArgs": {
2233                                 "lookup": self.s4u2self_options,
2234                                 "value_lookup": False,
2235                             },
2236                             "PutArgs": {
2237                                 "lookup": self.s4u2self_options,
2238                                 "value_lookup": True,
2239                             },
2240                         },
2241                     },
2242                     "Server_RequireSecuritySignature": {
2243                         "Policy": (
2244                             "Microsoft network server: Digitally sign "
2245                             "communications (always)"
2246                         ),
2247                         "Settings": self.enabled_one_disabled_zero.keys(),
2248                         "lgpo_section": self.security_options_gpedit_path,
2249                         "Registry": {
2250                             "Hive": "HKEY_LOCAL_MACHINE",
2251                             "Path": (
2252                                 "SYSTEM\\CurrentControlSet\\Services\\"
2253                                 "LanmanServer\\Parameters"
2254                             ),
2255                             "Value": "RequireSecuritySignature",
2256                             "Type": "REG_DWORD",
2257                         },
2258                         "Transform": self.enabled_one_disabled_zero_transform,
2259                     },
2260                     "Server_EnableSecuritySignature": {
2261                         "Policy": (
2262                             "Microsoft network server: Digitally sign "
2263                             "communications (if client agrees)"
2264                         ),
2265                         "Settings": self.enabled_one_disabled_zero.keys(),
2266                         "lgpo_section": self.security_options_gpedit_path,
2267                         "Registry": {
2268                             "Hive": "HKEY_LOCAL_MACHINE",
2269                             "Path": (
2270                                 "SYSTEM\\CurrentControlSet\\Services\\"
2271                                 "LanmanServer\\Parameters"
2272                             ),
2273                             "Value": "EnableSecuritySignature",
2274                             "Type": "REG_DWORD",
2275                         },
2276                         "Transform": self.enabled_one_disabled_zero_transform,
2277                     },
2278                     "EnableForcedLogoff": {
2279                         "Policy": (
2280                             "Microsoft network server: Disconnect "
2281                             "clients when logon hours expire"
2282                         ),
2283                         "Settings": self.enabled_one_disabled_zero.keys(),
2284                         "lgpo_section": self.security_options_gpedit_path,
2285                         "Registry": {
2286                             "Hive": "HKEY_LOCAL_MACHINE",
2287                             "Path": (
2288                                 "SYSTEM\\CurrentControlSet\\Services\\"
2289                                 "LanmanServer\\Parameters"
2290                             ),
2291                             "Value": "EnableForcedLogoff",
2292                             "Type": "REG_DWORD",
2293                         },
2294                         "Transform": self.enabled_one_disabled_zero_transform,
2295                     },
2296                     "SmbServerNameHardeningLevel": {
2297                         "Policy": (
2298                             "Microsoft network server: Server SPN target "
2299                             "name validation level"
2300                         ),
2301                         "Settings": self.smb_server_name_hardening_levels.keys(),
2302                         "lgpo_section": self.security_options_gpedit_path,
2303                         "Registry": {
2304                             "Hive": "HKEY_LOCAL_MACHINE",
2305                             "Path": (
2306                                 "System\\CurrentControlSet\\Services\\"
2307                                 "LanmanServer\\Parameters"
2308                             ),
2309                             "Value": "SmbServerNameHardeningLevel",
2310                             "Type": "REG_DWORD",
2311                         },
2312                         "Transform": {
2313                             "Get": "_dict_lookup",
2314                             "Put": "_dict_lookup",
2315                             "GetArgs": {
2316                                 "lookup": self.smb_server_name_hardening_levels,
2317                                 "value_lookup": False,
2318                             },
2319                             "PutArgs": {
2320                                 "lookup": self.smb_server_name_hardening_levels,
2321                                 "value_lookup": True,
2322                             },
2323                         },
2324                     },
2325                     "FullPrivilegeAuditing": {
2326                         "Policy": (
2327                             "Audit: Audit the use of Backup and Restore privilege"
2328                         ),
2329                         "Settings": [chr(0), chr(1)],
2330                         "lgpo_section": self.security_options_gpedit_path,
2331                         "Registry": {
2332                             "Hive": "HKEY_LOCAL_MACHINE",
2333                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2334                             "Value": "FullPrivilegeAuditing",
2335                             "Type": "REG_BINARY",
2336                         },
2337                         "Transform": {
2338                             "Get": "_binary_enable_zero_disable_one_conversion",
2339                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2340                         },
2341                     },
2342                     "CrashOnAuditFail": {
2343                         "Policy": (
2344                             "Audit: Shut down system immediately if "
2345                             "unable to log security audits"
2346                         ),
2347                         "Settings": self.enabled_one_disabled_zero.keys(),
2348                         "lgpo_section": self.security_options_gpedit_path,
2349                         "Registry": {
2350                             "Hive": "HKEY_LOCAL_MACHINE",
2351                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2352                             "Value": "CrashOnAuditFail",
2353                             "Type": "REG_DWORD",
2354                         },
2355                         "Transform": self.enabled_one_disabled_zero_transform,
2356                     },
2357                     "UndockWithoutLogon": {
2358                         "Policy": "Devices: Allow undock without having to log on",
2359                         "Settings": self.enabled_one_disabled_zero.keys(),
2360                         "lgpo_section": self.security_options_gpedit_path,
2361                         "Registry": {
2362                             "Hive": "HKEY_LOCAL_MACHINE",
2363                             "Path": (
2364                                 "Software\\Microsoft\\Windows\\"
2365                                 "CurrentVersion\\Policies\\System"
2366                             ),
2367                             "Value": "UndockWithoutLogon",
2368                             "Type": "REG_DWORD",
2369                         },
2370                         "Transform": self.enabled_one_disabled_zero_transform,
2371                     },
2372                     "AddPrinterDrivers": {
2373                         "Policy": (
2374                             "Devices: Prevent users from installing printer drivers"
2375                         ),
2376                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2377                         "lgpo_section": self.security_options_gpedit_path,
2378                         "Registry": {
2379                             "Hive": "HKEY_LOCAL_MACHINE",
2380                             "Path": (
2381                                 "System\\CurrentControlSet\\Control\\"
2382                                 "Print\\Providers\\LanMan Print Services\\"
2383                                 "Servers"
2384                             ),
2385                             "Value": "AddPrinterDrivers",
2386                             "Type": "REG_DWORD",
2387                         },
2388                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2389                     },
2390                     "AllocateDASD": {
2391                         "Policy": (
2392                             "Devices: Allowed to format and eject removable media"
2393                         ),
2394                         "Settings": ["9999", "0", "1", "2"],
2395                         "lgpo_section": self.security_options_gpedit_path,
2396                         "Registry": {
2397                             "Hive": "HKEY_LOCAL_MACHINE",
2398                             "Path": (
2399                                 "Software\\Microsoft\\Windows NT\\"
2400                                 "CurrentVersion\\Winlogon"
2401                             ),
2402                             "Value": "AllocateDASD",
2403                             "Type": "REG_SZ",
2404                         },
2405                         "Transform": {
2406                             "Get": "_dasd_conversion",
2407                             "Put": "_dasd_reverse_conversion",
2408                         },
2409                     },
2410                     "AllocateCDRoms": {
2411                         "Policy": (
2412                             "Devices: Restrict CD-ROM access to locally "
2413                             "logged-on user only"
2414                         ),
2415                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2416                         "lgpo_section": self.security_options_gpedit_path,
2417                         "Registry": {
2418                             "Hive": "HKEY_LOCAL_MACHINE",
2419                             "Path": (
2420                                 "Software\\Microsoft\\Windows NT\\"
2421                                 "CurrentVersion\\Winlogon"
2422                             ),
2423                             "Value": "AllocateCDRoms",
2424                             "Type": "REG_SZ",
2425                         },
2426                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2427                     },
2428                     "AllocateFloppies": {
2429                         "Policy": (
2430                             "Devices: Restrict floppy access to locally "
2431                             "logged-on user only"
2432                         ),
2433                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2434                         "lgpo_section": self.security_options_gpedit_path,
2435                         "Registry": {
2436                             "Hive": "HKEY_LOCAL_MACHINE",
2437                             "Path": (
2438                                 "Software\\Microsoft\\Windows NT\\"
2439                                 "CurrentVersion\\Winlogon"
2440                             ),
2441                             "Value": "AllocateFloppies",
2442                             "Type": "REG_SZ",
2443                         },
2444                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2445                     },
2446                     "DriverSigningPolicy": {
2447                         "Policy": "Devices: Unsigned driver installation behavior",
2448                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2449                         "lgpo_section": self.security_options_gpedit_path,
2450                         "Secedit": {
2451                             "Option": (
2452                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2453                             ),
2454                             "Section": "Registry Values",
2455                         },
2456                         "Transform": {
2457                             "Get": "_driver_signing_reg_conversion",
2458                             "Put": "_driver_signing_reg_reverse_conversion",
2459                         },
2460                     },
2461                     "SubmitControl": {
2462                         "Policy": (
2463                             "Domain controller: Allow server operators "
2464                             "to schedule tasks"
2465                         ),
2466                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2467                         "lgpo_section": self.security_options_gpedit_path,
2468                         "Registry": {
2469                             "Hive": "HKEY_LOCAL_MACHINE",
2470                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2471                             "Value": "SubmitControl",
2472                             "Type": "REG_DWORD",
2473                         },
2474                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2475                     },
2476                     "LDAPServerIntegrity": {
2477                         "Policy": "Domain controller: LDAP server signing requirements",
2478                         "Settings": self.ldap_server_signing_requirements.keys(),
2479                         "lgpo_section": self.security_options_gpedit_path,
2480                         "Registry": {
2481                             "Hive": "HKEY_LOCAL_MACHINE",
2482                             "Path": (
2483                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2484                             ),
2485                             "Value": "LDAPServerIntegrity",
2486                             "Type": "REG_DWORD",
2487                         },
2488                         "Transform": {
2489                             "Get": "_dict_lookup",
2490                             "Put": "_dict_lookup",
2491                             "GetArgs": {
2492                                 "lookup": self.ldap_server_signing_requirements,
2493                                 "value_lookup": False,
2494                             },
2495                             "PutArgs": {
2496                                 "lookup": self.ldap_server_signing_requirements,
2497                                 "value_lookup": True,
2498                             },
2499                         },
2500                     },
2501                     "RefusePasswordChange": {
2502                         "Policy": (
2503                             "Domain controller: Refuse machine account password changes"
2504                         ),
2505                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2506                         "lgpo_section": self.security_options_gpedit_path,
2507                         "Registry": {
2508                             "Hive": "HKEY_LOCAL_MACHINE",
2509                             "Path": (
2510                                 "SYSTEM\\CurrentControlSet\\Services\\"
2511                                 "Netlogon\\Parameters"
2512                             ),
2513                             "Value": "RefusePasswordChange",
2514                             "Type": "REG_DWORD",
2515                         },
2516                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2517                     },
2518                     "RequireSignOrSeal": {
2519                         "Policy": (
2520                             "Domain member: Digitally encrypt or sign "
2521                             "secure channel data (always)"
2522                         ),
2523                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2524                         "lgpo_section": self.security_options_gpedit_path,
2525                         "Registry": {
2526                             "Hive": "HKEY_LOCAL_MACHINE",
2527                             "Path": (
2528                                 "System\\CurrentControlSet\\Services\\"
2529                                 "Netlogon\\Parameters"
2530                             ),
2531                             "Value": "RequireSignOrSeal",
2532                             "Type": "REG_DWORD",
2533                         },
2534                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2535                     },
2536                     "SealSecureChannel": {
2537                         "Policy": (
2538                             "Domain member: Digitally encrypt secure "
2539                             "channel data (when possible)"
2540                         ),
2541                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2542                         "lgpo_section": self.security_options_gpedit_path,
2543                         "Registry": {
2544                             "Hive": "HKEY_LOCAL_MACHINE",
2545                             "Path": (
2546                                 "System\\CurrentControlSet\\Services\\"
2547                                 "Netlogon\\Parameters"
2548                             ),
2549                             "Value": "SealSecureChannel",
2550                             "Type": "REG_DWORD",
2551                         },
2552                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2553                     },
2554                     "SignSecureChannel": {
2555                         "Policy": (
2556                             "Domain member: Digitally sign secure "
2557                             "channel data (when possible)"
2558                         ),
2559                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2560                         "lgpo_section": self.security_options_gpedit_path,
2561                         "Registry": {
2562                             "Hive": "HKEY_LOCAL_MACHINE",
2563                             "Path": (
2564                                 "System\\CurrentControlSet\\Services\\"
2565                                 "Netlogon\\Parameters"
2566                             ),
2567                             "Value": "SignSecureChannel",
2568                             "Type": "REG_DWORD",
2569                         },
2570                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2571                     },
2572                     "DisablePasswordChange": {
2573                         "Policy": (
2574                             "Domain member: Disable machine account password changes"
2575                         ),
2576                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2577                         "lgpo_section": self.security_options_gpedit_path,
2578                         "Registry": {
2579                             "Hive": "HKEY_LOCAL_MACHINE",
2580                             "Path": (
2581                                 "System\\CurrentControlSet\\Services\\"
2582                                 "Netlogon\\Parameters"
2583                             ),
2584                             "Value": "DisablePasswordChange",
2585                             "Type": "REG_DWORD",
2586                         },
2587                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2588                     },
2589                     "MaximumPasswordAge": {
2590                         "Policy": "Domain member: Maximum machine account password age",
2591                         "Settings": {
2592                             "Function": "_in_range_inclusive",
2593                             "Args": {"min": 0, "max": 999},
2594                         },
2595                         "lgpo_section": self.security_options_gpedit_path,
2596                         "Registry": {
2597                             "Hive": "HKEY_LOCAL_MACHINE",
2598                             "Path": (
2599                                 "System\\CurrentControlSet\\Services\\"
2600                                 "Netlogon\\Parameters"
2601                             ),
2602                             "Value": "MaximumPasswordAge",
2603                             "Type": "REG_DWORD",
2604                         },
2605                     },
2606                     "RequireStrongKey": {
2607                         "Policy": (
2608                             "Domain member: Require strong (Windows 2000 "
2609                             "or later) session key"
2610                         ),
2611                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2612                         "lgpo_section": self.security_options_gpedit_path,
2613                         "Registry": {
2614                             "Hive": "HKEY_LOCAL_MACHINE",
2615                             "Path": (
2616                                 "System\\CurrentControlSet\\Services\\"
2617                                 "Netlogon\\Parameters"
2618                             ),
2619                             "Value": "RequireStrongKey",
2620                             "Type": "REG_DWORD",
2621                         },
2622                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2623                     },
2624                     "LockoutDuration": {
2625                         "Policy": "Account lockout duration",
2626                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2627                         "Settings": {
2628                             "Function": "_in_range_inclusive",
2629                             "Args": {
2630                                 "min": 0,
2631                                 "max": 6000000,
2632                                 "zero_value": 0xFFFFFFFF,
2633                             },
2634                         },
2635                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2636                         "Transform": {
2637                             "Get": "_seconds_to_minutes",
2638                             "Put": "_minutes_to_seconds",
2639                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2640                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2641                         },
2642                     },
2643                     "LockoutThreshold": {
2644                         "Policy": "Account lockout threshold",
2645                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2646                         "Settings": {
2647                             "Function": "_in_range_inclusive",
2648                             "Args": {"min": 0, "max": 1000},
2649                         },
2650                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2651                     },
2652                     "LockoutWindow": {
2653                         "Policy": "Reset account lockout counter after",
2654                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2655                         "Settings": {
2656                             "Function": "_in_range_inclusive",
2657                             "Args": {"min": 0, "max": 6000000},
2658                         },
2659                         "NetUserModal": {
2660                             "Modal": 3,
2661                             "Option": "lockout_observation_window",
2662                         },
2663                         "Transform": {
2664                             "Get": "_seconds_to_minutes",
2665                             "Put": "_minutes_to_seconds",
2666                         },
2667                     },
2668                     "AuditAccountLogon": {
2669                         "Policy": "Audit account logon events",
2670                         "lgpo_section": self.audit_policy_gpedit_path,
2671                         "Settings": self.audit_lookup.keys(),
2672                         "Secedit": {
2673                             "Option": "AuditAccountLogon",
2674                             "Section": "Event Audit",
2675                         },
2676                         "Transform": self.audit_transform,
2677                     },
2678                     "AuditAccountManage": {
2679                         "Policy": "Audit account management",
2680                         "lgpo_section": self.audit_policy_gpedit_path,
2681                         "Settings": self.audit_lookup.keys(),
2682                         "Secedit": {
2683                             "Option": "AuditAccountManage",
2684                             "Section": "Event Audit",
2685                         },
2686                         "Transform": self.audit_transform,
2687                     },
2688                     "AuditDSAccess": {
2689                         "Policy": "Audit directory service access",
2690                         "lgpo_section": self.audit_policy_gpedit_path,
2691                         "Settings": self.audit_lookup.keys(),
2692                         "Secedit": {
2693                             "Option": "AuditDSAccess",
2694                             "Section": "Event Audit",
2695                         },
2696                         "Transform": self.audit_transform,
2697                     },
2698                     "AuditLogonEvents": {
2699                         "Policy": "Audit logon events",
2700                         "lgpo_section": self.audit_policy_gpedit_path,
2701                         "Settings": self.audit_lookup.keys(),
2702                         "Secedit": {
2703                             "Option": "AuditLogonEvents",
2704                             "Section": "Event Audit",
2705                         },
2706                         "Transform": self.audit_transform,
2707                     },
2708                     "AuditObjectAccess": {
2709                         "Policy": "Audit object access",
2710                         "lgpo_section": self.audit_policy_gpedit_path,
2711                         "Settings": self.audit_lookup.keys(),
2712                         "Secedit": {
2713                             "Option": "AuditObjectAccess",
2714                             "Section": "Event Audit",
2715                         },
2716                         "Transform": self.audit_transform,
2717                     },
2718                     "AuditPolicyChange": {
2719                         "Policy": "Audit policy change",
2720                         "lgpo_section": self.audit_policy_gpedit_path,
2721                         "Settings": self.audit_lookup.keys(),
2722                         "Secedit": {
2723                             "Option": "AuditPolicyChange",
2724                             "Section": "Event Audit",
2725                         },
2726                         "Transform": self.audit_transform,
2727                     },
2728                     "AuditPrivilegeUse": {
2729                         "Policy": "Audit privilege use",
2730                         "lgpo_section": self.audit_policy_gpedit_path,
2731                         "Settings": self.audit_lookup.keys(),
2732                         "Secedit": {
2733                             "Option": "AuditPrivilegeUse",
2734                             "Section": "Event Audit",
2735                         },
2736                         "Transform": self.audit_transform,
2737                     },
2738                     "AuditProcessTracking": {
2739                         "Policy": "Audit process tracking",
2740                         "lgpo_section": self.audit_policy_gpedit_path,
2741                         "Settings": self.audit_lookup.keys(),
2742                         "Secedit": {
2743                             "Option": "AuditProcessTracking",
2744                             "Section": "Event Audit",
2745                         },
2746                         "Transform": self.audit_transform,
2747                     },
2748                     "AuditSystemEvents": {
2749                         "Policy": "Audit system events",
2750                         "lgpo_section": self.audit_policy_gpedit_path,
2751                         "Settings": self.audit_lookup.keys(),
2752                         "Secedit": {
2753                             "Option": "AuditSystemEvents",
2754                             "Section": "Event Audit",
2755                         },
2756                         "Transform": self.audit_transform,
2757                     },
2758                     "AuditCredentialValidation": {
2759                         "Policy": "Audit Credential Validation",
2760                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2761                         "Settings": self.advanced_audit_lookup.keys(),
2762                         "AdvAudit": {"Option": "Audit Credential Validation"},
2763                         "Transform": self.advanced_audit_transform,
2764                     },
2765                     "AuditKerberosAuthenticationService": {
2766                         "Policy": "Audit Kerberos Authentication Service",
2767                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2768                         "Settings": self.advanced_audit_lookup.keys(),
2769                         "AdvAudit": {
2770                             "Option": "Audit Kerberos Authentication Service",
2771                         },
2772                         "Transform": self.advanced_audit_transform,
2773                     },
2774                     "AuditKerberosServiceTicketOperations": {
2775                         "Policy": "Audit Kerberos Service Ticket Operations",
2776                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2777                         "Settings": self.advanced_audit_lookup.keys(),
2778                         "AdvAudit": {
2779                             "Option": "Audit Kerberos Service Ticket Operations",
2780                         },
2781                         "Transform": self.advanced_audit_transform,
2782                     },
2783                     "AuditOtherAccountLogonEvents": {
2784                         "Policy": "Audit Other Account Logon Events",
2785                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2786                         "Settings": self.advanced_audit_lookup.keys(),
2787                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2788                         "Transform": self.advanced_audit_transform,
2789                     },
2790                     "AuditApplicationGroupManagement": {
2791                         "Policy": "Audit Application Group Management",
2792                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2793                         "Settings": self.advanced_audit_lookup.keys(),
2794                         "AdvAudit": {"Option": "Audit Application Group Management"},
2795                         "Transform": self.advanced_audit_transform,
2796                     },
2797                     "AuditComputerAccountManagement": {
2798                         "Policy": "Audit Computer Account Management",
2799                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2800                         "Settings": self.advanced_audit_lookup.keys(),
2801                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2802                         "Transform": self.advanced_audit_transform,
2803                     },
2804                     "AuditDistributionGroupManagement": {
2805                         "Policy": "Audit Distribution Group Management",
2806                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2807                         "Settings": self.advanced_audit_lookup.keys(),
2808                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2809                         "Transform": self.advanced_audit_transform,
2810                     },
2811                     "AuditOtherAccountManagementEvents": {
2812                         "Policy": "Audit Other Account Management Events",
2813                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2814                         "Settings": self.advanced_audit_lookup.keys(),
2815                         "AdvAudit": {
2816                             "Option": "Audit Other Account Management Events",
2817                         },
2818                         "Transform": self.advanced_audit_transform,
2819                     },
2820                     "AuditSecurityGroupManagement": {
2821                         "Policy": "Audit Security Group Management",
2822                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2823                         "Settings": self.advanced_audit_lookup.keys(),
2824                         "AdvAudit": {"Option": "Audit Security Group Management"},
2825                         "Transform": self.advanced_audit_transform,
2826                     },
2827                     "AuditUserAccountManagement": {
2828                         "Policy": "Audit User Account Management",
2829                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2830                         "Settings": self.advanced_audit_lookup.keys(),
2831                         "AdvAudit": {"Option": "Audit User Account Management"},
2832                         "Transform": self.advanced_audit_transform,
2833                     },
2834                     "AuditDPAPIActivity": {
2835                         "Policy": "Audit DPAPI Activity",
2836                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2837                         "Settings": self.advanced_audit_lookup.keys(),
2838                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2839                         "Transform": self.advanced_audit_transform,
2840                     },
2841                     "AuditPNPActivity": {
2842                         "Policy": "Audit PNP Activity",
2843                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2844                         "Settings": self.advanced_audit_lookup.keys(),
2845                         "AdvAudit": {"Option": "Audit PNP Activity"},
2846                         "Transform": self.advanced_audit_transform,
2847                     },
2848                     "AuditProcessCreation": {
2849                         "Policy": "Audit Process Creation",
2850                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2851                         "Settings": self.advanced_audit_lookup.keys(),
2852                         "AdvAudit": {"Option": "Audit Process Creation"},
2853                         "Transform": self.advanced_audit_transform,
2854                     },
2855                     "AuditProcessTermination": {
2856                         "Policy": "Audit Process Termination",
2857                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2858                         "Settings": self.advanced_audit_lookup.keys(),
2859                         "AdvAudit": {"Option": "Audit Process Termination"},
2860                         "Transform": self.advanced_audit_transform,
2861                     },
2862                     "AuditRPCEvents": {
2863                         "Policy": "Audit RPC Events",
2864                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2865                         "Settings": self.advanced_audit_lookup.keys(),
2866                         "AdvAudit": {"Option": "Audit RPC Events"},
2867                         "Transform": self.advanced_audit_transform,
2868                     },
2869                     "AuditTokenRightAdjusted": {
2870                         "Policy": "Audit Token Right Adjusted",
2871                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2872                         "Settings": self.advanced_audit_lookup.keys(),
2873                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2874                         "Transform": self.advanced_audit_transform,
2875                     },
2876                     "AuditDetailedDirectoryServiceReplication": {
2877                         "Policy": "Audit Detailed Directory Service Replication",
2878                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2879                         "Settings": self.advanced_audit_lookup.keys(),
2880                         "AdvAudit": {
2881                             "Option": "Audit Detailed Directory Service Replication",
2882                         },
2883                         "Transform": self.advanced_audit_transform,
2884                     },
2885                     "AuditDirectoryServiceAccess": {
2886                         "Policy": "Audit Directory Service Access",
2887                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2888                         "Settings": self.advanced_audit_lookup.keys(),
2889                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2890                         "Transform": self.advanced_audit_transform,
2891                     },
2892                     "AuditDirectoryServiceChanges": {
2893                         "Policy": "Audit Directory Service Changes",
2894                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2895                         "Settings": self.advanced_audit_lookup.keys(),
2896                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2897                         "Transform": self.advanced_audit_transform,
2898                     },
2899                     "AuditDirectoryServiceReplication": {
2900                         "Policy": "Audit Directory Service Replication",
2901                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2902                         "Settings": self.advanced_audit_lookup.keys(),
2903                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2904                         "Transform": self.advanced_audit_transform,
2905                     },
2906                     "AuditAccountLockout": {
2907                         "Policy": "Audit Account Lockout",
2908                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2909                         "Settings": self.advanced_audit_lookup.keys(),
2910                         "AdvAudit": {"Option": "Audit Account Lockout"},
2911                         "Transform": self.advanced_audit_transform,
2912                     },
2913                     "AuditUserDeviceClaims": {
2914                         "Policy": "Audit User / Device Claims",
2915                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2916                         "Settings": self.advanced_audit_lookup.keys(),
2917                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2918                         "Transform": self.advanced_audit_transform,
2919                     },
2920                     "AuditGroupMembership": {
2921                         "Policy": "Audit Group Membership",
2922                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2923                         "Settings": self.advanced_audit_lookup.keys(),
2924                         "AdvAudit": {"Option": "Audit Group Membership"},
2925                         "Transform": self.advanced_audit_transform,
2926                     },
2927                     "AuditIPsecExtendedMode": {
2928                         "Policy": "Audit IPsec Extended Mode",
2929                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2930                         "Settings": self.advanced_audit_lookup.keys(),
2931                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2932                         "Transform": self.advanced_audit_transform,
2933                     },
2934                     "AuditIPsecMainMode": {
2935                         "Policy": "Audit IPsec Main Mode",
2936                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2937                         "Settings": self.advanced_audit_lookup.keys(),
2938                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2939                         "Transform": self.advanced_audit_transform,
2940                     },
2941                     "AuditIPsecQuickMode": {
2942                         "Policy": "Audit IPsec Quick Mode",
2943                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2944                         "Settings": self.advanced_audit_lookup.keys(),
2945                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2946                         "Transform": self.advanced_audit_transform,
2947                     },
2948                     "AuditLogoff": {
2949                         "Policy": "Audit Logoff",
2950                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2951                         "Settings": self.advanced_audit_lookup.keys(),
2952                         "AdvAudit": {"Option": "Audit Logoff"},
2953                         "Transform": self.advanced_audit_transform,
2954                     },
2955                     "AuditLogon": {
2956                         "Policy": "Audit Logon",
2957                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2958                         "Settings": self.advanced_audit_lookup.keys(),
2959                         "AdvAudit": {"Option": "Audit Logon"},
2960                         "Transform": self.advanced_audit_transform,
2961                     },
2962                     "AuditNetworkPolicyServer": {
2963                         "Policy": "Audit Network Policy Server",
2964                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2965                         "Settings": self.advanced_audit_lookup.keys(),
2966                         "AdvAudit": {"Option": "Audit Network Policy Server"},
2967                         "Transform": self.advanced_audit_transform,
2968                     },
2969                     "AuditOtherLogonLogoffEvents": {
2970                         "Policy": "Audit Other Logon/Logoff Events",
2971                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2972                         "Settings": self.advanced_audit_lookup.keys(),
2973                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
2974                         "Transform": self.advanced_audit_transform,
2975                     },
2976                     "AuditSpecialLogon": {
2977                         "Policy": "Audit Special Logon",
2978                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2979                         "Settings": self.advanced_audit_lookup.keys(),
2980                         "AdvAudit": {"Option": "Audit Special Logon"},
2981                         "Transform": self.advanced_audit_transform,
2982                     },
2983                     "AuditApplicationGenerated": {
2984                         "Policy": "Audit Application Generated",
2985                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2986                         "Settings": self.advanced_audit_lookup.keys(),
2987                         "AdvAudit": {"Option": "Audit Application Generated"},
2988                         "Transform": self.advanced_audit_transform,
2989                     },
2990                     "AuditCertificationServices": {
2991                         "Policy": "Audit Certification Services",
2992                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2993                         "Settings": self.advanced_audit_lookup.keys(),
2994                         "AdvAudit": {"Option": "Audit Certification Services"},
2995                         "Transform": self.advanced_audit_transform,
2996                     },
2997                     "AuditDetailedFileShare": {
2998                         "Policy": "Audit Detailed File Share",
2999                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3000                         "Settings": self.advanced_audit_lookup.keys(),
3001                         "AdvAudit": {"Option": "Audit Detailed File Share"},
3002                         "Transform": self.advanced_audit_transform,
3003                     },
3004                     "AuditFileShare": {
3005                         "Policy": "Audit File Share",
3006                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3007                         "Settings": self.advanced_audit_lookup.keys(),
3008                         "AdvAudit": {"Option": "Audit File Share"},
3009                         "Transform": self.advanced_audit_transform,
3010                     },
3011                     "AuditFileSystem": {
3012                         "Policy": "Audit File System",
3013                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3014                         "Settings": self.advanced_audit_lookup.keys(),
3015                         "AdvAudit": {"Option": "Audit File System"},
3016                         "Transform": self.advanced_audit_transform,
3017                     },
3018                     "AuditFilteringPlatformConnection": {
3019                         "Policy": "Audit Filtering Platform Connection",
3020                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3021                         "Settings": self.advanced_audit_lookup.keys(),
3022                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
3023                         "Transform": self.advanced_audit_transform,
3024                     },
3025                     "AuditFilteringPlatformPacketDrop": {
3026                         "Policy": "Audit Filtering Platform Packet Drop",
3027                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3028                         "Settings": self.advanced_audit_lookup.keys(),
3029                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
3030                         "Transform": self.advanced_audit_transform,
3031                     },
3032                     "AuditHandleManipulation": {
3033                         "Policy": "Audit Handle Manipulation",
3034                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3035                         "Settings": self.advanced_audit_lookup.keys(),
3036                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
3037                         "Transform": self.advanced_audit_transform,
3038                     },
3039                     "AuditKernelObject": {
3040                         "Policy": "Audit Kernel Object",
3041                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3042                         "Settings": self.advanced_audit_lookup.keys(),
3043                         "AdvAudit": {"Option": "Audit Kernel Object"},
3044                         "Transform": self.advanced_audit_transform,
3045                     },
3046                     "AuditOtherObjectAccessEvents": {
3047                         "Policy": "Audit Other Object Access Events",
3048                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3049                         "Settings": self.advanced_audit_lookup.keys(),
3050                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
3051                         "Transform": self.advanced_audit_transform,
3052                     },
3053                     "AuditRegistry": {
3054                         "Policy": "Audit Registry",
3055                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3056                         "Settings": self.advanced_audit_lookup.keys(),
3057                         "AdvAudit": {"Option": "Audit Registry"},
3058                         "Transform": self.advanced_audit_transform,
3059                     },
3060                     "AuditRemovableStorage": {
3061                         "Policy": "Audit Removable Storage",
3062                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3063                         "Settings": self.advanced_audit_lookup.keys(),
3064                         "AdvAudit": {"Option": "Audit Removable Storage"},
3065                         "Transform": self.advanced_audit_transform,
3066                     },
3067                     "AuditSAM": {
3068                         "Policy": "Audit SAM",
3069                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3070                         "Settings": self.advanced_audit_lookup.keys(),
3071                         "AdvAudit": {"Option": "Audit SAM"},
3072                         "Transform": self.advanced_audit_transform,
3073                     },
3074                     "AuditCentralAccessPolicyStaging": {
3075                         "Policy": "Audit Central Access Policy Staging",
3076                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3077                         "Settings": self.advanced_audit_lookup.keys(),
3078                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
3079                         "Transform": self.advanced_audit_transform,
3080                     },
3081                     "AuditAuditPolicyChange": {
3082                         "Policy": "Audit Audit Policy Change",
3083                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3084                         "Settings": self.advanced_audit_lookup.keys(),
3085                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3086                         "Transform": self.advanced_audit_transform,
3087                     },
3088                     "AuditAuthenticationPolicyChange": {
3089                         "Policy": "Audit Authentication Policy Change",
3090                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3091                         "Settings": self.advanced_audit_lookup.keys(),
3092                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3093                         "Transform": self.advanced_audit_transform,
3094                     },
3095                     "AuditAuthorizationPolicyChange": {
3096                         "Policy": "Audit Authorization Policy Change",
3097                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3098                         "Settings": self.advanced_audit_lookup.keys(),
3099                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3100                         "Transform": self.advanced_audit_transform,
3101                     },
3102                     "AuditFilteringPlatformPolicyChange": {
3103                         "Policy": "Audit Filtering Platform Policy Change",
3104                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3105                         "Settings": self.advanced_audit_lookup.keys(),
3106                         "AdvAudit": {
3107                             "Option": "Audit Filtering Platform Policy Change",
3108                         },
3109                         "Transform": self.advanced_audit_transform,
3110                     },
3111                     "AuditMPSSVCRuleLevelPolicyChange": {
3112                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3113                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3114                         "Settings": self.advanced_audit_lookup.keys(),
3115                         "AdvAudit": {
3116                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3117                         },
3118                         "Transform": self.advanced_audit_transform,
3119                     },
3120                     "AuditOtherPolicyChangeEvents": {
3121                         "Policy": "Audit Other Policy Change Events",
3122                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3123                         "Settings": self.advanced_audit_lookup.keys(),
3124                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3125                         "Transform": self.advanced_audit_transform,
3126                     },
3127                     "AuditNonSensitivePrivilegeUse": {
3128                         "Policy": "Audit Non Sensitive Privilege Use",
3129                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3130                         "Settings": self.advanced_audit_lookup.keys(),
3131                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3132                         "Transform": self.advanced_audit_transform,
3133                     },
3134                     "AuditOtherPrivilegeUseEvents": {
3135                         "Policy": "Audit Other Privilege Use Events",
3136                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3137                         "Settings": self.advanced_audit_lookup.keys(),
3138                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3139                         "Transform": self.advanced_audit_transform,
3140                     },
3141                     "AuditSensitivePrivilegeUse": {
3142                         "Policy": "Audit Sensitive Privilege Use",
3143                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3144                         "Settings": self.advanced_audit_lookup.keys(),
3145                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3146                         "Transform": self.advanced_audit_transform,
3147                     },
3148                     "AuditIPsecDriver": {
3149                         "Policy": "Audit IPsec Driver",
3150                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3151                         "Settings": self.advanced_audit_lookup.keys(),
3152                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3153                         "Transform": self.advanced_audit_transform,
3154                     },
3155                     "AuditOtherSystemEvents": {
3156                         "Policy": "Audit Other System Events",
3157                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3158                         "Settings": self.advanced_audit_lookup.keys(),
3159                         "AdvAudit": {"Option": "Audit Other System Events"},
3160                         "Transform": self.advanced_audit_transform,
3161                     },
3162                     "AuditSecurityStateChange": {
3163                         "Policy": "Audit Security State Change",
3164                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3165                         "Settings": self.advanced_audit_lookup.keys(),
3166                         "AdvAudit": {"Option": "Audit Security State Change"},
3167                         "Transform": self.advanced_audit_transform,
3168                     },
3169                     "AuditSecuritySystemExtension": {
3170                         "Policy": "Audit Security System Extension",
3171                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3172                         "Settings": self.advanced_audit_lookup.keys(),
3173                         "AdvAudit": {"Option": "Audit Security System Extension"},
3174                         "Transform": self.advanced_audit_transform,
3175                     },
3176                     "AuditSystemIntegrity": {
3177                         "Policy": "Audit System Integrity",
3178                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3179                         "Settings": self.advanced_audit_lookup.keys(),
3180                         "AdvAudit": {"Option": "Audit System Integrity"},
3181                         "Transform": self.advanced_audit_transform,
3182                     },
3183                     "SeTrustedCredManAccessPrivilege": {
3184                         "Policy": "Access Credential Manager as a trusted caller",
3185                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3186                         "rights_assignment": True,
3187                         "Settings": None,
3188                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3189                         "Transform": {
3190                             "Get": "_sidConversion",
3191                             "Put": "_usernamesToSidObjects",
3192                         },
3193                     },
3194                     "SeNetworkLogonRight": {
3195                         "Policy": "Access this computer from the network",
3196                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3197                         "rights_assignment": True,
3198                         "Settings": None,
3199                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3200                         "Transform": {
3201                             "Get": "_sidConversion",
3202                             "Put": "_usernamesToSidObjects",
3203                         },
3204                     },
3205                     "SeTcbPrivilege": {
3206                         "Policy": "Act as part of the operating system",
3207                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3208                         "rights_assignment": True,
3209                         "Settings": None,
3210                         "LsaRights": {"Option": "SeTcbPrivilege"},
3211                         "Transform": {
3212                             "Get": "_sidConversion",
3213                             "Put": "_usernamesToSidObjects",
3214                         },
3215                     },
3216                     "SeMachineAccountPrivilege": {
3217                         "Policy": "Add workstations to domain",
3218                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3219                         "rights_assignment": True,
3220                         "Settings": None,
3221                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3222                         "Transform": {
3223                             "Get": "_sidConversion",
3224                             "Put": "_usernamesToSidObjects",
3225                         },
3226                     },
3227                     "SeIncreaseQuotaPrivilege": {
3228                         "Policy": "Adjust memory quotas for a process",
3229                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3230                         "rights_assignment": True,
3231                         "Settings": None,
3232                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3233                         "Transform": {
3234                             "Get": "_sidConversion",
3235                             "Put": "_usernamesToSidObjects",
3236                         },
3237                     },
3238                     "SeInteractiveLogonRight": {
3239                         "Policy": "Allow log on locally",
3240                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3241                         "rights_assignment": True,
3242                         "Settings": None,
3243                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3244                         "Transform": {
3245                             "Get": "_sidConversion",
3246                             "Put": "_usernamesToSidObjects",
3247                         },
3248                     },
3249                     "SeRemoteInteractiveLogonRight": {
3250                         "Policy": "Allow log on through Remote Desktop Services",
3251                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3252                         "rights_assignment": True,
3253                         "Settings": None,
3254                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3255                         "Transform": {
3256                             "Get": "_sidConversion",
3257                             "Put": "_usernamesToSidObjects",
3258                         },
3259                     },
3260                     "SeBackupPrivilege": {
3261                         "Policy": "Backup files and directories",
3262                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3263                         "rights_assignment": True,
3264                         "Settings": None,
3265                         "LsaRights": {"Option": "SeBackupPrivilege"},
3266                         "Transform": {
3267                             "Get": "_sidConversion",
3268                             "Put": "_usernamesToSidObjects",
3269                         },
3270                     },
3271                     "SeChangeNotifyPrivilege": {
3272                         "Policy": "Bypass traverse checking",
3273                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3274                         "rights_assignment": True,
3275                         "Settings": None,
3276                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3277                         "Transform": {
3278                             "Get": "_sidConversion",
3279                             "Put": "_usernamesToSidObjects",
3280                         },
3281                     },
3282                     "SeSystemtimePrivilege": {
3283                         "Policy": "Change the system time",
3284                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3285                         "rights_assignment": True,
3286                         "Settings": None,
3287                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3288                         "Transform": {
3289                             "Get": "_sidConversion",
3290                             "Put": "_usernamesToSidObjects",
3291                         },
3292                     },
3293                     "SeTimeZonePrivilege": {
3294                         "Policy": "Change the time zone",
3295                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3296                         "rights_assignment": True,
3297                         "Settings": None,
3298                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3299                         "Transform": {
3300                             "Get": "_sidConversion",
3301                             "Put": "_usernamesToSidObjects",
3302                         },
3303                     },
3304                     "SeCreatePagefilePrivilege": {
3305                         "Policy": "Create a pagefile",
3306                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3307                         "rights_assignment": True,
3308                         "Settings": None,
3309                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3310                         "Transform": {
3311                             "Get": "_sidConversion",
3312                             "Put": "_usernamesToSidObjects",
3313                         },
3314                     },
3315                     "SeCreateTokenPrivilege": {
3316                         "Policy": "Create a token object",
3317                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3318                         "rights_assignment": True,
3319                         "Settings": None,
3320                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3321                         "Transform": {
3322                             "Get": "_sidConversion",
3323                             "Put": "_usernamesToSidObjects",
3324                         },
3325                     },
3326                     "SeCreateGlobalPrivilege": {
3327                         "Policy": "Create global objects",
3328                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3329                         "rights_assignment": True,
3330                         "Settings": None,
3331                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3332                         "Transform": {
3333                             "Get": "_sidConversion",
3334                             "Put": "_usernamesToSidObjects",
3335                         },
3336                     },
3337                     "SeCreatePermanentPrivilege": {
3338                         "Policy": "Create permanent shared objects",
3339                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3340                         "rights_assignment": True,
3341                         "Settings": None,
3342                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3343                         "Transform": {
3344                             "Get": "_sidConversion",
3345                             "Put": "_usernamesToSidObjects",
3346                         },
3347                     },
3348                     "SeCreateSymbolicLinkPrivilege": {
3349                         "Policy": "Create symbolic links",
3350                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3351                         "rights_assignment": True,
3352                         "Settings": None,
3353                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3354                         "Transform": {
3355                             "Get": "_sidConversion",
3356                             "Put": "_usernamesToSidObjects",
3357                         },
3358                     },
3359                     "SeDebugPrivilege": {
3360                         "Policy": "Debug programs",
3361                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3362                         "rights_assignment": True,
3363                         "Settings": None,
3364                         "LsaRights": {"Option": "SeDebugPrivilege"},
3365                         "Transform": {
3366                             "Get": "_sidConversion",
3367                             "Put": "_usernamesToSidObjects",
3368                         },
3369                     },
3370                     "SeDenyNetworkLogonRight": {
3371                         "Policy": "Deny access to this computer from the network",
3372                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3373                         "rights_assignment": True,
3374                         "Settings": None,
3375                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3376                         "Transform": {
3377                             "Get": "_sidConversion",
3378                             "Put": "_usernamesToSidObjects",
3379                         },
3380                     },
3381                     "SeDenyBatchLogonRight": {
3382                         "Policy": "Deny log on as a batch job",
3383                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3384                         "rights_assignment": True,
3385                         "Settings": None,
3386                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3387                         "Transform": {
3388                             "Get": "_sidConversion",
3389                             "Put": "_usernamesToSidObjects",
3390                         },
3391                     },
3392                     "SeDenyServiceLogonRight": {
3393                         "Policy": "Deny log on as a service",
3394                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3395                         "rights_assignment": True,
3396                         "Settings": None,
3397                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3398                         "Transform": {
3399                             "Get": "_sidConversion",
3400                             "Put": "_usernamesToSidObjects",
3401                         },
3402                     },
3403                     "SeDenyInteractiveLogonRight": {
3404                         "Policy": "Deny log on locally",
3405                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3406                         "rights_assignment": True,
3407                         "Settings": None,
3408                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3409                         "Transform": {
3410                             "Get": "_sidConversion",
3411                             "Put": "_usernamesToSidObjects",
3412                         },
3413                     },
3414                     "SeDenyRemoteInteractiveLogonRight": {
3415                         "Policy": "Deny log on through Remote Desktop Services",
3416                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3417                         "rights_assignment": True,
3418                         "Settings": None,
3419                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3420                         "Transform": {
3421                             "Get": "_sidConversion",
3422                             "Put": "_usernamesToSidObjects",
3423                         },
3424                     },
3425                     "SeEnableDelegationPrivilege": {
3426                         "Policy": (
3427                             "Enable computer and user accounts to be "
3428                             "trusted for delegation"
3429                         ),
3430                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3431                         "rights_assignment": True,
3432                         "Settings": None,
3433                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3434                         "Transform": {
3435                             "Get": "_sidConversion",
3436                             "Put": "_usernamesToSidObjects",
3437                         },
3438                     },
3439                     "SeRemoteShutdownPrivilege": {
3440                         "Policy": "Force shutdown from a remote system",
3441                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3442                         "rights_assignment": True,
3443                         "Settings": None,
3444                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3445                         "Transform": {
3446                             "Get": "_sidConversion",
3447                             "Put": "_usernamesToSidObjects",
3448                         },
3449                     },
3450                     "SeAuditPrivilege": {
3451                         "Policy": "Generate security audits",
3452                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3453                         "rights_assignment": True,
3454                         "Settings": None,
3455                         "LsaRights": {"Option": "SeAuditPrivilege"},
3456                         "Transform": {
3457                             "Get": "_sidConversion",
3458                             "Put": "_usernamesToSidObjects",
3459                         },
3460                     },
3461                     "SeImpersonatePrivilege": {
3462                         "Policy": "Impersonate a client after authentication",
3463                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3464                         "rights_assignment": True,
3465                         "Settings": None,
3466                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3467                         "Transform": {
3468                             "Get": "_sidConversion",
3469                             "Put": "_usernamesToSidObjects",
3470                         },
3471                     },
3472                     "SeIncreaseWorkingSetPrivilege": {
3473                         "Policy": "Increase a process working set",
3474                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3475                         "rights_assignment": True,
3476                         "Settings": None,
3477                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3478                         "Transform": {
3479                             "Get": "_sidConversion",
3480                             "Put": "_usernamesToSidObjects",
3481                         },
3482                     },
3483                     "SeIncreaseBasePriorityPrivilege": {
3484                         "Policy": "Increase scheduling priority",
3485                         "rights_assignment": True,
3486                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3487                         "Settings": None,
3488                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3489                         "Transform": {
3490                             "Get": "_sidConversion",
3491                             "Put": "_usernamesToSidObjects",
3492                         },
3493                     },
3494                     "SeLoadDriverPrivilege": {
3495                         "Policy": "Load and unload device drivers",
3496                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3497                         "rights_assignment": True,
3498                         "Settings": None,
3499                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3500                         "Transform": {
3501                             "Get": "_sidConversion",
3502                             "Put": "_usernamesToSidObjects",
3503                         },
3504                     },
3505                     "SeLockMemoryPrivilege": {
3506                         "Policy": "Lock pages in memory",
3507                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3508                         "rights_assignment": True,
3509                         "Settings": None,
3510                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3511                         "Transform": {
3512                             "Get": "_sidConversion",
3513                             "Put": "_usernamesToSidObjects",
3514                         },
3515                     },
3516                     "SeBatchLogonRight": {
3517                         "Policy": "Log on as a batch job",
3518                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3519                         "rights_assignment": True,
3520                         "Settings": None,
3521                         "LsaRights": {"Option": "SeBatchLogonRight"},
3522                         "Transform": {
3523                             "Get": "_sidConversion",
3524                             "Put": "_usernamesToSidObjects",
3525                         },
3526                     },
3527                     "SeServiceLogonRight": {
3528                         "Policy": "Log on as a service",
3529                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3530                         "rights_assignment": True,
3531                         "Settings": None,
3532                         "LsaRights": {"Option": "SeServiceLogonRight"},
3533                         "Transform": {
3534                             "Get": "_sidConversion",
3535                             "Put": "_usernamesToSidObjects",
3536                         },
3537                     },
3538                     "SeSecurityPrivilege": {
3539                         "Policy": "Manage auditing and security log",
3540                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3541                         "rights_assignment": True,
3542                         "Settings": None,
3543                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3544                         "Transform": {
3545                             "Get": "_sidConversion",
3546                             "Put": "_usernamesToSidObjects",
3547                         },
3548                     },
3549                     "SeRelabelPrivilege": {
3550                         "Policy": "Modify an object label",
3551                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3552                         "rights_assignment": True,
3553                         "Settings": None,
3554                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3555                         "Transform": {
3556                             "Get": "_sidConversion",
3557                             "Put": "_usernamesToSidObjects",
3558                         },
3559                     },
3560                     "SeSystemEnvironmentPrivilege": {
3561                         "Policy": "Modify firmware environment values",
3562                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3563                         "rights_assignment": True,
3564                         "Settings": None,
3565                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3566                         "Transform": {
3567                             "Get": "_sidConversion",
3568                             "Put": "_usernamesToSidObjects",
3569                         },
3570                     },
3571                     "SeManageVolumePrivilege": {
3572                         "Policy": "Perform volume maintenance tasks",
3573                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3574                         "rights_assignment": True,
3575                         "Settings": None,
3576                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3577                         "Transform": {
3578                             "Get": "_sidConversion",
3579                             "Put": "_usernamesToSidObjects",
3580                         },
3581                     },
3582                     "SeProfileSingleProcessPrivilege": {
3583                         "Policy": "Profile single process",
3584                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3585                         "rights_assignment": True,
3586                         "Settings": None,
3587                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3588                         "Transform": {
3589                             "Get": "_sidConversion",
3590                             "Put": "_usernamesToSidObjects",
3591                         },
3592                     },
3593                     "SeSystemProfilePrivilege": {
3594                         "Policy": "Profile system performance",
3595                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3596                         "rights_assignment": True,
3597                         "Settings": None,
3598                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3599                         "Transform": {
3600                             "Get": "_sidConversion",
3601                             "Put": "_usernamesToSidObjects",
3602                         },
3603                     },
3604                     "SeUndockPrivilege": {
3605                         "Policy": "Remove computer from docking station",
3606                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3607                         "rights_assignment": True,
3608                         "Settings": None,
3609                         "LsaRights": {"Option": "SeUndockPrivilege"},
3610                         "Transform": {
3611                             "Get": "_sidConversion",
3612                             "Put": "_usernamesToSidObjects",
3613                         },
3614                     },
3615                     "SeAssignPrimaryTokenPrivilege": {
3616                         "Policy": "Replace a process level token",
3617                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3618                         "rights_assignment": True,
3619                         "Settings": None,
3620                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3621                         "Transform": {
3622                             "Get": "_sidConversion",
3623                             "Put": "_usernamesToSidObjects",
3624                         },
3625                     },
3626                     "SeRestorePrivilege": {
3627                         "Policy": "Restore files and directories",
3628                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3629                         "rights_assignment": True,
3630                         "Settings": None,
3631                         "LsaRights": {"Option": "SeRestorePrivilege"},
3632                         "Transform": {
3633                             "Get": "_sidConversion",
3634                             "Put": "_usernamesToSidObjects",
3635                         },
3636                     },
3637                     "SeShutdownPrivilege": {
3638                         "Policy": "Shut down the system",
3639                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3640                         "rights_assignment": True,
3641                         "Settings": None,
3642                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3643                         "Transform": {
3644                             "Get": "_sidConversion",
3645                             "Put": "_usernamesToSidObjects",
3646                         },
3647                     },
3648                     "SeSyncAgentPrivilege": {
3649                         "Policy": "Synchronize directory service data",
3650                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3651                         "rights_assignment": True,
3652                         "Settings": None,
3653                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3654                         "Transform": {
3655                             "Get": "_sidConversion",
3656                             "Put": "_usernamesToSidObjects",
3657                         },
3658                     },
3659                     "SeTakeOwnershipPrivilege": {
3660                         "Policy": "Take ownership of files or other objects",
3661                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3662                         "rights_assignment": True,
3663                         "Settings": None,
3664                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3665                         "Transform": {
3666                             "Get": "_sidConversion",
3667                             "Put": "_usernamesToSidObjects",
3668                         },
3669                     },
3670                     "RecoveryConsoleSecurityLevel": {
3671                         "Policy": (
3672                             "Recovery console: Allow automatic administrative logon"
3673                         ),
3674                         "Settings": self.enabled_one_disabled_zero.keys(),
3675                         "lgpo_section": self.security_options_gpedit_path,
3676                         "Registry": {
3677                             "Hive": "HKEY_LOCAL_MACHINE",
3678                             "Path": (
3679                                 "Software\\Microsoft\\Windows NT\\"
3680                                 "CurrentVersion\\Setup\\RecoveryConsole"
3681                             ),
3682                             "Value": "SecurityLevel",
3683                             "Type": "REG_DWORD",
3684                         },
3685                         "Transform": self.enabled_one_disabled_zero_transform,
3686                     },
3687                     "RecoveryConsoleSetCommand": {
3688                         "Policy": (
3689                             "Recovery console: Allow floppy copy and "
3690                             "access to all drives and all folders"
3691                         ),
3692                         "Settings": self.enabled_one_disabled_zero.keys(),
3693                         "lgpo_section": self.security_options_gpedit_path,
3694                         "Registry": {
3695                             "Hive": "HKEY_LOCAL_MACHINE",
3696                             "Path": (
3697                                 "Software\\Microsoft\\Windows NT\\"
3698                                 "CurrentVersion\\Setup\\RecoveryConsole"
3699                             ),
3700                             "Value": "SetCommand",
3701                             "Type": "REG_DWORD",
3702                         },
3703                         "Transform": self.enabled_one_disabled_zero_transform,
3704                     },
3705                     "ForceKeyProtection": {
3706                         "Policy": (
3707                             "System Cryptography: Force strong key protection for "
3708                             "user keys stored on the computer"
3709                         ),
3710                         "Settings": self.force_key_protection.keys(),
3711                         "lgpo_section": self.security_options_gpedit_path,
3712                         "Registry": {
3713                             "Hive": "HKEY_LOCAL_MACHINE",
3714                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3715                             "Value": "ForceKeyProtection",
3716                             "Type": "REG_DWORD",
3717                         },
3718                         "Transform": {
3719                             "Get": "_dict_lookup",
3720                             "Put": "_dict_lookup",
3721                             "GetArgs": {
3722                                 "lookup": self.force_key_protection,
3723                                 "value_lookup": False,
3724                             },
3725                             "PutArgs": {
3726                                 "lookup": self.force_key_protection,
3727                                 "value_lookup": True,
3728                             },
3729                         },
3730                     },
3731                     "FIPSAlgorithmPolicy": {
3732                         "Policy": (
3733                             "System Cryptography: Use FIPS compliant algorithms "
3734                             "for encryption, hashing, and signing"
3735                         ),
3736                         "Settings": self.enabled_one_disabled_zero.keys(),
3737                         "lgpo_section": self.security_options_gpedit_path,
3738                         "Registry": {
3739                             "Hive": "HKEY_LOCAL_MACHINE",
3740                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3741                             "Value": "Enabled",
3742                             "Type": "REG_DWORD",
3743                         },
3744                         "Transform": self.enabled_one_disabled_zero_transform,
3745                     },
3746                     "MachineAccessRestriction": {
3747                         "Policy": (
3748                             "DCOM: Machine Access Restrictions in Security Descriptor "
3749                             "Definition Language (SDDL) syntax"
3750                         ),
3751                         "Settings": None,
3752                         "lgpo_section": self.security_options_gpedit_path,
3753                         "Registry": {
3754                             "Hive": "HKEY_LOCAL_MACHINE",
3755                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3756                             "Value": "MachineAccessRestriction",
3757                             "Type": "REG_SZ",
3758                         },
3759                         "Transform": {"Put": "_string_put_transform"},
3760                     },
3761                     "MachineLaunchRestriction": {
3762                         "Policy": (
3763                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3764                             "Definition Language (SDDL) syntax"
3765                         ),
3766                         "Settings": None,
3767                         "lgpo_section": self.security_options_gpedit_path,
3768                         "Registry": {
3769                             "Hive": "HKEY_LOCAL_MACHINE",
3770                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3771                             "Value": "MachineLaunchRestriction",
3772                             "Type": "REG_SZ",
3773                         },
3774                         "Transform": {"Put": "_string_put_transform"},
3775                     },
3776                     "UseMachineId": {
3777                         "Policy": (
3778                             "Network security: Allow Local System to use computer "
3779                             "identity for NTLM"
3780                         ),
3781                         "Settings": self.enabled_one_disabled_zero.keys(),
3782                         "lgpo_section": self.security_options_gpedit_path,
3783                         "Registry": {
3784                             "Hive": "HKEY_LOCAL_MACHINE",
3785                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3786                             "Value": "UseMachineId",
3787                             "Type": "REG_DWORD",
3788                         },
3789                         "Transform": self.enabled_one_disabled_zero_transform,
3790                     },
3791                     "allownullsessionfallback": {
3792                         "Policy": (
3793                             "Network security: Allow LocalSystem NULL session fallback"
3794                         ),
3795                         "Settings": self.enabled_one_disabled_zero.keys(),
3796                         "lgpo_section": self.security_options_gpedit_path,
3797                         "Registry": {
3798                             "Hive": "HKEY_LOCAL_MACHINE",
3799                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3800                             "Value": "allownullsessionfallback",
3801                             "Type": "REG_DWORD",
3802                         },
3803                         "Transform": self.enabled_one_disabled_zero_transform,
3804                     },
3805                     "AllowOnlineID": {
3806                         "Policy": (
3807                             "Network security: Allow PKU2U authentication requests "
3808                             "to this computer to use online identities."
3809                         ),
3810                         "Settings": self.enabled_one_disabled_zero.keys(),
3811                         "lgpo_section": self.security_options_gpedit_path,
3812                         "Registry": {
3813                             "Hive": "HKEY_LOCAL_MACHINE",
3814                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3815                             "Value": "AllowOnlineID",
3816                             "Type": "REG_DWORD",
3817                         },
3818                         "Transform": self.enabled_one_disabled_zero_transform,
3819                     },
3820                     "KrbSupportedEncryptionTypes": {
3821                         "Policy": (
3822                             "Network security: Configure encryption types allowed "
3823                             "for Kerberos"
3824                         ),
3825                         "Settings": None,
3826                         "lgpo_section": self.security_options_gpedit_path,
3827                         "Registry": {
3828                             "Hive": "HKEY_LOCAL_MACHINE",
3829                             "Path": (
3830                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3831                                 "\\system\\Kerberos\\Parameters"
3832                             ),
3833                             "Value": "SupportedEncryptionTypes",
3834                             "Type": "REG_DWORD",
3835                         },
3836                         "Transform": {
3837                             "Get": "_dict_lookup_bitwise_add",
3838                             "Put": "_dict_lookup_bitwise_add",
3839                             "GetArgs": {
3840                                 "lookup": self.krb_encryption_types,
3841                                 "value_lookup": False,
3842                             },
3843                             "PutArgs": {
3844                                 "lookup": self.krb_encryption_types,
3845                                 "value_lookup": True,
3846                             },
3847                         },
3848                     },
3849                     "NoLMHash": {
3850                         "Policy": (
3851                             "Network security: Do not store LAN Manager hash value "
3852                             "on next password change"
3853                         ),
3854                         "Settings": self.enabled_one_disabled_zero.keys(),
3855                         "lgpo_section": self.security_options_gpedit_path,
3856                         "Registry": {
3857                             "Hive": "HKEY_LOCAL_MACHINE",
3858                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3859                             "Value": "NoLMHash",
3860                             "Type": "REG_DWORD",
3861                         },
3862                         "Transform": self.enabled_one_disabled_zero_transform,
3863                     },
3864                     "ForceLogoffWhenHourExpire": {
3865                         "Policy": (
3866                             "Network security: Force logoff when logon hours expire"
3867                         ),
3868                         "lgpo_section": self.security_options_gpedit_path,
3869                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3870                         "Secedit": {
3871                             "Option": "ForceLogoffWhenHourExpire",
3872                             "Section": "System Access",
3873                         },
3874                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3875                     },
3876                     "LmCompatibilityLevel": {
3877                         "Policy": "Network security: LAN Manager authentication level",
3878                         "Settings": self.lm_compat_levels.keys(),
3879                         "lgpo_section": self.security_options_gpedit_path,
3880                         "Registry": {
3881                             "Hive": "HKEY_LOCAL_MACHINE",
3882                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3883                             "Value": "LmCompatibilityLevel",
3884                             "Type": "REG_DWORD",
3885                         },
3886                         "Transform": {
3887                             "Get": "_dict_lookup",
3888                             "Put": "_dict_lookup",
3889                             "GetArgs": {
3890                                 "lookup": self.lm_compat_levels,
3891                                 "value_lookup": False,
3892                             },
3893                             "PutArgs": {
3894                                 "lookup": self.lm_compat_levels,
3895                                 "value_lookup": True,
3896                             },
3897                         },
3898                     },
3899                     "LDAPClientIntegrity": {
3900                         "Policy": "Network security: LDAP client signing requirements",
3901                         "Settings": self.ldap_signing_reqs.keys(),
3902                         "lgpo_section": self.security_options_gpedit_path,
3903                         "Registry": {
3904                             "Hive": "HKEY_LOCAL_MACHINE",
3905                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3906                             "Value": "LDAPClientIntegrity",
3907                             "Type": "REG_DWORD",
3908                         },
3909                         "Transform": {
3910                             "Get": "_dict_lookup",
3911                             "Put": "_dict_lookup",
3912                             "GetArgs": {
3913                                 "lookup": self.ldap_signing_reqs,
3914                                 "value_lookup": False,
3915                             },
3916                             "PutArgs": {
3917                                 "lookup": self.ldap_signing_reqs,
3918                                 "value_lookup": True,
3919                             },
3920                         },
3921                     },
3922                     "NTLMMinClientSec": {
3923                         "Policy": (
3924                             "Network security: Minimum session security for NTLM SSP"
3925                             " based (including secure RPC) clients"
3926                         ),
3927                         "Settings": None,
3928                         "lgpo_section": self.security_options_gpedit_path,
3929                         "Registry": {
3930                             "Hive": "HKEY_LOCAL_MACHINE",
3931                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3932                             "Value": "NTLMMinClientSec",
3933                             "Type": "REG_DWORD",
3934                         },
3935                         "Transform": {
3936                             "Get": "_dict_lookup_bitwise_add",
3937                             "Put": "_dict_lookup_bitwise_add",
3938                             "GetArgs": {
3939                                 "lookup": self.ntlm_session_security_levels,
3940                                 "value_lookup": False,
3941                             },
3942                             "PutArgs": {
3943                                 "lookup": self.ntlm_session_security_levels,
3944                                 "value_lookup": True,
3945                             },
3946                         },
3947                     },
3948                     "NTLMMinServerSec": {
3949                         "Policy": (
3950                             "Network security: Minimum session security for NTLM SSP"
3951                             " based (including secure RPC) servers"
3952                         ),
3953                         "Settings": None,
3954                         "lgpo_section": self.security_options_gpedit_path,
3955                         "Registry": {
3956                             "Hive": "HKEY_LOCAL_MACHINE",
3957                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3958                             "Value": "NTLMMinServerSec",
3959                             "Type": "REG_DWORD",
3960                         },
3961                         "Transform": {
3962                             "Get": "_dict_lookup_bitwise_add",
3963                             "Put": "_dict_lookup_bitwise_add",
3964                             "GetArgs": {
3965                                 "lookup": self.ntlm_session_security_levels,
3966                                 "value_lookup": False,
3967                             },
3968                             "PutArgs": {
3969                                 "lookup": self.ntlm_session_security_levels,
3970                                 "value_lookup": True,
3971                             },
3972                         },
3973                     },
3974                     "ClientAllowedNTLMServers": {
3975                         "Policy": (
3976                             "Network security: Restrict NTLM: Add remote server"
3977                             " exceptions for NTLM authentication"
3978                         ),
3979                         "lgpo_section": self.security_options_gpedit_path,
3980                         "Registry": {
3981                             "Hive": "HKEY_LOCAL_MACHINE",
3982                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3983                             "Value": "ClientAllowedNTLMServers",
3984                             "Type": "REG_MULTI_SZ",
3985                         },
3986                         "Transform": {
3987                             "Put": "_multi_string_put_transform",
3988                             "Get": "_multi_string_get_transform",
3989                         },
3990                     },
3991                     "DCAllowedNTLMServers": {
3992                         "Policy": (
3993                             "Network security: Restrict NTLM: Add server exceptions"
3994                             " in this domain"
3995                         ),
3996                         "lgpo_section": self.security_options_gpedit_path,
3997                         "Registry": {
3998                             "Hive": "HKEY_LOCAL_MACHINE",
3999                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4000                             "Value": "DCAllowedNTLMServers",
4001                             "Type": "REG_MULTI_SZ",
4002                         },
4003                         "Transform": {
4004                             "Put": "_multi_string_put_transform",
4005                             "Get": "_multi_string_get_transform",
4006                         },
4007                     },
4008                     "AuditReceivingNTLMTraffic": {
4009                         "Policy": (
4010                             "Network security: Restrict NTLM: Audit Incoming NTLM"
4011                             " Traffic"
4012                         ),
4013                         "Settings": self.ntlm_audit_settings.keys(),
4014                         "lgpo_section": self.security_options_gpedit_path,
4015                         "Registry": {
4016                             "Hive": "HKEY_LOCAL_MACHINE",
4017                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4018                             "Value": "AuditReceivingNTLMTraffic",
4019                             "Type": "REG_DWORD",
4020                         },
4021                         "Transform": {
4022                             "Get": "_dict_lookup",
4023                             "Put": "_dict_lookup",
4024                             "GetArgs": {
4025                                 "lookup": self.ntlm_audit_settings,
4026                                 "value_lookup": False,
4027                             },
4028                             "PutArgs": {
4029                                 "lookup": self.ntlm_audit_settings,
4030                                 "value_lookup": True,
4031                             },
4032                         },
4033                     },
4034                     "AuditNTLMInDomain": {
4035                         "Policy": (
4036                             "Network security: Restrict NTLM: Audit NTLM "
4037                             "authentication in this domain"
4038                         ),
4039                         "Settings": self.ntlm_domain_audit_settings.keys(),
4040                         "lgpo_section": self.security_options_gpedit_path,
4041                         "Registry": {
4042                             "Hive": "HKEY_LOCAL_MACHINE",
4043                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4044                             "Value": "AuditNTLMInDomain",
4045                             "Type": "REG_DWORD",
4046                         },
4047                         "Transform": {
4048                             "Get": "_dict_lookup",
4049                             "Put": "_dict_lookup",
4050                             "GetArgs": {
4051                                 "lookup": self.ntlm_domain_audit_settings,
4052                                 "value_lookup": False,
4053                             },
4054                             "PutArgs": {
4055                                 "lookup": self.ntlm_domain_audit_settings,
4056                                 "value_lookup": True,
4057                             },
4058                         },
4059                     },
4060                     "RestrictReceivingNTLMTraffic": {
4061                         "Policy": (
4062                             "Network security: Restrict NTLM: Incoming NTLM traffic"
4063                         ),
4064                         "Settings": self.incoming_ntlm_settings.keys(),
4065                         "lgpo_section": self.security_options_gpedit_path,
4066                         "Registry": {
4067                             "Hive": "HKEY_LOCAL_MACHINE",
4068                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4069                             "Value": "RestrictReceivingNTLMTraffic",
4070                             "Type": "REG_DWORD",
4071                         },
4072                         "Transform": {
4073                             "Get": "_dict_lookup",
4074                             "Put": "_dict_lookup",
4075                             "GetArgs": {
4076                                 "lookup": self.incoming_ntlm_settings,
4077                                 "value_lookup": False,
4078                             },
4079                             "PutArgs": {
4080                                 "lookup": self.incoming_ntlm_settings,
4081                                 "value_lookup": True,
4082                             },
4083                         },
4084                     },
4085                     "RestrictNTLMInDomain": {
4086                         "Policy": (
4087                             "Network security: Restrict NTLM: NTLM "
4088                             "authentication in this domain"
4089                         ),
4090                         "Settings": self.ntlm_domain_auth_settings.keys(),
4091                         "lgpo_section": self.security_options_gpedit_path,
4092                         "Registry": {
4093                             "Hive": "HKEY_LOCAL_MACHINE",
4094                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4095                             "Value": "RestrictNTLMInDomain",
4096                             "Type": "REG_DWORD",
4097                         },
4098                         "Transform": {
4099                             "Get": "_dict_lookup",
4100                             "Put": "_dict_lookup",
4101                             "GetArgs": {
4102                                 "lookup": self.ntlm_domain_auth_settings,
4103                                 "value_lookup": False,
4104                             },
4105                             "PutArgs": {
4106                                 "lookup": self.ntlm_domain_auth_settings,
4107                                 "value_lookup": True,
4108                             },
4109                         },
4110                     },
4111                     "RestrictSendingNTLMTraffic": {
4112                         "Policy": (
4113                             "Network security: Restrict NTLM: Outgoing NTLM"
4114                             " traffic to remote servers"
4115                         ),
4116                         "Settings": self.outgoing_ntlm_settings.keys(),
4117                         "lgpo_section": self.security_options_gpedit_path,
4118                         "Registry": {
4119                             "Hive": "HKEY_LOCAL_MACHINE",
4120                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4121                             "Value": "RestrictSendingNTLMTraffic",
4122                             "Type": "REG_DWORD",
4123                         },
4124                         "Transform": {
4125                             "Get": "_dict_lookup",
4126                             "Put": "_dict_lookup",
4127                             "GetArgs": {
4128                                 "lookup": self.outgoing_ntlm_settings,
4129                                 "value_lookup": False,
4130                             },
4131                             "PutArgs": {
4132                                 "lookup": self.outgoing_ntlm_settings,
4133                                 "value_lookup": True,
4134                             },
4135                         },
4136                     },
4137                     "ShutdownWithoutLogon": {
4138                         "Policy": (
4139                             "Shutdown: Allow system to be shut down "
4140                             "without having to log on"
4141                         ),
4142                         "Settings": self.enabled_one_disabled_zero.keys(),
4143                         "lgpo_section": self.security_options_gpedit_path,
4144                         "Registry": {
4145                             "Hive": "HKEY_LOCAL_MACHINE",
4146                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4147                             "Value": "ShutdownWithoutLogon",
4148                             "Type": "REG_DWORD",
4149                         },
4150                         "Transform": self.enabled_one_disabled_zero_transform,
4151                     },
4152                     "ClearPageFileAtShutdown": {
4153                         "Policy": "Shutdown: Clear virtual memory pagefile",
4154                         "Settings": self.enabled_one_disabled_zero.keys(),
4155                         "lgpo_section": self.security_options_gpedit_path,
4156                         "Registry": {
4157                             "Hive": "HKEY_LOCAL_MACHINE",
4158                             "Path": (
4159                                 "System\\CurrentControlSet\\Control\\"
4160                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4161                             ),
4162                             "Value": "ClearPageFileAtShutdown",
4163                             "Type": "REG_DWORD",
4164                         },
4165                         "Transform": self.enabled_one_disabled_zero_transform,
4166                     },
4167                     "ObCaseInsensitive": {
4168                         "Policy": (
4169                             "System objects: Require case insensitivity for "
4170                             "non-Windows subsystems"
4171                         ),
4172                         "Settings": self.enabled_one_disabled_zero.keys(),
4173                         "lgpo_section": self.security_options_gpedit_path,
4174                         "Registry": {
4175                             "Hive": "HKEY_LOCAL_MACHINE",
4176                             "Path": (
4177                                 "System\\CurrentControlSet\\Control\\"
4178                                 "SESSION MANAGER\\Kernel"
4179                             ),
4180                             "Value": "ObCaseInsensitive",
4181                             "Type": "REG_DWORD",
4182                         },
4183                         "Transform": self.enabled_one_disabled_zero_transform,
4184                     },
4185                     "ProtectionMode": {
4186                         "Policy": (
4187                             "System objects: Strengthen default permissions of "
4188                             "internal system objects (e.g. Symbolic Links)"
4189                         ),
4190                         "Settings": self.enabled_one_disabled_zero.keys(),
4191                         "lgpo_section": self.security_options_gpedit_path,
4192                         "Registry": {
4193                             "Hive": "HKEY_LOCAL_MACHINE",
4194                             "Path": (
4195                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4196                             ),
4197                             "Value": "ProtectionMode",
4198                             "Type": "REG_DWORD",
4199                         },
4200                         "Transform": self.enabled_one_disabled_zero_transform,
4201                     },
4202                     "OptionalSubsystems": {
4203                         "Policy": "System settings: Optional subsystems",
4204                         "lgpo_section": self.security_options_gpedit_path,
4205                         "Registry": {
4206                             "Hive": "HKEY_LOCAL_MACHINE",
4207                             "Path": (
4208                                 "System\\CurrentControlSet\\Control\\"
4209                                 "SESSION MANAGER\\SubSystems"
4210                             ),
4211                             "Value": "optional",
4212                             "Type": "REG_MULTI_SZ",
4213                         },
4214                         "Transform": {
4215                             "Put": "_multi_string_put_transform",
4216                             "Get": "_multi_string_get_transform",
4217                         },
4218                     },
4219                     "AuthenticodeEnabled": {
4220                         "Policy": (
4221                             "System settings: Use Certificate Rules on Windows"
4222                             " Executables for Software Restriction Policies"
4223                         ),
4224                         "Settings": self.enabled_one_disabled_zero.keys(),
4225                         "lgpo_section": self.security_options_gpedit_path,
4226                         "Registry": {
4227                             "Hive": "HKEY_LOCAL_MACHINE",
4228                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4229                             "Value": "AuthenticodeEnabled",
4230                             "Type": "REG_DWORD",
4231                         },
4232                         "Transform": self.enabled_one_disabled_zero_transform,
4233                     },
4234                 },
4235             },
4236             "User": {"lgpo_section": "User Configuration", "policies": {}},
4237         }
4238         self.admx_registry_classes = {
4239             "User": {
4240                 "policy_path": os.path.join(
4241                     os.getenv("WINDIR"),
4242                     "System32",
4243                     "GroupPolicy",
4244                     "User",
4245                     "Registry.pol",
4246                 ),
4247                 "hive": "HKEY_USERS",
4248                 "lgpo_section": "User Configuration",
4249                 "gpt_extension_location": "gPCUserExtensionNames",
4250                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4251             },
4252             "Machine": {
4253                 "policy_path": os.path.join(
4254                     os.getenv("WINDIR"),
4255                     "System32",
4256                     "GroupPolicy",
4257                     "Machine",
4258                     "Registry.pol",
4259                 ),
4260                 "hive": "HKEY_LOCAL_MACHINE",
4261                 "lgpo_section": "Computer Configuration",
4262                 "gpt_extension_location": "gPCMachineExtensionNames",
4263                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4264             },
4265         }
4266         self.reg_pol_header = "\u5250\u6765\x01\x00"
4267         self.gpt_ini_path = os.path.join(
4268             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4269         )
4270     @classmethod
4271     def _notEmpty(cls, val, **kwargs):
4272         if val:
4273             return True
4274         else:
4275             return False
4276     @classmethod
4277     def _seconds_to_days(cls, val, **kwargs):
4278         zero_value = kwargs.get("zero_value", 0)
4279         if val is not None:
4280             if val == zero_value:
4281                 return 0
4282             return val / 86400
4283         else:
4284             return "Not Defined"
4285     @classmethod
4286     def _days_to_seconds(cls, val, **kwargs):
4287         zero_value = kwargs.get("zero_value", 0)
4288         if val is not None:
4289             if val == 0:
4290                 return zero_value
4291             return val * 86400
4292         else:
4293             return "Not Defined"
4294     @classmethod
4295     def _seconds_to_minutes(cls, val, **kwargs):
4296         zero_value = kwargs.get("zero_value", 0)
4297         if val is not None:
4298             if val == zero_value:
4299                 return 0
4300             return val / 60
4301         else:
4302             return "Not Defined"
4303     @classmethod
4304     def _minutes_to_seconds(cls, val, **kwargs):
4305         zero_value = kwargs.get("zero_value", 0)
4306         if val is not None:
4307             if val == 0:
4308                 return zero_value
4309             return val * 60
4310         else:
4311             return "Not Defined"
4312     @classmethod
4313     def _strip_quotes(cls, val, **kwargs):
4314         return val.replace('"', "")
4315     @classmethod
4316     def _add_quotes(cls, val, **kwargs):
4317         return '"{}"'.format(val)
4318     @classmethod
4319     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4320         try:
4321             if val is not None:
4322                 if ord(val) == 0:
4323                     return "Disabled"
4324                 elif ord(val) == 1:
4325                     return "Enabled"
4326                 else:
4327                     return "Invalid Value: {!r}".format(val)
4328             else:
4329                 return "Not Defined"
4330         except TypeError:
4331             return "Invalid Value"
4332     @classmethod
4333     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4334         if val is not None:
4335             if val.upper() == "DISABLED":
4336                 return chr(0)
4337             elif val.upper() == "ENABLED":
4338                 return chr(1)
4339             else:
4340                 return None
4341         else:
4342             return None
4343     @classmethod
4344     def _dasd_conversion(cls, val, **kwargs):
4345         if val is not None:
4346             if val == "0" or val == 0 or val == "":
4347                 return "Administrators"
4348             elif val == "1" or val == 1:
4349                 return "Administrators and Power Users"
4350             elif val == "2" or val == 2:
4351                 return "Administrators and Interactive Users"
4352             else:
4353                 return "Not Defined"
4354         else:
4355             return "Not Defined"
4356     @classmethod
4357     def _dasd_reverse_conversion(cls, val, **kwargs):
4358         if val is not None:
4359             if val.upper() == "ADMINISTRATORS":
4360                 return "0"
4361             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4362                 return "1"
4363             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4364                 return "2"
4365             elif val.upper() == "NOT DEFINED":
4366                 return "9999"
4367             else:
4368                 return "Invalid Value"
4369         else:
4370             return "Not Defined"
4371     @classmethod
4372     def _in_range_inclusive(cls, val, **kwargs):
4373         minimum = kwargs.get("min", 0)
4374         maximum = kwargs.get("max", 1)
4375         zero_value = kwargs.get("zero_value", 0)
4376         if isinstance(val, str):
4377             if val.lower() == "not defined":
4378                 return True
4379             else:
4380                 try:
4381                     val = int(val)
4382                 except ValueError:
4383                     return False
4384         if val is not None:
4385             if minimum &lt;= val &lt;= maximum or val == zero_value:
4386                 return True
4387             else:
4388                 return False
4389         else:
4390             return False
4391     @classmethod
4392     def _driver_signing_reg_conversion(cls, val, **kwargs):
4393         log.trace("we have %s for the driver signing value", val)
4394         if val is not None:
4395             _val = val.split(",")
4396             if len(_val) == 2:
4397                 if _val[1] == "0":
4398                     return "Silently Succeed"
4399                 elif _val[1] == "1":
4400                     return "Warn but allow installation"
4401                 elif _val[1] == "2":
4402                     return "Do not allow installation"
4403                 elif _val[1] == "Not Defined":
4404                     return "Not Defined"
4405                 else:
4406                     return "Invalid Value"
4407             else:
4408                 return "Not Defined"
4409         else:
4410             return "Not Defined"
4411     @classmethod
4412     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4413         if val is not None:
4414             if val.upper() == "SILENTLY SUCCEED":
4415                 return ",".join(["3", "0"])
4416             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4417                 return ",".join(["3", chr(1)])
4418             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4419                 return ",".join(["3", chr(2)])
4420             else:
4421                 return "Invalid Value"
4422         else:
4423             return "Not Defined"
4424     @classmethod
4425     def _sidConversion(cls, val, **kwargs):
4426         if isinstance(val, str):
4427             val = val.split(",")
4428         usernames = []
4429         for _sid in val:
4430             try:
4431                 userSid = win32security.LookupAccountSid("", _sid)
4432                 if userSid[1]:
4433                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4434                 else:
4435                     userSid = "{}".format(userSid[0])
4436             except Exception:  # pylint: disable=broad-except
4437                 userSid = win32security.ConvertSidToStringSid(_sid)
4438                 log.warning(
4439                     "Unable to convert SID '%s' to a friendly name. "
4440                     "The SID will be displayed instead of a user/group name.",
4441                     userSid,
4442                 )
4443             usernames.append(userSid)
4444         return usernames
4445     @classmethod
4446     def _usernamesToSidObjects(cls, val, **kwargs):
4447         if not val:
4448             return val
4449         if isinstance(val, str):
4450             val = val.split(",")
4451         sids = []
4452         for _user in val:
4453             try:
4454                 sid = win32security.LookupAccountName("", _user)[0]
4455                 sids.append(sid)
4456             except Exception as e:  # pylint: disable=broad-except
4457                 log.exception("Handle this explicitly")
4458                 raise CommandExecutionError(
4459                     'There was an error obtaining the SID of user "{}". Error '
4460                     "returned: {}".format(_user, e)
4461                 )
4462         return sids
4463     @classmethod
4464     def _powershell_script_order_conversion(cls, val, **kwargs):
4465         log.trace("script order value = %s", val)
4466         if val is None or val == "None":
4467             return "Not Configured"
4468         elif val == "true":
4469             return "Run Windows PowerShell scripts first"
4470         elif val == "false":
4471             return "Run Windows PowerShell scripts last"
4472         else:
4473             return "Invalid Value"
4474     @classmethod
4475     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4476         if val.upper() == "Run Windows PowerShell scripts first".upper():
4477             return "true"
4478         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4479             return "false"
4480         elif val == "Not Configured":
4481             return None
4482         else:
4483             return "Invalid Value"
4484     @classmethod
4485     def _dict_lookup(cls, item, **kwargs):
4486         log.trace("item == %s", item)
4487         value_lookup = kwargs.get("value_lookup", False)
4488         if "lookup" in kwargs:
4489             for k, v in kwargs["lookup"].items():
4490                 if value_lookup:
4491                     if str(v).lower() == str(item).lower():
4492                         log.trace("returning key %s", k)
4493                         return k
4494                 else:
4495                     if str(k).lower() == str(item).lower():
4496                         log.trace("returning value %s", v)
4497                         return v
4498         return "Invalid Value"
4499     @classmethod
4500     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4501         value_lookup = kwargs.get("value_lookup", False)
4502         test_zero = kwargs.get("test_zero", False)
4503         ret_val = None
4504         if str(item).lower() == "not defined":
4505             return None
4506         if value_lookup:
4507             if not isinstance(item, list):
4508                 return "Invalid Value"
4509             ret_val = 0
4510         else:
4511             if not isinstance(item, int):
4512                 return "Invalid Value"
4513             ret_val = []
4514         if "lookup" in kwargs:
4515             for k, v in kwargs["lookup"].items():
4516                 if value_lookup:
4517                     if str(v).lower() in [z.lower() for z in item]:
4518                         ret_val = ret_val + k
4519                 else:
4520                     do_test = True
4521                     if not test_zero:
4522                         if k == 0:
4523                             do_test = False
4524                     if do_test and isinstance(k, int) and item &amp; k == k:
4525                         ret_val.append(v)
4526         else:
4527             return "Invalid Value"
4528         return ret_val
4529     @classmethod
4530     def _multi_string_put_transform(cls, item, **kwargs):
4531         if isinstance(item, list):
4532             return item
4533         elif isinstance(item, str):
4534             if item.lower() == "not defined":
4535                 return None
4536             else:
4537                 return item.split(",")
4538         else:
4539             return "Invalid Value"
4540     @classmethod
4541     def _multi_string_get_transform(cls, item, **kwargs):
4542         if isinstance(item, list):
4543             return item
4544         elif item is None:
4545             return "Not Defined"
4546         else:
4547             return "Invalid Value"
4548     @classmethod
4549     def _string_put_transform(cls, item, **kwargs):
4550         if isinstance(item, str):
4551             if item.lower() == "not defined":
4552                 return None
4553             else:
4554                 return item
4555 def __virtual__():
4556     if not salt.utils.platform.is_windows():
4557         return False, "win_lgpo: Not a Windows System"
4558     if not HAS_WINDOWS_MODULES:
4559         return False, "win_lgpo: Required modules failed to load"
4560     return __virtualname__
4561 def _updateNamespace(item, new_namespace):
4562     temp_item = ""
4563     i = item.tag.find("}")
4564     if i &gt;= 0:
4565         temp_item = item.tag[i + 1 :]
4566     else:
4567         temp_item = item.tag
4568     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4569     for child in item.getiterator():
4570         if isinstance(child.tag, str):
4571             temp_item = ""
4572             i = child.tag.find("}")
4573             if i &gt;= 0:
4574                 temp_item = child.tag[i + 1 :]
4575             else:
4576                 temp_item = child.tag
4577             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4578     return item
4579 def _updatePolicyElements(policy_item, regkey):
4580     for child in policy_item.getiterator():
4581         if "valueName" in child.attrib:
4582             if "key" not in child.attrib:
4583                 child.attrib["key"] = regkey
4584     return policy_item
4585 def _remove_unicode_encoding(xml_file):
4586     <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(xml_file, "rb") as f:
4587         xml_content = f.read()
4588     modified_xml = re.sub(
4589         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.</b></font>decode("utf-16"), count=1
4590     )
4591     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4592     return xml_tree
4593 def _remove_invalid_xmlns(xml_file):
4594     with salt.utils.files.fopen(xml_file, "rb") as f:
4595         xml_content = f.read()
4596     modified_xml = re.sub(
4597         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4598     )
4599     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4600     return xml_tree
4601 def _parse_xml(adm_file):
4602     parser = lxml.etree.XMLParser(remove_comments=True)
4603     modified_xml = ""
4604     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4605         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4606     name, ext = os.path.splitext(os.path.basename(adm_file))
4607     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4608     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4609     if not os.path.exists(cache_dir):
4610         os.makedirs(cache_dir)
4611     out_file = os.path.join(cache_dir, hashed_filename)
4612     if not os.path.isfile(out_file):
4613         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4614         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4615         for file_path in file_list:
4616             os.remove(file_path)
4617         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4618             encoding = "utf-8"
4619             raw = rfh.read()
4620             try:
4621                 raw = raw.decode(encoding)
4622             except UnicodeDecodeError:
4623                 log.trace("LGPO: Detecting encoding")
4624                 encoding = "utf-16"
4625                 raw = raw.decode(encoding)
4626             for line in raw.split("\r\n"):
4627                 if 'key="' in line:
4628                     start = line.index('key="')
4629                     q1 = line[start:].index('"') + start
4630                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4631                     line = line.replace(line[start:q2], line[start:q2].lower())
4632                     found_key = True
4633         modified_xml = modified_xml.replace("\u201c", '"')<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.replace("\u201d", '"')
4634         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4635         modified_xml = modified_xml.replace("\u2013", "-").replace(</b></font>"\u2014", "-")
4636         with salt.utils.files.fopen(out_file, "wb") as wfh:
4637             wfh.write(modified_xml.encode(encoding))
4638     try:
4639         xml_tree = lxml.etree.parse(out_file, parser=parser)
4640     except lxml.etree.XMLSyntaxError:
4641         try:
4642             xml_tree = _remove_unicode_encoding(out_file)
4643         except lxml.etree.XMLSyntaxError:
4644             xml_tree = _remove_invalid_xmlns(out_file)
4645     return xml_tree
4646 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4647     """
4648     t_policy_definitions = lxml<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.etree.Element("policyDefinitions")
4649     t_policy_definitions.append(lxml.etree.Element("categories"))
4650     t_policy_definitions.append(lxml.etree.Element("policies"))
4651     t_policy_definitions.append(lxml.etree.Element(</b></font>"policyNamespaces"))
4652     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4653     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4654     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4655     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4656     policydefs_resources_localname_xpath = etree.XPath(
4657         '//*[local-name() = "policyDefinitionResources"]/*'
4658     )
4659     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4660     for root, dirs, files in salt.utils.path.os_walk(path):
4661         if root == path:
4662             for t_admx_file in files:
4663                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4664                 if not admx_file_ext == ".admx":
4665                     log.debug("%s is not an ADMX file", t_admx_file)
4666                     continue
4667                 admx_file = os.path.join(root, t_admx_file)
4668                 try:
4669                     xml_tree = _parse_xml(admx_file)
4670                 except lxml.etree.XMLSyntaxError:
4671                     log.error(
4672                         "An error was found while processing admx "
4673                         "file %s, all policies from this file will "
4674                         "be unavailable via this module",
4675                         admx_file,
4676                     )
4677                     continue
4678                 namespaces = xml_tree.getroot().nsmap
4679                 namespace_string = ""
4680                 if None in namespaces:
4681                     namespaces["None"] = namespaces[None]
4682                     namespaces.pop(None)
4683                     namespace_string = "None:"
4684                 this_namespace = xml_tree.xpath(
4685                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4686                         namespace_string
4687                     ),
4688                     namespaces=namespaces,
4689                 )[0]
4690                 categories = xml_tree.xpath(
4691                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4692                         namespace_string
4693                     ),
4694                     namespaces=namespaces,
4695                 )
4696                 for category in categories:
4697                     temp_cat = category
4698                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4699                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4700                         temp_cat
4701                     )
4702                 policies = xml_tree.xpath(
4703                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4704                         namespace_string
4705                     ),
4706                     namespaces=namespaces,
4707                 )
4708                 for policy in policies:
4709                     temp_pol = policy
4710                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4711                     if "key" in temp_pol.attrib:
4712                         temp_pol = _updatePolicyElements(
4713                             temp_pol, temp_pol.attrib["key"]
4714                         )
4715                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4716                 policy_namespaces = xml_tree.xpath(
4717                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4718                         namespace_string
4719                     ),
4720                     namespaces=namespaces,
4721                 )
4722                 for policy_ns in policy_namespaces:
4723                     temp_ns = policy_ns
4724                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4725                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4726                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4727                 if not __salt__["file.file_exists"](adml_file):
4728                     log.info(
4729                         "An ADML file in the specified ADML language "
4730                         '"%s" does not exist for the ADMX "%s", the '
4731                         "the abbreviated language code will be tried.",
4732                         language,
4733                         t_admx_file,
4734                     )
4735                     adml_file = os.path.join(
4736                         root, language.split("-")[0], admx_file_name + ".adml"
4737                     )
4738                     if not __salt__["file.file_exists"](adml_file):
4739                         log.info(
4740                             "An ADML file in the specified ADML language "
4741                             'code %s does not exist for the ADMX "%s", '
4742                             "the fallback language will be tried.",
4743                             language[:2],
4744                             t_admx_file,
4745                         )
4746                         adml_file = os.path.join(
4747                             root, display_language_fallback, admx_file_name + ".adml"
4748                         )
4749                         if not __salt__["file.file_exists"](adml_file):
4750                             log.info(
4751                                 "An ADML file in the specified ADML "
4752                                 'fallback language "%s" '
4753                                 'does not exist for the ADMX "%s" '
4754                                 "the abbreviated fallback language code "
4755                                 "will be tried.",
4756                                 display_language_fallback,
4757                                 t_admx_file,
4758                             )
4759                             adml_file = os.path.join(
4760                                 root,
4761                                 display_language_fallback.split("-")[0],
4762                                 admx_file_name + ".adml",
4763                             )
4764                             if not __salt__["file.file_exists"](adml_file):
4765                                 raise SaltInvocationError(
4766                                     "An ADML file in the specified ADML language "
4767                                     '"{}" and the fallback language "{}" do not '
4768                                     'exist for the ADMX "{}".'.format(
4769                                         language, display_language_fallback, t_admx_file
4770                                     )
4771                                 )
4772                 try:
4773                     xml_tree = _parse_xml(adml_file)
4774                 except lxml.etree.XMLSyntaxError:
4775                     log.error(
4776                         "An error was found while processing adml "
4777                         "file %s, all policies from this file will "
4778                         "be unavailable via this module",
4779                         adml_file,
4780                     )
4781                     continue
4782                 if None in namespaces:
4783                     namespaces["None"] = namespaces[None]
4784                     namespaces.pop(None)
4785                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4786                 for policydefs_resource in policydefs_resources:
4787                     t_poldef = policydefs_resource
4788                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4789                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4790                         t_poldef
4791                     )
4792     __context__["lgpo.policy_definitions"] = t_policy_definitions
4793     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4794 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4795     if "lgpo.policy_definitions" not in __context__:
4796         log.debug("LGPO: Loading policy definitions")
4797         _load_policy_definitions(path=path, language=language)
4798     return __context__["lgpo.policy_definitions"]
4799 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4800     if "lgpo.policy_resources" not in __context__:
4801         log.debug("LGPO: Loading policy resources")
4802         _load_policy_definitions(path=path, language=language)
4803     return __context__["lgpo.policy_resources"]
4804 def _buildElementNsmap(using_elements):
4805     """
4806     build a namespace map for an ADMX element
4807     """
4808     thisMap = {}
4809     for e in using_elements:
4810         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4811     return thisMap
4812 def _get_advaudit_defaults(option=None):
4813     """
4814     Loads audit.csv defaults into a dict in __context__ called
4815     'lgpo.audit_defaults'. The dictionary includes fieldnames and all
4816     configurable policies as keys. The values are used to create/modify the
4817     ``audit.csv`` file. The first entry is `fieldnames` used to create the
4818     header for the csv file. The rest of the entries are the audit policy names.
4819     Sample data follows:
4820     {
4821         'fieldnames': ['Machine Name',
4822                        'Policy Target',
4823                        'Subcategory',
4824                        'Subcategory GUID',
4825                        'Inclusion Setting',
4826                        'Exclusion Setting',
4827                        'Setting Value'],
4828         'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',
4829                                           'Exclusion Setting': '',
4830                                           'Inclusion Setting': 'No Auditing',
4831                                           'Machine Name': 'WIN-8FGT3E045SE',
4832                                           'Policy Target': 'System',
4833                                           'Setting Value': '0',
4834                                           'Subcategory': u'Audit Sensitive Privilege Use',
4835                                           'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},
4836         'Audit Special Logon': {'Auditpol Name': 'Special Logon',
4837                                 'Exclusion Setting': '',
4838                                 'Inclusion Setting': 'No Auditing',
4839                                 'Machine Name': 'WIN-8FGT3E045SE',
4840                                 'Policy Target': 'System',
4841                                 'Setting Value': '0',
4842                                 'Subcategory': u'Audit Special Logon',
4843                                 'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},
4844         'Audit System Integrity': {'Auditpol Name': 'System Integrity',
4845                                    'Exclusion Setting': '',
4846                                    'Inclusion Setting': 'No Auditing',
4847                                    'Machine Name': 'WIN-8FGT3E045SE',
4848                                    'Policy Target': 'System',
4849                                    'Setting Value': '0',
4850                                    'Subcategory': u'Audit System Integrity',
4851                                    'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},
4852         ...
4853     }
4854     .. note::
4855         `Auditpol Name` designates the value to use when setting the value with
4856         the auditpol command
4857     Args:
4858         option (str): The item from the dictionary to return. If ``None`` the
4859             entire dictionary is returned. Default is ``None``
4860     Returns:
4861         dict: If ``None`` or one of the audit settings is passed
4862         list: If ``fieldnames`` is passed
4863     """
4864     if "lgpo.audit_defaults" not in __context__:
4865         log.debug("Loading auditpol defaults into __context__")
4866         dump = __utils__["auditpol.get_auditpol_dump"]()
4867         reader = csv.DictReader(dump)
4868         audit_defaults = {"fieldnames": reader.fieldnames}
4869         for row in reader:
4870             row["Machine Name"] = ""
4871             row["Auditpol Name"] = row["Subcategory"]
4872             if row["Subcategory"] == "Central Policy Staging":
4873                 row["Subcategory"] = "Audit Central Access Policy Staging"
4874             elif row["Subcategory"] == "Plug and Play Events":
4875                 row["Subcategory"] = "Audit PNP Activity"
4876             elif row["Subcategory"] == "Token Right Adjusted Events":
4877                 row["Subcategory"] = "Audit Token Right Adjusted"
4878             else:
4879                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
4880             audit_defaults[row["Subcategory"]] = row
4881         __context__["lgpo.audit_defaults"] = audit_defaults
4882     if option:
4883         return __context__["lgpo.audit_defaults"][option]
4884     else:
4885         return __context__["lgpo.audit_defaults"]
4886 def _advaudit_check_csv():
4887     """
4888     This function checks for the existence of the `audit.csv` file here:
4889     `C:\\Windows\\security\\audit`
4890     If the file does not exist, then it copies the `audit.csv` file from the
4891     Group Policy location:
4892     `C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit`
4893     If there is no `audit.csv` in either location, then a default `audit.csv`
4894     file is created.
4895     """
4896     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4897     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4898     f_audit_gpo = os.path.join(
4899         system_root,
4900         "System32",
4901         "GroupPolicy",
4902         "Machine",
4903         "Microsoft",
4904         "Windows NT",
4905         "Audit",
4906         "audit.csv",
4907     )
4908     if not __salt__["file.file_exists"](f_audit):
4909         if __salt__["file.file_exists"](f_audit_gpo):
4910             __salt__["file.copy"](f_audit_gpo, f_audit)
4911         else:
4912             field_names = _get_advaudit_defaults("fieldnames")
4913             __salt__["file.makedirs"](f_audit)
4914             __salt__["file.write"](f_audit, ",".join(field_names))
4915 def _get_advaudit_value(option, refresh=False):
4916     """
4917     Get the Advanced Auditing policy as configured in
4918     ``C:\\Windows\\Security\\Audit\\audit.csv``
4919     Args:
4920         option (str):
4921             The name of the setting as it appears in audit.csv
4922         refresh (bool):
4923             Refresh secedit data stored in __context__. This is needed for
4924             testing where the state is setting the value, but the module that
4925             is checking the value has its own __context__.
4926     Returns:
4927         bool: ``True`` if successful, otherwise ``False``
4928     """
4929     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
4930         system_root = os.environ.get("SystemRoot", "C:\\Windows")
4931         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4932         _advaudit_check_csv()
4933         audit_settings = {}
4934         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4935             reader = csv.DictReader(csv_file)
4936             for row in reader:
4937                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
4938         __context__["lgpo.adv_audit_data"] = audit_settings
4939     return __context__["lgpo.adv_audit_data"].get(option, None)
4940 def _set_advaudit_file_data(option, value):
4941     """
4942     Helper function that sets the Advanced Audit settings in the two .csv files
4943     on Windows. Those files are located at:
4944     C:\\Windows\\Security\\Audit\\audit.csv
4945     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
4946     Args:
4947         option (str): The name of the option to set
4948         value (str): The value to set. ['None', '0', '1', '2', '3']
4949     Returns:
4950         bool: ``True`` if successful, otherwise ``False``
4951     """
4952     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4953     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4954     f_audit_gpo = os.path.join(
4955         system_root,
4956         "System32",
4957         "GroupPolicy",
4958         "Machine",
4959         "Microsoft",
4960         "Windows NT",
4961         "Audit",
4962         "audit.csv",
4963     )
4964     f_temp = tempfile.NamedTemporaryFile(
4965         mode="w", delete=False, suffix=".csv", prefix="audit"
4966     )
4967     auditpol_values = {
4968         "None": "No Auditing",
4969         "0": "No Auditing",
4970         "1": "Success",
4971         "2": "Failure",
4972         "3": "Success and Failure",
4973     }
4974     _advaudit_check_csv()
4975     try:
4976         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4977             reader = csv.DictReader(csv_file)
4978             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
4979                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
4980                 writer.writeheader()
4981                 value_written = False
4982                 for row in reader:
4983                     if row["Subcategory"] == option:
4984                         if not value == "None":
4985                             row["Inclusion Setting"] = auditpol_values[value]
4986                             row["Setting Value"] = value
4987                             log.trace("LGPO: Setting %s to %s", option, value)
4988                             writer.writerow(row)
4989                         else:
4990                             log.trace("LGPO: Removing %s", option)
4991                         value_written = True
4992                     else:
4993                         writer.writerow(row)
4994                 if not value_written:
4995                     if not value == "None":
4996                         log.trace("LGPO: Setting %s to %s", option, value)
4997                         defaults = _get_advaudit_defaults(option)
4998                         writer.writerow(
4999                             {
5000                                 "Machine Name": defaults["Machine Name"],
5001                                 "Policy Target": defaults["Policy Target"],
5002                                 "Subcategory": defaults["Subcategory"],
5003                                 "Subcategory GUID": defaults["Subcategory GUID"],
5004                                 "Inclusion Setting": auditpol_values[value],
5005                                 "Exclusion Setting": defaults["Exclusion Setting"],
5006                                 "Setting Value": value,
5007                             }
5008                         )
5009                     value_written = True
5010         if value_written:
5011             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
5012             __salt__["file.makedirs"](f_audit_gpo)
5013             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
5014     finally:
5015         f_temp.close()
5016         __salt__["file.remove"](f_temp.name)
5017     return value_written
5018 def _set_advaudit_pol_data(option, value):
5019     """
5020     Helper function that updates the current applied settings to match what has
5021     just been set in the audit.csv files. We're doing it this way instead of
5022     running `gpupdate`
5023     Args:
5024         option (str): The name of the option to set
5025         value (str): The value to set. ['None', '0', '1', '2', '3']
5026     Returns:
5027         bool: ``True`` if successful, otherwise ``False``
5028     """
5029     auditpol_values = {
5030         "None": "No Auditing",
5031         "0": "No Auditing",
5032         "1": "Success",
5033         "2": "Failure",
5034         "3": "Success and Failure",
5035     }
5036     defaults = _get_advaudit_defaults(option)
5037     return __utils__["auditpol.set_setting"](
5038         name=defaults["Auditpol Name"], value=auditpol_values[value]
5039     )
5040 def _set_advaudit_value(option, value):
5041     """
5042     Helper function to update the Advanced Audit policy on the machine. This
5043     function modifies the two ``audit.csv`` files in the following locations:
5044     C:\\Windows\\Security\\Audit\\audit.csv
5045     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5046     Then it applies those settings using ``auditpol``
5047     After that, it updates ``__context__`` with the new setting
5048     Args:
5049         option (str): The name of the option to set
5050         value (str): The value to set. ['None', '0', '1', '2', '3']
5051     Returns:
5052         bool: ``True`` if successful, otherwise ``False``
5053     """
5054     if not _set_advaudit_file_data(option=option, value=value):
5055         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
5056     if not _set_advaudit_pol_data(option=option, value=value):
5057         log.error(
5058             "Failed to apply audit setting: %s\n"
5059             "Policy will take effect on next GPO update",
5060             option,
5061         )
5062     if "lgpo.adv_audit_data" not in __context__:
5063         _get_advaudit_value(option)
5064     if value is None:
5065         log.debug("LGPO: Removing Advanced Audit data: %s", option)
5066         __context__["lgpo.adv_audit_data"].pop(option)
5067     else:
5068         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
5069         __context__["lgpo.adv_audit_data"][option] = value
5070     return True
5071 def _get_netsh_value(profile, option):
5072     if "lgpo.netsh_data" not in __context__:
5073         __context__["lgpo.netsh_data"] = {}
5074     if profile not in __context__["lgpo.netsh_data"]:
5075         log.debug("LGPO: Loading netsh data for %s profile", profile)
5076         settings = salt.utils.win_lgpo_netsh.get_all_settings(
5077             profile=profile, store="lgpo"
5078         )
5079         __context__["lgpo.netsh_data"].update({profile: settings})
5080     log.trace(
5081         "LGPO: netsh returning value: %s",
5082         __context__["lgpo.netsh_data"][profile][option],
5083     )
5084     return __context__["lgpo.netsh_data"][profile][option]
5085 def _set_netsh_value(profile, section, option, value):
5086     if section not in ("firewallpolicy", "settings", "logging", "state"):
5087         raise ValueError("LGPO: Invalid section: {}".format(section))
5088     log.trace(
5089         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
5090         profile,
5091         section,
5092         option,
5093         value,
5094     )
5095     if section == "firewallpolicy":
5096         salt.utils.win_lgpo_netsh.set_firewall_settings(
5097             profile=profile,
5098             inbound=value if option == "Inbound" else None,
5099             outbound=value if option == "Outbound" else None,
5100             store="lgpo",
5101         )
5102     if section == "settings":
5103         salt.utils.win_lgpo_netsh.set_settings(
5104             profile=profile, setting=option, value=value, store="lgpo"
5105         )
5106     if section == "state":
5107         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
5108     if section == "logging":
5109         if option in ("FileName", "MaxFileSize"):
5110             if value == "Not configured":
5111                 value = "notconfigured"
5112         if option.startswith("Log"):
5113             option = option[3:]
5114         salt.utils.win_lgpo_netsh.set_logging_settings(
5115             profile=profile, setting=option, value=value, store="lgpo"
5116         )
5117     log.trace("LGPO: Clearing netsh data for %s profile", profile)
5118     __context__["lgpo.netsh_data"].pop(profile)
5119     return True
5120 def _load_secedit_data():
5121     """
5122     Helper function that loads secedit data. It runs `secedit /export /cfg
5123     &lt;file_name&gt;` which creates a file that contains the secedit data.
5124     Returns:
5125         str: The contents of the file generated by the secedit command
5126     """
5127     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
5128     try:
5129         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
5130         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
5131             secedit_data = fp.readlines()
5132         return secedit_data
5133     finally:
5134         if __salt__["file.file_exists"](f_exp):
5135             __salt__["file.remove"](f_exp)
5136 def _get_secedit_data(refresh=False):
5137     """
5138     Helper function that returns the secedit data in __context__ if it exists
5139     and puts the secedit data in __context__ if it does not.
5140     Args:
5141         refresh (bool):
5142             Refresh secedit data stored in __context__. This is needed for
5143             testing where the state is setting the value, but the module that
5144             is checking the value has its own __context__.
5145     Returns:
5146         str: secedit data from __context__
5147     """
5148     if "lgpo.secedit_data" not in __context__ or refresh is True:
5149         log.debug("LGPO: Loading secedit data")
5150         __context__["lgpo.secedit_data"] = _load_secedit_data()
5151     return __context__["lgpo.secedit_data"]
5152 def _get_secedit_value(option):
5153     """
5154     Helper function that looks for the passed option in the secedit data
5155     """
5156     secedit_data = _get_secedit_data()
5157     for _line in secedit_data:
5158         if _line.startswith(option):
5159             return _line.split("=")[1].strip()
5160     return "Not Defined"
5161 def _write_secedit_data(inf_data):
5162     """
5163     Helper function to write secedit data to the database
5164     """
5165     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
5166     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
5167     try:
5168         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
5169             fp.write(inf_data)
5170         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
5171         retcode = __salt__["cmd.retcode"](cmd)
5172         if not retcode == 0:
5173             log.debug("Secedit failed to import template data")
5174             return False
5175         cmd = ["secedit", "/configure", "/db", f_sdb]
5176         retcode = __salt__["cmd.retcode"](cmd)
5177         if not retcode == 0:
5178             log.debug("Secedit failed to apply security database")
5179             return False
5180         __context__.pop("lgpo.secedit_data", None)
5181         return True
5182     finally:
5183         if __salt__["file.file_exists"](f_inf):
5184             __salt__["file.remove"](f_inf)
5185 def _transform_value(value, policy, transform_type):
5186     """
5187     helper function to transform the policy value into something that more
5188     closely matches how the policy is displayed in the gpedit GUI
5189     """
5190     t_kwargs = {}
5191     if "Transform" in policy:
5192         if transform_type in policy["Transform"]:
5193             _policydata = _policy_info()
5194             if transform_type + "Args" in policy["Transform"]:
5195                 t_kwargs = policy["Transform"][transform_type + "Args"]
5196             return getattr(_policydata, policy["Transform"][transform_type])(
5197                 value, **t_kwargs
5198             )
5199         else:
5200             return value
5201     else:
5202         if "Registry" in policy:
5203             if value == "(value not set)":
5204                 return "Not Defined"
5205         return value
5206 def _validateSetting(value, policy):
5207     """
5208     helper function to validate specified value is appropriate for the policy
5209     if the 'Settings' key is a list, the value will check that it is in the list
5210     if the 'Settings' key is a dict we will try to execute the function name
5211         from the 'Function' key, passing the value and additional arguments from
5212         the 'Args' dict
5213     if the 'Settings' key is None, we won't do any validation and just return
5214         True
5215     if the Policy has 'Children', we'll validate their settings too
5216     """
5217     log.debug("validating %s for policy %s", value, policy)
5218     if "Settings" in policy:
5219         if policy["Settings"]:
5220             if isinstance(policy["Settings"], list):
5221                 if value not in policy["Settings"]:
5222                     return False
5223             elif isinstance(policy["Settings"], dict):
5224                 _policydata = _policy_info()
5225                 if not getattr(_policydata, policy["Settings"]["Function"])(
5226                     value, **policy["Settings"]["Args"]
5227                 ):
5228                     return False
5229     else:
5230         return True
5231     return True
5232 def _addAccountRights(sidObject, user_right):
5233     """
5234     helper function to add an account right to a user
5235     """
5236     try:
5237         if sidObject:
5238             _polHandle = win32security.LsaOpenPolicy(
5239                 None, win32security.POLICY_ALL_ACCESS
5240             )
5241             user_rights_list = [user_right]
5242             _ret = win32security.LsaAddAccountRights(
5243                 _polHandle, sidObject, user_rights_list
5244             )
5245         return True
5246     except Exception as e:  # pylint: disable=broad-except
5247         log.exception("Error attempting to add account right, exception was %s", e)
5248         return False
5249 def _delAccountRights(sidObject, user_right):
5250     """
5251     helper function to remove an account right from a user
5252     """
5253     try:
5254         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5255         user_rights_list = [user_right]
5256         _ret = win32security.LsaRemoveAccountRights(
5257             _polHandle, sidObject, False, user_rights_list
5258         )
5259         return True
5260     except Exception as e:  # pylint: disable=broad-except
5261         log.exception("Error attempting to delete account right")
5262         return False
5263 def _getRightsAssignments(user_right):
5264     """
5265     helper function to return all the user rights assignments/users
5266     """
5267     sids = []
5268     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5269     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5270     return sids
5271 def _getAdmlDisplayName(adml_xml_data, display_name):
5272     """
5273     helper function to take the 'displayName' attribute of an element and find
5274     the value from the ADML data
5275     adml_xml_data :: XML data of all ADML files to search
5276                     to search the ADML data for
5277     """
5278     if display_name<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.startswith("$(") and display_name.endswith(")"):
5279         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5280         display_name = display_name.split(".")
5281         displayname_type = display_name[</b></font>0]
5282         displayname_id = display_name[1]
5283         search_results = ADML_DISPLAY_NAME_XPATH(
5284             adml_xml_data,
5285             displayNameType=displayname_type,
5286             displayNameId=displayname_id,
5287         )
5288         if search_results:
5289             for result in search_results:
5290                 return result.text.strip()
5291     return None
5292 def _getAdmlPresentationRefId(adml_data, ref_id):
5293     """
5294     helper function to check for a presentation label for a policy element
5295     """
5296     search_results = adml_data.xpath(
5297         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5298     )
5299     alternate_label = ""
5300     if search_results:
5301         for result in search_results:
5302             the_localname = etree.QName(result.tag).localname
5303             if result.text is None:
5304                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5305                 if presentation_element:
5306                     presentation_element = presentation_element[0]
5307                     if TEXT_ELEMENT_XPATH(presentation_element):
5308                         for p_item in presentation_element:
5309                             if p_item == result:
5310                                 break
5311                             if etree.QName(p_item.tag).localname == "text":
5312                                 if getattr(p_item, "text"):
5313                                     alternate_label = getattr(p_item, "text").rstrip()
5314                         if alternate_label.endswith("."):
5315                             alternate_label = ""
5316             if the_localname in ["textBox", "comboBox"]:
5317                 label_items = result.xpath('.//*[local-name() = "label"]')
5318                 for label_item in label_items:
5319                     if label_item.text:
5320                         return label_item.text.rstrip().rstrip(":")
5321             elif the_localname in [
5322                 "decimalTextBox",
5323                 "longDecimalTextBox",
5324                 "dropdownList",
5325                 "listBox",
5326                 "checkBox",
5327                 "text",
5328                 "multiTextBox",
5329             ]:
5330                 if result.text:
5331                     return result.text.rstrip().rstrip(":")
5332                 else:
5333                     return alternate_label.rstrip(":")
5334     return None
5335 def _getFullPolicyName(
5336     policy_item, policy_name, return_full_policy_names, adml_language
5337 ):
5338     """
5339     helper function to retrieve the full policy name if needed
5340     """
5341     if policy_name in adm_policy_name_map[return_full_policy_names]:
5342         return adm_policy_name_map[return_full_policy_names][policy_name]
5343     adml_data = _get_policy_resources(language=adml_language)
5344     if return_full_policy_names and "displayName" in policy_item.attrib:
5345         fullPolicyName = _getAdmlDisplayName(
5346             adml_data, policy_item.attrib["displayName"]
5347         )
5348         if fullPolicyName:
5349             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5350             policy_name = fullPolicyName
5351     elif return_full_policy_names and "id" in policy_item.attrib:
5352         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5353         if fullPolicyName:
5354             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5355             policy_name = fullPolicyName
5356     policy_name = policy_name.rstrip(":").rstrip()
5357     return policy_name
5358 def _regexSearchRegPolData(search_string, policy_data):
5359     """
5360     Helper function to do a regex search of a string value in policy_data.
5361     This is used to search the policy data from a registry.pol file or from
5362     gpt.ini
5363     Args:
5364         search_string (str): The string to search for
5365         policy_data (str): The data to be searched
5366     Returns:
5367         bool: ``True`` if the regex search_string is found, otherwise ``False``
5368     """
5369     if policy_data:
5370         if search_string:
5371             match = re.search(search_string, policy_data, re.IGNORECASE)
5372             if match:
5373                 return True
5374     return False
5375 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5376     """
5377     helper function to do a search of Policy data from a registry.pol file
5378     returns the "data" field
5379     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
5380     [key;value;type;size;data]
5381     """
5382     value = None
5383     values = []
5384     encoded_semicolon = ";".encode("utf-16-le")
5385     if return_value_name:
5386         values = {}
5387     if search_string:
5388         registry = Registry()
5389         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5390             vtype = registry.vtype_reverse[
5391                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5392             ]
5393         else:
5394             vtype = None
5395         search_string = re.escape(search_string)
5396         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5397         if matches:
5398             for match in matches:
5399                 pol_entry <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= policy_data[
5400                     match.start() : (
5401                         policy_data.index("]".encode("utf-16-le"), match.end())
5402                     )
5403                 ].split(</b></font>encoded_semicolon, 4)
5404                 if len(pol_entry) &gt;= 2:
5405                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5406                 if len(pol_entry) &gt;= 5:
5407                     value = encoded_semicolon.join(pol_entry[4:])
5408                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5409                         if value:
5410                             if vtype == "REG_DWORD":
5411                                 for v in struct.unpack(b"I", value):
5412                                     value = v
5413                             elif vtype == "REG_QWORD":
5414                                 for v in struct.unpack(b"Q", value):
5415                                     value = v
5416                         else:
5417                             value = 0
5418                     elif vtype == "REG_MULTI_SZ":
5419                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5420                     else:
5421                         value = value.decode("utf-16-le").rstrip(chr(0))
5422                 if return_value_name:
5423                     log.trace("we want value names and the value")
5424                     values[valueName] = value
5425                 elif len(matches) &gt; 1:
5426                     log.trace("we have multiple matches, we will return a list")
5427                     values.append(value)
5428     if values:
5429         value = values
5430     return value
5431 def _checkListItem(
5432     policy_element,
5433     policy_name,
5434     policy_key,
5435     xpath_object,
5436     policy_file_data,
5437     test_items=True,
5438 ):
5439     """
5440     helper function to process an enabled/disabled/true/falseList set
5441     if test_items is True, it will determine if the policy is enabled or
5442     disabled returning True if all items are configured in the registry.pol file
5443     and false if they are not
5444     if test_items is False, the expected strings for the items will be returned
5445     as a list
5446     returns True if the enabled/disabledList is 100% configured in the
5447     registry.pol file, otherwise returns False
5448     """
5449     xpath_string = (
5450         './/*[local-name() = "decimal" or local-name() = "delete"'
5451         ' or local-name() = "longDecimal" or local-name() = "string"]'
5452     )
5453     value_item_child_xpath = etree.XPath(xpath_string)
5454     expected_strings = []
5455     for list_element in xpath_object(policy_element):
5456         configured_items = 0
5457         required_items = 0
5458         for item in list_element:
5459             required_items = required_items + 1
5460             if "key" in item.attrib:
5461                 item_key = item.attrib["key"]
5462             else:
5463                 item_key = policy_key
5464             if "valueName" in item.attrib:
5465                 item_valuename = item.attrib["valueName"]
5466             else:
5467                 log.error(
5468                     "%s item with attributes %s in policy %s does not "
5469                     'have the required "valueName" attribute',
5470                     etree.QName(list_element).localname,
5471                     item.attrib,
5472                     policy_element.attrib,
5473                 )
5474                 break
5475             for value_item in value_item_child_xpath(item):
5476                 search_string = _processValueItem(
5477                     value_item, item_key, item_valuename, policy_element, item
5478                 )
5479                 if test_items:
5480                     if _regexSearchRegPolData(
5481                         re.escape(search_string), policy_file_data
5482                     ):
5483                         configured_items = configured_items + 1
5484                         log.trace(
5485                             "found the search string in the pol file,"
5486                             "%s of %s items for policy %s are "
5487                             "configured in registry.pol",
5488                             configured_items,
5489                             required_items,
5490                             policy_name,
5491                         )
5492                 else:
5493                     expected_strings.append(search_string)
5494         if test_items:
5495             if required_items &gt; 0 and required_items == configured_items:
5496                 log.trace("%s all items are set", policy_name)
5497                 return True
5498     if test_items:
5499         return False
5500     else:
5501         return expected_strings
5502 def _checkValueItemParent(
5503     policy_element,
5504     policy_name,
5505     policy_key,
5506     policy_valueName,
5507     xpath_object,
5508     policy_file_data,
5509     check_deleted=False,
5510     test_item=True,
5511 ):
5512     """
5513     helper function to process the parent of a value item object
5514     if test_item is True, it will determine if the policy is enabled/disabled
5515     returns True if the value is configured in the registry.pol file, otherwise returns False
5516     if test_item is False, the expected search string will be returned
5517     value type parents:
5518         boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx
5519         enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx
5520         disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx
5521     """
5522     for element in xpath_object(policy_element):
5523         for value_item in element:
5524             search_string = _processValueItem(
5525                 value_item,
5526                 policy_key,
5527                 policy_valueName,
5528                 policy_element,
5529                 element,
5530                 check_deleted=check_deleted,
5531             )
5532             if not test_item:
5533                 return search_string
5534             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5535                 log.trace(
5536                     "found the search string in the pol file, %s is configured",
5537                     policy_name,
5538                 )
5539                 return True
5540     return False
5541 def _encode_string(value):
5542     encoded_null = chr(0).encode("utf-16-le")
5543     if value is None:
5544         return encoded_null
5545     elif not isinstance(value, str):
5546         raise TypeError(
5547             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5548         )
5549     return b"".join([value.encode("utf-16-le"), encoded_null])
5550 def _buildKnownDataSearchString(
5551     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5552 ):
5553     """
5554     helper function similar to _processValueItem to build a search string for a
5555     known key/value/type/data
5556     """
5557     registry = Registry()
5558     this_element_value = None
5559     expected_string = b""
5560     encoded_semicolon = ";".encode("utf-16-le")
5561     encoded_null = chr(0).encode("utf-16-le")
5562     if reg_key:
5563         reg_key = reg_key.encode("utf-16-le")
5564     if reg_valueName:
5565         reg_valueName = reg_valueName.encode("utf-16-le")
5566     if reg_data and not check_deleted:
5567         if reg_vtype == "REG_DWORD":
5568             this_element_value = struct.pack(b"I", int(reg_data))
5569         elif reg_vtype == "REG_QWORD":
5570             this_element_value = struct.pack(b"Q", int(reg_data))
5571         elif reg_vtype == "REG_SZ":
5572             this_element_value = _encode_string(reg_data)
5573     if check_deleted:
5574         reg_vtype = "REG_SZ"
5575         expected_string = b"".join(
5576             [
5577                 "[".encode("utf-16-le"),
5578                 reg_key,
5579                 encoded_null,
5580                 encoded_semicolon,
5581                 "**del.".encode("utf-16-le"),
5582                 encoded_null,
5583                 encoded_semicolon,
5584                 chr(registry.vtype[reg_vtype]).encode<font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("utf-32-le"),
5585                 encoded_semicolon,
5586                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
5587                 encoded_semicolon,
5588                 " ".encode(</b></font>"utf-16-le"),
5589                 encoded_null,
5590                 "]".encode("utf-16-le"),
5591             ]
5592         )
5593     else:
5594         expected_string = b"".join(
5595             [
5596                 "[".encode("utf-16-le"),
5597                 reg_key,
5598                 encoded_null,
5599                 encoded_semicolon,
5600                 reg_valueName,
5601                 encoded_null,
5602                 encoded_semicolon,
5603                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5604                 encoded_semicolon,
5605                 chr(len(this_element_value)).encode("utf-32-le"),
5606                 encoded_semicolon,
5607                 this_element_value,
5608                 "]".encode("utf-16-le"),
5609             ]
5610         )
5611     return expected_string
5612 def _processValueItem(
5613     element,
5614     reg_key,
5615     reg_valuename,
5616     policy,
5617     parent_element,
5618     check_deleted=False,
5619     this_element_value=None,
5620 ):
5621     """
5622     helper function to process a value type item and generate the expected
5623     string in the Registry.pol file
5624     element - the element to process
5625     reg_key - the registry key associated with the element (some inherit from
5626               their parent policy)
5627     reg_valuename - the registry valueName associated with the element (some
5628                     inherit from their parent policy)
5629     policy - the parent policy element
5630     parent_element - the parent element (primarily passed in to differentiate
5631                      children of "elements" objects
5632     check_deleted - if the returned expected string should be for a deleted
5633                     value
5634     this_element_value - a specific value to place into the expected string
5635                          returned for "elements" children whose values are
5636                          specified by the user
5637     """
5638     registry = Registry()
5639     expected_string = None
5640     this_vtype = "REG_SZ"
5641     encoded_semicolon = ";".encode("utf-16-le")
5642     encoded_null = chr(0).encode("utf-16-le")
5643     if reg_key:
5644         reg_key = reg_key.encode("utf-16-le")
5645     if reg_valuename:
5646         reg_valuename = reg_valuename.encode("utf-16-le")
5647     if (
5648         etree.QName(element).localname == "decimal"
5649         and etree.QName(parent_element).localname != "elements"
5650     ):
5651         this_vtype = "REG_DWORD"
5652         if "value" in element.attrib:
5653             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5654         else:
5655             log.error(
5656                 "The %s child %s element for the policy with "
5657                 'attributes: %s does not have the required "value" '
5658                 "attribute. The element attributes are: %s",
5659                 etree.QName(parent_element).localname,
5660                 etree.QName(element).localname,
5661                 policy.attrib,
5662                 element.attrib,
5663             )
5664             return None
5665     elif (
5666         etree.QName(element).localname == "longDecimal"
5667         and etree.QName(parent_element).localname != "elements"
5668     ):
5669         this_vtype = "REG_QWORD"
5670         if "value" in element.attrib:
5671             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5672         else:
5673             log.error(
5674                 "The %s child %s element for the policy with "
5675                 'attributes: %s does not have the required "value" '
5676                 "attribute. The element attributes are: %s",
5677                 etree.QName(parent_element).localname,
5678                 etree.QName(element).localname,
5679                 policy.attrib,
5680                 element.attrib,
5681             )
5682             return None
5683     elif etree.QName(element).localname == "string":
5684         this_vtype = "REG_SZ"
5685         this_element_value = _encode_string(element.text)
5686     elif etree.QName(parent_element).localname == "elements":
5687         standard_element_expected_string = True
5688         if etree.QName(element).localname == "boolean":
5689             if this_element_value is False:
5690                 check_deleted = True
5691             if not check_deleted:
5692                 this_vtype = "REG_DWORD"
5693             this_element_value = struct.pack("I", 1)
5694             standard_element_expected_string = False
5695         elif etree.QName(element).localname == "decimal":
5696             this_vtype = "REG_DWORD"
5697             requested_val = this_element_value
5698             if this_element_value is not None:
5699                 this_element_value = struct.pack(b"I", int(this_element_value))
5700             if "storeAsText" in element.attrib:
5701                 if element.attrib["storeAsText"].lower() == "true":
5702                     this_vtype = "REG_SZ"
5703                     if requested_val is not None:
5704                         this_element_value = str(requested_val).encode("utf-16-le")
5705             if check_deleted:
5706                 this_vtype = "REG_SZ"
5707         elif etree.QName(element).localname == "longDecimal":
5708             this_vtype = "REG_QWORD"
5709             requested_val = this_element_value
5710             if this_element_value is not None:
5711                 this_element_value = struct.pack(b"Q", int(this_element_value))
5712             if "storeAsText" in element.attrib:
5713                 if element.attrib["storeAsText"].lower() == "true":
5714                     this_vtype = "REG_SZ"
5715                     if requested_val is not None:
5716                         this_element_value = str(requested_val).encode("utf-16-le")
5717         elif etree.QName(element).localname == "text":
5718             this_vtype = "REG_SZ"
5719             if "expandable" in element.attrib:
5720                 if element.attrib["expandable"].lower() == "true":
5721                     this_vtype = "REG_EXPAND_SZ"
5722             if this_element_value is not None:
5723                 this_element_value = _encode_string(this_element_value)
5724         elif etree.QName(element).localname == "multiText":
5725             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5726             if this_element_value is not None:
5727                 this_element_value = "{0}{1}{1}".format(
5728                     chr(0).join(this_element_value), chr(0)
5729                 )
5730         elif etree.QName(element).localname == "list":
5731             standard_element_expected_string = False
5732             del_keys = b""
5733             element_valuenames = []
5734             element_values = this_element_value
5735             if this_element_value is not None:
5736                 element_valuenames = [
5737                     str(z) for z in range(1, len(this_element_value) + 1)
5738                 ]
5739             if "additive" in element.attrib:
5740                 if element.attrib["additive"].lower() == "false":
5741                     del_keys = b"".join(
5742                         [
5743                             "[".encode("utf-16-le"),
5744                             reg_key,
5745                             encoded_null,
5746                             encoded_semicolon,
5747                             "**delvals.".encode("utf-16-le"),
5748                             encoded_null,
5749                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5750                             encoded_semicolon,
5751                             chr(len<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5752                                 "utf-32-le"
5753                             ),
5754                             encoded_semicolon,
5755                             " ".encode("utf-16-le"),
5756                             encoded_null,
5757                             "]".encode(</b></font>"utf-16-le"),
5758                         ]
5759                     )
5760             if "expandable" in element.attrib:
5761                 this_vtype = "REG_EXPAND_SZ"
5762             if element.attrib.get("explicitValue", "false").lower() == "true":
5763                 if this_element_value is not None:
5764                     element_valuenames = [str(k) for k in this_element_value.keys()]
5765                     element_values = [str(v) for v in this_element_value.values()]
5766             elif "valuePrefix" in element.attrib:
5767                 if element.attrib["valuePrefix"] != "":
5768                     if this_element_value is not None:
5769                         element_valuenames = [
5770                             "{}{}".format(element.attrib["valuePrefix"], k)
5771                             for k in element_valuenames
5772                         ]
5773             else:
5774                 if element_values is not None:
5775                     element_valuenames = [str(z) for z in element_values]
5776             if not check_deleted:
5777                 if this_element_value is not None:
5778                     log.trace(
5779                         "_processValueItem has an explicit element_value of %s",
5780                         this_element_value,
5781                     )
5782                     expected_string = del_keys
5783                     log.trace(
5784                         "element_valuenames == %s and element_values == %s",
5785                         element_valuenames,
5786                         element_values,
5787                     )
5788                     for i, item in enumerate(element_valuenames):
5789                         expected_string = expected_string + b"".join(
5790                             [
5791                                 "[".encode("utf-16-le"),
5792                                 reg_key,
5793                                 encoded_null,
5794                                 encoded_semicolon,
5795                                 element_valuenames[i].encode("utf-16-le"),
5796                                 encoded_null,
5797                                 encoded_semicolon,
5798                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5799                                 encoded_semicolon,
5800                                 chr(
5801                                     len(
5802                                         "{}{}".format(element_values[i], chr(0)).encode(
5803                                             "utf-16-le"
5804                                         )
5805                                     )
5806                                 ).encode("utf-32-le"),
5807                                 encoded_semicolon,
5808                                 _encode_string(element_values[i]),
5809                                 "]".encode("utf-16-le"),
5810                             ]
5811                         )
5812                 else:
5813                     expected_string = del_keys + b"".join(
5814                         [
5815                             "[".encode("utf-16-le"),
5816                             reg_key,
5817                             encoded_null,
5818                             encoded_semicolon,
5819                         ]
5820                     )
5821             else:
5822                 expected_string = b"".join(
5823                     [
5824                         "[".encode("utf-16-le"),
5825                         reg_key,
5826                         encoded_null,
5827                         encoded_semicolon,
5828                         "**delvals.".encode("utf-16-le"),
5829                         encoded_null,
5830                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5831                         encoded_semicolon,
5832                         chr(len<font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5833                             "utf-32-le"
5834                         ),
5835                         encoded_semicolon,
5836                         " ".encode("utf-16-le"),
5837                         encoded_null,
5838                         "]".encode(</b></font>"utf-16-le"),
5839                     ]
5840                 )
5841         elif etree.QName(element).localname == "enum":
5842             if this_element_value is not None:
5843                 pass
5844         if standard_element_expected_string and not check_deleted:
5845             if this_element_value is not None:
5846                 if isinstance(this_element_value, str):
5847                     log.debug("Converting %s to bytes", this_element_value)
5848                     this_element_value = this_element_value.encode("utf-32-le")
5849                 expected_string = b"".join(
5850                     [
5851                         "[".encode("utf-16-le"),
5852                         reg_key,
5853                         encoded_null,
5854                         encoded_semicolon,
5855                         reg_valuename,
5856                         encoded_null,
5857                         encoded_semicolon,
5858                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5859                         encoded_semicolon,
5860                         chr(len(this_element_value)).encode("utf-32-le"),
5861                         encoded_semicolon,
5862                         this_element_value,
5863                         "]".encode("utf-16-le"),
5864                     ]
5865                 )
5866             else:
5867                 expected_string = b"".join(
5868                     [
5869                         "[".encode("utf-16-le"),
5870                         reg_key,
5871                         encoded_null,
5872                         encoded_semicolon,
5873                         reg_valuename,
5874                         encoded_null,
5875                         encoded_semicolon,
5876                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5877                         encoded_semicolon,
5878                     ]
5879                 )
5880     if not expected_string:
5881         if etree.QName(element).localname == "delete" or check_deleted:
5882             expected_string = b"".join(
5883                 [
5884                     "[".encode("utf-16-le"),
5885                     reg_key,
5886                     encoded_null,
5887                     encoded_semicolon,
5888                     "**del.".encode("utf-16-le"),
5889                     reg_valuename,
5890                     encoded_null,
5891                     encoded_semicolon,
5892                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5893                     encoded_semicolon,
5894                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5895                         "utf-32-le"
5896                     ),
5897                     encoded_semicolon,
5898                     " ".encode("utf-16-le"),
5899                     encoded_null,
5900                     "]".encode("utf-16-le"),
5901                 ]
5902             )
5903         else:
5904             expected_string = b"".join(
5905                 [
5906                     "[".encode("utf-16-le"),
5907                     reg_key,
5908                     encoded_null,
5909                     encoded_semicolon,
5910                     reg_valuename,
5911                     encoded_null,
5912                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5913                     encoded_semicolon,
5914                     chr(len<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(this_element_value)).encode("utf-32-le"),
5915                     encoded_semicolon,
5916                     this_element_value,
5917                     "]".encode("utf-16-le"),
5918                 ]
5919             )
5920     return expected_string
5921 def _checkAllAdmxPolicies(
5922     policy_class,
5923     adml_language="en-US",
5924     return_full_policy_names=False,
5925     hierarchical_return=False,
5926     return_not_configured=</b></font>False,
5927 ):
5928     """
5929     rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of
5930     looking only at the contents of the file, we're going to loop through every
5931     policy and look in the registry.pol file to determine if it is
5932     enabled/disabled/not configured
5933     """
5934     log.trace("POLICY CLASS == %s", policy_class)
5935     module_policy_data = _policy_info()
5936     policy_file_data = _read_regpol_file(
5937         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
5938     )
5939     admx_policies = []
5940     policy_vals = {}
5941     hierarchy = {}
5942     full_names = {}
5943     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5944     adml_policy_resources = _get_policy_resources(language=adml_language)
5945     if policy_file_data:
5946         log.trace("POLICY CLASS %s has file data", policy_class)
5947         policy_filedata_split = re.sub(
5948             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
5949             b"",
5950                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
5951                 b"",
5952                 re<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.sub(
5953                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
5954                     b"",
5955                     policy_file_data,
5956                 ),
5957             ),
5958         ).split("][".encode("utf-16-le"))
5959         log.trace("Searching %s policies...", len(</b></font>policy_filedata_split))
5960         start_time = time.time()
5961         for policy_item in policy_filedata_split:
5962             policy_item_key = (
5963                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
5964                 .decode("utf-16-le")
5965                 .lower()
5966             )
5967             if policy_item_key:
5968                 admx_items = REGKEY_XPATH(
5969                     admx_policy_definitions, keyvalue=policy_item_key
5970                 )
5971                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
5972                 for admx_item in admx_items:
5973                     if etree.QName(admx_item).localname == "policy":
5974                         if admx_item not in admx_policies:
5975                             admx_policies.append(admx_item)
5976                     else:
5977                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
5978                             if policy_item not in admx_policies:
5979                                 admx_policies.append(policy_item)
5980         log.trace("Search complete: %s seconds", time.time() - start_time)
5981         if return_not_configured:
5982             log.trace("Gathering non configured policies")
5983             start_time = time.time()
5984             not_configured_policies = ALL_CLASS_POLICY_XPATH(
5985                 admx_policy_definitions, registry_class=policy_class
5986             )
5987             for policy_item in admx_policies:
5988                 if policy_item in not_configured_policies:
5989                     not_configured_policies.remove(policy_item)
5990             for not_configured_policy in not_configured_policies:
5991                 not_configured_policy_namespace = not_configured_policy.nsmap[
5992                     not_configured_policy.prefix
5993                 ]
5994                 if not_configured_policy_namespace not in policy_vals:
5995                     policy_vals[not_configured_policy_namespace] = {}
5996                 policy_vals[not_configured_policy_namespace][
5997                     not_configured_policy.attrib["name"]
5998                 ] = "Not Configured"
5999                 if return_full_policy_names:
6000                     if not_configured_policy_namespace not in full_names:
6001                         full_names[not_configured_policy_namespace] = {}
6002                     full_names[not_configured_policy_namespace][
6003                         not_configured_policy.attrib["name"]
6004                     ] = _getFullPolicyName(
6005                         policy_item=not_configured_policy,
6006                         policy_name=not_configured_policy.attrib["name"],
6007                         return_full_policy_names=return_full_policy_names,
6008                         adml_language=adml_language,
6009                     )
6010                 log.trace(
6011                     "building hierarchy for non-configured item %s",
6012                     not_configured_policy.attrib["name"],
6013                 )
6014                 if not_configured_policy_namespace not in hierarchy:
6015                     hierarchy[not_configured_policy_namespace] = {}
6016                 hierarchy[not_configured_policy_namespace][
6017                     not_configured_policy.attrib["name"]
6018                 ] = _build_parent_list(
6019                     policy_definition=not_configured_policy,
6020                     return_full_policy_names=return_full_policy_names,
6021                     adml_language=adml_language,
6022                 )
6023             log.trace("Gathering complete: %s seconds", time.time() - start_time)
6024         log.trace("Examining %s policies...", len(admx_policies))
6025         start_time = time.time()
6026         for admx_policy in admx_policies:
6027             this_valuename = None
6028             this_policy_setting = "Not Configured"
6029             element_only_enabled_disabled = True
6030             explicit_enable_disable_value_setting = False
6031             if "key" in admx_policy.attrib:
6032                 this_key = admx_policy.attrib["key"]
6033             else:
6034                 log.error(
6035                     'policy item %s does not have the required "key" attribute',
6036                     admx_policy.attrib,
6037                 )
6038                 break
6039             if "valueName" in admx_policy.attrib:
6040                 this_valuename = admx_policy.attrib["valueName"]
6041             if "name" in admx_policy.attrib:
6042                 this_policyname = admx_policy.attrib["name"]
6043             else:
6044                 log.error(
6045                     'policy item %s does not have the required "name" attribute',
6046                     admx_policy.attrib,
6047                 )
6048                 break
6049             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
6050             if (
6051                 ENABLED_VALUE_XPATH(admx_policy)
6052                 and this_policy_setting == "Not Configured"
6053             ):
6054                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6055                     admx_policy
6056                 ):
6057                     element_only_enabled_disabled = False
6058                     explicit_enable_disable_value_setting = True
6059                 if _checkValueItemParent(
6060                     admx_policy,
6061                     this_policyname,
6062                     this_key,
6063                     this_valuename,
6064                     ENABLED_VALUE_XPATH,
6065                     policy_file_data,
6066                 ):
6067                     this_policy_setting = "Enabled"
6068                     log.trace(
6069                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
6070                     )
6071                     if this_policynamespace not in policy_vals:
6072                         policy_vals[this_policynamespace] = {}
6073                     policy_vals[this_policynamespace][
6074                         this_policyname
6075                     ] = this_policy_setting
6076             if (
6077                 DISABLED_VALUE_XPATH(admx_policy)
6078                 and this_policy_setting == "Not Configured"
6079             ):
6080                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6081                     element_only_enabled_disabled = False
6082                     explicit_enable_disable_value_setting = True
6083                 if _checkValueItemParent(
6084                     admx_policy,
6085                     this_policyname,
6086                     this_key,
6087                     this_valuename,
6088                     DISABLED_VALUE_XPATH,
6089                     policy_file_data,
6090                 ):
6091                     this_policy_setting = "Disabled"
6092                     log.trace(
6093                         "%s is disabled by detected DISABLED_VALUE_XPATH",
6094                         this_policyname,
6095                     )
6096                     if this_policynamespace not in policy_vals:
6097                         policy_vals[this_policynamespace] = {}
6098                     policy_vals[this_policynamespace][
6099                         this_policyname
6100                     ] = this_policy_setting
6101             if (
6102                 ENABLED_LIST_XPATH(admx_policy)
6103                 and this_policy_setting == "Not Configured"
6104             ):
6105                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6106                     admx_policy
6107                 ):
6108                     element_only_enabled_disabled = False
6109                     explicit_enable_disable_value_setting = True
6110                 if _checkListItem(
6111                     admx_policy,
6112                     this_policyname,
6113                     this_key,
6114                     ENABLED_LIST_XPATH,
6115                     policy_file_data,
6116                 ):
6117                     this_policy_setting = "Enabled"
6118                     log.trace(
6119                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
6120                     )
6121                     if this_policynamespace not in policy_vals:
6122                         policy_vals[this_policynamespace] = {}
6123                     policy_vals[this_policynamespace][
6124                         this_policyname
6125                     ] = this_policy_setting
6126             if (
6127                 DISABLED_LIST_XPATH(admx_policy)
6128                 and this_policy_setting == "Not Configured"
6129             ):
6130                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6131                     element_only_enabled_disabled = False
6132                     explicit_enable_disable_value_setting = True
6133                 if _checkListItem(
6134                     admx_policy,
6135                     this_policyname,
6136                     this_key,
6137                     DISABLED_LIST_XPATH,
6138                     policy_file_data,
6139                 ):
6140                     this_policy_setting = "Disabled"
6141                     log.trace(
6142                         "%s is disabled by detected DISABLED_LIST_XPATH",
6143                         this_policyname,
6144                     )
6145                     if this_policynamespace not in policy_vals:
6146                         policy_vals[this_policynamespace] = {}
6147                     policy_vals[this_policynamespace][
6148                         this_policyname
6149                     ] = this_policy_setting
6150             if not explicit_enable_disable_value_setting and this_valuename:
6151                 if _regexSearchRegPolData(
6152                     re.escape(
6153                         _buildKnownDataSearchString(
6154                             this_key, this_valuename, "REG_DWORD", "1"
6155                         )
6156                     ),
6157                     policy_file_data,
6158                 ):
6159                     this_policy_setting = "Enabled"
6160                     log.trace(
6161                         "%s is enabled by no explicit enable/disable list or value",
6162                         this_policyname,
6163                     )
6164                     if this_policynamespace not in policy_vals:
6165                         policy_vals[this_policynamespace] = {}
6166                     policy_vals[this_policynamespace][
6167                         this_policyname
6168                     ] = this_policy_setting
6169                 elif _regexSearchRegPolData(
6170                     re.escape(
6171                         _buildKnownDataSearchString(
6172                             this_key,
6173                             this_valuename,
6174                             "REG_DWORD",
6175                             None,
6176                             check_deleted=True,
6177                         )
6178                     ),
6179                     policy_file_data,
6180                 ):
6181                     this_policy_setting = "Disabled"
6182                     log.trace(
6183                         "%s is disabled by no explicit enable/disable list or value",
6184                         this_policyname,
6185                     )
6186                     if this_policynamespace not in policy_vals:
6187                         policy_vals[this_policynamespace] = {}
6188                     policy_vals[this_policynamespace][
6189                         this_policyname
6190                     ] = this_policy_setting
6191             if ELEMENTS_XPATH(admx_policy):
6192                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
6193                     required_elements = {}
6194                     configured_elements = {}
6195                     policy_disabled_elements = 0
6196                     for elements_item in ELEMENTS_XPATH(admx_policy):
6197                         for child_item in elements_item:
6198                             this_element_name = _getFullPolicyName(
6199                                 policy_item=child_item,
6200                                 policy_name=child_item.attrib["id"],
6201                                 return_full_policy_names=return_full_policy_names,
6202                                 adml_language=adml_language,
6203                             )
6204                             required_elements[this_element_name] = None
6205                             child_key = child_item.attrib.get("key", this_key)
6206                             child_valuename = child_item.attrib.get(
6207                                 "valueName", this_valuename
6208                             )
6209                             if etree.QName(child_item).localname == "boolean":
6210                                 if child_item is not None:
6211                                     if (
6212                                         TRUE_VALUE_XPATH(child_item)
6213                                         and this_element_name not in configured_elements
6214                                     ):
6215                                         if _checkValueItemParent(
6216                                             child_item,
6217                                             this_policyname,
6218                                             child_key,
6219                                             child_valuename,
6220                                             TRUE_VALUE_XPATH,
6221                                             policy_file_data,
6222                                         ):
6223                                             configured_elements[
6224                                                 this_element_name
6225                                             ] = True
6226                                             log.trace(
6227                                                 "element %s is configured true",
6228                                                 child_item.attrib["id"],
6229                                             )
6230                                     if (
6231                                         FALSE_VALUE_XPATH(child_item)
6232                                         and this_element_name not in configured_elements
6233                                     ):
6234                                         if _checkValueItemParent(
6235                                             child_item,
6236                                             this_policyname,
6237                                             child_key,
6238                                             child_valuename,
6239                                             FALSE_VALUE_XPATH,
6240                                             policy_file_data,
6241                                         ):
6242                                             configured_elements[
6243                                                 this_element_name
6244                                             ] = False
6245                                             policy_disabled_elements = (
6246                                                 policy_disabled_elements + 1
6247                                             )
6248                                             log.trace(
6249                                                 "element %s is configured false",
6250                                                 child_item.attrib["id"],
6251                                             )
6252                                     if (
6253                                         TRUE_LIST_XPATH(child_item)
6254                                         and this_element_name not in configured_elements
6255                                     ):
6256                                         log.trace("checking trueList")
6257                                         if _checkListItem(
6258                                             child_item,
6259                                             this_policyname,
6260                                             this_key,
6261                                             TRUE_LIST_XPATH,
6262                                             policy_file_data,
6263                                         ):
6264                                             configured_elements[
6265                                                 this_element_name
6266                                             ] = True
6267                                             log.trace(
6268                                                 "element %s is configured true",
6269                                                 child_item.attrib["id"],
6270                                             )
6271                                     if (
6272                                         FALSE_LIST_XPATH(child_item)
6273                                         and this_element_name not in configured_elements
6274                                     ):
6275                                         log.trace("checking falseList")
6276                                         if _checkListItem(
6277                                             child_item,
6278                                             this_policyname,
6279                                             this_key,
6280                                             FALSE_LIST_XPATH,
6281                                             policy_file_data,
6282                                         ):
6283                                             configured_elements[
6284                                                 this_element_name
6285                                             ] = False
6286                                             policy_disabled_elements = (
6287                                                 policy_disabled_elements + 1
6288                                             )
6289                                             log.trace(
6290                                                 "element %s is configured false",
6291                                                 child_item.attrib["id"],
6292                                             )
6293                                 else:
6294                                     if _regexSearchRegPolData(
6295                                         re.escape(
6296                                             _processValueItem(
6297                                                 child_item,
6298                                                 child_key,
6299                                                 child_valuename,
6300                                                 admx_policy,
6301                                                 elements_item,
6302                                                 check_deleted=True,
6303                                             )
6304                                         ),
6305                                         policy_file_data,
6306                                     ):
6307                                         configured_elements[this_element_name] = False
6308                                         policy_disabled_elements = (
6309                                             policy_disabled_elements + 1
6310                                         )
6311                                         log.trace(
6312                                             "element %s is configured false",
6313                                             child_item.attrib["id"],
6314                                         )
6315                                     elif _regexSearchRegPolData(
6316                                         re.escape(
6317                                             _processValueItem(
6318                                                 child_item,
6319                                                 child_key,
6320                                                 child_valuename,
6321                                                 admx_policy,
6322                                                 elements_item,
6323                                                 check_deleted=False,
6324                                             )
6325                                         ),
6326                                         policy_file_data,
6327                                     ):
6328                                         log.trace(
6329                                             "element %s is configured true",
6330                                             child_item.attrib["<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>id"],
6331                                         )
6332                             elif (
6333                                 etree.QName(child_item).localname == "decimal"
6334                                 or etree.QName(child_item).localname == "text"
6335                                 or etree.QName(child_item).localname == "longDecimal"
6336                                 or etree.QName(child_item).</b></font>localname == "multiText"
6337                             ):
6338                                 if _regexSearchRegPolData(
6339                                     re.escape(
6340                                         _processValueItem(
6341                                             child_item,
6342                                             child_key,
6343                                             child_valuename,
6344                                             admx_policy,
6345                                             elements_item,
6346                                             check_deleted=True,
6347                                         )
6348                                     ),
6349                                     policy_file_data,
6350                                 ):
6351                                     configured_elements[this_element_name] = "Disabled"
6352                                     policy_disabled_elements = (
6353                                         policy_disabled_elements + 1
6354                                     )
6355                                     log.trace(
6356                                         "element %s is disabled",
6357                                         child_item.attrib["id"],
6358                                     )
6359                                 elif _regexSearchRegPolData(
6360                                     re.escape(
6361                                         _processValueItem(
6362                                             child_item,
6363                                             child_key,
6364                                             child_valuename,
6365                                             admx_policy,
6366                                             elements_item,
6367                                             check_deleted=False,
6368                                         )
6369                                     ),
6370                                     policy_file_data,
6371                                 ):
6372                                     configured_value = _getDataFromRegPolData(
6373                                         _processValueItem(
6374                                             child_item,
6375                                             child_key,
6376                                             child_valuename,
6377                                             admx_policy,
6378                                             elements_item,
6379                                             check_deleted=False,
6380                                         ),
6381                                         policy_file_data,
6382                                     )
6383                                     configured_elements[
6384                                         this_element_name
6385                                     ] = configured_value
6386                                     log.trace(
6387                                         "element %s is enabled, value == %s",
6388                                         child_item.attrib["id"],
6389                                         configured_value,
6390                                     )
6391                             elif etree.QName(child_item).localname == "enum":
6392                                 if _regexSearchRegPolData(
6393                                     re.escape(
6394                                         _processValueItem(
6395                                             child_item,
6396                                             child_key,
6397                                             child_valuename,
6398                                             admx_policy,
6399                                             elements_item,
6400                                             check_deleted=True,
6401                                         )
6402                                     ),
6403                                     policy_file_data,
6404                                 ):
6405                                     log.trace(
6406                                         "enum element %s is disabled",
6407                                         child_item.attrib["id"],
6408                                     )
6409                                     configured_elements[this_element_name] = "Disabled"
6410                                     policy_disabled_elements = (
6411                                         policy_disabled_elements + 1
6412                                     )
6413                                 else:
6414                                     for enum_item in child_item:
6415                                         if _checkValueItemParent(
6416                                             enum_item,
6417                                             child_item.attrib["id"],
6418                                             child_key,
6419                                             child_valuename,
6420                                             VALUE_XPATH,
6421                                             policy_file_data,
6422                                         ):
6423                                             if VALUE_LIST_XPATH(enum_item):
6424                                                 log.trace("enum item has a valueList")
6425                                                 if _checkListItem(
6426                                                     enum_item,
6427                                                     this_policyname,
6428                                                     child_key,
6429                                                     VALUE_LIST_XPATH,
6430                                                     policy_file_data,
6431                                                 ):
6432                                                     log.trace(
6433                                                         "all valueList items exist in"
6434                                                         " file"
6435                                                     )
6436                                                     configured_elements[
6437                                                         this_element_name
6438                                                     ] = _getAdmlDisplayName(
6439                                                         adml_policy_resources,
6440                                                         enum_item.attrib["displayName"],
6441                                                     )
6442                                                     break
6443                                             else:
6444                                                 configured_elements[
6445                                                     this_element_name
6446                                                 ] = _getAdmlDisplayName(
6447                                                     adml_policy_resources,
6448                                                     enum_item.attrib["displayName"],
6449                                                 )
6450                                                 break
6451                             elif etree.QName(child_item).localname == "list":
6452                                 return_value_name = False
6453                                 if (
6454                                     "explicitValue" in child_item.attrib
6455                                     and child_item.attrib["explicitValue"].lower()
6456                                     == "true"
6457                                 ):
6458                                     log.trace(
6459                                         "explicitValue list, we will return value names"
6460                                     )
6461                                     return_value_name = True
6462                                 regex_str = [
6463                                     r"(?!\*",
6464                                     r"\*",
6465                                     "D",
6466                                     "e",
6467                                     "l",
6468                                     "V",
6469                                     "a",
6470                                     "l",
6471                                     "s",
6472                                     r"\.",
6473                                     ")",
6474                                 ]
6475                                 delvals_regex = "\x00".join(regex_str)
6476                                 delvals_regex = salt.utils.stringutils.to_bytes(
6477                                     delvals_regex
6478                                 )
6479                                 if _regexSearchRegPolData(
6480                                     re.escape(
6481                                         _processValueItem(
6482                                             child_item,
6483                                             child_key,
6484                                             child_valuename,
6485                                             admx_policy,
6486                                             elements_item,
6487                                             check_deleted=False,
6488                                         )
6489                                     )
6490                                     + delvals_regex,
6491                                     policy_file_data,
6492                                 ):
6493                                     configured_value = _getDataFromRegPolData(
6494                                         _processValueItem(
6495                                             child_item,
6496                                             child_key,
6497                                             child_valuename,
6498                                             admx_policy,
6499                                             elements_item,
6500                                             check_deleted=False,
6501                                         ),
6502                                         policy_file_data,
6503                                         return_value_name=return_value_name,
6504                                     )
6505                                     configured_elements[
6506                                         this_element_name
6507                                     ] = configured_value
6508                                     log.trace(
6509                                         "element %s is enabled values: %s",
6510                                         child_item.attrib["id"],
6511                                         configured_value,
6512                                     )
6513                                 elif _regexSearchRegPolData(
6514                                     re.escape(
6515                                         _processValueItem(
6516                                             child_item,
6517                                             child_key,
6518                                             child_valuename,
6519                                             admx_policy,
6520                                             elements_item,
6521                                             check_deleted=True,
6522                                         )
6523                                     ),
6524                                     policy_file_data,
6525                                 ):
6526                                     configured_elements[this_element_name] = "Disabled"
6527                                     policy_disabled_elements = (
6528                                         policy_disabled_elements + 1
6529                                     )
6530                                     log.trace(
6531                                         "element %s is disabled",
6532                                         child_item.attrib["id"],
6533                                     )
6534                     if element_only_enabled_disabled:
6535                         if len(required_elements.keys()) &gt; 0 and len(
6536                             configured_elements.keys()
6537                         ) == len(required_elements.keys()):
6538                             if policy_disabled_elements == len(
6539                                 required_elements.keys()
6540                             ):
6541                                 log.trace(
6542                                     "%s is disabled by all enum elements",
6543                                     this_policyname,
6544                                 )
6545                                 if this_policynamespace not in policy_vals:
6546                                     policy_vals[this_policynamespace] = {}
6547                                 policy_vals[this_policynamespace][
6548                                     this_policyname
6549                                 ] = "Disabled"
6550                             else:
6551                                 if this_policynamespace not in policy_vals:
6552                                     policy_vals[this_policynamespace] = {}
6553                                 policy_vals[this_policynamespace][
6554                                     this_policyname
6555                                 ] = configured_elements
6556                                 log.trace(
6557                                     "%s is enabled by enum elements", this_policyname
6558                                 )
6559                     else:
6560                         if this_policy_setting == "Enabled":
6561                             if this_policynamespace not in policy_vals:
6562                                 policy_vals[this_policynamespace] = {}
6563                             policy_vals[this_policynamespace][
6564                                 this_policyname
6565                             ] = configured_elements
6566             if (
6567                 return_full_policy_names
6568                 and this_policynamespace in policy_vals
6569                 and this_policyname in policy_vals[this_policynamespace]
6570             ):
6571                 if this_policynamespace not in full_names:
6572                     full_names[this_policynamespace] = {}
6573                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6574                     policy_item=admx_policy,
6575                     policy_name=admx_policy.attrib["name"],
6576                     return_full_policy_names=return_full_policy_names,
6577                     adml_language=adml_language,
6578                 )
6579                 if (
6580                     this_policyname
6581                     in policy_vals[this_policynamespace][this_policyname]
6582                 ):
6583                     full_name = full_names[this_policynamespace][this_policyname]
6584                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6585                         this_policyname
6586                     )
6587                     policy_vals[this_policynamespace][this_policyname][
6588                         full_name
6589                     ] = setting
6590             if (
6591                 this_policynamespace in policy_vals
6592                 and this_policyname in policy_vals[this_policynamespace]
6593             ):
6594                 if this_policynamespace not in hierarchy:
6595                     hierarchy[this_policynamespace] = {}
6596                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6597                     policy_definition=admx_policy,
6598                     adml_language=adml_language,
6599                 )
6600         log<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("Examination complete: %s seconds", time.time() - start_time)
6601     if policy_vals and return_full_policy_names and not hierarchical_return:
6602         log.debug("Compiling non hierarchical return...")
6603         start_time = time.time()
6604         unpathed_dict =</b></font> {}
6605         pathed_dict = {}
6606         for policy_namespace in list(policy_vals):
6607             for policy_item in list(policy_vals[policy_namespace]):
6608                 if (
6609                     full_names[policy_namespace][policy_item]
6610                     in policy_vals[policy_namespace]
6611                 ):
6612                     full_path_list = hierarchy[policy_namespace][policy_item]
6613                     full_path_list.reverse()
6614                     full_path_list.append(full_names[policy_namespace][policy_item])
6615                         policy_namespace
6616                     ].pop(policy_item)
6617                     pathed_dict[full_names[policy_namespace][policy_item]] <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= True
6618                 else:
6619                     policy_vals[policy_namespace][
6620                         full_names[policy_namespace][policy_item]
6621                     ] = policy_vals[policy_namespace].pop(policy_item)
6622                     if policy_namespace not in unpathed_dict:
6623                         unpathed_dict[policy_namespace] =</b></font> {}
6624                     unpathed_dict[policy_namespace][
6625                         full_names[policy_namespace][policy_item]
6626                     ] = policy_item
6627             if policy_namespace in unpathed_dict:
6628                 for path_needed in unpathed_dict[policy_namespace]:
6629                     full_path_list = hierarchy[policy_namespace][
6630                         unpathed_dict[policy_namespace][path_needed]
6631                     ]
6632                     full_path_list.reverse()
6633                     full_path_list.append(path_needed)
6634                     log.trace("full_path_list == %s", full_path_list)
6635                     policy_vals["\\".join(full_path_list)] = policy_vals[
6636                         policy_namespace
6637                     ].pop(path_needed)
6638         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6639     for policy_namespace in list(policy_vals):
6640         if policy_vals[policy_namespace] == {}:
6641             policy_vals.pop(policy_namespace)
6642     if policy_vals and hierarchical_return:
6643         if hierarchy:
6644             log.debug("Compiling hierarchical return...")
6645             start_time = time.time()
6646             for policy_namespace in hierarchy:
6647                 for hierarchy_item in hierarchy[policy_namespace]:
6648                     if hierarchy_item in policy_vals[policy_namespace]:
6649                         tdict = {}
6650                         first_item = True
6651                         for item in hierarchy[policy_namespace][hierarchy_item]:
6652                             newdict = {}
6653                             if first_item:
6654                                 h_policy_name = hierarchy_item
6655                                 if return_full_policy_names:
6656                                     h_policy_name = full_names[policy_namespace][
6657                                         hierarchy_item
6658                                     ]
6659                                 newdict[item] = {
6660                                     h_policy_name: policy_vals[policy_namespace].pop(
6661                                         hierarchy_item
6662                                     )
6663                                 }
6664                                 first_item = False
6665                             else:
6666                                 newdict[item] = tdict
6667                             tdict = newdict
6668                         if tdict:
6669                             policy_vals = dictupdate.update(policy_vals, tdict)
6670                 if (
6671                     policy_namespace in policy_vals
6672                     and policy_vals[policy_namespace] == {}
6673                 ):
6674                     policy_vals.pop(policy_namespace)
6675             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6676         policy_vals = {
6677             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6678                 "Administrative Templates": policy_vals
6679             }
6680         }
6681     return policy_vals
6682 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6683     """
6684     helper function to build a list containing parent elements of the ADMX
6685     policy
6686     """
6687     parent_list = []
6688     policy_namespace = next(iter(policy_definition.nsmap))
6689     parent_category = policy_definition.xpath(
6690         "{}:parentCategory/@ref".format(policy_namespace),
6691         namespaces=policy_definition.nsmap,
6692     )
6693     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6694     if parent_category:
6695         parent_category = parent_category[0]
6696         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6697             policy_namespace
6698         )
6699         this_namespace_map = _buildElementNsmap(
6700             admx_policy_definitions.xpath(
6701                 nsmap_xpath, namespaces=policy_definition.nsmap
6702             )
6703         )
6704         this_namespace_map = dictupdate.update(
6705             this_namespace_map, policy_definition.nsmap
6706         )
6707         parent_list = _admx_policy_parent_walk(
6708             path=parent_list,
6709             policy_namespace=policy_namespace,
6710             parent_category=parent_category,
6711             policy_nsmap=this_namespace_map,
6712             return_full_policy_names=return_full_policy_names,
6713             adml_language=adml_language,
6714         )
6715     return parent_list
6716 def _admx_policy_parent_walk(
6717     path,
6718     policy_namespace,
6719     parent_category,
6720     policy_nsmap,
6721     return_full_policy_names,
6722     adml_language,
6723 ):
6724     """
6725     helper function to recursively walk up the ADMX namespaces and build the
6726     hierarchy for the policy
6727     """
6728     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6729     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6730     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6731     if parent_category.find(":") &gt;= 0:
6732         policy_namespace = parent_category.split(":")[0]
6733         parent_category = parent_category.split(":")[1]
6734         using_xpath_string = using_xpath_string.format(policy_namespace)
6735         policy_nsmap = dictupdate.update(
6736             policy_nsmap,
6737             _buildElementNsmap(
6738                 admx_policy_definitions.xpath(
6739                     using_xpath_string, namespaces=policy_nsmap
6740                 )
6741             ),
6742         )
6743     category_xpath_string = category_xpath_string.format(
6744         policy_namespace, parent_category
6745     )
6746     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6747         tparent_category = admx_policy_definitions.xpath(
6748             category_xpath_string, namespaces=policy_nsmap
6749         )[0]
6750         this_parent_name = _getFullPolicyName(
6751             policy_item=tparent_category,
6752             policy_name=tparent_category.attrib["name"],
6753             return_full_policy_names=return_full_policy_names,
6754             adml_language=adml_language,
6755         )
6756         path.append(this_parent_name)
6757         if tparent_category.xpath(
6758             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6759         ):
6760             path = _admx_policy_parent_walk(
6761                 path=path,
6762                 policy_namespace=policy_namespace,
6763                 parent_category=tparent_category.xpath(
6764                     "{}:parentCategory/@ref".format(policy_namespace),
6765                     namespaces=policy_nsmap,
6766                 )[0],
6767                 policy_nsmap=policy_nsmap,
6768                 return_full_policy_names=return_full_policy_names,
6769                 adml_language=adml_language,
6770             )
6771     return path
6772 def _read_regpol_file(reg_pol_path):
6773     """
6774     helper function to read a reg policy file and return decoded data
6775     """
6776     returndata = None
6777     if os.path.exists(reg_pol_path):
6778         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6779             returndata = pol_file.read()
6780     return returndata
6781 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6782     """
6783     helper function to do a search of Policy data from a registry.pol file
6784     """
6785     if policy_data:
6786         regex_str <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= [
6787             r"(\*",
6788             r"\*",
6789             "D",
6790             "e",
6791             "l",
6792             r"\.",
6793             r"|\*",
6794             r"\*",
6795             "D",
6796             "e",
6797             "l",
6798             "V",
6799             "a",
6800             "l",
6801             "s",
6802             r"\.",
6803             "){0,1}",
6804         ]
6805         specialValueRegex = "\x00".join(regex_str)
6806         _thisSearch = b"".join(
6807             [
6808                 salt</b></font><font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.stringutils.to_bytes(r"\["),
6809                 re.escape(policy_regpath),
6810                 b"\x00;\x00",
6811                 specialValueRegex,
6812                 re.escape(policy_regkey.lstrip(b"\x00")),
6813                 b"\x00;",
6814             ]
6815         )
6816         match = re.search(</b></font>_thisSearch, policy_data, re.IGNORECASE)
6817         if match:
6818             return policy_data[
6819                 match.start() : (policy_data.index(b"]", match.end())) + 2
6820             ]
6821     return None
6822 def _write_regpol_data(
6823     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6824 ):
6825     """
6826     helper function to actually write the data to a Registry.pol file
6827     also updates/edits the gpt.ini file to include the ADM policy extensions
6828     to let the computer know user and/or machine registry policy files need
6829     to be processed
6830     data_to_write: data to write into the user/machine registry.pol file
6831     policy_file_path: path to the registry.pol file
6832     gpt_ini_path: path to gpt.ini file
6833     gpt_extension: gpt extension list name from _policy_info class for this registry class gpt_extension_location
6834     gpt_extension_guid: admx registry extension guid for the class
6835     """
6836     if not os.path.exists(policy_file_path):
6837         __salt__["file.makedirs"](policy_file_path)
6838     try:
6839         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
6840             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
6841             if not data_to_write.startswith(reg_pol_header):
6842                 pol_file.write(reg_pol_header)
6843             pol_file.write(data_to_write)
6844     except Exception as e:  # pylint: disable=broad-except
6845         msg = (
6846             "An error occurred attempting to write to {}, the exception was: {}".format(
6847                 policy_file_path, e
6848             )
6849         )
6850         log.exception(msg)
6851         raise CommandExecutionError(msg)
6852     gpt_ini_data = ""
6853     if os.path.exists(gpt_ini_path):
6854         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
6855             gpt_ini_data = gpt_file.read()
6856         gpt_ini_data = (
6857             gpt_ini_data.replace("\r\n", "_|-")
6858             .replace("\n", "_|-")
6859             .replace("_|-", "\r\n")
6860         )
6861     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
6862     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
6863         gpt_ext_loc <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= re.search(
6864             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
6865             gpt_ini_data,
6866             re.IGNORECASE | re.MULTILINE,
6867         )
6868         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.</b></font>end()]
6869         if not _regexSearchRegPolData(
6870             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
6871         ):
6872             gpt_ext_str = gpt_ext_str.split("=")
6873             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
6874             gpt_ext_str = "=".join(gpt_ext_str)
6875             gpt_ini_data = (
6876                 gpt_ini_data[0 : gpt_ext_loc.start()]
6877                 + gpt_ext_str
6878                 + gpt_ini_data[gpt_ext_loc.end() :]
6879             )
6880     else:
6881             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6882         )
6883         gpt_ini_data = "{}{}={}\r\n{}"<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(
6884             gpt_ini_data[general_location.start() : general_location.end()],
6885             gpt_extension,
6886             gpt_extension_guid,
6887             gpt_ini_data[general_location.end() :],
6888         )
6889     if</b></font> _regexSearchRegPolData(r"Version=", gpt_ini_data):
6890             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6891         )
6892         version_str = version_str.split("=")
6893         version_nums = struct.unpack(b"&gt;2H", struct.pack(</b></font>b"&gt;I", int(version_str[1])))
6894         if gpt_extension<font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.lower() == "gPCMachineExtensionNames".lower():
6895             version_nums = (version_nums[0], version_nums[1] + 1)
6896         elif gpt_extension.lower() == "gPCUserExtensionNames".lower(</b></font>):
6897             version_nums = (version_nums[0] + 1, version_nums[1])
6898         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
6899         gpt_ini_data = "{}{}={}\r\n{}".format(
6900             gpt_ini_data[0 : version_loc.start()],
6901             "Version",
6902             version_num,
6903             gpt_ini_data[version_loc.end() :],
6904         )
6905     else:
6906         general_location = re.search(
6907             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6908         )
6909         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6910             version_nums = (0, 1)
6911         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6912             version_nums = (1, 0)
6913         gpt_ini_data = "{}{}={}\r\n{}".format(
6914             gpt_ini_data[general_location.start() : general_location.end()],
6915             "Version",
6916             int(
6917                 "{}{}".format(
6918                     str(version_nums[0]).zfill(4),
6919                     str(version_nums[1]).zfill(4),
6920                 ),
6921                 16,
6922             ),
6923             gpt_ini_data[general_location.end() :],
6924         )
6925     if gpt_ini_data:
6926         try:
6927             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
6928                 gpt_file.write(gpt_ini_data)
6929         except Exception as e:  # pylint: disable=broad-except
6930             msg = (
6931                 "An error occurred attempting to write the gpg.ini file.\n"
6932                 "path: {}\n"
6933                 "exception: {}".format(gpt_ini_path, e)
6934             )
6935             log.exception(msg)
6936             raise CommandExecutionError(msg)
6937 def _policyFileReplaceOrAppendList(string_list, policy_data):
6938     """
6939     helper function to take a list of strings for registry.pol file data and
6940     update existing strings or append the strings
6941     """
6942     if not policy_data:
6943         policy_data = b""
6944     specialValueRegex = salt.utils.stringutils.to_bytes(
6945         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6946     )
6947     for this_string in string_list:
6948         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6949         list_item_value_name = re.sub(
6950             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6951         )
6952         log.trace("item value name is %s", list_item_value_name)
6953         data_to_replace = _regexSearchKeyValueCombo(
6954             policy_data, list_item_key, list_item_value_name
6955         )
6956         if data_to_replace:
6957             policy_data = policy_data.replace(data_to_replace, this_string)
6958         else:
6959             log<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("appending %s", this_string)
6960             policy_data = b"".join([policy_data, this_string])
6961     return policy_data
6962 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=</b></font>False):
6963     """
6964     helper function to take a ADMX policy string for registry.pol file data and
6965     update existing string or append the string to the data
6966     """
6967     if not policy_data:
6968         policy_data = b""
6969     specialValueRegex = salt.utils.stringutils.to_bytes(
6970         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6971     )
6972     item_key = None
6973     item_value_name = None
6974     data_to_replace = None
6975     if not append_only:
6976         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6977         item_value_name = re.sub(
6978             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6979         )
6980         log.trace("item value name is %s", item_value_name)
6981         data_to_replace = _regexSearchKeyValueCombo(
6982             policy_data, item_key, item_value_name
6983         )
6984     if data_to_replace:
6985         log.trace("replacing %s with %s", data_to_replace, this_string)
6986         policy_data = policy_data.replace(data_to_replace, this_string)
6987     else:
6988         log.trace("appending %s", this_string)
6989         policy_data = b"".join([policy_data, this_string])
6990     return policy_data
6991 def _writeAdminTemplateRegPolFile(
6992     admtemplate_data, adml_language="en-US", registry_class="Machine"
6993 ):
6994     r"""
6995     helper function to prep/write adm template data to the Registry.pol file
6996     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
6997     REGISTRY_FILE_VERSION (u'\x01\00')
6998     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
6999     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
7000     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
7001     """
7002     existing_data = b""
7003     policy_data = _policy_info()
7004     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
7005     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7006     adml_policy_resources = _get_policy_resources(language=adml_language)
7007     base_policy_settings = _checkAllAdmxPolicies(
7008         policy_class=registry_class,
7009         adml_language=adml_language,
7010         return_full_policy_names=False,
7011         hierarchical_return=False,
7012         return_not_configured=False,
7013     )
7014     for adm_namespace in admtemplate_data:
7015         for adm_policy in admtemplate_data[adm_namespace]:
7016             if (
7017                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
7018                 == "not configured"
7019             ):
7020                 if (
7021                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
7022                     is not None
7023                 ):
7024                     log.trace('Policy "%s" removed', adm_policy)
7025             else:
7026                 log.trace("adding %s to base_policy_settings", adm_policy)
7027                 if adm_namespace not in base_policy_settings:
7028                     base_policy_settings[adm_namespace] = {}
7029                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
7030                     adm_namespace
7031                 ][adm_policy]
7032     for adm_namespace in base_policy_settings:
7033         for admPolicy in base_policy_settings[adm_namespace]:
7034             log.trace("working on admPolicy %s", admPolicy)
7035             explicit_enable_disable_value_setting = False
7036             this_key = None
7037             this_valuename = None
7038             if (
7039                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
7040                 == "disabled"
7041             ):
7042                 log.trace("time to disable %s", admPolicy)
7043                 this_policy = admx_policy_definitions.xpath(
7044                     policySearchXpath.format(admPolicy),
7045                     namespaces={"ns1": adm_namespace},
7046                 )
7047                 if this_policy:
7048                     this_policy = this_policy[0]
7049                     if "class" in this_policy.attrib:
7050                         if (
7051                             this_policy.attrib["class"] == registry_class
7052                             or this_policy.attrib["class"] == "Both"
7053                         ):
7054                             if "key" in this_policy.attrib:
7055                                 this_key = this_policy.attrib["key"]
7056                             else:
7057                                 log.error(
7058                                     "policy item %s does not have "
7059                                     'the required "key" attribute',
7060                                     this_policy.attrib,
7061                                 )
7062                                 break
7063                             if "valueName" in this_policy.attrib:
7064                                 this_valuename = this_policy.attrib["valueName"]
7065                             if DISABLED_VALUE_XPATH(this_policy):
7066                                 explicit_enable_disable_value_setting = True
7067                                 disabled_value_string = _checkValueItemParent(
7068                                     this_policy,
7069                                     admPolicy,
7070                                     this_key,
7071                                     this_valuename,
7072                                     DISABLED_VALUE_XPATH,
7073                                     None,
7074                                     check_deleted=False,
7075                                     test_item=False,
7076                                 )
7077                                 existing_data = _policyFileReplaceOrAppend(
7078                                     disabled_value_string, existing_data
7079                                 )
7080                             if DISABLED_LIST_XPATH(this_policy):
7081                                 explicit_enable_disable_value_setting = True
7082                                 disabled_list_strings = _checkListItem(
7083                                     this_policy,
7084                                     admPolicy,
7085                                     this_key,
7086                                     DISABLED_LIST_XPATH,
7087                                     None,
7088                                     test_items=False,
7089                                 )
7090                                 log.trace(
7091                                     "working with disabledList portion of %s",
7092                                     admPolicy,
7093                                 )
7094                                 existing_data = _policyFileReplaceOrAppendList(
7095                                     disabled_list_strings, existing_data
7096                                 )
7097                             if (
7098                                 not explicit_enable_disable_value_setting
7099                                 and this_valuename
7100                             ):
7101                                 disabled_value_string = _buildKnownDataSearchString(
7102                                     this_key,
7103                                     this_valuename,
7104                                     "REG_DWORD",
7105                                     None,
7106                                     check_deleted=True,
7107                                 )
7108                                 existing_data = _policyFileReplaceOrAppend(
7109                                     disabled_value_string, existing_data
7110                                 )
7111                             if ELEMENTS_XPATH(this_policy):
7112                                 log.trace("checking elements of %s", admPolicy)
7113                                 for elements_item in ELEMENTS_XPATH(this_policy):
7114                                     for child_item in elements_item:
7115                                         child_key = this_key
7116                                         child_valuename = this_valuename
7117                                         if "key" in child_item.attrib:
7118                                             child_key = child_item.attrib["key"]
7119                                         if "valueName" in child_item.attrib:
7120                                             child_valuename = child_item.attrib[
7121                                                 "valueName"
7122                                             ]
7123                                         if etree.QName(
7124                                             child_item
7125                                         ).localname == "boolean" and (
7126                                             TRUE_LIST_XPATH(child_item)
7127                                             or FALSE_LIST_XPATH(child_item)
7128                                         ):
7129                                             temp_dict = {
7130                                                 "trueList": TRUE_LIST_XPATH,
7131                                                 "falseList": FALSE_LIST_XPATH,
7132                                             }
7133                                             for this_list in temp_dict:
7134                                                 disabled_list_strings = _checkListItem(
7135                                                     child_item,
7136                                                     admPolicy,
7137                                                     child_key,
7138                                                     temp_dict[this_list],
7139                                                     None,
7140                                                     test_items=False,
7141                                                 )
7142                                                 log.trace(
7143                                                     "working with %s portion of %s",
7144                                                     admPolicy,
7145                                                     this_list,
7146                                                 )
7147                                                 existing_data = (
7148                                                     _policyFileReplaceOrAppendList(
7149                                                         disabled_list_strings,
7150                                                         existing_data,
7151                                                     )
7152                                                 )
7153                                         elif (
7154                                             etree.QName(child_item).localname
7155                                             == "boolean"
7156                                             or etree.QName(child_item).localname
7157                                             == "decimal"
7158                                             or etree.QName(child_item).localname
7159                                             == "text"
7160                                             or etree.QName(child_item).localname
7161                                             == "longDecimal"
7162                                             or etree.QName(child_item).localname
7163                                             == "multiText"
7164                                             or etree.QName(child_item).localname
7165                                             == "enum"
7166                                         ):
7167                                             disabled_value_string = _processValueItem(
7168                                                 child_item,
7169                                                 child_key,
7170                                                 child_valuename,
7171                                                 this_policy,
7172                                                 elements_item,
7173                                                 check_deleted=True,
7174                                             )
7175                                             log.trace(
7176                                                 "I have disabled value string of %s",
7177                                                 disabled_value_string,
7178                                             )
7179                                             existing_data = _policyFileReplaceOrAppend(
7180                                                 disabled_value_string, existing_data
7181                                             )
7182                                         elif (
7183                                             etree.QName(child_item).localname == "list"
7184                                         ):
7185                                             disabled_value_string = _processValueItem(
7186                                                 child_item,
7187                                                 child_key,
7188                                                 child_valuename,
7189                                                 this_policy,
7190                                                 elements_item,
7191                                                 check_deleted=True,
7192                                             )
7193                                             log.trace(
7194                                                 "I have disabled value string of %s",
7195                                                 disabled_value_string,
7196                                             )
7197                                             existing_data = _policyFileReplaceOrAppend(
7198                                                 disabled_value_string, existing_data
7199                                             )
7200                         else:
7201                             log.error(
7202                                 "policy %s was found but it does not appear to be valid"
7203                                 " for the class %s",
7204                                 admPolicy,
7205                                 registry_class,
7206                             )
7207                     else:
7208                         log.error(
7209                             'policy item %s does not have the required "class"'
7210                             " attribute",
7211                             this_policy.attrib,
7212                         )
7213             else:
7214                 log.trace('time to enable and set the policy "%s"', admPolicy)
7215                 this_policy = admx_policy_definitions.xpath(
7216                     policySearchXpath.format(admPolicy),
7217                     namespaces={"ns1": adm_namespace},
7218                 )
7219                 log.trace("found this_policy == %s", this_policy)
7220                 if this_policy:
7221                     this_policy = this_policy[0]
7222                     if "class" in this_policy.attrib:
7223                         if (
7224                             this_policy.attrib["class"] == registry_class
7225                             or this_policy.attrib["class"] == "Both"
7226                         ):
7227                             if "key" in this_policy.attrib:
7228                                 this_key = this_policy.attrib["key"]
7229                             else:
7230                                 log.error(
7231                                     'policy item %s does not have the required "key"'
7232                                     " attribute",
7233                                     this_policy.attrib,
7234                                 )
7235                                 break
7236                             if "valueName" in this_policy.attrib:
7237                                 this_valuename = this_policy.attrib["valueName"]
7238                             if ENABLED_VALUE_XPATH(this_policy):
7239                                 explicit_enable_disable_value_setting = True
7240                                 enabled_value_string = _checkValueItemParent(
7241                                     this_policy,
7242                                     admPolicy,
7243                                     this_key,
7244                                     this_valuename,
7245                                     ENABLED_VALUE_XPATH,
7246                                     None,
7247                                     check_deleted=False,
7248                                     test_item=False,
7249                                 )
7250                                 existing_data = _policyFileReplaceOrAppend(
7251                                     enabled_value_string, existing_data
7252                                 )
7253                             if ENABLED_LIST_XPATH(this_policy):
7254                                 explicit_enable_disable_value_setting = True
7255                                 enabled_list_strings = _checkListItem(
7256                                     this_policy,
7257                                     admPolicy,
7258                                     this_key,
7259                                     ENABLED_LIST_XPATH,
7260                                     None,
7261                                     test_items=False,
7262                                 )
7263                                 log.trace(
7264                                     "working with enabledList portion of %s", admPolicy
7265                                 )
7266                                 existing_data = _policyFileReplaceOrAppendList(
7267                                     enabled_list_strings, existing_data
7268                                 )
7269                             if (
7270                                 not explicit_enable_disable_value_setting
7271                                 and this_valuename
7272                             ):
7273                                 enabled_value_string = _buildKnownDataSearchString(
7274                                     this_key,
7275                                     this_valuename,
7276                                     "REG_DWORD",
7277                                     "1",
7278                                     check_deleted=False,
7279                                 )
7280                                 existing_data = _policyFileReplaceOrAppend(
7281                                     enabled_value_string, existing_data
7282                                 )
7283                             if ELEMENTS_XPATH(this_policy):
7284                                 for elements_item in ELEMENTS_XPATH(this_policy):
7285                                     for child_item in elements_item:
7286                                         child_key = this_key
7287                                         child_valuename = this_valuename
7288                                         if "key" in child_item.attrib:
7289                                             child_key = child_item.attrib["key"]
7290                                         if "valueName" in child_item.attrib:
7291                                             child_valuename = child_item.attrib[
7292                                                 "valueName"
7293                                             ]
7294                                         if (
7295                                             child_item.attrib["id"]
7296                                             in base_policy_settings[adm_namespace][
7297                                                 admPolicy
7298                                             ]
7299                                         ):
7300                                             if etree.QName(
7301                                                 child_item
7302                                             ).localname == "boolean" and (
7303                                                 TRUE_LIST_XPATH(child_item)
7304                                                 or FALSE_LIST_XPATH(child_item)
7305                                             ):
7306                                                 list_strings = []
7307                                                 if base_policy_settings[adm_namespace][
7308                                                     admPolicy
7309                                                 ][child_item.attrib["id"]]:
7310                                                     list_strings = _checkListItem(
7311                                                         child_item,
7312                                                         admPolicy,
7313                                                         child_key,
7314                                                         TRUE_LIST_XPATH,
7315                                                         None,
7316                                                         test_items=False,
7317                                                     )
7318                                                     log.trace(
7319                                                         "working with trueList portion"
7320                                                         " of %s",
7321                                                         admPolicy,
7322                                                     )
7323                                                 else:
7324                                                     list_strings = _checkListItem(
7325                                                         child_item,
7326                                                         admPolicy,
7327                                                         child_key,
7328                                                         FALSE_LIST_XPATH,
7329                                                         None,
7330                                                         test_items=False,
7331                                                     )
7332                                                 existing_data = (
7333                                                     _policyFileReplaceOrAppendList(
7334                                                         list_strings, existing_data
7335                                                     )
7336                                                 )
7337                                             elif etree.QName(
7338                                                 child_item
7339                                             ).localname == "boolean" and (
7340                                                 TRUE_VALUE_XPATH(child_item)
7341                                                 or FALSE_VALUE_XPATH(child_item)
7342                                             ):
7343                                                 value_string = ""
7344                                                 if base_policy_settings[adm_namespace][
7345                                                     admPolicy
7346                                                 ][child_item.attrib["id"]]:
7347                                                     value_string = (
7348                                                         _checkValueItemParent(
7349                                                             child_item,
7350                                                             admPolicy,
7351                                                             child_key,
7352                                                             child_valuename,
7353                                                             TRUE_VALUE_XPATH,
7354                                                             None,
7355                                                             check_deleted=False,
7356                                                             test_item=False,
7357                                                         )
7358                                                     )
7359                                                 else:
7360                                                     value_string = (
7361                                                         _checkValueItemParent(
7362                                                             child_item,
7363                                                             admPolicy,
7364                                                             child_key,
7365                                                             child_valuename,
7366                                                             FALSE_VALUE_XPATH,
7367                                                             None,
7368                                                             check_deleted=False,
7369                                                             test_item=False,
7370                                                         )
7371                                                     )
7372                                                 existing_data = (
7373                                                     _policyFileReplaceOrAppend(
7374                                                         value_string, existing_data
7375                                                     )
7376                                                 )
7377                                             elif (
7378                                                 etree.QName(child_item).localname
7379                                                 == "boolean"
7380                                                 or etree.QName(child_item).localname
7381                                                 == "decimal"
7382                                                 or etree.QName(child_item).localname
7383                                                 == "text"
7384                                                 or etree.QName(child_item).localname
7385                                                 == "longDecimal"
7386                                                 or etree.QName(child_item).localname
7387                                                 == "multiText"
7388                                             ):
7389                                                 enabled_value_string = _processValueItem(
7390                                                     child_item,
7391                                                     child_key,
7392                                                     child_valuename,
7393                                                     this_policy,
7394                                                     elements_item,
7395                                                     check_deleted=False,
7396                                                     this_element_value=base_policy_settings[
7397                                                         adm_namespace
7398                                                     ][
7399                                                         admPolicy
7400                                                     ][
7401                                                         child_item.attrib["id"]
7402                                                     ],
7403                                                 )
7404                                                 log.trace(
7405                                                     "I have enabled value string of %s",
7406                                                     enabled_value_string,
7407                                                 )
7408                                                 existing_data = (
7409                                                     _policyFileReplaceOrAppend(
7410                                                         enabled_value_string,
7411                                                         existing_data,
7412                                                     )
7413                                                 )
7414                                             elif (
7415                                                 etree.QName(child_item).localname
7416                                                 == "enum"
7417                                             ):
7418                                                 for enum_item in child_item:
7419                                                     if (
7420                                                         base_policy_settings[
7421                                                             adm_namespace
7422                                                         ][admPolicy][
7423                                                             child_item.attrib["id"]
7424                                                         ]
7425                                                         == _getAdmlDisplayName(
7426                                                             adml_policy_resources,
7427                                                             enum_item.attrib[
7428                                                                 "displayName"
7429                                                             ],
7430                                                         ).strip()
7431                                                     ):
7432                                                         enabled_value_string = (
7433                                                             _checkValueItemParent(
7434                                                                 enum_item,
7435                                                                 child_item.attrib["id"],
7436                                                                 child_key,
7437                                                                 child_valuename,
7438                                                                 VALUE_XPATH,
7439                                                                 None,
7440                                                                 check_deleted=False,
7441                                                                 test_item=False,
7442                                                             )
7443                                                         )
7444                                                         existing_data = (
7445                                                             _policyFileReplaceOrAppend(
7446                                                                 enabled_value_string,
7447                                                                 existing_data,
7448                                                             )
7449                                                         )
7450                                                         if VALUE_LIST_XPATH(enum_item):
7451                                                             enabled_list_strings = (
7452                                                                 _checkListItem(
7453                                                                     enum_item,
7454                                                                     admPolicy,
7455                                                                     child_key,
7456                                                                     VALUE_LIST_XPATH,
7457                                                                     None,
7458                                                                     test_items=False,
7459                                                                 )
7460                                                             )
7461                                                             log.trace(
7462                                                                 "working with valueList"
7463                                                                 " portion of %s",
7464                                                                 child_item.attrib["id"],
7465                                                             )
7466                                                             existing_data = _policyFileReplaceOrAppendList(
7467                                                                 enabled_list_strings,
7468                                                                 existing_data,
7469                                                             )
7470                                                         break
7471                                             elif (
7472                                                 etree.QName(child_item).localname
7473                                                 == "list"
7474                                             ):
7475                                                 enabled_value_string = _processValueItem(
7476                                                     child_item,
7477                                                     child_key,
7478                                                     child_valuename,
7479                                                     this_policy,
7480                                                     elements_item,
7481                                                     check_deleted=False,
7482                                                     this_element_value=base_policy_settings[
7483                                                         adm_namespace
7484                                                     ][
7485                                                         admPolicy
7486                                                     ][
7487                                                         child_item.attrib["id"]
7488                                                     ],
7489                                                 )
7490                                                 log.trace(
7491                                                     "I have enabled value string of %s",
7492                                                     enabled_value_string,
7493                                                 )
7494                                                 existing_data = (
7495                                                     _policyFileReplaceOrAppend(
7496                                                         enabled_value_string,
7497                                                         existing_data,
7498                                                         append_only=True,
7499                                                     )
7500                                                 )
7501     try:
7502         _write_regpol_data(
7503             existing_data,
7504             policy_data.admx_registry_classes[registry_class]["policy_path"],
7505             policy_data.gpt_ini_path,
7506             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7507             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7508         )
7509     except CommandExecutionError as exc:  # pylint: disable=broad-except
7510         log.exception(
7511             "Unhandled exception occurred while attempting to "
7512             "write Adm Template Policy File.\nException: %s",
7513             exc,
7514         )
7515         return False
7516     return True
7517 def _getScriptSettingsFromIniFile(policy_info):
7518     """
7519     helper function to parse/read a GPO Startup/Shutdown script file
7520     psscript.ini and script.ini file definitions are here
7521         https://msdn.microsoft.com/en-us/library/ff842529.aspx
7522         https://msdn.microsoft.com/en-us/library/dd303238.aspx
7523     """
7524     _existingData = None
7525     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7526         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7527             _existingData = fhr.read()
7528         if _existingData:
7529             try:
7530                 _existingData = deserialize(
7531                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7532                 )
7533                 log.trace("Have deserialized data %s", _existingData)
7534             except Exception as error:  # pylint: disable=broad-except
7535                 log.exception(
7536                     "An error occurred attempting to deserialize data for %s",
7537                     policy_info["Policy"],
7538                 )
7539                 raise CommandExecutionError(error)
7540             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7541                 "Section"
7542             ].lower() in [z.lower() for z in _existingData.keys()]:
7543                 if "SettingName" in policy_info["ScriptIni"]:
7544                     log.trace(
7545                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7546                     )
7547                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7548                         z.lower()
7549                         for z in _existingData[
7550                             policy_info["ScriptIni"]["Section"]
7551                         ].keys()
7552                     ]:
7553                         return _existingData[policy_info["ScriptIni"]["Section"]][
7554                             policy_info["ScriptIni"]["SettingName"].lower()
7555                         ]
7556                     else:
7557                         return None
7558                 else:
7559                     return _existingData[policy_info["ScriptIni"]["Section"]]
7560             else:
7561                 return None
7562     return None
7563 def _writeGpoScript(psscript=False):
7564     """
7565     helper function to write local GPO startup/shutdown script
7566     scripts are stored in scripts.ini and psscripts.ini files in
7567     ``WINDIR\\System32\\GroupPolicy\\Machine|User\\Scripts``
7568     these files have the hidden attribute set
7569     files have following format:
7570         empty line
7571         [Startup]
7572         0CmdLine=&lt;path to script 0&gt;
7573         0Parameters=&lt;script 0 parameters&gt;
7574         [Shutdown]
7575         0CmdLine=&lt;path to shutdown script 0&gt;
7576         0Parameters=&lt;shutdown script 0 parameters&gt;
7577     Number is incremented for each script added
7578     psscript file also has the option of a [ScriptsConfig] section, which has
7579     the following two parameters:
7580         StartExecutePSFirst
7581         EndExecutePSFirst
7582     these can be set to True/False to denote if the powershell startup/shutdown
7583     scripts execute first (True) or last (False), if the value isn't set, then
7584     it is 'Not Configured' in the GUI
7585     """
7586     _machineScriptPolicyPath = os.path.join(
7587         os.getenv("WINDIR"),
7588         "System32",
7589         "GroupPolicy",
7590         "Machine",
7591         "Scripts",
7592         "scripts.ini",
7593     )
7594     _machinePowershellScriptPolicyPath = os.path.join(
7595         os.getenv("WINDIR"),
7596         "System32",
7597         "GroupPolicy",
7598         "Machine",
7599         "Scripts",
7600         "psscripts.ini",
7601     )
7602     _userScriptPolicyPath = os.path.join(
7603         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7604     )
7605     _userPowershellScriptPolicyPath = os.path.join(
7606         os.getenv("WINDIR"),
7607         "System32",
7608         "GroupPolicy",
7609         "User",
7610         "Scripts",
7611         "psscripts.ini",
7612     )
7613 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7614     """
7615     (success_flag, policy_xml_item, policy_name_list, message)
7616     """
7617     policy_aliases = []
7618     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7619     adml_policy_resources = _get_policy_resources(language=adml_language)
7620     admx_search_results = ADMX_SEARCH_XPATH(
7621         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7622     )
7623     if admx_search_results:
7624         if len(admx_search_results) == 1:
7625             the_policy = admx_search_results[0]
7626             policy_display_name = _getFullPolicyName(
7627                 policy_item=the_policy,
7628                 policy_name=the_policy.attrib["name"],
7629                 return_full_policy_names=True,
7630                 adml_language=adml_language,
7631             )
7632             policy_aliases.append(policy_display_name)
7633             policy_aliases.append(the_policy.attrib["name"])
7634             full_path_list = _build_parent_list(
7635                 policy_definition=the_policy,
7636                 return_full_policy_names=True,
7637                 adml_language=adml_language,
7638             )
7639             full_path_list.reverse()
7640             full_path_list.append(policy_display_name)
7641             policy_aliases.append("\\".join(full_path_list))
7642             return True, the_policy, policy_aliases, None
7643         else:
7644             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7645             return False, None, [], msg
7646     else:
7647         adml_search_results = ADML_SEARCH_XPATH(
7648             adml_policy_resources, policy_name=policy_name
7649         )
7650         hierarchy = []
7651         hierarchy_policy_name = policy_name
7652         if not adml_search_results:
7653             log.warning("Trying another: %s", policy_name)
7654             if "\\" in policy_name:
7655                 hierarchy = policy_name.split("\\")
7656                 policy_name = hierarchy.pop()
7657                 adml_search_results = ADML_SEARCH_XPATH(
7658                     adml_policy_resources, policy_name=policy_name
7659                 )
7660         if adml_search_results:
7661             multiple_adml_entries = False
7662             suggested_policies = ""
7663             adml_to_remove = []
7664             if len(adml_search_results) &gt; 1:
7665                 log.trace(
7666                     "multiple ADML entries found matching the policy name %s",
7667                     policy_name,
7668                 )
7669                 multiple_adml_entries = True
7670                 for adml_search_result in adml_search_results:
7671                     if (
7672                         not getattr(adml_search_result, "text", "").strip()
7673                         == policy_name
7674                     ):
7675                     else:
7676                         if hierarchy:
7677                             log<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.trace("we have hierarchy of %s", hierarchy)
7678                             display_name_searchval = "$({}.{})".format(
7679                                 adml_search_result.tag.split("}")[1],
7680                                 adml_search_result.attrib["id"],
7681                             )
7682                             policy_search_string =</b></font> (
7683                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7684                                 ' or @class = "{}") ]'.format(
7685                                     adml_search_result.prefix,
7686                                     display_name_searchval,
7687                                     policy_class,
7688                                 )
7689                             )
7690                             admx_results = []
7691                             these_admx_search_results = admx_policy_definitions.xpath(
7692                                 policy_search_string,
7693                                 namespaces=adml_search_result.nsmap,
7694                             )
7695                             if not these_admx_search_results:
7696                                 log.trace(
7697                                     "No admx was found for the adml entry %s, it will"
7698                                     " be removed",
7699                                     display_name_searchval,
7700                                 )
7701                                 adml_to_remove.append(adml_search_result)
7702                             for search_result in these_admx_search_results:
7703                                 log.trace("policy_name == %s", policy_name)
7704                                 this_hierarchy = _build_parent_list(
7705                                     policy_definition=search_result,
7706                                     return_full_policy_names=True,
7707                                     adml_language=adml_language,
7708                                 )
7709                                 this_hierarchy.reverse()
7710                                 if hierarchy != this_hierarchy:
7711                                     log.trace(
7712                                         "hierarchy %s does not match this item's"
7713                                         " hierarchy of %s",
7714                                         hierarchy,
7715                                         this_hierarchy,
7716                                     )
7717                                     if len(these_admx_search_results) == 1:
7718                                         log.trace(
7719                                             "only 1 admx was found and it does not "
7720                                             "match this adml, it is safe to remove "
7721                                             "from the list"
7722                                         )
7723                                         adml_to_remove.append(adml_search_result)
7724                                 else:
7725                                     log.trace(
7726                                         "hierarchy %s matches item's hierarchy of %s",
7727                                         hierarchy,
7728                                         this_hierarchy,
7729                                     )
7730                                     log.trace(
7731                                         "search_result %s added to results",
7732                                         search_result,
7733                                     )
7734                                     admx_results.append(search_result)
7735                             if len(admx_results) == 1:
7736                                 admx_search_results.append(admx_results[0])
7737                         else:
7738                             display_name_searchval = "$({}.{})".format(
7739                                 adml_search_result.tag.split("}")[1],
7740                                 adml_search_result.attrib["id"],
7741                             )
7742                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7743                                 admx_policy_definitions,
7744                                 display_name=display_name_searchval,
7745                                 registry_class=policy_class,
7746                             )
7747                             if not these_admx_search_results:
7748                                 adml_to_remove.append(adml_search_result)
7749             for adml in adml_to_remove:
7750                 if adml in adml_search_results:
7751                     adml_search_results.remove(adml)
7752             if len(adml_search_results) == 1 and multiple_adml_entries:
7753                 multiple_adml_entries = False
7754             for adml_search_result in adml_search_results:
7755                 log.trace(
7756                     "found an ADML entry matching the string! %s -- %s",
7757                     adml_search_result.tag,
7758                     adml_search_result.attrib,
7759                 )
7760                 display_name_searchval = "$({}.{})".format(
7761                     adml_search_result.tag.split("}")[1],
7762                     adml_search_result.attrib["id"],
7763                 )
7764                 log.trace("searching for displayName == %s", display_name_searchval)
7765                 if not admx_search_results:
7766                     log.trace(
7767                         "search for an admx entry matching display_name %s and"
7768                         " registry_class %s",
7769                         display_name_searchval,
7770                         policy_class,
7771                     )
7772                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7773                         admx_policy_definitions,
7774                         display_name=display_name_searchval,
7775                         registry_class=policy_class,
7776                     )
7777                 if admx_search_results:
7778                     log.trace(
7779                         "processing admx_search_results of %s", admx_search_results
7780                     )
7781                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7782                     if (
7783                         len(admx_search_results) == 1 or hierarchy
7784                     ) and not multiple_adml_entries:
7785                         found = False
7786                         for search_result in admx_search_results:
7787                             found = False
7788                             if hierarchy:
7789                                 this_hierarchy = _build_parent_list(
7790                                     policy_definition=search_result,
7791                                     return_full_policy_names=True,
7792                                     adml_language=adml_language,
7793                                 )
7794                                 this_hierarchy.reverse()
7795                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7796                                 if hierarchy == this_hierarchy:
7797                                     found = True
7798                             else:
7799                                 found = True
7800                             if found:
7801                                 log.trace(
7802                                     "found the ADMX policy matching "
7803                                     "the display name %s -- %s",
7804                                     search_result,
7805                                     policy_name,
7806                                 )
7807                                 if "name" in search_result.attrib:
7808                                     policy_display_name = _getFullPolicyName(
7809                                         policy_item=search_result,
7810                                         policy_name=search_result.attrib["name"],
7811                                         return_full_policy_names=True,
7812                                         adml_language=adml_language,
7813                                     )
7814                                     policy_aliases.append(policy_display_name)
7815                                     policy_aliases.append(search_result.attrib["name"])
7816                                     full_path_list = _build_parent_list(
7817                                         policy_definition=search_result,
7818                                         return_full_policy_names=True,
7819                                         adml_language=adml_language,
7820                                     )
7821                                     full_path_list.reverse()
7822                                     full_path_list.append(policy_display_name)
7823                                     policy_aliases.append("\\".join(full_path_list))
7824                                     return True, search_result, policy_aliases, None
7825                                 else:
7826                                     msg = (
7827                                         "ADMX policy with the display name {} does not"
7828                                         "have the required name attribute"
7829                                     )
7830                                     msg = msg.format(policy_name)
7831                                     return False, None, [], msg
7832                         if not found:
7833                             msg = "Unable to correlate {} to any policy".format(
7834                                 hierarchy_policy_name
7835                             )
7836                             return False, None, [], msg
7837                     else:
7838                         for possible_policy in admx_search_results:
7839                             this_parent_list = _build_parent_list(
7840                                 policy_definition=possible_policy,
7841                                 return_full_policy_names=True,
7842                                 adml_language=adml_language,
7843                             )
7844                             this_parent_list.reverse()
7845                             this_parent_list.append(policy_name)
7846                             if suggested_policies:
7847                                 suggested_policies = ", ".join(
7848                                     [suggested_policies, "\\".join(this_parent_list)]
7849                                 )
7850                             else:
7851                                 suggested_policies = "\\".join(this_parent_list)
7852             if suggested_policies:
7853                 msg = (
7854                     'ADML policy name "{}" is used as the display name for '
7855                     "multiple policies. These policies matched: {}. You can "
7856                     "utilize these long names to specify the correct policy"
7857                 )
7858                 return False, None, [], msg.format(policy_name, suggested_policies)
7859     return (
7860         False,
7861         None,
7862         [],
7863         "Unable to find {} policy {}".format(policy_class, policy_name),
7864     )
7865 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
7866     r"""
7867     Returns information about a specified policy
7868     Args:
7869         policy_name (str):
7870             The name of the policy to lookup
7871         policy_class (str):
7872             The class of policy, i.e. machine, user, both
7873         adml_language (str):
7874             The ADML language to use for Administrative Template data lookup
7875     Returns:
7876         dict: Information about the specified policy
7877     CLI Example:
7878     .. code-block:: bash
7879         salt '*' lgpo.get_policy_info 'Maximum password age' machine
7880     You can use ``lgpo.get_policy_info`` to get all the possible names that
7881     could be used in a state file or from the command line (along with elements
7882     that need to be set/etc). The key is to match the text you see in the
7883     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
7884     "full path" style is really only needed when there are multiple policies
7885     that use the same base name. For example, ``Access data sources across
7886     domains`` exists in ~10 different paths. If you put that through
7887     ``get_policy_info`` you'll get back a message that it is used for multiple
7888     policies and you need to be more specific.
7889     CLI Example:
7890     .. code-block:: bash
7891         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
7892         local:
7893             ----------
7894             message:
7895             policy_aliases:
7896                 - Turn off the "Order Prints" picture task
7897                 - ShellRemoveOrderPrints_2
7898                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7899             policy_class:
7900                 machine
7901             policy_elements:
7902             policy_found:
7903                 True
7904             policy_name:
7905                 ShellRemoveOrderPrints_2
7906             rights_assignment:
7907                 False
7908     Escaping can get tricky in cmd/Powershell. The following is an example of
7909     escaping in Powershell using backquotes:
7910     .. code-block:: bash
7911         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
7912         local:
7913             ----------
7914             message:
7915             policy_aliases:
7916                 - Turn off the "Order Prints" picture task
7917                 - ShellRemoveOrderPrints_2
7918                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7919             policy_class:
7920                 machine
7921             policy_elements:
7922             policy_found:
7923                 True
7924             policy_name:
7925                 Turn off the "Order Prints" picture task
7926             rights_assignment:
7927                 False
7928     This function can then be used to get the options available for specifying
7929     Group Policy Objects to be used in state files. Based on the above any of
7930     these *should* be usable:
7931     .. code-block:: bash
7932         internet_communications_settings:
7933           lgpo.set:
7934             - computer_policy:
7935                 Turn off the "Order Prints" picture task: Enabled
7936     .. code-block:: bash
7937         internet_communications_settings:
7938           lgpo.set:
7939             - computer_policy:
7940                 ShellRemoveOrderPrints_2: Enabled
7941     When using the full path, it might be a good idea to use single quotes
7942     around the path:
7943     .. code-block:: bash
7944         internet_communications_settings:
7945           lgpo.set:
7946             - computer_policy:
7947                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
7948     If you struggle to find the policy from ``get_policy_info`` using the name
7949     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
7950     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
7951     relationships (ADML holds what you see in the GUI, ADMX holds the more
7952     technical details), then this may be a little bit too much info, but here is
7953     an example with the above policy using Powershell:
7954     .. code-block:: bash
7955         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
7956         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
7957         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
7958         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
7959         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
7960     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
7961     string used to describe this policy, then we search for it in the ADMX:
7962     .. code-block:: bash
7963         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
7964         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7965         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7966     Now we have two to pick from. And if you notice the ``class="Machine"`` and
7967     ``class="User"`` (which details if it is a computer policy or user policy
7968     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
7969     use to pass through ``get_policy_info`` to see what the module itself is
7970     expecting.
7971     """
7972     ret = {
7973         "policy_name": policy_name,
7974         "policy_class": policy_class,
7975         "policy_aliases": [],
7976         "policy_found": False,
7977         "rights_assignment": False,
7978         "policy_elements": [],
7979         "message": "policy not found",
7980     }
7981     policy_class = policy_class.title()
7982     policy_data = _policy_info()
7983     if policy_class not in policy_data.policies.keys():
7984         policy_classes = ", ".join(policy_data.policies.keys())
7985         ret["message"] = (
7986             'The requested policy class "{}" is invalid, '
7987             "policy_class should be one of: {}"
7988             "".format(policy_class, policy_classes)
7989         )
7990         return ret
7991     if policy_name in policy_data.policies[policy_class]["policies"]:
7992         ret["policy_aliases"].append(
7993             policy_data.policies[policy_class]["policies"][policy_name]["Policy"]
7994         )
7995         ret["policy_found"] = True
7996         ret["message"] = ""
7997         if "LsaRights" in policy_data.policies[policy_class]["policies"][policy_name]:
7998             ret["rights_assignment"] = True
7999         return ret
8000     else:
8001         for pol in policy_data.policies[policy_class]["policies"]:
8002             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8003             if _p == policy_name:
8004                 ret["policy_aliases"].append(pol)
8005                 ret["policy_found"] = True
8006                 ret["message"] = ""
8007                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8008                     ret["rights_assignment"] = True
8009                 return ret
8010         for pol in policy_data.policies[policy_class]["policies"]:
8011             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8012             if _p.lower() == policy_name.lower():
8013                 ret["policy_aliases"].append(pol)
8014                 ret["policy_found"] = True
8015                 ret["message"] = ""
8016                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8017                     ret["rights_assignment"] = True
8018                 return ret
8019     success, policy_xml_item, policy_name_list, message = _lookup_admin_template(
8020         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
8021     )
8022     if success:
8023         for elements_item in ELEMENTS_XPATH(policy_xml_item):
8024             for child_item in elements_item:
8025                 this_element_name = _getFullPolicyName(
8026                     policy_item=child_item,
8027                     policy_name=child_item.attrib["id"],
8028                     return_full_policy_names=True,
8029                     adml_language=adml_language,
8030                 )
8031                 ret["policy_elements"].append(
8032                     {
8033                         "element_id": child_item.attrib["id"],
8034                         "element_aliases": [child_item.attrib["id"], this_element_name],
8035                     }
8036                 )
8037         ret["policy_aliases"] = policy_name_list
8038         ret["policy_found"] = True
8039         ret["message"] = ""
8040         return ret
8041     else:
8042         ret["message"] = message
8043     return ret
8044 def get(
8045     policy_class=None,
8046     return_full_policy_names=True,
8047     hierarchical_return=False,
8048     adml_language="en-US",
8049     return_not_configured=False,
8050 ):
8051     """
8052     Get a policy value
8053     Args:
8054         policy_class (str):
8055             Some policies are both user and computer, by default all policies
8056             will be pulled, but this can be used to retrieve only a specific
8057             policy class User/USER/user = retrieve user policies
8058             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
8059             machine/computer policies
8060         return_full_policy_names (bool):
8061             True/False to return the policy name as it is seen in the
8062             ``gpedit.msc`` GUI or to only return the policy key/id.
8063         hierarchical_return (bool):
8064             True/False to return the policy data in the hierarchy as seen in the
8065             ``gpedit.msc`` GUI. The default of False will return data split only
8066             into User/Computer configuration sections
8067         adml_language (str):
8068             The ADML language to use for processing display/descriptive names
8069             and enumeration values of ADMX template data, defaults to en-US
8070         return_not_configured (bool):
8071             Include Administrative Template policies that are 'Not Configured'
8072             in the return data
8073     Returns:
8074         dict: A dictionary containing the policy values for the specified class
8075     CLI Example:
8076     .. code-block:: bash
8077         salt '*' lgpo.get machine return_full_policy_names=True
8078     """
8079     vals = {}
8080     _policydata = _policy_info()
8081     if policy_class is None or policy_class.lower() == "both":
8082         policy_class = _policydata.policies.keys()
8083     elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:
8084         msg = (
8085             "The policy_class {} is not an available policy class, please "
8086             "use one of the following: {}, Both"
8087         )
8088         raise SaltInvocationError(
8089             msg.format(policy_class, ", ".join(_policydata.policies.keys()))
8090         )
8091     else:
8092         policy_class = [policy_class.title()]
8093     for p_class in policy_class:
8094         this_class_policy_names = _policydata.policies[p_class]["policies"]
8095         class_vals = {}
8096         for policy_name in this_class_policy_names:
8097             _pol = None
8098             if policy_name in _policydata.policies[p_class]["policies"]:
8099                 _pol = _policydata.policies[p_class]["policies"][policy_name]
8100             else:
8101                 for policy in _policydata.policies[p_class]["policies"]:
8102                     _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8103                     if _p == policy_name:
8104                         _pol = _policydata.policies[p_class]["policies"][policy]
8105                         policy_name = policy
8106                 if _pol is None:
8107                     for policy in _policydata.policies[p_class]["policies"]:
8108                         _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8109                         if _p.lower() == policy_name.lower():
8110                             _pol = _policydata.policies[p_class]["policies"][policy]
8111                             policy_name = policy
8112             if _pol:
8113                 vals_key_name = policy_name
8114                 class_vals[policy_name] = _get_policy_info_setting(_pol)
8115                 if return_full_policy_names:
8116                     class_vals[_pol["Policy"]] = class_vals.pop(policy_name)
8117                     vals_key_name = _pol["Policy"]
8118                 if hierarchical_return:
8119                     if "lgpo_section" in _pol:
8120                         firstItem = True
8121                         tdict = {}
8122                         for level in reversed(_pol["lgpo_section"]):
8123                             newdict = {}
8124                             if firstItem:
8125                                 newdict[level] = {
8126                                     vals_key_name: class_vals.pop(vals_key_name)
8127                                 }
8128                                 firstItem = False
8129                             else:
8130                                 newdict[level] = tdict
8131                             tdict = newdict
8132                         if tdict:
8133                             class_vals = dictupdate.update(class_vals, tdict)
8134             else:
8135                 raise CommandExecutionError(
8136                     "The specified policy {} is not currently available "
8137                     "to be configured via this module".format(policy_name)
8138                 )
8139         class_vals = dictupdate.update(
8140             class_vals,
8141             _checkAllAdmxPolicies(
8142                 policy_class=p_class,
8143                 adml_language=adml_language,
8144                 return_full_policy_names=return_full_policy_names,
8145                 hierarchical_return=hierarchical_return,
8146                 return_not_configured=return_not_configured,
8147             ),
8148         )
8149         if _policydata.policies[p_class]["lgpo_section"] not in class_vals:
8150             temp_dict = {_policydata.policies[p_class]["lgpo_section"]: class_vals}
8151             class_vals = temp_dict
8152         vals = dictupdate.update(vals, class_vals)
8153     return vals
8154 def _get_policy_info_setting(policy_definition):
8155     """
8156     Some policies are defined in this module and others by the ADMX/ADML files
8157     on the machine. This function loads the current values for policies defined
8158     in this module.
8159     Args:
8160         policy_definition (dict):
8161             A sub-dict of Policies property of the _policy_info() class.
8162             Basically a dictionary that defines the policy
8163     Returns:
8164         The transformed value. The transform is defined in the policy
8165         definition. It can be a list, a string, a dictionary, depending on how
8166         it's defined
8167     Usage:
8168         policy_data = _policy_info()
8169         policy_name = 'RemoteRegistryExactPaths'
8170         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
8171         policy_value = _get_policy_info_setting(policy_definition)
8172     """
8173     if "Registry" in policy_definition:
8174         value = __utils__["reg.read_value"](
8175             policy_definition["Registry"]["Hive"],
8176             policy_definition["Registry"]["Path"],
8177             policy_definition["Registry"]["Value"],
8178         )["vdata"]
8179         log.trace(
8180             "Value %r found for Regisry policy %s", value, policy_definition["Policy"]
8181         )
8182     elif "Secedit" in policy_definition:
8183         value = _get_secedit_value(option=policy_definition["Secedit"]["Option"])
8184         log.trace(
8185             "Value %r found for Secedit policy %s", value, policy_definition["Policy"]
8186         )
8187     elif "NetSH" in policy_definition:
8188         value = _get_netsh_value(
8189             profile=policy_definition["NetSH"]["Profile"],
8190             option=policy_definition["NetSH"]["Option"],
8191         )
8192         log.trace(
8193             "Value %r found for NetSH policy %s", value, policy_definition["Policy"]
8194         )
8195     elif "AdvAudit" in policy_definition:
8196         value = _get_advaudit_value(option=policy_definition["AdvAudit"]["Option"])
8197         log.trace(
8198             "Value %r found for AuditPol policy %s", value, policy_definition["Policy"]
8199         )
8200     elif "NetUserModal" in policy_definition:
8201         modal_return = win32net.NetUserModalsGet(
8202             None, policy_definition["NetUserModal"]["Modal"]
8203         )
8204         value = modal_return[policy_definition["NetUserModal"]["Option"]]
8205         log.trace(
8206             "Value %r found for NetUserModal policy %s",
8207             value,
8208             policy_definition["Policy"],
8209         )
8210     elif "LsaRights" in policy_definition:
8211         value = _getRightsAssignments(policy_definition["LsaRights"]["Option"])
8212         log.trace(
8213             "Value %r found for LSARights policy %s", value, policy_definition["Policy"]
8214         )
8215     elif "ScriptIni" in policy_definition:
8216         value = _getScriptSettingsFromIniFile(policy_definition)
8217         log.trace(
8218             "Value %r found for ScriptIni policy %s", value, policy_definition["Policy"]
8219         )
8220     else:
8221         raise CommandExecutionError(
8222             "Unknown or missing mechanism in policy_definition\n{}".format(
8223                 policy_definition
8224             )
8225         )
8226     value = _transform_value(
8227         value=value, policy=policy_definition, transform_type="Get"
8228     )
8229     return value
8230 def _get_policy_adm_setting(
8231     admx_policy,
8232     policy_class,
8233     adml_language="en-US",
8234     return_full_policy_names=False,
8235     hierarchical_return=False,
8236 ):
8237     """
8238     Get the current setting for polices set via the policy templates (ADMX/ADML)
8239     files
8240     Args:
8241         admx_policy (obj):
8242             The XPath object as returned by the ``_lookup_admin_template``
8243             function
8244         policy_class (str):
8245             The policy class. Must be one of ``machine`` or ``user``
8246         adml_language (str):
8247             The language code for the adml file to use for localization. The
8248             default is ``en-US``
8249         return_full_policy_names (bool):
8250             Returns the full policy name regardless of what was passed in
8251             ``policy_name``
8252         hierarchical_return (bool):
8253             Returns a hierarchical view of the policy showing its parents
8254     Returns:
8255         dict: A dictionary containing the policy settings
8256     Usage:
8257         policy_name = 'AutoUpdateCfg'
8258         policy_class = 'machine'
8259         adml_language = 'en-US'
8260         success, policy_obj, _, _ = _lookup_admin_template(
8261             policy_name=policy_name,
8262             policy_class=policy_class,
8263             adml_language=adml_language)
8264         if success:
8265             setting = _get_policy_adm_setting(
8266                 admx_policy=policy_obj,
8267                 policy_class=policy_class,
8268                 adml_language=adml_language,
8269                 return_full_policy_names=return_full_policy_names,
8270                 hierarchical_return=hierarchical_return
8271             )
8272     """
8273     this_key = admx_policy.attrib.get("key", None)
8274     this_policy_name = admx_policy.attrib<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("name", None)
8275     if this_key is None or this_policy_name is None:
8276         raise CommandExecutionError(
8277             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
8278                 admx_policy.attrib
8279             )
8280         )
8281     this_value_name = admx_policy.attrib.get("valueName", None)
8282     this_policy_setting =</b></font> "Not Configured"
8283     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
8284     element_only_enabled_disabled = True
8285     explicit_enable_disable_value_setting = False
8286     policy_data = _policy_info()
8287     policy_file_data = _read_regpol_file(
8288         policy_data.admx_registry_classes[policy_class]["policy_path"]
8289     )
8290     adml_policy_resources = _get_policy_resources(language=adml_language)
8291     policy_vals = {}
8292     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8293         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8294             element_only_enabled_disabled = False
8295             explicit_enable_disable_value_setting = True
8296             if _checkValueItemParent(
8297                 policy_element=admx_policy,
8298                 policy_name=this_policy_name,
8299                 policy_key=this_key,
8300                 policy_valueName=this_value_name,
8301                 xpath_object=ENABLED_VALUE_XPATH,
8302                 policy_file_data=policy_file_data,
8303             ):
8304                 log.trace(
8305                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
8306                 )
8307                 this_policy_setting = "Enabled"
8308                 policy_vals.setdefault(this_policy_namespace, {})[
8309                     this_policy_name
8310                 ] = this_policy_setting
8311     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8312         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8313             element_only_enabled_disabled = False
8314             explicit_enable_disable_value_setting = True
8315             if _checkValueItemParent(
8316                 policy_element=admx_policy,
8317                 policy_name=this_policy_name,
8318                 policy_key=this_key,
8319                 policy_valueName=this_value_name,
8320                 xpath_object=DISABLED_VALUE_XPATH,
8321                 policy_file_data=policy_file_data,
8322             ):
8323                 log.trace(
8324                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
8325                 )
8326                 this_policy_setting = "Disabled"
8327                 policy_vals.setdefault(this_policy_namespace, {})[
8328                     this_policy_name
8329                 ] = this_policy_setting
8330     if ENABLED_LIST_XPATH(admx_policy):
8331         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8332             element_only_enabled_disabled = False
8333             explicit_enable_disable_value_setting = True
8334             if _checkListItem(
8335                 policy_element=admx_policy,
8336                 policy_name=this_policy_name,
8337                 policy_key=this_key,
8338                 xpath_object=ENABLED_LIST_XPATH,
8339                 policy_file_data=policy_file_data,
8340             ):
8341                 log.trace(
8342                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
8343                 )
8344                 this_policy_setting = "Enabled"
8345                 policy_vals.setdefault(this_policy_namespace, {})[
8346                     this_policy_name
8347                 ] = this_policy_setting
8348     if DISABLED_LIST_XPATH(admx_policy):
8349         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8350             element_only_enabled_disabled = False
8351             explicit_enable_disable_value_setting = True
8352             if _checkListItem(
8353                 policy_element=admx_policy,
8354                 policy_name=this_policy_name,
8355                 policy_key=this_key,
8356                 xpath_object=DISABLED_LIST_XPATH,
8357                 policy_file_data=policy_file_data,
8358             ):
8359                 log.trace(
8360                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
8361                 )
8362                 this_policy_setting = "Disabled"
8363                 policy_vals.setdefault(this_policy_namespace, {})[
8364                     this_policy_name
8365                 ] = this_policy_setting
8366     if not explicit_enable_disable_value_setting and this_value_name:
8367         if _regexSearchRegPolData(
8368             re.escape(
8369                 _buildKnownDataSearchString(
8370                     reg_key=this_key,
8371                     reg_valueName=this_value_name,
8372                     reg_vtype="REG_DWORD",
8373                     reg_data="1",
8374                 )
8375             ),
8376             policy_file_data,
8377         ):
8378             log.trace(
8379                 "%s is enabled by no explicit enable/disable list or value",
8380                 this_policy_name,
8381             )
8382             this_policy_setting = "Enabled"
8383             policy_vals.setdefault(this_policy_namespace, {})[
8384                 this_policy_name
8385             ] = this_policy_setting
8386         elif _regexSearchRegPolData(
8387             re.escape(
8388                 _buildKnownDataSearchString(
8389                     reg_key=this_key,
8390                     reg_valueName=this_value_name,
8391                     reg_vtype="REG_DWORD",
8392                     reg_data=None,
8393                     check_deleted=True,
8394                 )
8395             ),
8396             policy_file_data,
8397         ):
8398             log.trace(
8399                 "%s is disabled by no explicit enable/disable list or value",
8400                 this_policy_name,
8401             )
8402             this_policy_setting = "Disabled"
8403             policy_vals.setdefault(this_policy_namespace, {})[
8404                 this_policy_name
8405             ] = this_policy_setting
8406     full_names = {}
8407     hierarchy = {}
8408     if ELEMENTS_XPATH(admx_policy):
8409         if element_only_enabled_disabled or this_policy_setting == "Enabled":
8410             required_elements = {}
8411             configured_elements = {}
8412             policy_disabled_elements = 0
8413             for elements_item in ELEMENTS_XPATH(admx_policy):
8414                 for child_item in elements_item:
8415                     this_element_name = _getFullPolicyName(
8416                         policy_item=child_item,
8417                         policy_name=child_item.attrib["id"],
8418                         return_full_policy_names=return_full_policy_names,
8419                         adml_language=adml_language,
8420                     )
8421                     required_elements[this_element_name] = None
8422                     child_key = child_item.attrib.get("key", this_key)
8423                     child_value_name = child_item.attrib.get(
8424                         "valueName", this_value_name
8425                     )
8426                     if etree.QName(child_item).localname == "boolean":
8427                         if child_item is not None:
8428                             if (
8429                                 TRUE_VALUE_XPATH(child_item)
8430                                 and this_element_name not in configured_elements
8431                             ):
8432                                 if _checkValueItemParent(
8433                                     policy_element=child_item,
8434                                     policy_name=this_policy_name,
8435                                     policy_key=child_key,
8436                                     policy_valueName=child_value_name,
8437                                     xpath_object=TRUE_VALUE_XPATH,
8438                                     policy_file_data=policy_file_data,
8439                                 ):
8440                                     configured_elements[this_element_name] = True
8441                                     log.trace(
8442                                         "element %s is configured true",
8443                                         child_item.attrib["id"],
8444                                     )
8445                             if (
8446                                 FALSE_VALUE_XPATH(child_item)
8447                                 and this_element_name not in configured_elements
8448                             ):
8449                                 if _checkValueItemParent(
8450                                     policy_element=child_item,
8451                                     policy_name=this_policy_name,
8452                                     policy_key=child_key,
8453                                     policy_valueName=child_value_name,
8454                                     xpath_object=FALSE_VALUE_XPATH,
8455                                     policy_file_data=policy_file_data,
8456                                 ):
8457                                     configured_elements[this_element_name] = False
8458                                     policy_disabled_elements = (
8459                                         policy_disabled_elements + 1
8460                                     )
8461                                     log.trace(
8462                                         "element %s is configured false",
8463                                         child_item.attrib["id"],
8464                                     )
8465                             if (
8466                                 TRUE_LIST_XPATH(child_item)
8467                                 and this_element_name not in configured_elements
8468                             ):
8469                                 log.trace("checking trueList")
8470                                 if _checkListItem(
8471                                     policy_element=child_item,
8472                                     policy_name=this_policy_name,
8473                                     policy_key=this_key,
8474                                     xpath_object=TRUE_LIST_XPATH,
8475                                     policy_file_data=policy_file_data,
8476                                 ):
8477                                     configured_elements[this_element_name] = True
8478                                     log.trace(
8479                                         "element %s is configured true",
8480                                         child_item.attrib["id"],
8481                                     )
8482                             if (
8483                                 FALSE_LIST_XPATH(child_item)
8484                                 and this_element_name not in configured_elements
8485                             ):
8486                                 log.trace("checking falseList")
8487                                 if _checkListItem(
8488                                     policy_element=child_item,
8489                                     policy_name=this_policy_name,
8490                                     policy_key=this_key,
8491                                     xpath_object=FALSE_LIST_XPATH,
8492                                     policy_file_data=policy_file_data,
8493                                 ):
8494                                     configured_elements[this_element_name] = False
8495                                     policy_disabled_elements = (
8496                                         policy_disabled_elements + 1
8497                                     )
8498                                     log.trace(
8499                                         "element %s is configured false",
8500                                         child_item.attrib["id"],
8501                                     )
8502                         else:
8503                             if _regexSearchRegPolData(
8504                                 re.escape(
8505                                     _processValueItem(
8506                                         element=child_item,
8507                                         reg_key=child_key,
8508                                         reg_valuename=child_value_name,
8509                                         policy=admx_policy,
8510                                         parent_element=elements_item,
8511                                         check_deleted=True,
8512                                     )
8513                                 ),
8514                                 policy_file_data,
8515                             ):
8516                                 configured_elements[this_element_name] = False
8517                                 policy_disabled_elements = policy_disabled_elements + 1
8518                                 log.trace(
8519                                     "element %s is configured false",
8520                                     child_item.attrib["id"],
8521                                 )
8522                             elif _regexSearchRegPolData(
8523                                 re.escape(
8524                                     _processValueItem(
8525                                         element=child_item,
8526                                         reg_key=child_key,
8527                                         reg_valuename=child_value_name,
8528                                         policy=admx_policy,
8529                                         parent_element=elements_item,
8530                                         check_deleted=False,
8531                                     )
8532                                 ),
8533                                 policy_file_data,
8534                             ):
8535                                 configured_elements[this_element_name] = True
8536                                 log.trace(
8537                                     "element %s is configured true",
8538                                     child_item.attrib["id"],
8539                                 )
8540                     elif etree.QName(child_item).localname in [
8541                         "decimal",
8542                         "text",
8543                         "longDecimal",
8544                         "multiText",
8545                     ]:
8546                         if _regexSearchRegPolData(
8547                             re.escape(
8548                                 _processValueItem(
8549                                     element=child_item,
8550                                     reg_key=child_key,
8551                                     reg_valuename=child_value_name,
8552                                     policy=admx_policy,
8553                                     parent_element=elements_item,
8554                                     check_deleted=True,
8555                                 )
8556                             ),
8557                             policy_file_data,
8558                         ):
8559                             configured_elements[this_element_name] = "Disabled"
8560                             policy_disabled_elements = policy_disabled_elements + 1
8561                             log.trace("element %s is disabled", child_item.attrib["id"])
8562                         elif _regexSearchRegPolData(
8563                             re.escape(
8564                                 _processValueItem(
8565                                     element=child_item,
8566                                     reg_key=child_key,
8567                                     reg_valuename=child_value_name,
8568                                     policy=admx_policy,
8569                                     parent_element=elements_item,
8570                                     check_deleted=False,
8571                                 )
8572                             ),
8573                             policy_data=policy_file_data,
8574                         ):
8575                             configured_value = _getDataFromRegPolData(
8576                                 _processValueItem(
8577                                     element=child_item,
8578                                     reg_key=child_key,
8579                                     reg_valuename=child_value_name,
8580                                     policy=admx_policy,
8581                                     parent_element=elements_item,
8582                                     check_deleted=False,
8583                                 ),
8584                                 policy_data=policy_file_data,
8585                             )
8586                             configured_elements[this_element_name] = configured_value
8587                             log.trace(
8588                                 "element %s is enabled, value == %s",
8589                                 child_item.attrib["id"],
8590                                 configured_value,
8591                             )
8592                     elif etree.QName(child_item).localname == "enum":
8593                         if _regexSearchRegPolData(
8594                             re.escape(
8595                                 _processValueItem(
8596                                     element=child_item,
8597                                     reg_key=child_key,
8598                                     reg_valuename=child_value_name,
8599                                     policy=admx_policy,
8600                                     parent_element=elements_item,
8601                                     check_deleted=True,
8602                                 )
8603                             ),
8604                             policy_file_data,
8605                         ):
8606                             log.trace(
8607                                 "enum element %s is disabled", child_item.attrib["id"]
8608                             )
8609                             configured_elements[this_element_name] = "Disabled"
8610                             policy_disabled_elements = policy_disabled_elements + 1
8611                         else:
8612                             for enum_item in child_item:
8613                                 if _checkValueItemParent(
8614                                     policy_element=enum_item,
8615                                     policy_name=child_item.attrib["id"],
8616                                     policy_key=child_key,
8617                                     policy_valueName=child_value_name,
8618                                     xpath_object=VALUE_XPATH,
8619                                     policy_file_data=policy_file_data,
8620                                 ):
8621                                     if VALUE_LIST_XPATH(enum_item):
8622                                         log.trace("enum item has a valueList")
8623                                         if _checkListItem(
8624                                             policy_element=enum_item,
8625                                             policy_name=this_policy_name,
8626                                             policy_key=child_key,
8627                                             xpath_object=VALUE_LIST_XPATH,
8628                                             policy_file_data=policy_file_data,
8629                                         ):
8630                                             log.trace(
8631                                                 "all valueList items exist in file"
8632                                             )
8633                                             configured_elements[
8634                                                 this_element_name
8635                                             ] = _getAdmlDisplayName(
8636                                                 adml_xml_data=adml_policy_resources,
8637                                                 display_name=enum_item.attrib[
8638                                                     "displayName"
8639                                                 ],
8640                                             )
8641                                             break
8642                                     else:
8643                                         configured_elements[
8644                                             this_element_name
8645                                         ] = _getAdmlDisplayName(
8646                                             adml_xml_data=adml_policy_resources,
8647                                             display_name=enum_item.attrib[
8648                                                 "displayName"
8649                                             ],
8650                                         )
8651                                         break
8652                     elif etree.QName(child_item).localname == "list":
8653                         return_value_name = False
8654                         if (
8655                             "explicitValue" in child_item.attrib
8656                             and child_item.attrib["explicitValue"].lower() == "true"
8657                         ):
8658                             log.trace("explicitValue list, we will return value names")
8659                             return_value_name = True
8660                         regex_str = [
8661                             r"(?!\*",
8662                             r"\*",
8663                             "D",
8664                             "e",
8665                             "l",
8666                             "V",
8667                             "a",
8668                             "l",
8669                             "s",
8670                             r"\.",
8671                             ")",
8672                         ]
8673                         delvals_regex = "\x00".join(regex_str)
8674                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
8675                         if _regexSearchRegPolData(
8676                             re.escape(
8677                                 _processValueItem(
8678                                     element=child_item,
8679                                     reg_key=child_key,
8680                                     reg_valuename=child_value_name,
8681                                     policy=admx_policy,
8682                                     parent_element=elements_item,
8683                                     check_deleted=False,
8684                                 )
8685                             )
8686                             + delvals_regex,
8687                             policy_data=policy_file_data,
8688                         ):
8689                             configured_value = _getDataFromRegPolData(
8690                                 _processValueItem(
8691                                     element=child_item,
8692                                     reg_key=child_key,
8693                                     reg_valuename=child_value_name,
8694                                     policy=admx_policy,
8695                                     parent_element=elements_item,
8696                                     check_deleted=False,
8697                                 ),
8698                                 policy_data=policy_file_data,
8699                                 return_value_name=return_value_name,
8700                             )
8701                             configured_elements[this_element_name] = configured_value
8702                             log.trace(
8703                                 "element %s is enabled values: %s",
8704                                 child_item.attrib["id"],
8705                                 configured_value,
8706                             )
8707                         elif _regexSearchRegPolData(
8708                             re.escape(
8709                                 _processValueItem(
8710                                     element=child_item,
8711                                     reg_key=child_key,
8712                                     reg_valuename=child_value_name,
8713                                     policy=admx_policy,
8714                                     parent_element=elements_item,
8715                                     check_deleted=True,
8716                                 )
8717                             ),
8718                             policy_file_data,
8719                         ):
8720                             configured_elements[this_element_name] = "Disabled"
8721                             policy_disabled_elements = policy_disabled_elements + 1
8722                             log.trace("element %s is disabled", child_item.attrib["id"])
8723             if element_only_enabled_disabled:
8724                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
8725                     if policy_disabled_elements == len(required_elements.keys()):
8726                         log.trace(
8727                             "%s is disabled by all enum elements", this_policy_name
8728                         )
8729                         policy_vals.setdefault(this_policy_namespace, {})[
8730                             this_policy_name
8731                         ] = "Disabled"
8732                     else:
8733                         log.trace("%s is enabled by enum elements", this_policy_name)
8734                         policy_vals.setdefault(this_policy_namespace, {})[
8735                             this_policy_name
8736                         ] = configured_elements
8737                 else:
8738                     policy_vals.setdefault(this_policy_namespace, {})[
8739                         this_policy_name
8740                     ] = this_policy_setting
8741             else:
8742                 if this_policy_setting == "Enabled":
8743                     policy_vals.setdefault(this_policy_namespace, {})[
8744                         this_policy_name
8745                     ] = configured_elements
8746         else:
8747             policy_vals.setdefault(this_policy_namespace, {})[
8748                 this_policy_name
8749             ] = this_policy_setting
8750     else:
8751         policy_vals.setdefault(this_policy_namespace, {})[
8752             this_policy_name
8753         ] = this_policy_setting
8754     if (
8755         return_full_policy_names
8756         and this_policy_namespace in policy_vals
8757         and this_policy_name in policy_vals[this_policy_namespace]
8758     ):
8759         full_names.setdefault(this_policy_namespace, {})
8760         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
8761             policy_item=admx_policy,
8762             policy_name=admx_policy.attrib["name"],
8763             return_full_policy_names=return_full_policy_names,
8764             adml_language=adml_language,
8765         )
8766         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
8767             full_name = full_names[this_policy_namespace][this_policy_name]
8768             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
8769                 this_policy_name
8770             )
8771             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
8772     if (
8773         this_policy_namespace in policy_vals
8774         and this_policy_name in policy_vals[this_policy_namespace]
8775     ):
8776         hierarchy.setdefault(this_policy_namespace, {})[
8777             this_policy_name
8778         ] = _build_parent_list(
8779             policy_definition=admx_policy,
8780             return_full_policy_names=return_full_policy_names,
8781             adml_language=adml_language,
8782         )
8783     if policy_vals and return_full_policy_names and not hierarchical_return:
8784         log.debug("Compiling non hierarchical return...")
8785         unpathed_dict = {}
8786         pathed_dict = {}
8787         for policy_namespace in list(policy_vals):
8788             for policy_item in list(policy_vals[policy_namespace]):
8789                 full_name = full_names[policy_namespace][policy_item]
8790                 if full_name in policy_vals[policy_namespace]:
8791                     full_path_list = hierarchy[policy_namespace][policy_item]
8792                     full_path_list.reverse()
8793                     full_path_list.append(full_names[policy_namespace][policy_item])
8794                     policy_vals["\\".join(full_path_list)] = policy_vals[
8795                         policy_namespace
8796                     ].pop(policy_item)
8797                     pathed_dict[full_name] = True
8798                 else:
8799                     policy_vals[policy_namespace][full_name] = policy_vals[
8800                         policy_namespace
8801                     ].pop(policy_item)
8802                     unpathed_dict.setdefault(policy_namespace, {})[
8803                         full_name
8804                     ] = policy_item
8805             for path_needed in unpathed_dict[policy_namespace]:
8806                 full_path_list = hierarchy[policy_namespace][
8807                     unpathed_dict[policy_namespace][path_needed]
8808                 ]
8809                 full_path_list.reverse()
8810                 full_path_list.append(path_needed)
8811                 log.trace("full_path_list == %s", full_path_list)
8812                 policy_vals["\\".join(full_path_list)] = policy_vals[
8813                     policy_namespace
8814                 ].pop(path_needed)
8815     for policy_namespace in list(policy_vals):
8816         if policy_vals[policy_namespace] == {}:
8817             policy_vals.pop(policy_namespace)
8818         elif isinstance(policy_vals[policy_namespace], dict):
8819             if this_policy_namespace == policy_namespace and not hierarchical_return:
8820                 policy_vals.update(policy_vals[policy_namespace])
8821                 policy_vals.pop(policy_namespace)
8822     if policy_vals and hierarchical_return:
8823         if hierarchy:
8824             log.debug("Compiling hierarchical return...")
8825             for policy_namespace in hierarchy:
8826                 for hierarchy_item in hierarchy[policy_namespace]:
8827                     if hierarchy_item in policy_vals[policy_namespace]:
8828                         t_dict = {}
8829                         first_item = True
8830                         for item in hierarchy[policy_namespace][hierarchy_item]:
8831                             new_dict = {}
8832                             if first_item:
8833                                 h_policy_name = hierarchy_item
8834                                 if return_full_policy_names:
8835                                     h_policy_name = full_names[policy_namespace][
8836                                         hierarchy_item
8837                                     ]
8838                                 new_dict[item] = {
8839                                     h_policy_name: policy_vals[policy_namespace].pop(
8840                                         hierarchy_item
8841                                     )
8842                                 }
8843                                 first_item = False
8844                             else:
8845                                 new_dict[item] = t_dict
8846                             t_dict = new_dict
8847                         if t_dict:
8848                             policy_vals = dictupdate.update(policy_vals, t_dict)
8849                 if (
8850                     policy_namespace in policy_vals
8851                     and policy_vals[policy_namespace] == {}
8852                 ):
8853                     policy_vals.pop(policy_namespace)
8854         policy_vals = {
8855             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
8856                 "Administrative Templates": policy_vals
8857             }
8858         }
8859     return policy_vals
8860 def get_policy(
8861     policy_name,
8862     policy_class,
8863     adml_language="en-US",
8864     return_value_only=True,
8865     return_full_policy_names=True,
8866     hierarchical_return=False,
8867 ):
8868     r"""
8869     Get the current settings for a single policy on the machine
8870     Args:
8871         policy_name (str):
8872             The name of the policy to retrieve. Can be the any of the names
8873             or alieses returned by ``lgpo.get_policy_info``
8874         policy_class (str):
8875             The policy class. Must be one of ``machine`` or ``user``
8876         adml_language (str):
8877             The language code for the adml file to use for localization. The
8878             default is ``en-US``
8879         return_value_only (bool):
8880             ``True`` will return only the value for the policy, without the
8881             name of the policy. ``return_full_policy_names`` and
8882             ``hierarchical_return`` will be ignored. Default is ``True``
8883         return_full_policy_names (bool):
8884             Returns the full policy name regardless of what was passed in
8885             ``policy_name``
8886             .. note::
8887                 This setting applies to sub-elements of the policy if they
8888                 exist. The value passed in ``policy_name`` will always be used
8889                 as the policy name when this setting is ``False``
8890         hierarchical_return (bool):
8891             Returns a hierarchical view of the policy showing its parents
8892     Returns:
8893         dict: A dictionary containing the policy settings
8894     CLI Example:
8895     .. code-block:: bash
8896         salt * lgpo.get_policy LockoutDuration machine
8897         salt * lgpo.get_policy AutoUpdateCfg machine
8898         salt * lgpo.get_policy "Account lockout duration" machine
8899         salt * lgpo.get_policy "Configure Automatic Updates" machine
8900         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
8901     """
8902     if not policy_name:
8903         raise SaltInvocationError("policy_name must be defined")
8904     if not policy_class:
8905         raise SaltInvocationError("policy_class must be defined")
8906     policy_class = policy_class.title()
8907     policy_data = _policy_info()
8908     if policy_class not in policy_data.policies.keys():
8909         policy_classes = ", ".join(policy_data.policies.keys())
8910         raise CommandExecutionError(
8911             'The requested policy class "{}" is invalid, policy_class should '
8912             "be one of: {}".format(policy_class, policy_classes)
8913         )
8914     policy_definition = None
8915     if policy_name in policy_data.policies[policy_class]["policies"]:
8916         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
8917     else:
8918         for pol in policy_data.policies[policy_class]["policies"]:
8919             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8920             if _p == policy_name:
8921                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
8922                 break
8923         if policy_definition is None:
8924             for pol in policy_data.policies[policy_class]["policies"]:
8925                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8926                 if _p.lower() == policy_name.lower():
8927                     policy_definition = policy_data.policies[policy_class]["policies"][
8928                         pol
8929                     ]
8930                     break
8931     if policy_definition:
8932         if return_value_only:
8933             return _get_policy_info_setting(policy_definition)
8934         if return_full_policy_names:
8935             key_name = policy_definition["Policy"]
8936         else:
8937             key_name = policy_name
8938         setting = {key_name: _get_policy_info_setting(policy_definition)}
8939         if hierarchical_return:
8940             if "lgpo_section" in policy_definition:
8941                 first_item = True
8942                 t_dict = {}
8943                 for level in reversed(policy_definition["lgpo_section"]):
8944                     new_dict = {}
8945                     if first_item:
8946                         new_dict[level] = {key_name: setting.pop(key_name)}
8947                         first_item = False
8948                     else:
8949                         new_dict[level] = t_dict
8950                     t_dict = new_dict
8951                 if t_dict:
8952                     setting = t_dict
8953         return setting
8954     success, policy_obj, _, _ = _lookup_admin_template(
8955         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
8956     )
8957     if success:
8958         setting = _get_policy_adm_setting(
8959             admx_policy=policy_obj,
8960             policy_class=policy_class,
8961             adml_language=adml_language,
8962             return_full_policy_names=return_full_policy_names,
8963             hierarchical_return=hierarchical_return,
8964         )
8965         if return_value_only:
8966             for key in setting:
8967                 return setting[key]
8968         return setting
8969 def set_computer_policy(
8970     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
8971 ):
8972     """
8973     Set a single computer policy
8974     Args:
8975         name (str):
8976             The name of the policy to configure
8977         setting (str):
8978             The setting to configure the named policy with
8979         cumulative_rights_assignments (bool): Determine how user rights
8980             assignment policies are configured. If True, user right assignment
8981             specifications are simply added to the existing policy. If False,
8982             only the users specified will get the right (any existing will have
8983             the right revoked)
8984         adml_language (str): The language files to use for looking up
8985             Administrative Template policy data (i.e. how the policy is
8986             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
8987     Returns:
8988         bool: True if successful, otherwise False
8989     CLI Example:
8990     .. code-block:: bash
8991         salt '*' lgpo.set_computer_policy LockoutDuration 1440
8992     """
8993     pol = {}
8994     pol[name] = setting
8995     ret = set_(
8996         computer_policy=pol,
8997         user_policy=None,
8998         cumulative_rights_assignments=cumulative_rights_assignments,
8999         adml_language=adml_language,
9000     )
9001     return ret
9002 def set_user_policy(name, setting, adml_language="en-US"):
9003     """
9004     Set a single user policy
9005     Args:
9006         name (str):
9007             The name of the policy to configure
9008         setting (str):
9009             The setting to configure the named policy with
9010         adml_language (str):
9011             The language files to use for looking up Administrative Template
9012             policy data (i.e. how the policy is displayed in the GUI). Defaults
9013             to 'en-US' (U.S. English).
9014     Returns:
9015         bool: True if successful, Otherwise False
9016     CLI Example:
9017     .. code-block:: bash
9018         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
9019     """
9020     pol = {}
9021     pol[name] = setting
9022     ret = set_(
9023         user_policy=pol,
9024         computer_policy=None,
9025         cumulative_rights_assignments=True,
9026         adml_language=adml_language,
9027     )
9028     return ret
9029 def set_(
9030     computer_policy=None,
9031     user_policy=None,
9032     cumulative_rights_assignments=True,
9033     adml_language="en-US",
9034 ):
9035     """
9036     Set a local server policy.
9037     Args:
9038         computer_policy (dict):
9039             A dictionary of "policyname: value" pairs of computer policies to
9040             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
9041             if a setting can be 'Enabled'/'Disabled', then that should be passed
9042             Administrative Template data may require dicts within dicts, to
9043             specify each element of the Administrative Template policy.
9044             Administrative Templates policies are always cumulative.
9045             Policy names can be specified in a number of ways based on the type
9046             of policy:
9047                 Windows Settings Policies:
9048                     These policies can be specified using the GUI display name
9049                     or the key name from the _policy_info class in this module.
9050                     The GUI display name is also contained in the _policy_info
9051                     class in this module.
9052                 Administrative Template Policies:
9053                     These can be specified using the policy name as displayed in
9054                     the GUI (case sensitive). Some policies have the same name,
9055                     but a different location (for example, "Access data sources
9056                     across domains"). These can be differentiated by the "path"
9057                     in the GUI (for example, "Windows Components\\Internet
9058                     Explorer\\Internet Control Panel\\Security Page\\Internet
9059                     Zone\\Access data sources across domains").
9060                     Additionally, policies can be specified using the "name" and
9061                     "id" attributes from the ADMX files.
9062                     For Administrative Templates that have policy elements, each
9063                     element can be specified using the text string as seen in
9064                     the GUI or using the ID attribute from the ADMX file. Due to
9065                     the way some of the GUI text is laid out, some policy
9066                     element names could include descriptive text that appears
9067                     lbefore the policy element in the GUI.
9068                     Use the get_policy_info function for the policy name to view
9069                     the element ID/names that the module will accept.
9070         user_policy (dict):
9071             The same setup as the computer_policy, except with data to configure
9072             the local user policy.
9073         cumulative_rights_assignments (bool):
9074             Determine how user rights assignment policies are configured.
9075             If True, user right assignment specifications are simply added to
9076             the existing policy
9077             If False, only the users specified will get the right (any existing
9078             will have the right revoked)
9079         adml_language (str):
9080             The language files to use for looking up Administrative Template
9081             policy data (i.e. how the policy is displayed in the GUI). Defaults
9082             to 'en-US' (U.S. English).
9083     Returns:
9084         bool: True is successful, otherwise False
9085     CLI Example:
9086     .. code-block:: bash
9087         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
9088     """
9089     if computer_policy and not isinstance(computer_policy, dict):
9090         raise SaltInvocationError("computer_policy must be specified as a dict")
9091     if user_policy and not isinstance(user_policy, dict):
9092         raise SaltInvocationError("user_policy must be specified as a dict")
9093     policies = {}
9094     policies["User"] = user_policy
9095     policies["Machine"] = computer_policy
9096     if policies:
9097         adml_policy_resources = _get_policy_resources(language=adml_language)
9098         for p_class in policies:
9099             _secedits = {}
9100             _netshs = {}
9101             _advaudits = {}
9102             _modal_sets = {}
9103             _admTemplateData = {}
9104             _regedits = {}
9105             _lsarights = {}
9106             _policydata = _policy_info()
9107             if policies[p_class]:
9108                 for policy_name in policies[p_class]:
9109                     _pol = None
9110                     policy_key_name = policy_name
9111                     if policy_name in _policydata.policies[p_class]["policies"]:
9112                         _pol = _policydata.policies[p_class]["policies"][policy_name]
9113                     else:
9114                         for policy in _policydata.policies[p_class]["policies"]:
9115                             _p = _policydata.policies[p_class]["policies"][policy][
9116                                 "Policy"
9117                             ]
9118                             if _p == policy_name:
9119                                 _pol = _policydata.policies[p_class]["policies"][policy]
9120                                 policy_key_name = policy
9121                         if _pol is None:
9122                             for policy in _policydata.policies[p_class]["policies"]:
9123                                 _p = _policydata.policies[p_class]["policies"][policy][
9124                                     "Policy"
9125                                 ]
9126                                 if _p.lower() == policy_name.lower():
9127                                     _pol = _policydata.policies[p_class]["policies"][
9128                                         policy
9129                                     ]
9130                                     policy_key_name = policy
9131                     if _pol:
9132                         _value = _transform_value(
9133                             value=policies[p_class][policy_name],
9134                             policy=_policydata.policies[p_class]["policies"][
9135                                 policy_key_name
9136                             ],
9137                             transform_type="Put",
9138                         )
9139                         if not _validateSetting(
9140                             value=_value,
9141                             policy=_policydata.policies[p_class]["policies"][
9142                                 policy_key_name
9143                             ],
9144                         ):
9145                             raise SaltInvocationError(
9146                                 "The specified value {} is not an acceptable setting"
9147                                 " for policy {}.".format(
9148                                     policies[p_class][policy_name], policy_name
9149                                 )
9150                             )
9151                         if "Registry" in _pol:
9152                             log.trace("%s is a registry policy", policy_name)
9153                             _regedits[policy_name] = {"policy": _pol, "value": _value}
9154                         elif "Secedit" in _pol:
9155                             log.trace("%s is a Secedit policy", policy_name)
9156                             if _pol["Secedit"]["Section"] not in _secedits:
9157                                 _secedits[_pol["Secedit"]["Section"]] = []
9158                             _secedits[_pol["Secedit"]["Section"]].append(
9159                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
9160                             )
9161                         elif "NetSH" in _pol:
9162                             log.trace("%s is a NetSH policy", policy_name)
9163                             _netshs.setdefault(
9164                                 policy_name,
9165                                     "profile": _pol["NetSH"]["Profile"],
9166                                     "section": _pol["NetSH"]["Section"],
9167                                     "option": _pol["NetSH"]<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["Option"],
9168                                     "value": str(_value),
9169                                 },
9170                             )
9171                         elif "AdvAudit" in _pol:
9172                             _advaudits.setdefault(
9173                                 policy_name,
9174                                 {
9175                                     "option": _pol["AdvAudit"]["Option"],
9176                                     "value": str(_value),
9177                                 },
9178                             )
9179                         elif "NetUserModal" in _pol:
9180                             log.trace("%s is a NetUserModal policy", policy_name)
9181                             if _pol[</b></font>"NetUserModal"]["Modal"] not in _modal_sets:
9182                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
9183                             _modal_sets[_pol["NetUserModal"]["Modal"]][
9184                                 _pol["NetUserModal"]["Option"]
9185                             ] = _value
9186                         elif "LsaRights" in _pol:
9187                             log.trace("%s is a LsaRights policy", policy_name)
9188                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
9189                     else:
9190                         _value = policies[p_class][policy_name]
9191                         log.trace('searching for "%s" in admx data', policy_name)
9192                         (
9193                             success,
9194                             the_policy,
9195                             policy_name_list,
9196                             msg,
9197                         ) = _lookup_admin_template(
9198                             policy_name=policy_name,
9199                             policy_class=p_class,
9200                             adml_language=adml_language,
9201                         )
9202                         if success:
9203                             policy_name = the_policy.attrib["name"]
9204                             policy_namespace = the_policy.nsmap[the_policy.prefix]
9205                             if policy_namespace not in _admTemplateData:
9206                                 _admTemplateData[policy_namespace] = {}
9207                             _admTemplateData[policy_namespace][policy_name] = _value
9208                         else:
9209                             raise SaltInvocationError(msg)
9210                         if (
9211                             policy_namespace
9212                             and policy_name in _admTemplateData[policy_namespace]
9213                             and the_policy is not None
9214                         ):
9215                             log.trace(
9216                                 "setting == %s",
9217                                 str(
9218                                     _admTemplateData[policy_namespace][policy_name]
9219                                 ).lower(),
9220                             )
9221                             log.trace(
9222                                 str(
9223                                     _admTemplateData[policy_namespace][policy_name]
9224                                 ).lower()
9225                             )
9226                             if (
9227                                 str(
9228                                     _admTemplateData[policy_namespace][policy_name]
9229                                 ).lower()
9230                                 != "disabled"
9231                                 and str(
9232                                     _admTemplateData[policy_namespace][policy_name]
9233                                 ).lower()
9234                                 != "not configured"
9235                             ):
9236                                 if ELEMENTS_XPATH(the_policy):
9237                                     if isinstance(
9238                                         _admTemplateData[policy_namespace][policy_name],
9239                                         dict,
9240                                     ):
9241                                         for elements_item in ELEMENTS_XPATH(the_policy):
9242                                             for child_item in elements_item:
9243                                                 log.trace(
9244                                                     "checking element %s",
9245                                                     child_item.attrib["id"],
9246                                                 )
9247                                                 temp_element_name = None
9248                                                 this_element_name = _getFullPolicyName(
9249                                                     policy_item=child_item,
9250                                                     policy_name=child_item.attrib["id"],
9251                                                     return_full_policy_names=True,
9252                                                     adml_language=adml_language,
9253                                                 )
9254                                                 log.trace(
9255                                                     'id attribute == "%s" '
9256                                                     ' this_element_name == "%s"',
9257                                                     child_item.attrib["id"],
9258                                                     this_element_name,
9259                                                 )
9260                                                 if (
9261                                                     this_element_name
9262                                                     in _admTemplateData[
9263                                                         policy_namespace
9264                                                     ][policy_name]
9265                                                 ):
9266                                                     temp_element_name = (
9267                                                         this_element_name
9268                                                     )
9269                                                 elif (
9270                                                     child_item.attrib["id"]
9271                                                     in _admTemplateData[
9272                                                         policy_namespace
9273                                                     ][policy_name]
9274                                                 ):
9275                                                     temp_element_name = (
9276                                                         child_item.attrib["id"]
9277                                                     )
9278                                                 else:
9279                                                     raise SaltInvocationError(
9280                                                         'Element "{}" must be included'
9281                                                         " in the policy configuration"
9282                                                         " for policy {}".format(
9283                                                             this_element_name,
9284                                                             policy_name,
9285                                                         )
9286                                                     )
9287                                                 if (
9288                                                     "required" in child_item.attrib
9289                                                     and child_item.attrib[
9290                                                         "required"
9291                                                     ].lower()
9292                                                     == "true"
9293                                                 ):
9294                                                     if not _admTemplateData[
9295                                                         policy_namespace
9296                                                     ][policy_name][temp_element_name]:
9297                                                         raise SaltInvocationError(
9298                                                             'Element "{}" requires a value '
9299                                                             "to be specified".format(
9300                                                                 temp_element_name
9301                                                             )
9302                                                         )
9303                                                 if (
9304                                                     etree.QName(child_item).localname
9305                                                     == "boolean"
9306                                                 ):
9307                                                     if not isinstance(
9308                                                         _admTemplateData[
9309                                                             policy_namespace
9310                                                         ][policy_name][
9311                                                             temp_element_name
9312                                                         ],
9313                                                         bool,
9314                                                     ):
9315                                                         raise SaltInvocationError(
9316                                                             "Element {} requires a boolean "
9317                                                             "True or False".format(
9318                                                                 temp_element_name
9319                                                             )
9320                                                         )
9321                                                 elif (
9322                                                     etree.QName(child_item).localname
9323                                                     == "decimal"
9324                                                     or etree.QName(child_item).localname
9325                                                     == "longDecimal"
9326                                                 ):
9327                                                     min_val = 0
9328                                                     max_val = 9999
9329                                                     if "minValue" in child_item.attrib:
9330                                                         min_val = int(
9331                                                             child_item.attrib[
9332                                                                 "minValue"
9333                                                             ]
9334                                                         )
9335                                                     if "maxValue" in child_item.attrib:
9336                                                         max_val = int(
9337                                                             child_item.attrib[
9338                                                                 "maxValue"
9339                                                             ]
9340                                                         )
9341                                                     if (
9342                                                         int(
9343                                                             _admTemplateData[
9344                                                                 policy_namespace
9345                                                             ][policy_name][
9346                                                                 temp_element_name
9347                                                             ]
9348                                                         )
9349                                                         &lt; min_val
9350                                                         or int(
9351                                                             _admTemplateData[
9352                                                                 policy_namespace
9353                                                             ][policy_name][
9354                                                                 temp_element_name
9355                                                             ]
9356                                                         )
9357                                                         &gt; max_val
9358                                                     ):
9359                                                         raise SaltInvocationError(
9360                                                             'Element "{}" value must be between '
9361                                                             "{} and {}".format(
9362                                                                 temp_element_name,
9363                                                                 min_val,
9364                                                                 max_val,
9365                                                             )
9366                                                         )
9367                                                 elif (
9368                                                     etree.QName(child_item).localname
9369                                                     == "enum"
9370                                                 ):
9371                                                     found = False
9372                                                     for enum_item in child_item:
9373                                                         if (
9374                                                             _admTemplateData[
9375                                                                 policy_namespace
9376                                                             ][policy_name][
9377                                                                 temp_element_name
9378                                                             ]
9379                                                             == _getAdmlDisplayName(
9380                                                                 adml_policy_resources,
9381                                                                 enum_item.attrib[
9382                                                                     "displayName"
9383                                                                 ],
9384                                                             ).strip()
9385                                                         ):
9386                                                             found = True
9387                                                             break
9388                                                     if not found:
9389                                                         raise SaltInvocationError(
9390                                                             'Element "{}" does not have'
9391                                                             " a valid value".format(
9392                                                                 temp_element_name
9393                                                             )
9394                                                         )
9395                                                 elif (
9396                                                     etree.QName(child_item).localname
9397                                                     == "list"
9398                                                 ):
9399                                                     if (
9400                                                         "explicitValue"
9401                                                         in child_item.attrib
9402                                                         and child_item.attrib[
9403                                                             "explicitValue"
9404                                                         ].lower()
9405                                                         == "true"
9406                                                     ):
9407                                                         if not isinstance(
9408                                                             _admTemplateData[
9409                                                                 policy_namespace
9410                                                             ][policy_name][
9411                                                                 temp_element_name
9412                                                             ],
9413                                                             dict,
9414                                                         ):
9415                                                             raise SaltInvocationError(
9416                                                                 "Each list item of element "
9417                                                                 '"{}" requires a dict '
9418                                                                 "value".format(
9419                                                                     temp_element_name
9420                                                                 )
9421                                                             )
9422                                                     elif not isinstance(
9423                                                         _admTemplateData[
9424                                                             policy_namespace
9425                                                         ][policy_name][
9426                                                             temp_element_name
9427                                                         ],
9428                                                         list,
9429                                                     ):
9430                                                         raise SaltInvocationError(
9431                                                             'Element "{}" requires a'
9432                                                             " list value".format(
9433                                                                 temp_element_name
9434                                                             )
9435                                                         )
9436                                                 elif (
9437                                                     etree.QName(child_item).localname
9438                                                     == "multiText"
9439                                                 ):
9440                                                     if not isinstance(
9441                                                         _admTemplateData[
9442                                                             policy_namespace
9443                                                         ][policy_name][
9444                                                             temp_element_name
9445                                                         ],
9446                                                         list,
9447                                                     ):
9448                                                         raise SaltInvocationError(
9449                                                             'Element "{}" requires a'
9450                                                             " list value".format(
9451                                                                 temp_element_name
9452                                                             )
9453                                                         )
9454                                                 _admTemplateData[policy_namespace][
9455                                                     policy_name
9456                                                 ][
9457                                                     child_item.attrib["id"]
9458                                                 ] = _admTemplateData[
9459                                                     policy_namespace
9460                                                 ][
9461                                                     policy_name
9462                                                 ].pop(
9463                                                     temp_element_name
9464                                                 )
9465                                     else:
9466                                         raise SaltInvocationError(
9467                                             'The policy "{}" has elements which must be'
9468                                             " configured".format(policy_name)
9469                                         )
9470                                 else:
9471                                     if (
9472                                         str(
9473                                             _admTemplateData[policy_namespace][
9474                                                 policy_name
9475                                             ]
9476                                         ).lower()
9477                                         != "enabled"
9478                                     ):
9479                                         raise SaltInvocationError(
9480                                             'The policy {} must either be "Enabled", '
9481                                             '"Disabled", or "Not Configured"'.format(
9482                                                 policy_name
9483                                             )
9484                                         )
9485                 if _regedits:
9486                     for regedit in _regedits:
9487                         log.trace("%s is a Registry policy", regedit)
9488                         if (
9489                             _regedits[regedit]["value"] is not None
9490                         ):
9491                             _ret = __utils__["reg.set_value"](
9492                                 _regedits<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[regedit]["policy"]["Registry"]["Hive"],
9493                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9494                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9495                                 _regedits[regedit]["value"],
9496                                 _regedits[regedit]["policy"]["Registry"]["Type"],
9497                             )
9498                         else:
9499                             _ret = __utils__["reg.read_value"](</b></font>
9500                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9501                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9502                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9503                             )
9504                             if _ret["success"] and _ret["vdata"] != "(value not set)":
9505                                 _ret = __utils__["reg.delete_value"](
9506                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
9507                                     _regedits[regedit]["policy"]["Registry"]["Path"],
9508                                     _regedits[regedit]["policy"]["Registry"]["Value"],
9509                                 )
9510                         if not _ret:
9511                             raise CommandExecutionError(
9512                                 "Error while attempting to set policy {} via the"
9513                                 " registry.  Some changes may not be applied as"
9514                                 " expected".format(regedit)
9515                             )
9516                 if _lsarights:
9517                     for lsaright in _lsarights:
9518                         _existingUsers = None
9519                         if not cumulative_rights_assignments:
9520                             _existingUsers = _getRightsAssignments(
9521                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
9522                             )
9523                         if _lsarights[lsaright]["value"]:
9524                             for acct in _lsarights[lsaright]["value"]:
9525                                 _ret = _addAccountRights(
9526                                     acct,
9527                                     _lsarights[lsaright]["policy"]["LsaRights"][
9528                                         "Option"
9529                                     ],
9530                                 )
9531                                 if not _ret:
9532                                     raise SaltInvocationError(
9533                                         "An error occurred attempting to configure the"
9534                                         " user right {}.".format(lsaright)
9535                                     )
9536                         if _existingUsers:
9537                             for acct in _existingUsers:
9538                                 if acct not in _lsarights[lsaright]["value"]:
9539                                     _ret = _delAccountRights(
9540                                         acct,
9541                                         _lsarights[lsaright]["policy"]["LsaRights"][
9542                                             "Option"
9543                                         ],
9544                                     )
9545                                     if not _ret:
9546                                         raise SaltInvocationError(
9547                                             "An error occurred attempting to remove previously "
9548                                             "configured users with right {}.".format(
9549                                                 lsaright
9550                                             )
9551                                         )
9552                 if _secedits:
9553                     log.trace(_secedits)
9554                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
9555                     _seceditSections = [
9556                         "System Access",
9557                         "Event Audit",
9558                         "Registry Values",
9559                         "Privilege Rights",
9560                     ]
9561                     for _seceditSection in _seceditSections:
9562                         if _seceditSection in _secedits:
9563                             ini_data = "\r\n".join(
9564                                 [
9565                                     ini_data,
9566                                     "".join(["[", _seceditSection, "]"]),
9567                                     "\r\n".join(_secedits[_seceditSection]),
9568                                 ]
9569                             )
9570                     ini_data = "\r\n".join(
9571                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
9572                     )
9573                     log.trace("ini_data == %s", ini_data)
9574                     if not _write_secedit_data(ini_data):
9575                         raise CommandExecutionError(
9576                             "Error while attempting to set policies via "
9577                             "secedit. Some changes may not be applied as "
9578                             "expected"
9579                         )
9580                 if _netshs:
9581                     for setting in _netshs:
9582                         log.trace("Setting firewall policy: %s", setting)
9583                         log.trace(_netshs[setting])
9584                         _set_netsh_value(**_netshs[setting])
9585                 if _advaudits:
9586                     for setting in _advaudits:
9587                         log.trace("Setting Advanced Audit policy: %s", setting)
9588                         log.trace(_advaudits[setting])
9589                         _set_advaudit_value(**_advaudits[setting])
9590                 if _modal_sets:
9591                     log.trace(_modal_sets)
9592                     for _modal_set in _modal_sets:
9593                         try:
9594                             _existingModalData = win32net.NetUserModalsGet(
9595                                 None, _modal_set
9596                             )
9597                             _newModalSetData = dictupdate.update(
9598                                 _existingModalData, _modal_sets[_modal_set]
9599                             )
9600                             log.trace("NEW MODAL SET = %s", _newModalSetData)
9601                             _ret = win32net.NetUserModalsSet(
9602                                 None, _modal_set, _newModalSetData
9603                             )
9604                         except Exception as exc:  # pylint: disable=broad-except
9605                             msg = (
9606                                 "An unhandled exception occurred while "
9607                                 "attempting to set policy via "
9608                                 "NetUserModalSet\n{}".format(exc)
9609                             )
9610                             log.exception(msg)
9611                             raise CommandExecutionError(msg)
9612                 if _admTemplateData:
9613                     _ret = False
9614                     log.trace(
9615                         "going to write some adm template data :: %s", _admTemplateData
9616                     )
9617                     _ret = _writeAdminTemplateRegPolFile(
9618                         _admTemplateData,
9619                         adml_language=adml_language,
9620                         registry_class=p_class,
9621                     )
9622                     if not _ret:
9623                         raise CommandExecutionError(
9624                             "Error while attempting to write Administrative Template"
9625                             " Policy data.  Some changes may not be applied as expected"
9626                         )
9627         return True
9628     else:
9629         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Work with virtual machines managed by libvirt
3 :depends:
4     * libvirt Python module
5     * libvirt client
6     * qemu-img
7     * grep
8 Connection
9 ==========
10 The connection to the virtualization host can be either setup in the minion configuration,
11 pillar data or overridden for each individual call.
12 By default, the libvirt connection URL will be guessed: the first available libvirt
13 hypervisor driver will be used. This can be overridden like this:
14 .. code-block:: yaml
15     virt:
16       connection:
17         uri: lxc:///
18 If the connection requires an authentication like for ESXi, this can be defined in the
19 minion pillar data like this:
20 .. code-block:: yaml
21     virt:
22       connection:
23         uri: esx://10.1.1.101/?no_verify=1&amp;auto_answer=1
24         auth:
25           username: user
26           password: secret
27 Connecting with SSH protocol
28 ----------------------------
29 Libvirt can connect to remote hosts using SSH using one of the ``ssh``, ``libssh`` and
30 ``libssh2`` transports. Note that ``libssh2`` is likely to fail as it doesn't read the
31 ``known_hosts`` file. Libvirt may also have been built without ``libssh`` or ``libssh2``
32 support.
33 To use the SSH transport, on the minion setup an SSH agent with a key authorized on
34 the remote libvirt machine.
35 Per call connection setup
36 -------------------------
37 .. versionadded:: 2019.2.0
38 All the calls requiring the libvirt connection configuration as mentioned above can
39 override this configuration using ``connection``, ``username`` and ``password`` parameters.
40 This means that the following will list the domains on the local LXC libvirt driver,
41 whatever the ``virt:connection`` is.
42 .. code-block:: bash
43     salt 'hypervisor' virt.list_domains connection=lxc:///
44 The calls not using the libvirt connection setup are:
45 - ``seed_non_shared_migrate``
46 - ``virt_type``
47 - ``is_*hyper``
48 - all migration functions
49 - `libvirt ESX URI format &lt;http://libvirt.org/drvesx.html#uriformat&gt;`_
50 - `libvirt URI format &lt;http://libvirt.org/uri.html#URI_config&gt;`_
51 - `libvirt authentication configuration &lt;http://libvirt.org/auth.html#Auth_client_config&gt;`_
52 Units
53 ==========
54 .. _virt-units:
55 .. rubric:: Units specification
56 .. versionadded:: 3002
57 The string should contain a number optionally followed
58 by a unit. The number may have a decimal fraction. If
59 the unit is not given then MiB are set by default.
60 Units can optionally be given in IEC style (such as MiB),
61 although the standard single letter style (such as M) is
62 more convenient.
63 Valid units include:
64 ========== =====    ==========  ==========  ======
65 Standard   IEC      Standard    IEC
66   Unit     Unit     Name        Name        Factor
67 ========== =====    ==========  ==========  ======
68     B               Bytes                   1
69     K       KiB     Kilobytes   Kibibytes   2**10
70     M       MiB     Megabytes   Mebibytes   2**20
71     G       GiB     Gigabytes   Gibibytes   2**30
72     T       TiB     Terabytes   Tebibytes   2**40
73     P       PiB     Petabytes   Pebibytes   2**50
74     E       EiB     Exabytes    Exbibytes   2**60
75     Z       ZiB     Zettabytes  Zebibytes   2**70
76     Y       YiB     Yottabytes  Yobibytes   2**80
77 ========== =====    ==========  ==========  ======
78 Additional decimal based units:
79 ======  =======
80 Unit     Factor
81 ======  =======
82 KB      10**3
83 MB      10**6
84 GB      10**9
85 TB      10**12
86 PB      10**15
87 EB      10**18
88 ZB      10**21
89 YB      10**24
90 ======  =======
91 """
92 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import base64
93 import collections
94 import copy
95 import datetime
96 import logging
97 import os
98 import re
99 import shutil
100 import string  # pylint: disable=deprecated-module
101 import subprocess
102 import sys
103 import time
104 import urllib.parse
105 from xml.etree import ElementTree
106 from xml.sax import saxutils
107 import jinja2.exceptions
108 import salt.utils.data
109 import salt.utils.files
110 import salt.utils.json
111 import</b></font> salt.utils.path
112 import salt.utils.stringutils
113 import salt.utils.templates
114 import salt.utils.virt
115 import salt.utils.xmlutil as xmlutil
116 import salt.utils.yaml
117 from salt._compat import ipaddress
118 from salt.exceptions import CommandExecutionError, SaltInvocationError
119 try:
120     import libvirt  # pylint: disable=import-error
121     from libvirt import libvirtError
122     HAS_LIBVIRT = True
123 except ImportError:
124     HAS_LIBVIRT = False
125 JINJA = jinja2<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Environment(
126     loader=jinja2.FileSystemLoader(
127         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "virt")
128     )
129 )
130 CACHE_DIR =</b></font> "/var/lib/libvirt/saltinst"
131 VIRT_STATE_NAME_MAP = {
132     0: "running",
133     1: "running",
134     2: "running",
135     3: "paused",
136     4: "shutdown",
137     5: "shutdown",
138     6: "crashed",
139 }
140 def __virtual__():
141     if not HAS_LIBVIRT:
142         return (False, "Unable to locate or import python libvirt library.")
143     return "virt"
144 def __get_request_auth(username, password):
145     """
146     Get libvirt.openAuth callback with username, password values overriding
147     the configuration ones.
148     """
149     def __request_auth(credentials, user_data):
150         """Callback method passed to libvirt.openAuth().
151         The credentials argument is a list of credentials that libvirt
152         would like to request. An element of this list is a list containing
153         5 items (4 inputs, 1 output):
154           - the credential type, e.g. libvirt.VIR_CRED_AUTHNAME
155           - a prompt to be displayed to the user
156           - a challenge
157           - a default result for the request
158           - a place to store the actual result for the request
159         The user_data argument is currently not set in the openAuth call.
160         """
161         for credential in credentials:
162             if credential[0] == libvirt.VIR_CRED_AUTHNAME:
163                 credential[4] = (
164                     username
165                     if username
166                     else __salt__["config.get"](
167                         "virt:connection:auth:username", credential[3]
168                     )
169                 )
170             elif credential[0] == libvirt.VIR_CRED_NOECHOPROMPT:
171                 credential[4] = (
172                     password
173                     if password
174                     else __salt__["config.get"](
175                         "virt:connection:auth:password", credential[3]
176                     )
177                 )
178             else:
179                 log.info("Unhandled credential type: %s", credential[0])
180         return 0
181 def __get_conn(**kwargs):
182     """
183     Detects what type of dom this node is and attempts to connect to the
184     correct hypervisor via libvirt.
185     :param connection: libvirt connection URI, overriding defaults
186     :param username: username to connect with, overriding defaults
187     :param password: password to connect with, overriding defaults
188     """
189     username = kwargs.get("username", None)
190     password = kwargs.get("password", None)
191     conn_str = kwargs.get("connection", None)
192     if not conn_str:
193         conn_str = __salt__["config.get"]("virt:connection:uri", conn_str)
194     try:
195         auth_types = [
196             libvirt.VIR_CRED_AUTHNAME,
197             libvirt.VIR_CRED_NOECHOPROMPT,
198             libvirt.VIR_CRED_ECHOPROMPT,
199             libvirt.VIR_CRED_PASSPHRASE,
200             libvirt.VIR_CRED_EXTERNAL,
201         ]
202         conn = libvirt.openAuth(
203             conn_str, [auth_types, __get_request_auth(username, password), None], 0
204         )
205     except Exception:  # pylint: disable=broad-except
206         raise CommandExecutionError(
207             "Sorry, {} failed to open a connection to the hypervisor "
208             "software at {}".format(__grains__["fqdn"], conn_str)
209         )
210     return conn
211 def _get_domain(conn, *vms, **kwargs):
212     """
213     Return a domain object for the named VM or return domain object for all VMs.
214     :params conn: libvirt connection object
215     :param vms: list of domain names to look for
216     :param iterable: True to return an array in all cases
217     """
218     ret = list()
219     lookup_vms = list()
220     all_vms = []
221     if kwargs.get("active", True):
222         for id_ in conn.listDomainsID():
223             all_vms.append(conn.lookupByID(id_).name())
224     if kwargs.get("inactive", True):
225         for id_ in conn.listDefinedDomains():
226             all_vms.append(id_)
227     if vms and not all_vms:
228         raise CommandExecutionError("No virtual machines found.")
229     if vms:
230         for name in vms:
231             if name not in all_vms:
232                 raise CommandExecutionError(
233                     'The VM "{name}" is not present'.format(name=name)
234                 )
235             else:
236                 lookup_vms.append(name)
237     else:
238         lookup_vms = list(all_vms)
239     for name in lookup_vms:
240         ret.append(conn.lookupByName(name))
241     return len(ret) == 1 and not kwargs.get("iterable") and ret[0] or ret
242 def _parse_qemu_img_info(info):
243     """
244     Parse qemu-img info JSON output into disk infos dictionary
245     """
246     raw_infos = salt.utils.json.loads(info)
247     disks = []
248     for disk_infos in raw_infos:
249         disk = {
250             "file": disk_infos["filename"],
251             "file format": disk_infos["format"],
252             "disk size": disk_infos["actual-size"],
253             "virtual size": disk_infos["virtual-size"],
254             "cluster size": disk_infos["cluster-size"]
255             if "cluster-size" in disk_infos
256             else None,
257         }
258         if "full-backing-filename" in disk_infos.keys():
259             disk["backing file"] = format(disk_infos["full-backing-filename"])
260         if "snapshots" in disk_infos.keys():
261             disk["snapshots"] = [
262                 {
263                     "id": snapshot["id"],
264                     "tag": snapshot["name"],
265                     "vmsize": snapshot["vm-state-size"],
266                     "date": datetime.datetime.fromtimestamp(
267                         float(
268                             "{}.{}".format(snapshot["date-sec"], snapshot["date-nsec"])
269                         )
270                     ).isoformat(),
271                     "vmclock": datetime.datetime.utcfromtimestamp(
272                         float(
273                             "{}.{}".format(
274                                 snapshot["vm-clock-sec"], snapshot["vm-clock-nsec"]
275                             )
276                         )
277                     )
278                     .time()
279                     .isoformat(),
280                 }
281                 for snapshot in disk_infos["snapshots"]
282             ]
283         disks.append(disk)
284     for disk in disks:
285         if "backing file" in disk.keys():
286             candidates = [
287                 info
288                 for info in disks
289                 if "file" in info.keys() and info["file"] == disk["backing file"]
290             ]
291             if candidates:
292                 disk["backing file"] = candidates[0]
293     return disks[0]
294 def _get_uuid(dom):
295     """
296     Return a uuid from the named vm
297     CLI Example:
298     .. code-block:: bash
299         salt '*' virt.get_uuid &lt;domain&gt;
300     """
301     return ElementTree.fromstring(get_xml(dom)).find("uuid").text
302 def _get_on_poweroff(dom):
303     """
304     Return `on_poweroff` setting from the named vm
305     CLI Example:
306     .. code-block:: bash
307         salt '*' virt.get_on_restart &lt;domain&gt;
308     """
309     node = ElementTree.fromstring(get_xml(dom)).find("on_poweroff")
310     return node.text if node is not None else ""
311 def _get_on_reboot(dom):
312     """
313     Return `on_reboot` setting from the named vm
314     CLI Example:
315     .. code-block:: bash
316         salt '*' virt.get_on_reboot &lt;domain&gt;
317     """
318     node = ElementTree.fromstring(get_xml(dom)).find("on_reboot")
319     return node.text if node is not None else ""
320 def _get_on_crash(dom):
321     """
322     Return `on_crash` setting from the named vm
323     CLI Example:
324     .. code-block:: bash
325         salt '*' virt.get_on_crash &lt;domain&gt;
326     """
327     node = ElementTree.fromstring(get_xml(dom)).find("on_crash")
328     return node.text if node is not None else ""
329 def _get_nics(dom):
330     """
331     Get domain network interfaces from a libvirt domain object.
332     """
333     nics = {}
334     doc = ElementTree.fromstring(dom.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
335     for iface_node in doc.findall("devices/interface"):
336         nic = {}
337         nic["type"] = iface_node.get("type")
338         for v_node in iface_node:
339             if v_node.tag == "mac":
340                 nic["mac"] = v_node.get("address")
341             if v_node.tag == "model":
342                 nic["model"] = v_node.get("type")
343             if v_node.tag == "target":
344                 nic["target"] = v_node.get("dev")
345             if re.match("(driver|source|address)", v_node.tag):
346                 temp = {}
347                 for key, value in v_node.attrib.items():
348                     temp[key] = value
349                 nic[v_node.tag] = temp
350             if v_node.tag == "virtualport":
351                 temp = {}
352                 temp["type"] = v_node.get("type")
353                 for key, value in v_node.attrib.items():
354                     temp[key] = value
355                 nic["virtualport"] = temp
356         if "mac" not in nic:
357             continue
358         nics[nic["mac"]] = nic
359     return nics
360 def _get_graphics(dom):
361     """
362     Get domain graphics from a libvirt domain object.
363     """
364     out = {
365         "autoport": "None",
366         "keymap": "None",
367         "listen": "None",
368         "port": "None",
369         "type": "None",
370     }
371     doc = ElementTree.fromstring(dom.XMLDesc(0))
372     for g_node in doc.findall("devices/graphics"):
373         for key, value in g_node.attrib.items():
374             out[key] = value
375     return out
376 def _get_loader(dom):
377     """
378     Get domain loader from a libvirt domain object.
379     """
380     out = {"path": "None"}
381     doc = ElementTree.fromstring(dom.XMLDesc(0))
382     for g_node in doc.findall("os/loader"):
383         out["path"] = g_node.text
384         for key, value in g_node.attrib.items():
385             out[key] = value
386     return out
387 def _get_disks(conn, dom):
388     """
389     Get domain disks from a libvirt domain object.
390     """
391     disks = {}
392     doc = ElementTree.fromstring(dom.XMLDesc(0))
393     all_volumes = _get_all_volumes_paths(conn)
394     for elem in doc.findall("devices/disk"):
395         source = elem.find("source")
396         if source is None:
397             continue
398         target = elem.find("target")
399         driver = elem.find("driver")
400         if target is None:
401             continue
402         qemu_target = None
403         extra_properties = None
404         if "dev" in target.attrib:
405             disk_type = elem.get("type")
406             def _get_disk_volume_data(pool_name, volume_name):
407                 qemu_target = "{}/{}".format(pool_name, volume_name)
408                 pool = conn.storagePoolLookupByName(pool_name)
409                 extra_properties = {}
410                 try:
411                     vol = pool.storageVolLookupByName(volume_name)
412                     vol_info = vol.info()
413                     extra_properties = {
414                         "virtual size": vol_info[1],
415                         "disk size": vol_info[2],
416                     }
417                     backing_files = [
418                         {
419                             "file": node.find("source").get("file"),
420                             "file format": node.find("format").get("type"),
421                         }
422                         for node in elem.findall(".//backingStore[source]")
423                     ]
424                     if backing_files:
425                         extra_properties["backing file"] = backing_files[0]
426                         parent = extra_properties["backing file"]
427                         for sub_backing_file in backing_files[1:]:
428                             parent["backing file"] = sub_backing_file
429                             parent = sub_backing_file
430                     else:
431                         vol_desc = ElementTree.fromstring(vol.XMLDesc())
432                         backing_path = vol_desc.find("./backingStore/path")
433                         backing_format = vol_desc.find("./backingStore/format")
434                         if backing_path is not None:
435                             extra_properties["backing file"] = {
436                                 "file": backing_path.text
437                             }
438                             if backing_format is not None:
439                                 extra_properties["backing file"][
440                                     "file format"
441                                 ] = backing_format.get("type")
442                 except libvirt.libvirtError:
443                     log.info(
444                         "Couldn't extract all volume informations: pool is likely not"
445                         " running or refreshed"
446                     )
447                 return (qemu_target, extra_properties)
448             if disk_type == "file":
449                 qemu_target = source.get("file", "")
450                 if qemu_target.startswith("/dev/zvol/"):
451                     disks[target.get("dev")] = {"file": qemu_target, "zfs": True}
452                     continue
453                 if qemu_target in all_volumes.keys():
454                     volume = all_volumes[qemu_target]
455                     qemu_target, extra_properties = _get_disk_volume_data(
456                         volume["pool"], volume["name"]
457                     )
458                 elif elem.get("device", "disk") != "cdrom":
459                     try:
460                         process = subprocess.Popen(
461                             [
462                                 "qemu-img",
463                                 "info",
464                                 "-U",
465                                 "--output",
466                                 "json",
467                                 "--backing-chain",
468                                 qemu_target,
469                             ],
470                             shell=False,
471                             stdout=subprocess.PIPE,
472                             stderr=subprocess.PIPE,
473                         )
474                         stdout, stderr = process.communicate()
475                         if process.returncode == 0:
476                             qemu_output = salt.utils.stringutils.to_str(stdout)
477                             output = _parse_qemu_img_info(qemu_output)
478                             extra_properties = output
479                         else:
480                             extra_properties = {"error": stderr}
481                     except FileNotFoundError:
482                         extra_properties = {"error": "qemu-img not found"}
483             elif disk_type == "block":
484                 qemu_target = source.get("dev", "")
485                 if qemu_target in all_volumes.keys():
486                     volume = all_volumes[qemu_target]
487                     qemu_target, extra_properties = _get_disk_volume_data(
488                         volume["pool"], volume["name"]
489                     )
490             elif disk_type == "network":
491                 qemu_target = source.get("protocol")
492                 source_name = source.get("name")
493                 if source_name:
494                     qemu_target = "{}:{}".format(qemu_target, source_name)
495                 if source.get("protocol") in ["rbd", "gluster"]:
496                     for pool_i in conn.listAllStoragePools():
497                         pool_i_xml = ElementTree.fromstring(pool_i.XMLDesc())
498                         name_node = pool_i_xml.find("source/name")
499                         if name_node is not None and source_name.startswith(
500                             "{}/".format(name_node.text)
501                         ):
502                             qemu_target = "{}{}".format(
503                                 pool_i.name(), source_name[len(name_node.text) :]
504                             )
505                             break
506                 if elem.get("device", "disk") == "cdrom":
507                     host_node = source.find("host")
508                         hostname = host_node.get("name")
509                         port = host_node.get("port")
510                         qemu_target <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= urllib.parse.urlunparse(
511                             (
512                                 source.get("protocol"),
513                                 "{}:{}".format(hostname, port) if port else hostname,
514                                 source_name,
515                                 "",
516                                 saxutils.unescape(source.get(</b></font>"query", "")),
517                                 "",
518                             )
519                         )
520             elif disk_type == "volume":
521                 pool_name = source.get("pool")
522                 volume_name = source.get("volume")
523                 qemu_target, extra_properties = _get_disk_volume_data(
524                     pool_name, volume_name
525                 )
526             if not qemu_target:
527                 continue
528             disk = {
529                 "file": qemu_target,
530                 "type": elem.get("device"),
531             }
532             if driver is not None and "type" in driver.attrib:
533                 disk["file format"] = driver.get("type")
534             if extra_properties:
535                 disk.update(extra_properties)
536             disks[target.get("dev")] = disk
537     return disks
538 def _libvirt_creds():
539     """
540     Returns the user and group that the disk images should be owned by
541     """
542     g_cmd = ["grep", "^\\s*group", "/etc/libvirt/qemu.conf"]
543     u_cmd = ["grep", "^\\s*user", "/etc/libvirt/qemu.conf"]
544     try:
545         stdout = subprocess.Popen(g_cmd, stdout=subprocess.PIPE).communicate()[0]
546         group = salt.utils.stringutils.to_str(stdout).split('"')[1]
547     except IndexError:
548         group = "root"
549     try:
550         stdout = subprocess.Popen(u_cmd, stdout=subprocess.PIPE).communicate()[0]
551         user = salt.utils.stringutils.to_str(stdout).split('"')[1]
552     except IndexError:
553         user = "root"
554     return {"user": user, "group": group}
555 def _migrate(dom, dst_uri, **kwargs):
556     """
557     Migrate the domain object from its current host to the destination
558     host given by URI.
559     :param dom: domain object to migrate
560     :param dst_uri: destination URI
561     :param kwargs:
562         - live:            Use live migration. Default value is True.
563         - persistent:      Leave the domain persistent on destination host.
564                            Default value is True.
565         - undefinesource:  Undefine the domain on the source host.
566                            Default value is True.
567         - offline:         If set to True it will migrate the domain definition
568                            without starting the domain on destination and without
569                            stopping it on source host. Default value is False.
570         - max_bandwidth:   The maximum bandwidth (in MiB/s) that will be used.
571         - max_downtime:    Set maximum tolerable downtime for live-migration.
572                            The value represents a number of milliseconds the guest
573                            is allowed to be down at the end of live migration.
574         - parallel_connections: Specify a number of parallel network connections
575                            to be used to send memory pages to the destination host.
576         - compressed:      Activate compression.
577         - comp_methods:    A comma-separated list of compression methods. Supported
578                            methods are "mt" and "xbzrle" and can be  used in any
579                            combination. QEMU defaults to "xbzrle".
580         - comp_mt_level:   Set compression level. Values are in range from 0 to 9,
581                            where 1 is maximum speed and 9 is  maximum compression.
582         - comp_mt_threads: Set number of compress threads on source host.
583         - comp_mt_dthreads: Set number of decompress threads on target host.
584         - comp_xbzrle_cache: Set the size of page cache for xbzrle compression in bytes.
585         - copy_storage:    Migrate non-shared storage. It must be one of the following
586                            values: all (full disk copy) or incremental (Incremental copy)
587         - postcopy:        Enable the use of post-copy migration.
588         - postcopy_bandwidth: The maximum bandwidth allowed in post-copy phase. (MiB/s)
589         - username:        Username to connect with target host
590         - password:        Password to connect with target host
591     """
592     flags = 0
593     params = {}
594     migrated_state = libvirt.VIR_DOMAIN_RUNNING_MIGRATED
595     if kwargs.get("live", True):
596         flags |= libvirt.VIR_MIGRATE_LIVE
597     if kwargs.get("persistent", True):
598         flags |= libvirt.VIR_MIGRATE_PERSIST_DEST
599     if kwargs.get("undefinesource", True):
600         flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE
601     max_bandwidth = kwargs.get("max_bandwidth")
602     if max_bandwidth:
603         try:
604             bandwidth_value = int(max_bandwidth)
605         except ValueError:
606             raise SaltInvocationError(
607                 "Invalid max_bandwidth value: {}".format(max_bandwidth)
608             )
609         dom.migrateSetMaxSpeed(bandwidth_value)
610     max_downtime = kwargs.get("max_downtime")
611     if max_downtime:
612         try:
613             downtime_value = int(max_downtime)
614         except ValueError:
615             raise SaltInvocationError(
616                 "Invalid max_downtime value: {}".format(max_downtime)
617             )
618         dom.migrateSetMaxDowntime(downtime_value)
619     if kwargs.get("offline") is True:
620         flags |= libvirt.VIR_MIGRATE_OFFLINE
621         migrated_state = libvirt.VIR_DOMAIN_RUNNING_UNPAUSED
622     if kwargs.get("compressed") is True:
623         flags |= libvirt.VIR_MIGRATE_COMPRESSED
624     comp_methods = kwargs.get("comp_methods")
625     if comp_methods:
626         params[libvirt.VIR_MIGRATE_PARAM_COMPRESSION] = comp_methods.split(",")
627     comp_options = {
628         "comp_mt_level": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,
629         "comp_mt_threads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,
630         "comp_mt_dthreads": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,
631         "comp_xbzrle_cache": libvirt.VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,
632     }
633     for (comp_option, param_key) in comp_options.items():
634         comp_option_value = kwargs.get(comp_option)
635         if comp_option_value:
636             try:
637                 params[param_key] = int(comp_option_value)
638             except ValueError:
639                 raise SaltInvocationError("Invalid {} value".format(comp_option))
640     parallel_connections = kwargs.get("parallel_connections")
641     if parallel_connections:
642         try:
643             params[libvirt.VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS] = int(
644                 parallel_connections
645             )
646         except ValueError:
647             raise SaltInvocationError("Invalid parallel_connections value")
648         flags |= libvirt.VIR_MIGRATE_PARALLEL
649     if __salt__["config.get"]("virt:tunnel"):
650         if parallel_connections:
651             raise SaltInvocationError(
652                 "Parallel migration isn't compatible with tunneled migration"
653             )
654         flags |= libvirt.VIR_MIGRATE_PEER2PEER
655         flags |= libvirt.VIR_MIGRATE_TUNNELLED
656     if kwargs.get("postcopy") is True:
657         flags |= libvirt.VIR_MIGRATE_POSTCOPY
658     postcopy_bandwidth = kwargs.get("postcopy_bandwidth")
659     if postcopy_bandwidth:
660         try:
661             postcopy_bandwidth_value = int(postcopy_bandwidth)
662         except ValueError:
663             raise SaltInvocationError("Invalid postcopy_bandwidth value")
664         dom.migrateSetMaxSpeed(
665             postcopy_bandwidth_value,
666             flags=libvirt.VIR_DOMAIN_MIGRATE_MAX_SPEED_POSTCOPY,
667         )
668     copy_storage = kwargs.get("copy_storage")
669     if copy_storage:
670         if copy_storage == "all":
671             flags |= libvirt.VIR_MIGRATE_NON_SHARED_DISK
672         elif copy_storage in ["inc", "incremental"]:
673             flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC
674         else:
675             raise SaltInvocationError("invalid copy_storage value")
676     try:
677         state = False
678         dst_conn = __get_conn(
679             connection=dst_uri,
680             username=kwargs.get("username"),
681             password=kwargs.get("password"),
682         )
683         new_dom = dom.migrate3(dconn=dst_conn, params=params, flags=flags)
684         if new_dom:
685             state = new_dom.state()
686         dst_conn.close()
687         return state and migrated_state in state
688     except libvirt.libvirtError as err:
689         dst_conn.close()
690         raise CommandExecutionError(err.get_error_message())
691 def _get_volume_path(pool, volume_name):
692     """
693     Get the path to a volume. If the volume doesn't exist, compute its path from the pool one.
694     """
695     if volume_name in pool.listVolumes():
696         volume = pool.storageVolLookupByName(volume_name)
697         volume_xml = ElementTree.fromstring(volume.XMLDesc())
698         return volume_xml.find("./target/path").text
699     pool_xml = ElementTree.fromstring(pool.XMLDesc())
700     pool_path = pool_xml.find("./target/path").text
701     return pool_path + "/" + volume_name
702 def _disk_from_pool(conn, pool, pool_xml, volume_name):
703     """
704     Create a disk definition out of the pool XML and volume name.
705     The aim of this function is to replace the volume-based definition when not handled by libvirt.
706     It returns the disk Jinja context to be used when creating the VM
707     """
708     pool_type = pool_xml.get("type")
709     disk_context = {}
710     if pool_type in ["dir", "netfs", "fs"]:
711         disk_context["type"] = "file"
712         disk_context["source_file"] = _get_volume_path(pool, volume_name)
713     elif pool_type in ["logical", "disk", "iscsi", "scsi"]:
714         disk_context["type"] = "block"
715         disk_context["format"] = "raw"
716         disk_context["source_file"] = _get_volume_path(pool, volume_name)
717     elif pool_type in ["rbd", "gluster", "sheepdog"]:
718         disk_context["type"] = "network"
719         disk_context["protocol"] = pool_type
720         disk_context["hosts"] = [
721             {"name": host.get("name"), "port": host.get("port")}
722             for host in pool_xml.findall(".//host")
723         ]
724         dir_node = pool_xml.find("./source/dir")
725         name_node = pool_xml.find("./source/name")
726         if name_node is not None:
727             disk_context["volume"] = "{}/{}".format(name_node.text, volume_name)
728         auth_node = pool_xml.find("./source/auth")
729         if auth_node is not None:
730             username = auth_node.get("username")
731             secret_node = auth_node.find("./secret")
732             usage = secret_node.get("usage")
733             if not usage:
734                 uuid = secret_node.get("uuid")
735                 usage = conn.secretLookupByUUIDString(uuid).usageID()
736             disk_context["auth"] = {
737                 "type": "ceph",
738                 "username": username,
739                 "usage": usage,
740             }
741     return disk_context
742 def _handle_unit(s, def_unit="m"):
743     """
744     Handle the unit conversion, return the value in bytes
745     """
746     m = re.match(r"(?P&lt;value&gt;[0-9.]*)\s*(?P&lt;unit&gt;.*)$", str(s).strip())
747     value = m.group("value")
748     unit = m.group("unit").lower() or def_unit
749     try:
750         value = int(value)
751     except ValueError:
752         try:
753             value = float(value)
754         except ValueError:
755             raise SaltInvocationError("invalid number")
756     dec = False
757     if re.match(r"[kmgtpezy]b$", unit):
758         dec = True
759     elif not re.match(r"(b|[kmgtpezy](ib)?)$", unit):
760         raise SaltInvocationError("invalid units")
761     p = "bkmgtpezy".index(unit[0])
762     value *= 10 ** (p * 3) if dec else 2 ** (p * 10)
763     return int(value)
764 def nesthash(value=None):
765     """
766     create default dict that allows arbitrary level of nesting
767     """
768     return collections.defaultdict(nesthash, value or {})
769 def _gen_xml(
770     conn,
771     name,
772     cpu,
773     mem,
774     diskp,
775     nicp,
776     hypervisor,
777     os_type,
778     arch,
779     graphics=None,
780     boot=None,
781     boot_dev=None,
782     numatune=None,
783     hypervisor_features=None,
784     clock=None,
785     serials=None,
786     consoles=None,
787     stop_on_reboot=False,
788     host_devices=None,
789     **kwargs
790 ):
791     """
792     Generate the XML string to define a libvirt VM
793     """
794     context = {
795         "hypervisor": hypervisor,
796         "name": name,
797         "hypervisor_features": hypervisor_features or {},
798         "clock": clock or {},
799         "on_reboot": "destroy" if stop_on_reboot else "restart",
800     }
801     context["to_kib"] = lambda v: int(_handle_unit(v) / 1024)
802     context["yesno"] = lambda v: "yes" if v else "no"
803     context["mem"] = nesthash()
804     if isinstance(mem, int):
805         context["mem"]["boot"] = mem
806         context["mem"]["current"] = mem
807     elif isinstance(mem, dict):
808         context["mem"] = nesthash(mem)
809     context["cpu"] = nesthash()
810     context["cputune"] = nesthash()
811     if isinstance(cpu, int):
812         context["cpu"]["maximum"] = str(cpu)
813     elif isinstance(cpu, dict):
814         context["cpu"] = nesthash(cpu)
815     if clock:
816         offset = "utc" if clock.get("utc", True) else "localtime"
817         if "timezone" in clock:
818             offset = "timezone"
819         context["clock"]["offset"] = offset
820     if hypervisor in ["qemu", "kvm"]:
821         context["numatune"] = numatune if numatune else {}
822         context["controller_model"] = False
823     elif hypervisor == "vmware":
824         context["controller_model"] = "lsilogic"
825     if graphics:
826         if "listen" not in graphics:
827             graphics["listen"] = {"type": "address", "address": "0.0.0.0"}
828         elif (
829             "address" not in graphics["listen"]
830             and graphics["listen"]["type"] == "address"
831         ):
832             graphics["listen"]["address"] = "0.0.0.0"
833         if graphics.get("type", "none") == "none":
834             graphics = None
835     context["graphics"] = graphics
836     context["boot_dev"] = boot_dev.split() if boot_dev is not None else ["hd"]
837     context["boot"] = boot if boot else {}
838     efi_value = context["boot"].get("efi", None) if boot else None
839     if efi_value is True:
840         context["boot"]["os_attrib"] = "firmware='efi'"
841     elif efi_value is not None and type(efi_value) != bool:
842         raise SaltInvocationError("Invalid efi value")
843     if os_type == "xen":
844         if __grains__["os_family"] == "Suse":
845             if not boot or not boot.get("kernel", None):
846                 paths = [
847                     path
848                     for path in ["/usr/share", "/usr/lib"]
849                     if os.path.exists(path + "/grub2/x86_64-xen/grub.xen")
850                 ]
851                 if not paths:
852                     raise CommandExecutionError("grub-x86_64-xen needs to be installed")
853                 context["boot"]["kernel"] = paths[0] + "/grub2/x86_64-xen/grub.xen"
854                 context["boot_dev"] = []
855     default_port = 23023
856     default_chardev_type = "tcp"
857     chardev_types = ["serial", "console"]
858     for chardev_type in chardev_types:
859         context[chardev_type + "s"] = []
860         parameter_value = locals()[chardev_type + "s"]
861         if parameter_value is not None:
862             for chardev in parameter_value:
863                 chardev_context = chardev
864                 chardev_context["type"] = chardev.get("type", default_chardev_type)
865                 if chardev_context["type"] == "tcp":
866                     chardev_context["port"] = chardev.get("port", default_port)
867                     chardev_context["protocol"] = chardev.get("protocol", "telnet")
868                 context[chardev_type + "s"].append(chardev_context)
869     context["disks"] = []
870     disk_bus_map = {"virtio": "vd", "xen": "xvd", "fdc": "fd", "ide": "hd"}
871     targets = []
872     for i, disk in enumerate(diskp):
873         prefix = disk_bus_map.get(disk["model"], "sd")
874         disk_context = {
875             "device": disk.get("device", "disk"),
876             "target_dev": _get_disk_target(targets, len(diskp), prefix),
877             "disk_bus": disk["model"],
878             "format": disk.get("format", "raw"),
879             "index": str(i),
880             "io": disk.get("io", "native"),
881             "iothread": disk.get("iothread_id", None),
882         }
883         targets.append(disk_context["target_dev"])
884         if disk.get("source_file"):
885             url = urllib.parse.urlparse(disk["source_file"])
886             if not url.scheme or not url.hostname:
887                 disk_context["source_file"] = disk["source_file"]
888                 disk_context["type"] = "file"
889             elif url.scheme in ["http", "https", "ftp", "ftps", "tftp"]:
890                 disk_context["type"] = "network"
891                 disk_context["protocol"] = url.scheme
892                 disk_context["volume"] = url.path
893                 disk_context["query"] = saxutils.escape(url.query)
894                 disk_context["hosts"] = [{"name": url.hostname, "port": url.port}]
895         elif disk.get("pool"):
896             disk_context["volume"] = disk["filename"]
897             pool = conn.storagePoolLookupByName(disk["pool"])
898             pool_xml = ElementTree.fromstring(pool.XMLDesc())
899             pool_type = pool_xml.get("type")
900             if hypervisor == "xen" or pool_type in ["rbd", "gluster", "sheepdog"]:
901                 disk_context.update(
902                     _disk_from_pool(conn, pool, pool_xml, disk_context["volume"])
903                 )
904             else:
905                 if pool_type in ["disk", "logical"]:
906                     disk_context["format"] = "raw"
907                 disk_context["type"] = "volume"
908                 disk_context["pool"] = disk["pool"]
909         else:
910             disk_context["type"] = "file"
911         if hypervisor in ["qemu", "kvm", "bhyve", "xen"]:
912             disk_context["address"] = False
913             disk_context["driver"] = True
914         elif hypervisor in ["esxi", "vmware"]:
915             disk_context["address"] = True
916             disk_context["driver"] = False
917         context["disks"].append(disk_context)
918     context["nics"] = nicp
919     hostdev_context = []
920     try:
921         for hostdev_name in host_devices or []:
922             hostdevice = conn.nodeDeviceLookupByName(hostdev_name)
923             doc = ElementTree.fromstring(hostdevice.XMLDesc())
924             if "pci" in hostdevice.listCaps():
925                 hostdev_context.append(
926                     {
927                         "type": "pci",
928                         "domain": "0x{:04x}".format(
929                             int(doc.find("./capability[@type='pci']/domain").text)
930                         ),
931                         "bus": "0x{:02x}".format(
932                             int(doc.find("./capability[@type='pci']/bus").text)
933                         ),
934                         "slot": "0x{:02x}".format(
935                             int(doc.find("./capability[@type='pci']/slot").text)
936                         ),
937                         "function": "0x{}".format(
938                             doc.find("./capability[@type='pci']/function").text
939                     }
940                 )
941             elif "usb_device" in hostdevice<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.listCaps():
942                 vendor_id = doc.find(".//vendor").get("id")
943                 product_id = doc.find(".//product").get(</b></font>"id")
944                 hostdev_context.append(
945                     {"type": "usb", "vendor": vendor_id, "product": product_id}
946                 )
947     except libvirt.libvirtError as err:
948         conn.close()
949         raise CommandExecutionError(
950             "Failed to get host devices: " + err.get_error_message()
951         )
952     context["hostdevs"] = hostdev_context
953     context["os_type"] = os_type
954     context["arch"] = arch
955     fn_ = "libvirt_domain.jinja"
956     try:
957         template = JINJA.get_template(fn_)
958     except jinja2.exceptions.TemplateNotFound:
959         log.error("Could not load template %s", fn_)
960         return ""
961     return template.render(**context)
962 def _gen_vol_xml(
963     name,
964     size,
965     format=None,
966     allocation=0,
967     type=None,
968     permissions=None,
969     backing_store=None,
970     nocow=False,
971 ):
972     """
973     Generate the XML string to define a libvirt storage volume
974     """
975     size = int(size) * 1024  # MB
976     context = {
977         "type": type,
978         "name": name,
979         "target": {"permissions": permissions, "nocow": nocow},
980         "format": format,
981         "size": str(size),
982         "allocation": str(int(allocation) * 1024),
983         "backingStore": backing_store,
984     }
985     fn_ = "libvirt_volume.jinja"
986     try:
987         template = JINJA.get_template(fn_)
988     except jinja2.exceptions.TemplateNotFound:
989         log.error("Could not load template %s", fn_)
990         return ""
991     return template.render(**context)
992 def _gen_net_xml(
993     name,
994     bridge,
995     forward,
996     vport,
997     tag=None,
998     ip_configs=None,
999     mtu=None,
1000     domain=None,
1001     nat=None,
1002     interfaces=None,
1003     addresses=None,
1004     physical_function=None,
1005     dns=None,
1006 ):
1007     """
1008     Generate the XML string to define a libvirt network
1009     """
1010     if isinstance(vport, str):
1011         vport_context = {"type": vport}
1012     else:
1013         vport_context = vport
1014     if isinstance(tag, (str, int)):
1015         tag_context = {"tags": [{"id": tag}]}
1016     else:
1017         tag_context = tag
1018     addresses_context = []
1019     if addresses:
1020         matches = [
1021             re.fullmatch(r"([0-9]+):([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9])", addr)
1022             for addr in addresses.lower().split(" ")
1023         ]
1024         addresses_context = [
1025             {
1026                 "domain": m.group(1),
1027                 "bus": m.group(2),
1028                 "slot": m.group(3),
1029                 "function": m.group(4),
1030             }
1031             for m in matches
1032             if m
1033         ]
1034     context = {
1035         "name": name,
1036         "bridge": bridge,
1037         "mtu": mtu,
1038         "domain": domain,
1039         "forward": forward,
1040         "nat": nat,
1041         "interfaces": interfaces.split(" ") if interfaces else [],
1042         "addresses": addresses_context,
1043         "pf": physical_function,
1044         "vport": vport_context,
1045         "vlan": tag_context,
1046         "dns": dns,
1047         "ip_configs": [
1048             {
1049                 "address": ipaddress.ip_network(config["cidr"]),
1050                 "dhcp_ranges": config.get("dhcp_ranges", []),
1051                 "hosts": config.get("hosts", {}),
1052                 "bootp": config.get("bootp", {}),
1053                 "tftp": config.get("tftp"),
1054             }
1055             for config in ip_configs or []
1056         ],
1057         "yesno": lambda v: "yes" if v else "no",
1058     }
1059     fn_ = "libvirt_network.jinja"
1060     try:
1061         template = JINJA.get_template(fn_)
1062     except jinja2.exceptions.TemplateNotFound:
1063         log.error("Could not load template %s", fn_)
1064         return ""
1065     return template.render(**context)
1066 def _gen_pool_xml(
1067     name,
1068     ptype,
1069     target=None,
1070     permissions=None,
1071     source_devices=None,
1072     source_dir=None,
1073     source_adapter=None,
1074     source_hosts=None,
1075     source_auth=None,
1076     source_name=None,
1077     source_format=None,
1078     source_initiator=None,
1079 ):
1080     """
1081     Generate the XML string to define a libvirt storage pool
1082     """
1083     hosts = [host.split(":") for host in source_hosts or []]
1084     source = None
1085     if any(
1086         [
1087             source_devices,
1088             source_dir,
1089             source_adapter,
1090             hosts,
1091             source_auth,
1092             source_name,
1093             source_format,
1094             source_initiator,
1095         ]
1096     ):
1097         source = {
1098             "devices": source_devices or [],
1099             "dir": source_dir
1100             if source_format != "cifs" or not source_dir
1101             else source_dir.lstrip("/"),
1102             "adapter": source_adapter,
1103             "hosts": [
1104                 {"name": host[0], "port": host[1] if len(host) &gt; 1 else None}
1105                 for host in hosts
1106             ],
1107             "auth": source_auth,
1108             "name": source_name,
1109             "format": source_format,
1110             "initiator": source_initiator,
1111         }
1112     context = {
1113         "name": name,
1114         "ptype": ptype,
1115         "target": {"path": target, "permissions": permissions},
1116         "source": source,
1117     }
1118     fn_ = "libvirt_pool.jinja"
1119     try:
1120         template = JINJA.get_template(fn_)
1121     except jinja2.exceptions.TemplateNotFound:
1122         log.error("Could not load template %s", fn_)
1123         return ""
1124     return template.render(**context)
1125 def _gen_secret_xml(auth_type, usage, description):
1126     """
1127     Generate a libvirt secret definition XML
1128     """
1129     context = {
1130         "type": auth_type,
1131         "usage": usage,
1132         "description": description,
1133     }
1134     fn_ = "libvirt_secret.jinja"
1135     try:
1136         template = JINJA.get_template(fn_)
1137     except jinja2.exceptions.TemplateNotFound:
1138         log.error("Could not load template %s", fn_)
1139         return ""
1140     return template.render(**context)
1141 def _get_images_dir():
1142     """
1143     Extract the images dir from the configuration. First attempts to
1144     find legacy virt.images, then tries virt:images.
1145     """
1146     img_dir = __salt__["config.get"]("virt:images")
1147     log.debug("Image directory from config option `virt:images` is %s", img_dir)
1148     return img_dir
1149 def _zfs_image_create(
1150     vm_name,
1151     pool,
1152     disk_name,
1153     hostname_property_name,
1154     sparse_volume,
1155     disk_size,
1156     disk_image_name,
1157 ):
1158     """
1159     Clones an existing image, or creates a new one.
1160     When cloning an image, disk_image_name refers to the source
1161     of the clone. If not specified, disk_size is used for creating
1162     a new zvol, and sparse_volume determines whether to create
1163     a thin provisioned volume.
1164     The cloned or new volume can have a ZFS property set containing
1165     the vm_name. Use hostname_property_name for specifying the key
1166     of this ZFS property.
1167     """
1168     if not disk_image_name and not disk_size:
1169         raise CommandExecutionError(
1170             "Unable to create new disk {}, please specify"
1171             " the disk image name or disk size argument".format(disk_name)
1172         )
1173     if not pool:
1174         raise CommandExecutionError(
1175             "Unable to create new disk {}, please specify the disk pool name".format(
1176                 disk_name
1177             )
1178         )
1179     destination_fs = os.path.join(pool, "{}.{}".format(vm_name, disk_name))
1180     log.debug("Image destination will be %s", destination_fs)
1181     existing_disk = __salt__["zfs.list"](name=pool)
1182     if "error" in existing_disk:
1183         raise CommandExecutionError(
1184             "Unable to create new disk {}. {}".format(
1185                 destination_fs, existing_disk["error"]
1186             )
1187         )
1188     elif destination_fs in existing_disk:
1189         log.info("ZFS filesystem %s already exists. Skipping creation", destination_fs)
1190         blockdevice_path = os.path.join("/dev/zvol", pool, vm_name)
1191         return blockdevice_path
1192     properties = {}
1193     if hostname_property_name:
1194         properties[hostname_property_name] = vm_name
1195     if disk_image_name:
1196         __salt__["zfs.clone"](
1197             name_a=disk_image_name, name_b=destination_fs, properties=properties
1198         )
1199     elif disk_size:
1200         __salt__["zfs.create"](
1201             name=destination_fs,
1202             properties=properties,
1203             volume_size=disk_size,
1204             sparse=sparse_volume,
1205         )
1206     blockdevice_path = os.path.join(
1207         "/dev/zvol", pool, "{}.{}".format(vm_name, disk_name)
1208     )
1209     log.debug("Image path will be %s", blockdevice_path)
1210     return blockdevice_path
1211 def _qemu_image_create(disk, create_overlay=False, saltenv="base"):
1212     """
1213     Create the image file using specified disk_size or/and disk_image
1214     """
1215     disk_size = disk.get("size", None)
1216     disk_image = disk<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("image", None)
1217     if not disk_size and not disk_image:
1218         raise CommandExecutionError(
1219             "Unable to create new disk {}, please specify"
1220             " disk size and/or disk image argument".format(disk["filename"])
1221         )
1222     img_dest = disk["source_file"]
1223     img_dir =</b></font> os.path.dirname(img_dest)
1224     log.debug("Image destination directory is %s", img_dir)
1225     if not os.path<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.exists(img_dir):
1226         os.makedirs(img_dir)
1227     if disk_image:
1228         log.debug("Create disk from specified image %s", disk_image)
1229         sfn = __salt__["cp.cache_file"](disk_image, saltenv)
1230         qcow2 =</b></font> False
1231         if salt.utils.path.which("qemu-img"):
1232             res = __salt__["cmd.run"]('qemu-img info "{}"'.format(sfn))
1233             imageinfo = salt.utils.yaml.safe_load(res)
1234             qcow2 = imageinfo["file format"] == "qcow2"
1235         try:
1236             if create_overlay and qcow2:
1237                 log.info("Cloning qcow2 image %s using copy on write", sfn)
1238                 __salt__["cmd.run"](
1239                     'qemu-img create -f qcow2 -o backing_file="{}" "{}"'.format(
1240                         sfn, img_dest
1241                     ).split()
1242                 )
1243             else:
1244                 log.debug("Copying %s to %s", sfn, img_dest)
1245                 salt.utils.files.copyfile(sfn, img_dest)
1246             mask = salt.utils.files.get_umask()
1247             if disk_size and qcow2:
1248                 log.debug("Resize qcow2 image to %sM", disk_size)
1249                 __salt__["cmd.run"](
1250                     'qemu-img resize "{}" {}M'.format(img_dest, disk_size)
1251                 )
1252             log.debug("Apply umask and remove exec bit")
1253             mode = (0o0777 ^ mask) &amp; 0o0666
1254             os.chmod(img_dest, mode)
1255         except OSError as err:
1256             raise CommandExecutionError(
1257                 "Problem while copying image. {} - {}".format(disk_image, err)
1258             )
1259     else:
1260         try:
1261             mask = salt.utils.files.get_umask()
1262             if disk_size:
1263                 log.debug("Create empty image with size %sM", disk_size)
1264                 __salt__["cmd.run"](
1265                     'qemu-img create -f {} "{}" {}M'.format(
1266                         disk.get("format", "qcow2"), img_dest, disk_size
1267                     )
1268                 )
1269             else:
1270                 raise CommandExecutionError(
1271                     "Unable to create new disk {},"
1272                     " please specify &lt;size&gt; argument".format(img_dest)
1273                 )
1274             log.debug("Apply umask and remove exec bit")
1275             mode = (0o0777 ^ mask) &amp; 0o0666
1276             os.chmod(img_dest, mode)
1277         except OSError as err:
1278             raise CommandExecutionError(
1279                 "Problem while creating volume {} - {}".format(img_dest, err)
1280             )
1281     return img_dest
1282 def _seed_image(seed_cmd, img_path, name, config, install, pub_key, priv_key):
1283     """
1284     Helper function to seed an existing image. Note that this doesn't
1285     handle volumes.
1286     """
1287     log.debug("Seeding image")
1288     __salt__[seed_cmd](
1289         img_path,
1290         id_=name,
1291         config=config,
1292         install=install,
1293         pub_key=pub_key,
1294         priv_key=priv_key,
1295     )
1296 def _disk_volume_create(conn, disk, seeder=None, saltenv="base"):
1297     """
1298     Create a disk volume for use in a VM
1299     """
1300     if disk.get("overlay_image"):
1301         raise SaltInvocationError(
1302             "Disk overlay_image property is not supported when creating volumes,"
1303             "use backing_store_path and backing_store_format instead."
1304         )
1305     pool = conn.storagePoolLookupByName(disk["pool"])
1306     if disk["filename"] in pool.listVolumes():
1307         return
1308     pool_type = ElementTree.fromstring(pool.XMLDesc()).get("type")
1309     backing_path = disk.get("backing_store_path")
1310     backing_format = disk.get("backing_store_format")
1311     backing_store = None
1312     if (
1313         backing_path
1314         and backing_format
1315         and (disk.get("format") == "qcow2" or pool_type == "logical")
1316     ):
1317         backing_store = {"path": backing_path, "format": backing_format}
1318     if backing_store and disk.get("image"):
1319         raise SaltInvocationError(
1320             "Using a template image with a backing store is not possible, "
1321             "choose either of them."
1322         )
1323     vol_xml = _gen_vol_xml(
1324         disk["filename"],
1325         disk.get("size", 0),
1326         format=disk.get("format"),
1327         backing_store=backing_store,
1328     )
1329     _define_vol_xml_str(conn, vol_xml, disk.get("pool"))
1330     if disk.get("image"):
1331         log.debug("Caching disk template image: %s", disk.get("image"))
1332         cached_path = __salt__["cp.cache_file"](disk.get("image"), saltenv)
1333         if seeder:
1334             seeder(cached_path)
1335         _volume_upload(
1336             conn,
1337             disk["pool"],
1338             disk["filename"],
1339             cached_path,
1340             sparse=disk.get("format") == "qcow2",
1341         )
1342 def _disk_profile(conn, profile, hypervisor, disks, vm_name):
1343     """
1344     Gather the disk profile from the config or apply the default based
1345     on the active hypervisor
1346     This is the ``default`` profile for KVM/QEMU, which can be
1347     overridden in the configuration:
1348     .. code-block:: yaml
1349         virt:
1350           disk:
1351             default:
1352               - system:
1353                   size: 8192
1354                   format: qcow2
1355                   model: virtio
1356     Example profile for KVM/QEMU with two disks, first is created
1357     from specified image, the second is empty:
1358     .. code-block:: yaml
1359         virt:
1360           disk:
1361             two_disks:
1362               - system:
1363                   size: 8192
1364                   format: qcow2
1365                   model: virtio
1366                   image: http://path/to/image.qcow2
1367               - lvm:
1368                   size: 32768
1369                   format: qcow2
1370                   model: virtio
1371     The ``format`` and ``model`` parameters are optional, and will
1372     default to whatever is best suitable for the active hypervisor.
1373     """
1374     default = [{"system": {"size": 8192}}]
1375     if hypervisor == "vmware":
1376         overlay = {"format": "vmdk", "model": "scsi", "device": "disk"}
1377     elif hypervisor in ["qemu", "kvm"]:
1378         overlay = {"device": "disk", "model": "virtio"}
1379     elif hypervisor == "xen":
1380         overlay = {"device": "disk", "model": "xen"}
1381     elif hypervisor == "bhyve":
1382         overlay = {"format": "raw", "model": "virtio", "sparse_volume": False}
1383     else:
1384         overlay = {}
1385     disklist = []
1386     if profile:
1387         disklist = copy.deepcopy(
1388             __salt__["config.get"]("virt:disk", {}).get(profile, default)
1389         )
1390         disklist = [dict(d, name=name) for disk in disklist for name, d in disk.items()]
1391     if disks:
1392         for udisk in disks:
1393             if "name" in udisk:
1394                 found = [disk for disk in disklist if udisk["name"] == disk["name"]]
1395                 if found:
1396                     found[0].update(udisk)
1397                 else:
1398                     disklist.append(udisk)
1399     pool_caps = _pool_capabilities(conn)
1400     for disk in disklist:
1401         if disk.get("device", "disk") == "cdrom" and "model" not in disk:
1402             disk["model"] = "ide"
1403         for key, val in overlay.items():
1404             if key not in disk:
1405                 disk[key] = val
1406         if disk.get("source_file") and os.path.exists(disk["source_file"]):
1407             disk["filename"] = os.path.basename(disk["source_file"])
1408             if not disk.get("format"):
1409                 disk["format"] = (
1410                     "qcow2" if disk.get("device", "disk") != "cdrom" else "raw"
1411                 )
1412         elif vm_name and disk.get("device", "disk") == "disk":
1413             _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps)
1414     return disklist
1415 def _fill_disk_filename(conn, vm_name, disk, hypervisor, pool_caps):
1416     """
1417     Compute the disk file name and update it in the disk value.
1418     """
1419     disk["filename"] = "{}_{}".format(vm_name, disk["name"])
1420     base_dir = disk.get("pool", None)
1421     if hypervisor in ["qemu", "kvm", "xen"]:
1422         if not base_dir:
1423             base_dir = _get_images_dir()
1424         if base_dir not in conn.listStoragePools():
1425             if not disk.get("format"):
1426                 disk["format"] = "qcow2"
1427             disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1428             disk["source_file"] = os.path.join(base_dir, disk["filename"])
1429         else:
1430             if "pool" not in disk:
1431                 disk["pool"] = base_dir
1432             pool_obj = conn.storagePoolLookupByName(base_dir)
1433             pool_xml = ElementTree.fromstring(pool_obj.XMLDesc())
1434             pool_type = pool_xml.get("type")
1435             if pool_type == "disk":
1436                 device = pool_xml.find("./source/device").get("path")
1437                 all_volumes = pool_obj.listVolumes()
1438                 if disk.get("source_file") not in all_volumes:
1439                     indexes = [
1440                         int(re.sub("[a-z]+", "", vol_name)) for vol_name in all_volumes
1441                     ] or [0]
1442                     index = min(
1443                         idx for idx in range(1, max(indexes) + 2) if idx not in indexes
1444                     )
1445                     disk["filename"] = "{}{}".format(os.path.basename(device), index)
1446             if disk.get("source_file"):
1447                 if not disk.get("source_file") in pool_obj.listVolumes():
1448                     raise SaltInvocationError(
1449                         "{} volume doesn't exist in pool {}".format(
1450                             disk.get("source_file"), base_dir
1451                         )
1452                     )
1453                 disk["filename"] = disk["source_file"]
1454                 del disk["source_file"]
1455             if not disk.get("format"):
1456                 volume_options = (
1457                     [
1458                         type_caps.get("options", {}).get("volume", {})
1459                         for type_caps in pool_caps.get("pool_types")
1460                         if type_caps["name"] == pool_type
1461                     ]
1462                     or [{}]
1463                 )[0]
1464                 if "qcow2" in volume_options.get("targetFormatType", []):
1465                     disk["format"] = "qcow2"
1466                 else:
1467                     disk["format"] = volume_options.get("default_format", None)
1468     elif hypervisor == "bhyve" and vm_name:
1469         disk["filename"] = "{}.{}".format(vm_name, disk["name"])
1470         disk["source_file"] = os.path.join(
1471             "/dev/zvol", base_dir or "", disk["filename"]
1472         )
1473     elif hypervisor in ["esxi", "vmware"]:
1474         if not base_dir:
1475             base_dir = __salt__["config.get"]("virt:storagepool", "[0] ")
1476         disk["filename"] = "{}.{}".format(disk["filename"], disk["format"])
1477         disk["source_file"] = "{}{}".format(base_dir, disk["filename"])
1478 def _complete_nics(interfaces, hypervisor):
1479     """
1480     Complete missing data for network interfaces.
1481     """
1482     vmware_overlay = {"type": "bridge", "source": "DEFAULT", "model": "e1000"}
1483     kvm_overlay = {"type": "bridge", "source": "br0", "model": "virtio"}
1484     xen_overlay = {"type": "bridge", "source": "br0", "model": None}
1485     bhyve_overlay = {"type": "bridge", "source": "bridge0", "model": "virtio"}
1486     overlays = {
1487         "xen": xen_overlay,
1488         "kvm": kvm_overlay,
1489         "qemu": kvm_overlay,
1490         "vmware": vmware_overlay,
1491         "bhyve": bhyve_overlay,
1492     }
1493     def _normalize_net_types(attributes):
1494         """
1495         Guess which style of definition:
1496             bridge: br0
1497              or
1498             network: net0
1499              or
1500             type: network
1501             source: net0
1502         """
1503         for type_ in ["bridge", "network"]:
1504             if type_ in attributes:
1505                 attributes["type"] = type_
1506                 attributes["source"] = attributes.pop(type_)
1507         attributes["type"] = attributes.get("type", None)
1508         attributes["source"] = attributes.get("source", None)
1509     def _apply_default_overlay(attributes):
1510         """
1511         Apply the default overlay to attributes
1512         """
1513         for key, value in overlays[hypervisor].items():
1514             if key not in attributes or not attributes[key]:
1515                 attributes[key] = value
1516     for interface in interfaces:
1517         _normalize_net_types(interface)
1518         if hypervisor in overlays:
1519             _apply_default_overlay(interface)
1520     return interfaces
1521 def _nic_profile(profile_name, hypervisor):
1522     """
1523     Compute NIC data based on profile
1524     """
1525     config_data = __salt__["config.get"]("virt:nic", {}).get(
1526         profile_name, [{"eth0": {}}]
1527     )
1528     interfaces = []
1529     def append_dict_profile_to_interface_list(profile_dict):
1530         """
1531         Append dictionary profile data to interfaces list
1532         """
1533         for interface_name, attributes in profile_dict.items():
1534             attributes["name"] = interface_name
1535             interfaces.append(attributes)
1536     if isinstance(config_data, dict):
1537         append_dict_profile_to_interface_list(config_data)
1538     elif isinstance(config_data, list):
1539         for interface in config_data:
1540             if isinstance(interface, dict):
1541                 if len(interface) == 1:
1542                     append_dict_profile_to_interface_list(interface)
1543                 else:
1544                     interfaces.append(interface)
1545     return _complete_nics(interfaces, hypervisor)
1546 def _get_merged_nics(hypervisor, profile, interfaces=None):
1547     """
1548     Get network devices from the profile and merge uer defined ones with them.
1549     """
1550     nicp = _nic_profile(profile, hypervisor) if profile else []
1551     log.debug("NIC profile is %s", nicp)
1552     if interfaces:
1553         users_nics = _complete_nics(interfaces, hypervisor)
1554         for unic in users_nics:
1555             found = [nic for nic in nicp if nic["name"] == unic["name"]]
1556             if found:
1557                 found[0].update(unic)
1558             else:
1559                 nicp.append(unic)
1560         log.debug("Merged NICs: %s", nicp)
1561     return nicp
1562 def _handle_remote_boot_params(orig_boot):
1563     """
1564     Checks if the boot parameters contain a remote path. If so, it will copy
1565     the parameters, download the files specified in the remote path, and return
1566     a new dictionary with updated paths containing the canonical path to the
1567     kernel and/or initrd
1568     :param orig_boot: The original boot parameters passed to the init or update
1569     functions.
1570     """
1571     saltinst_dir = None
1572     new_boot = orig_boot.copy()
1573     keys = orig_boot.keys()
1574     cases = [
1575         {"efi"},
1576         {"kernel", "initrd", "efi"},
1577         {"kernel", "initrd", "cmdline", "efi"},
1578         {"loader", "nvram"},
1579         {"kernel", "initrd"},
1580         {"kernel", "initrd", "cmdline"},
1581         {"kernel", "initrd", "loader", "nvram"},
1582         {"kernel", "initrd", "cmdline", "loader", "nvram"},
1583     ]
1584         for key in keys:
1585             if key == "efi" and type(orig_boot.get(key)) == bool:
1586                 new_boot[key] = orig_boot<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get(key)
1587             elif orig_boot.get(key) is not None and salt.utils.virt.check_remote(
1588                 orig_boot.get(key)
1589             ):
1590                 if saltinst_dir is None:
1591                     os.</b></font>makedirs(CACHE_DIR)
1592                     saltinst_dir = CACHE_DIR
1593                 new_boot[key] = salt.utils.virt.download_remote(
1594                     orig_boot.get(key), saltinst_dir
1595                 )
1596         return new_boot
1597     else:
1598         raise SaltInvocationError(
1599             "Invalid boot parameters,It has to follow this combination: [(kernel,"
1600             " initrd) or/and cmdline] or/and [(loader, nvram) or efi]"
1601         )
1602 def _handle_efi_param(boot, desc):
1603     """
1604     Checks if boot parameter contains efi boolean value, if so, handles the firmware attribute.
1605     :param boot: The boot parameters passed to the init or update functions.
1606     :param desc: The XML description of that domain.
1607     :return: A boolean value.
1608     """
1609     efi_value = boot.get("efi", None) if boot else None
1610     parent_tag = desc.find("os")
1611     os_attrib = parent_tag.attrib
1612     if efi_value is False and os_attrib != {}:
1613         parent_tag.attrib.pop("firmware", None)
1614         return True
1615     elif type(efi_value) == bool and os_attrib == {}:
1616         if efi_value is True and parent_tag.find("loader") is None:
1617             parent_tag.set("firmware", "efi")
1618             return True
1619         if efi_value is False and parent_tag.find("loader") is not None:
1620             parent_tag.remove(parent_tag.find("loader"))
1621             parent_tag.remove(parent_tag.find("nvram"))
1622             return True
1623     elif type(efi_value) != bool:
1624         raise SaltInvocationError("Invalid efi value")
1625     return False
1626 def init(
1627     name,
1628     cpu,
1629     nic="default",
1630     interfaces=None,
1631     hypervisor<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
1632     start=True,  # pylint: disable=redefined-outer-name
1633     disk="default",
1634     disks=None,
1635     saltenv="base",
1636     seed=True,
1637     install=True,
1638     pub_key=None,
1639     priv_key=None,
1640     seed_cmd="seed.apply",
1641     graphics=None,
1642     os_type=None,
1643     arch=None,
1644     boot=None,
1645     boot_dev=None,
1646     numatune=None,
1647     hypervisor_features=None,
1648     clock=None,
1649     serials=None,
1650     consoles=None,
1651     stop_on_reboot=False,
1652     host_devices=None,
1653     **kwargs
1654 ):
1655     """
1656     Initialize a new vm
1657     :param name: name of the virtual machine to create
1658     :param cpu:
1659         Number of virtual CPUs to assign to the virtual machine or a dictionary with detailed information to configure
1660         cpu model and topology, numa node tuning, cpu tuning and iothreads allocation. The structure of the dictionary is
1661         documented in :ref:`init-cpu-def`.
1662         .. code-block:: yaml
1663              cpu:
1664                placement: static
1665                cpuset: 0-11
1666                current: 5
1667                maximum: 12
1668                vcpus:
1669                  0:
1670                    enabled: True
1671                    hotpluggable: False
1672                    order: 1
1673                  1:
1674                    enabled: False
1675                    hotpluggable: True
1676                match: minimum
1677                mode: custom
1678                check: full
1679                vendor: Intel
1680                model:
1681                  name: core2duo
1682                  fallback: allow
1683                  vendor_id: GenuineIntel
1684                topology:
1685                  sockets: 1
1686                  cores: 12
1687                  threads: 1
1688                cache:
1689                  level: 3
1690                  mode: emulate
1691                features:
1692                  lahf: optional
1693                  pcid: require
1694                numa:
1695                  0:
1696                     cpus: 0-3
1697                     memory: 1g
1698                     discard: True
1699                     distances:
1700                       0: 10     # sibling id : value
1701                       1: 21
1702                       2: 31
1703                       3: 41
1704                  1:
1705                     cpus: 4-6
1706                     memory: 1g
1707                     memAccess: shared
1708                     distances:
1709                       0: 21
1710                       1: 10
1711                       2: 21
1712                       3: 31
1713                tuning:
1714                     vcpupin:
1715                       0: 1-4,^2  # vcpuid : cpuset
1716                       1: 0,1
1717                       2: 2,3
1718                       3: 0,4
1719                     emulatorpin: 1-3
1720                     iothreadpin:
1721                       1: 5,6    # iothread id: cpuset
1722                       2: 7,8
1723                     shares: 2048
1724                     period: 1000000
1725                     quota: -1
1726                     global_period: 1000000
1727                     global_quota: -1
1728                     emulator_period: 1000000
1729                     emulator_quota: -1
1730                     iothread_period: 1000000
1731                     iothread_quota: -1
1732                     vcpusched:
1733                       - scheduler: fifo
1734                         priority: 1
1735                         vcpus: 0,3-5
1736                       - scheduler: rr
1737                         priority: 3
1738                     iothreadsched:
1739                       - scheduler: idle
1740                       - scheduler: batch
1741                         iothreads: 2,3
1742                     emulatorsched:
1743                       - scheduler: batch
1744                     cachetune:
1745                       0-3:      # vcpus set
1746                         0:      # cache id
1747                           level: 3
1748                           type: both
1749                           size: 4
1750                         1:
1751                           level: 3
1752                           type: both
1753                           size: 6
1754                         monitor:
1755                           1: 3
1756                           0-3: 3
1757                       4-5:
1758                         monitor:
1759                           4: 3  # vcpus: level
1760                           5: 3
1761                     memorytune:
1762                       0-3:      # vcpus set
1763                         0: 60   # node id: bandwidth
1764                       4-5:
1765                         0: 60
1766                iothreads: 4
1767         .. versionadded:: 3003
1768     :param mem: Amount of memory to allocate to the virtual machine in MiB. Since 3002, a dictionary can be used to
1769         contain detailed configuration which support memory allocation or tuning. Supported parameters are ``boot``,
1770         ``current``, ``max``, ``slots``, ``hard_limit``, ``soft_limit``, ``swap_hard_limit``, ``min_guarantee``,
1771         ``hugepages`` ,  ``nosharepages``, ``locked``, ``source``, ``access``, ``allocation`` and ``discard``. The structure
1772         of the dictionary is documented in  :ref:`init-mem-def`. Both decimal and binary base are supported. Detail unit
1773         specification is documented  in :ref:`virt-units`. Please note that the value for ``slots`` must be an integer.
1774         .. code-block:: python
1775             {
1776                 'boot': 1g,
1777                 'current': 1g,
1778                 'max': 1g,
1779                 'slots': 10,
1780                 'hard_limit': '1024',
1781                 'soft_limit': '512m',
1782                 'swap_hard_limit': '1g',
1783                 'min_guarantee': '512mib',
1784                 'hugepages': [{'nodeset': '0-3,^2', 'size': '1g'}, {'nodeset': '2', 'size': '2m'}],
1785                 'nosharepages': True,
1786                 'locked': True,
1787                 'source': 'file',
1788                 'access': 'shared',
1789                 'allocation': 'immediate',
1790                 'discard': True
1791             }
1792         .. versionchanged:: 3002
1793     :param nic: NIC profile to use (Default: ``'default'``).
1794                 The profile interfaces can be customized / extended with the interfaces parameter.
1795                 If set to ``None``, no profile will be used.
1796     :param interfaces:
1797         List of dictionaries providing details on the network interfaces to create.
1798         These data are merged with the ones from the nic profile. The structure of
1799         each dictionary is documented in :ref:`init-nic-def`.
1800         .. versionadded:: 2019.2.0
1801     :param hypervisor: the virtual machine type. By default the value will be computed according
1802                        to the virtual host capabilities.
1803     :param start: ``True`` to start the virtual machine after having defined it (Default: ``True``)
1804     :param disk: Disk profile to use (Default: ``'default'``). If set to ``None``, no profile will be used.
1805     :param disks: List of dictionaries providing details on the disk devices to create.
1806                   These data are merged with the ones from the disk profile. The structure of
1807                   each dictionary is documented in :ref:`init-disk-def`.
1808                   .. versionadded:: 2019.2.0
1809     :param saltenv: Fileserver environment (Default: ``'base'``).
1810                     See :mod:`cp module for more details &lt;salt.modules.cp&gt;`
1811     :param seed: ``True`` to seed the disk image. Only used when the ``image`` parameter is provided.
1812                  (Default: ``True``)
1813     :param install: install salt minion if absent (Default: ``True``)
1814     :param pub_key: public key to seed with (Default: ``None``)
1815     :param priv_key: public key to seed with (Default: ``None``)
1816     :param seed_cmd: Salt command to execute to seed the image. (Default: ``'seed.apply'``)
1817     :param graphics:
1818         Dictionary providing details on the graphics device to create. (Default: ``None``)
1819         See :ref:`init-graphics-def` for more details on the possible values.
1820         .. versionadded:: 2019.2.0
1821     :param os_type:
1822         type of virtualization as found in the ``//os/type`` element of the libvirt definition.
1823         The default value is taken from the host capabilities, with a preference for ``hvm``.
1824         .. versionadded:: 2019.2.0
1825     :param arch:
1826         architecture of the virtual machine. The default value is taken from the host capabilities,
1827         but ``x86_64`` is prefed over ``i686``.
1828         .. versionadded:: 2019.2.0
1829     :param config: minion configuration to use when seeding.
1830                    See :mod:`seed module for more details &lt;salt.modules.seed&gt;`
1831     :param boot_dev: String of space-separated devices to boot from (Default: ``'hd'``)
1832     :param connection: libvirt connection URI, overriding defaults
1833                        .. versionadded:: 2019.2.0
1834     :param username: username to connect with, overriding defaults
1835                      .. versionadded:: 2019.2.0
1836     :param password: password to connect with, overriding defaults
1837                      .. versionadded:: 2019.2.0
1838     :param stop_on_reboot:
1839         If set to ``True`` the guest will stop instead of rebooting.
1840         This is specially useful when creating a virtual machine with an installation cdrom or
1841         an autoinstallation needing a special first boot configuration.
1842         Defaults to ``False``
1843         .. versionadded:: 3003
1844     :param boot:
1845         Specifies kernel, initial ramdisk and kernel command line parameters for the virtual machine.
1846         This is an optional parameter, all of the keys are optional within the dictionary. The structure of
1847         the dictionary is documented in :ref:`init-boot-def`. If a remote path is provided to kernel or initrd,
1848         salt will handle the downloading of the specified remote file and modify the XML accordingly.
1849         To boot VM with UEFI, specify loader and nvram path or specify 'efi': ``True`` if your libvirtd version
1850         is &gt;= 5.2.0 and QEMU &gt;= 3.0.0.
1851         .. versionadded:: 3000
1852         .. code-block:: python
1853             {
1854                 'kernel': '/root/f8-i386-vmlinuz',
1855                 'initrd': '/root/f8-i386-initrd',
1856                 'cmdline': 'console=ttyS0 ks=http://example.com/f8-i386/os/',
1857                 'loader': '/usr/share/OVMF/OVMF_CODE.fd',
1858                 'nvram': '/usr/share/OVMF/OVMF_VARS.ms.fd'
1859             }
1860     :param boot_dev:
1861         Space separated list of devices to boot from sorted by decreasing priority.
1862         Values can be ``hd``, ``fd``, ``cdrom`` or ``network``.
1863         By default, the value will ``"hd"``.
1864     :param numatune:
1865         The optional numatune element provides details of how to tune the performance of a NUMA host via controlling NUMA
1866         policy for domain process. The optional ``memory`` element specifies how to allocate memory for the domain process
1867         on a NUMA host. ``memnode`` elements can specify memory allocation policies per each guest NUMA node. The definition
1868         used in the dictionary can be found at :ref:`init-cpu-def`.
1869         .. versionadded:: 3003
1870         .. code-block:: python
1871             {
1872                 'memory': {'mode': 'strict', 'nodeset': '0-11'},
1873                 'memnodes': {0: {'mode': 'strict', 'nodeset': 1}, 1: {'mode': 'preferred', 'nodeset': 2}}
1874             }
1875     :param hypervisor_features:
1876         Enable or disable hypervisor-specific features on the virtual machine.
1877         .. versionadded:: 3003
1878         .. code-block:: yaml
1879             hypervisor_features:
1880               kvm-hint-dedicated: True
1881     :param clock:
1882         Configure the guest clock.
1883         The value is a dictionary with the following keys:
1884         adjustment
1885             time adjustment in seconds or ``reset``
1886         utc
1887             set to ``False`` to use the host local time as the guest clock. Defaults to ``True``.
1888         timezone
1889             synchronize the guest to the correspding timezone
1890         timers
1891             a dictionary associating the timer name with its configuration.
1892             This configuration is a dictionary with the properties ``track``, ``tickpolicy``,
1893             ``catchup``, ``frequency``, ``mode``, ``present``, ``slew``, ``threshold`` and ``limit``.
1894             See `libvirt time keeping documentation &lt;https://libvirt.org/formatdomain.html#time-keeping&gt;`_ for the possible values.
1895         .. versionadded:: 3003
1896         Set the clock to local time using an offset in seconds
1897         .. code-block:: yaml
1898             clock:
1899               adjustment: 3600
1900               utc: False
1901         Set the clock to a specific time zone:
1902         .. code-block:: yaml
1903             clock:
1904               timezone: CEST
1905         Tweak guest timers:
1906         .. code-block:: yaml
1907             clock:
1908               timers:
1909                 tsc:
1910                   frequency: 3504000000
1911                   mode: native
1912                 rtc:
1913                   track: wall
1914                   tickpolicy: catchup
1915                   slew: 4636
1916                   threshold: 123
1917                   limit: 2342
1918                 hpet:
1919                   present: False
1920     :param serials:
1921         Dictionary providing details on the serials connection to create. (Default: ``None``)
1922         See :ref:`init-chardevs-def` for more details on the possible values.
1923         .. versionadded:: 3003
1924     :param consoles:
1925         Dictionary providing details on the consoles device to create. (Default: ``None``)
1926         See :ref:`init-chardevs-def` for more details on the possible values.
1927         .. versionadded:: 3003
1928     :param host_devices:
1929         List of host devices to passthrough to the guest.
1930         The value is a list of device names as provided by the :py:func:`~salt.modules.virt.node_devices` function.
1931         (Default: ``None``)
1932         .. versionadded:: 3003
1933     .. _init-cpu-def:
1934     .. rubric:: cpu parameters definition
1935     The cpu parameters dictionary can contain the following properties:
1936     cpuset
1937         a comma-separated list of physical CPU numbers that domain process and virtual CPUs can be pinned to by default.
1938         eg. ``1-4,^3`` cpuset 3 is excluded.
1939     current
1940         the number of virtual cpus available at startup
1941     placement
1942         indicate the CPU placement mode for domain process. the value can be either ``static`` or ``auto``
1943     vcpus
1944         specify the state of individual vcpu. Possible attribute for each individual vcpu include: ``id``, ``enabled``,
1945         ``hotpluggable`` and ``order``. Valid ``ids`` are from 0 to the maximum vCPU count minus 1. ``enabled`` takes
1946         boolean values which controls the state of the vcpu. ``hotpluggable`` take boolean value which controls whether
1947         given vCPU can be hotplugged and hotunplugged. ``order`` takes an integer value which specifies the order to add
1948         the online vCPUs.
1949     match
1950         The cpu attribute ``match`` attribute specifies how strictly the virtual CPU provided to the guest matches the CPU
1951         requirements, possible values are ``minimum``, ``exact`` or ``strict``.
1952     check
1953         Optional cpu attribute ``check`` attribute can be used to request a specific way of checking whether the virtual
1954         CPU matches the specification, possible values are ``none``, ``partial`` and ``full``.
1955     mode
1956         Optional cpu attribute ``mode`` attribute may be used to make it easier to configure a guest CPU to be as close
1957         to host CPU as possible, possible values are ``custom``, ``host-model`` and ``host-passthrough``.
1958     model
1959         specifies CPU model requested by the guest. An optional ``fallback`` attribute can be used to forbid libvirt falls
1960         back to the closest model supported by the hypervisor, possible values are ``allow`` or ``forbid``. ``vendor_id``
1961         attribute can be used to set the vendor id seen by the guest, the length must be exactly 12 characters long.
1962     vendor
1963         specifies CPU vendor requested by the guest.
1964     topology
1965         specifies requested topology of virtual CPU provided to the guest. Four possible attributes , ``sockets``, ``dies``,
1966         ``cores``, and ``threads``, accept non-zero positive integer values. They refer to the number of CPU sockets per
1967         NUMA node, number of dies per socket, number of cores per die, and number of threads per core, respectively.
1968     features
1969         A dictionary contains a set of cpu features to fine-tune features provided by the selected CPU model. Use cpu
1970         feature ``name`` as the key and the ``policy`` as the value. ``policy`` Attribute takes ``force``, ``require``,
1971         ``optional``, ``disable`` or ``forbid``.
1972     cache
1973         describes the virtual CPU cache. Optional attribute ``level`` takes an integer value which describes cache level
1974         ``mode`` attribute supported three possible values: ``emulate``, ``passthrough``, ``disable``
1975     numa
1976         specify the guest numa topology. ``cell`` element specifies a NUMA cell or a NUMA node, ``cpus`` specifies the
1977         CPU or range of CPUs that are part of the node, ``memory`` specifies the size of the node memory. All cells
1978         should have ``id`` attribute in case referring to some cell is necessary in the code. optional attribute
1979         ``memAccess`` control whether the memory is to be mapped as ``shared`` or ``private``, ``discard`` attribute which
1980         fine tunes the discard feature for given numa node, possible values are ``True`` or ``False``.  ``distances``
1981         element define the distance between NUMA cells and ``sibling`` sub-element is used to specify the distance value
1982         between sibling NUMA cells.
1983     vcpupin
1984         The optional vcpupin element specifies which of host's physical CPUs the domain vCPU will be pinned to.
1985     emulatorpin
1986         The optional emulatorpin element specifies which of host physical CPUs the "emulator", a subset of a domain not
1987         including vCPU or iothreads will be pinned to.
1988     iothreadpin
1989         The optional iothreadpin element specifies which of host physical CPUs the IOThreads will be pinned to.
1990     shares
1991         The optional shares element specifies the proportional weighted share for the domain.
1992     period
1993         The optional period element specifies the enforcement interval (unit: microseconds).
1994     quota
1995         The optional quota element specifies the maximum allowed bandwidth (unit: microseconds).
1996     global_period
1997         The optional global_period element specifies the enforcement CFS scheduler interval (unit: microseconds) for the
1998         whole domain in contrast with period which enforces the interval per vCPU.
1999     global_quota
2000         The optional global_quota element specifies the maximum allowed bandwidth (unit: microseconds) within a period
2001         for the whole domain.
2002     emulator_period
2003         The optional emulator_period element specifies the enforcement interval (unit: microseconds).
2004     emulator_quota
2005         The optional emulator_quota element specifies the maximum allowed bandwidth (unit: microseconds) for domain's
2006         emulator threads (those excluding vCPUs).
2007     iothread_period
2008         The optional iothread_period element specifies the enforcement interval (unit: microseconds) for IOThreads.
2009     iothread_quota
2010         The optional iothread_quota element specifies the maximum allowed bandwidth (unit: microseconds) for IOThreads.
2011     vcpusched
2012         specify the scheduler type for vCPUs.
2013         The value is a list of dictionaries with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2014         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer and the
2015         ``vcpus`` value is a cpu set like ``1-4,^3,6`` or simply the vcpu id.
2016     iothreadsched
2017         specify the scheduler type for IO threads.
2018         The value is a list of dictionaries with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2019         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer and the
2020         ``vcpus`` value is a cpu set like ``1-4,^3,6`` or simply the vcpu id.
2021     emulatorsched
2022         specify the scheduler type (values batch, idle, fifo, rr) for particular the emulator.
2023         The value is a dictionary with the ``scheduler`` key (values ``batch``, ``idle``, ``fifo``, ``rr``)
2024         and the optional ``priority`` and ``vcpus`` keys. The ``priority`` value usually is a positive integer.
2025     cachetune
2026         Optional cachetune element can control allocations for CPU caches using the resctrl on the host.
2027     monitor
2028         The optional element monitor creates the cache monitor(s) for current cache allocation.
2029     memorytune
2030         Optional memorytune element can control allocations for memory bandwidth using the resctrl on the host.
2031     iothreads
2032         Number of threads for supported disk devices to perform I/O requests. iothread id will be numbered from 1 to
2033         the provided number (Default: None).
2034     .. _init-boot-def:
2035     .. rubric:: Boot parameters definition
2036     The boot parameters dictionary can contains the following properties:
2037     kernel
2038         The URL or path to the kernel to run the virtual machine with.
2039     initrd
2040         The URL or path to the initrd file to run the virtual machine with.
2041     cmdline
2042         The parameters to pass to the kernel provided in the `kernel` property.
2043     loader
2044         The path to the UEFI binary loader to use.
2045         .. versionadded:: 3001
2046     nvram
2047         The path to the UEFI data template. The file will be copied when creating the virtual machine.
2048         .. versionadded:: 3001
2049     efi
2050        A boolean value.
2051        .. versionadded:: 3001
2052     .. _init-mem-def:
2053     .. rubric:: Memory parameter definition
2054     Memory parameter can contain the following properties:
2055     boot
2056         The maximum allocation of memory for the guest at boot time
2057     current
2058         The actual allocation of memory for the guest
2059     max
2060         The run time maximum memory allocation of the guest
2061     slots
2062          specifies the number of slots available for adding memory to the guest
2063     hard_limit
2064         the maximum memory the guest can use
2065     soft_limit
2066         memory limit to enforce during memory contention
2067     swap_hard_limit
2068         the maximum memory plus swap the guest can use
2069     min_guarantee
2070         the guaranteed minimum memory allocation for the guest
2071     hugepages
2072         memory allocated using ``hugepages`` instead of the normal native page size. It takes a list of
2073         dictionaries with ``nodeset`` and ``size`` keys.
2074         For example ``"hugepages": [{"nodeset": "1-4,^3", "size": "2m"}, {"nodeset": "3", "size": "1g"}]``.
2075     nosharepages
2076         boolean value to instruct hypervisor to disable shared pages (memory merge, KSM) for this domain
2077     locked
2078         boolean value that allows memory pages belonging to the domain will be locked in host's memory and the host will
2079         not be allowed to swap them out, which might be required for some workloads such as real-time.
2080     source
2081         possible values are ``file`` which utilizes file memorybacking, ``anonymous`` by default and ``memfd`` backing.
2082         (QEMU/KVM only)
2083     access
2084         specify if the memory is to be ``shared`` or ``private``. This can be overridden per numa node by memAccess.
2085     allocation
2086         specify when to allocate the memory by supplying either ``immediate`` or ``ondemand``.
2087     discard
2088         boolean value to ensure the memory content is discarded just before guest shuts down (or when DIMM module is
2089         unplugged). Please note that this is just an optimization and is not guaranteed to work in all cases
2090         (e.g. when hypervisor crashes). (QEMU/KVM only)
2091     .. _init-nic-def:
2092     .. rubric:: Network Interfaces Definitions
2093     Network interfaces dictionaries can contain the following properties:
2094     name
2095         Name of the network interface. This is only used as a key to merge with the profile data
2096     type
2097         Network type. One of ``'bridge'``, ``'network'``
2098     source
2099         The network source, typically the bridge or network name
2100     mac
2101         The desired mac address, computed if ``None`` (Default: ``None``).
2102     model
2103         The network card model (Default: depends on the hypervisor)
2104     .. _init-disk-def:
2105     .. rubric:: Disks Definitions
2106     Disk dictionaries can contain the following properties:
2107     name
2108         Name of the disk. This is mostly used in the name of the disk image and as a key to merge
2109         with the profile data.
2110     format
2111         Format of the disk image, like ``'qcow2'``, ``'raw'``, ``'vmdk'``.
2112         (Default: depends on the hypervisor)
2113     size
2114         Disk size in MiB
2115     pool
2116         Path to the folder or name of the pool where disks should be created.
2117         (Default: depends on hypervisor and the virt:storagepool configuration)
2118         .. versionchanged:: 3001
2119         If the value contains no '/', it is considered a pool name where to create a volume.
2120         Using volumes will be mandatory for some pools types like rdb, iscsi, etc.
2121     model
2122         One of the disk busses allowed by libvirt (Default: depends on hypervisor)
2123         See the libvirt `disk element`_ documentation for the allowed bus types.
2124     image
2125         Path to the image to use for the disk. If no image is provided, an empty disk will be created
2126         (Default: ``None``)
2127         Note that some pool types do not support uploading an image. This list can evolve with libvirt
2128         versions.
2129     overlay_image
2130         ``True`` to create a QCOW2 disk image with ``image`` as backing file. If ``False``
2131         the file pointed to by the ``image`` property will simply be copied. (Default: ``False``)
2132         .. versionchanged:: 3001
2133         This property is only valid on path-based disks, not on volumes. To create a volume with a
2134         backing store, set the ``backing_store_path`` and ``backing_store_format`` properties.
2135     backing_store_path
2136         Path to the backing store image to use. This can also be the name of a volume to use as
2137         backing store within the same pool.
2138         .. versionadded:: 3001
2139     backing_store_format
2140         Image format of the disk or volume to use as backing store. This property is mandatory when
2141         using ``backing_store_path`` to avoid `problems &lt;https://libvirt.org/kbase/backing_chains.html#troubleshooting&gt;`_
2142         .. versionadded:: 3001
2143     source_file
2144         Absolute path to the disk image to use. Not to be confused with ``image`` parameter. This
2145         parameter is useful to use disk images that are created outside of this module. Can also
2146         be ``None`` for devices that have no associated image like cdroms.
2147         .. versionchanged:: 3001
2148         For volume disks, this can be the name of a volume already existing in the storage pool.
2149     device
2150         Type of device of the disk. Can be one of 'disk', 'cdrom', 'floppy' or 'lun'.
2151         (Default: ``'disk'``)
2152     hostname_property
2153         When using ZFS volumes, setting this value to a ZFS property ID will make Salt store the name of the
2154         virtual machine inside this property. (Default: ``None``)
2155     sparse_volume
2156         Boolean to specify whether to use a thin provisioned ZFS volume.
2157         Example profile for a bhyve VM with two ZFS disks. The first is
2158         cloned from the specified image. The second disk is a thin
2159         provisioned volume.
2160         .. code-block:: yaml
2161             virt:
2162               disk:
2163                 two_zvols:
2164                   - system:
2165                       image: zroot/bhyve/CentOS-7-x86_64-v1@v1.0.5
2166                       hostname_property: virt:hostname
2167                       pool: zroot/bhyve/guests
2168                   - data:
2169                       pool: tank/disks
2170                       size: 20G
2171                       hostname_property: virt:hostname
2172                       sparse_volume: True
2173     io
2174         I/O control policy. String value amongst ``native``, ``threads`` and ``io_uring``.
2175         (Default: ``native``)
2176         .. versionadded:: 3003
2177     iothread_id
2178         I/O thread id to assign the disk to.
2179         (Default: none assigned)
2180         .. versionadded:: 3003
2181     .. _init-graphics-def:
2182     .. rubric:: Graphics Definition
2183     The graphics dictionary can have the following properties:
2184     type
2185         Graphics type. The possible values are ``none``, ``'spice'``, ``'vnc'`` and other values
2186         allowed as a libvirt graphics type (Default: ``None``)
2187         See the libvirt `graphics element`_ documentation for more details on the possible types.
2188     port
2189         Port to export the graphics on for ``vnc``, ``spice`` and ``rdp`` types.
2190     tls_port
2191         Port to export the graphics over a secured connection for ``spice`` type.
2192     listen
2193         Dictionary defining on what address to listen on for ``vnc``, ``spice`` and ``rdp``.
2194         It has a ``type`` property with ``address`` and ``None`` as possible values, and an
2195         ``address`` property holding the IP or hostname to listen on.
2196         By default, not setting the ``listen`` part of the dictionary will default to
2197         listen on all addresses.
2198     .. _init-chardevs-def:
2199     .. rubric:: Serials and Consoles Definitions
2200     Serial dictionaries can contain the following properties:
2201     type
2202         Type of the serial connection, like ``'tcp'``, ``'pty'``, ``'file'``, ``'udp'``, ``'dev'``,
2203         ``'pipe'``, ``'unix'``.
2204     path
2205         Path to the source device. Can be a log file, a host character device to pass through,
2206         a unix socket, a named pipe path.
2207     host
2208         The serial UDP or TCP host name.
2209         (Default: 23023)
2210     port
2211         The serial UDP or TCP port number.
2212         (Default: 23023)
2213     protocol
2214         Name of the TCP connection protocol.
2215         (Default: telnet)
2216     tls
2217         Boolean value indicating whether to use hypervisor TLS certificates environment for TCP devices.
2218     target_port
2219         The guest device port number starting from 0
2220     target_type
2221         The guest device type. Common values are ``serial``, ``virtio`` or ``usb-serial``, but more are documented in
2222         `the libvirt documentation &lt;https://libvirt.org/formatdomain.html#consoles-serial-parallel-channel-devices&gt;`_.
2223     .. rubric:: CLI Example
2224     .. code-block:: bash
2225         salt 'hypervisor' virt.init vm_name 4 512 salt://path/to/image.raw
2226         salt 'hypervisor' virt.init vm_name 4 512 /var/lib/libvirt/images/img.raw
2227         salt 'hypervisor' virt.init vm_name 4 512 nic=profile disk=profile
2228     The disk images will be created in an image folder within the directory
2229     defined by the ``virt:images`` option. Its default value is
2230     ``/srv/salt-images/`` but this can changed with such a configuration:
2231     .. code-block:: yaml
2232         virt:
2233             images: /data/my/vm/images/
2234     .. _disk element: https://libvirt.org/formatdomain.html#elementsDisks
2235     .. _graphics element: https://libvirt.org/formatdomain.html#elementsGraphics
2236     """
2237     try</b></font>:
2238         conn = __get_conn(**kwargs)
2239         caps = _capabilities(conn)
2240         os_types = sorted({guest["os_type"] for guest in caps["guests"]})
2241         arches = sorted({guest["arch"]["name"] for guest in caps["guests"]})
2242         virt_hypervisor = hypervisor
2243         if not virt_hypervisor:
2244             hypervisors = sorted(
2245                 {
2246                     x
2247                     for y in [
2248                         guest["arch"]["domains"].keys() for guest in caps["guests"]
2249                     ]
2250                     for x in y
2251                 }
2252             )
2253             if len(hypervisors) == 0:
2254                 raise SaltInvocationError("No supported hypervisors were found")
2255             virt_hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
2256         virt_hypervisor = "vmware" if virt_hypervisor == "esxi" else virt_hypervisor
2257         log.debug("Using hypervisor %s", virt_hypervisor)
2258         nicp = _get_merged_nics(virt_hypervisor, nic, interfaces)
2259         diskp = _disk_profile(conn, disk, virt_hypervisor, disks, name)
2260         for _disk in diskp:
2261             if _disk.get("device", "disk") == "cdrom":
2262                 continue
2263             log.debug("Creating disk for VM [ %s ]: %s", name, _disk)
2264             if virt_hypervisor == "vmware":
2265                 if "image" in _disk:
2266                     raise SaltInvocationError(
2267                         "virt.init does not support image "
2268                         "template in conjunction with esxi hypervisor"
2269                     )
2270                 else:
2271                     log.debug("Generating libvirt XML for %s", _disk)
2272                     volume_name = "{}/{}".format(name, _disk["name"])
2273                     filename = "{}.{}".format(volume_name, _disk["format"])
2274                     vol_xml = _gen_vol_xml(
2275                         filename, _disk["size"], format=_disk["format"]
2276                     )
2277                     _define_vol_xml_str(conn, vol_xml, pool=_disk.get("pool"))
2278             elif virt_hypervisor in ["qemu", "kvm", "xen"]:
2279                 def seeder(path):
2280                     _seed_image(
2281                         seed_cmd,
2282                         path,
2283                         name,
2284                         kwargs.get("config"),
2285                         install,
2286                         pub_key,
2287                         priv_key,
2288                     )
2289                 create_overlay = _disk.get("overlay_image", False)
2290                 format = _disk.get("format")
2291                 if _disk.get("source_file"):
2292                     if os.path.exists(_disk["source_file"]):
2293                         img_dest = _disk["source_file"]
2294                     else:
2295                         img_dest = _qemu_image_create(_disk, create_overlay, saltenv)
2296                 else:
2297                     _disk_volume_create(conn, _disk, seeder if seed else None, saltenv)
2298                     img_dest = None
2299                 if seed and img_dest and _disk.get("image", None):
2300                     seeder(img_dest)
2301                 img_dest = _zfs_image_create(
2302                     vm_name=name,
2303                     pool<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=_disk.get("pool"),
2304                     disk_name=_disk.get("name"),
2305                     disk_size=_disk.get("size"),
2306                     disk_image_name=_disk.get("image"),
2307                     hostname_property_name=_disk.get("hostname_property"),
2308                     sparse_volume=_disk.get(</b></font>"sparse_volume"),
2309                 )
2310             else:
2311                 raise SaltInvocationError(
2312                     "Unsupported hypervisor when handling disk image: {}".format(
2313                         virt_hypervisor
2314                     )
2315                 )
2316         log.debug("Generating VM XML")
2317         if os_type is None:
2318             os_type = "hvm" if "hvm" in os_types else os_types[0]
2319         if arch is None:
2320             arch = "x86_64" if "x86_64" in arches else arches[0]
2321         if boot is not None:
2322             boot = _handle_remote_boot_params(boot)
2323         vm_xml = _gen_xml(
2324             conn,
2325             name,
2326             cpu,
2327             mem,
2328             diskp,
2329             nicp,
2330             virt_hypervisor,
2331             os_type,
2332             arch,
2333             graphics,
2334             boot,
2335             boot_dev,
2336             numatune,
2337             hypervisor_features,
2338             clock,
2339             serials,
2340             consoles,
2341             stop_on_reboot,
2342             host_devices,
2343             **kwargs
2344         )
2345         log.debug("New virtual machine definition: %s", vm_xml)
2346         conn.defineXML(vm_xml)
2347     except libvirt.libvirtError as err:
2348         conn.close()
2349         raise CommandExecutionError(err.get_error_message())
2350     if start:
2351         log.debug("Starting VM %s", name)
2352         _get_domain(conn, name).create()
2353     conn.close()
2354     return True
2355 def _disks_equal(disk1, disk2):
2356     Test if two disk elements should be considered like the same device
2357     """
2358     target1 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= disk1.find("target")
2359     target2 = disk2.find("target")
2360     disk1_dict = xmlutil.to_dict(disk1, True)
2361     disk2_dict = xmlutil.to_dict(disk2, True)
2362     source1_dict = disk1_dict.get("source", {})
2363     source2_dict = disk2_dict.get("source", {})
2364     io1 = disk1_dict.get(</b></font>"driver", {}).get("io", "native")
2365     io2 = disk2_dict.get("driver", {}).get("io", "native")
2366     if source1_dict:
2367         source1_dict.pop("index", None)
2368     if source2_dict:
2369         source2_dict.pop("index", None)
2370     return (
2371         source1_dict == source2_dict
2372         and target1 is not None
2373         and target2 is not None
2374         and target1.get("bus") == target2.get("bus")
2375         and disk1.get("device", "disk") == disk2.get("device", "disk")
2376         and target1.get("dev") == target2.get("dev")
2377         and io1 == io2
2378     )
2379 def _nics_equal(nic1, nic2):
2380     """
2381     Test if two interface elements should be considered like the same device
2382     """
2383     def _filter_nic(nic):
2384         """
2385         Filter out elements to ignore when comparing nics
2386         """
2387         source_node = nic.find("source")
2388         source_attrib = source_node.attrib if source_node is not None else {}
2389         source_type = "network" if "network" in source_attrib else nic.attrib["type"]
2390         source_getters = {
2391             "network": lambda n: n.get("network"),
2392             "bridge": lambda n: n.get("bridge"),
2393             "direct": lambda n: n.get("dev"),
2394             "hostdev": lambda n: _format_pci_address(n.find("address")),
2395         }
2396         return {
2397             "type": source_type,
2398             "source": source_getters[source_type](source_node)
2399             if source_node is not None
2400             else None,
2401             "model": nic.find("model").attrib["type"]
2402             if nic.find("model") is not None
2403             else None,
2404         }
2405     def _get_mac(nic):
2406         return (
2407             nic.find("mac").attrib["address"].lower()
2408             if nic.find("mac") is not None
2409             else None
2410         )
2411     mac1 = _get_mac(nic1)
2412     mac2 = _get_mac(nic2)
2413     macs_equal = not mac1 or not mac2 or mac1 == mac2
2414     return _filter_nic(nic1) == _filter_nic(nic2) and macs_equal
2415 def _graphics_equal(gfx1, gfx2):
2416     """
2417     Test if two graphics devices should be considered the same device
2418     """
2419     def _filter_graphics(gfx):
2420         """
2421         When the domain is running, the graphics element may contain additional properties
2422         with the default values. This function will strip down the default values.
2423         """
2424         gfx_copy = copy.deepcopy(gfx)
2425         defaults = [
2426             {"node": ".", "attrib": "port", "values": ["5900", "-1"]},
2427             {"node": ".", "attrib": "address", "values": ["127.0.0.1"]},
2428             {"node": "listen", "attrib": "address", "values": ["127.0.0.1"]},
2429         ]
2430         for default in defaults:
2431             node = gfx_copy.find(default["node"])
2432             attrib = default["attrib"]
2433             if node is not None and (
2434                 attrib in node.attrib and node.attrib[attrib] in default["values"]
2435             ):
2436                 node.attrib.pop(attrib)
2437         return gfx_copy
2438     return xmlutil.to_dict(_filter_graphics(gfx1), True) == xmlutil.to_dict(
2439         _filter_graphics(gfx2), True
2440     )
2441 def _hostdevs_equal(dev1, dev2):
2442     """
2443     Test if two hostdevs devices should be considered the same device
2444     """
2445     def _filter_hostdevs(dev):
2446         """
2447         When the domain is running, the hostdevs element may contain additional properties.
2448         This function will only keep the ones we care about
2449         """
2450         type_ = dev.get("type")
2451         definition = {
2452             "type": type_,
2453         }
2454         if type_ == "pci":
2455             address_node = dev.find("./source/address")
2456             for attr in ["domain", "bus", "slot", "function"]:
2457                 definition[attr] = address_node.get(attr)
2458         elif type_ == "usb":
2459             for attr in ["vendor", "product"]:
2460                 definition[attr] = dev.find("./source/" + attr).get("id")
2461         return definition
2462     return _filter_hostdevs(dev1) == _filter_hostdevs(dev2)
2463 def _diff_lists(old, new, comparator):
2464     """
2465     Compare lists to extract the changes
2466     :param old: old list
2467     :param new: new list
2468     :return: a dictionary with ``unchanged``, ``new``, ``deleted`` and ``sorted`` keys
2469     The sorted list is the union of unchanged and new lists, but keeping the original
2470     order from the new list.
2471     """
2472     def _remove_indent(node):
2473         """
2474         Remove the XML indentation to compare XML trees more easily
2475         """
2476         node_copy = copy.deepcopy(node)
2477         node_copy.text = None
2478         for item in node_copy.iter():
2479             item.tail = None
2480         return node_copy
2481     diff = {"unchanged": [], "new": [], "deleted": [], "sorted": []}
2482     old_devices = copy.deepcopy(old)
2483     for new_item in new:
2484         found = [
2485             item
2486             for item in old_devices
2487             if comparator(_remove_indent(item), _remove_indent(new_item))
2488         ]
2489         if found:
2490             old_devices.remove(found[0])
2491             diff["unchanged"].append(found[0])
2492             diff["sorted"].append(found[0])
2493         else:
2494             diff["new"].append(new_item)
2495             diff["sorted"].append(new_item)
2496     diff["deleted"] = old_devices
2497     return diff
2498 def _get_disk_target(targets, disks_count, prefix):
2499     """
2500     Compute the disk target name for a given prefix.
2501     :param targets: the list of already computed targets
2502     :param disks: the number of disks
2503     :param prefix: the prefix of the target name, i.e. "hd"
2504     """
2505     for i in range(disks_count):
2506         ret = "{}{}".format(prefix, string.ascii_lowercase[i])
2507         if ret not in targets:
2508             return ret
2509     return None
2510 def _diff_disk_lists(old, new):
2511     """
2512     Compare disk definitions to extract the changes and fix target devices
2513     :param old: list of ElementTree nodes representing the old disks
2514     :param new: list of ElementTree nodes representing the new disks
2515     """
2516     targets = []
2517     prefixes = ["fd", "hd", "vd", "sd", "xvd", "ubd"]
2518     for disk in new:
2519         target_node = disk.find("target")
2520         target = target_node.get("dev")
2521         prefix = [item for item in prefixes if target.startswith(item)][0]
2522         new_target = _get_disk_target(targets, len(new), prefix)
2523         target_node.set("dev", new_target)
2524         targets.append(new_target)
2525     return _diff_lists(old, new, _disks_equal)
2526 def _diff_interface_lists(old, new):
2527     """
2528     Compare network interface definitions to extract the changes
2529     :param old: list of ElementTree nodes representing the old interfaces
2530     :param new: list of ElementTree nodes representing the new interfaces
2531     """
2532     return _diff_lists(old, new, _nics_equal)
2533 def _diff_graphics_lists(old, new):
2534     """
2535     Compare graphic devices definitions to extract the changes
2536     :param old: list of ElementTree nodes representing the old graphic devices
2537     :param new: list of ElementTree nodes representing the new graphic devices
2538     """
2539     return _diff_lists(old, new, _graphics_equal)
2540 def _diff_hostdev_lists(old, new):
2541     """
2542     Compare hostdev devices definitions to extract the changes
2543     :param old: list of ElementTree nodes representing the old hostdev devices
2544     :param new: list of ElementTree nodes representing the new hostdev devices
2545     """
2546     return _diff_lists(old, new, _hostdevs_equal)
2547 def _expand_cpuset(cpuset):
2548     """
2549     Expand the libvirt cpuset and nodeset values into a list of cpu/node IDs
2550     """
2551     if cpuset is None:
2552         return None
2553     if isinstance(cpuset, int):
2554         return str(cpuset)
2555     result = set()
2556     toremove = set()
2557         m = re.match("([0-9]+)-([0-9]+)", part)
2558         if m:
2559             result |= set<font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(range(int(m.group(1)), int(m.group(2)) + 1))
2560         elif part.startswith("^"):
2561             toremove.add(</b></font>int(part[1:]))
2562         else:
2563             result.add(int(part))
2564     cpus = list(result - toremove)
2565     cpus.sort()
2566     cpus = [str(cpu) for cpu in cpus]
2567     return ",".join(cpus)
2568 def _normalize_cpusets(desc, data):
2569     """
2570     Expand the cpusets that can't be expanded by the change_xml() function,
2571     namely the ones that are used as keys and in the middle of the XPath expressions.
2572     """
2573     xpaths = ["cputune/cachetune", "cputune/cachetune/monitor", "cputune/memorytune"]
2574     for xpath in xpaths:
2575         nodes = desc.findall(xpath)
2576         for node in nodes:
2577             node.set("vcpus", _expand_cpuset(node.get("vcpus")))
2578     if not isinstance(data.get("cpu"), dict):
2579         return
2580     tuning = data["cpu"].get("tuning", {})
2581     for child in ["cachetune", "memorytune"]:
2582         if tuning.get(child):
2583             new_item = dict()
2584             for cpuset, value in tuning[child].items():
2585                 if child == "cachetune" and value.get("monitor"):
2586                     value["monitor"] = {
2587                         _expand_cpuset(monitor_cpus): monitor
2588                         for monitor_cpus, monitor in value["monitor"].items()
2589                     }
2590                 new_item[_expand_cpuset(cpuset)] = value
2591             tuning[child] = new_item
2592 def _serial_or_concole_equal(old, new):
2593     def _filter_serial_or_concole(item):
2594         """
2595         Filter out elements to ignore when comparing items
2596         """
2597         return {
2598             "type": item.attrib["type"],
2599             "port": item.find("source").get("service")
2600             if item.find("source") is not None
2601             else None,
2602             "protocol": item.find("protocol").get("type")
2603             if item.find("protocol") is not None
2604             else None,
2605         }
2606     return _filter_serial_or_concole(old) == _filter_serial_or_concole(new)
2607 def _diff_serial_lists(old, new):
2608     """
2609     Compare serial definitions to extract the changes
2610     :param old: list of ElementTree nodes representing the old serials
2611     :param new: list of ElementTree nodes representing the new serials
2612     """
2613     return _diff_lists(old, new, _serial_or_concole_equal)
2614 def _diff_console_lists(old, new):
2615     """
2616     Compare console definitions to extract the changes
2617     :param old: list of ElementTree nodes representing the old consoles
2618     :param new: list of ElementTree nodes representing the new consoles
2619     """
2620     return _diff_lists(old, new, _serial_or_concole_equal)
2621 def _format_pci_address(node):
2622     return "{}:{}:{}.{}".format(
2623         node.get("domain").replace("0x", ""),
2624         node.get("bus").replace("0x", ""),
2625         node.get("slot").replace("0x", ""),
2626         node.get("function").replace("0x", ""),
2627     )
2628 def _almost_equal(current, new):
2629     """
2630     return True if the parameters are numbers that are almost
2631     """
2632     if current is None or new is None:
2633         return False
2634     return abs(current - new) / current &lt; 1e-03
2635 def _compute_device_changes(old_xml, new_xml, to_skip):
2636     """
2637     Compute the device changes between two domain XML definitions.
2638     """
2639     devices_node = old_xml.find("devices")
2640     changes = {}
2641     for dev_type in to_skip:
2642         changes[dev_type] = {}
2643         if not to_skip[dev_type]:
2644             old = devices_node.findall(dev_type)
2645             new = new_xml.findall("devices/{}".format(dev_type))
2646             changes[dev_type] = globals()["_diff_{}_lists".format(dev_type)](old, new)
2647     return changes
2648 def _get_pci_addresses(node):
2649     """
2650     Get all the pci addresses in the node in 0000:00:00.0 form
2651     """
2652     return {_format_pci_address(address) for address in node.findall(".//address")}
2653 def _correct_networks(conn, desc):
2654     """
2655     Adjust the interface devices matching existing networks.
2656     Returns the network interfaces XML definition as string mapped to the new device node.
2657     """
2658     networks = [ElementTree.fromstring(net.XMLDesc()) for net in conn.listAllNetworks()]
2659     nics = desc.findall("devices/interface")
2660     device_map = {}
2661     for nic in nics:
2662         if nic.get("type") == "hostdev":
2663             addr = _get_pci_addresses(nic.find("source"))
2664             matching_nets = [
2665                 net
2666                 for net in networks
2667                 if net.find("forward").get("mode") == "hostdev"
2668                 and addr &amp; _get_pci_addresses(net)
2669             ]
2670             if matching_nets:
2671                 old_xml = ElementTree.tostring(nic)
2672                 nic.set("type", "network")
2673                 nic.find("source").set("network", matching_nets[0].find("name").text)
2674                 device_map[nic] = old_xml
2675     return device_map
2676 def _update_live(domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test):
2677     """
2678     Perform the live update of a domain.
2679     """
2680     status = {}
2681     errors = []
2682     if not domain.isActive():
2683         return status, errors
2684     commands = []
2685     if cpu and (isinstance(cpu, int) or isinstance(cpu, dict) and cpu.get("maximum")):
2686         new_cpu = cpu.get("maximum") if isinstance(cpu, dict) else cpu
2687         if old_cpu != new_cpu and new_cpu is not None:
2688             commands.append(
2689                 {
2690                     "device": "cpu",
2691                     "cmd": "setVcpusFlags",
2692                     "args": [new_cpu, libvirt.VIR_DOMAIN_AFFECT_LIVE],
2693                 }
2694             )
2695     if mem:
2696         if isinstance(mem, dict):
2697             new_mem = (
2698                 int(_handle_unit(mem.get("current")) / 1024)
2699                 if "current" in mem
2700                 else None
2701             )
2702         elif isinstance(mem, int):
2703             new_mem = int(mem * 1024)
2704         if not _almost_equal(old_mem, new_mem) and new_mem is not None:
2705             commands.append(
2706                 {
2707                     "device": "mem",
2708                     "cmd": "setMemoryFlags",
2709                     "args": [new_mem, libvirt.VIR_DOMAIN_AFFECT_LIVE],
2710                 }
2711             )
2712     old_desc = ElementTree.fromstring(domain.XMLDesc(0))
2713     changed_devices = {"interface": _correct_networks(domain.connect(), old_desc)}
2714     changes = _compute_device_changes(old_desc, new_desc, to_skip)
2715     removable_changes = []
2716     new_disks = []
2717     for new_disk in changes["disk"].get("new", []):
2718         device = new_disk.get("device", "disk")
2719         if device not in ["cdrom", "floppy"]:
2720             new_disks.append(new_disk)
2721             continue
2722         target_dev = new_disk.find("target").get("dev")
2723         matching = [
2724             old_disk
2725             for old_disk in changes["disk"].get("deleted", [])
2726             if old_disk.get("device", "disk") == device
2727             and old_disk.find("target").get("dev") == target_dev
2728         ]
2729         if not matching:
2730             new_disks.append(new_disk)
2731             updated_disk = matching[0]
2732             changes["disk"]["deleted"]<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.remove(updated_disk)
2733             removable_changes.append(updated_disk)
2734             source_node = updated_disk.find("source")
2735             new_source_node = new_disk.find("source")
2736             source_file = (
2737                 new_source_node.</b></font>get("file") if new_source_node is not None else None
2738             )
2739             updated_disk.set("type", "file")
2740             if source_node is not None:
2741                 updated_disk.remove(source_node)
2742             if source_file:
2743                 ElementTree.SubElement(
2744                     updated_disk, "source", attrib={"file": source_file}
2745                 )
2746     changes["disk"]["new"] = new_disks
2747     for dev_type in ["disk", "interface", "hostdev"]:
2748         for added in changes[dev_type].get("new", []):
2749             commands.append(
2750                 {
2751                     "device": dev_type,
2752                     "cmd": "attachDevice",
2753                     "args": [xmlutil.element_to_str(added)],
2754                 }
2755             )
2756         for removed in changes[dev_type].get("deleted", []):
2757             removed_def = changed_devices.get(dev_type, {}).get(
2758                 removed, ElementTree.tostring(removed)
2759             )
2760             commands.append(
2761                 {
2762                     "device": dev_type,
2763                     "cmd": "detachDevice",
2764                     "args": [salt.utils.stringutils.to_str(removed_def)],
2765                 }
2766             )
2767     for updated_disk in removable_changes:
2768         commands.append(
2769             {
2770                 "device": "disk",
2771                 "cmd": "updateDeviceFlags",
2772                 "args": [xmlutil.element_to_str(updated_disk)],
2773             }
2774         )
2775     for cmd in commands:
2776         try:
2777             ret = 0 if test else getattr(domain, cmd["cmd"])(*cmd["args"])
2778             device_type = cmd["device"]
2779             if device_type in ["cpu", "mem"]:
2780                 status[device_type] = not ret
2781             else:
2782                 actions = {
2783                     "attachDevice": "attached",
2784                     "detachDevice": "detached",
2785                     "updateDeviceFlags": "updated",
2786                 }
2787                 device_status = status.setdefault(device_type, {})
2788                 cmd_status = device_status.setdefault(actions[cmd["cmd"]], [])
2789                 cmd_status.append(cmd["args"][0])
2790         except libvirt.libvirtError as err:
2791             errors.append(str(err))
2792     return status, errors
2793 def update(
2794     name,
2795     cpu=0,
2796     mem=0,
2797     disk_profile=None,
2798     disks=None,
2799     nic_profile=None,
2800     interfaces=None,
2801     graphics=None,
2802     live=True,
2803     boot=None,
2804     numatune=None,
2805     test=False,
2806     boot_dev=None,
2807     hypervisor_features=None,
2808     clock=None,
2809     serials=None,
2810     consoles=None,
2811     stop_on_reboot=False,
2812     host_devices=None,
2813     **kwargs
2814 ):
2815     """
2816     Update the definition of an existing domain.
2817     :param name: Name of the domain to update
2818     :param cpu:
2819         Number of virtual CPUs to assign to the virtual machine or a dictionary with detailed information to configure
2820         cpu model and topology, numa node tuning, cpu tuning and iothreads allocation. The structure of the dictionary is
2821         documented in :ref:`init-cpu-def`.
2822         To update any cpu parameters specify the new values to the corresponding tag. To remove any element or attribute,
2823         specify ``None`` object. Please note that ``None`` object is mapped to ``null`` in yaml, use ``null`` in sls file
2824         instead.
2825     :param mem: Amount of memory to allocate to the virtual machine in MiB. Since 3002, a dictionary can be used to
2826         contain detailed configuration which support memory allocation or tuning. Supported parameters are ``boot``,
2827         ``current``, ``max``, ``slots``, ``hard_limit``, ``soft_limit``, ``swap_hard_limit``, ``min_guarantee``,
2828         ``hugepages`` ,  ``nosharepages``, ``locked``, ``source``, ``access``, ``allocation`` and ``discard``. The structure
2829         of the dictionary is documented in  :ref:`init-mem-def`. Both decimal and binary base are supported. Detail unit
2830         specification is documented  in :ref:`virt-units`. Please note that the value for ``slots`` must be an integer.
2831         To remove any parameters, pass a None object, for instance: 'soft_limit': ``None``. Please note  that ``None``
2832         is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
2833         .. code-block:: yaml
2834             - mem:
2835                 hard_limit: null
2836                 soft_limit: null
2837         .. versionchanged:: 3002
2838     :param disk_profile: disk profile to use
2839     :param disks:
2840         Disk definitions as documented in the :func:`init` function.
2841         If neither the profile nor this parameter are defined, the disk devices
2842         will not be changed. However to clear disks set this parameter to empty list.
2843     :param nic_profile: network interfaces profile to use
2844     :param interfaces:
2845         Network interface definitions as documented in the :func:`init` function.
2846         If neither the profile nor this parameter are defined, the interface devices
2847         will not be changed. However to clear network interfaces set this parameter
2848         to empty list.
2849     :param graphics:
2850         The new graphics definition as defined in :ref:`init-graphics-def`. If not set,
2851         the graphics will not be changed. To remove a graphics device, set this parameter
2852         to ``{'type': 'none'}``.
2853     :param live:
2854         ``False`` to avoid trying to live update the definition. In such a case, the
2855         new definition is applied at the next start of the virtual machine. If ``True``,
2856         not all aspects of the definition can be live updated, but as much as possible
2857         will be attempted. (Default: ``True``)
2858     :param connection: libvirt connection URI, overriding defaults
2859     :param username: username to connect with, overriding defaults
2860     :param password: password to connect with, overriding defaults
2861     :param boot:
2862         Specifies kernel, initial ramdisk and kernel command line parameters for the virtual machine.
2863         This is an optional parameter, all of the keys are optional within the dictionary.
2864         Refer to :ref:`init-boot-def` for the complete boot parameter description.
2865         To update any boot parameters, specify the new path for each. To remove any boot parameters, pass ``None`` object,
2866         for instance: 'kernel': ``None``. To switch back to BIOS boot, specify ('loader': ``None`` and 'nvram': ``None``)
2867         or 'efi': ``False``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in sls file instead.
2868         SLS file Example:
2869         .. code-block:: yaml
2870             - boot:
2871                 loader: null
2872                 nvram: null
2873         .. versionadded:: 3000
2874     :param boot_dev:
2875         Space separated list of devices to boot from sorted by decreasing priority.
2876         Values can be ``hd``, ``fd``, ``cdrom`` or ``network``.
2877         By default, the value will ``"hd"``.
2878         .. versionadded:: 3002
2879     :param numatune:
2880         The optional numatune element provides details of how to tune the performance of a NUMA host via controlling NUMA
2881         policy for domain process. The optional ``memory`` element specifies how to allocate memory for the domain process
2882         on a NUMA host. ``memnode`` elements can specify memory allocation policies per each guest NUMA node. The definition
2883         used in the dictionary can be found at :ref:`init-cpu-def`.
2884         To update any numatune parameters, specify the new value. To remove any ``numatune`` parameters, pass a None object,
2885         for instance: 'numatune': ``None``. Please note that ``None`` is mapped to ``null`` in sls file, pass ``null`` in
2886         sls file instead.
2887         .. versionadded:: 3003
2888     :param serials:
2889         Dictionary providing details on the serials connection to create. (Default: ``None``)
2890         See :ref:`init-chardevs-def` for more details on the possible values.
2891         .. versionadded:: 3003
2892     :param consoles:
2893         Dictionary providing details on the consoles device to create. (Default: ``None``)
2894         See :ref:`init-chardevs-def` for more details on the possible values.
2895         .. versionadded:: 3003
2896     :param stop_on_reboot:
2897         If set to ``True`` the guest will stop instead of rebooting.
2898         This is specially useful when creating a virtual machine with an installation cdrom or
2899         an autoinstallation needing a special first boot configuration.
2900         Defaults to ``False``
2901         .. versionadded:: 3003
2902     :param test: run in dry-run mode if set to True
2903         .. versionadded:: 3001
2904     :param hypervisor_features:
2905         Enable or disable hypervisor-specific features on the virtual machine.
2906         .. versionadded:: 3003
2907         .. code-block:: yaml
2908             hypervisor_features:
2909               kvm-hint-dedicated: True
2910     :param clock:
2911         Configure the guest clock.
2912         The value is a dictionary with the following keys:
2913         adjustment
2914             time adjustment in seconds or ``reset``
2915         utc
2916             set to ``False`` to use the host local time as the guest clock. Defaults to ``True``.
2917         timezone
2918             synchronize the guest to the correspding timezone
2919         timers
2920             a dictionary associating the timer name with its configuration.
2921             This configuration is a dictionary with the properties ``track``, ``tickpolicy``,
2922             ``catchup``, ``frequency``, ``mode``, ``present``, ``slew``, ``threshold`` and ``limit``.
2923             See `libvirt time keeping documentation &lt;https://libvirt.org/formatdomain.html#time-keeping&gt;`_ for the possible values.
2924         .. versionadded:: 3003
2925         Set the clock to local time using an offset in seconds
2926         .. code-block:: yaml
2927             clock:
2928               adjustment: 3600
2929               utc: False
2930         Set the clock to a specific time zone:
2931         .. code-block:: yaml
2932             clock:
2933               timezone: CEST
2934         Tweak guest timers:
2935         .. code-block:: yaml
2936             clock:
2937               timers:
2938                 tsc:
2939                   frequency: 3504000000
2940                   mode: native
2941                 rtc:
2942                   track: wall
2943                   tickpolicy: catchup
2944                   slew: 4636
2945                   threshold: 123
2946                   limit: 2342
2947                 hpet:
2948                   present: False
2949     :param host_devices:
2950         List of host devices to passthrough to the guest.
2951         The value is a list of device names as provided by the :py:func:`~salt.modules.virt.node_devices` function.
2952         (Default: ``None``)
2953         .. versionadded:: 3003
2954     :return:
2955         Returns a dictionary indicating the status of what has been done. It is structured in
2956         the following way:
2957         .. code-block:: python
2958             {
2959               'definition': True,
2960               'cpu': True,
2961               'mem': True,
2962               'disks': {'attached': [list of actually attached disks],
2963                         'detached': [list of actually detached disks]},
2964               'nics': {'attached': [list of actually attached nics],
2965                        'detached': [list of actually detached nics]},
2966               'errors': ['error messages for failures']
2967             }
2968     .. versionadded:: 2019.2.0
2969     CLI Example:
2970     .. code-block:: bash
2971         salt '*' virt.update domain cpu=2 mem=1024
2972     """
2973     status = {
2974         "definition": False,
2975         "disk": {"attached": [], "detached": [], "updated": []},
2976         "interface": {"attached": [], "detached": []},
2977     }
2978     conn = __get_conn(**kwargs)
2979     domain = _get_domain(conn, name)
2980     desc = ElementTree.fromstring(domain.XMLDesc(libvirt.VIR_DOMAIN_XML_INACTIVE))
2981     need_update = False
2982     hypervisor = desc.get("type")
2983     all_disks = _disk_profile(conn, disk_profile, hypervisor, disks, name)
2984     if boot is not None:
2985         boot = _handle_remote_boot_params(boot)
2986         if boot.get("efi", None) is not None:
2987             need_update = _handle_efi_param(boot, desc)
2988     new_desc = ElementTree.fromstring(
2989         _gen_xml(
2990             conn,
2991             name,
2992             cpu,
2993             mem or 0,
2994             all_disks,
2995             _get_merged_nics(hypervisor, nic_profile, interfaces),
2996             hypervisor,
2997             domain.OSType(),
2998             desc.find(".//os/type").get("arch"),
2999             graphics,
3000             boot,
3001             boot_dev,
3002             numatune,
3003             serials=serials,
3004             consoles=consoles,
3005             stop_on_reboot=stop_on_reboot,
3006             host_devices=host_devices,
3007             **kwargs
3008         )
3009     )
3010     if clock:
3011         offset = "utc" if clock.get("utc", True) else "localtime"
3012         if "timezone" in clock:
3013             offset = "timezone"
3014         clock["offset"] = offset
3015     def _set_loader(node, value):
3016         salt.utils.xmlutil.set_node_text(node, value)
3017         if value is not None:
3018             node.set("readonly", "yes")
3019             node.set("type", "pflash")
3020     def _set_nvram(node, value):
3021         node.set("template", value)
3022     def _set_with_byte_unit(attr_name=None):
3023         def _setter(node, value):
3024             if attr_name:
3025                 node.set(attr_name, str(value))
3026             else:
3027                 node.text = str(value)
3028             node.set("unit", "bytes")
3029         return _setter
3030     def _get_with_unit(node):
3031         unit = node.get("unit", "KiB")
3032         unit = unit if unit != "bytes" else "b"
3033         value = node.get("memory") or node.get("size") or node.text
3034         return _handle_unit("{}{}".format(value, unit)) if value else None
3035     def _set_vcpu(node, value):
3036         node.text = str(value)
3037         node.set("current", str(value))
3038     old_mem = int(_get_with_unit(desc.find("memory")) / 1024)
3039     old_cpu = int(desc.find("./vcpu").text)
3040     def _yesno_attribute(path, xpath, attr_name, ignored=None):
3041         return xmlutil.attribute(
3042             path, xpath, attr_name, ignored, lambda v: "yes" if v else "no"
3043         )
3044     def _memory_parameter(path, xpath, attr_name=None, ignored=None):
3045         entry = {
3046             "path": path,
3047             "xpath": xpath,
3048             "convert": _handle_unit,
3049             "get": _get_with_unit,
3050             "set": _set_with_byte_unit(attr_name),
3051             "equals": _almost_equal,
3052         }
3053         if attr_name:
3054             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
3055         return entry
3056     def _cpuset_parameter(path, xpath, attr_name=None, ignored=None):
3057         def _set_cpuset(node, value):
3058             if attr_name:
3059                 node.set(attr_name, value)
3060             else:
3061                 node.text = value
3062         entry = {
3063             "path": path,
3064             "xpath": xpath,
3065             "convert": _expand_cpuset,
3066             "get": lambda n: _expand_cpuset(n.get(attr_name) if attr_name else n.text),
3067             "set": _set_cpuset,
3068         }
3069         if attr_name:
3070             entry["del"] = salt.utils.xmlutil.del_attribute(attr_name, ignored)
3071         return entry
3072     data = {k: v for k, v in locals().items() if bool(v)}
3073     data["stop_on_reboot"] = stop_on_reboot
3074     if boot_dev:
3075         data["boot_dev"] = boot_dev.split()
3076     timer_names = [
3077         "platform",
3078         "hpet",
3079         "kvmclock",
3080         "pit",
3081         "rtc",
3082         "tsc",
3083         "hypervclock",
3084         "armvtimer",
3085     ]
3086     if data.get("clock", {}).get("timers"):
3087         attributes = [
3088             "track",
3089             "tickpolicy",
3090             "frequency",
3091             "mode",
3092             "present",
3093             "slew",
3094             "threshold",
3095             "limit",
3096         ]
3097         for timer in data["clock"]["timers"].values():
3098             for attribute in attributes:
3099                 if attribute not in timer:
3100                     timer[attribute] = None
3101         for timer_name in timer_names:
3102             if timer_name not in data["clock"]["timers"]:
3103                 data["clock"]["timers"][timer_name] = None
3104     _normalize_cpusets(desc, data)
3105     params_mapping = [
3106         {
3107             "path": "stop_on_reboot",
3108             "xpath": "on_reboot",
3109             "convert": lambda v: "destroy" if v else "restart",
3110         },
3111         {"path": "boot:kernel", "xpath": "os/kernel"},
3112         {"path": "boot:initrd", "xpath": "os/initrd"},
3113         {"path": "boot:cmdline", "xpath": "os/cmdline"},
3114         {"path": "boot:loader", "xpath": "os/loader", "set": _set_loader},
3115         {"path": "boot:nvram", "xpath": "os/nvram", "set": _set_nvram},
3116         _memory_parameter("mem", "memory"),
3117         _memory_parameter("mem", "currentMemory"),
3118         _memory_parameter("mem:max", "maxMemory"),
3119         _memory_parameter("mem:boot", "memory"),
3120         _memory_parameter("mem:current", "currentMemory"),
3121         xmlutil.attribute("mem:slots", "maxMemory", "slots", ["unit"]),
3122         _memory_parameter("mem:hard_limit", "memtune/hard_limit"),
3123         _memory_parameter("mem:soft_limit", "memtune/soft_limit"),
3124         _memory_parameter("mem:swap_hard_limit", "memtune/swap_hard_limit"),
3125         _memory_parameter("mem:min_guarantee", "memtune/min_guarantee"),
3126         xmlutil.attribute("boot_dev:{dev}", "os/boot[$dev]", "dev"),
3127         _memory_parameter(
3128             "mem:hugepages:{id}:size",
3129             "memoryBacking/hugepages/page[$id]",
3130             "size",
3131             ["unit", "nodeset"],
3132         ),
3133         _cpuset_parameter(
3134             "mem:hugepages:{id}:nodeset", "memoryBacking/hugepages/page[$id]", "nodeset"
3135         ),
3136         {
3137             "path": "mem:nosharepages",
3138             "xpath": "memoryBacking/nosharepages",
3139             "get": lambda n: n is not None,
3140             "set": lambda n, v: None,
3141         },
3142         {
3143             "path": "mem:locked",
3144             "xpath": "memoryBacking/locked",
3145             "get": lambda n: n is not None,
3146             "set": lambda n, v: None,
3147         },
3148         xmlutil.attribute("mem:source", "memoryBacking/source", "type"),
3149         xmlutil.attribute("mem:access", "memoryBacking/access", "mode"),
3150         xmlutil.attribute("mem:allocation", "memoryBacking/allocation", "mode"),
3151         {"path": "mem:discard", "xpath": "memoryBacking/discard"},
3152         {
3153             "path": "cpu",
3154             "xpath": "vcpu",
3155             "get": lambda n: int(n.text),
3156             "set": _set_vcpu,
3157         },
3158         {"path": "cpu:maximum", "xpath": "vcpu", "get": lambda n: int(n.text)},
3159         xmlutil.attribute("cpu:placement", "vcpu", "placement"),
3160         _cpuset_parameter("cpu:cpuset", "vcpu", "cpuset"),
3161         xmlutil.attribute("cpu:current", "vcpu", "current"),
3162         xmlutil.attribute("cpu:match", "cpu", "match"),
3163         xmlutil.attribute("cpu:mode", "cpu", "mode"),
3164         xmlutil.attribute("cpu:check", "cpu", "check"),
3165         {"path": "cpu:model:name", "xpath": "cpu/model"},
3166         xmlutil.attribute("cpu:model:fallback", "cpu/model", "fallback"),
3167         xmlutil.attribute("cpu:model:vendor_id", "cpu/model", "vendor_id"),
3168         {"path": "cpu:vendor", "xpath": "cpu/vendor"},
3169         xmlutil.attribute("cpu:topology:sockets", "cpu/topology", "sockets"),
3170         xmlutil.attribute("cpu:topology:cores", "cpu/topology", "cores"),
3171         xmlutil.attribute("cpu:topology:threads", "cpu/topology", "threads"),
3172         xmlutil.attribute("cpu:cache:level", "cpu/cache", "level"),
3173         xmlutil.attribute("cpu:cache:mode", "cpu/cache", "mode"),
3174         xmlutil.attribute(
3175             "cpu:features:{id}", "cpu/feature[@name='$id']", "policy", ["name"]
3176         ),
3177         _yesno_attribute(
3178             "cpu:vcpus:{id}:enabled", "vcpus/vcpu[@id='$id']", "enabled", ["id"]
3179         ),
3180         _yesno_attribute(
3181             "cpu:vcpus:{id}:hotpluggable",
3182             "vcpus/vcpu[@id='$id']",
3183             "hotpluggable",
3184             ["id"],
3185         ),
3186         xmlutil.int_attribute(
3187             "cpu:vcpus:{id}:order", "vcpus/vcpu[@id='$id']", "order", ["id"]
3188         ),
3189         _cpuset_parameter(
3190             "cpu:numa:{id}:cpus", "cpu/numa/cell[@id='$id']", "cpus", ["id"]
3191         ),
3192         _memory_parameter(
3193             "cpu:numa:{id}:memory", "cpu/numa/cell[@id='$id']", "memory", ["id"]
3194         ),
3195         _yesno_attribute(
3196             "cpu:numa:{id}:discard", "cpu/numa/cell[@id='$id']", "discard", ["id"]
3197         ),
3198             "cpu:numa:{id}:memAccess", "cpu/numa/cell[@id='$id']", "memAccess", ["id"]
3199         ),
3200         xmlutil<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.attribute(
3201             "cpu:numa:{id}:distances:{sid}",
3202             "cpu/numa/cell[@id='$id']/distances/sibling[@id='$sid']",
3203             "value",
3204             ["id"],
3205         ),
3206         {"path": "cpu:iothreads", "xpath": "iothreads"},
3207         {"path": "cpu:tuning:shares", "xpath": "cputune/shares"},
3208         {"path": "cpu:tuning:period", "xpath": "cputune/period"},
3209         {"path": "cpu:tuning:quota", "xpath": "cputune/quota"},
3210         {"path": "cpu:tuning:global_period", "xpath": "cputune/global_period"},
3211         {"path": "cpu:tuning:global_quota", "xpath": "cputune/global_quota"},
3212         {"path": "cpu:tuning:emulator_period", "xpath": "cputune/emulator_period"},
3213         {"path": "cpu:tuning:emulator_quota", "xpath": "cputune/emulator_quota"},
3214         {"path": "cpu:tuning:iothread_period", "xpath": "cputune/iothread_period"},
3215         {"path": "cpu:tuning:iothread_quota", "xpath": "cputune/iothread_quota"},
3216         _cpuset_parameter(</b></font>
3217             "cpu:tuning:vcpupin:{id}",
3218             "cputune/vcpupin[@vcpu='$id']",
3219             "cpuset",
3220             ["vcpu"],
3221         ),
3222         _cpuset_parameter("cpu:tuning:emulatorpin", "cputune/emulatorpin", "cpuset"),
3223         _cpuset_parameter(
3224             "cpu:tuning:iothreadpin:{id}",
3225             "cputune/iothreadpin[@iothread='$id']",
3226             "cpuset",
3227             ["iothread"],
3228         ),
3229         xmlutil.attribute(
3230             "cpu:tuning:vcpusched:{id}:scheduler",
3231             "cputune/vcpusched[$id]",
3232             "scheduler",
3233             ["priority", "vcpus"],
3234         ),
3235         xmlutil.attribute(
3236             "cpu:tuning:vcpusched:{id}:priority", "cputune/vcpusched[$id]", "priority"
3237         ),
3238         _cpuset_parameter(
3239             "cpu:tuning:vcpusched:{id}:vcpus", "cputune/vcpusched[$id]", "vcpus"
3240         ),
3241         xmlutil.attribute(
3242             "cpu:tuning:iothreadsched:{id}:scheduler",
3243             "cputune/iothreadsched[$id]",
3244             "scheduler",
3245             ["priority", "iothreads"],
3246         ),
3247         xmlutil.attribute(
3248             "cpu:tuning:iothreadsched:{id}:priority",
3249             "cputune/iothreadsched[$id]",
3250             "priority",
3251         ),
3252         _cpuset_parameter(
3253             "cpu:tuning:iothreadsched:{id}:iothreads",
3254             "cputune/iothreadsched[$id]",
3255             "iothreads",
3256         ),
3257         xmlutil.attribute(
3258             "cpu:tuning:emulatorsched:scheduler",
3259             "cputune/emulatorsched",
3260             "scheduler",
3261             ["priority"],
3262         ),
3263         xmlutil.attribute(
3264             "cpu:tuning:emulatorsched:priority", "cputune/emulatorsched", "priority"
3265         ),
3266         xmlutil.attribute(
3267             "cpu:tuning:cachetune:{id}:monitor:{sid}",
3268             "cputune/cachetune[@vcpus='$id']/monitor[@vcpus='$sid']",
3269             "level",
3270             ["vcpus"],
3271         ),
3272         xmlutil.attribute(
3273             "cpu:tuning:memorytune:{id}:{sid}",
3274             "cputune/memorytune[@vcpus='$id']/node[@id='$sid']",
3275             "bandwidth",
3276             ["id", "vcpus"],
3277         ),
3278         xmlutil.attribute("clock:offset", "clock", "offset"),
3279         xmlutil.attribute("clock:adjustment", "clock", "adjustment", convert=str),
3280         xmlutil.attribute("clock:timezone", "clock", "timezone"),
3281     ]
3282     for timer in timer_names:
3283         params_mapping += [
3284             xmlutil.attribute(
3285                 "clock:timers:{}:track".format(timer),
3286                 "clock/timer[@name='{}']".format(timer),
3287                 "track",
3288                 ["name"],
3289             ),
3290             xmlutil.attribute(
3291                 "clock:timers:{}:tickpolicy".format(timer),
3292                 "clock/timer[@name='{}']".format(timer),
3293                 "tickpolicy",
3294                 ["name"],
3295             ),
3296             xmlutil.int_attribute(
3297                 "clock:timers:{}:frequency".format(timer),
3298                 "clock/timer[@name='{}']".format(timer),
3299                 "frequency",
3300                 ["name"],
3301             ),
3302             xmlutil.attribute(
3303                 "clock:timers:{}:mode".format(timer),
3304                 "clock/timer[@name='{}']".format(timer),
3305                 "mode",
3306                 ["name"],
3307             ),
3308             _yesno_attribute(
3309                 "clock:timers:{}:present".format(timer),
3310                 "clock/timer[@name='{}']".format(timer),
3311                 "present",
3312                 ["name"],
3313             ),
3314         ]
3315         for attr in ["slew", "threshold", "limit"]:
3316             params_mapping.append(
3317                 xmlutil.int_attribute(
3318                     "clock:timers:{}:{}".format(timer, attr),
3319                     "clock/timer[@name='{}']/catchup".format(timer),
3320                     attr,
3321                 )
3322             )
3323     for attr in ["level", "type", "size"]:
3324         params_mapping.append(
3325             xmlutil.attribute(
3326                 "cpu:tuning:cachetune:{id}:{sid}:" + attr,
3327                 "cputune/cachetune[@vcpus='$id']/cache[@id='$sid']",
3328                 attr,
3329                 ["id", "unit", "vcpus"],
3330             )
3331         )
3332     if hypervisor in ["qemu", "kvm"]:
3333         params_mapping += [
3334             xmlutil.attribute("numatune:memory:mode", "numatune/memory", "mode"),
3335             _cpuset_parameter("numatune:memory:nodeset", "numatune/memory", "nodeset"),
3336             xmlutil.attribute(
3337                 "numatune:memnodes:{id}:mode",
3338                 "numatune/memnode[@cellid='$id']",
3339                 "mode",
3340                 ["cellid"],
3341             ),
3342             _cpuset_parameter(
3343                 "numatune:memnodes:{id}:nodeset",
3344                 "numatune/memnode[@cellid='$id']",
3345                 "nodeset",
3346                 ["cellid"],
3347             ),
3348             xmlutil.attribute(
3349                 "hypervisor_features:kvm-hint-dedicated",
3350                 "features/kvm/hint-dedicated",
3351                 "state",
3352                 convert=lambda v: "on" if v else "off",
3353             ),
3354         ]
3355     need_update = (
3356         salt.utils.xmlutil.change_xml(desc, data, params_mapping) or need_update
3357     )
3358     devices_node = desc.find("devices")
3359     func_locals = locals()
3360     def _skip_update(names):
3361         return all(func_locals.get(n) is None for n in names)
3362     to_skip = {
3363         "disk": _skip_update(["disks", "disk_profile"]),
3364         "interface": _skip_update(["interfaces", "nic_profile"]),
3365         "graphics": _skip_update(["graphics"]),
3366         "serial": _skip_update(["serials"]),
3367         "console": _skip_update(["consoles"]),
3368         "hostdev": _skip_update(["host_devices"]),
3369     }
3370     changes = _compute_device_changes(desc, new_desc, to_skip)
3371     for dev_type in changes:
3372         if not to_skip[dev_type]:
3373             old = devices_node.findall(dev_type)
3374             if changes[dev_type].get("deleted") or changes[dev_type].get("new"):
3375                 for item in old:
3376                     devices_node.remove(item)
3377                 devices_node.extend(changes[dev_type]["sorted"])
3378                 need_update = True
3379     if need_update:
3380         try:
3381             if changes["disk"]:
3382                 for idx, item in enumerate(changes["disk"]["sorted"]):
3383                     source_file = all_disks[idx].get("source_file")
3384                     if all_disks[idx].get("device", "disk") == "cdrom":
3385                         continue
3386                     if (
3387                         item in changes["disk"]["new"]
3388                         and source_file
3389                         and not os.path.exists(source_file)
3390                     ):
3391                         _qemu_image_create(all_disks[idx])
3392                     elif item in changes["disk"]["new"] and not source_file:
3393                         _disk_volume_create(conn, all_disks[idx])
3394             if not test:
3395                 xml_desc = xmlutil.element_to_str(desc)
3396                 log.debug("Update virtual machine definition: %s", xml_desc)
3397                 conn.defineXML(xml_desc)
3398             status["definition"] = True
3399         except libvirt.libvirtError as err:
3400             conn.close()
3401             raise err
3402     if live:
3403         live_status, errors = _update_live(
3404             domain, new_desc, mem, cpu, old_mem, old_cpu, to_skip, test
3405         )
3406         status.update(live_status)
3407         if errors:
3408             status_errors = status.setdefault("errors", [])
3409             status_errors += errors
3410     conn.close()
3411     return status
3412 def list_domains(**kwargs):
3413     """
3414     Return a list of available domains.
3415     :param connection: libvirt connection URI, overriding defaults
3416         .. versionadded:: 2019.2.0
3417     :param username: username to connect with, overriding defaults
3418         .. versionadded:: 2019.2.0
3419     :param password: password to connect with, overriding defaults
3420         .. versionadded:: 2019.2.0
3421     CLI Example:
3422     .. code-block:: bash
3423         salt '*' virt.list_domains
3424     """
3425     vms = []
3426     conn = __get_conn(**kwargs)
3427     for dom in _get_domain(conn, iterable=True):
3428         vms.append(dom.name())
3429     conn.close()
3430     return vms
3431 def list_active_vms(**kwargs):
3432     """
3433     Return a list of names for active virtual machine on the minion
3434     :param connection: libvirt connection URI, overriding defaults
3435         .. versionadded:: 2019.2.0
3436     :param username: username to connect with, overriding defaults
3437         .. versionadded:: 2019.2.0
3438     :param password: password to connect with, overriding defaults
3439         .. versionadded:: 2019.2.0
3440     CLI Example:
3441     .. code-block:: bash
3442         salt '*' virt.list_active_vms
3443     """
3444     vms = []
3445     conn = __get_conn(**kwargs)
3446     for dom in _get_domain(conn, iterable=True, inactive=False):
3447         vms.append(dom.name())
3448     conn.close()
3449     return vms
3450 def list_inactive_vms(**kwargs):
3451     """
3452     Return a list of names for inactive virtual machine on the minion
3453     :param connection: libvirt connection URI, overriding defaults
3454         .. versionadded:: 2019.2.0
3455     :param username: username to connect with, overriding defaults
3456         .. versionadded:: 2019.2.0
3457     :param password: password to connect with, overriding defaults
3458         .. versionadded:: 2019.2.0
3459     CLI Example:
3460     .. code-block:: bash
3461         salt '*' virt.list_inactive_vms
3462     """
3463     vms = []
3464     conn = __get_conn(**kwargs)
3465     for dom in _get_domain(conn, iterable=True, active=False):
3466         vms.append(dom.name())
3467     conn.close()
3468     return vms
3469 def vm_info(vm_=None, **kwargs):
3470     """
3471     Return detailed information about the vms on this hyper in a
3472     list of dicts:
3473     :param vm_: name of the domain
3474     :param connection: libvirt connection URI, overriding defaults
3475         .. versionadded:: 2019.2.0
3476     :param username: username to connect with, overriding defaults
3477         .. versionadded:: 2019.2.0
3478     :param password: password to connect with, overriding defaults
3479         .. versionadded:: 2019.2.0
3480     .. code-block:: python
3481         [
3482             'your-vm': {
3483                 'cpu': &lt;int&gt;,
3484                 'maxMem': &lt;int&gt;,
3485                 'mem': &lt;int&gt;,
3486                 'state': '&lt;state&gt;',
3487                 'cputime' &lt;int&gt;
3488                 },
3489             ...
3490             ]
3491     If you pass a VM name in as an argument then it will return info
3492     for just the named VM, otherwise it will return all VMs.
3493     CLI Example:
3494     .. code-block:: bash
3495         salt '*' virt.vm_info
3496     """
3497     def _info(conn, dom):
3498         """
3499         Compute the infos of a domain
3500         """
3501         raw = dom.info()
3502         return {
3503             "cpu": raw[3],
3504             "cputime": int(raw[4]),
3505             "disks": _get_disks(conn, dom),
3506             "graphics": _get_graphics(dom),
3507             "nics": _get_nics(dom),
3508             "uuid": _get_uuid(dom),
3509             "loader": _get_loader(dom),
3510             "on_crash": _get_on_crash(dom),
3511             "on_reboot": _get_on_reboot(dom),
3512             "on_poweroff": _get_on_poweroff(dom),
3513             "maxMem": int(raw[1]),
3514             "mem": int(raw[2]),
3515             "state": VIRT_STATE_NAME_MAP.get(raw[0], "unknown"),
3516         }
3517     info = {}
3518     conn = __get_conn(**kwargs)
3519     if vm_:
3520         info[vm_] = _info(conn, _get_domain(conn, vm_))
3521     else:
3522         for domain in _get_domain(conn, iterable=True):
3523             info[domain.name()] = _info(conn, domain)
3524     conn.close()
3525     return info
3526 def vm_state(vm_=None, **kwargs):
3527     """
3528     Return list of all the vms and their state.
3529     If you pass a VM name in as an argument then it will return info
3530     for just the named VM, otherwise it will return all VMs.
3531     :param vm_: name of the domain
3532     :param connection: libvirt connection URI, overriding defaults
3533         .. versionadded:: 2019.2.0
3534     :param username: username to connect with, overriding defaults
3535         .. versionadded:: 2019.2.0
3536     :param password: password to connect with, overriding defaults
3537         .. versionadded:: 2019.2.0
3538     CLI Example:
3539     .. code-block:: bash
3540         salt '*' virt.vm_state &lt;domain&gt;
3541     """
3542     def _info(dom):
3543         """
3544         Compute domain state
3545         """
3546         state = ""
3547         raw = dom.info()
3548         state = VIRT_STATE_NAME_MAP.get(raw[0], "unknown")
3549         return state
3550     info = {}
3551     conn = __get_conn(**kwargs)
3552     if vm_:
3553         info[vm_] = _info(_get_domain(conn, vm_))
3554     else:
3555         for domain in _get_domain(conn, iterable=True):
3556             info[domain.name()] = _info(domain)
3557     conn.close()
3558     return info
3559 def _node_info(conn):
3560     """
3561     Internal variant of node_info taking a libvirt connection as parameter
3562     """
3563     raw = conn.getInfo()
3564     info = {
3565         "cpucores": raw[6],
3566         "cpumhz": raw[3],
3567         "cpumodel": str(raw[0]),
3568         "cpus": raw[2],
3569         "cputhreads": raw[7],
3570         "numanodes": raw[4],
3571         "phymemory": raw[1],
3572         "sockets": raw[5],
3573     }
3574     return info
3575 def node_info(**kwargs):
3576     """
3577     Return a dict with information about this node
3578     :param connection: libvirt connection URI, overriding defaults
3579         .. versionadded:: 2019.2.0
3580     :param username: username to connect with, overriding defaults
3581         .. versionadded:: 2019.2.0
3582     :param password: password to connect with, overriding defaults
3583         .. versionadded:: 2019.2.0
3584     CLI Example:
3585     .. code-block:: bash
3586         salt '*' virt.node_info
3587     """
3588     conn = __get_conn(**kwargs)
3589     info = _node_info(conn)
3590     conn.close()
3591     return info
3592 def _node_devices(conn):
3593     """
3594     List the host available devices, using an established connection.
3595     :param conn: the libvirt connection handle to use.
3596     .. versionadded:: 3003
3597     """
3598     devices = conn.listAllDevices()
3599     devices_infos = []
3600     for dev in devices:
3601         root = ElementTree.fromstring(dev.XMLDesc())
3602         if not set(dev.listCaps()) &amp; {"pci", "usb_device", "net"}:
3603             continue
3604         infos = {
3605             "caps": " ".join(dev.listCaps()),
3606         }
3607         if "net" in dev.listCaps():
3608             if parent == "computer":
3609                 c<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ontinue
3610             infos.update(
3611                 {
3612                     "name": root.find(".//interface").text,
3613                     "address": root.find(".//address").text,
3614                     "device name": parent,
3615                     "state": root.find(".//link").</b></font>get("state"),
3616                 }
3617             )
3618             devices_infos.append(infos)
3619         vendor_node = root.find(".//vendor")
3620         vendor_id = vendor_node<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("id").lower()
3621         product_node = root.find(".//product")
3622         product_id = product_node.get("id").lower(</b></font>)
3623         infos.update(
3624             {"name": dev.name(), "vendor_id": vendor_id, "product_id": product_id}
3625         )
3626         if vendor_node.text:
3627             infos["vendor"] = vendor_node.text
3628         if product_node.text:
3629             infos["product"] = product_node.text
3630         if "pci" in dev.listCaps():
3631             infos["address"] = "{:04x}:{:02x}:{:02x}.{}".format(
3632                 int(root.find(".//domain").text),
3633                 int(root.find(".//bus").text),
3634                 int(root.find(".//slot").text),
3635                 root.find(".//function").text,
3636             )
3637             class_node = root.find(".//class")
3638             if class_node is not None:
3639                 infos["PCI class"] = class_node.text
3640             vf_addresses = [
3641                 _format_pci_address(vf)
3642                 for vf in root.findall(
3643                     "./capability[@type='pci']/capability[@type='virt_functions']/address"
3644                 )
3645             ]
3646             if vf_addresses:
3647                 infos["virtual functions"] = vf_addresses
3648             pf = root.find(
3649                 "./capability[@type='pci']/capability[@type='phys_function']/address"
3650             )
3651             if pf is not None:
3652                 infos["physical function"] = _format_pci_address(pf)
3653         elif "usb_device" in dev.listCaps():
3654             infos["address"] = "{:03}:{:03}".format(
3655                 int(root.find(".//bus").text), int(root.find(".//device").text)
3656             )
3657         linux_usb_host = vendor_id == "0x1d6b" and product_id in [
3658             "0x0001",
3659             "0x0002",
3660             "0x0003",
3661         ]
3662         if (
3663             root.find(".//capability[@type='pci-bridge']") is None
3664             and not linux_usb_host
3665         ):
3666             devices_infos.append(infos)
3667     return devices_infos
3668 def node_devices(**kwargs):
3669     """
3670     List the host available devices.
3671     :param connection: libvirt connection URI, overriding defaults
3672     :param username: username to connect with, overriding defaults
3673     :param password: password to connect with, overriding defaults
3674     .. versionadded:: 3003
3675     """
3676     conn = __get_conn(**kwargs)
3677     devs = _node_devices(conn)
3678     conn.close()
3679     return devs
3680 def get_nics(vm_, **kwargs):
3681     """
3682     Return info about the network interfaces of a named vm
3683     :param vm_: name of the domain
3684     :param connection: libvirt connection URI, overriding defaults
3685         .. versionadded:: 2019.2.0
3686     :param username: username to connect with, overriding defaults
3687         .. versionadded:: 2019.2.0
3688     :param password: password to connect with, overriding defaults
3689         .. versionadded:: 2019.2.0
3690     CLI Example:
3691     .. code-block:: bash
3692         salt '*' virt.get_nics &lt;domain&gt;
3693     """
3694     conn = __get_conn(**kwargs)
3695     nics = _get_nics(_get_domain(conn, vm_))
3696     conn.close()
3697     return nics
3698 def get_macs(vm_, **kwargs):
3699     """
3700     Return a list off MAC addresses from the named vm
3701     :param vm_: name of the domain
3702     :param connection: libvirt connection URI, overriding defaults
3703         .. versionadded:: 2019.2.0
3704     :param username: username to connect with, overriding defaults
3705         .. versionadded:: 2019.2.0
3706     :param password: password to connect with, overriding defaults
3707         .. versionadded:: 2019.2.0
3708     CLI Example:
3709     .. code-block:: bash
3710         salt '*' virt.get_macs &lt;domain&gt;
3711     """
3712     doc = ElementTree.fromstring(get_xml(vm_, **kwargs))
3713     return [node.get("address") for node in doc.findall("devices/interface/mac")]
3714 def get_graphics(vm_, **kwargs):
3715     """
3716     Returns the information on vnc for a given vm
3717     :param vm_: name of the domain
3718     :param connection: libvirt connection URI, overriding defaults
3719         .. versionadded:: 2019.2.0
3720     :param username: username to connect with, overriding defaults
3721         .. versionadded:: 2019.2.0
3722     :param password: password to connect with, overriding defaults
3723         .. versionadded:: 2019.2.0
3724     CLI Example:
3725     .. code-block:: bash
3726         salt '*' virt.get_graphics &lt;domain&gt;
3727     """
3728     conn = __get_conn(**kwargs)
3729     graphics = _get_graphics(_get_domain(conn, vm_))
3730     conn.close()
3731     return graphics
3732 def get_loader(vm_, **kwargs):
3733     """
3734     Returns the information on the loader for a given vm
3735     :param vm_: name of the domain
3736     :param connection: libvirt connection URI, overriding defaults
3737     :param username: username to connect with, overriding defaults
3738     :param password: password to connect with, overriding defaults
3739     CLI Example:
3740     .. code-block:: bash
3741         salt '*' virt.get_loader &lt;domain&gt;
3742     .. versionadded:: 2019.2.0
3743     """
3744     conn = __get_conn(**kwargs)
3745     try:
3746         loader = _get_loader(_get_domain(conn, vm_))
3747         return loader
3748     finally:
3749         conn.close()
3750 def get_disks(vm_, **kwargs):
3751     """
3752     Return the disks of a named vm
3753     :param vm_: name of the domain
3754     :param connection: libvirt connection URI, overriding defaults
3755         .. versionadded:: 2019.2.0
3756     :param username: username to connect with, overriding defaults
3757         .. versionadded:: 2019.2.0
3758     :param password: password to connect with, overriding defaults
3759         .. versionadded:: 2019.2.0
3760     CLI Example:
3761     .. code-block:: bash
3762         salt '*' virt.get_disks &lt;domain&gt;
3763     """
3764     conn = __get_conn(**kwargs)
3765     disks = _get_disks(conn, _get_domain(conn, vm_))
3766     conn.close()
3767     return disks
3768 def setmem(vm_, memory, config=False, **kwargs):
3769     """
3770     Changes the amount of memory allocated to VM. The VM must be shutdown
3771     for this to work.
3772     :param vm_: name of the domain
3773     :param memory: memory amount to set in MB
3774     :param config: if True then libvirt will be asked to modify the config as well
3775     :param connection: libvirt connection URI, overriding defaults
3776         .. versionadded:: 2019.2.0
3777     :param username: username to connect with, overriding defaults
3778         .. versionadded:: 2019.2.0
3779     :param password: password to connect with, overriding defaults
3780         .. versionadded:: 2019.2.0
3781     CLI Example:
3782     .. code-block:: bash
3783         salt '*' virt.setmem &lt;domain&gt; &lt;size&gt;
3784         salt '*' virt.setmem my_domain 768
3785     """
3786     conn = __get_conn(**kwargs)
3787     dom = _get_domain(conn, vm_)
3788     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
3789         return False
3790     flags = libvirt.VIR_DOMAIN_MEM_MAXIMUM
3791     if config:
3792         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
3793     ret1 = dom.setMemoryFlags(memory * 1024, flags)
3794     ret2 = dom.setMemoryFlags(memory * 1024, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
3795     conn.close()
3796     return ret1 == ret2 == 0
3797 def setvcpus(vm_, vcpus, config=False, **kwargs):
3798     """
3799     Changes the amount of vcpus allocated to VM. The VM must be shutdown
3800     for this to work.
3801     If config is True then we ask libvirt to modify the config as well
3802     :param vm_: name of the domain
3803     :param vcpus: integer representing the number of CPUs to be assigned
3804     :param config: if True then libvirt will be asked to modify the config as well
3805     :param connection: libvirt connection URI, overriding defaults
3806         .. versionadded:: 2019.2.0
3807     :param username: username to connect with, overriding defaults
3808         .. versionadded:: 2019.2.0
3809     :param password: password to connect with, overriding defaults
3810         .. versionadded:: 2019.2.0
3811     CLI Example:
3812     .. code-block:: bash
3813         salt '*' virt.setvcpus &lt;domain&gt; &lt;amount&gt;
3814         salt '*' virt.setvcpus my_domain 4
3815     """
3816     conn = __get_conn(**kwargs)
3817     dom = _get_domain(conn, vm_)
3818     if VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown":
3819         return False
3820     flags = libvirt.VIR_DOMAIN_VCPU_MAXIMUM
3821     if config:
3822         flags = flags | libvirt.VIR_DOMAIN_AFFECT_CONFIG
3823     ret1 = dom.setVcpusFlags(vcpus, flags)
3824     ret2 = dom.setVcpusFlags(vcpus, libvirt.VIR_DOMAIN_AFFECT_CURRENT)
3825     conn.close()
3826     return ret1 == ret2 == 0
3827 def _freemem(conn):
3828     """
3829     Internal variant of freemem taking a libvirt connection as parameter
3830     """
3831     mem = conn.getInfo()[1]
3832     mem -= 256
3833     for dom in _get_domain(conn, iterable=True):
3834         if dom<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.ID() &gt; 0:
3835             mem -= dom.info()[2] / 1024
3836     return mem
3837 def freemem(**kwargs):
3838     """
3839     Return an int representing the amount of memory (in MB) that has not
3840     been given to virtual machines on this node
3841     :param connection: libvirt connection URI, overriding defaults
3842         .. versionadded:: 2019.2.0
3843     :param username: username to connect with, overriding defaults
3844         .. versionadded:: 2019.2.0
3845     :param password: password to connect with, overriding defaults
3846         .. versionadded:: 2019.2.0
3847     CLI Example:
3848     .. code-block:: bash
3849         salt '*' virt.freemem
3850     """
3851     conn =</b></font> __get_conn(**kwargs)
3852     mem = _freemem(conn)
3853     conn.close()
3854     return mem
3855 def _freecpu(conn):
3856     """
3857     Internal variant of freecpu taking a libvirt connection as parameter
3858     """
3859     cpus = conn.getInfo()[2]
3860     for dom in _get_domain(conn, iterable=True):
3861         if dom.ID() &gt; 0:
3862             cpus -= dom.info()[3]
3863     return cpus
3864 def freecpu(**kwargs):
3865     """
3866     Return an int representing the number of unallocated cpus on this
3867     hypervisor
3868     :param connection: libvirt connection URI, overriding defaults
3869         .. versionadded:: 2019.2.0
3870     :param username: username to connect with, overriding defaults
3871         .. versionadded:: 2019.2.0
3872     :param password: password to connect with, overriding defaults
3873         .. versionadded:: 2019.2.0
3874     CLI Example:
3875     .. code-block:: bash
3876         salt '*' virt.freecpu
3877     """
3878     conn = __get_conn(**kwargs)
3879     cpus = _freecpu(conn)
3880     conn.close()
3881     return cpus
3882 def full_info(**kwargs):
3883     """
3884     Return the node_info, vm_info and freemem
3885     :param connection: libvirt connection URI, overriding defaults
3886         .. versionadded:: 2019.2.0
3887     :param username: username to connect with, overriding defaults
3888         .. versionadded:: 2019.2.0
3889     :param password: password to connect with, overriding defaults
3890         .. versionadded:: 2019.2.0
3891     CLI Example:
3892     .. code-block:: bash
3893         salt '*' virt.full_info
3894     """
3895     conn = __get_conn(**kwargs)
3896     info = {
3897         "freecpu": _freecpu(conn),
3898         "freemem": _freemem(conn),
3899         "node_info": _node_info(conn),
3900         "vm_info": vm_info(),
3901     }
3902     conn.close()
3903     return info
3904 def get_xml(vm_, **kwargs):
3905     """
3906     Returns the XML for a given vm
3907     :param vm_: domain name
3908     :param connection: libvirt connection URI, overriding defaults
3909         .. versionadded:: 2019.2.0
3910     :param username: username to connect with, overriding defaults
3911         .. versionadded:: 2019.2.0
3912     :param password: password to connect with, overriding defaults
3913         .. versionadded:: 2019.2.0
3914     CLI Example:
3915     .. code-block:: bash
3916         salt '*' virt.get_xml &lt;domain&gt;
3917     """
3918     conn = __get_conn(**kwargs)
3919     xml_desc = (
3920         vm_.XMLDesc(0)
3921         if isinstance(vm_, libvirt.virDomain)
3922         else _get_domain(conn, vm_).XMLDesc(0)
3923     )
3924     conn.close()
3925     return xml_desc
3926 def get_profiles(hypervisor=None, **kwargs):
3927     """
3928     Return the virt profiles for hypervisor.
3929     Currently there are profiles for:
3930     - nic
3931     - disk
3932     :param hypervisor: override the default machine type.
3933     :param connection: libvirt connection URI, overriding defaults
3934         .. versionadded:: 2019.2.0
3935     :param username: username to connect with, overriding defaults
3936         .. versionadded:: 2019.2.0
3937     :param password: password to connect with, overriding defaults
3938         .. versionadded:: 2019.2.0
3939     CLI Example:
3940     .. code-block:: bash
3941         salt '*' virt.get_profiles
3942         salt '*' virt.get_profiles hypervisor=vmware
3943     """
3944     conn = __get_conn(**kwargs)
3945     caps = _capabilities(conn)
3946     hypervisors = sorted(
3947         {
3948             x
3949             for y in [guest["arch"]["domains"].keys() for guest in caps["guests"]]
3950             for x in y
3951         }
3952     )
3953     if len(hypervisors) == 0:
3954         raise SaltInvocationError("No supported hypervisors were found")
3955     if not hypervisor:
3956         hypervisor = "kvm" if "kvm" in hypervisors else hypervisors[0]
3957     ret = {
3958         "disk": {"default": _disk_profile(conn, "default", hypervisor, [], None)},
3959         "nic": {"default": _nic_profile("default", hypervisor)},
3960     }
3961     virtconf = __salt__["config.get"]("virt", {})
3962     for profile in virtconf.get("disk", []):
3963         ret["disk"][profile] = _disk_profile(conn, profile, hypervisor, [], None)
3964     for profile in virtconf.get("nic", []):
3965         ret["nic"][profile] = _nic_profile(profile, hypervisor)
3966     return ret
3967 def shutdown(vm_, **kwargs):
3968     """
3969     Send a soft shutdown signal to the named vm
3970     :param vm_: domain name
3971     :param connection: libvirt connection URI, overriding defaults
3972         .. versionadded:: 2019.2.0
3973     :param username: username to connect with, overriding defaults
3974         .. versionadded:: 2019.2.0
3975     :param password: password to connect with, overriding defaults
3976         .. versionadded:: 2019.2.0
3977     CLI Example:
3978     .. code-block:: bash
3979         salt '*' virt.shutdown &lt;domain&gt;
3980     """
3981     conn = __get_conn(**kwargs)
3982     dom = _get_domain(conn, vm_)
3983     ret = dom.shutdown() == 0
3984     conn.close()
3985     return ret
3986 def pause(vm_, **kwargs):
3987     """
3988     Pause the named vm
3989     :param vm_: domain name
3990     :param connection: libvirt connection URI, overriding defaults
3991         .. versionadded:: 2019.2.0
3992     :param username: username to connect with, overriding defaults
3993         .. versionadded:: 2019.2.0
3994     :param password: password to connect with, overriding defaults
3995         .. versionadded:: 2019.2.0
3996     CLI Example:
3997     .. code-block:: bash
3998         salt '*' virt.pause &lt;domain&gt;
3999     """
4000     conn = __get_conn(**kwargs)
4001     dom = _get_domain(conn, vm_)
4002     ret = dom.suspend() == 0
4003     conn.close()
4004     return ret
4005 def resume(vm_, **kwargs):
4006     """
4007     Resume the named vm
4008     :param vm_: domain name
4009     :param connection: libvirt connection URI, overriding defaults
4010         .. versionadded:: 2019.2.0
4011     :param username: username to connect with, overriding defaults
4012         .. versionadded:: 2019.2.0
4013     :param password: password to connect with, overriding defaults
4014         .. versionadded:: 2019.2.0
4015     CLI Example:
4016     .. code-block:: bash
4017         salt '*' virt.resume &lt;domain&gt;
4018     """
4019     conn = __get_conn(**kwargs)
4020     dom = _get_domain(conn, vm_)
4021     ret = dom.resume() == 0
4022     conn.close()
4023     return ret
4024 def start(name, **kwargs):
4025     """
4026     Start a defined domain
4027     :param vm_: domain name
4028     :param connection: libvirt connection URI, overriding defaults
4029         .. versionadded:: 2019.2.0
4030     :param username: username to connect with, overriding defaults
4031         .. versionadded:: 2019.2.0
4032     :param password: password to connect with, overriding defaults
4033         .. versionadded:: 2019.2.0
4034     CLI Example:
4035     .. code-block:: bash
4036         salt '*' virt.start &lt;domain&gt;
4037     """
4038     conn = __get_conn(**kwargs)
4039     ret = _get_domain(conn, name).create() == 0
4040     conn.close()
4041     return ret
4042 def stop(name, **kwargs):
4043     """
4044     Hard power down the virtual machine, this is equivalent to pulling the power.
4045     :param vm_: domain name
4046     :param connection: libvirt connection URI, overriding defaults
4047         .. versionadded:: 2019.2.0
4048     :param username: username to connect with, overriding defaults
4049         .. versionadded:: 2019.2.0
4050     :param password: password to connect with, overriding defaults
4051         .. versionadded:: 2019.2.0
4052     CLI Example:
4053     .. code-block:: bash
4054         salt '*' virt.stop &lt;domain&gt;
4055     """
4056     conn = __get_conn(**kwargs)
4057     ret = _get_domain(conn, name).destroy() == 0
4058     conn.close()
4059     return ret
4060 def reboot(name, **kwargs):
4061     """
4062     Reboot a domain via ACPI request
4063     :param vm_: domain name
4064     :param connection: libvirt connection URI, overriding defaults
4065         .. versionadded:: 2019.2.0
4066     :param username: username to connect with, overriding defaults
4067         .. versionadded:: 2019.2.0
4068     :param password: password to connect with, overriding defaults
4069         .. versionadded:: 2019.2.0
4070     CLI Example:
4071     .. code-block:: bash
4072         salt '*' virt.reboot &lt;domain&gt;
4073     """
4074     conn = __get_conn(**kwargs)
4075     ret = _get_domain(conn, name).reboot(libvirt.VIR_DOMAIN_REBOOT_DEFAULT) == 0
4076     conn.close()
4077     return ret
4078 def reset(vm_, **kwargs):
4079     """
4080     Reset a VM by emulating the reset button on a physical machine
4081     :param vm_: domain name
4082     :param connection: libvirt connection URI, overriding defaults
4083         .. versionadded:: 2019.2.0
4084     :param username: username to connect with, overriding defaults
4085         .. versionadded:: 2019.2.0
4086     :param password: password to connect with, overriding defaults
4087         .. versionadded:: 2019.2.0
4088     CLI Example:
4089     .. code-block:: bash
4090         salt '*' virt.reset &lt;domain&gt;
4091     """
4092     conn = __get_conn(**kwargs)
4093     dom = _get_domain(conn, vm_)
4094     ret = dom.reset(0) == 0
4095     conn.close()
4096     return ret
4097 def ctrl_alt_del(vm_, **kwargs):
4098     """
4099     Sends CTRL+ALT+DEL to a VM
4100     :param vm_: domain name
4101     :param connection: libvirt connection URI, overriding defaults
4102         .. versionadded:: 2019.2.0
4103     :param username: username to connect with, overriding defaults
4104         .. versionadded:: 2019.2.0
4105     :param password: password to connect with, overriding defaults
4106         .. versionadded:: 2019.2.0
4107     CLI Example:
4108     .. code-block:: bash
4109         salt '*' virt.ctrl_alt_del &lt;domain&gt;
4110     """
4111     conn = __get_conn(**kwargs)
4112     dom = _get_domain(conn, vm_)
4113     ret = dom.sendKey(0, 0, [29, 56, 111], 3, 0) == 0
4114     conn.close()
4115     return ret
4116 def create_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
4117     """
4118     Start a transient domain based on the XML passed to the function
4119     :param xml: libvirt XML definition of the domain
4120     :param connection: libvirt connection URI, overriding defaults
4121         .. versionadded:: 2019.2.0
4122     :param username: username to connect with, overriding defaults
4123         .. versionadded:: 2019.2.0
4124     :param password: password to connect with, overriding defaults
4125         .. versionadded:: 2019.2.0
4126     CLI Example:
4127     .. code-block:: bash
4128         salt '*' virt.create_xml_str &lt;XML in string format&gt;
4129     """
4130     conn = __get_conn(**kwargs)
4131     ret = conn.createXML(xml, 0) is not None
4132     conn.close()
4133     return ret
4134 def create_xml_path(path, **kwargs):
4135     """
4136     Start a transient domain based on the XML-file path passed to the function
4137     :param path: path to a file containing the libvirt XML definition of the domain
4138     :param connection: libvirt connection URI, overriding defaults
4139         .. versionadded:: 2019.2.0
4140     :param username: username to connect with, overriding defaults
4141         .. versionadded:: 2019.2.0
4142     :param password: password to connect with, overriding defaults
4143         .. versionadded:: 2019.2.0
4144     CLI Example:
4145     .. code-block:: bash
4146         salt '*' virt.create_xml_path &lt;path to XML file on the node&gt;
4147     """
4148     try:
4149         with salt.utils.files.fopen(path, "r") as fp_:
4150             return create_xml_str(
4151                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
4152             )
4153     except OSError:
4154         return False
4155 def define_xml_str(xml, **kwargs):  # pylint: disable=redefined-outer-name
4156     """
4157     Define a persistent domain based on the XML passed to the function
4158     :param xml: libvirt XML definition of the domain
4159     :param connection: libvirt connection URI, overriding defaults
4160         .. versionadded:: 2019.2.0
4161     :param username: username to connect with, overriding defaults
4162         .. versionadded:: 2019.2.0
4163     :param password: password to connect with, overriding defaults
4164         .. versionadded:: 2019.2.0
4165     CLI Example:
4166     .. code-block:: bash
4167         salt '*' virt.define_xml_str &lt;XML in string format&gt;
4168     """
4169     conn = __get_conn(**kwargs)
4170     ret = conn.defineXML(xml) is not None
4171     conn.close()
4172     return ret
4173 def define_xml_path(path, **kwargs):
4174     """
4175     Define a persistent domain based on the XML-file path passed to the function
4176     :param path: path to a file containing the libvirt XML definition of the domain
4177     :param connection: libvirt connection URI, overriding defaults
4178         .. versionadded:: 2019.2.0
4179     :param username: username to connect with, overriding defaults
4180         .. versionadded:: 2019.2.0
4181     :param password: password to connect with, overriding defaults
4182         .. versionadded:: 2019.2.0
4183     CLI Example:
4184     .. code-block:: bash
4185         salt '*' virt.define_xml_path &lt;path to XML file on the node&gt;
4186     """
4187     try:
4188         with salt.utils.files.fopen(path, "r") as fp_:
4189             return define_xml_str(
4190                 salt.utils.stringutils.to_unicode(fp_.read()), **kwargs
4191             )
4192     except OSError:
4193         return False
4194 def _define_vol_xml_str(conn, xml, pool=None):  # pylint: disable=redefined-outer-name
4195     """
4196     Same function than define_vml_xml_str but using an already opened libvirt connection
4197     """
4198     default_pool = "default" if conn.getType() != "ESX" else "0"
4199     poolname = (
4200         pool if pool else __salt__["config.get"]("virt:storagepool", default_pool)
4201     )
4202     pool = conn.storagePoolLookupByName(str(poolname))
4203     ret = pool.createXML(xml, 0) is not None
4204     return ret
4205 def define_vol_xml_str(
4206     xml, pool=None, **kwargs
4207 ):  # pylint: disable=redefined-outer-name
4208     """
4209     Define a volume based on the XML passed to the function
4210     :param xml: libvirt XML definition of the storage volume
4211     :param pool:
4212         storage pool name to define the volume in.
4213         If defined, this parameter will override the configuration setting.
4214         .. versionadded:: 3001
4215     :param connection: libvirt connection URI, overriding defaults
4216         .. versionadded:: 2019.2.0
4217     :param username: username to connect with, overriding defaults
4218         .. versionadded:: 2019.2.0
4219     :param password: password to connect with, overriding defaults
4220         .. versionadded:: 2019.2.0
4221     CLI Example:
4222     .. code-block:: bash
4223         salt '*' virt.define_vol_xml_str &lt;XML in string format&gt;
4224     The storage pool where the disk image will be defined is ``default``
4225     unless changed with the pool parameter or a configuration like this:
4226     .. code-block:: yaml
4227         virt:
4228             storagepool: mine
4229     """
4230     conn = __get_conn(**kwargs)
4231     ret = False
4232     try:
4233         ret = _define_vol_xml_str(conn, xml, pool=pool)
4234     except libvirtError as err:
4235         raise CommandExecutionError(err.get_error_message())
4236     finally:
4237         conn.close()
4238     return ret
4239 def define_vol_xml_path(path, pool=None, **kwargs):
4240     """
4241     Define a volume based on the XML-file path passed to the function
4242     :param path: path to a file containing the libvirt XML definition of the volume
4243     :param pool:
4244         storage pool name to define the volume in.
4245         If defined, this parameter will override the configuration setting.
4246         .. versionadded:: 3001
4247     :param connection: libvirt connection URI, overriding defaults
4248         .. versionadded:: 2019.2.0
4249     :param username: username to connect with, overriding defaults
4250         .. versionadded:: 2019.2.0
4251     :param password: password to connect with, overriding defaults
4252         .. versionadded:: 2019.2.0
4253     CLI Example:
4254     .. code-block:: bash
4255         salt '*' virt.define_vol_xml_path &lt;path to XML file on the node&gt;
4256     """
4257     try:
4258         with salt.utils.files.fopen(path, "r") as fp_:
4259             return define_vol_xml_str(
4260                 salt.utils.stringutils.to_unicode(fp_.read()), pool=pool, **kwargs
4261             )
4262     except OSError:
4263         return False
4264 def migrate(vm_, target, **kwargs):
4265     """
4266     Shared storage migration
4267     :param vm_: domain name
4268     :param target: target libvirt URI or host name
4269     :param kwargs:
4270         - live:            Use live migration. Default value is True.
4271         - persistent:      Leave the domain persistent on destination host.
4272                            Default value is True.
4273         - undefinesource:  Undefine the domain on the source host.
4274                            Default value is True.
4275         - offline:         If set to True it will migrate the domain definition
4276                            without starting the domain on destination and without
4277                            stopping it on source host. Default value is False.
4278         - max_bandwidth:   The maximum bandwidth (in MiB/s) that will be used.
4279         - max_downtime:    Set maximum tolerable downtime for live-migration.
4280                            The value represents a number of milliseconds the guest
4281                            is allowed to be down at the end of live migration.
4282         - parallel_connections: Specify a number of parallel network connections
4283                            to be used to send memory pages to the destination host.
4284         - compressed:      Activate compression.
4285         - comp_methods:    A comma-separated list of compression methods. Supported
4286                            methods are "mt" and "xbzrle" and can be  used in any
4287                            combination. QEMU defaults to "xbzrle".
4288         - comp_mt_level:   Set compression level. Values are in range from 0 to 9,
4289                            where 1 is maximum speed and 9 is  maximum compression.
4290         - comp_mt_threads: Set number of compress threads on source host.
4291         - comp_mt_dthreads: Set number of decompress threads on target host.
4292         - comp_xbzrle_cache: Set the size of page cache for xbzrle compression in bytes.
4293         - copy_storage:    Migrate non-shared storage. It must be one of the following
4294                            values: all (full disk copy) or incremental (Incremental copy)
4295         - postcopy:        Enable the use of post-copy migration.
4296         - postcopy_bandwidth: The maximum bandwidth allowed in post-copy phase. (MiB/s)
4297         - username:        Username to connect with target host
4298         - password:        Password to connect with target host
4299         .. versionadded:: 3002
4300     CLI Example:
4301     .. code-block:: bash
4302         salt '*' virt.migrate &lt;domain&gt; &lt;target hypervisor URI&gt;
4303         salt src virt.migrate guest qemu+ssh://dst/system
4304         salt src virt.migrate guest qemu+tls://dst/system
4305         salt src virt.migrate guest qemu+tcp://dst/system
4306     A tunnel data migration can be performed by setting this in the
4307     configuration:
4308     .. code-block:: yaml
4309         virt:
4310             tunnel: True
4311     For more details on tunnelled data migrations, report to
4312     https://libvirt.org/migration.html#transporttunnel
4313     """
4314     conn = __get_conn()
4315     dom = _get_domain(conn, vm_)
4316     if not urllib.parse.urlparse(target).scheme:
4317         proto = "qemu"
4318         dst_uri = "{}://{}/system".format(proto, target)
4319     else:
4320         dst_uri = target
4321     ret = _migrate(dom, dst_uri, **kwargs)
4322     conn.close()
4323     return ret
4324 def migrate_start_postcopy(vm_):
4325     """
4326     Starts post-copy migration. This function has to be called
4327     while live migration is in progress and it has been initiated
4328     with the `postcopy=True` option.
4329     CLI Example:
4330     .. code-block:: bash
4331         salt '*' virt.migrate_start_postcopy &lt;domain&gt;
4332     """
4333     conn = __get_conn()
4334     dom = _get_domain(conn, vm_)
4335     try:
4336         dom.migrateStartPostCopy()
4337     except libvirt.libvirtError as err:
4338         conn.close()
4339         raise CommandExecutionError(err.get_error_message())
4340     conn.close()
4341 def seed_non_shared_migrate(disks, force=False):
4342     """
4343     Non shared migration requires that the disks be present on the migration
4344     destination, pass the disks information via this function, to the
4345     migration destination before executing the migration.
4346     :param disks: the list of disk data as provided by virt.get_disks
4347     :param force: skip checking the compatibility of source and target disk
4348                   images if True. (default: False)
4349     CLI Example:
4350     .. code-block:: bash
4351         salt '*' virt.seed_non_shared_migrate &lt;disks&gt;
4352     """
4353     for _, data in disks.items():
4354         fn_ = data["file"]
4355         form = data["file format"]
4356         size = data["virtual size"].split()[1][1:]
4357         if os.path.isfile(fn_) and not force:
4358             pre = salt.utils.yaml.safe_load(
4359                 subprocess.Popen(
4360                     ["qemu-img", "info", "arch"], stdout=subprocess.PIPE
4361                 ).communicate()[0]
4362             )
4363             if (
4364                 pre["file format"] != data["file format"]
4365             ):
4366                 return False
4367         if not os.path<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.isdir(os.path.dirname(fn_)):
4368             os.makedirs(os.path.dirname(fn_))
4369         if</b></font> os.path.isfile(fn_):
4370             os.remove(fn_)
4371         subprocess.call(["qemu-img", "create", "-f", form, fn_, size])
4372         creds = _libvirt_creds()
4373         subprocess.call(["chown", "{user}:{group}".format(**creds), fn_])
4374     return True
4375 def set_autostart(vm_, state="on", **kwargs):
4376     """
4377     Set the autostart flag on a VM so that the VM will start with the host
4378     system on reboot.
4379     :param vm_: domain name
4380     :param state: 'on' to auto start the pool, anything else to mark the
4381                   pool not to be started when the host boots
4382     :param connection: libvirt connection URI, overriding defaults
4383         .. versionadded:: 2019.2.0
4384     :param username: username to connect with, overriding defaults
4385         .. versionadded:: 2019.2.0
4386     :param password: password to connect with, overriding defaults
4387         .. versionadded:: 2019.2.0
4388     CLI Example:
4389     .. code-block:: bash
4390         salt "*" virt.set_autostart &lt;domain&gt; &lt;on | off&gt;
4391     """
4392     conn = __get_conn(**kwargs)
4393     dom = _get_domain(conn, vm_)
4394     ret = False
4395     if state == "on":
4396         ret = dom.setAutostart(1) == 0
4397     elif state == "off":
4398         ret = dom.setAutostart(0) == 0
4399     conn.close()
4400     return ret
4401 def undefine(vm_, **kwargs):
4402     """
4403     Remove a defined vm, this does not purge the virtual machine image, and
4404     this only works if the vm is powered down
4405     :param vm_: domain name
4406     :param connection: libvirt connection URI, overriding defaults
4407         .. versionadded:: 2019.2.0
4408     :param username: username to connect with, overriding defaults
4409         .. versionadded:: 2019.2.0
4410     :param password: password to connect with, overriding defaults
4411         .. versionadded:: 2019.2.0
4412     CLI Example:
4413     .. code-block:: bash
4414         salt '*' virt.undefine &lt;domain&gt;
4415     """
4416     conn = __get_conn(**kwargs)
4417     dom = _get_domain(conn, vm_)
4418     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
4419         ret = dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM) == 0
4420     else:
4421         ret = dom.undefine() == 0
4422     conn.close()
4423     return ret
4424 def purge(vm_, dirs=False, removables=False, **kwargs):
4425     """
4426     Recursively destroy and delete a persistent virtual machine, pass True for
4427     dir's to also delete the directories containing the virtual machine disk
4428     images - USE WITH EXTREME CAUTION!
4429     :param vm_: domain name
4430     :param dirs: pass True to remove containing directories
4431     :param removables: pass True to remove removable devices
4432         .. versionadded:: 2019.2.0
4433     :param connection: libvirt connection URI, overriding defaults
4434         .. versionadded:: 2019.2.0
4435     :param username: username to connect with, overriding defaults
4436         .. versionadded:: 2019.2.0
4437     :param password: password to connect with, overriding defaults
4438         .. versionadded:: 2019.2.0
4439     CLI Example:
4440     .. code-block:: bash
4441         salt '*' virt.purge &lt;domain&gt;
4442     """
4443     conn = __get_conn(**kwargs)
4444     dom = _get_domain(conn, vm_)
4445     disks = _get_disks(conn, dom)
4446     if (
4447         VIRT_STATE_NAME_MAP.get(dom.info()[0], "unknown") != "shutdown"
4448         and dom.destroy() != 0
4449     ):
4450         return False
4451     directories = set()
4452     for disk in disks:
4453         if not removables and disks[disk]["type"] in ["cdrom", "floppy"]:
4454             continue
4455         if disks[disk].get("zfs", False):
4456             time.sleep(3)
4457             fs_name = disks[disk]["file"][len("/dev/zvol/") :]
4458             log.info("Destroying VM ZFS volume %s", fs_name)
4459             __salt__["zfs.destroy"](name=fs_name, force=True)
4460         elif os.path.exists(disks[disk]["file"]):
4461             os.remove(disks[disk]["file"])
4462             directories.add(os.path.dirname(disks[disk]["file"]))
4463         else:
4464             matcher = re.match("^(?P&lt;pool&gt;[^/]+)/(?P&lt;volume&gt;.*)$", disks[disk]["file"])
4465             if matcher:
4466                 pool_name = matcher.group("pool")
4467                 pool = None
4468                 if pool_name in conn.listStoragePools():
4469                     pool = conn.storagePoolLookupByName(pool_name)
4470                 if pool and matcher.group("volume") in pool.listVolumes():
4471                     volume = pool.storageVolLookupByName(matcher.group("volume"))
4472                     volume.delete()
4473     if dirs:
4474         for dir_ in directories:
4475             shutil.rmtree(dir_)
4476     if getattr(libvirt, "VIR_DOMAIN_UNDEFINE_NVRAM", False):
4477         try:
4478             dom.undefineFlags(libvirt.VIR_DOMAIN_UNDEFINE_NVRAM)
4479         except Exception:  # pylint: disable=broad-except
4480             dom.undefine()
4481     else:
4482         dom.undefine()
4483     conn.close()
4484     return True
4485 def virt_type():
4486     """
4487     Returns the virtual machine type as a string
4488     CLI Example:
4489     .. code-block:: bash
4490         salt '*' virt.virt_type
4491     """
4492     return __grains__["virtual"]
4493 def _is_kvm_hyper():
4494     """
4495     Returns a bool whether or not this node is a KVM hypervisor
4496     """
4497     if not os.path.exists("/dev/kvm"):
4498         return False
4499     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
4500 def _is_xen_hyper():
4501     """
4502     Returns a bool whether or not this node is a XEN hypervisor
4503     """
4504     try:
4505         if __grains__["virtual_subtype"] != "Xen Dom0":
4506             return False
4507     except KeyError:
4508         return False
4509     try:
4510         with salt.utils.files.fopen("/proc/modules") as fp_:
4511             if "xen_" not in salt.utils.stringutils.to_unicode(fp_.read()):
4512                 return False
4513     except OSError:
4514         return False
4515     return "libvirtd" in __salt__["cmd.run"](__grains__["ps"])
4516 def get_hypervisor():
4517     """
4518     Returns the name of the hypervisor running on this node or ``None``.
4519     Detected hypervisors:
4520     - kvm
4521     - xen
4522     - bhyve
4523     CLI Example:
4524     .. code-block:: bash
4525         salt '*' virt.get_hypervisor
4526     .. versionadded:: 2019.2.0
4527         the function and the ``kvm``, ``xen`` and ``bhyve`` hypervisors support
4528     """
4529     hypervisors = ["kvm", "xen", "bhyve"]
4530     result = [
4531         hyper
4532         for hyper in hypervisors
4533         if getattr(sys.modules[__name__], "_is_{}_hyper".format(hyper))()
4534     ]
4535     return result[0] if result else None
4536 def _is_bhyve_hyper():
4537     sysctl_cmd = "sysctl hw.vmm.create"
4538     vmm_enabled = False
4539     try:
4540         stdout = subprocess.Popen(
4541             ["sysctl", "hw.vmm.create"], stdout=subprocess.PIPE
4542         ).communicate()[0]
4543         vmm_enabled = len(salt.utils.stringutils.to_str(stdout).split('"')[1]) != 0
4544     except IndexError:
4545         pass
4546     return vmm_enabled
4547 def is_hyper():
4548     """
4549     Returns a bool whether or not this node is a hypervisor of any kind
4550     CLI Example:
4551     .. code-block:: bash
4552         salt '*' virt.is_hyper
4553     """
4554     if HAS_LIBVIRT:
4555         return _is_xen_hyper() or _is_kvm_hyper() or _is_bhyve_hyper()
4556     return False
4557 def vm_cputime(vm_=None, **kwargs):
4558     """
4559     Return cputime used by the vms on this hyper in a
4560     list of dicts:
4561     :param vm_: domain name
4562     :param connection: libvirt connection URI, overriding defaults
4563         .. versionadded:: 2019.2.0
4564     :param username: username to connect with, overriding defaults
4565         .. versionadded:: 2019.2.0
4566     :param password: password to connect with, overriding defaults
4567         .. versionadded:: 2019.2.0
4568     .. code-block:: python
4569         [
4570             'your-vm': {
4571                 'cputime' &lt;int&gt;
4572                 'cputime_percent' &lt;int&gt;
4573                 },
4574             ...
4575             ]
4576     If you pass a VM name in as an argument then it will return info
4577     for just the named VM, otherwise it will return all VMs.
4578     CLI Example:
4579     .. code-block:: bash
4580         salt '*' virt.vm_cputime
4581     """
4582     conn = __get_conn(**kwargs)
4583     host_cpus = conn.getInfo()[2]
4584     def _info(dom):
4585         """
4586         Compute cputime info of a domain
4587         """
4588         raw = dom.info()
4589         vcpus = int(raw[3])
4590         cputime = int(raw[4])
4591         cputime_percent = 0
4592         if cputime:
4593             cputime_percent = (1.0e-7 * cputime / host_cpus) / vcpus
4594         return {
4595             "cputime": int(raw[4]),
4596             "cputime_percent": int("{:.0f}".format(cputime_percent)),
4597         }
4598     info = {}
4599     if vm_:
4600         info[vm_] = _info(_get_domain(conn, vm_))
4601     else:
4602         for domain in _get_domain(conn, iterable=True):
4603             info[domain.name()] = _info(domain)
4604     conn.close()
4605     return info
4606 def vm_netstats(vm_=None, **kwargs):
4607     """
4608     Return combined network counters used by the vms on this hyper in a
4609     list of dicts:
4610     :param vm_: domain name
4611     :param connection: libvirt connection URI, overriding defaults
4612         .. versionadded:: 2019.2.0
4613     :param username: username to connect with, overriding defaults
4614         .. versionadded:: 2019.2.0
4615     :param password: password to connect with, overriding defaults
4616         .. versionadded:: 2019.2.0
4617     .. code-block:: python
4618         [
4619             'your-vm': {
4620                 'rx_bytes'   : 0,
4621                 'rx_packets' : 0,
4622                 'rx_errs'    : 0,
4623                 'rx_drop'    : 0,
4624                 'tx_bytes'   : 0,
4625                 'tx_packets' : 0,
4626                 'tx_errs'    : 0,
4627                 'tx_drop'    : 0
4628                 },
4629             ...
4630             ]
4631     If you pass a VM name in as an argument then it will return info
4632     for just the named VM, otherwise it will return all VMs.
4633     CLI Example:
4634     .. code-block:: bash
4635         salt '*' virt.vm_netstats
4636     """
4637     def _info(dom):
4638         """
4639         Compute network stats of a domain
4640         """
4641         nics = _get_nics(dom)
4642         ret = {
4643             "rx_bytes": 0,
4644             "rx_packets": 0,
4645             "rx_errs": 0,
4646             "rx_drop": 0,
4647             "tx_bytes": 0,
4648             "tx_packets": 0,
4649             "tx_errs": 0,
4650             "tx_drop": 0,
4651         }
4652         for attrs in nics.values():
4653                 dev = attrs["target"]
4654                 stats = dom.interfaceStats(dev)
4655                 ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["rx_bytes"] += stats[0]
4656                 ret["rx_packets"] += stats[1]
4657                 ret["rx_errs"] += stats[2]
4658                 ret["rx_drop"] += stats[3]
4659                 ret["tx_bytes"] += stats[4]
4660                 ret["tx_packets"] += stats[5]
4661                 ret["tx_errs"] += stats[6]
4662                 ret["tx_drop"] += stats[</b></font>7]
4663         return ret
4664     info = {}
4665     conn = __get_conn(**kwargs)
4666     if vm_:
4667         info[vm_] = _info(_get_domain(conn, vm_))
4668     else:
4669         for domain in _get_domain(conn, iterable=True):
4670             info[domain.name()] = _info(domain)
4671     conn.close()
4672     return info
4673 def vm_diskstats(vm_=None, **kwargs):
4674     """
4675     Return disk usage counters used by the vms on this hyper in a
4676     list of dicts:
4677     :param vm_: domain name
4678     :param connection: libvirt connection URI, overriding defaults
4679         .. versionadded:: 2019.2.0
4680     :param username: username to connect with, overriding defaults
4681         .. versionadded:: 2019.2.0
4682     :param password: password to connect with, overriding defaults
4683         .. versionadded:: 2019.2.0
4684     .. code-block:: python
4685         [
4686             'your-vm': {
4687                 'rd_req'   : 0,
4688                 'rd_bytes' : 0,
4689                 'wr_req'   : 0,
4690                 'wr_bytes' : 0,
4691                 'errs'     : 0
4692                 },
4693             ...
4694             ]
4695     If you pass a VM name in as an argument then it will return info
4696     for just the named VM, otherwise it will return all VMs.
4697     CLI Example:
4698     .. code-block:: bash
4699         salt '*' virt.vm_blockstats
4700     """
4701     def get_disk_devs(dom):
4702         """
4703         Extract the disk devices names from the domain XML definition
4704         """
4705         doc = ElementTree.fromstring(get_xml(dom, **kwargs))
4706         return [target.get("dev") for target in doc.findall("devices/disk/target")]
4707     def _info(dom):
4708         """
4709         Compute the disk stats of a domain
4710         """
4711         disks = get_disk_devs(dom)
4712         for disk in disks:
4713             stats = dom.blockStats(disk)
4714             ret<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["rd_req"] += stats[0]
4715             ret["rd_bytes"] += stats[1]
4716             ret["wr_req"] += stats[2]
4717             ret["wr_bytes"] += stats[3]
4718             ret["errs"] += stats[</b></font>4]
4719         return ret
4720     info = {}
4721     conn = __get_conn(**kwargs)
4722     if vm_:
4723         info[vm_] = _info(_get_domain(conn, vm_))
4724     else:
4725         for domain in _get_domain(conn, iterable=True, inactive=False):
4726             info[domain.name()] = _info(domain)
4727     conn.close()
4728     return info
4729 def _parse_snapshot_description(vm_snapshot, unix_time=False):
4730     """
4731     Parse XML doc and return a dict with the status values.
4732     :param xmldoc:
4733     :return:
4734     """
4735     ret = dict()
4736     tree = ElementTree.fromstring(vm_snapshot.getXMLDesc())
4737     for node in tree:
4738         if node.tag == "name":
4739             ret["name"] = node.text
4740         elif node.tag == "creationTime":
4741             ret["created"] = (
4742                 datetime.datetime.fromtimestamp(float(node.text)).isoformat(" ")
4743                 if not unix_time
4744                 else float(node.text)
4745             )
4746         elif node.tag == "state":
4747             ret["running"] = node.text == "running"
4748     ret["current"] = vm_snapshot.isCurrent() == 1
4749     return ret
4750 def list_snapshots(domain=None, **kwargs):
4751     """
4752     List available snapshots for certain vm or for all.
4753     :param domain: domain name
4754     :param connection: libvirt connection URI, overriding defaults
4755         .. versionadded:: 2019.2.0
4756     :param username: username to connect with, overriding defaults
4757         .. versionadded:: 2019.2.0
4758     :param password: password to connect with, overriding defaults
4759         .. versionadded:: 2019.2.0
4760     .. versionadded:: 2016.3.0
4761     CLI Example:
4762     .. code-block:: bash
4763         salt '*' virt.list_snapshots
4764         salt '*' virt.list_snapshots &lt;domain&gt;
4765     """
4766     ret = dict()
4767     conn = __get_conn(**kwargs)
4768     for vm_domain in _get_domain(conn, *(domain and [domain] or list()), iterable=True):
4769         ret[vm_domain.name()] = [
4770             _parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()
4771         ] or "N/A"
4772     conn.close()
4773     return ret
4774 def snapshot(domain, name=None, suffix=None, **kwargs):
4775     """
4776     Create a snapshot of a VM.
4777     :param domain: domain name
4778     :param name: Name of the snapshot. If the name is omitted, then will be used original domain
4779                  name with ISO 8601 time as a suffix.
4780     :param suffix: Add suffix for the new name. Useful in states, where such snapshots
4781                    can be distinguished from manually created.
4782     :param connection: libvirt connection URI, overriding defaults
4783         .. versionadded:: 2019.2.0
4784     :param username: username to connect with, overriding defaults
4785         .. versionadded:: 2019.2.0
4786     :param password: password to connect with, overriding defaults
4787         .. versionadded:: 2019.2.0
4788     .. versionadded:: 2016.3.0
4789     CLI Example:
4790     .. code-block:: bash
4791         salt '*' virt.snapshot &lt;domain&gt;
4792     """
4793     if name and name.lower() == domain.lower():
4794         raise CommandExecutionError(
4795             "Virtual Machine {name} is already defined. "
4796             "Please choose another name for the snapshot".format(name=name)
4797         )
4798     if not name:
4799         name = "{domain}-{tsnap}".format(
4800             domain=domain, tsnap=time.strftime("%Y%m%d-%H%M%S", time.localtime())
4801         )
4802     if suffix:
4803         name = "{name}-{suffix}".format(name=name, suffix=suffix)
4804     doc = ElementTree.Element("domainsnapshot")
4805     n_name = ElementTree.SubElement(doc, "name")
4806     n_name.text = name
4807     conn = __get_conn(**kwargs)
4808     _get_domain(conn, domain).snapshotCreateXML(xmlutil.element_to_str(doc))
4809     conn.close()
4810     return {"name": name}
4811 def delete_snapshots(name, *names, **kwargs):
4812     """
4813     Delete one or more snapshots of the given VM.
4814     :param name: domain name
4815     :param names: names of the snapshots to remove
4816     :param connection: libvirt connection URI, overriding defaults
4817         .. versionadded:: 2019.2.0
4818     :param username: username to connect with, overriding defaults
4819         .. versionadded:: 2019.2.0
4820     :param password: password to connect with, overriding defaults
4821         .. versionadded:: 2019.2.0
4822     .. versionadded:: 2016.3.0
4823     CLI Example:
4824     .. code-block:: bash
4825         salt '*' virt.delete_snapshots &lt;domain&gt; all=True
4826         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot&gt;
4827         salt '*' virt.delete_snapshots &lt;domain&gt; &lt;snapshot1&gt; &lt;snapshot2&gt; ...
4828     """
4829     deleted = dict()
4830     conn = __get_conn(**kwargs)
4831     domain = _get_domain(conn, name)
4832     for snap in domain.listAllSnapshots():
4833         if snap.getName() in names or not names:
4834             deleted[snap.getName()] = _parse_snapshot_description(snap)
4835             snap.delete()
4836     conn.close()
4837     available = {
4838         name: [_parse_snapshot_description(snap) for snap in domain.listAllSnapshots()]
4839         or "N/A"
4840     }
4841     return {"available": available, "deleted": deleted}
4842 def revert_snapshot(name, vm_snapshot=None, cleanup=False, **kwargs):
4843     """
4844     Revert snapshot to the previous from current (if available) or to the specific.
4845     :param name: domain name
4846     :param vm_snapshot: name of the snapshot to revert
4847     :param cleanup: Remove all newer than reverted snapshots. Values: True or False (default False).
4848     :param connection: libvirt connection URI, overriding defaults
4849         .. versionadded:: 2019.2.0
4850     :param username: username to connect with, overriding defaults
4851         .. versionadded:: 2019.2.0
4852     :param password: password to connect with, overriding defaults
4853         .. versionadded:: 2019.2.0
4854     .. versionadded:: 2016.3.0
4855     CLI Example:
4856     .. code-block:: bash
4857         salt '*' virt.revert &lt;domain&gt;
4858         salt '*' virt.revert &lt;domain&gt; &lt;snapshot&gt;
4859     """
4860     ret = dict()
4861     conn = __get_conn(**kwargs)
4862     domain = _get_domain(conn, name)
4863     snapshots = domain.listAllSnapshots()
4864     _snapshots = list()
4865     for snap_obj in snapshots:
4866         _snapshots.append(
4867             {
4868                 "idx": _parse_snapshot_description(snap_obj, unix_time=True)["created"],
4869                 "ptr": snap_obj,
4870             }
4871         )
4872     snapshots = [
4873         w_ptr["ptr"]
4874         for w_ptr in sorted(_snapshots, key=lambda item: item["idx"], reverse=True)
4875     ]
4876     del _snapshots
4877     if not snapshots:
4878         conn.close()
4879         raise CommandExecutionError("No snapshots found")
4880     elif len(snapshots) == 1:
4881         conn.close()
4882         raise CommandExecutionError(
4883             "Cannot revert to itself: only one snapshot is available."
4884         )
4885     snap = None
4886     for p_snap in snapshots:
4887         if not vm_snapshot:
4888             if p_snap.isCurrent() and snapshots[snapshots.index(p_snap) + 1 :]:
4889                 snap = snapshots[snapshots.index(p_snap) + 1 :][0]
4890                 break
4891         elif p_snap.getName() == vm_snapshot:
4892             snap = p_snap
4893             break
4894     if not snap:
4895         conn.close()
4896         raise CommandExecutionError(
4897             snapshot
4898             and 'Snapshot "{}" not found'.format(vm_snapshot)
4899             or "No more previous snapshots available"
4900         )
4901     elif snap.isCurrent():
4902         conn.close()
4903         raise CommandExecutionError("Cannot revert to the currently running snapshot.")
4904     domain.revertToSnapshot(snap)
4905     ret["reverted"] = snap.getName()
4906     if cleanup:
4907         delete = list()
4908         for p_snap in snapshots:
4909             if p_snap.getName() != snap.getName():
4910                 delete.append(p_snap.getName())
4911                 p_snap.delete()
4912             else:
4913                 break
4914         ret["deleted"] = delete
4915     else:
4916         ret["deleted"] = "N/A"
4917     conn.close()
4918     return ret
4919 def _caps_add_machine(machines, node):
4920     """
4921     Parse the &lt;machine&gt; element of the host capabilities and add it
4922     to the machines list.
4923     """
4924     maxcpus = node.get("maxCpus")
4925     canonical = node.get("canonical")
4926     name = node.text
4927     alternate_name = ""
4928     if canonical:
4929         alternate_name = name
4930         name = canonical
4931     machine = machines.get(name)
4932     if not machine:
4933         machine = {"alternate_names": []}
4934         if maxcpus:
4935             machine["maxcpus"] = int(maxcpus)
4936         machines[name] = machine
4937     if alternate_name:
4938         machine["alternate_names"].append(alternate_name)
4939 def _parse_caps_guest(guest):
4940     """
4941     Parse the &lt;guest&gt; element of the connection capabilities XML
4942     """
4943     arch_node = guest.find("arch")
4944     result = {
4945         "os_type": guest.find("os_type").text,
4946         "arch": {"name": arch_node.get("name"), "machines": {}, "domains": {}},
4947     }
4948     child = None
4949     for child in arch_node:
4950         if child.tag == "wordsize":
4951             result["arch"]["wordsize"] = int(child.text)
4952         elif child.tag == "emulator":
4953             result["arch"]["emulator"] = child.text
4954         elif child.tag == "machine":
4955             _caps_add_machine(result["arch"]["machines"], child)
4956         elif child.tag == "domain":
4957             domain_type = child.get("type")
4958             domain = {"emulator": None, "machines": {}}
4959             emulator_node = child.find("emulator")
4960             if emulator_node is not None:
4961                 domain["emulator"] = emulator_node.text
4962             for machine in child.findall("machine"):
4963                 _caps_add_machine(domain["machines"], machine)
4964             result["arch"]["domains"][domain_type] = domain
4965     features_nodes = guest.find("features")
4966     if features_nodes is not None and child is not None:
4967         result["features"] = {
4968             child.tag: {
4969                 "toggle": child.get("toggle", "no") == "yes",
4970                 "default": child.get("default", "on") == "on",
4971             }
4972             for child in features_nodes
4973         }
4974     return result
4975 def _parse_caps_cell(cell):
4976     """
4977     Parse the &lt;cell&gt; nodes of the connection capabilities XML output.
4978     """
4979     result = {"id": int(cell.get("id"))}
4980     mem_node = cell.find("memory")
4981     if mem_node is not None:
4982         unit = mem_node.get("unit", "KiB")
4983         memory = mem_node.text
4984         result["memory"] = "{} {}".format(memory, unit)
4985     pages = [
4986         {
4987             "size": "{} {}".format(page.get("size"), page.get("unit", "KiB")),
4988             "available": int(page.text),
4989         }
4990         for page in cell.findall("pages")
4991     ]
4992     if pages:
4993         result["pages"] = pages
4994     distances = {
4995         int(distance.get("id")): int(distance.get("value"))
4996         for distance in cell.findall("distances/sibling")
4997     }
4998     if distances:
4999         result["distances"] = distances
5000     cpus = []
5001     for cpu_node in cell.findall("cpus/cpu"):
5002         cpu = {"id": int(cpu_node.get("id"))}
5003         socket_id = cpu_node.get("socket_id")
5004         if socket_id:
5005             cpu["socket_id"] = int(socket_id)
5006         core_id = cpu_node.get("core_id")
5007         if core_id:
5008             cpu["core_id"] = int(core_id)
5009         siblings = cpu_node.get("siblings")
5010         if siblings:
5011             cpu["siblings"] = siblings
5012         cpus.append(cpu)
5013     if cpus:
5014         result["cpus"] = cpus
5015     return result
5016 def _parse_caps_bank(bank):
5017     """
5018     """
5019     result = {
5020         "id": int<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(bank.get("id")),
5021         "level": int(bank.get("level")),
5022         "type": bank.get("type"),
5023         "size": "{} {}".format(bank.get(</b></font>"size"), bank.get("unit")),
5024         "cpus": bank.get("cpus"),
5025     }
5026     controls = []
5027     for control in bank.findall("control"):
5028         unit = control.get("unit")
5029         result_control = {
5030             "granularity": "{} {}".format(control.get("granularity"), unit),
5031             "type": control.get("type"),
5032             "maxAllocs": int(control.get("maxAllocs")),
5033         }
5034         minimum = control.get("min")
5035         if minimum:
5036             result_control["min"] = "{} {}".format(minimum, unit)
5037         controls.append(result_control)
5038     if controls:
5039         result["controls"] = controls
5040     return result
5041 def _parse_caps_host(host):
5042     """
5043     Parse the &lt;host&gt; element of the connection capabilities XML.
5044     """
5045     result = {}
5046     for child in host:
5047         if child.tag == "uuid":
5048             result["uuid"] = child.text
5049         elif child.tag == "cpu":
5050             cpu = {
5051                 "arch": child.find("arch").text
5052                 if child.find("arch") is not None
5053                 else None,
5054                 "model": child.find("model").text
5055                 if child.find("model") is not None
5056                 else None,
5057                 "vendor": child.find("vendor").text
5058                 if child.find("vendor") is not None
5059                 else None,
5060                 "features": [
5061                 ],
5062                 "pages": [
5063                     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{"size": "{} {}".format(page.get("size"), page.get("unit", "KiB"))}
5064                     for page in child.findall("pages")
5065                 ],
5066             }
5067             microcode = child.find(</b></font>"microcode")
5068             if microcode is not None:
5069                 cpu["microcode"] = microcode.get("version")
5070             topology = child.find("topology")
5071             if topology is not None:
5072                 cpu["sockets"] = int(topology.get("sockets"))
5073                 cpu["cores"] = int(topology.get("cores"))
5074                 cpu["threads"] = int(topology.get("threads"))
5075             result["cpu"] = cpu
5076         elif child.tag == "power_management":
5077             result["power_management"] = [node.tag for node in child]
5078         elif child.tag == "migration_features":
5079             result["migration"] = {
5080                 "live": child.find("live") is not None,
5081                 "transports": [
5082                     node.text for node in child.findall("uri_transports/uri_transport")
5083                 ],
5084             }
5085         elif child.tag == "topology":
5086             result["topology"] = {
5087                 "cells": [
5088                     _parse_caps_cell(cell) for cell in child.findall("cells/cell")
5089                 ]
5090             }
5091         elif child.tag == "cache":
5092             result["cache"] = {
5093                 "banks": [_parse_caps_bank(bank) for bank in child.findall("bank")]
5094             }
5095     result["security"] = [
5096         {
5097             "model": secmodel.find("model").text
5098             if secmodel.find("model") is not None
5099             else None,
5100             "doi": secmodel.find("doi").text
5101             if secmodel.find("doi") is not None
5102             else None,
5103             "baselabels": [
5104                 {"type": label.get("type"), "label": label.text}
5105                 for label in secmodel.findall("baselabel")
5106             ],
5107         }
5108         for secmodel in host.findall("secmodel")
5109     ]
5110     return result
5111 def _capabilities(conn):
5112     """
5113     Return the hypervisor connection capabilities.
5114     :param conn: opened libvirt connection to use
5115     """
5116     caps = ElementTree.fromstring(conn.getCapabilities())
5117     return {
5118         "host": _parse_caps_host(caps.find("host")),
5119         "guests": [_parse_caps_guest(guest) for guest in caps.findall("guest")],
5120     }
5121 def capabilities(**kwargs):
5122     """
5123     Return the hypervisor connection capabilities.
5124     :param connection: libvirt connection URI, overriding defaults
5125     :param username: username to connect with, overriding defaults
5126     :param password: password to connect with, overriding defaults
5127     .. versionadded:: 2019.2.0
5128     CLI Example:
5129     .. code-block:: bash
5130         salt '*' virt.capabilities
5131     """
5132     conn = __get_conn(**kwargs)
5133     try:
5134         caps = _capabilities(conn)
5135     except libvirt.libvirtError as err:
5136         raise CommandExecutionError(str(err))
5137     finally:
5138         conn.close()
5139     return caps
5140 def _parse_caps_enum(node):
5141     """
5142     Return a tuple containing the name of the enum and the possible values
5143     """
5144     return (node.get("name"), [value.text for value in node.findall("value")])
5145 def _parse_caps_cpu(node):
5146     """
5147     Parse the &lt;cpu&gt; element of the domain capabilities
5148     """
5149     result = {}
5150     for mode in node.findall("mode"):
5151         if not mode.get("supported") == "yes":
5152             continue
5153         name = mode.get("name")
5154         if name == "host-passthrough":
5155             result[name] = True
5156         elif name == "host-model":
5157             host_model = {}
5158             model_node = mode.find("model")
5159             if model_node is not None:
5160                 model = {"name": model_node.text}
5161                 vendor_id = model_node.get("vendor_id")
5162                 if vendor_id:
5163                     model["vendor_id"] = vendor_id
5164                 fallback = model_node.get("fallback")
5165                 if fallback:
5166                     model["fallback"] = fallback
5167                 host_model["model"] = model
5168             vendor = (
5169                 mode.find("vendor").text if mode.find("vendor") is not None else None
5170             )
5171             if vendor:
5172                 host_model["vendor"] = vendor
5173             features = {
5174                 feature.get("name"): feature.get("policy")
5175                 for feature in mode.findall("feature")
5176             }
5177             if features:
5178                 host_model["features"] = features
5179             result[name] = host_model
5180         elif name == "custom":
5181             custom_model = {}
5182             models = {
5183                 model.text: model.get("usable") for model in mode.findall("model")
5184             }
5185             if models:
5186                 custom_model["models"] = models
5187             result[name] = custom_model
5188     return result
5189 def _parse_caps_devices_features(node):
5190     """
5191     Parse the devices or features list of the domain capatilities
5192     """
5193     result = {}
5194     for child in node:
5195         if child.get("supported") == "yes":
5196             enums = [_parse_caps_enum(node) for node in child.findall("enum")]
5197             result[child.tag] = {item[0]: item[1] for item in enums if item[0]}
5198     return result
5199 def _parse_caps_loader(node):
5200     """
5201     """
5202     enums = [_parse_caps_enum(enum) for enum in node.findall("enum")]
5203     result <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {item[0]: item[1] for item in enums if item[0]}
5204     values = [child.text for child in node.findall("value")]
5205     if values:
5206         result["values"] =</b></font> values
5207     return result
5208 def _parse_domain_caps(caps):
5209     """
5210     """
5211     result = {
5212         "emulator": caps.find("path")<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.text if caps.find("path") is not None else None,
5213         "domain": caps.find("domain").text if caps.find("domain") is not None else None,
5214         "machine": caps.find("machine").text
5215         if caps.find("machine") is not None
5216         else None,
5217         "arch": caps.find("arch").text if caps.find(</b></font>"arch") is not None else None,
5218     }
5219     for child in caps:
5220         if child.tag == "vcpu" and child.get("max"):
5221             result["max_vcpus"] = int(child.get("max"))
5222         elif child.tag == "iothreads":
5223             result["iothreads"] = child.get("supported") == "yes"
5224         elif child.tag == "os":
5225             result["os"] = {}
5226             loader_node = child.find("loader")
5227             if loader_node is not None and loader_node.get("supported") == "yes":
5228                 loader = _parse_caps_loader(loader_node)
5229                 result["os"]["loader"] = loader
5230         elif child.tag == "cpu":
5231             cpu = _parse_caps_cpu(child)
5232             if cpu:
5233                 result["cpu"] = cpu
5234         elif child.tag == "devices":
5235             devices = _parse_caps_devices_features(child)
5236             if devices:
5237                 result["devices"] = devices
5238         elif child.tag == "features":
5239             features = _parse_caps_devices_features(child)
5240             if features:
5241                 result["features"] = features
5242     return result
5243 def domain_capabilities(emulator=None, arch=None, machine=None, domain=None, **kwargs):
5244     """
5245     Return the domain capabilities given an emulator, architecture, machine or virtualization type.
5246     .. versionadded:: 2019.2.0
5247     :param emulator: return the capabilities for the given emulator binary
5248     :param arch: return the capabilities for the given CPU architecture
5249     :param machine: return the capabilities for the given emulated machine type
5250     :param domain: return the capabilities for the given virtualization type.
5251     :param connection: libvirt connection URI, overriding defaults
5252     :param username: username to connect with, overriding defaults
5253     :param password: password to connect with, overriding defaults
5254     The list of the possible emulator, arch, machine and domain can be found in
5255     the host capabilities output.
5256     If none of the parameters is provided, the libvirt default one is returned.
5257     CLI Example:
5258     .. code-block:: bash
5259         salt '*' virt.domain_capabilities arch='x86_64' domain='kvm'
5260     """
5261     conn = __get_conn(**kwargs)
5262     result = []
5263     try:
5264         caps = ElementTree.fromstring(
5265             conn.getDomainCapabilities(emulator, arch, machine, domain, 0)
5266         )
5267         result = _parse_domain_caps(caps)
5268     finally:
5269         conn.close()
5270     return result
5271 def all_capabilities(**kwargs):
5272     """
5273     Return the host and domain capabilities in a single call.
5274     .. versionadded:: 3001
5275     :param connection: libvirt connection URI, overriding defaults
5276     :param username: username to connect with, overriding defaults
5277     :param password: password to connect with, overriding defaults
5278     CLI Example:
5279     .. code-block:: bash
5280         salt '*' virt.all_capabilities
5281     conn = __get_conn(**kwargs)
5282     try:
5283         host_caps = ElementTree<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.fromstring(conn.getCapabilities())
5284         domains = [
5285             [
5286                 (
5287                     guest.get("arch", {}).get(</b></font>"name", None),
5288                     key,
5289                     guest.get("arch", {}).get("emulator", None),
5290                 )
5291                 for key in guest.get("arch", {}).get("domains", {}).keys()
5292             ]
5293             for guest in [
5294                 _parse_caps_guest(guest) for guest in host_caps.findall("guest")
5295             ]
5296         ]
5297         result = {
5298             "host": {
5299                 "host": _parse_caps_host<font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(host_caps.find("host")),
5300                 "guests": [
5301                     _parse_caps_guest(guest) for guest in host_caps.findall("guest")
5302                 ],
5303             },
5304             "domains": [
5305                 _parse_domain_caps(
5306                     ElementTree.fromstring(
5307                         conn.getDomainCapabilities(</b></font>emulator, arch, None, domain)
5308                     )
5309                 )
5310                 for (arch, domain, emulator) in flattened
5311             ],
5312         }
5313         return result
5314     finally:
5315         conn.close()
5316 def cpu_baseline(full=False, migratable=False, out="libvirt", **kwargs):
5317     """
5318     Return the optimal 'custom' CPU baseline config for VM's on this minion
5319     .. versionadded:: 2016.3.0
5320     :param full: Return all CPU features rather than the ones on top of the closest CPU model
5321     :param migratable: Exclude CPU features that are unmigratable (libvirt 2.13+)
5322     :param out: 'libvirt' (default) for usable libvirt XML definition, 'salt' for nice dict
5323     :param connection: libvirt connection URI, overriding defaults
5324         .. versionadded:: 2019.2.0
5325     :param username: username to connect with, overriding defaults
5326         .. versionadded:: 2019.2.0
5327     :param password: password to connect with, overriding defaults
5328         .. versionadded:: 2019.2.0
5329     CLI Example:
5330     .. code-block:: bash
5331         salt '*' virt.cpu_baseline
5332     """
5333     conn = __get_conn(**kwargs)
5334     caps = ElementTree.fromstring(conn.getCapabilities())
5335     cpu = caps.find("host/cpu")
5336     host_cpu_def = xmlutil.element_to_str(cpu)
5337     log.debug("Host CPU model definition: %s", host_cpu_def)
5338     flags = 0
5339     if migratable:
5340         if getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_MIGRATABLE", False):
5341             flags += libvirt.VIR_CONNECT_BASELINE_CPU_MIGRATABLE
5342         else:
5343             conn.close()
5344             raise ValueError
5345     if full and getattr(libvirt, "VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES", False):
5346         flags += libvirt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES
5347     cpu = ElementTree.fromstring(conn.baselineCPU([host_cpu_def], flags))
5348     conn.close()
5349         <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen("/usr/share/libvirt/cpu_map.xml", "r") as cpu_map:
5350             cpu_map = ElementTree.parse(cpu_map)
5351         cpu_model = cpu.find("model").</b></font>text
5352         while cpu_model:
5353             cpu_map_models = cpu_map.findall("arch/model")
5354             cpu_specs = [
5355                 el
5356                 for el in cpu_map_models
5357                 if el.get("name") == cpu_model and bool(len(el))
5358             ]
5359             if not cpu_specs:
5360                 raise ValueError("Model {} not found in CPU map".format(cpu_model))
5361             elif len(cpu_specs) &gt; 1:
5362                 raise ValueError(
5363                     "Multiple models {} found in CPU map".format(cpu_model)
5364                 )
5365             cpu_specs = cpu_specs[0]
5366             model_node = cpu_specs.find("model")
5367             if model_node is None:
5368                 cpu_model = None
5369             else:
5370                 cpu_model = model_node.get("name")
5371             cpu.extend([feature for feature in cpu_specs.findall("feature")])
5372     if out == "salt":
5373         return {
5374             "model": cpu.find("model").text,
5375             "vendor": cpu.find("vendor").text,
5376             "features": [feature.get("name") for feature in cpu.findall("feature")],
5377         }
5378     return ElementTree.tostring(cpu)
5379 def network_define(
5380     name,
5381     bridge,
5382     forward,
5383     ipv4_config=None,
5384     ipv6_config=None,
5385     vport=None,
5386     tag=None,
5387     autostart=True,
5388     start=True,
5389     mtu=None,
5390     domain=None,
5391     nat=None,
5392     interfaces=None,
5393     addresses=None,
5394     physical_function=None,
5395     dns=None,
5396     **kwargs
5397 ):
5398     """
5399     Create libvirt network.
5400     :param name: Network name.
5401     :param bridge: Bridge name.
5402     :param forward: Forward mode (bridge, router, nat).
5403         .. versionchanged:: 3003
5404            a ``None`` value creates an isolated network with no forwarding at all
5405     :param vport: Virtualport type.
5406         The value can also be a dictionary with ``type`` and ``parameters`` keys.
5407         The ``parameters`` value is a dictionary of virtual port parameters.
5408         .. code-block:: yaml
5409           - vport:
5410               type: openvswitch
5411               parameters:
5412                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
5413         .. versionchanged:: 3003
5414            possible dictionary value
5415     :param tag: Vlan tag.
5416         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
5417         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
5418         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
5419         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
5420         .. code-block:: yaml
5421           - tag:
5422               trunk: True
5423               tags:
5424                 - id: 42
5425                   nativeMode: untagged
5426                 - id: 47
5427         .. versionchanged:: 3003
5428            possible dictionary value
5429     :param autostart: Network autostart (default True).
5430     :param start: Network start (default True).
5431     :param ipv4_config: IP v4 configuration.
5432         Dictionary describing the IP v4 setup like IP range and
5433         a possible DHCP configuration. The structure is documented
5434         in net-define-ip_.
5435         .. versionadded:: 3000
5436     :type ipv4_config: dict or None
5437     :param ipv6_config: IP v6 configuration.
5438         Dictionary describing the IP v6 setup like IP range and
5439         a possible DHCP configuration. The structure is documented
5440         in net-define-ip_.
5441         .. versionadded:: 3000
5442     :type ipv6_config: dict or None
5443     :param connection: libvirt connection URI, overriding defaults.
5444     :param username: username to connect with, overriding defaults.
5445     :param password: password to connect with, overriding defaults.
5446     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
5447         (default ``None``)
5448         .. versionadded:: 3003
5449     :param domain: DNS domain name of the DHCP server.
5450         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
5451         (default ``None``)
5452         .. code-block:: yaml
5453           - domain:
5454               name: lab.acme.org
5455               localOnly: True
5456         .. versionadded:: 3003
5457     :param nat: addresses and ports to route in NAT forward mode.
5458         The value is a dictionary with optional keys ``address`` and ``port``.
5459         Both values are a dictionary with ``start`` and ``end`` values.
5460         (default ``None``)
5461         .. code-block:: yaml
5462           - forward: nat
5463           - nat:
5464               address:
5465                 start: 1.2.3.4
5466                 end: 1.2.3.10
5467               port:
5468                 start: 500
5469                 end: 1000
5470         .. versionadded:: 3003
5471     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
5472         (default ``None``)
5473         .. code-block:: yaml
5474           - forward: passthrough
5475           - interfaces: "eth10 eth11 eth12"
5476         .. versionadded:: 3003
5477     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
5478         (default ``None``)
5479         .. code-block:: yaml
5480           - forward: hostdev
5481           - interfaces: "0000:04:00.1 0000:e3:01.2"
5482         .. versionadded:: 3003
5483     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
5484         (default ``None``)
5485         .. code-block:: yaml
5486           - forward: hostdev
5487           - physical_function: "eth0"
5488         .. versionadded:: 3003
5489     :param dns: virtual network DNS configuration.
5490         The value is a dictionary described in net-define-dns_.
5491         (default ``None``)
5492         .. code-block:: yaml
5493           - dns:
5494               forwarders:
5495                 - domain: example.com
5496                   addr: 192.168.1.1
5497                 - addr: 8.8.8.8
5498                 - domain: www.example.com
5499               txt:
5500                 example.com: "v=spf1 a -all"
5501                 _http.tcp.example.com: "name=value,paper=A4"
5502               hosts:
5503                 192.168.1.2:
5504                   - mirror.acme.lab
5505                   - test.acme.lab
5506               srvs:
5507                 - name: ldap
5508                   protocol: tcp
5509                   domain: ldapserver.example.com
5510                   target: .
5511                   port: 389
5512                   priority: 1
5513                   weight: 10
5514         .. versionadded:: 3003
5515     .. _net-define-ip:
5516     .. rubric:: IP configuration definition
5517     Both the IPv4 and IPv6 configuration dictionaries can contain the following properties:
5518     cidr
5519         CIDR notation for the network. For example '192.168.124.0/24'
5520     dhcp_ranges
5521         A list of dictionaries with ``'start'`` and ``'end'`` properties.
5522     hosts
5523         A list of dictionaries with ``ip`` property and optional ``name``, ``mac`` and ``id`` properties.
5524         .. versionadded:: 3003
5525     bootp
5526         A dictionary with a ``file`` property and an optional ``server`` one.
5527         .. versionadded:: 3003
5528     tftp
5529         The path to the TFTP root directory to serve.
5530         .. versionadded:: 3003
5531     .. _net-define-dns:
5532     .. rubric:: DNS configuration definition
5533     The DNS configuration dictionary contains the following optional properties:
5534     forwarders
5535         List of alternate DNS forwarders to use.
5536         Each item is a dictionary with the optional ``domain`` and ``addr`` keys.
5537         If both are provided, the requests to the domain are forwarded to the server at the ``addr``.
5538         If only ``domain`` is provided the requests matching this domain will be resolved locally.
5539         If only ``addr`` is provided all requests will be forwarded to this DNS server.
5540     txt:
5541         Dictionary of TXT fields to set.
5542     hosts:
5543         Dictionary of host DNS entries.
5544         The key is the IP of the host, and the value is a list of hostnames for it.
5545     srvs:
5546         List of SRV DNS entries.
5547         Each entry is a dictionary with the mandatory ``name`` and ``protocol`` keys.
5548         Entries can also have ``target``, ``port``, ``priority``, ``domain`` and ``weight`` optional properties.
5549     CLI Example:
5550     .. code-block:: bash
5551         salt '*' virt.network_define network main bridge openvswitch
5552     .. versionadded:: 2019.2.0
5553     """
5554     conn = __get_conn(**kwargs)
5555     vport = kwargs.get("vport", None)
5556     tag = kwargs.get("tag", None)
5557     net_xml = _gen_net_xml(
5558         name,
5559         bridge,
5560         forward,
5561         vport,
5562         tag=tag,
5563         ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
5564         mtu=mtu,
5565         domain=domain,
5566         nat=nat,
5567         interfaces=interfaces,
5568         addresses=addresses,
5569         physical_function=physical_function,
5570         dns=dns,
5571     )
5572     try:
5573         conn.networkDefineXML(net_xml)
5574     except libvirt.libvirtError as err:
5575         log.warning(err)
5576         conn.close()
5577         raise err  # a real error we should report upwards
5578     try:
5579         network = conn.networkLookupByName(name)
5580     except libvirt.libvirtError as err:
5581         log.warning(err)
5582         conn.close()
5583         raise err  # a real error we should report upwards
5584     if network is None:
5585         conn.close()
5586         return False
5587     if (start or autostart) and network.isActive() != 1:
5588         network.create()
5589     if autostart and network.autostart() != 1:
5590         network.setAutostart(int(autostart))
5591     elif not autostart and network.autostart() == 1:
5592         network.setAutostart(int(autostart))
5593     conn.close()
5594     return True
5595 def _remove_empty_xml_node(node):
5596     """
5597     Remove the nodes with no children, no text and no attribute
5598     """
5599     for child in node:
5600         if not child.tail and not child.text and not child.items() and not child:
5601             node.remove(child)
5602         else:
5603             _remove_empty_xml_node(child)
5604     return node
5605 def network_update(
5606     name,
5607     bridge,
5608     forward,
5609     ipv4_config=None,
5610     ipv6_config=None,
5611     vport=None,
5612     tag=None,
5613     mtu=None,
5614     domain=None,
5615     nat=None,
5616     interfaces=None,
5617     addresses=None,
5618     physical_function=None,
5619     dns=None,
5620     test=False,
5621     **kwargs
5622 ):
5623     """
5624     Update a virtual network if needed.
5625     :param name: Network name.
5626     :param bridge: Bridge name.
5627     :param forward: Forward mode (bridge, router, nat).
5628         A ``None`` value creates an isolated network with no forwarding at all.
5629     :param vport: Virtualport type.
5630         The value can also be a dictionary with ``type`` and ``parameters`` keys.
5631         The ``parameters`` value is a dictionary of virtual port parameters.
5632         .. code-block:: yaml
5633           - vport:
5634               type: openvswitch
5635               parameters:
5636                 interfaceid: 09b11c53-8b5c-4eeb-8f00-d84eaa0aaa4f
5637     :param tag: Vlan tag.
5638         The value can also be a dictionary with the ``tags`` and optional ``trunk`` keys.
5639         ``trunk`` is a boolean value indicating whether to use VLAN trunking.
5640         ``tags`` is a list of dictionaries with keys ``id`` and ``nativeMode``.
5641         The ``nativeMode`` value can be one of ``tagged`` or ``untagged``.
5642         .. code-block:: yaml
5643           - tag:
5644               trunk: True
5645               tags:
5646                 - id: 42
5647                   nativeMode: untagged
5648                 - id: 47
5649     :param ipv4_config: IP v4 configuration.
5650         Dictionary describing the IP v4 setup like IP range and
5651         a possible DHCP configuration. The structure is documented
5652         in net-define-ip_.
5653     :type ipv4_config: dict or None
5654     :param ipv6_config: IP v6 configuration.
5655         Dictionary describing the IP v6 setup like IP range and
5656         a possible DHCP configuration. The structure is documented
5657         in net-define-ip_.
5658     :type ipv6_config: dict or None
5659     :param connection: libvirt connection URI, overriding defaults.
5660     :param username: username to connect with, overriding defaults.
5661     :param password: password to connect with, overriding defaults.
5662     :param mtu: size of the Maximum Transmission Unit (MTU) of the network.
5663         (default ``None``)
5664     :param domain: DNS domain name of the DHCP server.
5665         The value is a dictionary with a mandatory ``name`` property and an optional ``localOnly`` boolean one.
5666         (default ``None``)
5667         .. code-block:: yaml
5668           - domain:
5669               name: lab.acme.org
5670               localOnly: True
5671     :param nat: addresses and ports to route in NAT forward mode.
5672         The value is a dictionary with optional keys ``address`` and ``port``.
5673         Both values are a dictionary with ``start`` and ``end`` values.
5674         (default ``None``)
5675         .. code-block:: yaml
5676           - forward: nat
5677           - nat:
5678               address:
5679                 start: 1.2.3.4
5680                 end: 1.2.3.10
5681               port:
5682                 start: 500
5683                 end: 1000
5684     :param interfaces: whitespace separated list of network interfaces devices that can be used for this network.
5685         (default ``None``)
5686         .. code-block:: yaml
5687           - forward: passthrough
5688           - interfaces: "eth10 eth11 eth12"
5689     :param addresses: whitespace separated list of addresses of PCI devices that can be used for this network in `hostdev` forward mode.
5690         (default ``None``)
5691         .. code-block:: yaml
5692           - forward: hostdev
5693           - interfaces: "0000:04:00.1 0000:e3:01.2"
5694     :param physical_function: device name of the physical interface to use in ``hostdev`` forward mode.
5695         (default ``None``)
5696         .. code-block:: yaml
5697           - forward: hostdev
5698           - physical_function: "eth0"
5699     :param dns: virtual network DNS configuration.
5700         The value is a dictionary described in net-define-dns_.
5701         (default ``None``)
5702         .. code-block:: yaml
5703           - dns:
5704               forwarders:
5705                 - domain: example.com
5706                   addr: 192.168.1.1
5707                 - addr: 8.8.8.8
5708                 - domain: www.example.com
5709               txt:
5710                 example.com: "v=spf1 a -all"
5711                 _http.tcp.example.com: "name=value,paper=A4"
5712               hosts:
5713                 192.168.1.2:
5714                   - mirror.acme.lab
5715                   - test.acme.lab
5716               srvs:
5717                 - name: ldap
5718                   protocol: tcp
5719                   domain: ldapserver.example.com
5720                   target: .
5721                   port: 389
5722                   priority: 1
5723                   weight: 10
5724     .. versionadded:: 3003
5725     """
5726     conn = __get_conn(**kwargs)
5727     needs_update = False
5728     try:
5729         net = conn.networkLookupByName(name)
5730         old_xml = ElementTree.fromstring(net.XMLDesc())
5731         new_xml = ElementTree.fromstring(
5732             _gen_net_xml(
5733                 name,
5734                 bridge,
5735                 forward,
5736                 vport,
5737                 tag=tag,
5738                 ip_configs=[config for config in [ipv4_config, ipv6_config] if config],
5739                 mtu=mtu,
5740                 domain=domain,
5741                 nat=nat,
5742                 interfaces=interfaces,
5743                 addresses=addresses,
5744                 physical_function=physical_function,
5745                 dns=dns,
5746             )
5747         )
5748         elements_to_copy = ["uuid", "mac"]
5749         for to_copy in elements_to_copy:
5750             element = old_xml.find(to_copy)
5751             if element is not None:
5752                 new_xml.insert(1, element)
5753         old_xml.attrib.pop("connections", None)
5754         if old_xml.find("forward/pf") is not None:
5755             forward_node = old_xml.find("forward")
5756             address_nodes = forward_node.findall("address")
5757             for node in address_nodes:
5758                 forward_node.remove(node)
5759         default_bridge_attribs = {"stp": "on", "delay": "0"}
5760         old_bridge_node = old_xml.find("bridge")
5761         if old_bridge_node is not None:
5762             for key, value in default_bridge_attribs.items():
5763                 if old_bridge_node.get(key, None) == value:
5764                     old_bridge_node.attrib.pop(key, None)
5765             old_forward = (
5766                 old_xml.find("forward").get("mode")
5767                 if old_xml.find("forward") is not None
5768                 else None
5769             )
5770             if (
5771                 old_forward == forward
5772                 and forward in ["nat", "route", "open", None]
5773                 and bridge is None
5774                 and old_bridge_node.get("name", "").startswith("virbr")
5775             ):
5776                 old_bridge_node.attrib.pop("name", None)
5777         ipv4_nodes = [
5778             node
5779             for node in old_xml.findall("ip")
5780             if node.get("family", "ipv4") == "ipv4"
5781         ]
5782         for ip_node in ipv4_nodes:
5783             netmask = ip_node.attrib.pop("netmask", None)
5784             if netmask:
5785                 address = ipaddress.ip_network(
5786                     "{}/{}".format(ip_node.get("address"), netmask), strict=False
5787                 )
5788                 ip_node.set("prefix", str(address.prefixlen))
5789         for doc in [old_xml, new_xml]:
5790             for node in doc.findall("ip"):
5791                 if "family" not in node.keys():
5792                     node.set("family", "ipv4")
5793         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
5794         xmlutil.strip_spaces(new_xml)
5795         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
5796         if needs_update and not test:
5797             conn.networkDefineXML(xmlutil.element_to_str(new_xml))
5798     finally:
5799         conn.close()
5800     return needs_update
5801 def list_networks(**kwargs):
5802     """
5803     List all virtual networks.
5804     :param connection: libvirt connection URI, overriding defaults
5805     :param username: username to connect with, overriding defaults
5806     :param password: password to connect with, overriding defaults
5807     .. versionadded:: 2019.2.0
5808     CLI Example:
5809     .. code-block:: bash
5810        salt '*' virt.list_networks
5811     """
5812     conn = __get_conn(**kwargs)
5813     try:
5814         return [net.name() for net in conn.listAllNetworks()]
5815     finally:
5816         conn.close()
5817 def network_info(name=None, **kwargs):
5818     """
5819     Return information on a virtual network provided its name.
5820     :param name: virtual network name
5821     :param connection: libvirt connection URI, overriding defaults
5822     :param username: username to connect with, overriding defaults
5823     :param password: password to connect with, overriding defaults
5824     If no name is provided, return the infos for all defined virtual networks.
5825     .. versionadded:: 2019.2.0
5826     CLI Example:
5827     .. code-block:: bash
5828         salt '*' virt.network_info default
5829     """
5830     result = {}
5831     conn = __get_conn(**kwargs)
5832     def _net_get_leases(net):
5833         """
5834         Get all DHCP leases for a network
5835         """
5836         leases = net.DHCPLeases()
5837         for lease in leases:
5838             if lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV4:
5839                 lease["type"] = "ipv4"
5840             elif lease["type"] == libvirt.VIR_IP_ADDR_TYPE_IPV6:
5841                 lease["type"] = "ipv6"
5842             else:
5843                 lease["type"] = "unknown"
5844         return leases
5845     def _net_get_bridge(net):
5846         """
5847         Get the bridge of the network or None
5848         """
5849         try:
5850             return net.bridgeName()
5851         except libvirt.libvirtError as err:
5852             return None
5853     try:
5854         nets = [
5855             net for net in conn.listAllNetworks() if name is None or net.name() == name
5856         ]
5857         result = {
5858             net.name(): {
5859                 "uuid": net.UUIDString(),
5860                 "bridge": _net_get_bridge(net),
5861                 "autostart": net.autostart(),
5862                 "active": net.isActive(),
5863                 "persistent": net.isPersistent(),
5864                 "leases": _net_get_leases(net),
5865             }
5866             for net in nets
5867         }
5868     except libvirt.libvirtError as err:
5869         log.debug("Silenced libvirt error: %s", err)
5870     finally:
5871         conn.close()
5872     return result
5873 def network_get_xml(name, **kwargs):
5874     """
5875     Return the XML definition of a virtual network
5876     :param name: libvirt network name
5877     :param connection: libvirt connection URI, overriding defaults
5878     :param username: username to connect with, overriding defaults
5879     :param password: password to connect with, overriding defaults
5880     .. versionadded:: 3000
5881     CLI Example:
5882     .. code-block:: bash
5883         salt '*' virt.network_get_xml default
5884     """
5885     conn = __get_conn(**kwargs)
5886     try:
5887         return conn.networkLookupByName(name).XMLDesc()
5888     finally:
5889         conn.close()
5890 def network_start(name, **kwargs):
5891     """
5892     Start a defined virtual network.
5893     :param name: virtual network name
5894     :param connection: libvirt connection URI, overriding defaults
5895     :param username: username to connect with, overriding defaults
5896     :param password: password to connect with, overriding defaults
5897     .. versionadded:: 2019.2.0
5898     CLI Example:
5899     .. code-block:: bash
5900         salt '*' virt.network_start default
5901     """
5902     conn = __get_conn(**kwargs)
5903     try:
5904         net = conn.networkLookupByName(name)
5905         return not bool(net.create())
5906     finally:
5907         conn.close()
5908 def network_stop(name, **kwargs):
5909     """
5910     Stop a defined virtual network.
5911     :param name: virtual network name
5912     :param connection: libvirt connection URI, overriding defaults
5913     :param username: username to connect with, overriding defaults
5914     :param password: password to connect with, overriding defaults
5915     .. versionadded:: 2019.2.0
5916     CLI Example:
5917     .. code-block:: bash
5918         salt '*' virt.network_stop default
5919     """
5920     conn = __get_conn(**kwargs)
5921     try:
5922         net = conn.networkLookupByName(name)
5923         return not bool(net.destroy())
5924     finally:
5925         conn.close()
5926 def network_undefine(name, **kwargs):
5927     """
5928     Remove a defined virtual network. This does not stop the virtual network.
5929     :param name: virtual network name
5930     :param connection: libvirt connection URI, overriding defaults
5931     :param username: username to connect with, overriding defaults
5932     :param password: password to connect with, overriding defaults
5933     .. versionadded:: 2019.2.0
5934     CLI Example:
5935     .. code-block:: bash
5936         salt '*' virt.network_undefine default
5937     """
5938     conn = __get_conn(**kwargs)
5939     try:
5940         net = conn.networkLookupByName(name)
5941         return not bool(net.undefine())
5942     finally:
5943         conn.close()
5944 def network_set_autostart(name, state="on", **kwargs):
5945     """
5946     Set the autostart flag on a virtual network so that the network
5947     will start with the host system on reboot.
5948     :param name: virtual network name
5949     :param state: 'on' to auto start the network, anything else to mark the
5950                   virtual network not to be started when the host boots
5951     :param connection: libvirt connection URI, overriding defaults
5952     :param username: username to connect with, overriding defaults
5953     :param password: password to connect with, overriding defaults
5954     .. versionadded:: 2019.2.0
5955     CLI Example:
5956     .. code-block:: bash
5957         salt "*" virt.network_set_autostart &lt;pool&gt; &lt;on | off&gt;
5958     """
5959     conn = __get_conn(**kwargs)
5960     try:
5961         net = conn.networkLookupByName(name)
5962         return not bool(net.setAutostart(1 if state == "on" else 0))
5963     finally:
5964         conn.close()
5965 def _parse_pools_caps(doc):
5966     """
5967     Parse libvirt pool capabilities XML
5968     """
5969     def _parse_pool_caps(pool):
5970         pool_caps = {
5971             "name": pool.get("type"),
5972             "supported": pool.get("supported", "no") == "yes",
5973         }
5974         for option_kind in ["pool", "vol"]:
5975             options = {}
5976             default_format_node = pool.find(
5977                 "{}Options/defaultFormat".format(option_kind)
5978             )
5979             if default_format_node is not None:
5980                 options["default_format"] = default_format_node.get("type")
5981             options_enums = {
5982                 enum.get("name"): [value.text for value in enum.findall("value")]
5983                 for enum in pool.findall("{}Options/enum".format(option_kind))
5984             }
5985             if options_enums:
5986                 options.update(options_enums)
5987             if options:
5988                 if "options" not in pool_caps:
5989                     pool_caps["options"] = {}
5990                 kind = option_kind if option_kind != "vol" else "volume"
5991                 pool_caps["options"][kind] = options
5992         return pool_caps
5993     return [_parse_pool_caps(pool) for pool in doc.findall("pool")]
5994 def _pool_capabilities(conn):
5995     """
5996     Return the hypervisor connection storage pool capabilities.
5997     :param conn: opened libvirt connection to use
5998     """
5999     has_pool_capabilities = bool(getattr(conn, "getStoragePoolCapabilities", None))
6000     if has_pool_capabilities:
6001         caps = ElementTree.fromstring(conn.getStoragePoolCapabilities())
6002         pool_types = _parse_pools_caps(caps)
6003     else:
6004         all_hypervisors = ["xen", "kvm", "bhyve"]
6005         images_formats = [
6006             "none",
6007             "raw",
6008             "dir",
6009             "bochs",
6010             "cloop",
6011             "dmg",
6012             "iso",
6013             "vpc",
6014             "vdi",
6015             "fat",
6016             "vhd",
6017             "ploop",
6018             "cow",
6019             "qcow",
6020             "qcow2",
6021             "qed",
6022             "vmdk",
6023         ]
6024         common_drivers = [
6025             {
6026                 "default_source_format": "auto",
6027                 "source_formats": [
6028                     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"auto",
6029                     "ext2",
6030                     "ext3",
6031                     "ext4",
6032                     "ufs",
6033                     "iso9660",
6034                     "udf",
6035                     "gfs",
6036                     "gfs2",
6037                     "vfat",
6038                     "hfs+",
6039                     "xfs",
6040                     "ocfs2",
6041                 ],
6042                 "default_target_format": "raw",
6043                 "target_formats": images_formats,
6044             },
6045             {
6046                 "name": "dir",
6047                 "default_target_format": "raw",
6048                 "target_formats": images_formats,
6049             },
6050             {"name": "iscsi"},
6051             {"name": "scsi"},
6052             {
6053                 "name": "logical",
6054                 "default_source_format": "lvm2",
6055                 "source_formats": ["unknown", "lvm2"],
6056             },
6057             {
6058                 "name": "netfs",
6059                 "default_source_format": "auto",
6060                 "source_formats": ["auto", "nfs", "glusterfs", "cifs"],
6061                 "default_target_format": "raw",
6062                 "target_formats": images_formats,
6063             },
6064             {
6065                 "name": "disk",
6066                 "default_source_format": "unknown",
6067                 "source_formats": [
6068                     "unknown",
6069                     "dos",
6070                     "dvh",
6071                     "gpt",
6072                     "mac",
6073                     "bsd",
6074                     "pc98",
6075                     "sun",
6076                     "lvm2",
6077                 ],
6078                 "default_target_format": "none",
6079                 "target_formats": [
6080                     "none",
6081                     "linux",
6082                     "fat16",
6083                     "fat32",
6084                     "linux-swap",
6085                     "linux-lvm",
6086                     "linux-raid",
6087                     "extended",
6088                 ],
6089             },
6090             {"name": "mpath"},
6091             {"name": "rbd", "default_target_format": "raw", "target_formats": []},
6092             {
6093                 "name": "sheepdog",
6094                 "version": 10000,
6095                 "hypervisors": ["kvm"],
6096                 "default_target_format": "raw",
6097                 "target_formats": images_formats,
6098             },
6099             {
6100                 "name": "gluster",
6101                 "version": 1002000,
6102                 "hypervisors": ["kvm"],
6103                 "default_target_format": "raw",
6104                 "target_formats": images_formats,
6105             },
6106             {"name": "zfs", "version": 1002008, "hypervisors": ["bhyve"]},
6107             {
6108                 "name": "iscsi-direct",
6109                 "version": 4007000,
6110                 "hypervisors": ["kvm", "xen"],
6111             },
6112         ]
6113         libvirt_version = conn.getLibVersion(</b></font>)
6114         hypervisor = get_hypervisor()
6115         def _get_backend_output(backend):
6116             output = {
6117                 "name": backend["name"],
6118                 "supported": (
6119                     not backend.get("version") or libvirt_version &gt;= backend["version"]
6120                 )
6121                 and hypervisor in backend.get("hypervisors", all_hypervisors),
6122                 "options": {
6123                     "pool": {
6124                         "default_format": backend.get("default_source_format"),
6125                         "sourceFormatType": backend.get("source_formats"),
6126                     },
6127                     "volume": {
6128                         "default_format": backend.get("default_target_format"),
6129                         "targetFormatType": backend.get("target_formats"),
6130                     },
6131                 },
6132             }
6133             for option_kind in ["pool", "volume"]:
6134                 if not [
6135                     value
6136                     for value in output["options"][option_kind].values()
6137                     if value is not None
6138                 ]:
6139                     del output["options"][option_kind]
6140             if not output["options"]:
6141                 del output["options"]
6142             return output
6143         pool_types = [_get_backend_output(backend) for backend in common_drivers]
6144     return {
6145         "computed": not has_pool_capabilities,
6146         "pool_types": pool_types,
6147     }
6148 def pool_capabilities(**kwargs):
6149     """
6150     Return the hypervisor connection storage pool capabilities.
6151     The returned data are either directly extracted from libvirt or computed.
6152     In the latter case some pool types could be listed as supported while they
6153     are not. To distinguish between the two cases, check the value of the ``computed`` property.
6154     :param connection: libvirt connection URI, overriding defaults
6155     :param username: username to connect with, overriding defaults
6156     :param password: password to connect with, overriding defaults
6157     .. versionadded:: 3000
6158     CLI Example:
6159     .. code-block:: bash
6160         salt '*' virt.pool_capabilities
6161     """
6162     try:
6163         conn = __get_conn(**kwargs)
6164         return _pool_capabilities(conn)
6165     finally:
6166         conn.close()
6167 def pool_define(
6168     name,
6169     ptype,
6170     target=None,
6171     permissions=None,
6172     source_devices=None,
6173     source_dir=None,
6174     source_initiator=None,
6175     source_adapter=None,
6176     source_hosts=None,
6177     source_auth=None,
6178     source_name=None,
6179     source_format=None,
6180     transient=False,
6181     start=True,  # pylint: disable=redefined-outer-name
6182     **kwargs
6183 ):
6184     """
6185     Create libvirt pool.
6186     :param name: Pool name
6187     :param ptype:
6188         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
6189         possible values.
6190     :param target: Pool full path target
6191     :param permissions:
6192         Permissions to set on the target folder. This is mostly used for filesystem-based
6193         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6194     :param source_devices:
6195         List of source devices for pools backed by physical devices. (Default: ``None``)
6196         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
6197         keys. The path is the qualified name for iSCSI devices.
6198         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6199         for more information on the use of ``part_separator``
6200     :param source_dir:
6201         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
6202         (Default: ``None``)
6203     :param source_initiator:
6204         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
6205         .. versionadded:: 3000
6206     :param source_adapter:
6207         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
6208         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
6209         and ``parent_address`` keys.
6210         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
6211         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
6212         ``slot`` and ``function`` properties.
6213         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6214         for the meaning and possible values of these properties.
6215     :param source_hosts:
6216         List of source for pools backed by storage from remote servers. Each item is the hostname
6217         optionally followed by the port separated by a colon. (Default: ``None``)
6218     :param source_auth:
6219         Source authentication details. (Default: ``None``)
6220         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
6221         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
6222         The ``secret`` value links to a libvirt secret object. It is a dictionary with
6223         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
6224         Examples:
6225         .. code-block:: python
6226             source_auth={
6227                 'type': 'ceph',
6228                 'username': 'admin',
6229                 'secret': {
6230                     'type': 'uuid',
6231                     'value': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
6232                 }
6233             }
6234         .. code-block:: python
6235             source_auth={
6236                 'type': 'chap',
6237                 'username': 'myname',
6238                 'secret': {
6239                     'type': 'usage',
6240                     'value': 'mycluster_myname'
6241                 }
6242             }
6243         Since 3000, instead the source authentication can only contain ``username``
6244         and ``password`` properties. In this case the libvirt secret will be defined and used.
6245         For Ceph authentications a base64 encoded key is expected.
6246     :param source_name:
6247         Identifier of name-based sources.
6248     :param source_format:
6249         String representing the source format. The possible values are depending on the
6250         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
6251         the possible values.
6252     :param start: Pool start (default True)
6253     :param transient:
6254         When ``True``, the pool will be automatically undefined after being stopped.
6255         Note that a transient pool will force ``start`` to ``True``. (Default: ``False``)
6256     :param connection: libvirt connection URI, overriding defaults
6257     :param username: username to connect with, overriding defaults
6258     :param password: password to connect with, overriding defaults
6259     .. _pool-define-permissions:
6260     .. rubric:: Permissions definition
6261     The permissions are described by a dictionary containing the following keys:
6262     mode
6263         The octal representation of the permissions. (Default: `0711`)
6264     owner
6265         the numeric user ID of the owner. (Default: from the parent folder)
6266     group
6267         the numeric ID of the group. (Default: from the parent folder)
6268     label
6269         the SELinux label. (Default: `None`)
6270     .. rubric:: CLI Example:
6271     Local folder pool:
6272     .. code-block:: bash
6273         salt '*' virt.pool_define somepool dir target=/srv/mypool \
6274                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
6275     CIFS backed pool:
6276     .. code-block:: bash
6277         salt '*' virt.pool_define myshare netfs source_format=cifs \
6278                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
6279     .. versionadded:: 2019.2.0
6280     """
6281     conn = __get_conn(**kwargs)
6282     auth = _pool_set_secret(conn, ptype, name, source_auth)
6283     pool_xml = _gen_pool_xml(
6284         name,
6285         ptype,
6286         target,
6287         permissions=permissions,
6288         source_devices=source_devices,
6289         source_dir=source_dir,
6290         source_adapter=source_adapter,
6291         source_hosts=source_hosts,
6292         source_auth=auth,
6293         source_name=source_name,
6294         source_format=source_format,
6295         source_initiator=source_initiator,
6296     )
6297     try:
6298         if transient:
6299             pool = conn.storagePoolCreateXML(pool_xml)
6300         else:
6301             pool = conn.storagePoolDefineXML(pool_xml)
6302             if start:
6303                 pool.create()
6304     except libvirt.libvirtError as err:
6305         raise err  # a real error we should report upwards
6306     finally:
6307         conn.close()
6308     return True
6309 def _pool_set_secret(
6310     conn, pool_type, pool_name, source_auth, uuid=None, usage=None, test=False
6311 ):
6312     secret_types = {"rbd": "ceph", "iscsi": "chap", "iscsi-direct": "chap"}
6313     secret_type = secret_types.get(pool_type)
6314     auth = source_auth
6315     if source_auth and "username" in source_auth and "password" in source_auth:
6316         if secret_type:
6317             secret = None
6318             try:
6319                 if usage:
6320                     usage_type = (
6321                         libvirt.VIR_SECRET_USAGE_TYPE_CEPH
6322                         if secret_type == "ceph"
6323                         else libvirt.VIR_SECRET_USAGE_TYPE_ISCSI
6324                     )
6325                     secret = conn.secretLookupByUsage(usage_type, usage)
6326                 elif uuid:
6327                     secret = conn.secretLookupByUUIDString(uuid)
6328             except libvirt.libvirtError as err:
6329                 log.info("Secret not found: %s", err.get_error_message())
6330             if not secret:
6331                 description = "Passphrase for {} pool created by Salt".format(pool_name)
6332                 if not usage:
6333                     usage = "pool_{}".format(pool_name)
6334                 secret_xml = _gen_secret_xml(secret_type, usage, description)
6335                 if not test:
6336                     secret = conn.secretDefineXML(secret_xml)
6337             password = auth["password"]
6338             if pool_type == "rbd":
6339                 password = base64.b64decode(salt.utils.stringutils.to_bytes(password))
6340             if not test:
6341                 secret.setValue(password)
6342             auth["type"] = secret_type
6343             auth["secret"] = {
6344                 "type": "uuid" if uuid else "usage",
6345                 "value": uuid if uuid else usage,
6346             }
6347     return auth
6348 def pool_update(
6349     name,
6350     ptype,
6351     target=None,
6352     permissions=None,
6353     source_devices=None,
6354     source_dir=None,
6355     source_initiator=None,
6356     source_adapter=None,
6357     source_hosts=None,
6358     source_auth=None,
6359     source_name=None,
6360     source_format=None,
6361     test=False,
6362     **kwargs
6363 ):
6364     """
6365     Update a libvirt storage pool if needed.
6366     If called with test=True, this is also reporting whether an update would be performed.
6367     :param name: Pool name
6368     :param ptype:
6369         Pool type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_  for the
6370         possible values.
6371     :param target: Pool full path target
6372     :param permissions:
6373         Permissions to set on the target folder. This is mostly used for filesystem-based
6374         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6375     :param source_devices:
6376         List of source devices for pools backed by physical devices. (Default: ``None``)
6377         Each item in the list is a dictionary with ``path`` and optionally ``part_separator``
6378         keys. The path is the qualified name for iSCSI devices.
6379         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6380         for more information on the use of ``part_separator``
6381     :param source_dir:
6382         Path to the source directory for pools of type ``dir``, ``netfs`` or ``gluster``.
6383         (Default: ``None``)
6384     :param source_initiator:
6385         Initiator IQN for libiscsi-direct pool types. (Default: ``None``)
6386         .. versionadded:: 3000
6387     :param source_adapter:
6388         SCSI source definition. The value is a dictionary with ``type``, ``name``, ``parent``,
6389         ``managed``, ``parent_wwnn``, ``parent_wwpn``, ``parent_fabric_wwn``, ``wwnn``, ``wwpn``
6390         and ``parent_address`` keys.
6391         The ``parent_address`` value is a dictionary with ``unique_id`` and ``address`` keys.
6392         The address represents a PCI address and is itself a dictionary with ``domain``, ``bus``,
6393         ``slot`` and ``function`` properties.
6394         Report to `this libvirt page &lt;https://libvirt.org/formatstorage.html#StoragePool&gt;`_
6395         for the meaning and possible values of these properties.
6396     :param source_hosts:
6397         List of source for pools backed by storage from remote servers. Each item is the hostname
6398         optionally followed by the port separated by a colon. (Default: ``None``)
6399     :param source_auth:
6400         Source authentication details. (Default: ``None``)
6401         The value is a dictionary with ``type``, ``username`` and ``secret`` keys. The type
6402         can be one of ``ceph`` for Ceph RBD or ``chap`` for iSCSI sources.
6403         The ``secret`` value links to a libvirt secret object. It is a dictionary with
6404         ``type`` and ``value`` keys. The type value can be either ``uuid`` or ``usage``.
6405         Examples:
6406         .. code-block:: python
6407             source_auth={
6408                 'type': 'ceph',
6409                 'username': 'admin',
6410                 'secret': {
6411                     'type': 'uuid',
6412                     'uuid': '2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'
6413                 }
6414             }
6415         .. code-block:: python
6416             source_auth={
6417                 'type': 'chap',
6418                 'username': 'myname',
6419                 'secret': {
6420                     'type': 'usage',
6421                     'uuid': 'mycluster_myname'
6422                 }
6423             }
6424         Since 3000, instead the source authentication can only contain ``username``
6425         and ``password`` properties. In this case the libvirt secret will be defined and used.
6426         For Ceph authentications a base64 encoded key is expected.
6427     :param source_name:
6428         Identifier of name-based sources.
6429     :param source_format:
6430         String representing the source format. The possible values are depending on the
6431         source type. See `libvirt documentation &lt;https://libvirt.org/storage.html&gt;`_ for
6432         the possible values.
6433     :param test: run in dry-run mode if set to True
6434     :param connection: libvirt connection URI, overriding defaults
6435     :param username: username to connect with, overriding defaults
6436     :param password: password to connect with, overriding defaults
6437     .. rubric:: Example:
6438     Local folder pool:
6439     .. code-block:: bash
6440         salt '*' virt.pool_update somepool dir target=/srv/mypool \
6441                                   permissions="{'mode': '0744' 'ower': 107, 'group': 107 }"
6442     CIFS backed pool:
6443     .. code-block:: bash
6444         salt '*' virt.pool_update myshare netfs source_format=cifs \
6445                                   source_dir=samba_share source_hosts="['example.com']" target=/mnt/cifs
6446     .. versionadded:: 3000
6447     """
6448     conn = __get_conn(**kwargs)
6449     try:
6450         pool = conn.storagePoolLookupByName(name)
6451         old_xml = ElementTree.fromstring(pool<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.XMLDesc())
6452         secret_node = old_xml.find("source/auth/secret")
6453         usage = secret_node.get("usage") if secret_node is not None else None
6454         uuid = secret_node.get("uuid") if secret_node is not None else None
6455         auth =</b></font> _pool_set_secret(
6456             conn, ptype, name, source_auth, uuid=uuid, usage=usage, test=test
6457         )
6458         new_xml = ElementTree.fromstring(
6459             _gen_pool_xml(
6460                 name,
6461                 ptype,
6462                 target,
6463                 permissions=permissions,
6464                 source_devices=source_devices,
6465                 source_dir=source_dir,
6466                 source_initiator=source_initiator,
6467                 source_adapter=source_adapter,
6468                 source_hosts=source_hosts,
6469                 source_auth=auth,
6470                 source_name=source_name,
6471                 source_format=source_format,
6472             )
6473         )
6474         elements_to_copy = ["available", "allocation", "capacity", "uuid"]
6475         for to_copy in elements_to_copy:
6476             element = old_xml.find(to_copy)
6477             new_xml.insert(1, element)
6478         _remove_empty_xml_node(xmlutil.strip_spaces(old_xml))
6479         xmlutil.strip_spaces(new_xml)
6480         needs_update = xmlutil.to_dict(old_xml, True) != xmlutil.to_dict(new_xml, True)
6481         if needs_update and not test:
6482             conn.storagePoolDefineXML(xmlutil.element_to_str(new_xml))
6483     finally:
6484         conn.close()
6485     return needs_update
6486 def list_pools(**kwargs):
6487     """
6488     List all storage pools.
6489     :param connection: libvirt connection URI, overriding defaults
6490     :param username: username to connect with, overriding defaults
6491     :param password: password to connect with, overriding defaults
6492     .. versionadded:: 2019.2.0
6493     CLI Example:
6494     .. code-block:: bash
6495         salt '*' virt.list_pools
6496     """
6497     conn = __get_conn(**kwargs)
6498     try:
6499         return [pool.name() for pool in conn.listAllStoragePools()]
6500     finally:
6501         conn.close()
6502 def pool_info(name=None, **kwargs):
6503     """
6504     Return information on a storage pool provided its name.
6505     :param name: libvirt storage pool name
6506     :param connection: libvirt connection URI, overriding defaults
6507     :param username: username to connect with, overriding defaults
6508     :param password: password to connect with, overriding defaults
6509     If no name is provided, return the infos for all defined storage pools.
6510     .. versionadded:: 2019.2.0
6511     CLI Example:
6512     .. code-block:: bash
6513         salt '*' virt.pool_info default
6514     """
6515     result = {}
6516     conn = __get_conn(**kwargs)
6517     def _pool_extract_infos(pool):
6518         """
6519         Format the pool info dictionary
6520         :param pool: the libvirt pool object
6521         """
6522         states <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= ["inactive", "building", "running", "degraded", "inaccessible"]
6523         infos = pool.info()
6524         state = states[infos[0]] if infos[0] &lt; len(states) else "unknown"
6525         desc = ElementTree.fromstring(pool.</b></font>XMLDesc())
6526         path_node = desc.find("target/path")
6527         return {
6528             "uuid": pool.UUIDString(),
6529             "state": state,
6530             "capacity": infos[1],
6531             "allocation": infos[2],
6532             "free": infos[3],
6533             "autostart": pool.autostart(),
6534             "persistent": pool.isPersistent(),
6535             "target_path": path_node.text if path_node is not None else None,
6536             "type": desc.get("type"),
6537         }
6538     try:
6539         pools = [
6540             pool
6541             for pool in conn.listAllStoragePools()
6542             if name is None or pool.name() == name
6543         ]
6544         result = {pool.name(): _pool_extract_infos(pool) for pool in pools}
6545     except libvirt.libvirtError as err:
6546         log.debug("Silenced libvirt error: %s", err)
6547     finally:
6548         conn.close()
6549     return result
6550 def pool_get_xml(name, **kwargs):
6551     """
6552     Return the XML definition of a virtual storage pool
6553     :param name: libvirt storage pool name
6554     :param connection: libvirt connection URI, overriding defaults
6555     :param username: username to connect with, overriding defaults
6556     :param password: password to connect with, overriding defaults
6557     .. versionadded:: 3000
6558     CLI Example:
6559     .. code-block:: bash
6560         salt '*' virt.pool_get_xml default
6561     """
6562     conn = __get_conn(**kwargs)
6563     try:
6564         return conn.storagePoolLookupByName(name).XMLDesc()
6565     finally:
6566         conn.close()
6567 def pool_start(name, **kwargs):
6568     """
6569     Start a defined libvirt storage pool.
6570     :param name: libvirt storage pool name
6571     :param connection: libvirt connection URI, overriding defaults
6572     :param username: username to connect with, overriding defaults
6573     :param password: password to connect with, overriding defaults
6574     .. versionadded:: 2019.2.0
6575     CLI Example:
6576     .. code-block:: bash
6577         salt '*' virt.pool_start default
6578     """
6579     conn = __get_conn(**kwargs)
6580     try:
6581         pool = conn.storagePoolLookupByName(name)
6582         return not bool(pool.create())
6583     finally:
6584         conn.close()
6585 def pool_build(name, **kwargs):
6586     """
6587     Build a defined libvirt storage pool.
6588     :param name: libvirt storage pool name
6589     :param connection: libvirt connection URI, overriding defaults
6590     :param username: username to connect with, overriding defaults
6591     :param password: password to connect with, overriding defaults
6592     .. versionadded:: 2019.2.0
6593     CLI Example:
6594     .. code-block:: bash
6595         salt '*' virt.pool_build default
6596     """
6597     conn = __get_conn(**kwargs)
6598     try:
6599         pool = conn.storagePoolLookupByName(name)
6600         return not bool(pool.build())
6601     finally:
6602         conn.close()
6603 def pool_stop(name, **kwargs):
6604     """
6605     Stop a defined libvirt storage pool.
6606     :param name: libvirt storage pool name
6607     :param connection: libvirt connection URI, overriding defaults
6608     :param username: username to connect with, overriding defaults
6609     :param password: password to connect with, overriding defaults
6610     .. versionadded:: 2019.2.0
6611     CLI Example:
6612     .. code-block:: bash
6613         salt '*' virt.pool_stop default
6614     """
6615     conn = __get_conn(**kwargs)
6616     try:
6617         pool = conn.storagePoolLookupByName(name)
6618         return not bool(pool.destroy())
6619     finally:
6620         conn.close()
6621 def pool_undefine(name, **kwargs):
6622     """
6623     Remove a defined libvirt storage pool. The pool needs to be stopped before calling.
6624     :param name: libvirt storage pool name
6625     :param connection: libvirt connection URI, overriding defaults
6626     :param username: username to connect with, overriding defaults
6627     :param password: password to connect with, overriding defaults
6628     .. versionadded:: 2019.2.0
6629     CLI Example:
6630     .. code-block:: bash
6631         salt '*' virt.pool_undefine default
6632     """
6633     conn = __get_conn(**kwargs)
6634     try:
6635         pool = conn.storagePoolLookupByName(name)
6636         desc = ElementTree.fromstring(pool.XMLDesc())
6637         auth_node = desc.find("source/auth")
6638         if auth_node is not None:
6639             auth_types = {
6640                 "ceph": libvirt.VIR_SECRET_USAGE_TYPE_CEPH,
6641                 "iscsi": libvirt.VIR_SECRET_USAGE_TYPE_ISCSI,
6642             }
6643             secret_type = auth_types[auth_node.get("type")]
6644             secret_usage = auth_node.find("secret").get("usage")
6645             if secret_type and "pool_{}".format(name) == secret_usage:
6646                 secret = conn.secretLookupByUsage(secret_type, secret_usage)
6647                 secret.undefine()
6648         return not bool(pool.undefine())
6649     finally:
6650         conn.close()
6651 def pool_delete(name, **kwargs):
6652     """
6653     Delete the resources of a defined libvirt storage pool.
6654     :param name: libvirt storage pool name
6655     :param connection: libvirt connection URI, overriding defaults
6656     :param username: username to connect with, overriding defaults
6657     :param password: password to connect with, overriding defaults
6658     .. versionadded:: 2019.2.0
6659     CLI Example:
6660     .. code-block:: bash
6661         salt '*' virt.pool_delete default
6662     """
6663     conn = __get_conn(**kwargs)
6664     try:
6665         pool = conn.storagePoolLookupByName(name)
6666         return not bool(pool.delete(libvirt.VIR_STORAGE_POOL_DELETE_NORMAL))
6667     finally:
6668         conn.close()
6669 def pool_refresh(name, **kwargs):
6670     """
6671     Refresh a defined libvirt storage pool.
6672     :param name: libvirt storage pool name
6673     :param connection: libvirt connection URI, overriding defaults
6674     :param username: username to connect with, overriding defaults
6675     :param password: password to connect with, overriding defaults
6676     .. versionadded:: 2019.2.0
6677     CLI Example:
6678     .. code-block:: bash
6679         salt '*' virt.pool_refresh default
6680     """
6681     conn = __get_conn(**kwargs)
6682     try:
6683         pool = conn.storagePoolLookupByName(name)
6684         return not bool(pool.refresh())
6685     finally:
6686         conn.close()
6687 def pool_set_autostart(name, state="on", **kwargs):
6688     """
6689     Set the autostart flag on a libvirt storage pool so that the storage pool
6690     will start with the host system on reboot.
6691     :param name: libvirt storage pool name
6692     :param state: 'on' to auto start the pool, anything else to mark the
6693                   pool not to be started when the host boots
6694     :param connection: libvirt connection URI, overriding defaults
6695     :param username: username to connect with, overriding defaults
6696     :param password: password to connect with, overriding defaults
6697     .. versionadded:: 2019.2.0
6698     CLI Example:
6699     .. code-block:: bash
6700         salt "*" virt.pool_set_autostart &lt;pool&gt; &lt;on | off&gt;
6701     """
6702     conn = __get_conn(**kwargs)
6703     try:
6704         pool = conn.storagePoolLookupByName(name)
6705         return not bool(pool.setAutostart(1 if state == "on" else 0))
6706     finally:
6707         conn.close()
6708 def pool_list_volumes(name, **kwargs):
6709     """
6710     List the volumes contained in a defined libvirt storage pool.
6711     :param name: libvirt storage pool name
6712     :param connection: libvirt connection URI, overriding defaults
6713     :param username: username to connect with, overriding defaults
6714     :param password: password to connect with, overriding defaults
6715     .. versionadded:: 2019.2.0
6716     CLI Example:
6717     .. code-block:: bash
6718         salt "*" virt.pool_list_volumes &lt;pool&gt;
6719     """
6720     conn = __get_conn(**kwargs)
6721     try:
6722         pool = conn.storagePoolLookupByName(name)
6723         return pool.listVolumes()
6724     finally:
6725         conn.close()
6726 def _get_storage_vol(conn, pool, vol):
6727     """
6728     Helper function getting a storage volume. Will throw a libvirtError
6729     if the pool or the volume couldn't be found.
6730     :param conn: libvirt connection object to use
6731     :param pool: pool name
6732     :param vol: volume name
6733     """
6734     pool_obj = conn.storagePoolLookupByName(pool)
6735     return pool_obj.storageVolLookupByName(vol)
6736 def _is_valid_volume(vol):
6737     """
6738     Checks whether a volume is valid for further use since those may have disappeared since
6739     the last pool refresh.
6740     """
6741     try:
6742         def discarder(ctxt, error):  # pylint: disable=unused-argument
6743             log.debug("Ignore libvirt error: %s", error[2])
6744         libvirt.registerErrorHandler(discarder, None)
6745         vol.info()
6746         libvirt.registerErrorHandler(None, None)
6747         return True
6748     except libvirt.libvirtError as err:
6749         return False
6750 def _get_all_volumes_paths(conn):
6751     """
6752     Extract the path, name, pool name and backing stores path of all volumes.
6753     :param conn: libvirt connection to use
6754     """
6755     pools = [
6756         pool
6757         for pool in conn.listAllStoragePools()
6758         if pool.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
6759     ]
6760     volumes = {}
6761         pool_volumes = {
6762             volume.path(): {
6763                 "pool": pool<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.name(),
6764                 "name": volume.name(),
6765                 "backing_stores": [
6766                     path.text
6767                     for path in ElementTree.fromstring(volume.XMLDesc()).findall(
6768                         ".//backingStore/path"
6769                     )
6770                 ],
6771             }
6772             for volume in pool.listAllVolumes()
6773             if _is_valid_volume(</b></font>volume)
6774         }
6775         volumes.update(pool_volumes)
6776     return volumes
6777 def volume_infos(pool=None, volume=None, **kwargs):
6778     """
6779     Provide details on a storage volume. If no volume name is provided, the infos
6780     all the volumes contained in the pool are provided. If no pool is provided,
6781     the infos of the volumes of all pools are output.
6782     :param pool: libvirt storage pool name (default: ``None``)
6783     :param volume: name of the volume to get infos from (default: ``None``)
6784     :param connection: libvirt connection URI, overriding defaults
6785     :param username: username to connect with, overriding defaults
6786     :param password: password to connect with, overriding defaults
6787     .. versionadded:: 3000
6788     CLI Example:
6789     .. code-block:: bash
6790         salt "*" virt.volume_infos &lt;pool&gt; &lt;volume&gt;
6791     """
6792     result = {}
6793     conn = __get_conn(**kwargs)
6794     try:
6795         backing_stores = _get_all_volumes_paths(conn)
6796         try:
6797             domains = _get_domain(conn)
6798             domains_list = domains if isinstance(domains, list) else [domains]
6799         except CommandExecutionError:
6800             domains_list = []
6801         disks = {
6802             domain.name(): {
6803                 node.get("file")
6804                 for node in ElementTree.fromstring(domain.XMLDesc(0)).findall(
6805                     ".//disk/source/[@file]"
6806                 )
6807             }
6808             for domain in domains_list
6809         }
6810         def _volume_extract_infos(vol):
6811             """
6812             Format the volume info dictionary
6813             :param vol: the libvirt storage volume object.
6814             """
6815             types = ["file", "block", "dir", "network", "netdir", "ploop"]
6816             infos = vol.info()
6817             vol_xml = ElementTree.fromstring(vol.XMLDesc())
6818             backing_store_path = vol_xml.find("./backingStore/path")
6819             backing_store_format = vol_xml.find("./backingStore/format")
6820             backing_store = None
6821             if backing_store_path is not None:
6822                 backing_store = {
6823                     "path": backing_store_path.text,
6824                     "format": backing_store_format.get("type")
6825                     if backing_store_format is not None
6826                     else None,
6827                 }
6828             format_node = vol_xml.find("./target/format")
6829             used_by = []
6830             if vol.path():
6831                 as_backing_store = {
6832                     path
6833                     for (path, volume) in backing_stores.items()
6834                     if vol.path() in volume.get("backing_stores")
6835                 }
6836                 used_by = [
6837                     vm_name
6838                     for (vm_name, vm_disks) in disks.items()
6839                     if vm_disks &amp; as_backing_store or vol.path() in vm_disks
6840                 ]
6841             return {
6842                 "type": types[infos[0]] if infos[0] &lt; len(types) else "unknown",
6843                 "key": vol.key(),
6844                 "path": vol.path(),
6845                 "capacity": infos[1],
6846                 "allocation": infos[2],
6847                 "used_by": used_by,
6848                 "backing_store": backing_store,
6849             }
6850         pools <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
6851             obj
6852             for obj in conn.listAllStoragePools()
6853             if (pool is None or obj.name() == pool)
6854             and obj.info()[0] == libvirt.VIR_STORAGE_POOL_RUNNING
6855         ]
6856         vols = {
6857             pool_obj.name(): {
6858                 vol</b></font>.name(): _volume_extract_infos(vol)
6859                 for vol in pool_obj.listAllVolumes()
6860                 if (volume is None or vol.name() == volume) and _is_valid_volume(vol)
6861             }
6862             for pool_obj in pools
6863         }
6864         return {pool_name: volumes for (pool_name, volumes) in vols.items() if volumes}
6865     except libvirt.libvirtError as err:
6866         log.debug("Silenced libvirt error: %s", err)
6867     finally:
6868         conn.close()
6869     return result
6870 def volume_delete(pool, volume, **kwargs):
6871     """
6872     Delete a libvirt managed volume.
6873     :param pool: libvirt storage pool name
6874     :param volume: name of the volume to delete
6875     :param connection: libvirt connection URI, overriding defaults
6876     :param username: username to connect with, overriding defaults
6877     :param password: password to connect with, overriding defaults
6878     .. versionadded:: 3000
6879     CLI Example:
6880     .. code-block:: bash
6881         salt "*" virt.volume_delete &lt;pool&gt; &lt;volume&gt;
6882     """
6883     conn = __get_conn(**kwargs)
6884     try:
6885         vol = _get_storage_vol(conn, pool, volume)
6886         return not bool(vol.delete())
6887     finally:
6888         conn.close()
6889 def volume_define(
6890     pool,
6891     name,
6892     size,
6893     allocation=0,
6894     format=None,
6895     type=None,
6896     permissions=None,
6897     backing_store=None,
6898     nocow=False,
6899     **kwargs
6900 ):
6901     """
6902     Create libvirt volume.
6903     :param pool: name of the pool to create the volume in
6904     :param name: name of the volume to define
6905     :param size: capacity of the volume to define in MiB
6906     :param allocation: allocated size of the volume in MiB. Defaults to 0.
6907     :param format:
6908         volume format. The allowed values are depending on the pool type.
6909         Check the virt.pool_capabilities output for the possible values and the default.
6910     :param type:
6911         type of the volume. One of file, block, dir, network, netdiri, ploop or None.
6912         By default, the type is guessed by libvirt from the pool type.
6913     :param permissions:
6914         Permissions to set on the target folder. This is mostly used for filesystem-based
6915         pool types. See :ref:`pool-define-permissions` for more details on this structure.
6916     :param backing_store:
6917         dictionary describing a backing file for the volume. It must contain a ``path``
6918         property pointing to the base volume and a ``format`` property defining the format
6919         of the base volume.
6920         The base volume format will not be guessed for security reasons and is thus mandatory.
6921     :param nocow: disable COW for the volume.
6922     :param connection: libvirt connection URI, overriding defaults
6923     :param username: username to connect with, overriding defaults
6924     :param password: password to connect with, overriding defaults
6925     .. rubric:: CLI Example:
6926     Volume on ESX:
6927     .. code-block:: bash
6928         salt '*' virt.volume_define "[local-storage]" myvm/myvm.vmdk vmdk 8192
6929     QCow2 volume with backing file:
6930     .. code-block:: bash
6931         salt '*' virt.volume_define default myvm.qcow2 qcow2 8192 \
6932                             permissions="{'mode': '0775', 'owner': '123', 'group': '345'"}" \
6933                             backing_store="{'path': '/path/to/base.img', 'format': 'raw'}" \
6934                             nocow=True
6935     .. versionadded:: 3001
6936     """
6937     ret = False
6938     try:
6939         conn = __get_conn(**kwargs)
6940         pool_obj = conn.storagePoolLookupByName(pool)
6941         pool_type = ElementTree.fromstring(pool_obj.XMLDesc()).get("type")
6942         new_allocation = allocation
6943         if pool_type == "logical" and size != allocation:
6944             new_allocation = size
6945         xml = _gen_vol_xml(
6946             name,
6947             size,
6948             format=format,
6949             allocation=new_allocation,
6950             type=type,
6951             permissions=permissions,
6952             backing_store=backing_store,
6953             nocow=nocow,
6954         )
6955         ret = _define_vol_xml_str(conn, xml, pool=pool)
6956     except libvirt.libvirtError as err:
6957         raise CommandExecutionError(err.get_error_message())
6958     finally:
6959         conn.close()
6960     return ret
6961 def _volume_upload(conn, pool, volume, file, offset=0, length=0, sparse=False):
6962     """
6963     Function performing the heavy duty for volume_upload but using an already
6964     opened libvirt connection.
6965     """
6966     def handler(stream, nbytes, opaque):
6967         return os.read(opaque, nbytes)
6968     def holeHandler(stream, opaque):
6969         """
6970         Taken from the sparsestream.py libvirt-python example.
6971         """
6972         fd = opaque
6973         cur = os.lseek(fd, 0, os.SEEK_CUR)
6974         try:
6975             data = os.lseek(fd, cur, os.SEEK_DATA)
6976         except OSError as e:
6977             if e.errno != 6:
6978                 raise e
6979             else:
6980                 data = -1
6981         if data &lt; 0:
6982             inData = False
6983             eof = os.lseek(fd, 0, os.SEEK_END)
6984             if eof &lt; cur:
6985                 raise RuntimeError("Current position in file after EOF: {}".format(cur))
6986             sectionLen = eof - cur
6987         else:
6988             if data &gt; cur:
6989                 inData = False
6990                 sectionLen = data - cur
6991             else:
6992                 inData = True
6993                 hole = os.lseek(fd, data, os.SEEK_HOLE)
6994                 if hole &lt; 0:
6995                     raise RuntimeError("No trailing hole")
6996                 if hole == data:
6997                     raise RuntimeError("Impossible happened")
6998                 else:
6999                     sectionLen = hole - data
7000         os.lseek(fd, cur, os.SEEK_SET)
7001         return [inData, sectionLen]
7002     def skipHandler(stream, length, opaque):
7003         return os.lseek(opaque, length, os.SEEK_CUR)
7004     stream = None
7005     ret = False
7006     try:
7007         pool_obj <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= conn.storagePoolLookupByName(pool)
7008         vol_obj = pool_obj.storageVolLookupByName(volume)
7009         stream = conn.newStream()
7010         fd = os.open(</b></font>file, os.O_RDONLY)
7011         vol_obj.upload(
7012             stream,
7013             offset,
7014             length,
7015             libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM if sparse else 0,
7016         )
7017         if sparse:
7018             stream.sparseSendAll(handler, holeHandler, skipHandler, fd)
7019         else:
7020             stream.sendAll(handler, fd)
7021         ret = True
7022     except libvirt.libvirtError as err:
7023         raise CommandExecutionError(err.get_error_message())
7024     finally:
7025         if fd:
7026             try:
7027                 os.close(fd)
7028             except OSError as err:
7029                 if stream:
7030                     stream.abort()
7031                 if ret:
7032                     raise CommandExecutionError(
7033                         "Failed to close file: {}".format(err.strerror)
7034                     )
7035         if stream:
7036             try:
7037             except libvirt.libvirtError as err:
7038                 if ret:
7039                     raise CommandExecutionError<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
7040                         "Failed to finish stream: {}".format(err.get_error_message())
7041                     )
7042     return ret
7043 def volume_upload(pool, volume, file, offset=0, length=0, sparse=False, **kwargs):
7044     """
7045     Create libvirt volume.
7046     :param pool: name of the pool to create the volume in
7047     :param name: name of the volume to define
7048     :param file: the file to upload to the volume
7049     :param offset: where to start writing the data in the volume
7050     :param length: amount of bytes to transfer to the volume
7051     :param sparse: set to True to preserve data sparsiness.
7052     :param connection: libvirt connection URI, overriding defaults
7053     :param username: username to connect with, overriding defaults
7054     :param password: password to connect with, overriding defaults
7055     .. rubric:: CLI Example:
7056     .. code-block:: bash
7057         salt '*' virt.volume_upload default myvm.qcow2 /path/to/disk.qcow2
7058     .. versionadded:: 3001
7059     """
7060     conn =</b></font> __get_conn(**kwargs)
7061     ret = False
7062     try:
7063         ret = _volume_upload(
7064             conn, pool, volume, file, offset=offset, length=length, sparse=sparse
7065         )
7066     finally:
7067         conn.close()
7068     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
