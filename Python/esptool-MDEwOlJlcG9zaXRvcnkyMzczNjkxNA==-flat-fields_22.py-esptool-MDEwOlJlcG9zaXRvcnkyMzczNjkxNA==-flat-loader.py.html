
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.42942942942943%, Tokens: 9</h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_22.py</h3>
            <pre><code>1  import binascii
2  import struct
3  import time
4  from bitstring import BitArray
5  import esptool
6  import reedsolo
7  from .mem_definition import EfuseDefineBlocks, EfuseDefineFields, EfuseDefineRegisters
8  from .. import base_fields
9  from .. import util
10  class EfuseBlock(base_fields.EfuseBlockBase):
11      def len_of_burn_unit(self):
12          return 8 * 4
13      def __init__(self, parent, param, skip_read=False):
14          parent.read_coding_scheme()
15          super(EfuseBlock, self).__init__(parent, param, skip_read=skip_read)
16      def apply_coding_scheme(self):
17          data = self.get_raw(from_read=False)[::-1]
18          if len(data) < self.len_of_burn_unit():
19              add_empty_bytes = self.len_of_burn_unit() - len(data)
20              data = data + (b"\x00" * add_empty_bytes)
21          if self.get_coding_scheme() == self.parent.REGS.CODING_SCHEME_RS:
22              rs = reedsolo.RSCodec(12)
23              encoded_data = rs.encode([x for x in data])
24              words = struct.unpack("<" + "I" * 11, encoded_data)
25          else:
26              words = struct.unpack("<" + ("I" * (len(data) // 4)), data)
27          return words
28  class EspEfuses(base_fields.EspEfusesBase):
29      debug = False
30      do_not_confirm = False
31      def __init__(self, esp, skip_connect=False, debug=False, do_not_confirm=False):
32          self.Blocks = EfuseDefineBlocks()
33          self.Fields = EfuseDefineFields()
34          self.REGS = EfuseDefineRegisters
35          self.BURN_BLOCK_DATA_NAMES = self.Blocks.get_burn_block_data_names()
36          self.BLOCKS_FOR_KEYS = self.Blocks.get_blocks_for_keys()
37          self._esp = esp
38          self.debug = debug
39          self.do_not_confirm = do_not_confirm
40          if esp.CHIP_NAME != "ESP32-H2(beta1)":
41              raise esptool.FatalError(
42                  "Expected the 'esp' param for ESP32-H2(beta1) chip but got for '%s'."
43                  % (esp.CHIP_NAME)
44              )
45          if not skip_connect:
46              flags = self._esp.get_security_info()["flags"]
47              GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE = 1 << 2
48              if flags & GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE:
49                  raise esptool.FatalError(
50                      "Secure Download Mode is enabled. The tool can not read eFuses."
51                  )
52          self.blocks = [
53              EfuseBlock(self, self.Blocks.get(block), skip_read=skip_connect)
54              for block in self.Blocks.BLOCKS
55          ]
56          if not skip_connect:
57              self.get_coding_scheme_warnings()
58          self.efuses = [EfuseField.convert(self, efuse) for efuse in self.Fields.EFUSES]
59          self.efuses += [
60              EfuseField.convert(self, efuse) for efuse in self.Fields.KEYBLOCKS
61          ]
62          if skip_connect:
63              self.efuses += [
64                  EfuseField.convert(self, efuse)
65                  for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
66              ]
67          else:
68              if self["BLK_VERSION_MAJOR"].get() == 1:
69                  self.efuses += [
70                      EfuseField.convert(self, efuse)
71                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
72                  ]
73              self.efuses += [
74                  EfuseField.convert(self, efuse) for efuse in self.Fields.CALC
75              ]
76      def __getitem__(self, efuse_name):
77          for e in self.efuses:
78              if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
79                  return e
80          new_fields = False
81          for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES:
82              if efuse.name == efuse_name or any(
83                  x == efuse_name for x in efuse.alt_names
84              ):
85                  self.efuses += [
86                      EfuseField.convert(self, efuse)
87                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
88                  ]
89                  new_fields = True
90          if new_fields:
91              for e in self.efuses:
92                  if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
93                      return e
94          raise KeyError
95      def read_coding_scheme(self):
96          self.coding_scheme = self.REGS.CODING_SCHEME_RS
97      def print_status_regs(self):
98          print("")
99          self.blocks[0].print_block(self.blocks[0].err_bitarray, "err__regs", debug=True)
100          print(
101              "{:27} 0x{:08x}".format(
102                  "EFUSE_RD_RS_ERR0_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR0_REG)
103              )
104          )
105          print(
106              "{:27} 0x{:08x}".format(
107                  "EFUSE_RD_RS_ERR1_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR1_REG)
108              )
109          )
110      def efuse_controller_setup(self):
111          self.set_efuse_timing()
112          self.clear_pgm_registers()
113          self.wait_efuse_idle()
114      def write_efuses(self, block):
115          self.efuse_program(block)
116          return self.get_coding_scheme_warnings(silent=True)
117      def clear_pgm_registers(self):
118          self.wait_efuse_idle()
119          for r in range(
120              self.REGS.EFUSE_PGM_DATA0_REG, self.REGS.EFUSE_PGM_DATA0_REG + 32, 4
121          ):
122              self.write_reg(r, 0)
123      def wait_efuse_idle(self):
124          deadline = time.time() + self.REGS.EFUSE_BURN_TIMEOUT
125          while time.time() < deadline:
126              if self.read_reg(self.REGS.EFUSE_STATUS_REG) & 0x7 == 1:
127                  return
128          raise esptool.FatalError(
129              "Timed out waiting for Efuse controller command to complete"
130          )
131      def efuse_program(self, block):
132          self.wait_efuse_idle()
<span onclick='openModal()' class='match'>133          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_WRITE_OP_CODE)
134          self.write_reg(self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_PGM_CMD | (block << 2))
</span>135          self.wait_efuse_idle()
136          self.clear_pgm_registers()
137          self.efuse_read()
138      def efuse_read(self):
139          self.wait_efuse_idle()
140          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_READ_OP_CODE)
141          try:
142              self.write_reg(
143                  self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_READ_CMD, delay_after_us=1000
144              )
145              self.wait_efuse_idle()
146          except esptool.FatalError:
147              secure_download_mode_before = self._esp.secure_download_mode
148              try:
149                  self._esp = self.reconnect_chip(self._esp)
150              except esptool.FatalError:
151                  print("Can not re-connect to the chip")
152                  if not self["DIS_DOWNLOAD_MODE"].get() and self[
153                      "DIS_DOWNLOAD_MODE"
154                  ].get(from_read=False):
155                      print(
156                          "This is the correct behavior as we are actually burning "
157                          "DIS_DOWNLOAD_MODE which disables the connection to the chip"
158                      )
159                      print("DIS_DOWNLOAD_MODE is enabled")
160                      print("Successful")
161                      exit(0)  # finish without errors
162                  raise
163              print("Established a connection with the chip")
164              if self._esp.secure_download_mode and not secure_download_mode_before:
165                  print("Secure download mode is enabled")
166                  if not self["ENABLE_SECURITY_DOWNLOAD"].get() and self[
167                      "ENABLE_SECURITY_DOWNLOAD"
168                  ].get(from_read=False):
169                      print(
170                          "espefuse tool can not continue to work in Secure download mode"
171                      )
172                      print("ENABLE_SECURITY_DOWNLOAD is enabled")
173                      print("Successful")
174                      exit(0)  # finish without errors
175              raise
176      def set_efuse_timing(self):
177          apb_freq = self.get_crystal_freq()
178          if apb_freq != 32:
179              raise esptool.FatalError(
180                  "The eFuse supports only xtal=32M (xtal was %d)" % apb_freq
181              )
182          self.update_reg(self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_NUM_M, 0xFF)
183          self.update_reg(
184              self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_CLK_DIV_M, 0x28
185          )
186          self.update_reg(
187              self.REGS.EFUSE_WR_TIM_CONF1_REG, self.REGS.EFUSE_PWR_ON_NUM_M, 0x3000
188          )
189          self.update_reg(
190              self.REGS.EFUSE_WR_TIM_CONF2_REG, self.REGS.EFUSE_PWR_OFF_NUM_M, 0x190
191          )
192      def get_coding_scheme_warnings(self, silent=False):
193          old_addr_reg = 0
194          reg_value = 0
195          ret_fail = False
196          for block in self.blocks:
197              if block.id == 0:
198                  words = [
199                      self.read_reg(self.REGS.EFUSE_RD_REPEAT_ERR0_REG + offs * 4)
200                      for offs in range(5)
201                  ]
202                  block.err_bitarray.pos = 0
203                  for word in reversed(words):
204                      block.err_bitarray.overwrite(BitArray("uint:32=%d" % word))
205                  block.num_errors = block.err_bitarray.count(True)
206                  block.fail = block.num_errors != 0
207              else:
208                  addr_reg, err_num_mask, err_num_offs, fail_bit = self.REGS.BLOCK_ERRORS[
209                      block.id
210                  ]
211                  if err_num_mask is None or err_num_offs is None or fail_bit is None:
212                      continue
213                  if addr_reg != old_addr_reg:
214                      old_addr_reg = addr_reg
215                      reg_value = self.read_reg(addr_reg)
216                  block.fail = reg_value & (1 << fail_bit) != 0
217                  block.num_errors = (reg_value >> err_num_offs) & err_num_mask
218              ret_fail |= block.fail
219              if not silent and (block.fail or block.num_errors):
220                  print(
221                      "Error(s) in BLOCK%d [ERRORS:%d FAIL:%d]"
222                      % (block.id, block.num_errors, block.fail)
223                  )
224          if (self.debug or ret_fail) and not silent:
225              self.print_status_regs()
226          return ret_fail
227      def summary(self):
228          return ""
229  class EfuseField(base_fields.EfuseFieldBase):
230      @staticmethod
231      def convert(parent, efuse):
232          return {
233              "mac": EfuseMacField,
234              "keypurpose": EfuseKeyPurposeField,
235              "t_sensor": EfuseTempSensor,
236              "adc_tp": EfuseAdcPointCalibration,
237              "wafer": EfuseWafer,
238          }.get(efuse.class_type, EfuseField)(parent, efuse)
239  class EfuseWafer(EfuseField):
240      def get(self, from_read=True):
241          hi_bits = self.parent["WAFER_VERSION_MINOR_HI"].get(from_read)
242          assert self.parent["WAFER_VERSION_MINOR_HI"].bit_len == 1
243          lo_bits = self.parent["WAFER_VERSION_MINOR_LO"].get(from_read)
244          assert self.parent["WAFER_VERSION_MINOR_LO"].bit_len == 3
245          return (hi_bits << 3) + lo_bits
246      def save(self, new_value):
247          raise esptool.FatalError("Burning %s is not supported" % self.name)
248  class EfuseTempSensor(EfuseField):
249      def get(self, from_read=True):
250          value = self.get_bitstring(from_read)
251          sig = -1 if value[0] else 1
252          return sig * value[1:].uint * 0.1
253  class EfuseAdcPointCalibration(EfuseField):
254      def get(self, from_read=True):
255          STEP_SIZE = 4
256          value = self.get_bitstring(from_read)
257          sig = -1 if value[0] else 1
258          return sig * value[1:].uint * STEP_SIZE
259  class EfuseMacField(EfuseField):
260      def check_format(self, new_value_str):
261          if new_value_str is None:
262              raise esptool.FatalError(
263                  "Required MAC Address in AA:CD:EF:01:02:03 format!"
264              )
265          if new_value_str.count(":") != 5:
266              raise esptool.FatalError(
267                  "MAC Address needs to be a 6-byte hexadecimal format "
268                  "separated by colons (:)!"
269              )
270          hexad = new_value_str.replace(":", "")
271          if len(hexad) != 12:
272              raise esptool.FatalError(
273                  "MAC Address needs to be a 6-byte hexadecimal number "
274                  "(12 hexadecimal characters)!"
275              )
276          bindata = binascii.unhexlify(hexad)
277          if esptool.util.byte(bindata, 0) & 0x01:
278              raise esptool.FatalError("Custom MAC must be a unicast MAC!")
279          return bindata
280      def check(self):
281          errs, fail = self.parent.get_block_errors(self.block)
282          if errs != 0 or fail:
283              output = "Block%d has ERRORS:%d FAIL:%d" % (self.block, errs, fail)
284          else:
285              output = "OK"
286          return "(" + output + ")"
287      def get(self, from_read=True):
288          if self.name == "CUSTOM_MAC":
289              mac = self.get_raw(from_read)[::-1] + self.parent["MAC_EXT"].get_raw(
290                  from_read
291              )
292          elif self.name == "MAC":
293              mac = self.get_raw(from_read) + self.parent["MAC_EXT"].get_raw(from_read)
294          else:
295              mac = self.get_raw(from_read)
296          return "%s %s" % (util.hexify(mac, ":"), self.check())
297      def save(self, new_value):
298          def print_field(e, new_value):
299              print(
300                  "    - '{}' ({}) {} -> {}".format(
301                      e.name, e.description, e.get_bitstring(), new_value
302                  )
303              )
304          if self.name == "CUSTOM_MAC":
305              bitarray_mac = self.convert_to_bitstring(new_value)
306              print_field(self, bitarray_mac)
307              super(EfuseMacField, self).save(new_value)
308          else:
309              raise esptool.FatalError("Writing Factory MAC address is not supported")
310  class EfuseKeyPurposeField(EfuseField):
311      KEY_PURPOSES = [
312          ("USER",                         0,  None,       None,      "no_need_rd_protect"),   # User purposes (software-only use)
313          ("RESERVED",                     1,  None,       None,      "no_need_rd_protect"),   # Reserved
314          ("XTS_AES_128_KEY",              4,  None,       "Reverse", "need_rd_protect"),      # XTS_AES_128_KEY (flash/PSRAM encryption)
315          ("HMAC_DOWN_ALL",                5,  None,       None,      "need_rd_protect"),      # HMAC Downstream mode
316          ("HMAC_DOWN_JTAG",               6,  None,       None,      "need_rd_protect"),      # JTAG soft enable key (uses HMAC Downstream mode)
317          ("HMAC_DOWN_DIGITAL_SIGNATURE",  7,  None,       None,      "need_rd_protect"),      # Digital Signature peripheral key (uses HMAC Downstream mode)
318          ("HMAC_UP",                      8,  None,       None,      "need_rd_protect"),      # HMAC Upstream mode
319          ("SECURE_BOOT_DIGEST0",          9,  "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST0 (Secure Boot key digest)
320          ("SECURE_BOOT_DIGEST1",          10, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST1 (Secure Boot key digest)
321          ("SECURE_BOOT_DIGEST2",          11, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST2 (Secure Boot key digest)
322      ]
323      KEY_PURPOSES_NAME = [name[0] for name in KEY_PURPOSES]
324      DIGEST_KEY_PURPOSES = [name[0] for name in KEY_PURPOSES if name[2] == "DIGEST"]
325      def check_format(self, new_value_str):
326          raw_val = new_value_str
327          for purpose_name in self.KEY_PURPOSES:
328              if purpose_name[0] == new_value_str:
329                  raw_val = str(purpose_name[1])
330                  break
331          if raw_val.isdigit():
332              if int(raw_val) not in [p[1] for p in self.KEY_PURPOSES if p[1] > 0]:
333                  raise esptool.FatalError("'%s' can not be set (value out of range)" % raw_val)
334          else:
335              raise esptool.FatalError("'%s' unknown name" % raw_val)
336          return raw_val
337      def need_reverse(self, new_key_purpose):
338          for key in self.KEY_PURPOSES:
339              if key[0] == new_key_purpose:
340                  return key[3] == "Reverse"
341      def need_rd_protect(self, new_key_purpose):
342          for key in self.KEY_PURPOSES:
343              if key[0] == new_key_purpose:
344                  return key[4] == "need_rd_protect"
345      def get(self, from_read=True):
346          for p in self.KEY_PURPOSES:
347              if p[1] == self.get_raw(from_read):
348                  return p[0]
349          return "FORBIDDEN_STATE"
350      def get_name(self, raw_val):
351          for key in self.KEY_PURPOSES:
352              if key[1] == raw_val:
353                  return key[0]
354      def save(self, new_value):
355          raw_val = int(self.check_format(str(new_value)))
356          str_new_value = self.get_name(raw_val)
357          if self.name == "KEY_PURPOSE_5" and str_new_value.startswith("XTS_AES"):
358              raise esptool.FatalError(f"{self.name} can not have {str_new_value} key due to a hardware bug (please see TRM for more details)")
359          return super(EfuseKeyPurposeField, self).save(raw_val)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
25      print(
26          "Pyserial is not installed for %s. "
27          "Check the README for installation instructions." % (sys.executable)
28      )
29      raise
30  try:
31      if "serialization" in serial.__doc__ and "deserialization" in serial.__doc__:
32          raise ImportError(
33              "esptool.py depends on pyserial, but there is a conflict with a currently "
34              "installed package named 'serial'.\n"
35              "You may work around this by 'pip uninstall serial; pip install pyserial' "
36              "but this may break other installed Python software "
37              "that depends on 'serial'.\n"
38              "There is no good fix for this right now, "
39              "apart from configuring virtualenvs. "
40              "See https://github.com/espressif/esptool/issues/269#issuecomment-385298196"
41              " for discussion of the underlying issue(s)."
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          "The installed version (%s) of pyserial appears to be too old for esptool.py "
50          "(Python interpreter %s). Check the README for installation instructions."
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == "darwin":
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg["esptool"]
61  DEFAULT_TIMEOUT = cfg.getfloat("timeout", 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat("chip_erase_timeout", 120)
63  MAX_TIMEOUT = cfg.getfloat("max_timeout", CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat("sync_timeout", 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat("md5_timeout_per_mb", 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat("erase_region_timeout_per_mb", 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat("erase_write_timeout_per_mb", 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat("mem_end_rom_timeout", 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat("serial_write_timeout", 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint("connect_attempts", 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint("write_block_attempts", 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), "targets", "stub_flasher")
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace("esp", "")
76      return os.path.join(STUBS_DIR, f"stub_flasher_{chip_name}.json")
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result < DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in ["ESP8266"]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in ["ESP8266", "ESP32", "ESP32-S2"]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub["text"])
105          self.text_start = stub["text_start"]
106          self.entry = stub["entry"]
107          try:
108              self.data = base64.b64decode(stub["data"])
109              self.data_start = stub["data_start"]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = "Espressif device"
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = "/dev/ttyUSB0"
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: "ESP32-S3(beta 3)"}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              "flash_id": None,
165              "chip_id": None,
166              "uart_no": None,
167          }
168          if isinstance(port, str):
169              try:
170                  self._port = serial.serial_for_url(port)
171              except serial.serialutil.SerialException:
172                  raise FatalError(f"Could not open {port}, the port doesn't exist")
173          else:
174              self._port = port
175          self._slip_reader = slip_reader(self._port, self.trace)
176          self._set_port_baudrate(baud)
177          self._trace_enabled = trace_enabled
178          try:
179              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
180          except NotImplementedError:
181              self._port.write_timeout = None
182      @property
183      def serial_port(self):
184          return self._port.port
185      def _set_port_baudrate(self, baud):
186          try:
187              self._port.baudrate = baud
188          except IOError:
189              raise FatalError(
190                  "Failed to set baud rate %d. The driver may not support this rate."
191                  % baud
192              )
193      def read(self):
194          return next(self._slip_reader)
195      def write(self, packet):
196          buf = (
197              b"\xc0"
198              + (packet.replace(b"\xdb", b"\xdb\xdd").replace(b"\xc0", b"\xdb\xdc"))
199              + b"\xc0"
200          )
201          self.trace("Write %d bytes: %s", len(buf), HexFormatter(buf))
202          self._port.write(buf)
203      def trace(self, message, *format_args):
204          if self._trace_enabled:
205              now = time.time()
206              try:
207                  delta = now - self._last_trace
208              except AttributeError:
209                  delta = 0.0
210              self._last_trace = now
211              prefix = "TRACE +%.3f " % delta
212              print(prefix + (message % format_args))
213      @staticmethod
214      def checksum(data, state=ESP_CHECKSUM_MAGIC):
215          for b in data:
216              state ^= b
217          return state
218      def command(
219          self,
220          op=None,
221          data=b"",
222          chk=0,
223          wait_response=True,
224          timeout=DEFAULT_TIMEOUT,
225      ):
226          saved_timeout = self._port.timeout
227          new_timeout = min(timeout, MAX_TIMEOUT)
228          if new_timeout != saved_timeout:
229              self._port.timeout = new_timeout
230          try:
231              if op is not None:
232                  self.trace(
233                      "command op=0x%02x data len=%s wait_response=%d "
234                      "timeout=%.3f data=%s",
235                      op,
236                      len(data),
237                      1 if wait_response else 0,
238                      timeout,
239                      HexFormatter(data),
240                  )
241                  pkt = struct.pack(b"<BBHI", 0x00, op, len(data), chk) + data
242                  self.write(pkt)
243              if not wait_response:
244                  return
245              for retry in range(100):
246                  p = self.read()
247                  if len(p) < 8:
248                      continue
249                  (resp, op_ret, len_ret, val) = struct.unpack("<BBHI", p[:8])
250                  if resp != 1:
251                      continue
252                  data = p[8:]
253                  if op is None or op_ret == op:
254                      return val, data
255                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
256                      self.flush_input()
257                      raise UnsupportedCommandError(self, op)
258          finally:
259              if new_timeout != saved_timeout:
260                  self._port.timeout = saved_timeout
261          raise FatalError("Response doesn't match request")
262      def check_command(
263          self, op_description, op=None, data=b"", chk=0, timeout=DEFAULT_TIMEOUT
264      ):
265          val, data = self.command(op, data, chk, timeout=timeout)
266          if len(data) < self.STATUS_BYTES_LENGTH:
267              raise FatalError(
268                  "Failed to %s. Only got %d byte status response."
269                  % (op_description, len(data))
270              )
271          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
272          if byte(status_bytes, 0) != 0:
273              raise FatalError.WithResult("Failed to %s" % op_description, status_bytes)
274          if len(data) > self.STATUS_BYTES_LENGTH:
275              return data[: -self.STATUS_BYTES_LENGTH]
276          else:
277              return val
278      def flush_input(self):
279          self._port.flushInput()
280          self._slip_reader = slip_reader(self._port, self.trace)
281      def sync(self):
282          val, _ = self.command(
283              self.ESP_SYNC, b"\x07\x07\x12\x20" + 32 * b"\x55", timeout=SYNC_TIMEOUT
284          )
285          self.sync_stub_detected = val == 0
286          for _ in range(7):
287              val, _ = self.command()
288              self.sync_stub_detected &= val == 0
289      def _get_pid(self):
290          if list_ports is None:
291              print(
292                  "\nListing all serial ports is currently not available. "
293                  "Can't get device PID."
294              )
295              return
296          active_port = self._port.port
297          if not active_port.lower().startswith(("com", "/dev/")):
298              print(
299                  "\nDevice PID identification is only supported on "
300                  "COM and /dev/ serial ports."
301              )
302              return
303          if active_port.startswith("/dev/") and os.path.islink(active_port):
304              active_port = os.path.realpath(active_port)
305          active_ports = [active_port]
306          if sys.platform == "darwin" and "tty" in active_port:
307              active_ports.append(active_port.replace("tty", "cu"))
308          ports = list_ports.comports()
309          for p in ports:
310              if p.device in active_ports:
311                  return p.pid
312          print(
313              "\nFailed to get PID of a device on {}, "
314              "using standard reset sequence.".format(active_port)
315          )
316      def _connect_attempt(self, reset_strategy, mode="default_reset"):
317          last_error = None
318          boot_log_detected = False
319          download_mode = False
320          if mode == "no_reset_no_sync":
321              return last_error
322          if mode != "no_reset":
323              if not self.USES_RFC2217:  # Might block on rfc2217 ports
324                  self._port.reset_input_buffer()
325              reset_strategy()  # Reset the chip to bootloader (download mode)
326              waiting = self._port.inWaiting()
327              read_bytes = self._port.read(waiting)
328              data = re.search(
329                  b"boot:(0x[0-9a-fA-F]+)(.*waiting for download)?", read_bytes, re.DOTALL
330              )
331              if data is not None:
332                  boot_log_detected = True
333                  boot_mode = data.group(1)
334                  download_mode = data.group(2) is not None
335          for _ in range(5):
336              try:
337                  self.flush_input()
338                  self._port.flushOutput()
339                  self.sync()
340                  return None
341              except FatalError as e:
342                  print(".", end="")
343                  sys.stdout.flush()
344                  time.sleep(0.05)
345                  last_error = e
346          if boot_log_detected:
347              last_error = FatalError(
348                  "Wrong boot mode detected ({})! "
349                  "The chip needs to be in download mode.".format(
350                      boot_mode.decode("utf-8")
351                  )
352              )
353              if download_mode:
354                  last_error = FatalError(
355                      "Download mode successfully detected, but getting no sync reply: "
356                      "The serial TX path seems to be down."
357                  )
358          return last_error
359      def get_memory_region(self, name):
360          try:
361              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
362          except IndexError:
363              return None
364      def _construct_reset_strategy_sequence(self, mode):
365          cfg_custom_reset_sequence = cfg.get("custom_reset_sequence")
366          if cfg_custom_reset_sequence is not None:
367              return (CustomReset(self._port, cfg_custom_reset_sequence),)
368          cfg_reset_delay = cfg.getfloat("reset_delay")
369          if cfg_reset_delay is not None:
370              delay = extra_delay = cfg_reset_delay
371          else:
372              delay = DEFAULT_RESET_DELAY
373              extra_delay = DEFAULT_RESET_DELAY + 0.5
374          if (
375              self.FPGA_SLOW_BOOT
376              and os.environ.get("ESPTOOL_ENV_FPGA", "").strip() == "1"
377          ):
378              delay = extra_delay = 7
379          if mode == "usb_reset" or self._get_pid() == self.USB_JTAG_SERIAL_PID:
380              return (USBJTAGSerialReset(self._port),)
381          if os.name != "nt" and not self._port.name.startswith("rfc2217:"):
382              return (
383                  UnixTightReset(self._port, delay),
384                  UnixTightReset(self._port, extra_delay),
385                  ClassicReset(self._port, delay),
386                  ClassicReset(self._port, extra_delay),
387              )
388          return (
389              ClassicReset(self._port, delay),
390              ClassicReset(self._port, extra_delay),
391          )
392      def connect(
393          self,
394          mode="default_reset",
395          attempts=DEFAULT_CONNECT_ATTEMPTS,
396          detecting=False,
397          warnings=True,
398      ):
399          if warnings and mode in ["no_reset", "no_reset_no_sync"]:
400              print(
401                  'WARNING: Pre-connection option "{}" was selected.'.format(mode),
402                  "Connection may fail if the chip is not in bootloader "
403                  "or flasher stub mode.",
404              )
405          print("Connecting...", end="")
406          sys.stdout.flush()
407          last_error = None
408          reset_sequence = self._construct_reset_strategy_sequence(mode)
409          try:
410              for _, reset_strategy in zip(
411                  range(attempts) if attempts > 0 else itertools.count(),
412                  itertools.cycle(reset_sequence),
413              ):
414                  last_error = self._connect_attempt(reset_strategy, mode)
415                  if last_error is None:
416                      break
417          finally:
418              print("")  # end 'Connecting...' line
419          if last_error is not None:
420              raise FatalError(
421                  "Failed to connect to {}: {}"
422                  "\nFor troubleshooting steps visit: "
423                  "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html".format(  # noqa E501
424                      self.CHIP_NAME, last_error
425                  )
426              )
427          if not detecting:
428              try:
429                  from .targets import ROM_LIST
430                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
431                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
432                      actually = None
433                      for cls in ROM_LIST:
434                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
435                              actually = cls
436                              break
437                      if warnings and actually is None:
438                          print(
439                              "WARNING: This chip doesn't appear to be a %s "
440                              "(chip magic value 0x%08x). "
441                              "Probably it is unsupported by this version of esptool."
442                              % (self.CHIP_NAME, chip_magic_value)
443                          )
444                      else:
445                          raise FatalError(
446                              "This chip is %s not %s. Wrong --chip argument?"
447                              % (actually.CHIP_NAME, self.CHIP_NAME)
448                          )
449              except UnsupportedCommandError:
450                  self.secure_download_mode = True
451              try:
452                  self.check_chip_id()
453              except UnsupportedCommandError:
454                  if self.secure_download_mode:
455                      self._connect_attempt(mode, reset_sequence[0])
456                      self.check_chip_id()
457                  else:
458                      raise
459              self._post_connect()
460      def _post_connect(self):
461          pass
462      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
463          val, data = self.command(
464              self.ESP_READ_REG, struct.pack("<I", addr), timeout=timeout
465          )
466          if byte(data, 0) != 0:
467              raise FatalError.WithResult(
468                  "Failed to read register address %08x" % addr, data
469              )
470          return val
471      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
472          command = struct.pack("<IIII", addr, value, mask, delay_us)
473          if delay_after_us > 0:
474              command += struct.pack(
475                  "<IIII", self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
476              )
477          return self.check_command("write target memory", self.ESP_WRITE_REG, command)
478      def update_reg(self, addr, mask, new_val):
479          shift = mask_to_shift(mask)
480          val = self.read_reg(addr)
481          val &= ~mask
482          val |= (new_val << shift) & mask
483          self.write_reg(addr, val)
484          return val
485      def mem_begin(self, size, blocks, blocksize, offset):
486          if self.IS_STUB:
487              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
488              load_start = offset
489              load_end = offset + size
490              for start, end in [
<span onclick='openModal()' class='match'>491                  (stub.data_start, stub.data_start + len(stub.data)),
492                  (stub.text_start, stub.text_start + len(stub.text)),
</span>493              ]:
494                  if load_start < end and load_end > start:
495                      raise FatalError(
496                          "Software loader is resident at 0x%08x-0x%08x. "
497                          "Can't load binary at overlapping address range 0x%08x-0x%08x. "
498                          "Either change binary loading address, or use the --no-stub "
499                          "option to disable the software loader."
500                          % (start, end, load_start, load_end)
501                      )
502          return self.check_command(
503              "enter RAM download mode",
504              self.ESP_MEM_BEGIN,
505              struct.pack("<IIII", size, blocks, blocksize, offset),
506          )
507      def mem_block(self, data, seq):
508          return self.check_command(
509              "write to target RAM",
510              self.ESP_MEM_DATA,
511              struct.pack("<IIII", len(data), seq, 0, 0) + data,
512              self.checksum(data),
513          )
514      def mem_finish(self, entrypoint=0):
515          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
516          data = struct.pack("<II", int(entrypoint == 0), entrypoint)
517          try:
518              return self.check_command(
519                  "leave RAM download mode", self.ESP_MEM_END, data=data, timeout=timeout
520              )
521          except FatalError:
522              if self.IS_STUB:
523                  raise
524              pass
525      def flash_begin(self, size, offset, begin_rom_encrypted=False):
526          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
527          erase_size = self.get_erase_size(offset, size)
528          t = time.time()
529          if self.IS_STUB:
530              timeout = DEFAULT_TIMEOUT
531          else:
532              timeout = timeout_per_mb(
533                  ERASE_REGION_TIMEOUT_PER_MB, size
534              )  # ROM performs the erase up front
535          params = struct.pack(
536              "<IIII", erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
537          )
538          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
539              params += struct.pack("<I", 1 if begin_rom_encrypted else 0)
540          self.check_command(
541              "enter Flash download mode", self.ESP_FLASH_BEGIN, params, timeout=timeout
542          )
543          if size != 0 and not self.IS_STUB:
544              print("Took %.2fs to erase flash block" % (time.time() - t))
545          return num_blocks
546      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
547          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
548              try:
549                  self.check_command(
550                      "write to target Flash after seq %d" % seq,
551                      self.ESP_FLASH_DATA,
552                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
553                      self.checksum(data),
554                      timeout=timeout,
555                  )
556                  break
557              except FatalError:
558                  if attempts_left:
559                      self.trace(
560                          "Block write failed, "
561                          f"retrying with {attempts_left} attempts left"
562                      )
563                  else:
564                      raise
565      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
566          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
567              return self.flash_block(data, seq, timeout)
568          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
569              try:
570                  self.check_command(
571                      "Write encrypted to target Flash after seq %d" % seq,
572                      self.ESP_FLASH_ENCRYPT_DATA,
573                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
574                      self.checksum(data),
575                      timeout=timeout,
576                  )
577                  break
578              except FatalError:
579                  if attempts_left:
580                      self.trace(
581                          "Encrypted block write failed, "
582                          f"retrying with {attempts_left} attempts left"
583                      )
584                  else:
585                      raise
586      def flash_finish(self, reboot=False):
587          pkt = struct.pack("<I", int(not reboot))
588          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
589      def run(self, reboot=False):
590          self.flash_begin(0, 0)
591          self.flash_finish(reboot)
592      def flash_id(self):
593          if self.cache["flash_id"] is None:
594              SPIFLASH_RDID = 0x9F
595              self.cache["flash_id"] = self.run_spiflash_command(SPIFLASH_RDID, b"", 24)
596          return self.cache["flash_id"]
597      def flash_type(self):
598          return None  # not implemented for all chip targets
599      def get_security_info(self):
600          res = self.check_command("get security info", self.ESP_GET_SECURITY_INFO, b"")
601          esp32s2 = True if len(res) == 12 else False
602          res = struct.unpack("<IBBBBBBBB" if esp32s2 else "<IBBBBBBBBII", res)
603          return {
604              "flags": res[0],
605              "flash_crypt_cnt": res[1],
606              "key_purposes": res[2:9],
607              "chip_id": None if esp32s2 else res[9],
608              "api_version": None if esp32s2 else res[10],
609          }
610      @esp32s3_or_newer_function_only
611      def get_chip_id(self):
612          if self.cache["chip_id"] is None:
613              res = self.check_command(
614                  "get security info", self.ESP_GET_SECURITY_INFO, b""
615              )
616              res = struct.unpack(
617                  "<IBBBBBBBBI", res[:16]
618              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
619              self.cache["chip_id"] = res[9]  # 2/4 status bytes invariant
620          return self.cache["chip_id"]
621      def get_uart_no(self):
622          if self.cache["uart_no"] is None:
623              self.cache["uart_no"] = self.read_reg(self.UARTDEV_BUF_NO) & 0xFF
624          return self.cache["uart_no"]
625      @classmethod
626      def parse_flash_size_arg(cls, arg):
627          try:
628              return cls.FLASH_SIZES[arg]
629          except KeyError:
630              raise FatalError(
631                  "Flash size '%s' is not supported by this chip type. "
632                  "Supported sizes: %s" % (arg, ", ".join(cls.FLASH_SIZES.keys()))
633              )
634      @classmethod
635      def parse_flash_freq_arg(cls, arg):
636          if arg is None:
637              return 0
638          try:
639              return cls.FLASH_FREQUENCY[arg]
640          except KeyError:
641              raise FatalError(
642                  "Flash frequency '%s' is not supported by this chip type. "
643                  "Supported frequencies: %s"
644                  % (arg, ", ".join(cls.FLASH_FREQUENCY.keys()))
645              )
646      def run_stub(self, stub=None):
647          if stub is None:
648              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
649          if self.sync_stub_detected:
650              print("Stub is already running. No upload is necessary.")
651              return self.STUB_CLASS(self)
652          print("Uploading stub...")
653          for field in [stub.text, stub.data]:
654              if field is not None:
655                  offs = stub.text_start if field == stub.text else stub.data_start
656                  length = len(field)
657                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
658                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
659                  for seq in range(blocks):
660                      from_offs = seq * self.ESP_RAM_BLOCK
661                      to_offs = from_offs + self.ESP_RAM_BLOCK
662                      self.mem_block(field[from_offs:to_offs], seq)
663          print("Running stub...")
664          self.mem_finish(stub.entry)
665          try:
666              p = self.read()
667          except StopIteration:
668              raise FatalError(
669                  "Failed to start stub. There was no response."
670                  "\nTry increasing timeouts, for more information see: "
671                  "https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html"  # noqa E501
672              )
673          if p != b"OHAI":
674              raise FatalError(f"Failed to start stub. Unexpected response: {p}")
675          print("Stub running...")
676          return self.STUB_CLASS(self)
677      @stub_and_esp32_function_only
678      def flash_defl_begin(self, size, compsize, offset):
679          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
680          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
681          t = time.time()
682          if self.IS_STUB:
683              write_size = (
684                  size  # stub expects number of bytes here, manages erasing internally
685              )
686              timeout = DEFAULT_TIMEOUT
687          else:
688              write_size = (
689                  erase_blocks * self.FLASH_WRITE_SIZE
690              )  # ROM expects rounded up to erase block size
691              timeout = timeout_per_mb(
692                  ERASE_REGION_TIMEOUT_PER_MB, write_size
693              )  # ROM performs the erase up front
694          print("Compressed %d bytes to %d..." % (size, compsize))
695          params = struct.pack(
696              "<IIII", write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
697          )
698          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
699              params += struct.pack("<I", 0)
700          self.check_command(
701              "enter compressed flash mode",
702              self.ESP_FLASH_DEFL_BEGIN,
703              params,
704              timeout=timeout,
705          )
706          if size != 0 and not self.IS_STUB:
707              print("Took %.2fs to erase flash block" % (time.time() - t))
708          return num_blocks
709      @stub_and_esp32_function_only
710      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
711          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
712              try:
713                  self.check_command(
714                      "write compressed data to flash after seq %d" % seq,
715                      self.ESP_FLASH_DEFL_DATA,
716                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
717                      self.checksum(data),
718                      timeout=timeout,
719                  )
720                  break
721              except FatalError:
722                  if attempts_left:
723                      self.trace(
724                          "Compressed block write failed, "
725                          f"retrying with {attempts_left} attempts left"
726                      )
727                  else:
728                      raise
729      @stub_and_esp32_function_only
730      def flash_defl_finish(self, reboot=False):
731          if not reboot and not self.IS_STUB:
732              return
733          pkt = struct.pack("<I", int(not reboot))
734          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
735          self.in_bootloader = False
736      @stub_and_esp32_function_only
737      def flash_md5sum(self, addr, size):
738          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
739          res = self.check_command(
740              "calculate md5sum",
741              self.ESP_SPI_FLASH_MD5,
742              struct.pack("<IIII", addr, size, 0, 0),
743              timeout=timeout,
744          )
745          if len(res) == 32:
746              return res.decode("utf-8")  # already hex formatted
747          elif len(res) == 16:
748              return hexify(res).lower()
749          else:
750              raise FatalError("MD5Sum command returned unexpected result: %r" % res)
751      @stub_and_esp32_function_only
752      def change_baud(self, baud):
753          print("Changing baud rate to %d" % baud)
754          second_arg = self._port.baudrate if self.IS_STUB else 0
755          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack("<II", baud, second_arg))
756          print("Changed.")
757          self._set_port_baudrate(baud)
758          time.sleep(0.05)  # get rid of crap sent during baud rate change
759          self.flush_input()
760      @stub_function_only
761      def erase_flash(self):
762          self.check_command(
763              "erase flash", self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
764          )
765      @stub_function_only
766      def erase_region(self, offset, size):
767          if offset % self.FLASH_SECTOR_SIZE != 0:
768              raise FatalError("Offset to erase from must be a multiple of 4096")
769          if size % self.FLASH_SECTOR_SIZE != 0:
770              raise FatalError("Size of data to erase must be a multiple of 4096")
771          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
772          self.check_command(
773              "erase region",
774              self.ESP_ERASE_REGION,
775              struct.pack("<II", offset, size),
776              timeout=timeout,
777          )
778      def read_flash_slow(self, offset, length, progress_fn):
779          raise NotImplementedInROMError(self, self.read_flash_slow)
780      def read_flash(self, offset, length, progress_fn=None):
781          if not self.IS_STUB:
782              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
783          self.check_command(
784              "read flash",
785              self.ESP_READ_FLASH,
786              struct.pack("<IIII", offset, length, self.FLASH_SECTOR_SIZE, 64),
787          )
788          data = b""
789          while len(data) < length:
790              p = self.read()
791              data += p
792              if len(data) < length and len(p) < self.FLASH_SECTOR_SIZE:
793                  raise FatalError(
794                      "Corrupt data, expected 0x%x bytes but received 0x%x bytes"
795                      % (self.FLASH_SECTOR_SIZE, len(p))
796                  )
797              self.write(struct.pack("<I", len(data)))
798              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
799                  progress_fn(len(data), length)
800          if progress_fn:
801              progress_fn(len(data), length)
802          if len(data) > length:
803              raise FatalError("Read more than expected")
804          digest_frame = self.read()
805          if len(digest_frame) != 16:
806              raise FatalError("Expected digest, got: %s" % hexify(digest_frame))
807          expected_digest = hexify(digest_frame).upper()
808          digest = hashlib.md5(data).hexdigest().upper()
809          if digest != expected_digest:
810              raise FatalError(
811                  "Digest mismatch: expected %s, got %s" % (expected_digest, digest)
812              )
813          return data
814      def flash_spi_attach(self, hspi_arg):
815          arg = struct.pack("<I", hspi_arg)
816          if not self.IS_STUB:
817              is_legacy = 0
818              arg += struct.pack("BBBB", is_legacy, 0, 0, 0)
819          self.check_command("configure SPI flash pins", self.ESP_SPI_ATTACH, arg)
820      def flash_set_parameters(self, size):
821          fl_id = 0
822          total_size = size
823          block_size = 64 * 1024
824          sector_size = 4 * 1024
825          page_size = 256
826          status_mask = 0xFFFF
827          self.check_command(
828              "set SPI params",
829              self.ESP_SPI_SET_PARAMS,
830              struct.pack(
831                  "<IIIIII",
832                  fl_id,
833                  total_size,
834                  block_size,
835                  sector_size,
836                  page_size,
837                  status_mask,
838              ),
839          )
840      def run_spiflash_command(
841          self,
842          spiflash_command,
843          data=b"",
844          read_bits=0,
845          addr=None,
846          addr_len=0,
847          dummy_len=0,
848      ):
849          SPI_USR_COMMAND = 1 << 31
850          SPI_USR_ADDR = 1 << 30
851          SPI_USR_DUMMY = 1 << 29
852          SPI_USR_MISO = 1 << 28
853          SPI_USR_MOSI = 1 << 27
854          base = self.SPI_REG_BASE
855          SPI_CMD_REG = base + 0x00
856          SPI_ADDR_REG = base + 0x04
857          SPI_USR_REG = base + self.SPI_USR_OFFS
858          SPI_USR1_REG = base + self.SPI_USR1_OFFS
859          SPI_USR2_REG = base + self.SPI_USR2_OFFS
860          SPI_W0_REG = base + self.SPI_W0_OFFS
861          if self.SPI_MOSI_DLEN_OFFS is not None:
862              def set_data_lengths(mosi_bits, miso_bits):
863                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
864                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
865                  if mosi_bits > 0:
866                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
867                  if miso_bits > 0:
868                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
869                  flags = 0
870                  if dummy_len > 0:
871                      flags |= dummy_len - 1
872                  if addr_len > 0:
873                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
874                  if flags:
875                      self.write_reg(SPI_USR1_REG, flags)
876          else:
877              def set_data_lengths(mosi_bits, miso_bits):
878                  SPI_DATA_LEN_REG = SPI_USR1_REG
879                  SPI_MOSI_BITLEN_S = 17
880                  SPI_MISO_BITLEN_S = 8
881                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
882                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
883                  flags = (miso_mask << SPI_MISO_BITLEN_S) | (
884                      mosi_mask << SPI_MOSI_BITLEN_S
885                  )
886                  if dummy_len > 0:
887                      flags |= dummy_len - 1
888                  if addr_len > 0:
889                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
890                  self.write_reg(SPI_DATA_LEN_REG, flags)
891          SPI_CMD_USR = 1 << 18
892          SPI_USR2_COMMAND_LEN_SHIFT = 28
893          SPI_USR_ADDR_LEN_SHIFT = 26
894          if read_bits > 32:
895              raise FatalError(
896                  "Reading more than 32 bits back from a SPI flash "
897                  "operation is unsupported"
898              )
899          if len(data) > 64:
900              raise FatalError(
901                  "Writing more than 64 bytes of data with one SPI "
902                  "command is unsupported"
903              )
904          data_bits = len(data) * 8
905          old_spi_usr = self.read_reg(SPI_USR_REG)
906          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
907          flags = SPI_USR_COMMAND
908          if read_bits > 0:
909              flags |= SPI_USR_MISO
910          if data_bits > 0:
911              flags |= SPI_USR_MOSI
912          if addr_len > 0:
913              flags |= SPI_USR_ADDR
914          if dummy_len > 0:
915              flags |= SPI_USR_DUMMY
916          set_data_lengths(data_bits, read_bits)
917          self.write_reg(SPI_USR_REG, flags)
918          self.write_reg(
919              SPI_USR2_REG, (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
920          )
921          if addr and addr_len > 0:
922              self.write_reg(SPI_ADDR_REG, addr)
923          if data_bits == 0:
924              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
925          else:
926              data = pad_to(data, 4, b"\00")  # pad to 32-bit multiple
927              words = struct.unpack("I" * (len(data) // 4), data)
928              next_reg = SPI_W0_REG
929              for word in words:
930                  self.write_reg(next_reg, word)
931                  next_reg += 4
932          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
933          def wait_done():
934              for _ in range(10):
935                  if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:
936                      return
937              raise FatalError("SPI command did not complete in time")
938          wait_done()
939          status = self.read_reg(SPI_W0_REG)
940          self.write_reg(SPI_USR_REG, old_spi_usr)
941          self.write_reg(SPI_USR2_REG, old_spi_usr2)
942          return status
943      def read_spiflash_sfdp(self, addr, read_bits):
944          CMD_RDSFDP = 0x5A
945          return self.run_spiflash_command(
946              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
947          )
948      def read_status(self, num_bytes=2):
949          SPIFLASH_RDSR = 0x05
950          SPIFLASH_RDSR2 = 0x35
951          SPIFLASH_RDSR3 = 0x15
952          status = 0
953          shift = 0
954          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
955              status += self.run_spiflash_command(cmd, read_bits=8) << shift
956              shift += 8
957          return status
958      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
959          SPIFLASH_WRSR = 0x01
960          SPIFLASH_WRSR2 = 0x31
961          SPIFLASH_WRSR3 = 0x11
962          SPIFLASH_WEVSR = 0x50
963          SPIFLASH_WREN = 0x06
964          SPIFLASH_WRDI = 0x04
965          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
966          if num_bytes == 2:
967              self.run_spiflash_command(enable_cmd)
968              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack("<H", new_status))
969          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
970              self.run_spiflash_command(enable_cmd)
971              self.run_spiflash_command(cmd, struct.pack("B", new_status & 0xFF))
972              new_status >>= 8
973          self.run_spiflash_command(SPIFLASH_WRDI)
974      def get_crystal_freq(self):
975          uart_div = self.read_reg(self.UART_CLKDIV_REG) & self.UART_CLKDIV_MASK
976          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
977          norm_xtal = 40 if est_xtal > 33 else 26
978          if abs(norm_xtal - est_xtal) > 1:
979              print(
980                  "WARNING: Detected crystal freq %.2fMHz is quite different to "
981                  "normalized freq %dMHz. Unsupported crystal in use?"
982                  % (est_xtal, norm_xtal)
983              )
984          return norm_xtal
985      def hard_reset(self):
986          print("Hard resetting via RTS pin...")
987          HardReset(self._port)()
988      def soft_reset(self, stay_in_bootloader):
989          if not self.IS_STUB:
990              if stay_in_bootloader:
991                  return  # ROM bootloader is already in bootloader!
992              else:
993                  self.flash_begin(0, 0)
994                  self.flash_finish(False)
995          else:
996              if stay_in_bootloader:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(True)
999              elif self.CHIP_NAME != "ESP8266":
1000                  raise FatalError(
1001                      "Soft resetting is currently only supported on ESP8266"
1002                  )
1003              else:
1004                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1005      def check_chip_id(self):
1006          try:
1007              chip_id = self.get_chip_id()
1008              if chip_id != self.IMAGE_CHIP_ID:
1009                  print(
1010                      "WARNING: Chip ID {} ({}) doesn't match expected Chip ID {}. "
1011                      "esptool may not work correctly.".format(
1012                          chip_id,
1013                          self.UNSUPPORTED_CHIPS.get(chip_id, "Unknown"),
1014                          self.IMAGE_CHIP_ID,
1015                      )
1016                  )
1017                  self.stub_is_disabled = True
1018          except NotImplementedInROMError:
1019              pass
1020  def slip_reader(port, trace_function):
1021      def detect_panic_handler(input):
1022          guru_meditation = (
1023              rb"G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?"
1024          )
1025          fatal_exception = rb"F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?"
1026          data = re.search(
1027              rb"".join([rb"(?:", guru_meditation, rb"|", fatal_exception, rb")"]),
1028              input,
1029              re.DOTALL,
1030          )
1031          if data is not None:
1032              cause = [
1033                  "({})".format(i.decode("utf-8"))
1034                  for i in [data.group(1), data.group(2)]
1035                  if i is not None
1036              ]
1037              cause = f" {cause[0]}" if len(cause) else ""
1038              msg = f"Guru Meditation Error detected{cause}"
1039              raise FatalError(msg)
1040      partial_packet = None
1041      in_escape = False
1042      successful_slip = False
1043      while True:
1044          waiting = port.inWaiting()
1045          read_bytes = port.read(1 if waiting == 0 else waiting)
1046          if read_bytes == b"":
1047              if partial_packet is None:  # fail due to no data
1048                  msg = (
1049                      "Serial data stream stopped: Possible serial noise or corruption."
1050                      if successful_slip
1051                      else "No serial data received."
1052                  )
1053              else:  # fail during packet transfer
1054                  msg = "Packet content transfer stopped (received {} bytes)".format(
1055                      len(partial_packet)
1056                  )
1057              trace_function(msg)
1058              raise FatalError(msg)
1059          trace_function("Read %d bytes: %s", len(read_bytes), HexFormatter(read_bytes))
1060          for b in read_bytes:
1061              b = bytes([b])
1062              if partial_packet is None:  # waiting for packet header
1063                  if b == b"\xc0":
1064                      partial_packet = b""
1065                  else:
1066                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1067                      remaining_data = port.read(port.inWaiting())
1068                      trace_function(
1069                          "Remaining data in serial buffer: %s",
1070                          HexFormatter(remaining_data),
1071                      )
1072                      detect_panic_handler(read_bytes + remaining_data)
1073                      raise FatalError(
1074                          "Invalid head of packet (0x%s): "
1075                          "Possible serial noise or corruption." % hexify(b)
1076                      )
1077              elif in_escape:  # part-way through escape sequence
1078                  in_escape = False
1079                  if b == b"\xdc":
1080                      partial_packet += b"\xc0"
1081                  elif b == b"\xdd":
1082                      partial_packet += b"\xdb"
1083                  else:
1084                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1085                      remaining_data = port.read(port.inWaiting())
1086                      trace_function(
1087                          "Remaining data in serial buffer: %s",
1088                          HexFormatter(remaining_data),
1089                      )
1090                      detect_panic_handler(read_bytes + remaining_data)
1091                      raise FatalError("Invalid SLIP escape (0xdb, 0x%s)" % (hexify(b)))
1092              elif b == b"\xdb":  # start of escape sequence
1093                  in_escape = True
1094              elif b == b"\xc0":  # end of packet
1095                  trace_function("Received full packet: %s", HexFormatter(partial_packet))
1096                  yield partial_packet
1097                  partial_packet = None
1098                  successful_slip = True
1099              else:  # normal byte in packet
1100                  partial_packet += b
1101  class HexFormatter(object):
1102      def __init__(self, binary_string, auto_split=True):
1103          self._s = binary_string
1104          self._auto_split = auto_split
1105      def __str__(self):
1106          if self._auto_split and len(self._s) > 16:
1107              result = ""
1108              s = self._s
1109              while len(s) > 0:
1110                  line = s[:16]
1111                  ascii_line = "".join(
1112                      c
1113                      if (
1114                          c == " "
1115                          or (c in string.printable and c not in string.whitespace)
1116                      )
1117                      else "."
1118                      for c in line.decode("ascii", "replace")
1119                  )
1120                  s = s[16:]
1121                  result += "\n    %-16s %-16s | %s" % (
1122                      hexify(line[:8], False),
1123                      hexify(line[8:], False),
1124                      ascii_line,
1125                  )
1126              return result
1127          else:
1128              return hexify(self._s, False)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_22.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                </div>
                <div class="column column_space"><pre><code>133          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_WRITE_OP_CODE)
134          self.write_reg(self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_PGM_CMD | (block << 2))
</pre></code></div>
                <div class="column column_space"><pre><code>491                  (stub.data_start, stub.data_start + len(stub.data)),
492                  (stub.text_start, stub.text_start + len(stub.text)),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    