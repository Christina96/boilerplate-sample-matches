<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for adn.py &amp; twitch.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for adn.py &amp; twitch.py
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>adn.py (6.443914%)<th>twitch.py (2.542373%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(257-262)<td><a href="#" name="0">(298-302)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(4-36)<td><a href="#" name="1">(2-39)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>adn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import base64
3 import binascii
4 import json
5 import os
6 import random
7 from .common import InfoExtractor
8 from ..aes import aes_cbc_decrypt
9 from ..compat import (
10     compat_HTTPError,
11     compat_b64decode,
12     compat_ord,
13 )
14 from ..utils import (
15     bytes_to_intlist,
16     bytes_to_long,
17     ExtractorError,
18     float_or_none,
19     int_or_none,
20     intlist_to_bytes,
21     long_to_bytes,
22     pkcs1pad,
23     strip_or_none,
24     try_get,
25     unified_strdate,
26     urlencode_postdata,
27 )
28 class ADNIE(InfoExtractor):
29     IE_DESC = 'Anime Digital Network'
30     _VALID_URL = r'https?://(?:www\.)?animedigitalnetwork\.fr/video/[^/]+/(?P&lt;id&gt;\d+)'
31     _TEST =</b></font> {
32         'url': 'http://animedigitalnetwork.fr/video/blue-exorcist-kyoto-saga/7778-episode-1-debut-des-hostilites',
33         'md5': '0319c99885ff5547565cacb4f3f9348d',
34         'info_dict': {
35             'id': '7778',
36             'ext': 'mp4',
37             'title': 'Blue Exorcist - Kyôto Saga - Episode 1',
38             'description': 'md5:2f7b5aa76edbc1a7a92cedcda8a528d5',
39             'series': 'Blue Exorcist - Kyôto Saga',
40             'duration': 1467,
41             'release_date': '20170106',
42             'comment_count': int,
43             'average_rating': float,
44             'season_number': 2,
45             'episode': 'Début des hostilités',
46             'episode_number': 1,
47         }
48     }
49     _NETRC_MACHINE = 'animedigitalnetwork'
50     _BASE_URL = 'http://animedigitalnetwork.fr'
51     _API_BASE_URL = 'https://gw.api.animedigitalnetwork.fr/'
52     _PLAYER_BASE_URL = _API_BASE_URL + 'player/'
53     _HEADERS = {}
54     _LOGIN_ERR_MESSAGE = 'Unable to log in'
55     _RSA_KEY = (0x9B42B08905199A5CCE2026274399CA560ECB209EE9878A708B1C0812E1BB8CB5D1FB7441861147C1A1F2F3A0476DD63A9CAC20D3E983613346850AA6CB38F16DC7D720FD7D86FC6E5B3D5BBC72E14CD0BF9E869F2CEA2CCAD648F1DCE38F1FF916CEFB2D339B64AA0264372344BC775E265E8A852F88144AB0BD9AA06C1A4ABB, 65537)
56     _POS_ALIGN_MAP = {
57         'start': 1,
58         'end': 3,
59     }
60     _LINE_ALIGN_MAP = {
61         'middle': 8,
62         'end': 4,
63     }
64     @staticmethod
65     def _ass_subtitles_timecode(seconds):
66         return '%01d:%02d:%02d.%02d' % (seconds / 3600, (seconds % 3600) / 60, seconds % 60, (seconds % 1) * 100)
67     def _get_subtitles(self, sub_url, video_id):
68         if not sub_url:
69             return None
70         enc_subtitles = self._download_webpage(
71             sub_url, video_id, 'Downloading subtitles location', fatal=False) or '{}'
72         subtitle_location = (self._parse_json(enc_subtitles, video_id, fatal=False) or {}).get('location')
73         if subtitle_location:
74             enc_subtitles = self._download_webpage(
75                 subtitle_location, video_id, 'Downloading subtitles data',
76                 fatal=False, headers={'Origin': 'https://animedigitalnetwork.fr'})
77         if not enc_subtitles:
78             return None
79         dec_subtitles = intlist_to_bytes(aes_cbc_decrypt(
80             bytes_to_intlist(compat_b64decode(enc_subtitles[24:])),
81             bytes_to_intlist(binascii.unhexlify(self._K + 'ab9f52f5baae7c72')),
82             bytes_to_intlist(compat_b64decode(enc_subtitles[:24]))
83         ))
84         subtitles_json = self._parse_json(
85             dec_subtitles[:-compat_ord(dec_subtitles[-1])].decode(),
86             None, fatal=False)
87         if not subtitles_json:
88             return None
89         subtitles = {}
90         for sub_lang, sub in subtitles_json.items():
91             ssa = '''[Script Info]
92 ScriptType:V4.00
93 [V4 Styles]
94 Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,TertiaryColour,BackColour,Bold,Italic,BorderStyle,Outline,Shadow,Alignment,MarginL,MarginR,MarginV,AlphaLevel,Encoding
95 Style: Default,Arial,18,16777215,16777215,16777215,0,-1,0,1,1,0,2,20,20,20,0,0
96 [Events]
97 Format: Marked,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text'''
98             for current in sub:
99                 start, end, text, line_align, position_align = (
100                     float_or_none(current.get('startTime')),
101                     float_or_none(current.get('endTime')),
102                     current.get('text'), current.get('lineAlign'),
103                     current.get('positionAlign'))
104                 if start is None or end is None or text is None:
105                     continue
106                 alignment = self._POS_ALIGN_MAP.get(position_align, 2) + self._LINE_ALIGN_MAP.get(line_align, 0)
107                 ssa += os.linesep + 'Dialogue: Marked=0,%s,%s,Default,,0,0,0,,%s%s' % (
108                     self._ass_subtitles_timecode(start),
109                     self._ass_subtitles_timecode(end),
110                     '{\\a%d}' % alignment if alignment != 2 else '',
111                     text.replace('\n', '\\N').replace('&lt;i&gt;', '{\\i1}').replace('&lt;/i&gt;', '{\\i0}'))
112             if sub_lang == 'vostf':
113                 sub_lang = 'fr'
114             subtitles.setdefault(sub_lang, []).extend([{
115                 'ext': 'json',
116                 'data': json.dumps(sub),
117             }, {
118                 'ext': 'ssa',
119                 'data': ssa,
120             }])
121         return subtitles
122     def _real_initialize(self):
123         username, password = self._get_login_info()
124         if not username:
125             return
126         try:
127             access_token = (self._download_json(
128                 self._API_BASE_URL + 'authentication/login', None,
129                 'Logging in', self._LOGIN_ERR_MESSAGE, fatal=False,
130                 data=urlencode_postdata({
131                     'password': password,
132                     'rememberMe': False,
133                     'source': 'Web',
134                     'username': username,
135                 })) or {}).get('accessToken')
136             if access_token:
137                 self._HEADERS = {'authorization': 'Bearer ' + access_token}
138         except ExtractorError as e:
139             message = None
140             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:
141                 resp = self._parse_json(
142                     e.cause.read().decode(), None, fatal=False) or {}
143                 message = resp.get('message') or resp.get('code')
144             self.report_warning(message or self._LOGIN_ERR_MESSAGE)
145     def _real_extract(self, url):
146         video_id = self._match_id(url)
147         video_base_url = self._PLAYER_BASE_URL + 'video/%s/' % video_id
148         player = self._download_json(
149             video_base_url + 'configuration', video_id,
150             'Downloading player config JSON metadata',
151             headers=self._HEADERS)['player']
152         options = player['options']
153         user = options['user']
154         if not user.get('hasAccess'):
155             self.raise_login_required()
156         token = self._download_json(
157             user.get('refreshTokenUrl') or (self._PLAYER_BASE_URL + 'refresh/token'),
158             video_id, 'Downloading access token', headers={
159                 'x-player-refresh-token': user['refreshToken']
160             }, data=b'')['token']
161         links_url = try_get(options, lambda x: x['video']['url']) or (video_base_url + 'link')
162         self._K = ''.join([random.choice('0123456789abcdef') for _ in range(16)])
163         message = bytes_to_intlist(json.dumps({
164             'k': self._K,
165             't': token,
166         }))
167         links_data = None
168         for _ in range(3):
169             padded_message = intlist_to_bytes(pkcs1pad(message, 128))
170             n, e = self._RSA_KEY
171             encrypted_message = long_to_bytes(pow(bytes_to_long(padded_message), e, n))
172             authorization = base64.b64encode(encrypted_message).decode()
173             try:
174                 links_data = self._download_json(
175                     links_url, video_id, 'Downloading links JSON metadata', headers={
176                         'X-Player-Token': authorization
177                     }, query={
178                         'freeWithAds': 'true',
179                         'adaptive': 'false',
180                         'withMetadata': 'true',
181                         'source': 'Web'
182                     })
183                 break
184             except ExtractorError as e:
185                 if not isinstance(e.cause, compat_HTTPError):
186                     raise e
187                 if e.cause.code == 401:
188                     continue
189                 error = self._parse_json(e.cause.read(), video_id)
190                 message = error.get('message')
191                 if e.cause.code == 403 and error.get('code') == 'player-bad-geolocation-country':
192                     self.raise_geo_restricted(msg=message)
193                 raise ExtractorError(message)
194         else:
195             raise ExtractorError('Giving up retrying')
196         links = links_data.get('links') or {}
197         metas = links_data.get('metadata') or {}
198         sub_url = (links.get('subtitles') or {}).get('all')
199         video_info = links_data.get('video') or {}
200         title = metas['title']
201         formats = []
202         for format_id, qualities in (links.get('streaming') or {}).items():
203             if not isinstance(qualities, dict):
204                 continue
205             for quality, load_balancer_url in qualities.items():
206                 load_balancer_data = self._download_json(
207                     load_balancer_url, video_id,
208                     'Downloading %s %s JSON metadata' % (format_id, quality),
209                     fatal=False) or {}
210                 m3u8_url = load_balancer_data.get('location')
211                 if not m3u8_url:
212                     continue
213                 m3u8_formats = self._extract_m3u8_formats(
214                     m3u8_url, video_id, 'mp4', 'm3u8_native',
215                     m3u8_id=format_id, fatal=False)
216                 if format_id == 'vf':
217                     for f in m3u8_formats:
218                         f['language'] = 'fr'
219                 formats.extend(m3u8_formats)
220         self._sort_formats(formats)
221         video = (self._download_json(
222             self._API_BASE_URL + 'video/%s' % video_id, video_id,
223             'Downloading additional video metadata', fatal=False) or {}).get('video') or {}
224         show = video.get('show') or {}
225 <a name="0"></a>        return {
226             'id': video_id,
227             'title': title,
228             'description': strip_or_none(metas.get('summary') or video.get<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>('summary')),
229             'thumbnail': video_info.get('image') or player.get('image'),
230             'formats': formats,
231             'subtitles': self.extract_subtitles(sub_url, video_id),
232             'episode': metas.get('subtitle') or video.get('name'),
233             'episode_number': int_or_none(video.get(</b></font>'shortNumber')),
234             'series': show.get('title'),
235             'season_number': int_or_none(video.get('season')),
236             'duration': int_or_none(video_info.get('duration') or video.get('duration')),
237             'release_date': unified_strdate(video.get('releaseDate')),
238             'average_rating': float_or_none(video.get('rating') or metas.get('rating')),
239             'comment_count': int_or_none(video.get('commentsCount')),
240         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>twitch.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import unicode_literals
2 import collections
3 import itertools
4 import json
5 import random
6 import re
7 from .common import InfoExtractor
8 from ..compat import (
9     compat_parse_qs,
10     compat_str,
11     compat_urlparse,
12     compat_urllib_parse_urlencode,
13     compat_urllib_parse_urlparse,
14 )
15 from ..utils import (
16     clean_html,
17     dict_get,
18     ExtractorError,
19     float_or_none,
20     int_or_none,
21     parse_duration,
22     parse_iso8601,
23     qualities,
24     try_get,
25     unified_timestamp,
26     update_url_query,
27     url_or_none,
28     urljoin,
29 )
30 class TwitchBaseIE(InfoExtractor):
31     _VALID_URL_BASE = r'https?://(?:(?:www|go|m)\.)?twitch\.tv'
32     _API_BASE = 'https://api.twitch.tv'
33     _USHER_BASE =</b></font> 'https://usher.ttvnw.net'
34     _LOGIN_FORM_URL = 'https://www.twitch.tv/login'
35     _LOGIN_POST_URL = 'https://passport.twitch.tv/login'
36     _CLIENT_ID = 'kimne78kx3ncx6brgo4mv6wki5h1ko'
37     _NETRC_MACHINE = 'twitch'
38     _OPERATION_HASHES = {
39         'CollectionSideBar': '27111f1b382effad0b6def325caef1909c733fe6a4fbabf54f8d491ef2cf2f14',
40         'FilterableVideoTower_Videos': 'a937f1d22e269e39a03b509f65a7490f9fc247d7f83d6ac1421523e3b68042cb',
41         'ClipsCards__User': 'b73ad2bfaecfd30a9e6c28fada15bd97032c83ec77a0440766a56fe0bd632777',
42         'ChannelCollectionsContent': '07e3691a1bad77a36aba590c351180439a40baefc1c275356f40fc7082419a84',
43         'StreamMetadata': '1c719a40e481453e5c48d9bb585d971b8b372f8ebb105b17076722264dfa5b3e',
44         'ComscoreStreamingQuery': 'e1edae8122517d013405f237ffcc124515dc6ded82480a88daef69c83b53ac01',
45         'VideoAccessToken_Clip': '36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11',
46         'VideoPreviewOverlay': '3006e77e51b128d838fa4e835723ca4dc9a05c5efd4466c1085215c6e437e65c',
47         'VideoMetadata': '226edb3e692509f727fd56821f5653c05740242c82b0388883e0c0e75dcbf687',
48     }
49     def _real_initialize(self):
50         self._login()
51     def _login(self):
52         username, password = self._get_login_info()
53         if username is None:
54             return
55         def fail(message):
56             raise ExtractorError(
57                 'Unable to login. Twitch said: %s' % message, expected=True)
58         def login_step(page, urlh, note, data):
59             form = self._hidden_inputs(page)
60             form.update(data)
61             page_url = urlh.geturl()
62             post_url = self._search_regex(
63                 r'&lt;form[^&gt;]+action=(["\'])(?P&lt;url&gt;.+?)\1', page,
64                 'post url', default=self._LOGIN_POST_URL, group='url')
65             post_url = urljoin(page_url, post_url)
66             headers = {
67                 'Referer': page_url,
68                 'Origin': 'https://www.twitch.tv',
69                 'Content-Type': 'text/plain;charset=UTF-8',
70             }
71             response = self._download_json(
72                 post_url, None, note, data=json.dumps(form).encode(),
73                 headers=headers, expected_status=400)
74             error = dict_get(response, ('error', 'error_description', 'error_code'))
75             if error:
76                 fail(error)
77             if 'Authenticated successfully' in response.get('message', ''):
78                 return None, None
79             redirect_url = urljoin(
80                 post_url,
81                 response.get('redirect') or response['redirect_path'])
82             return self._download_webpage_handle(
83                 redirect_url, None, 'Downloading login redirect page',
84                 headers=headers)
85         login_page, handle = self._download_webpage_handle(
86             self._LOGIN_FORM_URL, None, 'Downloading login page')
87         if 'blacklist_message' in login_page:
88             fail(clean_html(login_page))
89         redirect_page, handle = login_step(
90             login_page, handle, 'Logging in', {
91                 'username': username,
92                 'password': password,
93                 'client_id': self._CLIENT_ID,
94             })
95         if not redirect_page:
96             return
97         if re.search(r'(?i)&lt;form[^&gt;]+id="two-factor-submit"', redirect_page) is not None:
98             tfa_token = self._get_tfa_info('two-factor authentication token')
99             login_step(redirect_page, handle, 'Submitting TFA token', {
100                 'authy_token': tfa_token,
101                 'remember_2fa': 'true',
102             })
103     def _prefer_source(self, formats):
104         try:
105             source = next(f for f in formats if f['format_id'] == 'Source')
106             source['quality'] = 10
107         except StopIteration:
108             for f in formats:
109                 if '/chunked/' in f['url']:
110                     f.update({
111                         'quality': 10,
112                         'format_note': 'Source',
113                     })
114         self._sort_formats(formats)
115     def _download_base_gql(self, video_id, ops, note, fatal=True):
116         headers = {
117             'Content-Type': 'text/plain;charset=UTF-8',
118             'Client-ID': self._CLIENT_ID,
119         }
120         gql_auth = self._get_cookies('https://gql.twitch.tv').get('auth-token')
121         if gql_auth:
122             headers['Authorization'] = 'OAuth ' + gql_auth.value
123         return self._download_json(
124             'https://gql.twitch.tv/gql', video_id, note,
125             data=json.dumps(ops).encode(),
126             headers=headers, fatal=fatal)
127     def _download_gql(self, video_id, ops, note, fatal=True):
128         for op in ops:
129             op['extensions'] = {
130                 'persistedQuery': {
131                     'version': 1,
132                     'sha256Hash': self._OPERATION_HASHES[op['operationName']],
133                 }
134             }
135         return self._download_base_gql(video_id, ops, note)
136     def _download_access_token(self, video_id, token_kind, param_name):
137         method = '%sPlaybackAccessToken' % token_kind
138         ops = {
139             'query': '''{
140               %s(
141                 %s: "%s",
142                 params: {
143                   platform: "web",
144                   playerBackend: "mediaplayer",
145                   playerType: "site"
146                 }
147               )
148               {
149                 value
150                 signature
151               }
152             }''' % (method, param_name, video_id),
153         }
154         return self._download_base_gql(
155             video_id, ops,
156             'Downloading %s access token GraphQL' % token_kind)['data'][method]
157 class TwitchVodIE(TwitchBaseIE):
158     IE_NAME = 'twitch:vod'
159     _VALID_URL = r'''(?x)
160                     https?://
161                         (?:
162                             (?:(?:www|go|m)\.)?twitch\.tv/(?:[^/]+/v(?:ideo)?|videos)/|
163                             player\.twitch\.tv/\?.*?\bvideo=v?
164                         )
165                         (?P&lt;id&gt;\d+)
166                     '''
167     _TESTS = [{
168         'url': 'http://www.twitch.tv/riotgames/v/6528877?t=5m10s',
169         'info_dict': {
170             'id': 'v6528877',
171             'ext': 'mp4',
172             'title': 'LCK Summer Split - Week 6 Day 1',
173             'thumbnail': r're:^https?://.*\.jpg$',
174             'duration': 17208,
175             'timestamp': 1435131734,
176             'upload_date': '20150624',
177             'uploader': 'Riot Games',
178             'uploader_id': 'riotgames',
179             'view_count': int,
180             'start_time': 310,
181         },
182         'params': {
183             'skip_download': True,
184         },
185     }, {
186         'url': 'http://www.twitch.tv/belkao_o/v/11230755',
187         'info_dict': {
188             'id': 'v11230755',
189             'ext': 'mp4',
190             'title': 'Untitled Broadcast',
191             'thumbnail': r're:^https?://.*\.jpg$',
192             'duration': 1638,
193             'timestamp': 1439746708,
194             'upload_date': '20150816',
195             'uploader': 'BelkAO_o',
196             'uploader_id': 'belkao_o',
197             'view_count': int,
198         },
199         'params': {
200             'skip_download': True,
201         },
202         'skip': 'HTTP Error 404: Not Found',
203     }, {
204         'url': 'http://player.twitch.tv/?t=5m10s&amp;video=v6528877',
205         'only_matching': True,
206     }, {
207         'url': 'https://www.twitch.tv/videos/6528877',
208         'only_matching': True,
209     }, {
210         'url': 'https://m.twitch.tv/beagsandjam/v/247478721',
211         'only_matching': True,
212     }, {
213         'url': 'https://www.twitch.tv/northernlion/video/291940395',
214         'only_matching': True,
215     }, {
216         'url': 'https://player.twitch.tv/?video=480452374',
217         'only_matching': True,
218     }]
219     def _download_info(self, item_id):
220         data = self._download_gql(
221             item_id, [{
222                 'operationName': 'VideoMetadata',
223                 'variables': {
224                     'channelLogin': '',
225                     'videoID': item_id,
226                 },
227             }],
228             'Downloading stream metadata GraphQL')[0]['data']
229         video = data.get('video')
230         if video is None:
231             raise ExtractorError(
232                 'Video %s does not exist' % item_id, expected=True)
233         return self._extract_info_gql(video, item_id)
234     @staticmethod
235     def _extract_info(info):
236         status = info.get('status')
237         if status == 'recording':
238             is_live = True
239         elif status == 'recorded':
240             is_live = False
241         else:
242             is_live = None
243         _QUALITIES = ('small', 'medium', 'large')
244         quality_key = qualities(_QUALITIES)
245         thumbnails = []
246         preview = info.get('preview')
247         if isinstance(preview, dict):
248             for thumbnail_id, thumbnail_url in preview.items():
249                 thumbnail_url = url_or_none(thumbnail_url)
250                 if not thumbnail_url:
251                     continue
252                 if thumbnail_id not in _QUALITIES:
253                     continue
254                 thumbnails.append({
255                     'url': thumbnail_url,
256                     'preference': quality_key(thumbnail_id),
257                 })
258         return {
259 <a name="0"></a>            'id': info['_id'],
260             'title': info.get('title') or 'Untitled Broadcast',
261             'description': info.get('description'),
262             'duration': int_or_none<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(info.get('length')),
263             'thumbnails': thumbnails,
264             'uploader': info.get('channel', {}).get('display_name'),
265             'uploader_id': info.get('channel', {}).get('name'),
266             'timestamp': parse_iso8601(info.get(</b></font>'recorded_at')),
267             'view_count': int_or_none(info.get('views')),
268             'is_live': is_live,
269         }
270     @staticmethod
271     def _extract_info_gql(info, item_id):
272         vod_id = info.get('id') or item_id
273         if vod_id[0] != 'v':
274             vod_id = 'v%s' % vod_id
275         thumbnail = url_or_none(info.get('previewThumbnailURL'))
276         if thumbnail:
277             for p in ('width', 'height'):
278                 thumbnail = thumbnail.replace('{%s}' % p, '0')
279         return {
280             'id': vod_id,
281             'title': info.get('title') or 'Untitled Broadcast',
282             'description': info.get('description'),
283             'duration': int_or_none(info.get('lengthSeconds')),
284             'thumbnail': thumbnail,
285             'uploader': try_get(info, lambda x: x['owner']['displayName'], compat_str),
286             'uploader_id': try_get(info, lambda x: x['owner']['login'], compat_str),
287             'timestamp': unified_timestamp(info.get('publishedAt')),
288             'view_count': int_or_none(info.get('viewCount')),
289         }
290     def _real_extract(self, url):
291         vod_id = self._match_id(url)
292         info = self._download_info(vod_id)
293         access_token = self._download_access_token(vod_id, 'video', 'id')
294         formats = self._extract_m3u8_formats(
295             '%s/vod/%s.m3u8?%s' % (
296                 self._USHER_BASE, vod_id,
297                 compat_urllib_parse_urlencode({
298                     'allow_source': 'true',
299                     'allow_audio_only': 'true',
300                     'allow_spectre': 'true',
301                     'player': 'twitchweb',
302                     'playlist_include_framerate': 'true',
303                     'nauth': access_token['value'],
304                     'nauthsig': access_token['signature'],
305                 })),
306             vod_id, 'mp4', entry_protocol='m3u8_native')
307         self._prefer_source(formats)
308         info['formats'] = formats
309         parsed_url = compat_urllib_parse_urlparse(url)
310         query = compat_parse_qs(parsed_url.query)
311         if 't' in query:
312             info['start_time'] = parse_duration(query['t'][0])
313         if info.get('timestamp') is not None:
314             info['subtitles'] = {
315                 'rechat': [{
316                     'url': update_url_query(
317                         'https://api.twitch.tv/v5/videos/%s/comments' % vod_id, {
318                             'client_id': self._CLIENT_ID,
319                         }),
320                     'ext': 'json',
321                 }],
322             }
323         return info
324 def _make_video_result(node):
325     assert isinstance(node, dict)
326     video_id = node.get('id')
327     if not video_id:
328         return
329     return {
330         '_type': 'url_transparent',
331         'ie_key': TwitchVodIE.ie_key(),
332         'id': video_id,
333         'url': 'https://www.twitch.tv/videos/%s' % video_id,
334         'title': node.get('title'),
335         'thumbnail': node.get('previewThumbnailURL'),
336         'duration': float_or_none(node.get('lengthSeconds')),
337         'view_count': int_or_none(node.get('viewCount')),
338     }
339 class TwitchCollectionIE(TwitchBaseIE):
340     _VALID_URL = r'https?://(?:(?:www|go|m)\.)?twitch\.tv/collections/(?P&lt;id&gt;[^/]+)'
341     _TESTS = [{
342         'url': 'https://www.twitch.tv/collections/wlDCoH0zEBZZbQ',
343         'info_dict': {
344             'id': 'wlDCoH0zEBZZbQ',
345             'title': 'Overthrow Nook, capitalism for children',
346         },
347         'playlist_mincount': 13,
348     }]
349     _OPERATION_NAME = 'CollectionSideBar'
350     def _real_extract(self, url):
351         collection_id = self._match_id(url)
352         collection = self._download_gql(
353             collection_id, [{
354                 'operationName': self._OPERATION_NAME,
355                 'variables': {'collectionID': collection_id},
356             }],
357             'Downloading collection GraphQL')[0]['data']['collection']
358         title = collection.get('title')
359         entries = []
360         for edge in collection['items']['edges']:
361             if not isinstance(edge, dict):
362                 continue
363             node = edge.get('node')
364             if not isinstance(node, dict):
365                 continue
366             video = _make_video_result(node)
367             if video:
368                 entries.append(video)
369         return self.playlist_result(
370             entries, playlist_id=collection_id, playlist_title=title)
371 class TwitchPlaylistBaseIE(TwitchBaseIE):
372     _PAGE_LIMIT = 100
373     def _entries(self, channel_name, *args):
374         cursor = None
375         variables_common = self._make_variables(channel_name, *args)
376         entries_key = '%ss' % self._ENTRY_KIND
377         for page_num in itertools.count(1):
378             variables = variables_common.copy()
379             variables['limit'] = self._PAGE_LIMIT
380             if cursor:
381                 variables['cursor'] = cursor
382             page = self._download_gql(
383                 channel_name, [{
384                     'operationName': self._OPERATION_NAME,
385                     'variables': variables,
386                 }],
387                 'Downloading %ss GraphQL page %s' % (self._NODE_KIND, page_num),
388                 fatal=False)
389             if not page:
390                 break
391             edges = try_get(
392                 page, lambda x: x[0]['data']['user'][entries_key]['edges'], list)
393             if not edges:
394                 break
395             for edge in edges:
396                 if not isinstance(edge, dict):
397                     continue
398                 if edge.get('__typename') != self._EDGE_KIND:
399                     continue
400                 node = edge.get('node')
401                 if not isinstance(node, dict):
402                     continue
403                 if node.get('__typename') != self._NODE_KIND:
404                     continue
405                 entry = self._extract_entry(node)
406                 if entry:
407                     cursor = edge.get('cursor')
408                     yield entry
409             if not cursor or not isinstance(cursor, compat_str):
410                 break
411 class TwitchVideosIE(TwitchPlaylistBaseIE):
412     _VALID_URL = r'https?://(?:(?:www|go|m)\.)?twitch\.tv/(?P&lt;id&gt;[^/]+)/(?:videos|profile)'
413     _TESTS = [{
414         'url': 'https://www.twitch.tv/spamfish/videos?filter=all',
415         'info_dict': {
416             'id': 'spamfish',
417             'title': 'spamfish - All Videos sorted by Date',
418         },
419         'playlist_mincount': 924,
420     }, {
421         'url': 'https://www.twitch.tv/spamfish/videos?filter=all&amp;sort=views',
422         'info_dict': {
423             'id': 'spamfish',
424             'title': 'spamfish - All Videos sorted by Popular',
425         },
426         'playlist_mincount': 931,
427     }, {
428         'url': 'https://www.twitch.tv/spamfish/videos?filter=archives',
429         'info_dict': {
430             'id': 'spamfish',
431             'title': 'spamfish - Past Broadcasts sorted by Date',
432         },
433         'playlist_mincount': 27,
434     }, {
435         'url': 'https://www.twitch.tv/spamfish/videos?filter=highlights',
436         'info_dict': {
437             'id': 'spamfish',
438             'title': 'spamfish - Highlights sorted by Date',
439         },
440         'playlist_mincount': 901,
441     }, {
442         'url': 'https://www.twitch.tv/esl_csgo/videos?filter=uploads&amp;sort=time',
443         'info_dict': {
444             'id': 'esl_csgo',
445             'title': 'esl_csgo - Uploads sorted by Date',
446         },
447         'playlist_mincount': 5,
448     }, {
449         'url': 'https://www.twitch.tv/spamfish/videos?filter=past_premieres',
450         'info_dict': {
451             'id': 'spamfish',
452             'title': 'spamfish - Past Premieres sorted by Date',
453         },
454         'playlist_mincount': 1,
455     }, {
456         'url': 'https://www.twitch.tv/spamfish/videos/all',
457         'only_matching': True,
458     }, {
459         'url': 'https://m.twitch.tv/spamfish/videos/all',
460         'only_matching': True,
461     }, {
462         'url': 'https://www.twitch.tv/spamfish/videos',
463         'only_matching': True,
464     }]
465     Broadcast = collections.namedtuple('Broadcast', ['type', 'label'])
466     _DEFAULT_BROADCAST = Broadcast(None, 'All Videos')
467     _BROADCASTS = {
468         'archives': Broadcast('ARCHIVE', 'Past Broadcasts'),
469         'highlights': Broadcast('HIGHLIGHT', 'Highlights'),
470         'uploads': Broadcast('UPLOAD', 'Uploads'),
471         'past_premieres': Broadcast('PAST_PREMIERE', 'Past Premieres'),
472         'all': _DEFAULT_BROADCAST,
473     }
474     _DEFAULT_SORTED_BY = 'Date'
475     _SORTED_BY = {
476         'time': _DEFAULT_SORTED_BY,
477         'views': 'Popular',
478     }
479     _OPERATION_NAME = 'FilterableVideoTower_Videos'
480     _ENTRY_KIND = 'video'
481     _EDGE_KIND = 'VideoEdge'
482     _NODE_KIND = 'Video'
483     @classmethod
484     def suitable(cls, url):
485         return (False
486                 if any(ie.suitable(url) for ie in (
487                     TwitchVideosClipsIE,
488                     TwitchVideosCollectionsIE))
489                 else super(TwitchVideosIE, cls).suitable(url))
490     @staticmethod
491     def _make_variables(channel_name, broadcast_type, sort):
492         return {
493             'channelOwnerLogin': channel_name,
494             'broadcastType': broadcast_type,
495             'videoSort': sort.upper(),
496         }
497     @staticmethod
498     def _extract_entry(node):
499         return _make_video_result(node)
500     def _real_extract(self, url):
501         channel_name = self._match_id(url)
502         qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)
503         filter = qs.get('filter', ['all'])[0]
504         sort = qs.get('sort', ['time'])[0]
505         broadcast = self._BROADCASTS.get(filter, self._DEFAULT_BROADCAST)
506         return self.playlist_result(
507             self._entries(channel_name, broadcast.type, sort),
508             playlist_id=channel_name,
509             playlist_title='%s - %s sorted by %s'
510             % (channel_name, broadcast.label,
511                self._SORTED_BY.get(sort, self._DEFAULT_SORTED_BY)))
512 class TwitchVideosClipsIE(TwitchPlaylistBaseIE):
513     _VALID_URL = r'https?://(?:(?:www|go|m)\.)?twitch\.tv/(?P&lt;id&gt;[^/]+)/(?:clips|videos/*?\?.*?\bfilter=clips)'
514     _TESTS = [{
515         'url': 'https://www.twitch.tv/vanillatv/clips?filter=clips&amp;range=all',
516         'info_dict': {
517             'id': 'vanillatv',
518             'title': 'vanillatv - Clips Top All',
519         },
520         'playlist_mincount': 1,
521     }, {
522         'url': 'https://www.twitch.tv/dota2ruhub/videos?filter=clips&amp;range=7d',
523         'only_matching': True,
524     }]
525     Clip = collections.namedtuple('Clip', ['filter', 'label'])
526     _DEFAULT_CLIP = Clip('LAST_WEEK', 'Top 7D')
527     _RANGE = {
528         '24hr': Clip('LAST_DAY', 'Top 24H'),
529         '7d': _DEFAULT_CLIP,
530         '30d': Clip('LAST_MONTH', 'Top 30D'),
531         'all': Clip('ALL_TIME', 'Top All'),
532     }
533     _PAGE_LIMIT = 20
534     _OPERATION_NAME = 'ClipsCards__User'
535     _ENTRY_KIND = 'clip'
536     _EDGE_KIND = 'ClipEdge'
537     _NODE_KIND = 'Clip'
538     @staticmethod
539     def _make_variables(channel_name, filter):
540         return {
541             'login': channel_name,
542             'criteria': {
543                 'filter': filter,
544             },
545         }
546     @staticmethod
547     def _extract_entry(node):
548         assert isinstance(node, dict)
549         clip_url = url_or_none(node.get('url'))
550         if not clip_url:
551             return
552         return {
553             '_type': 'url_transparent',
554             'ie_key': TwitchClipsIE.ie_key(),
555             'id': node.get('id'),
556             'url': clip_url,
557             'title': node.get('title'),
558             'thumbnail': node.get('thumbnailURL'),
559             'duration': float_or_none(node.get('durationSeconds')),
560             'timestamp': unified_timestamp(node.get('createdAt')),
561             'view_count': int_or_none(node.get('viewCount')),
562             'language': node.get('language'),
563         }
564     def _real_extract(self, url):
565         channel_name = self._match_id(url)
566         qs = compat_urlparse.parse_qs(compat_urlparse.urlparse(url).query)
567         range = qs.get('range', ['7d'])[0]
568         clip = self._RANGE.get(range, self._DEFAULT_CLIP)
569         return self.playlist_result(
570             self._entries(channel_name, clip.filter),
571             playlist_id=channel_name,
572             playlist_title='%s - Clips %s' % (channel_name, clip.label))
573 class TwitchVideosCollectionsIE(TwitchPlaylistBaseIE):
574     _VALID_URL = r'https?://(?:(?:www|go|m)\.)?twitch\.tv/(?P&lt;id&gt;[^/]+)/videos/*?\?.*?\bfilter=collections'
575     _TESTS = [{
576         'url': 'https://www.twitch.tv/spamfish/videos?filter=collections',
577         'info_dict': {
578             'id': 'spamfish',
579             'title': 'spamfish - Collections',
580         },
581         'playlist_mincount': 3,
582     }]
583     _OPERATION_NAME = 'ChannelCollectionsContent'
584     _ENTRY_KIND = 'collection'
585     _EDGE_KIND = 'CollectionsItemEdge'
586     _NODE_KIND = 'Collection'
587     @staticmethod
588     def _make_variables(channel_name):
589         return {
590             'ownerLogin': channel_name,
591         }
592     @staticmethod
593     def _extract_entry(node):
594         assert isinstance(node, dict)
595         collection_id = node.get('id')
596         if not collection_id:
597             return
598         return {
599             '_type': 'url_transparent',
600             'ie_key': TwitchCollectionIE.ie_key(),
601             'id': collection_id,
602             'url': 'https://www.twitch.tv/collections/%s' % collection_id,
603             'title': node.get('title'),
604             'thumbnail': node.get('thumbnailURL'),
605             'duration': float_or_none(node.get('lengthSeconds')),
606             'timestamp': unified_timestamp(node.get('updatedAt')),
607             'view_count': int_or_none(node.get('viewCount')),
608         }
609     def _real_extract(self, url):
610         channel_name = self._match_id(url)
611         return self.playlist_result(
612             self._entries(channel_name), playlist_id=channel_name,
613             playlist_title='%s - Collections' % channel_name)
614 class TwitchStreamIE(TwitchBaseIE):
615     IE_NAME = 'twitch:stream'
616     _VALID_URL = r'''(?x)
617                     https?://
618                         (?:
619                             (?:(?:www|go|m)\.)?twitch\.tv/|
620                             player\.twitch\.tv/\?.*?\bchannel=
621                         )
622                         (?P&lt;id&gt;[^/#?]+)
623                     '''
624     _TESTS = [{
625         'url': 'http://www.twitch.tv/shroomztv',
626         'info_dict': {
627             'id': '12772022048',
628             'display_id': 'shroomztv',
629             'ext': 'mp4',
630             'title': 're:^ShroomzTV [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',
631             'description': 'H1Z1 - lonewolfing with ShroomzTV | A3 Battle Royale later - @ShroomzTV',
632             'is_live': True,
633             'timestamp': 1421928037,
634             'upload_date': '20150122',
635             'uploader': 'ShroomzTV',
636             'uploader_id': 'shroomztv',
637             'view_count': int,
638         },
639         'params': {
640             'skip_download': True,
641         },
642     }, {
643         'url': 'http://www.twitch.tv/miracle_doto#profile-0',
644         'only_matching': True,
645     }, {
646         'url': 'https://player.twitch.tv/?channel=lotsofs',
647         'only_matching': True,
648     }, {
649         'url': 'https://go.twitch.tv/food',
650         'only_matching': True,
651     }, {
652         'url': 'https://m.twitch.tv/food',
653         'only_matching': True,
654     }]
655     @classmethod
656     def suitable(cls, url):
657         return (False
658                 if any(ie.suitable(url) for ie in (
659                     TwitchVodIE,
660                     TwitchCollectionIE,
661                     TwitchVideosIE,
662                     TwitchVideosClipsIE,
663                     TwitchVideosCollectionsIE,
664                     TwitchClipsIE))
665                 else super(TwitchStreamIE, cls).suitable(url))
666     def _real_extract(self, url):
667         channel_name = self._match_id(url).lower()
668         gql = self._download_gql(
669             channel_name, [{
670                 'operationName': 'StreamMetadata',
671                 'variables': {'channelLogin': channel_name},
672             }, {
673                 'operationName': 'ComscoreStreamingQuery',
674                 'variables': {
675                     'channel': channel_name,
676                     'clipSlug': '',
677                     'isClip': False,
678                     'isLive': True,
679                     'isVodOrCollection': False,
680                     'vodID': '',
681                 },
682             }, {
683                 'operationName': 'VideoPreviewOverlay',
684                 'variables': {'login': channel_name},
685             }],
686             'Downloading stream GraphQL')
687         user = gql[0]['data']['user']
688         if not user:
689             raise ExtractorError(
690                 '%s does not exist' % channel_name, expected=True)
691         stream = user['stream']
692         if not stream:
693             raise ExtractorError('%s is offline' % channel_name, expected=True)
694         access_token = self._download_access_token(
695             channel_name, 'stream', 'channelName')
696         token = access_token['value']
697         stream_id = stream.get('id') or channel_name
698         query = {
699             'allow_source': 'true',
700             'allow_audio_only': 'true',
701             'allow_spectre': 'true',
702             'p': random.randint(1000000, 10000000),
703             'player': 'twitchweb',
704             'playlist_include_framerate': 'true',
705             'segment_preference': '4',
706             'sig': access_token['signature'].encode('utf-8'),
707             'token': token.encode('utf-8'),
708         }
709         formats = self._extract_m3u8_formats(
710             '%s/api/channel/hls/%s.m3u8' % (self._USHER_BASE, channel_name),
711             stream_id, 'mp4', query=query)
712         self._prefer_source(formats)
713         view_count = stream.get('viewers')
714         timestamp = unified_timestamp(stream.get('createdAt'))
715         sq_user = try_get(gql, lambda x: x[1]['data']['user'], dict) or {}
716         uploader = sq_user.get('displayName')
717         description = try_get(
718             sq_user, lambda x: x['broadcastSettings']['title'], compat_str)
719         thumbnail = url_or_none(try_get(
720             gql, lambda x: x[2]['data']['user']['stream']['previewImageURL'],
721             compat_str))
722         title = uploader or channel_name
723         stream_type = stream.get('type')
724         if stream_type in ['rerun', 'live']:
725             title += ' (%s)' % stream_type
726         return {
727             'id': stream_id,
728             'display_id': channel_name,
729             'title': self._live_title(title),
730             'description': description,
731             'thumbnail': thumbnail,
732             'uploader': uploader,
733             'uploader_id': channel_name,
734             'timestamp': timestamp,
735             'view_count': view_count,
736             'formats': formats,
737             'is_live': stream_type == 'live',
738         }
739 class TwitchClipsIE(TwitchBaseIE):
740     IE_NAME = 'twitch:clips'
741     _VALID_URL = r'''(?x)
742                     https?://
743                         (?:
744                             clips\.twitch\.tv/(?:embed\?.*?\bclip=|(?:[^/]+/)*)|
745                             (?:(?:www|go|m)\.)?twitch\.tv/[^/]+/clip/
746                         )
747                         (?P&lt;id&gt;[^/?#&amp;]+)
748                     '''
749     _TESTS = [{
750         'url': 'https://clips.twitch.tv/FaintLightGullWholeWheat',
751         'md5': '761769e1eafce0ffebfb4089cb3847cd',
752         'info_dict': {
753             'id': '42850523',
754             'ext': 'mp4',
755             'title': 'EA Play 2016 Live from the Novo Theatre',
756             'thumbnail': r're:^https?://.*\.jpg',
757             'timestamp': 1465767393,
758             'upload_date': '20160612',
759             'creator': 'EA',
760             'uploader': 'stereotype_',
761             'uploader_id': '43566419',
762         },
763     }, {
764         'url': 'https://clips.twitch.tv/rflegendary/UninterestedBeeDAESuppy',
765         'only_matching': True,
766     }, {
767         'url': 'https://www.twitch.tv/sergeynixon/clip/StormyThankfulSproutFutureMan',
768         'only_matching': True,
769     }, {
770         'url': 'https://clips.twitch.tv/embed?clip=InquisitiveBreakableYogurtJebaited',
771         'only_matching': True,
772     }, {
773         'url': 'https://m.twitch.tv/rossbroadcast/clip/ConfidentBraveHumanChefFrank',
774         'only_matching': True,
775     }, {
776         'url': 'https://go.twitch.tv/rossbroadcast/clip/ConfidentBraveHumanChefFrank',
777         'only_matching': True,
778     }]
779     def _real_extract(self, url):
780         video_id = self._match_id(url)
781         clip = self._download_gql(
782             video_id, [{
783                 'operationName': 'VideoAccessToken_Clip',
784                 'variables': {
785                     'slug': video_id,
786                 },
787             }],
788             'Downloading clip access token GraphQL')[0]['data']['clip']
789         if not clip:
790             raise ExtractorError(
791                 'This clip is no longer available', expected=True)
792         access_query = {
793             'sig': clip['playbackAccessToken']['signature'],
794             'token': clip['playbackAccessToken']['value'],
795         }
796         data = self._download_base_gql(
797             video_id, {
798                 'query': '''{
799   clip(slug: "%s") {
800     broadcaster {
801       displayName
802     }
803     createdAt
804     curator {
805       displayName
806       id
807     }
808     durationSeconds
809     id
810     tiny: thumbnailURL(width: 86, height: 45)
811     small: thumbnailURL(width: 260, height: 147)
812     medium: thumbnailURL(width: 480, height: 272)
813     title
814     videoQualities {
815       frameRate
816       quality
817       sourceURL
818     }
819     viewCount
820   }
821 }''' % video_id}, 'Downloading clip GraphQL', fatal=False)
822         if data:
823             clip = try_get(data, lambda x: x['data']['clip'], dict) or clip
824         formats = []
825         for option in clip.get('videoQualities', []):
826             if not isinstance(option, dict):
827                 continue
828             source = url_or_none(option.get('sourceURL'))
829             if not source:
830                 continue
831             formats.append({
832                 'url': update_url_query(source, access_query),
833                 'format_id': option.get('quality'),
834                 'height': int_or_none(option.get('quality')),
835                 'fps': int_or_none(option.get('frameRate')),
836             })
837         self._sort_formats(formats)
838         thumbnails = []
839         for thumbnail_id in ('tiny', 'small', 'medium'):
840             thumbnail_url = clip.get(thumbnail_id)
841             if not thumbnail_url:
842                 continue
843             thumb = {
844                 'id': thumbnail_id,
845                 'url': thumbnail_url,
846             }
847             mobj = re.search(r'-(\d+)x(\d+)\.', thumbnail_url)
848             if mobj:
849                 thumb.update({
850                     'height': int(mobj.group(2)),
851                     'width': int(mobj.group(1)),
852                 })
853             thumbnails.append(thumb)
854         return {
855             'id': clip.get('id') or video_id,
856             'title': clip.get('title') or video_id,
857             'formats': formats,
858             'duration': int_or_none(clip.get('durationSeconds')),
859             'views': int_or_none(clip.get('viewCount')),
860             'timestamp': unified_timestamp(clip.get('createdAt')),
861             'thumbnails': thumbnails,
862             'creator': try_get(clip, lambda x: x['broadcaster']['displayName'], compat_str),
863             'uploader': try_get(clip, lambda x: x['curator']['displayName'], compat_str),
864             'uploader_id': try_get(clip, lambda x: x['curator']['id'], compat_str),
865         }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
