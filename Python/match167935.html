<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_process_1.py &amp; lxc_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_process_1.py &amp; lxc_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_process_1.py (4.536222%)<th>lxc_1.py (1.3432237%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-20)<td><a href="#" name="0">(21-41)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(162-166)<td><a href="#" name="1">(3028-3030)</a><td align="center"><font color="#b80000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(843-846)<td><a href="#" name="2">(4325-4329)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(810-813)<td><a href="#" name="3">(1058-1060)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(734-736)<td><a href="#" name="4">(215-222)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_process_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import datetime
2 import functools
3 import io
4 import multiprocessing
5 import os
6 import signal
7 import sys
8 import tempfile
9 import threading
10 import time
11 import warnings
12 import pytest
13 import salt.utils.platform
14 import salt.utils.process
15 from salt.utils.versions import warn_until_date
16 from tests.support.mock import patch
17 from tests.support.unit import TestCase, skipIf
18 HAS_PSUTIL =</b></font> False
19 try:
20     import psutil
21     HAS_PSUTIL = True
22 except ImportError:
23     pass
24 def die(func):
25     @functools.wraps(func)
26     def wrapper(self):
27         name = func.__name__[5:]
28         def _die():
29             salt.utils.process.appendproctitle("test_{}".format(name))
30         attrname = "die_" + name
31         setattr(self, attrname, _die)
32         self.addCleanup(delattr, self, attrname)
33     return wrapper
34 def incr(func):
35     @functools.wraps(func)
36     def wrapper(self):
37         name = func.__name__[5:]
38         def _incr(counter, num):
39             salt.utils.process.appendproctitle("test_{}".format(name))
40             for _ in range(0, num):
41                 counter.value += 1
42         attrname = "incr_" + name
43         setattr(self, attrname, _incr)
44         self.addCleanup(delattr, self, attrname)
45     return wrapper
46 def spin(func):
47     @functools.wraps(func)
48     def wrapper(self):
49         name = func.__name__[5:]
50         def _spin():
51             salt.utils.process.appendproctitle("test_{}".format(name))
52             while True:
53                 time.sleep(1)
54         attrname = "spin_" + name
55         setattr(self, attrname, _spin)
56         self.addCleanup(delattr, self, attrname)
57     return wrapper
58 class TestProcessManager(TestCase):
59     @spin
60     @pytest.mark.slow_test
61     def test_basic(self):
62         process_manager = salt.utils.process.ProcessManager()
63         self.addCleanup(process_manager.terminate)
64         process_manager.add_process(self.spin_basic)
65         initial_pid = next(iter(process_manager._process_map.keys()))
66         time.sleep(2)
67         process_manager.check_children()
68         assert initial_pid == next(iter(process_manager._process_map.keys()))
69     @spin
70     def test_kill(self):
71         process_manager = salt.utils.process.ProcessManager()
72         self.addCleanup(process_manager.terminate)
73         process_manager.add_process(self.spin_kill)
74         initial_pid = next(iter(process_manager._process_map.keys()))
75         if salt.utils.platform.is_windows():
76             os.kill(initial_pid, signal.SIGTERM)
77         else:
78             os.kill(initial_pid, signal.SIGKILL)
79         time.sleep(0.1)
80         process_manager.check_children()
81         assert initial_pid != next(iter(process_manager._process_map.keys()))
82     @die
83     def test_restarting(self):
84         process_manager = salt.utils.process.ProcessManager()
85         self.addCleanup(process_manager.terminate)
86         process_manager.add_process(self.die_restarting)
87         initial_pid = next(iter(process_manager._process_map.keys()))
88         time.sleep(2)
89         process_manager.check_children()
90         assert initial_pid != next(iter(process_manager._process_map.keys()))
91     @incr
92     def test_counter(self):
93         counter = multiprocessing.Value("i", 0)
94         process_manager = salt.utils.process.ProcessManager()
95         self.addCleanup(process_manager.terminate)
96         process_manager.add_process(self.incr_counter, args=(counter, 2))
97         time.sleep(1)
98         process_manager.check_children()
99         time.sleep(1)
100         assert counter.value == 4
101 class TestThreadPool(TestCase):
102     @pytest.mark.slow_test
103     def test_basic(self):
104         def incr_counter(counter):
105             counter.value += 1
106 <a name="1"></a>
107         counter = multiprocessing.Value("i", 0)
108         pool = salt.utils.process<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.ThreadPool()
109         sent = pool.fire_async(incr_counter, args=(counter,))
110         self.assertTrue(sent)
111         time.sleep(1)  # Sleep to let the threads do things
112         self.assertEqual(</b></font>counter.value, 1)
113         self.assertEqual(pool._job_queue.qsize(), 0)
114     @pytest.mark.slow_test
115     def test_full_queue(self):
116         def incr_counter(counter):
117             counter.value += 1
118         counter = multiprocessing.Value("i", 0)
119         pool = salt.utils.process.ThreadPool(0, 1)
120         sent = pool.fire_async(incr_counter, args=(counter,))
121         self.assertTrue(sent)
122         sent = pool.fire_async(incr_counter, args=(counter,))
123         self.assertFalse(sent)
124         time.sleep(1)  # Sleep to let the threads do things
125         self.assertEqual(counter.value, 0)
126         self.assertEqual(pool._job_queue.qsize(), 1)
127 class TestProcess(TestCase):
128     def test_daemonize_if(self):
129         with patch("sys.argv", ["salt-call"]):
130             ret = salt.utils.process.daemonize_if({})
131             self.assertEqual(None, ret)
132         ret = salt.utils.process.daemonize_if({"multiprocessing": False})
133         self.assertEqual(None, ret)
134         with patch("sys.platform", "win"):
135             ret = salt.utils.process.daemonize_if({})
136             self.assertEqual(None, ret)
137         with patch("salt.utils.process.daemonize"), patch("sys.platform", "linux2"):
138             salt.utils.process.daemonize_if({})
139             self.assertTrue(salt.utils.process.daemonize.called)
140 class TestProcessCallbacks(TestCase):
141     @staticmethod
142     def process_target(evt):
143         evt.set()
144     def test_callbacks(self):
145         "Validate Process call after fork and finalize methods"
146         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
147         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
148         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
149             evt = multiprocessing.Event()
150             proc = salt.utils.process.Process(target=self.process_target, args=(evt,))
151             proc.run()
152             assert evt.is_set()
153         mb.assert_called()
154         ma.assert_called()
155     def test_callbacks_called_when_run_overridden(self):
156         "Validate Process sub classes call after fork and finalize methods when run is overridden"
157         class MyProcess(salt.utils.process.Process):
158             def __init__(self):
159                 super().__init__()
160                 self.evt = multiprocessing.Event()
161             def run(self):
162                 self.evt.set()
163         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
164         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
165         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
166             proc = MyProcess()
167             proc.run()
168             assert proc.evt.is_set()
169         ma.assert_called()
170         mb.assert_called()
171 @skipIf(not HAS_PSUTIL, "Missing psutil")
172 class TestSignalHandlingProcess(TestCase):
173     @classmethod
174     def Process(cls, pid):
175         raise psutil.NoSuchProcess(pid)
176     @classmethod
177     def target(cls):
178         os.kill(os.getpid(), signal.SIGTERM)
179     @classmethod
180     def children(cls, *args, **kwargs):
181         raise psutil.NoSuchProcess(1)
182     def test_process_does_not_exist(self):
183         try:
184             with patch("psutil.Process", self.Process):
185                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
186                 proc.start()
187         except psutil.NoSuchProcess:
188             assert False, "psutil.NoSuchProcess raised"
189     def test_process_children_do_not_exist(self):
190         try:
191             with patch("psutil.Process.children", self.children):
192                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
193                 proc.start()
194         except psutil.NoSuchProcess:
195             assert False, "psutil.NoSuchProcess raised"
196     @staticmethod
197     def run_forever_sub_target(evt):
198         "Used by run_forever_target to create a sub-process"
199         while not evt.is_set():
200             time.sleep(1)
201     @staticmethod
202     def run_forever_target(sub_target, evt):
203         "A target that will run forever or until an event is set"
204         p = multiprocessing.Process(target=sub_target, args=(evt,))
205         p.start()
206         p.join()
207     @staticmethod
208     def kill_target_sub_proc():
209         pid = os.fork()
210         if pid == 0:
211             return
212         pid = os.fork()
213         if pid == 0:
214             return
215         time.sleep(0.1)
216         try:
217             os.kill(os.getpid(), signal.SIGINT)
218         except KeyboardInterrupt:
219             pass
220     @skipIf(sys.platform.startswith("win"), "No os.fork on Windows")
221     @pytest.mark.slow_test
222     def test_signal_processing_regression_test(self):
223         evt = multiprocessing.Event()
224         sh_proc = salt.utils.process.SignalHandlingProcess(
225             target=self.run_forever_target, args=(self.run_forever_sub_target, evt)
226         )
227         sh_proc.start()
228         proc = multiprocessing.Process(target=self.kill_target_sub_proc)
229         proc.start()
230         proc.join()
231         try:
232             assert sh_proc.is_alive()
233         finally:
234             evt.set()
235             sh_proc.join()
236     @staticmethod
237     def no_op_target():
238         pass
239     @staticmethod
240     def pid_setting_target(sub_target, val, evt):
241         val.value = os.getpid()
242         p = multiprocessing.Process(target=sub_target, args=(evt,))
243         p.start()
244         p.join()
245     @skipIf(sys.platform.startswith("win"), "Required signals not supported on windows")
246     @pytest.mark.slow_test
247     def test_signal_processing_handle_signals_called(self):
248         "Validate SignalHandlingProcess handles signals"
249         evt = multiprocessing.Event()
250         val = multiprocessing.Value("i", 0)
251         proc = salt.utils.process.SignalHandlingProcess(
252             target=self.pid_setting_target,
253             args=(self.run_forever_sub_target, val, evt),
254         )
255         proc.start()
256         proc2 = multiprocessing.Process(
257             target=self.run_forever_target,
258             args=(self.run_forever_sub_target, evt),
259         )
260         proc2.start()
261         while not val.value:
262             time.sleep(0.3)
263         assert not proc.signal_handled()
264         os.kill(val.value, signal.SIGTERM)
265         start = time.time()
266         while time.time() - start &lt; 10:
267             if proc.signal_handled():
268                 break
269             time.sleep(0.3)
270         try:
271             assert proc.signal_handled()
272             proc.join(1)
273             assert proc2.is_alive()
274         finally:
275             evt.set()
276             proc2.join(30)
277             proc.join(30)
278 class TestSignalHandlingProcessCallbacks(TestCase):
279     @staticmethod
280     def process_target(evt):
281         evt.set()
282     def test_callbacks(self):
283         "Validate SignalHandlingProcess call after fork and finalize methods"
284         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
285         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
286         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
287         evt = multiprocessing.Event()
288         with patch(sig_to_mock):
289             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
290                 sh_proc = salt.utils.process.SignalHandlingProcess(
291                     target=self.process_target, args=(evt,)
292                 )
293                 sh_proc.run()
294                 assert evt.is_set()
295         ma.assert_called()
296         mb.assert_called()
297     def test_callbacks_called_when_run_overridden(self):
298         "Validate SignalHandlingProcess sub classes call after fork and finalize methods when run is overridden"
299         class MyProcess(salt.utils.process.SignalHandlingProcess):
300             def __init__(self):
301                 super().__init__()
302                 self.evt = multiprocessing.Event()
303             def run(self):
304                 self.evt.set()
305         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
306         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
307         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
308         with patch(sig_to_mock):
309             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
310                 sh_proc = MyProcess()
311                 sh_proc.run()
312                 assert sh_proc.evt.is_set()
313         ma.assert_called()
314         mb.assert_called()
315 class TestDup2(TestCase):
316     def test_dup2_no_fileno(self):
317         "The dup2 method does not fail on streams without fileno support"
318         f1 = io.StringIO("some initial text data")
319         f2 = io.StringIO("some initial other text data")
320         with self.assertRaises(io.UnsupportedOperation):
321             f1.fileno()
322         with patch("os.dup2") as dup_mock:
323             try:
324                 salt.utils.process.dup2(f1, f2)
325             except io.UnsupportedOperation:
326                 assert False, "io.UnsupportedOperation was raised"
327         assert not dup_mock.called
328 def null_target():
329     pass
330 def event_target(event):
331     while True:
332         if event.wait(5):
333             break
334 class TestProcessList(TestCase):
335     @staticmethod
336     def wait_for_proc(proc, timeout=10):
337         start = time.time()
338         while proc.is_alive():
339             if time.time() - start &gt; timeout:
340                 raise Exception("Process did not finishe before timeout")
341             time.sleep(0.3)
342     @pytest.mark.slow_test
343     def test_process_list_process(self):
344         plist = salt.utils.process.SubprocessList()
345         proc = multiprocessing.Process(target=null_target)
346         proc.start()
347         plist.add(proc)
348         assert proc in plist.processes
349         self.wait_for_proc(proc)
350         assert not proc.is_alive()
351         plist.cleanup()
352         assert proc not in plist.processes
353     def test_process_list_thread(self):
354         plist = salt.utils.process.SubprocessList()
355         thread = threading.Thread(target=null_target)
356         thread.start()
357         plist.add(thread)
358         assert thread in plist.processes
359         self.wait_for_proc(thread)
360         assert not thread.is_alive()
361         plist.cleanup()
362         assert thread not in plist.processes
363     @pytest.mark.slow_test
364     def test_process_list_cleanup(self):
365         plist = salt.utils.process.SubprocessList()
366         event = multiprocessing.Event()
367         proc = multiprocessing.Process(target=event_target, args=[event])
368         proc.start()
369         plist.add(proc)
370         assert proc in plist.processes
371         plist.cleanup()
372         event.set()
373         assert proc in plist.processes
374         self.wait_for_proc(proc)
375         assert not proc.is_alive()
376         plist.cleanup()
377         assert proc not in plist.processes
378 class TestDeprecatedClassNames(TestCase):
379     @staticmethod
380     def process_target():
381         pass
382     @staticmethod
383     def patched_warn_until_date(current_date):
384         def _patched_warn_until_date(
385             date,
386             message,
387             category=DeprecationWarning,
388             stacklevel=None,
389             _current_date=current_date,
390             _dont_call_warnings=False,
391         ):
392             stacklevel = 4
393             return warn_until_date(
394                 date,
395                 message,
396                 category=category,
397                 stacklevel=stacklevel,
398                 _current_date=_current_date,
399                 _dont_call_warnings=_dont_call_warnings,
400             )
401         return _patched_warn_until_date
402     def test_multiprocessing_process_warning(self):
403         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
404         fake_utcnow = datetime.date(2021, 1, 1)
405         proc = None
406         try:
407             with patch(
408                 "salt.utils.versions.warn_until_date",
409                 self.patched_warn_until_date(fake_utcnow),
410             ):
411                 with warnings.catch_warnings(record=True) as recorded_warnings:
412                     proc = salt.utils.process.MultiprocessingProcess(
413                         target=self.process_target
414                     )
415                     self.assertEqual(
416                         "Please stop using 'salt.utils.process.MultiprocessingProcess' "
417                         "and instead use 'salt.utils.process.Process'. "
418                         "'salt.utils.process.MultiprocessingProcess' will go away "
419                         "after 2022-01-01.",
420                         str(recorded_warnings[0].message),
421                     )
422         finally:
423             if proc is not None:
424                 del proc
425     def test_multiprocessing_process_runtime_error(self):
426         fake_utcnow = datetime.date(2022, 1, 1)
427         proc = None
428         try:
429             with patch(
430                 "salt.utils.versions.warn_until_date",
431                 self.patched_warn_until_date(fake_utcnow),
432             ):
433                 with self.assertRaisesRegex(
434                     RuntimeError,
435                     r"Please stop using 'salt.utils.process.MultiprocessingProcess' "
436                     r"and instead use 'salt.utils.process.Process'. "
437                     r"'salt.utils.process.MultiprocessingProcess' will go away "
438                     r"after 2022-01-01. "
439                     r"This warning\(now exception\) triggered on "
440                     r"filename '(.*)test_process.py', line number ([\d]+), is "
441                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
442                     r"Please remove the warning.",
443                 ):
444                     proc = salt.utils.process.MultiprocessingProcess(
445                         target=self.process_target
446                     )
447         finally:
448             if proc is not None:
449                 del proc
450     def test_signal_handling_multiprocessing_process_warning(self):
451         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
452         fake_utcnow = datetime.date(2021, 1, 1)
453         proc = None
454         try:
455             with patch(
456                 "salt.utils.versions.warn_until_date",
457                 self.patched_warn_until_date(fake_utcnow),
458             ):
459                 with warnings.catch_warnings(record=True) as recorded_warnings:
460                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
461                         target=self.process_target
462                     )
463                     self.assertEqual(
464                         "Please stop using"
465                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess' and"
466                         " instead use 'salt.utils.process.SignalHandlingProcess'."
467                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess'"
468                         " will go away after 2022-01-01.",
469                         str(recorded_warnings[0].message),
470                     )
471         finally:
472             if proc is not None:
473                 del proc
474     def test_signal_handling_multiprocessing_process_runtime_error(self):
475         fake_utcnow = datetime.date(2022, 1, 1)
476         proc = None
477         try:
478             with patch(
479                 "salt.utils.versions.warn_until_date",
480                 self.patched_warn_until_date(fake_utcnow),
481             ):
482                 with self.assertRaisesRegex(
483                     RuntimeError,
484                     r"Please stop using"
485                     r" 'salt.utils.process.SignalHandlingMultiprocessingProcess' "
486                     r"and instead use 'salt.utils.process.SignalHandlingProcess'. "
487                     r"'salt.utils.process.SignalHandlingMultiprocessingProcess' will go"
488                     r" away "
489                     r"after 2022-01-01. "
490                     r"This warning\(now exception\) triggered on "
491                     r"filename '(.*)test_process.py', line number ([\d]+), is "
492                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
493                     r"Please remove the warning.",
494                 ):
495                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
496                         target=self.process_target
497                     )
498         finally:
499             if proc is not None:
500                 del proc
501 class CMORProcessHelper:
502     def __init__(self, file_name):
503         self._lock = threading.Lock()
504         self._running = True
505         self._queue = multiprocessing.Queue()
506         self._ret_queue = multiprocessing.Queue()
507         self._process = multiprocessing.Process(
508             target=self.test_process,
509             args=(file_name, self._queue, self._ret_queue),
510             daemon=True,
511         )
512         self._process.start()
513     def __enter__(self):
514         return self
515     def __exit__(self, exc_type, exc_val, exc_tb):
516         self.stop()
517     def claim(self):
518         try:
519             self._lock.acquire()
520             if self._running:
521                 self._queue.put("claim")
522                 return self._ret_queue.get(timeout=10)
523         finally:
524             self._lock.release()
525     def stop(self):
526         try:
527             self._lock.acquire()
528             if self._running:
529                 self._running = False
530                 self._queue.put("stop")
531                 self._process.join(timeout=10)
532                 self._queue.close()
533                 self._ret_queue.close()
534         finally:
535             self._lock.release()
536     @property
537     def pid(self):
538         return self._process.pid
539     @staticmethod
540     def test_process(file_name, queue, ret_queue):
541         while True:
542             action = queue.get()
543             if action == "claim":
544                 ret_queue.put(
545                     salt.utils.process.claim_mantle_of_responsibility(file_name)
546                 )
547             elif action == "stop":
548                 return
549 @skipIf(not HAS_PSUTIL, "Missing psutil")
550 class TestGetProcessInfo(TestCase):
551     def setUp(self):
552         handle, self.cmor_test_file_path = tempfile.mkstemp()
553         os.close(handle)
554         self.addCleanup(os.unlink, self.cmor_test_file_path)
555     def test_this_process(self):
556         this_process_info = salt.utils.process.get_process_info()
557         self.assertEqual(
558             this_process_info, salt.utils.process.get_process_info(os.getpid())
559         )
560         self.assertIsNotNone(this_process_info)
561 <a name="4"></a>        for key in ("pid", "name", "start_time"):
562             self.assertIn(key, this_process_info)
563         raw_process_info = psutil<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Process(os.getpid())
564         self.assertEqual(this_process_info["pid"], os.getpid())
565         self.assertEqual(this_process_info[</b></font>"name"], raw_process_info.name())
566         self.assertEqual(
567             this_process_info["start_time"], raw_process_info.create_time()
568         )
569     def test_random_processes(self):
570         for _ in range(3):
571             with CMORProcessHelper(self.cmor_test_file_path) as p1:
572                 pid = p1.pid
573                 self.assertIsInstance(salt.utils.process.get_process_info(pid), dict)
574             self.assertIsNone(salt.utils.process.get_process_info(pid))
575 @skipIf(not HAS_PSUTIL, "Missing psutil")
576 class TestClaimMantleOfResponsibility(TestCase):
577     def setUp(self):
578         handle, self.cmor_test_file_path = tempfile.mkstemp()
579         os.close(handle)
580         self.addCleanup(os.unlink, self.cmor_test_file_path)
581     def test_simple_claim_no_psutil(self):
582         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
583     def test_simple_claim(self):
584         for _ in range(5):
585             self.assertTrue(
586                 salt.utils.process.claim_mantle_of_responsibility(
587                     self.cmor_test_file_path
588                 )
589             )
590     def test_multiple_processes(self):
591         with CMORProcessHelper(self.cmor_test_file_path) as p1:
592             self.assertTrue(p1.claim())
593             self.assertFalse(
594                 salt.utils.process.claim_mantle_of_responsibility(
595                     self.cmor_test_file_path
596                 )
597             )
598             with CMORProcessHelper(self.cmor_test_file_path) as p2:
599                 for _ in range(3):
600                     self.assertFalse(p2.claim())
601             self.assertTrue(p1.claim())
602         with CMORProcessHelper(self.cmor_test_file_path) as p1:
603             self.assertTrue(p1.claim())
604             self.assertFalse(
605                 salt.utils.process.claim_mantle_of_responsibility(
606                     self.cmor_test_file_path
607                 )
608             )
609         self.assertTrue(
610             salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
611         )
612 @skipIf(not HAS_PSUTIL, "Missing psutil")
613 class TestCheckMantleOfResponsibility(TestCase):
614     def setUp(self):
615         handle, self.cmor_test_file_path = tempfile.mkstemp()
616         os.close(handle)
617         self.addCleanup(os.unlink, self.cmor_test_file_path)
618     def test_simple_claim_no_psutil(self):
619         self.assertIsNone(
620             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
621         )
622     def test_simple_claim(self):
623         self.assertIsNone(
624 <a name="3"></a>            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
625         )
626         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
627         pid = salt<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.process.get_process_info()["pid"]
628         self.assertEqual(
629             pid,
630             salt.utils.process.check_mantle_of_responsibility(self.</b></font>cmor_test_file_path),
631         )
632     def test_multiple_processes(self):
633         self.assertIsNone(
634             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
635         )
636         with CMORProcessHelper(self.cmor_test_file_path) as p1:
637             self.assertTrue(p1.claim())
638             random_pid = salt.utils.process.check_mantle_of_responsibility(
639                 self.cmor_test_file_path
640             )
641             self.assertIsInstance(random_pid, int)
642             with CMORProcessHelper(self.cmor_test_file_path) as p2:
643                 for _ in range(3):
644                     self.assertFalse(p2.claim())
645                 self.assertEqual(
646                     random_pid,
647                     salt.utils.process.check_mantle_of_responsibility(
648                         self.cmor_test_file_path
649                     ),
650                 )
651         self.assertIsNone(
652 <a name="2"></a>            salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
653         )
654         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
655         pid = salt<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.process.get_process_info()["pid"]
656         self.assertEqual(
657             pid,
658             salt.utils.process.check_mantle_of_responsibility(self.</b></font>cmor_test_file_path),
659         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import difflib
4 import logging
5 import os
6 import pipes
7 import random
8 import re
9 <a name="0"></a>import shutil
10 import string
11 import tempfile
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import textwrap
13 import time
14 import urllib.parse
15 import salt.config
16 import salt.utils.args
17 import salt.utils.cloud
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.functools
22 import salt.utils.hashutils
23 import salt.utils.network
24 import salt.utils.odict
25 import salt.utils.path
26 import salt.utils.stringutils
27 from salt.exceptions import CommandExecutionError, SaltInvocationError
28 from salt.utils.versions import LooseVersion as _LooseVersion
29 log =</b></font> logging.getLogger(__name__)
30 __func_alias__ = {"list_": "list", "ls_": "ls"}
31 __virtualname__ = "lxc"
32 DEFAULT_NIC = "eth0"
33 DEFAULT_BR = "br0"
34 SEED_MARKER = "/lxc.initial_seed"
35 EXEC_DRIVER = "lxc-attach"
36 DEFAULT_PATH = "/var/lib/lxc"
37 _marker = object()
38 def __virtual__():
39     if salt.utils.path.which("lxc-start"):
40         return __virtualname__
41     return (
42         False,
43         "The lxc execution module cannot be loaded: the lxc-start binary is not in the"
44         " path.",
45     )
46 def get_root_path(path):
47     if not path:
48         path = __opts__.get("lxc.root_path", DEFAULT_PATH)
49     return path
50 def version():
51     k = "lxc.version"
52     if not __context__.get(k, None):
53         cversion = __salt__["cmd.run_all"]("lxc-info --version")
54         if not cversion["retcode"]:
55             ver = _LooseVersion(cversion["stdout"])
56             if ver &lt; _LooseVersion("1.0"):
57                 raise CommandExecutionError("LXC should be at least 1.0")
58             __context__[k] = "{}".format(ver)
59     return __context__.get(k, None)
60 def _clear_context():
61     for var in [x for x in __context__ if x.startswith("lxc.")]:
62         log.trace("Clearing __context__['%s']", var)
63         __context__.pop(var, None)
64 def _ip_sort(ip):
65     idx = "001"
66     if ip == "127.0.0.1":
67         idx = "200"
68     if ip == "::1":
69         idx = "201"
70     elif "::" in ip:
71         idx = "100"
72     return "{}___{}".format(idx, ip)
73 def search_lxc_bridges():
74     bridges = __context__.get("lxc.bridges", None)
75     if not bridges:
76         bridges = set()
77         running_bridges = set()
78         bridges.add(DEFAULT_BR)
79         try:
80             output = __salt__["cmd.run_all"]("brctl show")
81             for line in output["stdout"].splitlines()[1:]:
82                 if not line.startswith(" "):
83                     running_bridges.add(line.split()[0].strip())
84         except (SaltInvocationError, CommandExecutionError):
85             pass
86         for ifc, ip in __grains__.get("ip_interfaces", {}).items():
87             if ifc in running_bridges:
88                 bridges.add(ifc)
89             elif os.path.exists("/sys/devices/virtual/net/{}/bridge".format(ifc)):
90                 bridges.add(ifc)
91         bridges = list(bridges)
92         def sort_bridges(a):
93             pref = "z"
94             if "lxc" in a:
95                 pref = "a"
96             elif "br0" == a:
97                 pref = "c"
98             return "{}_{}".format(pref, a)
99         bridges.sort(key=sort_bridges)
100         __context__["lxc.bridges"] = bridges
101     return bridges
102 def search_lxc_bridge():
103     return search_lxc_bridges()[0]
104 def _get_salt_config(config, **kwargs):
105     if not config:
106 <a name="4"></a>        config = kwargs.get("minion", {})
107     if not config:
108         config = {}
109     config<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.setdefault(
110         "master", kwargs.get("master", __opts__.get("master", __opts__["id"]))
111     )
112     config.setdefault(
113         "master_port",
114         kwargs.get(
115             "master_port",
116             __opts__.</b></font>get("master_port", __opts__.get("ret_port", __opts__.get("4506"))),
117         ),
118     )
119     if not config["master"]:
120         config = {}
121     return config
122 def cloud_init_interface(name, vm_=None, **kwargs):
123     if vm_ is None:
124         vm_ = {}
125     vm_ = copy.deepcopy(vm_)
126     vm_ = salt.utils.dictupdate.update(vm_, kwargs)
127     profile_data = copy.deepcopy(vm_.get("lxc_profile", vm_.get("profile", {})))
128     if not isinstance(profile_data, (dict, (str,))):
129         profile_data = {}
130     profile = get_container_profile(profile_data)
131     def _cloud_get(k, default=None):
132         return vm_.get(k, profile.get(k, default))
133     if name is None:
134         name = vm_["name"]
135     default_template = ""
136     if __grains__.get("os", "") in ["Ubuntu"]:
137         default_template = "ubuntu"
138     image = _cloud_get("image")
139     if not image:
140         _cloud_get("template", default_template)
141     backing = _cloud_get("backing", "dir")
142     if image:
143         profile["template"] = image
144     vgname = _cloud_get("vgname", None)
145     if vgname:
146         profile["vgname"] = vgname
147     if backing:
148         profile["backing"] = backing
149     snapshot = _cloud_get("snapshot", False)
150     autostart = bool(_cloud_get("autostart", True))
151     dnsservers = _cloud_get("dnsservers", [])
152     dns_via_dhcp = _cloud_get("dns_via_dhcp", True)
153     password = _cloud_get("password", "s3cr3t")
154     password_encrypted = _cloud_get("password_encrypted", False)
155     fstype = _cloud_get("fstype", None)
156     lvname = _cloud_get("lvname", None)
157     thinpool = _cloud_get("thinpool", None)
158     pub_key = _cloud_get("pub_key", None)
159     priv_key = _cloud_get("priv_key", None)
160     size = _cloud_get("size", "20G")
161     script = _cloud_get("script", None)
162     script_args = _cloud_get("script_args", None)
163     users = _cloud_get("users", None)
164     if users is None:
165         users = []
166     ssh_username = _cloud_get("ssh_username", None)
167     if ssh_username and (ssh_username not in users):
168         users.append(ssh_username)
169     network_profile = _cloud_get("network_profile", None)
170     nic_opts = kwargs.get("nic_opts", None)
171     netmask = _cloud_get("netmask", "24")
172     path = _cloud_get("path", None)
173     bridge = _cloud_get("bridge", None)
174     gateway = _cloud_get("gateway", None)
175     unconditional_install = _cloud_get("unconditional_install", False)
176     force_install = _cloud_get("force_install", True)
177     config = _get_salt_config(_cloud_get("config", {}), **vm_)
178     default_nic = _cloud_get("default_nic", DEFAULT_NIC)
179     if not isinstance(nic_opts, dict):
180         nic_opts = salt.utils.odict.OrderedDict()
181     eth0 = nic_opts.setdefault(default_nic, salt.utils.odict.OrderedDict())
182     if not isinstance(nic_opts, salt.utils.odict.OrderedDict):
183         bnic_opts = salt.utils.odict.OrderedDict()
184         bnic_opts.update(nic_opts)
185         nic_opts = bnic_opts
186     gw = None
187     bridge = _cloud_get("bridge", None)
188     ip = _cloud_get("ip", None)
189     mac = _cloud_get("mac", None)
190     if ip:
191         fullip = ip
192         if netmask:
193             fullip += "/{}".format(netmask)
194         eth0["ipv4"] = fullip
195         if mac is not None:
196             eth0["mac"] = mac
197     for ix, iopts in enumerate(_cloud_get("additional_ips", [])):
198         ifh = "eth{}".format(ix + 1)
199         ethx = nic_opts.setdefault(ifh, {})
200         if gw is None:
201             gw = iopts.get("gateway", ethx.get("gateway", None))
202             if gw:
203                 eth0.pop("gateway", None)
204                 gateway = None
205                 ethx["gateway"] = gw
206         elink = iopts.get("link", ethx.get("link", None))
207         if elink:
208             ethx["link"] = elink
209         aip = iopts.get("ipv4", iopts.get("ip", None))
210         if aip:
211             ethx["ipv4"] = aip
212         nm = iopts.get("netmask", "")
213         if nm:
214             ethx["ipv4"] += "/{}".format(nm)
215         for i in ("mac", "hwaddr"):
216             if i in iopts:
217                 ethx["mac"] = iopts[i]
218                 break
219         if "mac" not in ethx:
220             ethx["mac"] = salt.utils.network.gen_mac()
221     gw = None
222     for ethx in [a for a in nic_opts]:
223         ndata = nic_opts[ethx]
224         if gw:
225             ndata.pop("gateway", None)
226         if "gateway" in ndata:
227             gw = ndata["gateway"]
228             gateway = None
229     if bridge:
230         eth0["link"] = bridge
231     if gateway:
232         eth0["gateway"] = gateway
233     lxc_init_interface = {}
234     lxc_init_interface["name"] = name
235     lxc_init_interface["config"] = config
236     lxc_init_interface["memory"] = _cloud_get("memory", 0)  # nolimit
237     lxc_init_interface["pub_key"] = pub_key
238     lxc_init_interface["priv_key"] = priv_key
239     lxc_init_interface["nic_opts"] = nic_opts
240     for clone_from in ["clone_from", "clone", "from_container"]:
241         lxc_init_interface["clone_from"] = _cloud_get(clone_from, None)
242         if lxc_init_interface["clone_from"] is not None:
243             break
244     lxc_init_interface["profile"] = profile
245     lxc_init_interface["snapshot"] = snapshot
246     lxc_init_interface["dnsservers"] = dnsservers
247     lxc_init_interface["fstype"] = fstype
248     lxc_init_interface["path"] = path
249     lxc_init_interface["vgname"] = vgname
250     lxc_init_interface["size"] = size
251     lxc_init_interface["lvname"] = lvname
252     lxc_init_interface["thinpool"] = thinpool
253     lxc_init_interface["force_install"] = force_install
254     lxc_init_interface["unconditional_install"] = unconditional_install
255     lxc_init_interface["bootstrap_url"] = script
256     lxc_init_interface["bootstrap_args"] = script_args
257     lxc_init_interface["bootstrap_shell"] = _cloud_get("bootstrap_shell", "sh")
258     lxc_init_interface["bootstrap_delay"] = _cloud_get("bootstrap_delay", None)
259     lxc_init_interface["autostart"] = autostart
260     lxc_init_interface["users"] = users
261     lxc_init_interface["password"] = password
262     lxc_init_interface["password_encrypted"] = password_encrypted
263     lxc_init_interface["network_profile"] = network_profile
264     for i in ["cpu", "cpuset", "cpushare"]:
265         if _cloud_get(i, None):
266             try:
267                 lxc_init_interface[i] = vm_[i]
268             except KeyError:
269                 lxc_init_interface[i] = profile[i]
270     return lxc_init_interface
271 def _get_profile(key, name, **kwargs):
272     if isinstance(name, dict):
273         profilename = name.pop("name", None)
274         return _get_profile(key, profilename, **name)
275     if name is None:
276         profile_match = {}
277     else:
278         profile_match = __salt__["config.get"](
279             "lxc.{1}:{0}".format(name, key), default=None, merge="recurse"
280         )
281         if profile_match is None:
282             profile_match = {}
283     if not isinstance(profile_match, dict):
284         raise CommandExecutionError("lxc.{} must be a dictionary".format(key))
285     overrides = salt.utils.args.clean_kwargs(**copy.deepcopy(kwargs))
286     profile_match = salt.utils.dictupdate.update(
287         copy.deepcopy(profile_match), overrides
288     )
289     return profile_match
290 def get_container_profile(name=None, **kwargs):
291     profile = _get_profile("container_profile", name, **kwargs)
292     return profile
293 def get_network_profile(name=None, **kwargs):
294     profile = _get_profile("network_profile", name, **kwargs)
295     return profile
296 def _rand_cpu_str(cpu):
297     cpu = int(cpu)
298     avail = __salt__["status.nproc"]()
299     if cpu &lt; avail:
300         return "0-{}".format(avail)
301     to_set = set()
302     while len(to_set) &lt; cpu:
303         choice = random.randint(0, avail - 1)
304         if choice not in to_set:
305             to_set.add(str(choice))
306     return ",".join(sorted(to_set))
307 def _network_conf(conf_tuples=None, **kwargs):
308     nic = kwargs.get("network_profile", None)
309     ret = []
310     nic_opts = kwargs.get("nic_opts", {})
311     if nic_opts is None:
312         nic_opts = {}
313     if not conf_tuples:
314         conf_tuples = []
315     old = _get_veths(conf_tuples)
316     if not old:
317         old = {}
318     if nic and isinstance(nic, ((str,), dict)):
319         nicp = get_network_profile(nic)
320     else:
321         nicp = {}
322     if DEFAULT_NIC not in nicp:
323         nicp[DEFAULT_NIC] = {}
324     kwargs = copy.deepcopy(kwargs)
325     gateway = kwargs.pop("gateway", None)
326     bridge = kwargs.get("bridge", None)
327     if nic_opts:
328         for dev, args in nic_opts.items():
329             ethx = nicp.setdefault(dev, {})
330             try:
331                 ethx = salt.utils.dictupdate.update(ethx, args)
332             except AttributeError:
333                 raise SaltInvocationError("Invalid nic_opts configuration")
334     ifs = [a for a in nicp]
335     ifs += [a for a in old if a not in nicp]
336     ifs.sort()
337     gateway_set = False
338     for dev in ifs:
339         args = nicp.get(dev, {})
340         opts = nic_opts.get(dev, {}) if nic_opts else {}
341         old_if = old.get(dev, {})
342         disable = opts.get("disable", args.get("disable", False))
343         if disable:
344             continue
345         mac = opts.get(
346             "mac", opts.get("hwaddr", args.get("mac", args.get("hwaddr", "")))
347         )
348         type_ = opts.get("type", args.get("type", ""))
349         flags = opts.get("flags", args.get("flags", ""))
350         link = opts.get("link", args.get("link", ""))
351         ipv4 = opts.get("ipv4", args.get("ipv4", ""))
352         ipv6 = opts.get("ipv6", args.get("ipv6", ""))
353         infos = salt.utils.odict.OrderedDict(
354             [
355                 (
356                     "lxc.network.type",
357                     {
358                         "test": not type_,
359                         "value": type_,
360                         "old": old_if.get("lxc.network.type"),
361                         "default": "veth",
362                     },
363                 ),
364                 (
365                     "lxc.network.name",
366                     {"test": False, "value": dev, "old": dev, "default": dev},
367                 ),
368                 (
369                     "lxc.network.flags",
370                     {
371                         "test": not flags,
372                         "value": flags,
373                         "old": old_if.get("lxc.network.flags"),
374                         "default": "up",
375                     },
376                 ),
377                 (
378                     "lxc.network.link",
379                     {
380                         "test": not link,
381                         "value": link,
382                         "old": old_if.get("lxc.network.link"),
383                         "default": search_lxc_bridge(),
384                     },
385                 ),
386                 (
387                     "lxc.network.hwaddr",
388                     {
389                         "test": not mac,
390                         "value": mac,
391                         "old": old_if.get("lxc.network.hwaddr"),
392                         "default": salt.utils.network.gen_mac(),
393                     },
394                 ),
395                 (
396                     "lxc.network.ipv4",
397                     {
398                         "test": not ipv4,
399                         "value": ipv4,
400                         "old": old_if.get("lxc.network.ipv4", ""),
401                         "default": None,
402                     },
403                 ),
404                 (
405                     "lxc.network.ipv6",
406                     {
407                         "test": not ipv6,
408                         "value": ipv6,
409                         "old": old_if.get("lxc.network.ipv6", ""),
410                         "default": None,
411                     },
412                 ),
413             ]
414         )
415         for info in list(infos.keys()):
416             bundle = infos[info]
417             if bundle["test"]:
418                 if bundle["old"]:
419                     bundle["value"] = bundle["old"]
420                 elif bundle["default"]:
421                     bundle["value"] = bundle["default"]
422         for info, data in infos.items():
423             if data["value"]:
424                 ret.append({info: data["value"]})
425         for key, val in args.items():
426             if key == "link" and bridge:
427                 val = bridge
428             val = opts.get(key, val)
429             if key in [
430                 "type",
431                 "flags",
432                 "name",
433                 "gateway",
434                 "mac",
435                 "link",
436                 "ipv4",
437                 "ipv6",
438             ]:
439                 continue
440             ret.append({"lxc.network.{}".format(key): val})
441         if not gateway:
442             gateway = args.get("gateway", None)
443         if gateway is not None and not gateway_set:
444             ret.append({"lxc.network.ipv4.gateway": gateway})
445             gateway_set = True
446     if gateway is not None and not gateway_set:
447         ret.append({"lxc.network.ipv4.gateway": gateway})
448         gateway_set = True
449     new = _get_veths(ret)
450     for iface in [a for a in new]:
451         ndata = new[iface]
452         nmac = ndata.get("lxc.network.hwaddr", "")
453         ntype = ndata.get("lxc.network.type", "")
454         omac, otype = "", ""
455         if iface in old:
456             odata = old[iface]
457             omac = odata.get("lxc.network.hwaddr", "")
458             otype = odata.get("lxc.network.type", "")
459         if otype and not ntype:
460             ntype = otype
461         if not ntype:
462             ntype = "veth"
463         new[iface]["lxc.network.type"] = ntype
464         if omac and not nmac:
465             new[iface]["lxc.network.hwaddr"] = omac
466     ret = []
467     for val in new.values():
468         for row in val:
469             ret.append(salt.utils.odict.OrderedDict([(row, val[row])]))
470     if (
471         _LooseVersion(version()) &lt;= _LooseVersion("1.0.7")
472         and True not in ["lxc.network.ipv4.gateway" in a for a in ret]
473         and True in ["lxc.network.ipv4" in a for a in ret]
474     ):
475         ret.append({"lxc.network.ipv4.gateway": "auto"})
476     return ret
477 def _get_lxc_default_data(**kwargs):
478     kwargs = copy.deepcopy(kwargs)
479     ret = {}
480     for k in ["utsname", "rootfs"]:
481         val = kwargs.get(k, None)
482         if val is not None:
483             ret["lxc.{}".format(k)] = val
484     autostart = kwargs.get("autostart")
485     if autostart is None:
486         autostart = True
487     if autostart != "keep":
488         if autostart:
489             ret["lxc.start.auto"] = "1"
490         else:
491             ret["lxc.start.auto"] = "0"
492     memory = kwargs.get("memory")
493     if memory is not None:
494         ret["lxc.cgroup.memory.limit_in_bytes"] = memory * 1024 * 1024
495     cpuset = kwargs.get("cpuset")
496     if cpuset:
497         ret["lxc.cgroup.cpuset.cpus"] = cpuset
498     cpushare = kwargs.get("cpushare")
499     cpu = kwargs.get("cpu")
500     if cpushare:
501         ret["lxc.cgroup.cpu.shares"] = cpushare
502     if cpu and not cpuset:
503         ret["lxc.cgroup.cpuset.cpus"] = _rand_cpu_str(cpu)
504     return ret
505 def _config_list(conf_tuples=None, only_net=False, **kwargs):
506     only_net = bool(only_net)
507     if not conf_tuples:
508         conf_tuples = []
509     kwargs = copy.deepcopy(kwargs)
510     ret = []
511     if not only_net:
512         default_data = _get_lxc_default_data(**kwargs)
513         for k, val in default_data.items():
514             ret.append({k: val})
515     net_datas = _network_conf(conf_tuples=conf_tuples, **kwargs)
516     ret.extend(net_datas)
517     return ret
518 def _get_veths(net_data):
519     if isinstance(net_data, dict):
520         net_data = list(net_data.items())
521     nics = salt.utils.odict.OrderedDict()
522     current_nic = salt.utils.odict.OrderedDict()
523     no_names = True
524     for item in net_data:
525         if item and isinstance(item, dict):
526             item = list(item.items())[0]
527         elif isinstance(item, str):
528             sitem = item.strip()
529             if sitem.startswith("#") or not sitem:
530                 continue
531             elif "=" in item:
532                 item = tuple(a.strip() for a in item.split("=", 1))
533         if item[0] == "lxc.network.type":
534             current_nic = salt.utils.odict.OrderedDict()
535         if item[0] == "lxc.network.name":
536             no_names = False
537             nics[item[1].strip()] = current_nic
538         current_nic[item[0].strip()] = item[1].strip()
539     if no_names and current_nic:
540         nics[DEFAULT_NIC] = current_nic
541     return nics
542 class _LXCConfig:
543     pattern = re.compile(r"^(\S+)(\s*)(=)(\s*)(.*)")
544     non_interpretable_pattern = re.compile(r"^((#.*)|(\s*))$")
545     def __init__(self, **kwargs):
546         kwargs = copy.deepcopy(kwargs)
547         self.name = kwargs.pop("name", None)
548         path = get_root_path(kwargs.get("path", None))
549         self.data = []
550         if self.name:
551             self.path = os.path.join(path, self.name, "config")
552             if os.path.isfile(self.path):
553                 with salt.utils.files.fopen(self.path) as fhr:
554                     for line in salt.utils.data.decode(fhr.readlines()):
555                         match = self.pattern.findall(line.strip())
556                         if match:
557                             self.data.append((match[0][0], match[0][-1]))
558                         match = self.non_interpretable_pattern.findall(line.strip())
559                         if match:
560                             self.data.append(("", match[0][0]))
561         else:
562             self.path = None
563         def _replace(key, val):
564             if val:
565                 self._filter_data(key)
566                 self.data.append((key, val))
567         default_data = _get_lxc_default_data(**kwargs)
568         for key, val in default_data.items():
569             _replace(key, val)
570         old_net = self._filter_data("lxc.network")
571         net_datas = _network_conf(conf_tuples=old_net, **kwargs)
572         if net_datas:
573             for row in net_datas:
574                 self.data.extend(list(row.items()))
575         for idx in ["lxc.cgroup.memory.limit_in_bytes"]:
576             if not default_data.get(idx):
577                 self._filter_data(idx)
578     def as_string(self):
579         chunks = (
580             "{0[0]}{1}{0[1]}".format(item, (" = " if item[0] else ""))
581             for item in self.data
582         )
583         return "\n".join(chunks) + "\n"
584     def write(self):
585         if self.path:
586 <a name="3"></a>            content = self.as_string()
587             with salt<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(self.path, "w") as fic:
588                 fic.write(salt.utils.stringutils.to_str(content))
589                 fic.</b></font>flush()
590     def tempfile(self):
591         ntf = tempfile.NamedTemporaryFile()
592         ntf.write(self.as_string())
593         ntf.flush()
594         return ntf
595     def _filter_data(self, pattern):
596         removed = []
597         filtered = []
598         for param in self.data:
599             if not param[0].startswith(pattern):
600                 filtered.append(param)
601             else:
602                 removed.append(param)
603         self.data = filtered
604         return removed
605 def _get_base(**kwargs):
606     profile = get_container_profile(copy.deepcopy(kwargs.get("profile")))
607     kw_overrides = copy.deepcopy(kwargs)
608     def select(key, default=None):
609         kw_overrides_match = kw_overrides.pop(key, _marker)
610         profile_match = profile.pop(key, default)
611         if kw_overrides_match is _marker:
612             return profile_match
613         return kw_overrides_match
614     template = select("template")
615     image = select("image")
616     vgname = select("vgname")
617     path = kwargs.get("path", None)
618     for param in ("path", "image", "vgname", "template"):
619         kwargs.pop(param, None)
620     if image:
621         proto = urllib.parse.urlparse(image).scheme
622         img_tar = __salt__["cp.cache_file"](image)
623         img_name = os.path.basename(img_tar)
624         hash_ = salt.utils.hashutils.get_hash(
625             img_tar, __salt__["config.get"]("hash_type")
626         )
627         name = "__base_{}_{}_{}".format(proto, img_name, hash_)
628         if not exists(name, path=path):
629             create(
630                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
631             )
632             if vgname:
633                 rootfs = os.path.join("/dev", vgname, name)
634                 edit_conf(
635                     info(name, path=path)["config"],
636                     out_format="commented",
637                     **{"lxc.rootfs": rootfs}
638                 )
639         return name
640     elif template:
641         name = "__base_{}".format(template)
642         if not exists(name, path=path):
643             create(
644                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
645             )
646             if vgname:
647                 rootfs = os.path.join("/dev", vgname, name)
648                 edit_conf(
649                     info(name, path=path)["config"],
650                     out_format="commented",
651                     **{"lxc.rootfs": rootfs}
652                 )
653         return name
654     return ""
655 def init(
656     name,
657     config=None,
658     cpuset=None,
659     cpushare=None,
660     memory=None,
661     profile=None,
662     network_profile=None,
663     nic_opts=None,
664     cpu=None,
665     autostart=True,
666     password=None,
667     password_encrypted=None,
668     users=None,
669     dnsservers=None,
670     searchdomains=None,
671     bridge=None,
672     gateway=None,
673     pub_key=None,
674     priv_key=None,
675     force_install=False,
676     unconditional_install=False,
677     bootstrap_delay=None,
678     bootstrap_args=None,
679     bootstrap_shell=None,
680     bootstrap_url=None,
681     **kwargs
682 ):
683     ret = {"name": name, "changes": {}}
684     profile = get_container_profile(copy.deepcopy(profile))
685     if not network_profile:
686         network_profile = profile.get("network_profile")
687     if not network_profile:
688         network_profile = DEFAULT_NIC
689     changes_dict = {"init": []}
690     changes = changes_dict.get("init")
691     if users is None:
692         users = []
693     dusers = ["root"]
694     for user in dusers:
695         if user not in users:
696             users.append(user)
697     kw_overrides = copy.deepcopy(kwargs)
698     def select(key, default=None):
699         kw_overrides_match = kw_overrides.pop(key, _marker)
700         profile_match = profile.pop(key, default)
701         if kw_overrides_match is _marker:
702             return profile_match
703         return kw_overrides_match
704     path = select("path")
705     bpath = get_root_path(path)
706     state_pre = state(name, path=path)
707     tvg = select("vgname")
708     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
709     start_ = select("start", True)
710     autostart = select("autostart", autostart)
711     seed = select("seed", True)
712     install = select("install", True)
713     seed_cmd = select("seed_cmd")
714     salt_config = _get_salt_config(config, **kwargs)
715     approve_key = select("approve_key", True)
716     clone_from = select("clone_from")
717     if vgname and not clone_from:
718         try:
719             kwargs["vgname"] = vgname
720             clone_from = _get_base(profile=profile, **kwargs)
721         except (SaltInvocationError, CommandExecutionError) as exc:
722             ret["comment"] = exc.strerror
723             if changes:
724                 ret["changes"] = changes_dict
725             return ret
726         if not kwargs.get("snapshot") is False:
727             kwargs["snapshot"] = True
728     does_exist = exists(name, path=path)
729     to_reboot = False
730     remove_seed_marker = False
731     if does_exist:
732         pass
733     elif clone_from:
734         remove_seed_marker = True
735         try:
736             clone(name, clone_from, profile=profile, **kwargs)
737             changes.append({"create": "Container cloned"})
738         except (SaltInvocationError, CommandExecutionError) as exc:
739             if "already exists" in exc.strerror:
740                 changes.append({"create": "Container already exists"})
741             else:
742                 ret["result"] = False
743                 ret["comment"] = exc.strerror
744                 if changes:
745                     ret["changes"] = changes_dict
746                 return ret
747         cfg = _LXCConfig(
748             name=name,
749             network_profile=network_profile,
750             nic_opts=nic_opts,
751             bridge=bridge,
752             path=path,
753             gateway=gateway,
754             autostart=autostart,
755             cpuset=cpuset,
756             cpushare=cpushare,
757             memory=memory,
758         )
759         old_chunks = read_conf(cfg.path, out_format="commented")
760         cfg.write()
761         chunks = read_conf(cfg.path, out_format="commented")
762         if old_chunks != chunks:
763             to_reboot = True
764     else:
765         remove_seed_marker = True
766         cfg = _LXCConfig(
767             network_profile=network_profile,
768             nic_opts=nic_opts,
769             cpuset=cpuset,
770             path=path,
771             bridge=bridge,
772             gateway=gateway,
773             autostart=autostart,
774             cpushare=cpushare,
775             memory=memory,
776         )
777         with cfg.tempfile() as cfile:
778             try:
779                 create(name, config=cfile.name, profile=profile, **kwargs)
780                 changes.append({"create": "Container created"})
781             except (SaltInvocationError, CommandExecutionError) as exc:
782                 if "already exists" in exc.strerror:
783                     changes.append({"create": "Container already exists"})
784                 else:
785                     ret["comment"] = exc.strerror
786                     if changes:
787                         ret["changes"] = changes_dict
788                     return ret
789         cpath = os.path.join(bpath, name, "config")
790         old_chunks = []
791         if os.path.exists(cpath):
792             old_chunks = read_conf(cpath, out_format="commented")
793         new_cfg = _config_list(
794             conf_tuples=old_chunks,
795             cpu=cpu,
796             network_profile=network_profile,
797             nic_opts=nic_opts,
798             bridge=bridge,
799             cpuset=cpuset,
800             cpushare=cpushare,
801             memory=memory,
802         )
803         if new_cfg:
804             edit_conf(cpath, out_format="commented", lxc_config=new_cfg)
805         chunks = read_conf(cpath, out_format="commented")
806         if old_chunks != chunks:
807             to_reboot = True
808     cfg = _LXCConfig(
809         name=name,
810         network_profile=network_profile,
811         nic_opts=nic_opts,
812         bridge=bridge,
813         path=path,
814         gateway=gateway,
815         autostart=autostart,
816         cpuset=cpuset,
817         cpushare=cpushare,
818         memory=memory,
819     )
820     old_chunks = []
821     if os.path.exists(cfg.path):
822         old_chunks = read_conf(cfg.path, out_format="commented")
823     cfg.write()
824     chunks = read_conf(cfg.path, out_format="commented")
825     if old_chunks != chunks:
826         changes.append({"config": "Container configuration updated"})
827         to_reboot = True
828     if to_reboot:
829         try:
830             stop(name, path=path)
831         except (SaltInvocationError, CommandExecutionError) as exc:
832             ret["comment"] = "Unable to stop container: {}".format(exc)
833             if changes:
834                 ret["changes"] = changes_dict
835             return ret
836     if not does_exist or (does_exist and state(name, path=path) != "running"):
837         try:
838             start(name, path=path)
839         except (SaltInvocationError, CommandExecutionError) as exc:
840             ret["comment"] = "Unable to stop container: {}".format(exc)
841             if changes:
842                 ret["changes"] = changes_dict
843             return ret
844     if remove_seed_marker:
845         run(
846             name,
847             "rm -f '{}'".format(SEED_MARKER),
848             path=path,
849             chroot_fallback=False,
850             python_shell=False,
851         )
852     if ret.get("result", True) and password:
853         gid = "/.lxc.initial_pass"
854         gids = [gid, "/lxc.initial_pass", "/.lxc.{}.initial_pass".format(name)]
855         if not any(
856             retcode(
857                 name,
858                 'test -e "{}"'.format(x),
859                 chroot_fallback=True,
860                 path=path,
861                 ignore_retcode=True,
862             )
863             == 0
864             for x in gids
865         ):
866             for default_user in ["ubuntu"]:
867                 if (
868                     default_user not in users
869                     and retcode(
870                         name,
871                         "id {}".format(default_user),
872                         python_shell=False,
873                         path=path,
874                         chroot_fallback=True,
875                         ignore_retcode=True,
876                     )
877                     == 0
878                 ):
879                     users.append(default_user)
880             for user in users:
881                 try:
882                     cret = set_password(
883                         name,
884                         users=[user],
885                         path=path,
886                         password=password,
887                         encrypted=password_encrypted,
888                     )
889                 except (SaltInvocationError, CommandExecutionError) as exc:
890                     msg = "{}: Failed to set password".format(user) + exc.strerror
891                     if user == "root":
892                         ret["comment"] = msg
893                         ret["result"] = False
894                     else:
895                         log.debug(msg)
896             if ret.get("result", True):
897                 changes.append({"password": "Password(s) updated"})
898                 if (
899                     retcode(
900                         name,
901                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
902                         path=path,
903                         chroot_fallback=True,
904                         ignore_retcode=True,
905                     )
906                     != 0
907                 ):
908                     ret["comment"] = "Failed to set password marker"
909                     changes[-1]["password"] += ". " + ret["comment"] + "."
910                     ret["result"] = False
911     if ret.get("result", True) and dnsservers:
912         gid = "/.lxc.initial_dns"
913         gids = [gid, "/lxc.initial_dns", "/lxc.{}.initial_dns".format(name)]
914         if not any(
915             retcode(
916                 name,
917                 'test -e "{}"'.format(x),
918                 chroot_fallback=True,
919                 path=path,
920                 ignore_retcode=True,
921             )
922             == 0
923             for x in gids
924         ):
925             try:
926                 set_dns(
927                     name, path=path, dnsservers=dnsservers, searchdomains=searchdomains
928                 )
929             except (SaltInvocationError, CommandExecutionError) as exc:
930                 ret["comment"] = "Failed to set DNS: " + exc.strerror
931                 ret["result"] = False
932             else:
933                 changes.append({"dns": "DNS updated"})
934                 if (
935                     retcode(
936                         name,
937                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
938                         chroot_fallback=True,
939                         path=path,
940                         ignore_retcode=True,
941                     )
942                     != 0
943                 ):
944                     ret["comment"] = "Failed to set DNS marker"
945                     changes[-1]["dns"] += ". " + ret["comment"] + "."
946                     ret["result"] = False
947     if remove_seed_marker:
948         run(name, "rm -f '{}'".format(SEED_MARKER), path=path, python_shell=False)
949     gid = "/.lxc.initial_seed"
950     gids = [gid, "/lxc.initial_seed"]
951     if (
952         any(
953             retcode(
954                 name,
955                 "test -e {}".format(x),
956                 path=path,
957                 chroot_fallback=True,
958                 ignore_retcode=True,
959             )
960             == 0
961             for x in gids
962         )
963         or not ret.get("result", True)
964     ):
965         pass
966     elif seed or seed_cmd:
967         if seed:
968             try:
969                 result = bootstrap(
970                     name,
971                     config=salt_config,
972                     path=path,
973                     approve_key=approve_key,
974                     pub_key=pub_key,
975                     priv_key=priv_key,
976                     install=install,
977                     force_install=force_install,
978                     unconditional_install=unconditional_install,
979                     bootstrap_delay=bootstrap_delay,
980                     bootstrap_url=bootstrap_url,
981                     bootstrap_shell=bootstrap_shell,
982                     bootstrap_args=bootstrap_args,
983                 )
984             except (SaltInvocationError, CommandExecutionError) as exc:
985                 ret["comment"] = "Bootstrap failed: " + exc.strerror
986                 ret["result"] = False
987             else:
988                 if not result:
989                     ret[
990                         "comment"
991                     ] = "Bootstrap failed, see minion log for more information"
992                     ret["result"] = False
993                 else:
994                     changes.append({"bootstrap": "Container successfully bootstrapped"})
995         elif seed_cmd:
996             try:
997                 result = __salt__[seed_cmd](
998                     info(name, path=path)["rootfs"], name, salt_config
999                 )
1000             except (SaltInvocationError, CommandExecutionError) as exc:
1001                 ret["comment"] = "Bootstrap via seed_cmd '{}' failed: {}".format(
1002                     seed_cmd, exc.strerror
1003                 )
1004                 ret["result"] = False
1005             else:
1006                 if not result:
1007                     ret["comment"] = (
1008                         "Bootstrap via seed_cmd '{}' failed, "
1009                         "see minion log for more information ".format(seed_cmd)
1010                     )
1011                     ret["result"] = False
1012                 else:
1013                     changes.append(
1014                         {
1015                             "bootstrap": (
1016                                 "Container successfully bootstrapped "
1017                                 "using seed_cmd '{}'".format(seed_cmd)
1018                             )
1019                         }
1020                     )
1021     if ret.get("result", True) and not start_:
1022         try:
1023             stop(name, path=path)
1024         except (SaltInvocationError, CommandExecutionError) as exc:
1025             ret["comment"] = "Unable to stop container: {}".format(exc)
1026             ret["result"] = False
1027     state_post = state(name, path=path)
1028     if state_pre != state_post:
1029         changes.append({"state": {"old": state_pre, "new": state_post}})
1030     if ret.get("result", True):
1031         ret["comment"] = "Container '{}' successfully initialized".format(name)
1032         ret["result"] = True
1033     if changes:
1034         ret["changes"] = changes_dict
1035     return ret
1036 def cloud_init(name, vm_=None, **kwargs):
1037     init_interface = cloud_init_interface(name, vm_, **kwargs)
1038     name = init_interface.pop("name", name)
1039     return init(name, **init_interface)
1040 def images(dist=None):
1041     out = __salt__["cmd.run_stdout"](
1042         "lxc-create -n __imgcheck -t download -- --list", ignore_retcode=True
1043     )
1044     if "DIST" not in out:
1045         raise CommandExecutionError(
1046             "Unable to run the 'download' template script. Is it installed?"
1047         )
1048     ret = {}
1049     passed_header = False
1050     for line in out.splitlines():
1051         try:
1052             distro, release, arch, variant, build_time = line.split()
1053         except ValueError:
1054             continue
1055         if not passed_header:
1056             if distro == "DIST":
1057                 passed_header = True
1058             continue
1059         dist_list = ret.setdefault(distro, [])
1060         dist_list.append(
1061             {
1062                 "release": release,
1063                 "arch": arch,
1064                 "variant": variant,
1065                 "build_time": build_time,
1066             }
1067         )
1068     if dist is not None:
1069         return dict([(dist, ret.get(dist, []))])
1070     return ret
1071 def templates():
1072     try:
1073         template_scripts = os.listdir("/usr/share/lxc/templates")
1074     except OSError:
1075         return []
1076     else:
1077         return [x[4:] for x in template_scripts if x.startswith("lxc-")]
1078 def _after_ignition_network_profile(cmd, ret, name, network_profile, path, nic_opts):
1079     _clear_context()
1080     if ret["retcode"] == 0 and exists(name, path=path):
1081         if network_profile:
1082             network_changes = apply_network_profile(
1083                 name, network_profile, path=path, nic_opts=nic_opts
1084             )
1085             if network_changes:
1086                 log.info(
1087                     "Network changes from applying network profile '%s' "
1088                     "to newly-created container '%s':\n%s",
1089                     network_profile,
1090                     name,
1091                     network_changes,
1092                 )
1093         c_state = state(name, path=path)
1094         return {"result": True, "state": {"old": None, "new": c_state}}
1095     else:
1096         if exists(name, path=path):
1097             cmd = "lxc-destroy"
1098             if path:
1099                 cmd += " -P {}".format(pipes.quote(path))
1100             cmd += " -n {}".format(name)
1101             __salt__["cmd.retcode"](cmd, python_shell=False)
1102         raise CommandExecutionError(
1103             "Container could not be created with cmd '{}': {}".format(
1104                 cmd, ret["stderr"]
1105             )
1106         )
1107 def create(
1108     name, config=None, profile=None, network_profile=None, nic_opts=None, **kwargs
1109 ):
1110     download_template_deps = ("dist", "release", "arch")
1111     cmd = "lxc-create -n {}".format(name)
1112     profile = get_container_profile(copy.deepcopy(profile))
1113     kw_overrides = copy.deepcopy(kwargs)
1114     def select(key, default=None):
1115         kw_overrides_match = kw_overrides.pop(key, None)
1116         profile_match = profile.pop(key, default)
1117         if kw_overrides_match is None:
1118             return profile_match
1119         return kw_overrides_match
1120     path = select("path")
1121     if exists(name, path=path):
1122         raise CommandExecutionError("Container '{}' already exists".format(name))
1123     tvg = select("vgname")
1124     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
1125     template = select("template")
1126     image = select("image")
1127     if template and image:
1128         raise SaltInvocationError("Only one of 'template' and 'image' is permitted")
1129     elif not any((template, image, profile)):
1130         raise SaltInvocationError(
1131             "At least one of 'template', 'image', and 'profile' is required"
1132         )
1133     options = select("options") or {}
1134     backing = select("backing")
1135     if vgname and not backing:
1136         backing = "lvm"
1137     lvname = select("lvname")
1138     thinpool = select("thinpool")
1139     fstype = select("fstype")
1140     size = select("size", "1G")
1141     zfsroot = select("zfsroot")
1142     if backing in ("dir", "overlayfs", "btrfs", "zfs"):
1143         fstype = None
1144         size = None
1145     if backing in ("aufs", "dir", "overlayfs", "btrfs"):
1146         lvname = vgname = thinpool = None
1147     if image:
1148         img_tar = __salt__["cp.cache_file"](image)
1149         template = os.path.join(
1150             os.path.dirname(salt.__file__), "templates", "lxc", "salt_tarball"
1151         )
1152         options["imgtar"] = img_tar
1153     if path:
1154         cmd += " -P {}".format(pipes.quote(path))
1155         if not os.path.exists(path):
1156             os.makedirs(path)
1157     if config:
1158         cmd += " -f {}".format(config)
1159     if template:
1160         cmd += " -t {}".format(template)
1161     if backing:
1162         backing = backing.lower()
1163         cmd += " -B {}".format(backing)
1164         if backing in ("zfs",):
1165             if zfsroot:
1166                 cmd += " --zfsroot {}".format(zfsroot)
1167         if backing in ("lvm",):
1168             if lvname:
1169                 cmd += " --lvname {}".format(lvname)
1170             if vgname:
1171                 cmd += " --vgname {}".format(vgname)
1172             if thinpool:
1173                 cmd += " --thinpool {}".format(thinpool)
1174         if backing not in ("dir", "overlayfs"):
1175             if fstype:
1176                 cmd += " --fstype {}".format(fstype)
1177             if size:
1178                 cmd += " --fssize {}".format(size)
1179     if options:
1180         if template == "download":
1181             missing_deps = [x for x in download_template_deps if x not in options]
1182             if missing_deps:
1183                 raise SaltInvocationError(
1184                     "Missing params in 'options' dict: {}".format(
1185                         ", ".join(missing_deps)
1186                     )
1187                 )
1188         cmd += " --"
1189         for key, val in options.items():
1190             cmd += " --{} {}".format(key, val)
1191     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1192     return _after_ignition_network_profile(
1193         cmd, ret, name, network_profile, path, nic_opts
1194     )
1195 def clone(name, orig, profile=None, network_profile=None, nic_opts=None, **kwargs):
1196     profile = get_container_profile(copy.deepcopy(profile))
1197     kw_overrides = copy.deepcopy(kwargs)
1198     def select(key, default=None):
1199         kw_overrides_match = kw_overrides.pop(key, None)
1200         profile_match = profile.pop(key, default)
1201         if kw_overrides_match is None:
1202             return profile_match
1203         return kw_overrides_match
1204     path = select("path")
1205     if exists(name, path=path):
1206         raise CommandExecutionError("Container '{}' already exists".format(name))
1207     _ensure_exists(orig, path=path)
1208     if state(orig, path=path) != "stopped":
1209         raise CommandExecutionError(
1210             "Container '{}' must be stopped to be cloned".format(orig)
1211         )
1212     backing = select("backing")
1213     snapshot = select("snapshot")
1214     if backing in ("dir",):
1215         snapshot = False
1216     if not snapshot:
1217         snapshot = ""
1218     else:
1219         snapshot = "-s"
1220     size = select("size", "1G")
1221     if backing in ("dir", "overlayfs", "btrfs"):
1222         size = None
1223     if _LooseVersion(version()) &gt;= _LooseVersion("2.0"):
1224         cmd = "lxc-copy"
1225         cmd += " {} -n {} -N {}".format(snapshot, orig, name)
1226     else:
1227         cmd = "lxc-clone"
1228         cmd += " {} -o {} -n {}".format(snapshot, orig, name)
1229     if path:
1230         cmd += " -P {}".format(pipes.quote(path))
1231         if not os.path.exists(path):
1232             os.makedirs(path)
1233     if backing:
1234         backing = backing.lower()
1235         cmd += " -B {}".format(backing)
1236         if backing not in ("dir", "overlayfs"):
1237             if size:
1238                 cmd += " -L {}".format(size)
1239     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1240     return _after_ignition_network_profile(
1241         cmd, ret, name, network_profile, path, nic_opts
1242     )
1243 def ls_(active=None, cache=True, path=None):
1244     contextvar = "lxc.ls{}".format(path)
1245     if active:
1246         contextvar += ".active"
1247     if cache and (contextvar in __context__):
1248         return __context__[contextvar]
1249     else:
1250         ret = []
1251         cmd = "lxc-ls"
1252         if path:
1253             cmd += " -P {}".format(pipes.quote(path))
1254         if active:
1255             cmd += " --active"
1256         output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
1257         for line in output.splitlines():
1258             ret.extend(line.split())
1259         __context__[contextvar] = ret
1260         return ret
1261 def list_(extra=False, limit=None, path=None):
1262     ctnrs = ls_(path=path)
1263     if extra:
1264         stopped = {}
1265         frozen = {}
1266         running = {}
1267     else:
1268         stopped = []
1269         frozen = []
1270         running = []
1271     ret = {"running": running, "stopped": stopped, "frozen": frozen}
1272     for container in ctnrs:
1273         cmd = "lxc-info"
1274         if path:
1275             cmd += " -P {}".format(pipes.quote(path))
1276         cmd += " -n {}".format(container)
1277         c_info = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="debug")
1278         c_state = None
1279         for line in c_info.splitlines():
1280             stat = line.split(":")
1281             if stat[0] in ("State", "state"):
1282                 c_state = stat[1].strip()
1283                 break
1284         if not c_state or (limit is not None and c_state.lower() != limit):
1285             continue
1286         if extra:
1287             infos = info(container, path=path)
1288             method = "update"
1289             value = {container: infos}
1290         else:
1291             method = "append"
1292             value = container
1293         if c_state == "STOPPED":
1294             getattr(stopped, method)(value)
1295             continue
1296         if c_state == "FROZEN":
1297             getattr(frozen, method)(value)
1298             continue
1299         if c_state == "RUNNING":
1300             getattr(running, method)(value)
1301             continue
1302     if limit is not None:
1303         return ret.get(limit, {} if extra else [])
1304     return ret
1305 def _change_state(
1306     cmd,
1307     name,
1308     expected,
1309     stdin=_marker,
1310     stdout=_marker,
1311     stderr=_marker,
1312     with_communicate=_marker,
1313     use_vt=_marker,
1314     path=None,
1315 ):
1316     pre = state(name, path=path)
1317     if pre == expected:
1318         return {
1319             "result": True,
1320             "state": {"old": expected, "new": expected},
1321             "comment": "Container '{}' already {}".format(name, expected),
1322         }
1323     if cmd == "lxc-destroy":
1324         scmd = "lxc-stop"
1325         if path:
1326             scmd += " -P {}".format(pipes.quote(path))
1327         scmd += " -k -n {}".format(name)
1328         __salt__["cmd.run"](scmd, python_shell=False)
1329     if path and " -P " not in cmd:
1330         cmd += " -P {}".format(pipes.quote(path))
1331     cmd += " -n {}".format(name)
1332     pkwargs = {
1333         "python_shell": False,
1334         "redirect_stderr": True,
1335         "with_communicate": with_communicate,
1336         "use_vt": use_vt,
1337         "stdin": stdin,
1338         "stdout": stdout,
1339     }
1340     for i in [a for a in pkwargs]:
1341         val = pkwargs[i]
1342         if val is _marker:
1343             pkwargs.pop(i, None)
1344     _cmdout = __salt__["cmd.run_all"](cmd, **pkwargs)
1345     if _cmdout["retcode"] != 0:
1346         raise CommandExecutionError(
1347             "Error changing state for container '{}' using command '{}': {}".format(
1348                 name, cmd, _cmdout["stdout"]
1349             )
1350         )
1351     if expected is not None:
1352         rcmd = "lxc-wait"
1353         if path:
1354             rcmd += " -P {}".format(pipes.quote(path))
1355         rcmd += " -n {} -s {}".format(name, expected.upper())
1356         __salt__["cmd.run"](rcmd, python_shell=False, timeout=30)
1357     _clear_context()
1358     post = state(name, path=path)
1359     ret = {"result": post == expected, "state": {"old": pre, "new": post}}
1360     return ret
1361 def _ensure_exists(name, path=None):
1362     if not exists(name, path=path):
1363         raise CommandExecutionError("Container '{}' does not exist".format(name))
1364 def _ensure_running(name, no_start=False, path=None):
1365     _ensure_exists(name, path=path)
1366     pre = state(name, path=path)
1367     if pre == "running":
1368         return start(name, path=path)
1369     elif pre == "stopped":
1370         if no_start:
1371             raise CommandExecutionError("Container '{}' is not running".format(name))
1372         return start(name, path=path)
1373     elif pre == "frozen":
1374         if no_start:
1375             raise CommandExecutionError("Container '{}' is not running".format(name))
1376         return unfreeze(name, path=path)
1377 def restart(name, path=None, lxc_config=None, force=False):
1378     _ensure_exists(name, path=path)
1379     orig_state = state(name, path=path)
1380     if orig_state != "stopped":
1381         stop(name, kill=force, path=path)
1382     ret = start(name, path=path, lxc_config=lxc_config)
1383     ret["state"]["old"] = orig_state
1384     if orig_state != "stopped":
1385         ret["restarted"] = True
1386     return ret
1387 def start(name, **kwargs):
1388     path = kwargs.get("path", None)
1389     cpath = get_root_path(path)
1390     lxc_config = kwargs.get("lxc_config", None)
1391     cmd = "lxc-start"
1392     if not lxc_config:
1393         lxc_config = os.path.join(cpath, name, "config")
1394     if os.path.exists(lxc_config):
1395         cmd += " -f {}".format(pipes.quote(lxc_config))
1396     cmd += " -d"
1397     _ensure_exists(name, path=path)
1398     if state(name, path=path) == "frozen":
1399         raise CommandExecutionError(
1400             "Container '{}' is frozen, use lxc.unfreeze".format(name)
1401         )
1402     use_vt = kwargs.get("use_vt", None)
1403     with_communicate = kwargs.get("with_communicate", False)
1404     return _change_state(
1405         cmd,
1406         name,
1407         "running",
1408         stdout=None,
1409         stderr=None,
1410         stdin=None,
1411         with_communicate=with_communicate,
1412         path=path,
1413         use_vt=use_vt,
1414     )
1415 def stop(name, kill=False, path=None, use_vt=None):
1416     _ensure_exists(name, path=path)
1417     orig_state = state(name, path=path)
1418     if orig_state == "frozen" and not kill:
1419         unfreeze(name, path=path)
1420     cmd = "lxc-stop"
1421     if kill:
1422         cmd += " -k"
1423     ret = _change_state(cmd, name, "stopped", use_vt=use_vt, path=path)
1424     ret["state"]["old"] = orig_state
1425     return ret
1426 def freeze(name, **kwargs):
1427     use_vt = kwargs.get("use_vt", None)
1428     path = kwargs.get("path", None)
1429     _ensure_exists(name, path=path)
1430     orig_state = state(name, path=path)
1431     start_ = kwargs.get("start", False)
1432     if orig_state == "stopped":
1433         if not start_:
1434             raise CommandExecutionError("Container '{}' is stopped".format(name))
1435         start(name, path=path)
1436     cmd = "lxc-freeze"
1437     if path:
1438         cmd += " -P {}".format(pipes.quote(path))
1439     ret = _change_state(cmd, name, "frozen", use_vt=use_vt, path=path)
1440     if orig_state == "stopped" and start_:
1441         ret["state"]["old"] = orig_state
1442         ret["started"] = True
1443     ret["state"]["new"] = state(name, path=path)
1444     return ret
1445 def unfreeze(name, path=None, use_vt=None):
1446     _ensure_exists(name, path=path)
1447     if state(name, path=path) == "stopped":
1448         raise CommandExecutionError("Container '{}' is stopped".format(name))
1449     cmd = "lxc-unfreeze"
1450     if path:
1451         cmd += " -P {}".format(pipes.quote(path))
1452     return _change_state(cmd, name, "running", path=path, use_vt=use_vt)
1453 def destroy(name, stop=False, path=None):
1454     _ensure_exists(name, path=path)
1455     if not stop and state(name, path=path) != "stopped":
1456         raise CommandExecutionError("Container '{}' is not stopped".format(name))
1457     return _change_state("lxc-destroy", name, None, path=path)
1458 remove = salt.utils.functools.alias_function(destroy, "remove")
1459 def exists(name, path=None):
1460     _exists = name in ls_(path=path)
1461     if not _exists:
1462         _exists = name in ls_(cache=False, path=path)
1463     return _exists
1464 def state(name, path=None):
1465     cachekey = "lxc.state.{}{}".format(name, path)
1466     try:
1467         return __context__[cachekey]
1468     except KeyError:
1469         if not exists(name, path=path):
1470             __context__[cachekey] = None
1471         else:
1472             cmd = "lxc-info"
1473             if path:
1474                 cmd += " -P {}".format(pipes.quote(path))
1475             cmd += " -n {}".format(name)
1476             ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1477             if ret["retcode"] != 0:
1478                 _clear_context()
1479                 raise CommandExecutionError(
1480                     "Unable to get state of container '{}'".format(name)
1481                 )
1482             c_infos = ret["stdout"].splitlines()
1483             c_state = None
1484             for c_info in c_infos:
1485                 stat = c_info.split(":")
1486                 if stat[0].lower() == "state":
1487                     c_state = stat[1].strip().lower()
1488                     break
1489             __context__[cachekey] = c_state
1490     return __context__[cachekey]
1491 def get_parameter(name, parameter, path=None):
1492     _ensure_exists(name, path=path)
1493     cmd = "lxc-cgroup"
1494     if path:
1495         cmd += " -P {}".format(pipes.quote(path))
1496     cmd += " -n {} {}".format(name, parameter)
1497     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1498     if ret["retcode"] != 0:
1499         raise CommandExecutionError(
1500             "Unable to retrieve value for '{}'".format(parameter)
1501         )
1502     return ret["stdout"].strip()
1503 def set_parameter(name, parameter, value, path=None):
1504     if not exists(name, path=path):
1505         return None
1506     cmd = "lxc-cgroup"
1507     if path:
1508         cmd += " -P {}".format(pipes.quote(path))
1509     cmd += " -n {} {} {}".format(name, parameter, value)
1510     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1511     if ret["retcode"] != 0:
1512         return False
1513     else:
1514         return True
1515 def info(name, path=None):
1516     cachekey = "lxc.info.{}{}".format(name, path)
1517     try:
1518         return __context__[cachekey]
1519     except KeyError:
1520         _ensure_exists(name, path=path)
1521         cpath = get_root_path(path)
1522         try:
1523             conf_file = os.path.join(cpath, name, "config")
1524         except AttributeError:
1525             conf_file = os.path.join(cpath, str(name), "config")
1526         if not os.path.isfile(conf_file):
1527             raise CommandExecutionError(
1528                 "LXC config file {} does not exist".format(conf_file)
1529             )
1530         ret = {}
1531         config = []
1532         with salt.utils.files.fopen(conf_file) as fp_:
1533             for line in fp_:
1534                 line = salt.utils.stringutils.to_unicode(line)
1535                 comps = [x.strip() for x in line.split("#", 1)[0].strip().split("=", 1)]
1536                 if len(comps) == 2:
1537                     config.append(tuple(comps))
1538         ifaces = []
1539         current = {}
1540         for key, val in config:
1541             if key == "lxc.network.type":
1542                 current = {"type": val}
1543                 ifaces.append(current)
1544             elif not current:
1545                 continue
1546             elif key.startswith("lxc.network."):
1547                 current[key.replace("lxc.network.", "", 1)] = val
1548         if ifaces:
1549             ret["nics"] = ifaces
1550         ret["rootfs"] = next((x[1] for x in config if x[0] == "lxc.rootfs"), None)
1551         ret["state"] = state(name, path=path)
1552         ret["ips"] = []
1553         ret["public_ips"] = []
1554         ret["private_ips"] = []
1555         ret["public_ipv4_ips"] = []
1556         ret["public_ipv6_ips"] = []
1557         ret["private_ipv4_ips"] = []
1558         ret["private_ipv6_ips"] = []
1559         ret["ipv4_ips"] = []
1560         ret["ipv6_ips"] = []
1561         ret["size"] = None
1562         ret["config"] = conf_file
1563         if ret["state"] == "running":
1564             try:
1565                 limit = int(get_parameter(name, "memory.limit_in_bytes"))
1566             except (CommandExecutionError, TypeError, ValueError):
1567                 limit = 0
1568             try:
1569                 usage = int(get_parameter(name, "memory.usage_in_bytes"))
1570             except (CommandExecutionError, TypeError, ValueError):
1571                 usage = 0
1572             free = limit - usage
1573             ret["memory_limit"] = limit
1574             ret["memory_free"] = free
1575             size = run_stdout(name, "df /", path=path, python_shell=False)
1576             ret["size"] = size.splitlines()[-1].split()[1]
1577             ip_cmd = run_all(name, "ip link show", path=path, python_shell=False)
1578             if ip_cmd["retcode"] == 0:
1579                 ip_data = ip_cmd["stdout"]
1580                 ip_cmd = run_all(name, "ip addr show", path=path, python_shell=False)
1581                 ip_data += "\n" + ip_cmd["stdout"]
1582                 ip_data = salt.utils.network._interfaces_ip(ip_data)
1583             else:
1584                 ip_cmd = run_all(name, "ifconfig", path=path, python_shell=False)
1585                 if ip_cmd["retcode"] == 0:
1586                     ip_data = salt.utils.network._interfaces_ifconfig(ip_cmd["stdout"])
1587                 else:
1588                     log.warning("Unable to run ip or ifconfig in container '%s'", name)
1589                     ip_data = {}
1590             ret["ipv4_ips"] = salt.utils.network.ip_addrs(
1591                 include_loopback=True, interface_data=ip_data
1592             )
1593             ret["ipv6_ips"] = salt.utils.network.ip_addrs6(
1594                 include_loopback=True, interface_data=ip_data
1595             )
1596             ret["ips"] = ret["ipv4_ips"] + ret["ipv6_ips"]
1597             for address in ret["ipv4_ips"]:
1598                 if address == "127.0.0.1":
1599                     ret["private_ips"].append(address)
1600                     ret["private_ipv4_ips"].append(address)
1601                 elif salt.utils.cloud.is_public_ip(address):
1602                     ret["public_ips"].append(address)
1603                     ret["public_ipv4_ips"].append(address)
1604                 else:
1605                     ret["private_ips"].append(address)
1606                     ret["private_ipv4_ips"].append(address)
1607             for address in ret["ipv6_ips"]:
1608                 if address == "::1" or address.startswith("fe80"):
1609                     ret["private_ips"].append(address)
1610                     ret["private_ipv6_ips"].append(address)
1611                 else:
1612                     ret["public_ips"].append(address)
1613                     ret["public_ipv6_ips"].append(address)
1614         for key in [x for x in ret if x == "ips" or x.endswith("ips")]:
1615             ret[key].sort(key=_ip_sort)
1616         __context__[cachekey] = ret
1617     return __context__[cachekey]
1618 def set_password(name, users, password, encrypted=True, path=None):
1619     def _bad_user_input():
1620         raise SaltInvocationError("Invalid input for 'users' parameter")
1621     if not isinstance(users, list):
1622         try:
1623             users = users.split(",")
1624         except AttributeError:
1625             _bad_user_input()
1626     if not users:
1627         _bad_user_input()
1628     failed_users = []
1629     for user in users:
1630         result = retcode(
1631             name,
1632             "chpasswd{}".format(" -e" if encrypted else ""),
1633             stdin=":".join((user, password)),
1634             python_shell=False,
1635             path=path,
1636             chroot_fallback=True,
1637             output_loglevel="quiet",
1638         )
1639         if result != 0:
1640             failed_users.append(user)
1641     if failed_users:
1642         raise CommandExecutionError(
1643             "Password change failed for the following user(s): {}".format(
1644                 ", ".join(failed_users)
1645             )
1646         )
1647     return True
1648 set_pass = salt.utils.functools.alias_function(set_password, "set_pass")
1649 def update_lxc_conf(name, lxc_conf, lxc_conf_unset, path=None):
1650     _ensure_exists(name, path=path)
1651     cpath = get_root_path(path)
1652     lxc_conf_p = os.path.join(cpath, name, "config")
1653     if not os.path.exists(lxc_conf_p):
1654         raise SaltInvocationError(
1655             "Configuration file {} does not exist".format(lxc_conf_p)
1656         )
1657     changes = {"edited": [], "added": [], "removed": []}
1658     ret = {"changes": changes, "result": True, "comment": ""}
1659     with salt.utils.files.fopen(lxc_conf_p, "r") as fic:
1660         filtered_lxc_conf = []
1661         for row in lxc_conf:
1662             if not row:
1663                 continue
1664             for conf in row:
1665                 filtered_lxc_conf.append((conf.strip(), row[conf].strip()))
1666         ret["comment"] = "lxc.conf is up to date"
1667         lines = []
1668         orig_config = salt.utils.stringutils.to_unicode(fic.read())
1669         for line in orig_config.splitlines():
1670                 lines.append([line, ""])
1671             else:
1672                 line = line<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.split("=")
1673                 index = line.pop(0)
1674                 val = (index.strip(), "=".join(line).strip(</b></font>))
1675                 if val not in lines:
1676                     lines.append(val)
1677         for key, item in filtered_lxc_conf:
1678             matched = False
1679             for idx, line in enumerate(lines[:]):
1680                 if line[0] == key:
1681                     matched = True
1682                     lines[idx] = (key, item)
1683                     if "=".join(line[1:]).strip() != item.strip():
1684                         changes["edited"].append(({line[0]: line[1:]}, {key: item}))
1685                         break
1686             if not matched:
1687                 if (key, item) not in lines:
1688                     lines.append((key, item))
1689                 changes["added"].append({key: item})
1690         dest_lxc_conf = []
1691         if lxc_conf_unset:
1692             for line in lines:
1693                 for opt in lxc_conf_unset:
1694                     if not line[0].startswith(opt) and line not in dest_lxc_conf:
1695                         dest_lxc_conf.append(line)
1696                     else:
1697                         changes["removed"].append(opt)
1698         else:
1699             dest_lxc_conf = lines
1700         conf = ""
1701         for key, val in dest_lxc_conf:
1702             if not val:
1703                 conf += "{}\n".format(key)
1704             else:
1705                 conf += "{} = {}\n".format(key.strip(), val.strip())
1706         conf_changed = conf != orig_config
1707         chrono = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
1708         if conf_changed:
1709             with salt.utils.files.fopen(
1710                 "{}.{}".format(lxc_conf_p, chrono), "w"
1711             ) as wfic:
1712                 wfic.write(salt.utils.stringutils.to_str(conf))
1713             with salt.utils.files.fopen(lxc_conf_p, "w") as wfic:
1714                 wfic.write(salt.utils.stringutils.to_str(conf))
1715             ret["comment"] = "Updated"
1716             ret["result"] = True
1717     if not any(changes[x] for x in changes):
1718         ret["changes"] = {}
1719     return ret
1720 def set_dns(name, dnsservers=None, searchdomains=None, path=None):
1721     if dnsservers is None:
1722         dnsservers = ["8.8.8.8", "4.4.4.4"]
1723     elif not isinstance(dnsservers, list):
1724         try:
1725             dnsservers = dnsservers.split(",")
1726         except AttributeError:
1727             raise SaltInvocationError("Invalid input for 'dnsservers' parameter")
1728     if searchdomains is None:
1729         searchdomains = []
1730     elif not isinstance(searchdomains, list):
1731         try:
1732             searchdomains = searchdomains.split(",")
1733         except AttributeError:
1734             raise SaltInvocationError("Invalid input for 'searchdomains' parameter")
1735     dns = ["nameserver {}".format(x) for x in dnsservers]
1736     dns.extend(["search {}".format(x) for x in searchdomains])
1737     dns = "\n".join(dns) + "\n"
1738     rstr = __salt__["test.random_hash"]()
1739     script = "/sbin/{}_dns.sh".format(rstr)
1740     DNS_SCRIPT = "\n".join(
1741         [
1742             "#!/usr/bin/env bash",
1743             "if [ -h /etc/resolv.conf ];then",
1744             ' if [ "x$(readlink /etc/resolv.conf)"'
1745             ' = "x../run/resolvconf/resolv.conf" ];then',
1746             "  if [ ! -d /run/resolvconf/ ];then",
1747             "   mkdir -p /run/resolvconf",
1748             "  fi",
1749             "  cat &gt; /etc/resolvconf/resolv.conf.d/head &lt;&lt;EOF",
1750             dns,
1751             "EOF",
1752             "",
1753             " fi",
1754             "fi",
1755             "cat &gt; /etc/resolv.conf &lt;&lt;EOF",
1756             dns,
1757             "EOF",
1758             "",
1759         ]
1760     )
1761     result = run_all(
1762         name, "tee {}".format(script), path=path, stdin=DNS_SCRIPT, python_shell=True
1763     )
1764     if result["retcode"] == 0:
1765         result = run_all(
1766             name,
1767             'sh -c "chmod +x {0};{0}"'.format(script),
1768             path=path,
1769             python_shell=True,
1770         )
1771     run_all(
1772         name,
1773         'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1774         path=path,
1775         python_shell=True,
1776     )
1777     if result["retcode"] != 0:
1778         error = "Unable to write to /etc/resolv.conf in container '{}'".format(name)
1779         if result["stderr"]:
1780             error += ": {}".format(result["stderr"])
1781         raise CommandExecutionError(error)
1782     return True
1783 def running_systemd(name, cache=True, path=None):
1784     k = "lxc.systemd.test.{}{}".format(name, path)
1785     ret = __context__.get(k, None)
1786     if ret is None or not cache:
1787         rstr = __salt__["test.random_hash"]()
1788         script = "/sbin/{}_testsystemd.sh".format(rstr)
1789         _script = textwrap.dedent(
1790         )
1791         result = run_all(
1792             name, "tee {}".format(script), path=path, stdin=_script, python_shell=True
1793         )
1794         if result["retcode"] == 0:
1795             result = run_all(
1796                 name,
1797                 'sh -c "chmod +x {0};{0}"'.format(script),
1798                 path=path,
1799                 python_shell=True,
1800             )
1801         else:
1802             raise CommandExecutionError(
1803                 "lxc {} failed to copy initd tester".format(name)
1804             )
1805         run_all(
1806             name,
1807             'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1808             path=path,
1809             ignore_retcode=True,
1810             python_shell=True,
1811         )
1812         if result["retcode"] != 0:
1813             error = (
1814                 "Unable to determine if the container '{}'"
1815                 " was running systemd, assmuming it is not."
1816                 "".format(name)
1817             )
1818             if result["stderr"]:
1819                 error += ": {}".format(result["stderr"])
1820         if result["retcode"] in (0, 2):
1821             __context__[k] = ret = not result["retcode"]
1822     return ret
1823 def systemd_running_state(name, path=None):
1824     try:
1825         ret = run_all(
1826             name, "systemctl is-system-running", path=path, ignore_retcode=True
1827         )["stdout"]
1828     except CommandExecutionError:
1829         ret = ""
1830     return ret
1831 def test_sd_started_state(name, path=None):
1832     qstate = systemd_running_state(name, path=path)
1833     if qstate in ("initializing", "starting"):
1834         return False
1835     elif qstate == "":
1836         return None
1837     else:
1838         return True
1839 def test_bare_started_state(name, path=None):
1840     try:
1841         ret = run_all(name, "ls", path=path, ignore_retcode=True)["retcode"] == 0
1842     except (CommandExecutionError,):
1843         ret = None
1844     return ret
1845 def wait_started(name, path=None, timeout=300):
1846     if not exists(name, path=path):
1847         raise CommandExecutionError("Container {} does does exists".format(name))
1848     if not state(name, path=path) == "running":
1849         raise CommandExecutionError("Container {} is not running".format(name))
1850     ret = False
1851     if running_systemd(name, path=path):
1852         test_started = test_sd_started_state
1853         logger = log.error
1854     else:
1855         test_started = test_bare_started_state
1856         logger = log.debug
1857     now = time.time()
1858     expire = now + timeout
1859     now = time.time()
1860     started = test_started(name, path=path)
1861     while time.time() &lt; expire and not started:
1862         time.sleep(0.3)
1863         started = test_started(name, path=path)
1864     if started is None:
1865         logger(
1866             "Assuming %s is started, although we failed to detect that"
1867             " is fully started correctly",
1868             name,
1869         )
1870         ret = True
1871     else:
1872         ret = started
1873     return ret
1874 def _needs_install(name, path=None):
1875     ret = 0
1876     has_minion = retcode(name, "which salt-minion", path=path, ignore_retcode=True)
1877     if has_minion:
1878         processes = run_stdout(name, "ps aux", path=path)
1879         if "salt-minion" not in processes:
1880             ret = 1
1881         else:
1882             retcode(name, "salt-call --local service.stop salt-minion")
1883     else:
1884         ret = 1
1885     return ret
1886 def bootstrap(
1887     name,
1888     config=None,
1889     approve_key=True,
1890     install=True,
1891     pub_key=None,
1892     priv_key=None,
1893     bootstrap_url=None,
1894     force_install=False,
1895     unconditional_install=False,
1896     path=None,
1897     bootstrap_delay=None,
1898     bootstrap_args=None,
1899     bootstrap_shell=None,
1900 ):
1901     wait_started(name, path=path)
1902     if bootstrap_delay is not None:
1903         try:
1904             log.info("LXC %s: bootstrap_delay: %s", name, bootstrap_delay)
1905             time.sleep(bootstrap_delay)
1906         except TypeError:
1907             time.sleep(5)
1908     c_info = info(name, path=path)
1909     if not c_info:
1910         return None
1911     if bootstrap_args:
1912         if "{0}" not in bootstrap_args:
1913             bootstrap_args += " -c {0}"
1914     else:
1915         bootstrap_args = "-c {0}"
1916     if not bootstrap_shell:
1917         bootstrap_shell = "sh"
1918     orig_state = _ensure_running(name, path=path)
1919     if not orig_state:
1920         return orig_state
1921     if not force_install:
1922         needs_install = _needs_install(name, path=path)
1923     else:
1924         needs_install = True
1925     seeded = (
1926         retcode(
1927             name,
1928             "test -e '{}'".format(SEED_MARKER),
1929             path=path,
1930             chroot_fallback=True,
1931             ignore_retcode=True,
1932         )
1933         == 0
1934     )
1935     tmp = tempfile.mkdtemp()
1936     if seeded and not unconditional_install:
1937         ret = True
1938     else:
1939         ret = False
1940         cfg_files = __salt__["seed.mkconfig"](
1941             config,
1942             tmp=tmp,
1943             id_=name,
1944             approve_key=approve_key,
1945             pub_key=pub_key,
1946             priv_key=priv_key,
1947         )
1948         if needs_install or force_install or unconditional_install:
1949             if install:
1950                 rstr = __salt__["test.random_hash"]()
1951                 configdir = "/var/tmp/.c_{}".format(rstr)
1952                 cmd = "install -m 0700 -d {}".format(configdir)
1953                 if run_all(name, cmd, path=path, python_shell=False)["retcode"] != 0:
1954                     log.error("tmpdir %s creation failed %s", configdir, cmd)
1955                     return False
1956                 bs_ = __salt__["config.gather_bootstrap_script"](
1957                     bootstrap=bootstrap_url
1958                 )
1959                 script = "/sbin/{}_bootstrap.sh".format(rstr)
1960                 copy_to(name, bs_, script, path=path)
1961                 result = run_all(
1962                     name,
1963                     'sh -c "chmod +x {}"'.format(script),
1964                     path=path,
1965                     python_shell=True,
1966                 )
1967                 copy_to(
1968                     name,
1969                     cfg_files["config"],
1970                     os.path.join(configdir, "minion"),
1971                     path=path,
1972                 )
1973                 copy_to(
1974                     name,
1975                     cfg_files["privkey"],
1976                     os.path.join(configdir, "minion.pem"),
1977                     path=path,
1978                 )
1979                 copy_to(
1980                     name,
1981                     cfg_files["pubkey"],
1982                     os.path.join(configdir, "minion.pub"),
1983                     path=path,
1984                 )
1985                 bootstrap_args = bootstrap_args.format(configdir)
1986                 cmd = "{0} {2} {1}".format(
1987                     bootstrap_shell, bootstrap_args.replace("'", "''"), script
1988                 )
1989                 log.info("Running %s in LXC container '%s'", cmd, name)
1990                 ret = (
1991                     retcode(name, cmd, output_loglevel="info", path=path, use_vt=True)
1992                     == 0
1993                 )
1994                 run_all(
1995                     name,
1996                     'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1997                     path=path,
1998                     ignore_retcode=True,
1999                     python_shell=True,
2000                 )
2001             else:
2002                 ret = False
2003         else:
2004             minion_config = salt.config.minion_config(cfg_files["config"])
2005             pki_dir = minion_config["pki_dir"]
2006             copy_to(name, cfg_files["config"], "/etc/salt/minion", path=path)
2007             copy_to(
2008                 name,
2009                 cfg_files["privkey"],
2010                 os.path.join(pki_dir, "minion.pem"),
2011                 path=path,
2012             )
2013             copy_to(
2014                 name,
2015                 cfg_files["pubkey"],
2016                 os.path.join(pki_dir, "minion.pub"),
2017                 path=path,
2018             )
2019             run(
2020                 name,
2021                 "salt-call --local service.enable salt-minion",
2022                 path=path,
2023                 python_shell=False,
2024             )
2025             ret = True
2026         shutil.rmtree(tmp)
2027         if orig_state == "stopped":
2028             stop(name, path=path)
2029         elif orig_state == "frozen":
2030             freeze(name, path=path)
2031         if ret:
2032             run(name, "touch '{}'".format(SEED_MARKER), path=path, python_shell=False)
2033     return ret
2034 def attachable(name, path=None):
2035     cachekey = "lxc.attachable{}{}".format(name, path)
2036     try:
2037         return __context__[cachekey]
2038     except KeyError:
2039         _ensure_exists(name, path=path)
2040         log.debug("Checking if LXC container %s is attachable", name)
2041         cmd = "lxc-attach"
2042         if path:
2043             cmd += " -P {}".format(pipes.quote(path))
2044         cmd += " --clear-env -n {} -- /usr/bin/env".format(name)
2045         result = (
2046             __salt__["cmd.retcode"](
2047                 cmd, python_shell=False, output_loglevel="quiet", ignore_retcode=True
2048             )
2049             == 0
2050         )
2051         __context__[cachekey] = result
2052     return __context__[cachekey]
2053 def _run(
2054     name,
2055     cmd,
2056     output=None,
2057     no_start=False,
2058     preserve_state=True,
2059     stdin=None,
2060     python_shell=True,
2061     output_loglevel="debug",
2062     use_vt=False,
2063     path=None,
2064     ignore_retcode=False,
2065     chroot_fallback=None,
2066     keep_env="http_proxy,https_proxy,no_proxy",
2067 ):
2068     orig_state = state(name, path=path)
2069     try:
2070         if attachable(name, path=path):
2071             ret = __salt__["container_resource.run"](
2072                 name,
2073                 cmd,
2074                 path=path,
2075                 container_type=__virtualname__,
2076                 exec_driver=EXEC_DRIVER,
2077                 output=output,
2078                 no_start=no_start,
2079                 stdin=stdin,
2080                 python_shell=python_shell,
2081                 output_loglevel=output_loglevel,
2082                 ignore_retcode=ignore_retcode,
2083                 use_vt=use_vt,
2084                 keep_env=keep_env,
2085             )
2086         else:
2087             if not chroot_fallback:
2088                 raise CommandExecutionError("{} is not attachable.".format(name))
2089             rootfs = info(name, path=path).get("rootfs")
2090             __context__["cmd.run_chroot.func"] = __salt__["cmd.run"]
2091             ret = __salt__["cmd.run_chroot"](
2092                 rootfs,
2093                 cmd,
2094                 stdin=stdin,
2095                 python_shell=python_shell,
2096                 output_loglevel=output_loglevel,
2097                 ignore_retcode=ignore_retcode,
2098             )
2099     finally:
2100         new_state = state(name, path=path)
2101         if preserve_state:
2102             if orig_state == "stopped" and new_state != "stopped":
2103                 stop(name, path=path)
2104             elif orig_state == "frozen" and new_state != "frozen":
2105                 freeze(name, start=True, path=path)
2106     if output in (None, "all"):
2107         return ret
2108     else:
2109         return ret[output]
2110 def run(
2111     name,
2112     cmd,
2113     no_start=False,
2114     preserve_state=True,
2115     stdin=None,
2116     python_shell=True,
2117     output_loglevel="debug",
2118     use_vt=False,
2119     path=None,
2120     ignore_retcode=False,
2121     chroot_fallback=False,
2122     keep_env="http_proxy,https_proxy,no_proxy",
2123 ):
2124     return _run(
2125         name,
2126         cmd,
2127         path=path,
2128         output=None,
2129         no_start=no_start,
2130         preserve_state=preserve_state,
2131         stdin=stdin,
2132         python_shell=python_shell,
2133         output_loglevel=output_loglevel,
2134         use_vt=use_vt,
2135         ignore_retcode=ignore_retcode,
2136         chroot_fallback=chroot_fallback,
2137         keep_env=keep_env,
2138     )
2139 def run_stdout(
2140     name,
2141     cmd,
2142     no_start=False,
2143     preserve_state=True,
2144     stdin=None,
2145     python_shell=True,
2146     output_loglevel="debug",
2147     use_vt=False,
2148     path=None,
2149     ignore_retcode=False,
2150     chroot_fallback=False,
2151     keep_env="http_proxy,https_proxy,no_proxy",
2152 ):
2153     return _run(
2154         name,
2155         cmd,
2156         path=path,
2157         output="stdout",
2158         no_start=no_start,
2159         preserve_state=preserve_state,
2160         stdin=stdin,
2161         python_shell=python_shell,
2162         output_loglevel=output_loglevel,
2163         use_vt=use_vt,
2164         ignore_retcode=ignore_retcode,
2165         chroot_fallback=chroot_fallback,
2166         keep_env=keep_env,
2167     )
2168 def run_stderr(
2169     name,
2170     cmd,
2171     no_start=False,
2172     preserve_state=True,
2173     stdin=None,
2174     python_shell=True,
2175     output_loglevel="debug",
2176     use_vt=False,
2177     path=None,
2178     ignore_retcode=False,
2179     chroot_fallback=False,
2180     keep_env="http_proxy,https_proxy,no_proxy",
2181 ):
2182     return _run(
2183         name,
2184         cmd,
2185         path=path,
2186         output="stderr",
2187         no_start=no_start,
2188         preserve_state=preserve_state,
2189         stdin=stdin,
2190         python_shell=python_shell,
2191         output_loglevel=output_loglevel,
2192         use_vt=use_vt,
2193         ignore_retcode=ignore_retcode,
2194         chroot_fallback=chroot_fallback,
2195         keep_env=keep_env,
2196     )
2197 def retcode(
2198     name,
2199     cmd,
2200     no_start=False,
2201     preserve_state=True,
2202     stdin=None,
2203     python_shell=True,
2204     output_loglevel="debug",
2205     use_vt=False,
2206     path=None,
2207     ignore_retcode=False,
2208     chroot_fallback=False,
2209     keep_env="http_proxy,https_proxy,no_proxy",
2210 ):
2211     return _run(
2212         name,
2213         cmd,
2214         output="retcode",
2215         path=path,
2216         no_start=no_start,
2217         preserve_state=preserve_state,
2218         stdin=stdin,
2219         python_shell=python_shell,
2220         output_loglevel=output_loglevel,
2221         use_vt=use_vt,
2222         ignore_retcode=ignore_retcode,
2223         chroot_fallback=chroot_fallback,
2224         keep_env=keep_env,
2225     )
2226 def run_all(
2227     name,
2228     cmd,
2229     no_start=False,
2230     preserve_state=True,
2231     stdin=None,
2232     python_shell=True,
2233     output_loglevel="debug",
2234     use_vt=False,
2235     path=None,
2236     ignore_retcode=False,
2237     chroot_fallback=False,
2238     keep_env="http_proxy,https_proxy,no_proxy",
2239 ):
2240     return _run(
2241         name,
2242         cmd,
2243         output="all",
2244         no_start=no_start,
2245         preserve_state=preserve_state,
2246         stdin=stdin,
2247         python_shell=python_shell,
2248         output_loglevel=output_loglevel,
2249         use_vt=use_vt,
2250         path=path,
2251         ignore_retcode=ignore_retcode,
2252         chroot_fallback=chroot_fallback,
2253         keep_env=keep_env,
2254     )
2255 def _get_md5(name, path):
2256     output = run_stdout(
2257         name, 'md5sum "{}"'.format(path), chroot_fallback=True, ignore_retcode=True
2258     )
2259     try:
2260         return output.split()[0]
2261     except IndexError:
2262         return None
2263 def copy_to(name, source, dest, overwrite=False, makedirs=False, path=None):
2264     _ensure_running(name, no_start=True, path=path)
2265     return __salt__["container_resource.copy_to"](
2266         name,
2267         source,
2268         dest,
2269         container_type=__virtualname__,
2270         path=path,
2271         exec_driver=EXEC_DRIVER,
2272         overwrite=overwrite,
2273         makedirs=makedirs,
2274     )
2275 cp = salt.utils.functools.alias_function(copy_to, "cp")
2276 def read_conf(conf_file, out_format="simple"):
2277     ret_commented = []
2278     ret_simple = {}
2279     with salt.utils.files.fopen(conf_file, "r") as fp_:
2280         for line in salt.utils.data.decode(fp_.readlines()):
2281             if "=" not in line:
2282                 ret_commented.append(line)
2283                 continue
2284             comps = line.split("=")
2285             value = "=".join(comps[1:]).strip()
2286             comment = None
2287             if value.strip().startswith("#"):
2288                 vcomps = value.strip().split("#")
2289 <a name="2"></a>                value = vcomps[1].strip()
2290                 comment = "#".join(vcomps[1:]).strip()
2291                 ret_commented.append(
2292                     {<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>comps[0].strip(): {"value": value, "comment": comment}}
2293                 )
2294             else:
2295                 ret_commented.append({comps[0].strip(): value})
2296                 ret_simple[</b></font>comps[0].strip()] = value
2297     if out_format == "simple":
2298         return ret_simple
2299     return ret_commented
2300 def write_conf(conf_file, conf):
2301     if not isinstance(conf, list):
2302         raise SaltInvocationError("Configuration must be passed as a list")
2303     content = ""
2304     for line in conf:
2305         if isinstance(line, (str, (str,))):
2306             content += line
2307         elif isinstance(line, dict):
2308             for key in list(line.keys()):
2309                 out_line = None
2310                 if isinstance(
2311                     line[key],
2312                     (str, (str,), (int,), float),
2313                 ):
2314                     out_line = " = ".join((key, "{}".format(line[key])))
2315                 elif isinstance(line[key], dict):
2316                     out_line = " = ".join((key, line[key]["value"]))
2317                     if "comment" in line[key]:
2318                         out_line = " # ".join((out_line, line[key]["comment"]))
2319                 if out_line:
2320                     content += out_line
2321                     content += "\n"
2322     with salt.utils.files.fopen(conf_file, "w") as fp_:
2323         fp_.write(salt.utils.stringutils.to_str(content))
2324     return {}
2325 def edit_conf(
2326     conf_file, out_format="simple", read_only=False, lxc_config=None, **kwargs
2327 ):
2328     data = []
2329     try:
2330         conf = read_conf(conf_file, out_format=out_format)
2331     except Exception:  # pylint: disable=broad-except
2332         conf = []
2333     if not lxc_config:
2334         lxc_config = []
2335     lxc_config = copy.deepcopy(lxc_config)
2336     net_config = []
2337     for lxc_kws in lxc_config + [kwargs]:
2338         net_params = {}
2339         for kwarg in [a for a in lxc_kws]:
2340             if kwarg.startswith("__"):
2341                 continue
2342             if kwarg.startswith("lxc.network."):
2343                 net_params[kwarg] = lxc_kws[kwarg]
2344                 lxc_kws.pop(kwarg, None)
2345         if net_params:
2346             net_config.append(net_params)
2347     nic_opts = salt.utils.odict.OrderedDict()
2348     for params in net_config:
2349         dev = params.get("lxc.network.name", DEFAULT_NIC)
2350         dev_opts = nic_opts.setdefault(dev, salt.utils.odict.OrderedDict())
2351         for param in params:
2352             opt = param.replace("lxc.network.", "")
2353             opt = {"hwaddr": "mac"}.get(opt, opt)
2354             dev_opts[opt] = params[param]
2355     net_changes = []
2356     if nic_opts:
2357         net_changes = _config_list(
2358             conf,
2359             only_net=True,
2360             **{"network_profile": DEFAULT_NIC, "nic_opts": nic_opts}
2361         )
2362         if net_changes:
2363             lxc_config.extend(net_changes)
2364     for line in conf:
2365         if not isinstance(line, dict):
2366             data.append(line)
2367             continue
2368         else:
2369             for key in list(line.keys()):
2370                 val = line[key]
2371                 if net_changes and key.startswith("lxc.network."):
2372                     continue
2373                 found = False
2374                 for kw in lxc_config:
2375                     if key in kw:
2376                         found = True
2377                         data.append({key: kw[key]})
2378                         del kw[key]
2379                 if not found:
2380                     data.append({key: val})
2381     for lxc_kws in lxc_config:
2382         for kwarg in lxc_kws:
2383             data.append({kwarg: lxc_kws[kwarg]})
2384     if read_only:
2385         return data
2386     write_conf(conf_file, data)
2387     return read_conf(conf_file, out_format)
2388 def reboot(name, path=None):
2389     ret = {"result": True, "changes": {}, "comment": "{} rebooted".format(name)}
2390     does_exist = exists(name, path=path)
2391     if does_exist and (state(name, path=path) == "running"):
2392         try:
2393             stop(name, path=path)
2394         except (SaltInvocationError, CommandExecutionError) as exc:
2395             ret["comment"] = "Unable to stop container: {}".format(exc)
2396             ret["result"] = False
2397             return ret
2398     if does_exist and (state(name, path=path) != "running"):
2399         try:
2400             start(name, path=path)
2401         except (SaltInvocationError, CommandExecutionError) as exc:
2402             ret["comment"] = "Unable to stop container: {}".format(exc)
2403             ret["result"] = False
2404             return ret
2405     ret["changes"][name] = "rebooted"
2406     return ret
2407 def reconfigure(
2408     name,
2409     cpu=None,
2410     cpuset=None,
2411     cpushare=None,
2412     memory=None,
2413     profile=None,
2414     network_profile=None,
2415     nic_opts=None,
2416     bridge=None,
2417     gateway=None,
2418     autostart=None,
2419     utsname=None,
2420     rootfs=None,
2421     path=None,
2422     **kwargs
2423 ):
2424     changes = {}
2425     cpath = get_root_path(path)
2426     path = os.path.join(cpath, name, "config")
2427     ret = {
2428         "name": name,
2429         "comment": "config for {} up to date".format(name),
2430         "result": True,
2431         "changes": changes,
2432     }
2433     profile = get_container_profile(copy.deepcopy(profile))
2434     kw_overrides = copy.deepcopy(kwargs)
2435     def select(key, default=None):
2436         kw_overrides_match = kw_overrides.pop(key, _marker)
2437         profile_match = profile.pop(key, default)
2438         if kw_overrides_match is _marker:
2439             return profile_match
2440         return kw_overrides_match
2441     if nic_opts is not None and not network_profile:
2442         network_profile = DEFAULT_NIC
2443     if autostart is not None:
2444         autostart = select("autostart", autostart)
2445     else:
2446         autostart = "keep"
2447     if not utsname:
2448         utsname = select("utsname", utsname)
2449     if os.path.exists(path):
2450         old_chunks = read_conf(path, out_format="commented")
2451         make_kw = salt.utils.odict.OrderedDict(
2452             [
2453                 ("utsname", utsname),
2454                 ("rootfs", rootfs),
2455                 ("autostart", autostart),
2456                 ("cpu", cpu),
2457                 ("gateway", gateway),
2458                 ("cpuset", cpuset),
2459                 ("cpushare", cpushare),
2460                 ("network_profile", network_profile),
2461                 ("nic_opts", nic_opts),
2462                 ("bridge", bridge),
2463             ]
2464         )
2465         if memory:
2466             make_kw["memory"] = memory
2467         kw = salt.utils.odict.OrderedDict()
2468         for key, val in make_kw.items():
2469             if val is not None:
2470                 kw[key] = val
2471         new_cfg = _config_list(conf_tuples=old_chunks, **kw)
2472         if new_cfg:
2473             edit_conf(path, out_format="commented", lxc_config=new_cfg)
2474         chunks = read_conf(path, out_format="commented")
2475         if old_chunks != chunks:
2476             ret["comment"] = "{} lxc config updated".format(name)
2477             if state(name, path=path) == "running":
2478                 cret = reboot(name, path=path)
2479                 ret["result"] = cret["result"]
2480     return ret
2481 def apply_network_profile(name, network_profile, nic_opts=None, path=None):
2482     cpath = get_root_path(path)
2483     cfgpath = os.path.join(cpath, name, "config")
2484     before = []
2485     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2486         for line in fp_:
2487             before.append(line)
2488     lxcconfig = _LXCConfig(name=name, path=path)
2489     old_net = lxcconfig._filter_data("lxc.network")
2490     network_params = {}
2491     for param in _network_conf(
2492         conf_tuples=old_net, network_profile=network_profile, nic_opts=nic_opts
2493     ):
2494         network_params.update(param)
2495     if network_params:
2496         edit_conf(cfgpath, out_format="commented", **network_params)
2497     after = []
2498     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2499         for line in fp_:
2500             after.append(line)
2501     diff = ""
2502     for line in difflib.unified_diff(before, after, fromfile="before", tofile="after"):
2503         diff += line
2504     return diff
2505 def get_pid(name, path=None):
2506     if name not in list_(limit="running", path=path):
2507         raise CommandExecutionError(
2508             "Container {} is not running, can't determine PID".format(name)
2509         )
2510     info = __salt__["cmd.run"]("lxc-info -n {}".format(name)).split("\n")
2511     pid = [
2512         line.split(":")[1].strip()
2513         for line in info
2514         if re.match(r"\s*PID", line) is not None
2515     ][0]
2516     return pid
2517 def add_veth(name, interface_name, bridge=None, path=None):
2518     pid = get_pid(name, path=path)
2519     while True:
2520         random_veth = "veth" + "".join(
2521             random.choice(string.ascii_uppercase + string.digits) for _ in range(6)
2522         )
2523         if random_veth not in __salt__["network.interfaces"]().keys():
2524             break
2525     if not __salt__["file.directory_exists"]("/var/run/"):
2526         raise CommandExecutionError(
2527             "Directory /var/run required for lxc.add_veth doesn't exists"
2528         )
2529     if not __salt__["file.file_exists"]("/proc/{}/ns/net".format(pid)):
2530         raise CommandExecutionError(
2531             "Proc file for container {} network namespace doesn't exists".format(name)
2532         )
2533     if not __salt__["file.directory_exists"]("/var/run/netns"):
2534         __salt__["file.mkdir"]("/var/run/netns")
2535     if __salt__["file.is_link"]("/var/run/netns/{}".format(name)):
2536         __salt__["file.remove"]("/var/run/netns/{}".format(name))
2537     __salt__["file.symlink"](
2538         "/proc/{}/ns/net".format(pid), "/var/run/netns/{}".format(name)
2539     )
2540     interface_exists = 0 == __salt__["cmd.retcode"](
2541         "ip netns exec {netns} ip address list {interface}".format(
2542             netns=name, interface=interface_name
2543         )
2544     )
2545     if interface_exists:
2546         raise CommandExecutionError(
2547             "Interface {interface} already exists in {container}".format(
2548                 interface=interface_name, container=name
2549             )
2550         )
2551     if (
2552         __salt__["cmd.retcode"](
2553             "ip link add name {veth} type veth peer name {veth}_c".format(
2554                 veth=random_veth
2555             )
2556         )
2557         != 0
2558     ):
2559         raise CommandExecutionError(
2560             "Error while creating the veth pair {}".format(random_veth)
2561         )
2562     if __salt__["cmd.retcode"]("ip link set dev {} up".format(random_veth)) != 0:
2563         raise CommandExecutionError(
2564             "Error while bringing up host-side veth {}".format(random_veth)
2565         )
2566     attached = 0 == __salt__["cmd.retcode"](
2567         "ip link set dev {veth}_c netns {container} name {interface_name}".format(
2568             veth=random_veth, container=name, interface_name=interface_name
2569         )
2570     )
2571     if not attached:
2572         raise CommandExecutionError(
2573             "Error while attaching the veth {veth} to container {container}".format(
2574                 veth=random_veth, container=name
2575             )
2576         )
2577     __salt__["file.remove"]("/var/run/netns/{}".format(name))
2578     if bridge is not None:
2579         __salt__["bridge.addif"](bridge, random_veth)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
