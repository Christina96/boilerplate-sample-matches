<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_process_1.py &amp; lxc_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_process_1.py &amp; lxc_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_process_1.py (4.536222%)<th>lxc_1.py (1.3432237%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-20)<td><a href="#" name="0">(21-41)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(162-166)<td><a href="#" name="1">(3028-3030)</a><td align="center"><font color="#b80000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(843-846)<td><a href="#" name="2">(4325-4329)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(810-813)<td><a href="#" name="3">(1058-1060)</a><td align="center"><font color="#aa0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(734-736)<td><a href="#" name="4">(215-222)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_process_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import functools
2 import io
3 import multiprocessing
4 import os
5 import signal
6 import sys
7 import tempfile
8 import threading
9 import time
10 import warnings
11 import pytest
12 import salt.utils.platform
13 import salt.utils.process
14 from salt.utils.versions import warn_until_date
15 from tests.support.mock import patch
16 from tests.support.unit import TestCase, skipIf
17 HAS_PSUTIL =</b></font> False
18 try:
19     import psutil
20     HAS_PSUTIL = True
21 except ImportError:
22     pass
23 def die(func):
24     @functools.wraps(func)
25     def wrapper(self):
26         name = func.__name__[5:]
27         def _die():
28             salt.utils.process.appendproctitle("test_{}".format(name))
29         attrname = "die_" + name
30         setattr(self, attrname, _die)
31         self.addCleanup(delattr, self, attrname)
32     return wrapper
33 def incr(func):
34     @functools.wraps(func)
35     def wrapper(self):
36         name = func.__name__[5:]
37         def _incr(counter, num):
38             salt.utils.process.appendproctitle("test_{}".format(name))
39             for _ in range(0, num):
40                 counter.value += 1
41         attrname = "incr_" + name
42         setattr(self, attrname, _incr)
43         self.addCleanup(delattr, self, attrname)
44     return wrapper
45 def spin(func):
46     @functools.wraps(func)
47     def wrapper(self):
48         name = func.__name__[5:]
49         def _spin():
50             salt.utils.process.appendproctitle("test_{}".format(name))
51             while True:
52                 time.sleep(1)
53         attrname = "spin_" + name
54         setattr(self, attrname, _spin)
55         self.addCleanup(delattr, self, attrname)
56     return wrapper
57 class TestProcessManager(TestCase):
58     @spin
59     @pytest.mark.slow_test
60     def test_basic(self):
61         process_manager = salt.utils.process.ProcessManager()
62         self.addCleanup(process_manager.terminate)
63         process_manager.add_process(self.spin_basic)
64         initial_pid = next(iter(process_manager._process_map.keys()))
65         time.sleep(2)
66         process_manager.check_children()
67         assert initial_pid == next(iter(process_manager._process_map.keys()))
68     @spin
69     def test_kill(self):
70         process_manager = salt.utils.process.ProcessManager()
71         self.addCleanup(process_manager.terminate)
72         process_manager.add_process(self.spin_kill)
73         initial_pid = next(iter(process_manager._process_map.keys()))
74         if salt.utils.platform.is_windows():
75             os.kill(initial_pid, signal.SIGTERM)
76         else:
77             os.kill(initial_pid, signal.SIGKILL)
78         time.sleep(0.1)
79         process_manager.check_children()
80         assert initial_pid != next(iter(process_manager._process_map.keys()))
81     @die
82     def test_restarting(self):
83         process_manager = salt.utils.process.ProcessManager()
84         self.addCleanup(process_manager.terminate)
85         process_manager.add_process(self.die_restarting)
86         initial_pid = next(iter(process_manager._process_map.keys()))
87         time.sleep(2)
88         process_manager.check_children()
89         assert initial_pid != next(iter(process_manager._process_map.keys()))
90     @incr
91     def test_counter(self):
92         counter = multiprocessing.Value("i", 0)
93         process_manager = salt.utils.process.ProcessManager()
94         self.addCleanup(process_manager.terminate)
95         process_manager.add_process(self.incr_counter, args=(counter, 2))
96         time.sleep(1)
97         process_manager.check_children()
98         time.sleep(1)
99         assert counter.value == 4
100 class TestThreadPool(TestCase):
101     @pytest.mark.slow_test
102     def test_basic(self):
103         def incr_counter(counter):
104             counter.value += 1
105         counter = multiprocessing.Value("i", 0)
106         pool = salt.utils.process<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.ThreadPool()
107         sent = pool.fire_async(incr_counter, args=(counter,))
108         self.assertTrue(sent)
109         time.sleep(1)  # Sleep to let the threads do things
110         self.assertEqual(</b></font>counter.value, 1)
111         self.assertEqual(pool._job_queue.qsize(), 0)
112     @pytest.mark.slow_test
113     def test_full_queue(self):
114         def incr_counter(counter):
115             counter.value += 1
116         counter = multiprocessing.Value("i", 0)
117         pool = salt.utils.process.ThreadPool(0, 1)
118         sent = pool.fire_async(incr_counter, args=(counter,))
119         self.assertTrue(sent)
120         sent = pool.fire_async(incr_counter, args=(counter,))
121         self.assertFalse(sent)
122         time.sleep(1)  # Sleep to let the threads do things
123         self.assertEqual(counter.value, 0)
124         self.assertEqual(pool._job_queue.qsize(), 1)
125 class TestProcess(TestCase):
126     def test_daemonize_if(self):
127         with patch("sys.argv", ["salt-call"]):
128             ret = salt.utils.process.daemonize_if({})
129             self.assertEqual(None, ret)
130         ret = salt.utils.process.daemonize_if({"multiprocessing": False})
131         self.assertEqual(None, ret)
132         with patch("sys.platform", "win"):
133             ret = salt.utils.process.daemonize_if({})
134             self.assertEqual(None, ret)
135         with patch("salt.utils.process.daemonize"), patch("sys.platform", "linux2"):
136             salt.utils.process.daemonize_if({})
137             self.assertTrue(salt.utils.process.daemonize.called)
138 class TestProcessCallbacks(TestCase):
139     @staticmethod
140     def process_target(evt):
141         evt.set()
142     def test_callbacks(self):
143         "Validate Process call after fork and finalize methods"
144         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
145         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
146         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
147             evt = multiprocessing.Event()
148             proc = salt.utils.process.Process(target=self.process_target, args=(evt,))
149             proc.run()
150             assert evt.is_set()
151         mb.assert_called()
152         ma.assert_called()
153     def test_callbacks_called_when_run_overridden(self):
154         "Validate Process sub classes call after fork and finalize methods when run is overridden"
155         class MyProcess(salt.utils.process.Process):
156             def __init__(self):
157                 super().__init__()
158                 self.evt = multiprocessing.Event()
159             def run(self):
160                 self.evt.set()
161         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
162         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
163         with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
164             proc = MyProcess()
165             proc.run()
166             assert proc.evt.is_set()
167         ma.assert_called()
168         mb.assert_called()
169 @skipIf(not HAS_PSUTIL, "Missing psutil")
170 class TestSignalHandlingProcess(TestCase):
171     @classmethod
172     def Process(cls, pid):
173         raise psutil.NoSuchProcess(pid)
174     @classmethod
175     def target(cls):
176         os.kill(os.getpid(), signal.SIGTERM)
177     @classmethod
178     def children(cls, *args, **kwargs):
179         raise psutil.NoSuchProcess(1)
180     def test_process_does_not_exist(self):
181         try:
182             with patch("psutil.Process", self.Process):
183                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
184                 proc.start()
185         except psutil.NoSuchProcess:
186             assert False, "psutil.NoSuchProcess raised"
187     def test_process_children_do_not_exist(self):
188         try:
189             with patch("psutil.Process.children", self.children):
190                 proc = salt.utils.process.SignalHandlingProcess(target=self.target)
191                 proc.start()
192         except psutil.NoSuchProcess:
193             assert False, "psutil.NoSuchProcess raised"
194     @staticmethod
195     def run_forever_sub_target(evt):
196         "Used by run_forever_target to create a sub-process"
197         while not evt.is_set():
198             time.sleep(1)
199     @staticmethod
200     def run_forever_target(sub_target, evt):
201         "A target that will run forever or until an event is set"
202         p = multiprocessing.Process(target=sub_target, args=(evt,))
203         p.start()
204         p.join()
205     @staticmethod
206     def kill_target_sub_proc():
207         pid = os.fork()
208         if pid == 0:
209             return
210         pid = os.fork()
211         if pid == 0:
212             return
213         time.sleep(0.1)
214         try:
215             os.kill(os.getpid(), signal.SIGINT)
216         except KeyboardInterrupt:
217             pass
218     @skipIf(sys.platform.startswith("win"), "No os.fork on Windows")
219     @pytest.mark.slow_test
220     def test_signal_processing_regression_test(self):
221         evt = multiprocessing.Event()
222         sh_proc = salt.utils.process.SignalHandlingProcess(
223             target=self.run_forever_target, args=(self.run_forever_sub_target, evt)
224         )
225         sh_proc.start()
226         proc = multiprocessing.Process(target=self.kill_target_sub_proc)
227         proc.start()
228         proc.join()
229         try:
230             assert sh_proc.is_alive()
231         finally:
232             evt.set()
233             sh_proc.join()
234     @staticmethod
235     def no_op_target():
236         pass
237     @staticmethod
238     def pid_setting_target(sub_target, val, evt):
239         val.value = os.getpid()
240         p = multiprocessing.Process(target=sub_target, args=(evt,))
241         p.start()
242         p.join()
243     @skipIf(sys.platform.startswith("win"), "Required signals not supported on windows")
244     @pytest.mark.slow_test
245     def test_signal_processing_handle_signals_called(self):
246         "Validate SignalHandlingProcess handles signals"
247         evt = multiprocessing.Event()
248         val = multiprocessing.Value("i", 0)
249         proc = salt.utils.process.SignalHandlingProcess(
250             target=self.pid_setting_target,
251             args=(self.run_forever_sub_target, val, evt),
252         )
253         proc.start()
254         proc2 = multiprocessing.Process(
255             target=self.run_forever_target,
256             args=(self.run_forever_sub_target, evt),
257         )
258         proc2.start()
259         while not val.value:
260             time.sleep(0.3)
261         assert not proc.signal_handled()
262         os.kill(val.value, signal.SIGTERM)
263         start = time.time()
264         while time.time() - start &lt; 10:
265             if proc.signal_handled():
266                 break
267             time.sleep(0.3)
268         try:
269             assert proc.signal_handled()
270             proc.join(1)
271             assert proc2.is_alive()
272         finally:
273             evt.set()
274             proc2.join(30)
275             proc.join(30)
276 class TestSignalHandlingProcessCallbacks(TestCase):
277     @staticmethod
278     def process_target(evt):
279         evt.set()
280     def test_callbacks(self):
281         "Validate SignalHandlingProcess call after fork and finalize methods"
282         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
283         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
284         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
285         evt = multiprocessing.Event()
286         with patch(sig_to_mock):
287             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
288                 sh_proc = salt.utils.process.SignalHandlingProcess(
289                     target=self.process_target, args=(evt,)
290                 )
291                 sh_proc.run()
292                 assert evt.is_set()
293         ma.assert_called()
294         mb.assert_called()
295     def test_callbacks_called_when_run_overridden(self):
296         "Validate SignalHandlingProcess sub classes call after fork and finalize methods when run is overridden"
297         class MyProcess(salt.utils.process.SignalHandlingProcess):
298             def __init__(self):
299                 super().__init__()
300                 self.evt = multiprocessing.Event()
301             def run(self):
302                 self.evt.set()
303         teardown_to_mock = "salt.log.setup.shutdown_multiprocessing_logging"
304         log_to_mock = "salt.log.setup.setup_multiprocessing_logging"
305         sig_to_mock = "salt.utils.process.SignalHandlingProcess._setup_signals"
306         with patch(sig_to_mock):
307             with patch(teardown_to_mock) as ma, patch(log_to_mock) as mb:
308                 sh_proc = MyProcess()
309                 sh_proc.run()
310                 assert sh_proc.evt.is_set()
311         ma.assert_called()
312         mb.assert_called()
313 class TestDup2(TestCase):
314     def test_dup2_no_fileno(self):
315         "The dup2 method does not fail on streams without fileno support"
316         f1 = io.StringIO("some initial text data")
317         f2 = io.StringIO("some initial other text data")
318         with self.assertRaises(io.UnsupportedOperation):
319             f1.fileno()
320         with patch("os.dup2") as dup_mock:
321             try:
322                 salt.utils.process.dup2(f1, f2)
323             except io.UnsupportedOperation:
324                 assert False, "io.UnsupportedOperation was raised"
325         assert not dup_mock.called
326 def null_target():
327     pass
328 def event_target(event):
329     while True:
330         if event.wait(5):
331             break
332 class TestProcessList(TestCase):
333     @staticmethod
334     def wait_for_proc(proc, timeout=10):
335         start = time.time()
336         while proc.is_alive():
337             if time.time() - start &gt; timeout:
338                 raise Exception("Process did not finishe before timeout")
339             time.sleep(0.3)
340     @pytest.mark.slow_test
341     def test_process_list_process(self):
342         plist = salt.utils.process.SubprocessList()
343         proc = multiprocessing.Process(target=null_target)
344         proc.start()
345         plist.add(proc)
346         assert proc in plist.processes
347         self.wait_for_proc(proc)
348         assert not proc.is_alive()
349         plist.cleanup()
350         assert proc not in plist.processes
351     def test_process_list_thread(self):
352         plist = salt.utils.process.SubprocessList()
353         thread = threading.Thread(target=null_target)
354         thread.start()
355         plist.add(thread)
356         assert thread in plist.processes
357         self.wait_for_proc(thread)
358         assert not thread.is_alive()
359         plist.cleanup()
360         assert thread not in plist.processes
361     @pytest.mark.slow_test
362     def test_process_list_cleanup(self):
363         plist = salt.utils.process.SubprocessList()
364         event = multiprocessing.Event()
365         proc = multiprocessing.Process(target=event_target, args=[event])
366         proc.start()
367         plist.add(proc)
368         assert proc in plist.processes
369         plist.cleanup()
370         event.set()
371         assert proc in plist.processes
372         self.wait_for_proc(proc)
373         assert not proc.is_alive()
374         plist.cleanup()
375         assert proc not in plist.processes
376 class TestDeprecatedClassNames(TestCase):
377     @staticmethod
378     def process_target():
379         pass
380     @staticmethod
381     def patched_warn_until_date(current_date):
382         def _patched_warn_until_date(
383             date,
384             message,
385             category=DeprecationWarning,
386             stacklevel=None,
387             _current_date=current_date,
388             _dont_call_warnings=False,
389         ):
390             stacklevel = 4
391             return warn_until_date(
392                 date,
393                 message,
394                 category=category,
395                 stacklevel=stacklevel,
396                 _current_date=_current_date,
397                 _dont_call_warnings=_dont_call_warnings,
398             )
399         return _patched_warn_until_date
400     def test_multiprocessing_process_warning(self):
401         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
402         fake_utcnow = datetime.date(2021, 1, 1)
403         proc = None
404         try:
405             with patch(
406                 "salt.utils.versions.warn_until_date",
407                 self.patched_warn_until_date(fake_utcnow),
408             ):
409                 with warnings.catch_warnings(record=True) as recorded_warnings:
410                     proc = salt.utils.process.MultiprocessingProcess(
411                         target=self.process_target
412                     )
413                     self.assertEqual(
414                         "Please stop using 'salt.utils.process.MultiprocessingProcess' "
415                         "and instead use 'salt.utils.process.Process'. "
416                         "'salt.utils.process.MultiprocessingProcess' will go away "
417                         "after 2022-01-01.",
418                         str(recorded_warnings[0].message),
419                     )
420         finally:
421             if proc is not None:
422                 del proc
423     def test_multiprocessing_process_runtime_error(self):
424         fake_utcnow = datetime.date(2022, 1, 1)
425         proc = None
426         try:
427             with patch(
428                 "salt.utils.versions.warn_until_date",
429                 self.patched_warn_until_date(fake_utcnow),
430             ):
431                 with self.assertRaisesRegex(
432                     RuntimeError,
433                     r"Please stop using 'salt.utils.process.MultiprocessingProcess' "
434                     r"and instead use 'salt.utils.process.Process'. "
435                     r"'salt.utils.process.MultiprocessingProcess' will go away "
436                     r"after 2022-01-01. "
437                     r"This warning\(now exception\) triggered on "
438                     r"filename '(.*)test_process.py', line number ([\d]+), is "
439                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
440                     r"Please remove the warning.",
441                 ):
442                     proc = salt.utils.process.MultiprocessingProcess(
443                         target=self.process_target
444                     )
445         finally:
446             if proc is not None:
447                 del proc
448     def test_signal_handling_multiprocessing_process_warning(self):
449         warnings.filterwarnings("always", "", DeprecationWarning, __name__)
450         fake_utcnow = datetime.date(2021, 1, 1)
451         proc = None
452         try:
453             with patch(
454                 "salt.utils.versions.warn_until_date",
455                 self.patched_warn_until_date(fake_utcnow),
456             ):
457                 with warnings.catch_warnings(record=True) as recorded_warnings:
458                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
459                         target=self.process_target
460                     )
461                     self.assertEqual(
462                         "Please stop using"
463                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess' and"
464                         " instead use 'salt.utils.process.SignalHandlingProcess'."
465                         " 'salt.utils.process.SignalHandlingMultiprocessingProcess'"
466                         " will go away after 2022-01-01.",
467                         str(recorded_warnings[0].message),
468                     )
469         finally:
470             if proc is not None:
471                 del proc
472     def test_signal_handling_multiprocessing_process_runtime_error(self):
473         fake_utcnow = datetime.date(2022, 1, 1)
474         proc = None
475         try:
476             with patch(
477                 "salt.utils.versions.warn_until_date",
478                 self.patched_warn_until_date(fake_utcnow),
479             ):
480                 with self.assertRaisesRegex(
481                     RuntimeError,
482                     r"Please stop using"
483                     r" 'salt.utils.process.SignalHandlingMultiprocessingProcess' "
484                     r"and instead use 'salt.utils.process.SignalHandlingProcess'. "
485                     r"'salt.utils.process.SignalHandlingMultiprocessingProcess' will go"
486                     r" away "
487                     r"after 2022-01-01. "
488                     r"This warning\(now exception\) triggered on "
489                     r"filename '(.*)test_process.py', line number ([\d]+), is "
490                     r"supposed to be shown until ([\d-]+). Today is ([\d-]+). "
491                     r"Please remove the warning.",
492                 ):
493                     proc = salt.utils.process.SignalHandlingMultiprocessingProcess(
494                         target=self.process_target
495                     )
496         finally:
497             if proc is not None:
498                 del proc
499 class CMORProcessHelper:
500     def __init__(self, file_name):
501         self._lock = threading.Lock()
502         self._running = True
503         self._queue = multiprocessing.Queue()
504         self._ret_queue = multiprocessing.Queue()
505         self._process = multiprocessing.Process(
506             target=self.test_process,
507             args=(file_name, self._queue, self._ret_queue),
508             daemon=True,
509         )
510         self._process.start()
511     def __enter__(self):
512         return self
513     def __exit__(self, exc_type, exc_val, exc_tb):
514         self.stop()
515     def claim(self):
516         try:
517             self._lock.acquire()
518             if self._running:
519                 self._queue.put("claim")
520                 return self._ret_queue.get(timeout=10)
521         finally:
522             self._lock.release()
523     def stop(self):
524         try:
525             self._lock.acquire()
526             if self._running:
527                 self._running = False
528                 self._queue.put("stop")
529                 self._process.join(timeout=10)
530                 self._queue.close()
531                 self._ret_queue.close()
532         finally:
533             self._lock.release()
534     @property
535     def pid(self):
536         return self._process.pid
537     @staticmethod
538     def test_process(file_name, queue, ret_queue):
539         while True:
540             action = queue.get()
541             if action == "claim":
542                 ret_queue.put(
543                     salt.utils.process.claim_mantle_of_responsibility(file_name)
544                 )
545             elif action == "stop":
546                 return
547 @skipIf(not HAS_PSUTIL, "Missing psutil")
548 class TestGetProcessInfo(TestCase):
549     def setUp(self):
550         handle, self.cmor_test_file_path = tempfile.mkstemp()
551         os.close(handle)
552         self.addCleanup(os.unlink, self.cmor_test_file_path)
553     def test_this_process(self):
554         this_process_info = salt.utils.process.get_process_info()
555         self.assertEqual(
556             this_process_info, salt.utils.process.get_process_info(os.getpid())
557         )
558         self.assertIsNotNone(this_process_info)
559             self.assertIn(key, this_process_info)
560         raw_process_info = psutil<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Process(os.getpid())
561         self.assertEqual(this_process_info["pid"], os.getpid())
562         self.assertEqual(this_process_info[</b></font>"name"], raw_process_info.name())
563         self.assertEqual(
564             this_process_info["start_time"], raw_process_info.create_time()
565         )
566     def test_random_processes(self):
567         for _ in range(3):
568             with CMORProcessHelper(self.cmor_test_file_path) as p1:
569                 pid = p1.pid
570                 self.assertIsInstance(salt.utils.process.get_process_info(pid), dict)
571             self.assertIsNone(salt.utils.process.get_process_info(pid))
572 @skipIf(not HAS_PSUTIL, "Missing psutil")
573 class TestClaimMantleOfResponsibility(TestCase):
574     def setUp(self):
575         handle, self.cmor_test_file_path = tempfile.mkstemp()
576         os.close(handle)
577         self.addCleanup(os.unlink, self.cmor_test_file_path)
578     def test_simple_claim_no_psutil(self):
579         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
580     def test_simple_claim(self):
581         for _ in range(5):
582             self.assertTrue(
583                 salt.utils.process.claim_mantle_of_responsibility(
584                     self.cmor_test_file_path
585                 )
586             )
587     def test_multiple_processes(self):
588         with CMORProcessHelper(self.cmor_test_file_path) as p1:
589             self.assertTrue(p1.claim())
590             self.assertFalse(
591                 salt.utils.process.claim_mantle_of_responsibility(
592                     self.cmor_test_file_path
593                 )
594             )
595             with CMORProcessHelper(self.cmor_test_file_path) as p2:
596                 for _ in range(3):
597                     self.assertFalse(p2.claim())
598             self.assertTrue(p1.claim())
599         with CMORProcessHelper(self.cmor_test_file_path) as p1:
600             self.assertTrue(p1.claim())
601             self.assertFalse(
602                 salt.utils.process.claim_mantle_of_responsibility(
603                     self.cmor_test_file_path
604                 )
605             )
606         self.assertTrue(
607             salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
608         )
609 @skipIf(not HAS_PSUTIL, "Missing psutil")
610 class TestCheckMantleOfResponsibility(TestCase):
611     def setUp(self):
612         handle, self.cmor_test_file_path = tempfile.mkstemp()
613         os.close(handle)
614         self.addCleanup(os.unlink, self.cmor_test_file_path)
615     def test_simple_claim_no_psutil(self):
616         self.assertIsNone(
617             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
618         )
619     def test_simple_claim(self):
620         self.assertIsNone(
621         )
622         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
623         pid = salt<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.process.get_process_info()["pid"]
624         self.assertEqual(
625             pid,
626             salt.utils.process.check_mantle_of_responsibility(self.</b></font>cmor_test_file_path),
627         )
628     def test_multiple_processes(self):
629         self.assertIsNone(
630             salt.utils.process.check_mantle_of_responsibility(self.cmor_test_file_path)
631         )
632         with CMORProcessHelper(self.cmor_test_file_path) as p1:
633             self.assertTrue(p1.claim())
634             random_pid = salt.utils.process.check_mantle_of_responsibility(
635                 self.cmor_test_file_path
636             )
637             self.assertIsInstance(random_pid, int)
638             with CMORProcessHelper(self.cmor_test_file_path) as p2:
639                 for _ in range(3):
640                     self.assertFalse(p2.claim())
641                 self.assertEqual(
642                     random_pid,
643                     salt.utils.process.check_mantle_of_responsibility(
644                         self.cmor_test_file_path
645                     ),
646                 )
647         self.assertIsNone(
648         )
649         salt.utils.process.claim_mantle_of_responsibility(self.cmor_test_file_path)
650         pid = salt<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.process.get_process_info()["pid"]
651         self.assertEqual(
652             pid,
653             salt.utils.process.check_mantle_of_responsibility(self.</b></font>cmor_test_file_path),
654         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import difflib
4 import logging
5 import os
6 import pipes
7 import random
8 import re
9 import string
10 import tempfile
11 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import textwrap
12 import time
13 import urllib.parse
14 import salt.config
15 import salt.utils.args
16 import salt.utils.cloud
17 import salt.utils.data
18 import salt.utils.dictupdate
19 import salt.utils.files
20 import salt.utils.functools
21 import salt.utils.hashutils
22 import salt.utils.network
23 import salt.utils.odict
24 import salt.utils.path
25 import salt.utils.stringutils
26 from salt.exceptions import CommandExecutionError, SaltInvocationError
27 from salt.utils.versions import LooseVersion as _LooseVersion
28 log =</b></font> logging.getLogger(__name__)
29 __func_alias__ = {"list_": "list", "ls_": "ls"}
30 __virtualname__ = "lxc"
31 DEFAULT_NIC = "eth0"
32 DEFAULT_BR = "br0"
33 SEED_MARKER = "/lxc.initial_seed"
34 EXEC_DRIVER = "lxc-attach"
35 DEFAULT_PATH = "/var/lib/lxc"
36 _marker = object()
37 def __virtual__():
38     if salt.utils.path.which("lxc-start"):
39         return __virtualname__
40     return (
41         False,
42         "The lxc execution module cannot be loaded: the lxc-start binary is not in the"
43         " path.",
44     )
45 def get_root_path(path):
46     if not path:
47         path = __opts__.get("lxc.root_path", DEFAULT_PATH)
48     return path
49 def version():
50     k = "lxc.version"
51     if not __context__.get(k, None):
52         cversion = __salt__["cmd.run_all"]("lxc-info --version")
53         if not cversion["retcode"]:
54             ver = _LooseVersion(cversion["stdout"])
55             if ver &lt; _LooseVersion("1.0"):
56                 raise CommandExecutionError("LXC should be at least 1.0")
57             __context__[k] = "{}".format(ver)
58     return __context__.get(k, None)
59 def _clear_context():
60     for var in [x for x in __context__ if x.startswith("lxc.")]:
61         log.trace("Clearing __context__['%s']", var)
62         __context__.pop(var, None)
63 def _ip_sort(ip):
64     idx = "001"
65     if ip == "127.0.0.1":
66         idx = "200"
67     if ip == "::1":
68         idx = "201"
69     elif "::" in ip:
70         idx = "100"
71     return "{}___{}".format(idx, ip)
72 def search_lxc_bridges():
73     bridges = __context__.get("lxc.bridges", None)
74     if not bridges:
75         bridges = set()
76         running_bridges = set()
77         bridges.add(DEFAULT_BR)
78         try:
79             output = __salt__["cmd.run_all"]("brctl show")
80             for line in output["stdout"].splitlines()[1:]:
81                 if not line.startswith(" "):
82                     running_bridges.add(line.split()[0].strip())
83         except (SaltInvocationError, CommandExecutionError):
84             pass
85         for ifc, ip in __grains__.get("ip_interfaces", {}).items():
86             if ifc in running_bridges:
87                 bridges.add(ifc)
88             elif os.path.exists("/sys/devices/virtual/net/{}/bridge".format(ifc)):
89                 bridges.add(ifc)
90         bridges = list(bridges)
91         def sort_bridges(a):
92             pref = "z"
93             if "lxc" in a:
94                 pref = "a"
95             elif "br0" == a:
96                 pref = "c"
97             return "{}_{}".format(pref, a)
98         bridges.sort(key=sort_bridges)
99         __context__["lxc.bridges"] = bridges
100     return bridges
101 def search_lxc_bridge():
102     return search_lxc_bridges()[0]
103 def _get_salt_config(config, **kwargs):
104     if not config:
105     if not config:
106         config = {}
107     config<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.setdefault(
108         "master", kwargs.get("master", __opts__.get("master", __opts__["id"]))
109     )
110     config.setdefault(
111         "master_port",
112         kwargs.get(
113             "master_port",
114             __opts__.</b></font>get("master_port", __opts__.get("ret_port", __opts__.get("4506"))),
115         ),
116     )
117     if not config["master"]:
118         config = {}
119     return config
120 def cloud_init_interface(name, vm_=None, **kwargs):
121     if vm_ is None:
122         vm_ = {}
123     vm_ = copy.deepcopy(vm_)
124     vm_ = salt.utils.dictupdate.update(vm_, kwargs)
125     profile_data = copy.deepcopy(vm_.get("lxc_profile", vm_.get("profile", {})))
126     if not isinstance(profile_data, (dict, (str,))):
127         profile_data = {}
128     profile = get_container_profile(profile_data)
129     def _cloud_get(k, default=None):
130         return vm_.get(k, profile.get(k, default))
131     if name is None:
132         name = vm_["name"]
133     default_template = ""
134     if __grains__.get("os", "") in ["Ubuntu"]:
135         default_template = "ubuntu"
136     image = _cloud_get("image")
137     if not image:
138         _cloud_get("template", default_template)
139     backing = _cloud_get("backing", "dir")
140     if image:
141         profile["template"] = image
142     vgname = _cloud_get("vgname", None)
143     if vgname:
144         profile["vgname"] = vgname
145     if backing:
146         profile["backing"] = backing
147     snapshot = _cloud_get("snapshot", False)
148     autostart = bool(_cloud_get("autostart", True))
149     dnsservers = _cloud_get("dnsservers", [])
150     dns_via_dhcp = _cloud_get("dns_via_dhcp", True)
151     password = _cloud_get("password", "s3cr3t")
152     password_encrypted = _cloud_get("password_encrypted", False)
153     fstype = _cloud_get("fstype", None)
154     lvname = _cloud_get("lvname", None)
155     thinpool = _cloud_get("thinpool", None)
156     pub_key = _cloud_get("pub_key", None)
157     priv_key = _cloud_get("priv_key", None)
158     size = _cloud_get("size", "20G")
159     script = _cloud_get("script", None)
160     script_args = _cloud_get("script_args", None)
161     users = _cloud_get("users", None)
162     if users is None:
163         users = []
164     ssh_username = _cloud_get("ssh_username", None)
165     if ssh_username and (ssh_username not in users):
166         users.append(ssh_username)
167     network_profile = _cloud_get("network_profile", None)
168     nic_opts = kwargs.get("nic_opts", None)
169     netmask = _cloud_get("netmask", "24")
170     path = _cloud_get("path", None)
171     bridge = _cloud_get("bridge", None)
172     gateway = _cloud_get("gateway", None)
173     unconditional_install = _cloud_get("unconditional_install", False)
174     force_install = _cloud_get("force_install", True)
175     config = _get_salt_config(_cloud_get("config", {}), **vm_)
176     default_nic = _cloud_get("default_nic", DEFAULT_NIC)
177     if not isinstance(nic_opts, dict):
178         nic_opts = salt.utils.odict.OrderedDict()
179     eth0 = nic_opts.setdefault(default_nic, salt.utils.odict.OrderedDict())
180     if not isinstance(nic_opts, salt.utils.odict.OrderedDict):
181         bnic_opts = salt.utils.odict.OrderedDict()
182         bnic_opts.update(nic_opts)
183         nic_opts = bnic_opts
184     gw = None
185     bridge = _cloud_get("bridge", None)
186     ip = _cloud_get("ip", None)
187     mac = _cloud_get("mac", None)
188     if ip:
189         fullip = ip
190         if netmask:
191             fullip += "/{}".format(netmask)
192         eth0["ipv4"] = fullip
193         if mac is not None:
194             eth0["mac"] = mac
195     for ix, iopts in enumerate(_cloud_get("additional_ips", [])):
196         ifh = "eth{}".format(ix + 1)
197         ethx = nic_opts.setdefault(ifh, {})
198         if gw is None:
199             gw = iopts.get("gateway", ethx.get("gateway", None))
200             if gw:
201                 eth0.pop("gateway", None)
202                 gateway = None
203                 ethx["gateway"] = gw
204         elink = iopts.get("link", ethx.get("link", None))
205         if elink:
206             ethx["link"] = elink
207         aip = iopts.get("ipv4", iopts.get("ip", None))
208         if aip:
209             ethx["ipv4"] = aip
210         nm = iopts.get("netmask", "")
211         if nm:
212             ethx["ipv4"] += "/{}".format(nm)
213         for i in ("mac", "hwaddr"):
214             if i in iopts:
215                 ethx["mac"] = iopts[i]
216                 break
217         if "mac" not in ethx:
218             ethx["mac"] = salt.utils.network.gen_mac()
219     gw = None
220     for ethx in [a for a in nic_opts]:
221         ndata = nic_opts[ethx]
222         if gw:
223             ndata.pop("gateway", None)
224         if "gateway" in ndata:
225             gw = ndata["gateway"]
226             gateway = None
227     if bridge:
228         eth0["link"] = bridge
229     if gateway:
230         eth0["gateway"] = gateway
231     lxc_init_interface = {}
232     lxc_init_interface["name"] = name
233     lxc_init_interface["config"] = config
234     lxc_init_interface["memory"] = _cloud_get("memory", 0)  # nolimit
235     lxc_init_interface["pub_key"] = pub_key
236     lxc_init_interface["priv_key"] = priv_key
237     lxc_init_interface["nic_opts"] = nic_opts
238     for clone_from in ["clone_from", "clone", "from_container"]:
239         lxc_init_interface["clone_from"] = _cloud_get(clone_from, None)
240         if lxc_init_interface["clone_from"] is not None:
241             break
242     lxc_init_interface["profile"] = profile
243     lxc_init_interface["snapshot"] = snapshot
244     lxc_init_interface["dnsservers"] = dnsservers
245     lxc_init_interface["fstype"] = fstype
246     lxc_init_interface["path"] = path
247     lxc_init_interface["vgname"] = vgname
248     lxc_init_interface["size"] = size
249     lxc_init_interface["lvname"] = lvname
250     lxc_init_interface["thinpool"] = thinpool
251     lxc_init_interface["force_install"] = force_install
252     lxc_init_interface["unconditional_install"] = unconditional_install
253     lxc_init_interface["bootstrap_url"] = script
254     lxc_init_interface["bootstrap_args"] = script_args
255     lxc_init_interface["bootstrap_shell"] = _cloud_get("bootstrap_shell", "sh")
256     lxc_init_interface["bootstrap_delay"] = _cloud_get("bootstrap_delay", None)
257     lxc_init_interface["autostart"] = autostart
258     lxc_init_interface["users"] = users
259     lxc_init_interface["password"] = password
260     lxc_init_interface["password_encrypted"] = password_encrypted
261     lxc_init_interface["network_profile"] = network_profile
262     for i in ["cpu", "cpuset", "cpushare"]:
263         if _cloud_get(i, None):
264             try:
265                 lxc_init_interface[i] = vm_[i]
266             except KeyError:
267                 lxc_init_interface[i] = profile[i]
268     return lxc_init_interface
269 def _get_profile(key, name, **kwargs):
270     if isinstance(name, dict):
271         profilename = name.pop("name", None)
272         return _get_profile(key, profilename, **name)
273     if name is None:
274         profile_match = {}
275     else:
276         profile_match = __salt__["config.get"](
277             "lxc.{1}:{0}".format(name, key), default=None, merge="recurse"
278         )
279         if profile_match is None:
280             profile_match = {}
281     if not isinstance(profile_match, dict):
282         raise CommandExecutionError("lxc.{} must be a dictionary".format(key))
283     overrides = salt.utils.args.clean_kwargs(**copy.deepcopy(kwargs))
284     profile_match = salt.utils.dictupdate.update(
285         copy.deepcopy(profile_match), overrides
286     )
287     return profile_match
288 def get_container_profile(name=None, **kwargs):
289     profile = _get_profile("container_profile", name, **kwargs)
290     return profile
291 def get_network_profile(name=None, **kwargs):
292     profile = _get_profile("network_profile", name, **kwargs)
293     return profile
294 def _rand_cpu_str(cpu):
295     cpu = int(cpu)
296     avail = __salt__["status.nproc"]()
297     if cpu &lt; avail:
298         return "0-{}".format(avail)
299     to_set = set()
300     while len(to_set) &lt; cpu:
301         choice = random.randint(0, avail - 1)
302         if choice not in to_set:
303             to_set.add(str(choice))
304     return ",".join(sorted(to_set))
305 def _network_conf(conf_tuples=None, **kwargs):
306     nic = kwargs.get("network_profile", None)
307     ret = []
308     nic_opts = kwargs.get("nic_opts", {})
309     if nic_opts is None:
310         nic_opts = {}
311     if not conf_tuples:
312         conf_tuples = []
313     old = _get_veths(conf_tuples)
314     if not old:
315         old = {}
316     if nic and isinstance(nic, ((str,), dict)):
317         nicp = get_network_profile(nic)
318     else:
319         nicp = {}
320     if DEFAULT_NIC not in nicp:
321         nicp[DEFAULT_NIC] = {}
322     kwargs = copy.deepcopy(kwargs)
323     gateway = kwargs.pop("gateway", None)
324     bridge = kwargs.get("bridge", None)
325     if nic_opts:
326         for dev, args in nic_opts.items():
327             ethx = nicp.setdefault(dev, {})
328             try:
329                 ethx = salt.utils.dictupdate.update(ethx, args)
330             except AttributeError:
331                 raise SaltInvocationError("Invalid nic_opts configuration")
332     ifs = [a for a in nicp]
333     ifs += [a for a in old if a not in nicp]
334     ifs.sort()
335     gateway_set = False
336     for dev in ifs:
337         args = nicp.get(dev, {})
338         opts = nic_opts.get(dev, {}) if nic_opts else {}
339         old_if = old.get(dev, {})
340         disable = opts.get("disable", args.get("disable", False))
341         if disable:
342             continue
343         mac = opts.get(
344             "mac", opts.get("hwaddr", args.get("mac", args.get("hwaddr", "")))
345         )
346         type_ = opts.get("type", args.get("type", ""))
347         flags = opts.get("flags", args.get("flags", ""))
348         link = opts.get("link", args.get("link", ""))
349         ipv4 = opts.get("ipv4", args.get("ipv4", ""))
350         ipv6 = opts.get("ipv6", args.get("ipv6", ""))
351         infos = salt.utils.odict.OrderedDict(
352             [
353                 (
354                     "lxc.network.type",
355                     {
356                         "test": not type_,
357                         "value": type_,
358                         "old": old_if.get("lxc.network.type"),
359                         "default": "veth",
360                     },
361                 ),
362                 (
363                     "lxc.network.name",
364                     {"test": False, "value": dev, "old": dev, "default": dev},
365                 ),
366                 (
367                     "lxc.network.flags",
368                     {
369                         "test": not flags,
370                         "value": flags,
371                         "old": old_if.get("lxc.network.flags"),
372                         "default": "up",
373                     },
374                 ),
375                 (
376                     "lxc.network.link",
377                     {
378                         "test": not link,
379                         "value": link,
380                         "old": old_if.get("lxc.network.link"),
381                         "default": search_lxc_bridge(),
382                     },
383                 ),
384                 (
385                     "lxc.network.hwaddr",
386                     {
387                         "test": not mac,
388                         "value": mac,
389                         "old": old_if.get("lxc.network.hwaddr"),
390                         "default": salt.utils.network.gen_mac(),
391                     },
392                 ),
393                 (
394                     "lxc.network.ipv4",
395                     {
396                         "test": not ipv4,
397                         "value": ipv4,
398                         "old": old_if.get("lxc.network.ipv4", ""),
399                         "default": None,
400                     },
401                 ),
402                 (
403                     "lxc.network.ipv6",
404                     {
405                         "test": not ipv6,
406                         "value": ipv6,
407                         "old": old_if.get("lxc.network.ipv6", ""),
408                         "default": None,
409                     },
410                 ),
411             ]
412         )
413         for info in list(infos.keys()):
414             bundle = infos[info]
415             if bundle["test"]:
416                 if bundle["old"]:
417                     bundle["value"] = bundle["old"]
418                 elif bundle["default"]:
419                     bundle["value"] = bundle["default"]
420         for info, data in infos.items():
421             if data["value"]:
422                 ret.append({info: data["value"]})
423         for key, val in args.items():
424             if key == "link" and bridge:
425                 val = bridge
426             val = opts.get(key, val)
427             if key in [
428                 "type",
429                 "flags",
430                 "name",
431                 "gateway",
432                 "mac",
433                 "link",
434                 "ipv4",
435                 "ipv6",
436             ]:
437                 continue
438             ret.append({"lxc.network.{}".format(key): val})
439         if not gateway:
440             gateway = args.get("gateway", None)
441         if gateway is not None and not gateway_set:
442             ret.append({"lxc.network.ipv4.gateway": gateway})
443             gateway_set = True
444     if gateway is not None and not gateway_set:
445         ret.append({"lxc.network.ipv4.gateway": gateway})
446         gateway_set = True
447     new = _get_veths(ret)
448     for iface in [a for a in new]:
449         ndata = new[iface]
450         nmac = ndata.get("lxc.network.hwaddr", "")
451         ntype = ndata.get("lxc.network.type", "")
452         omac, otype = "", ""
453         if iface in old:
454             odata = old[iface]
455             omac = odata.get("lxc.network.hwaddr", "")
456             otype = odata.get("lxc.network.type", "")
457         if otype and not ntype:
458             ntype = otype
459         if not ntype:
460             ntype = "veth"
461         new[iface]["lxc.network.type"] = ntype
462         if omac and not nmac:
463             new[iface]["lxc.network.hwaddr"] = omac
464     ret = []
465     for val in new.values():
466         for row in val:
467             ret.append(salt.utils.odict.OrderedDict([(row, val[row])]))
468     if (
469         _LooseVersion(version()) &lt;= _LooseVersion("1.0.7")
470         and True not in ["lxc.network.ipv4.gateway" in a for a in ret]
471         and True in ["lxc.network.ipv4" in a for a in ret]
472     ):
473         ret.append({"lxc.network.ipv4.gateway": "auto"})
474     return ret
475 def _get_lxc_default_data(**kwargs):
476     kwargs = copy.deepcopy(kwargs)
477     ret = {}
478     for k in ["utsname", "rootfs"]:
479         val = kwargs.get(k, None)
480         if val is not None:
481             ret["lxc.{}".format(k)] = val
482     autostart = kwargs.get("autostart")
483     if autostart is None:
484         autostart = True
485     if autostart != "keep":
486         if autostart:
487             ret["lxc.start.auto"] = "1"
488         else:
489             ret["lxc.start.auto"] = "0"
490     memory = kwargs.get("memory")
491     if memory is not None:
492         ret["lxc.cgroup.memory.limit_in_bytes"] = memory * 1024 * 1024
493     cpuset = kwargs.get("cpuset")
494     if cpuset:
495         ret["lxc.cgroup.cpuset.cpus"] = cpuset
496     cpushare = kwargs.get("cpushare")
497     cpu = kwargs.get("cpu")
498     if cpushare:
499         ret["lxc.cgroup.cpu.shares"] = cpushare
500     if cpu and not cpuset:
501         ret["lxc.cgroup.cpuset.cpus"] = _rand_cpu_str(cpu)
502     return ret
503 def _config_list(conf_tuples=None, only_net=False, **kwargs):
504     only_net = bool(only_net)
505     if not conf_tuples:
506         conf_tuples = []
507     kwargs = copy.deepcopy(kwargs)
508     ret = []
509     if not only_net:
510         default_data = _get_lxc_default_data(**kwargs)
511         for k, val in default_data.items():
512             ret.append({k: val})
513     net_datas = _network_conf(conf_tuples=conf_tuples, **kwargs)
514     ret.extend(net_datas)
515     return ret
516 def _get_veths(net_data):
517     if isinstance(net_data, dict):
518         net_data = list(net_data.items())
519     nics = salt.utils.odict.OrderedDict()
520     current_nic = salt.utils.odict.OrderedDict()
521     no_names = True
522     for item in net_data:
523         if item and isinstance(item, dict):
524             item = list(item.items())[0]
525         elif isinstance(item, str):
526             sitem = item.strip()
527             if sitem.startswith("#") or not sitem:
528                 continue
529             elif "=" in item:
530                 item = tuple(a.strip() for a in item.split("=", 1))
531         if item[0] == "lxc.network.type":
532             current_nic = salt.utils.odict.OrderedDict()
533         if item[0] == "lxc.network.name":
534             no_names = False
535             nics[item[1].strip()] = current_nic
536         current_nic[item[0].strip()] = item[1].strip()
537     if no_names and current_nic:
538         nics[DEFAULT_NIC] = current_nic
539     return nics
540 class _LXCConfig:
541     pattern = re.compile(r"^(\S+)(\s*)(=)(\s*)(.*)")
542     non_interpretable_pattern = re.compile(r"^((#.*)|(\s*))$")
543     def __init__(self, **kwargs):
544         kwargs = copy.deepcopy(kwargs)
545         self.name = kwargs.pop("name", None)
546         path = get_root_path(kwargs.get("path", None))
547         self.data = []
548         if self.name:
549             self.path = os.path.join(path, self.name, "config")
550             if os.path.isfile(self.path):
551                 with salt.utils.files.fopen(self.path) as fhr:
552                     for line in salt.utils.data.decode(fhr.readlines()):
553                         match = self.pattern.findall(line.strip())
554                         if match:
555                             self.data.append((match[0][0], match[0][-1]))
556                         match = self.non_interpretable_pattern.findall(line.strip())
557                         if match:
558                             self.data.append(("", match[0][0]))
559         else:
560             self.path = None
561         def _replace(key, val):
562             if val:
563                 self._filter_data(key)
564                 self.data.append((key, val))
565         default_data = _get_lxc_default_data(**kwargs)
566         for key, val in default_data.items():
567             _replace(key, val)
568         old_net = self._filter_data("lxc.network")
569         net_datas = _network_conf(conf_tuples=old_net, **kwargs)
570         if net_datas:
571             for row in net_datas:
572                 self.data.extend(list(row.items()))
573         for idx in ["lxc.cgroup.memory.limit_in_bytes"]:
574             if not default_data.get(idx):
575                 self._filter_data(idx)
576     def as_string(self):
577         chunks = (
578             "{0[0]}{1}{0[1]}".format(item, (" = " if item[0] else ""))
579             for item in self.data
580         )
581         return "\n".join(chunks) + "\n"
582     def write(self):
583         if self.path:
584             with salt<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(self.path, "w") as fic:
585                 fic.write(salt.utils.stringutils.to_str(content))
586                 fic.</b></font>flush()
587     def tempfile(self):
588         ntf = tempfile.NamedTemporaryFile()
589         ntf.write(self.as_string())
590         ntf.flush()
591         return ntf
592     def _filter_data(self, pattern):
593         removed = []
594         filtered = []
595         for param in self.data:
596             if not param[0].startswith(pattern):
597                 filtered.append(param)
598             else:
599                 removed.append(param)
600         self.data = filtered
601         return removed
602 def _get_base(**kwargs):
603     profile = get_container_profile(copy.deepcopy(kwargs.get("profile")))
604     kw_overrides = copy.deepcopy(kwargs)
605     def select(key, default=None):
606         kw_overrides_match = kw_overrides.pop(key, _marker)
607         profile_match = profile.pop(key, default)
608         if kw_overrides_match is _marker:
609             return profile_match
610         return kw_overrides_match
611     template = select("template")
612     image = select("image")
613     vgname = select("vgname")
614     path = kwargs.get("path", None)
615     for param in ("path", "image", "vgname", "template"):
616         kwargs.pop(param, None)
617     if image:
618         proto = urllib.parse.urlparse(image).scheme
619         img_tar = __salt__["cp.cache_file"](image)
620         img_name = os.path.basename(img_tar)
621         hash_ = salt.utils.hashutils.get_hash(
622             img_tar, __salt__["config.get"]("hash_type")
623         )
624         name = "__base_{}_{}_{}".format(proto, img_name, hash_)
625         if not exists(name, path=path):
626             create(
627                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
628             )
629             if vgname:
630                 rootfs = os.path.join("/dev", vgname, name)
631                 edit_conf(
632                     info(name, path=path)["config"],
633                     out_format="commented",
634                     **{"lxc.rootfs": rootfs}
635                 )
636         return name
637     elif template:
638         name = "__base_{}".format(template)
639         if not exists(name, path=path):
640             create(
641                 name, template=template, image=image, path=path, vgname=vgname, **kwargs
642             )
643             if vgname:
644                 rootfs = os.path.join("/dev", vgname, name)
645                 edit_conf(
646                     info(name, path=path)["config"],
647                     out_format="commented",
648                     **{"lxc.rootfs": rootfs}
649                 )
650         return name
651     return ""
652 def init(
653     name,
654     config=None,
655     cpuset=None,
656     cpushare=None,
657     memory=None,
658     profile=None,
659     network_profile=None,
660     nic_opts=None,
661     cpu=None,
662     autostart=True,
663     password=None,
664     password_encrypted=None,
665     users=None,
666     dnsservers=None,
667     searchdomains=None,
668     bridge=None,
669     gateway=None,
670     pub_key=None,
671     priv_key=None,
672     force_install=False,
673     unconditional_install=False,
674     bootstrap_delay=None,
675     bootstrap_args=None,
676     bootstrap_shell=None,
677     bootstrap_url=None,
678     **kwargs
679 ):
680     ret = {"name": name, "changes": {}}
681     profile = get_container_profile(copy.deepcopy(profile))
682     if not network_profile:
683         network_profile = profile.get("network_profile")
684     if not network_profile:
685         network_profile = DEFAULT_NIC
686     changes_dict = {"init": []}
687     changes = changes_dict.get("init")
688     if users is None:
689         users = []
690     dusers = ["root"]
691     for user in dusers:
692         if user not in users:
693             users.append(user)
694     kw_overrides = copy.deepcopy(kwargs)
695     def select(key, default=None):
696         kw_overrides_match = kw_overrides.pop(key, _marker)
697         profile_match = profile.pop(key, default)
698         if kw_overrides_match is _marker:
699             return profile_match
700         return kw_overrides_match
701     path = select("path")
702     bpath = get_root_path(path)
703     state_pre = state(name, path=path)
704     tvg = select("vgname")
705     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
706     start_ = select("start", True)
707     autostart = select("autostart", autostart)
708     seed = select("seed", True)
709     install = select("install", True)
710     seed_cmd = select("seed_cmd")
711     salt_config = _get_salt_config(config, **kwargs)
712     approve_key = select("approve_key", True)
713     clone_from = select("clone_from")
714     if vgname and not clone_from:
715         try:
716             kwargs["vgname"] = vgname
717             clone_from = _get_base(profile=profile, **kwargs)
718         except (SaltInvocationError, CommandExecutionError) as exc:
719             ret["comment"] = exc.strerror
720             if changes:
721                 ret["changes"] = changes_dict
722             return ret
723         if not kwargs.get("snapshot") is False:
724             kwargs["snapshot"] = True
725     does_exist = exists(name, path=path)
726     to_reboot = False
727     remove_seed_marker = False
728     if does_exist:
729         pass
730     elif clone_from:
731         remove_seed_marker = True
732         try:
733             clone(name, clone_from, profile=profile, **kwargs)
734             changes.append({"create": "Container cloned"})
735         except (SaltInvocationError, CommandExecutionError) as exc:
736             if "already exists" in exc.strerror:
737                 changes.append({"create": "Container already exists"})
738             else:
739                 ret["result"] = False
740                 ret["comment"] = exc.strerror
741                 if changes:
742                     ret["changes"] = changes_dict
743                 return ret
744         cfg = _LXCConfig(
745             name=name,
746             network_profile=network_profile,
747             nic_opts=nic_opts,
748             bridge=bridge,
749             path=path,
750             gateway=gateway,
751             autostart=autostart,
752             cpuset=cpuset,
753             cpushare=cpushare,
754             memory=memory,
755         )
756         old_chunks = read_conf(cfg.path, out_format="commented")
757         cfg.write()
758         chunks = read_conf(cfg.path, out_format="commented")
759         if old_chunks != chunks:
760             to_reboot = True
761     else:
762         remove_seed_marker = True
763         cfg = _LXCConfig(
764             network_profile=network_profile,
765             nic_opts=nic_opts,
766             cpuset=cpuset,
767             path=path,
768             bridge=bridge,
769             gateway=gateway,
770             autostart=autostart,
771             cpushare=cpushare,
772             memory=memory,
773         )
774         with cfg.tempfile() as cfile:
775             try:
776                 create(name, config=cfile.name, profile=profile, **kwargs)
777                 changes.append({"create": "Container created"})
778             except (SaltInvocationError, CommandExecutionError) as exc:
779                 if "already exists" in exc.strerror:
780                     changes.append({"create": "Container already exists"})
781                 else:
782                     ret["comment"] = exc.strerror
783                     if changes:
784                         ret["changes"] = changes_dict
785                     return ret
786         cpath = os.path.join(bpath, name, "config")
787         old_chunks = []
788         if os.path.exists(cpath):
789             old_chunks = read_conf(cpath, out_format="commented")
790         new_cfg = _config_list(
791             conf_tuples=old_chunks,
792             cpu=cpu,
793             network_profile=network_profile,
794             nic_opts=nic_opts,
795             bridge=bridge,
796             cpuset=cpuset,
797             cpushare=cpushare,
798             memory=memory,
799         )
800         if new_cfg:
801             edit_conf(cpath, out_format="commented", lxc_config=new_cfg)
802         chunks = read_conf(cpath, out_format="commented")
803         if old_chunks != chunks:
804             to_reboot = True
805     cfg = _LXCConfig(
806         name=name,
807         network_profile=network_profile,
808         nic_opts=nic_opts,
809         bridge=bridge,
810         path=path,
811         gateway=gateway,
812         autostart=autostart,
813         cpuset=cpuset,
814         cpushare=cpushare,
815         memory=memory,
816     )
817     old_chunks = []
818     if os.path.exists(cfg.path):
819         old_chunks = read_conf(cfg.path, out_format="commented")
820     cfg.write()
821     chunks = read_conf(cfg.path, out_format="commented")
822     if old_chunks != chunks:
823         changes.append({"config": "Container configuration updated"})
824         to_reboot = True
825     if to_reboot:
826         try:
827             stop(name, path=path)
828         except (SaltInvocationError, CommandExecutionError) as exc:
829             ret["comment"] = "Unable to stop container: {}".format(exc)
830             if changes:
831                 ret["changes"] = changes_dict
832             return ret
833     if not does_exist or (does_exist and state(name, path=path) != "running"):
834         try:
835             start(name, path=path)
836         except (SaltInvocationError, CommandExecutionError) as exc:
837             ret["comment"] = "Unable to stop container: {}".format(exc)
838             if changes:
839                 ret["changes"] = changes_dict
840             return ret
841     if remove_seed_marker:
842         run(
843             name,
844             "rm -f '{}'".format(SEED_MARKER),
845             path=path,
846             chroot_fallback=False,
847             python_shell=False,
848         )
849     if ret.get("result", True) and password:
850         gid = "/.lxc.initial_pass"
851         gids = [gid, "/lxc.initial_pass", "/.lxc.{}.initial_pass".format(name)]
852         if not any(
853             retcode(
854                 name,
855                 'test -e "{}"'.format(x),
856                 chroot_fallback=True,
857                 path=path,
858                 ignore_retcode=True,
859             )
860             == 0
861             for x in gids
862         ):
863             for default_user in ["ubuntu"]:
864                 if (
865                     default_user not in users
866                     and retcode(
867                         name,
868                         "id {}".format(default_user),
869                         python_shell=False,
870                         path=path,
871                         chroot_fallback=True,
872                         ignore_retcode=True,
873                     )
874                     == 0
875                 ):
876                     users.append(default_user)
877             for user in users:
878                 try:
879                     cret = set_password(
880                         name,
881                         users=[user],
882                         path=path,
883                         password=password,
884                         encrypted=password_encrypted,
885                     )
886                 except (SaltInvocationError, CommandExecutionError) as exc:
887                     msg = "{}: Failed to set password".format(user) + exc.strerror
888                     if user == "root":
889                         ret["comment"] = msg
890                         ret["result"] = False
891                     else:
892                         log.debug(msg)
893             if ret.get("result", True):
894                 changes.append({"password": "Password(s) updated"})
895                 if (
896                     retcode(
897                         name,
898                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
899                         path=path,
900                         chroot_fallback=True,
901                         ignore_retcode=True,
902                     )
903                     != 0
904                 ):
905                     ret["comment"] = "Failed to set password marker"
906                     changes[-1]["password"] += ". " + ret["comment"] + "."
907                     ret["result"] = False
908     if ret.get("result", True) and dnsservers:
909         gid = "/.lxc.initial_dns"
910         gids = [gid, "/lxc.initial_dns", "/lxc.{}.initial_dns".format(name)]
911         if not any(
912             retcode(
913                 name,
914                 'test -e "{}"'.format(x),
915                 chroot_fallback=True,
916                 path=path,
917                 ignore_retcode=True,
918             )
919             == 0
920             for x in gids
921         ):
922             try:
923                 set_dns(
924                     name, path=path, dnsservers=dnsservers, searchdomains=searchdomains
925                 )
926             except (SaltInvocationError, CommandExecutionError) as exc:
927                 ret["comment"] = "Failed to set DNS: " + exc.strerror
928                 ret["result"] = False
929             else:
930                 changes.append({"dns": "DNS updated"})
931                 if (
932                     retcode(
933                         name,
934                         'sh -c \'touch "{0}"; test -e "{0}"\''.format(gid),
935                         chroot_fallback=True,
936                         path=path,
937                         ignore_retcode=True,
938                     )
939                     != 0
940                 ):
941                     ret["comment"] = "Failed to set DNS marker"
942                     changes[-1]["dns"] += ". " + ret["comment"] + "."
943                     ret["result"] = False
944     if remove_seed_marker:
945         run(name, "rm -f '{}'".format(SEED_MARKER), path=path, python_shell=False)
946     gid = "/.lxc.initial_seed"
947     gids = [gid, "/lxc.initial_seed"]
948     if (
949         any(
950             retcode(
951                 name,
952                 "test -e {}".format(x),
953                 path=path,
954                 chroot_fallback=True,
955                 ignore_retcode=True,
956             )
957             == 0
958             for x in gids
959         )
960         or not ret.get("result", True)
961     ):
962         pass
963     elif seed or seed_cmd:
964         if seed:
965             try:
966                 result = bootstrap(
967                     name,
968                     config=salt_config,
969                     path=path,
970                     approve_key=approve_key,
971                     pub_key=pub_key,
972                     priv_key=priv_key,
973                     install=install,
974                     force_install=force_install,
975                     unconditional_install=unconditional_install,
976                     bootstrap_delay=bootstrap_delay,
977                     bootstrap_url=bootstrap_url,
978                     bootstrap_shell=bootstrap_shell,
979                     bootstrap_args=bootstrap_args,
980                 )
981             except (SaltInvocationError, CommandExecutionError) as exc:
982                 ret["comment"] = "Bootstrap failed: " + exc.strerror
983                 ret["result"] = False
984             else:
985                 if not result:
986                     ret[
987                         "comment"
988                     ] = "Bootstrap failed, see minion log for more information"
989                     ret["result"] = False
990                 else:
991                     changes.append({"bootstrap": "Container successfully bootstrapped"})
992         elif seed_cmd:
993             try:
994                 result = __salt__[seed_cmd](
995                     info(name, path=path)["rootfs"], name, salt_config
996                 )
997             except (SaltInvocationError, CommandExecutionError) as exc:
998                 ret["comment"] = "Bootstrap via seed_cmd '{}' failed: {}".format(
999                     seed_cmd, exc.strerror
1000                 )
1001                 ret["result"] = False
1002             else:
1003                 if not result:
1004                     ret["comment"] = (
1005                         "Bootstrap via seed_cmd '{}' failed, "
1006                         "see minion log for more information ".format(seed_cmd)
1007                     )
1008                     ret["result"] = False
1009                 else:
1010                     changes.append(
1011                         {
1012                             "bootstrap": (
1013                                 "Container successfully bootstrapped "
1014                                 "using seed_cmd '{}'".format(seed_cmd)
1015                             )
1016                         }
1017                     )
1018     if ret.get("result", True) and not start_:
1019         try:
1020             stop(name, path=path)
1021         except (SaltInvocationError, CommandExecutionError) as exc:
1022             ret["comment"] = "Unable to stop container: {}".format(exc)
1023             ret["result"] = False
1024     state_post = state(name, path=path)
1025     if state_pre != state_post:
1026         changes.append({"state": {"old": state_pre, "new": state_post}})
1027     if ret.get("result", True):
1028         ret["comment"] = "Container '{}' successfully initialized".format(name)
1029         ret["result"] = True
1030     if changes:
1031         ret["changes"] = changes_dict
1032     return ret
1033 def cloud_init(name, vm_=None, **kwargs):
1034     init_interface = cloud_init_interface(name, vm_, **kwargs)
1035     name = init_interface.pop("name", name)
1036     return init(name, **init_interface)
1037 def images(dist=None):
1038     out = __salt__["cmd.run_stdout"](
1039         "lxc-create -n __imgcheck -t download -- --list", ignore_retcode=True
1040     )
1041     if "DIST" not in out:
1042         raise CommandExecutionError(
1043             "Unable to run the 'download' template script. Is it installed?"
1044         )
1045     ret = {}
1046     passed_header = False
1047     for line in out.splitlines():
1048         try:
1049             distro, release, arch, variant, build_time = line.split()
1050         except ValueError:
1051             continue
1052         if not passed_header:
1053             if distro == "DIST":
1054                 passed_header = True
1055             continue
1056         dist_list = ret.setdefault(distro, [])
1057         dist_list.append(
1058             {
1059                 "release": release,
1060                 "arch": arch,
1061                 "variant": variant,
1062                 "build_time": build_time,
1063             }
1064         )
1065     if dist is not None:
1066         return dict([(dist, ret.get(dist, []))])
1067     return ret
1068 def templates():
1069     try:
1070         template_scripts = os.listdir("/usr/share/lxc/templates")
1071     except OSError:
1072         return []
1073     else:
1074         return [x[4:] for x in template_scripts if x.startswith("lxc-")]
1075 def _after_ignition_network_profile(cmd, ret, name, network_profile, path, nic_opts):
1076     _clear_context()
1077     if ret["retcode"] == 0 and exists(name, path=path):
1078         if network_profile:
1079             network_changes = apply_network_profile(
1080                 name, network_profile, path=path, nic_opts=nic_opts
1081             )
1082             if network_changes:
1083                 log.info(
1084                     "Network changes from applying network profile '%s' "
1085                     "to newly-created container '%s':\n%s",
1086                     network_profile,
1087                     name,
1088                     network_changes,
1089                 )
1090         c_state = state(name, path=path)
1091         return {"result": True, "state": {"old": None, "new": c_state}}
1092     else:
1093         if exists(name, path=path):
1094             cmd = "lxc-destroy"
1095             if path:
1096                 cmd += " -P {}".format(pipes.quote(path))
1097             cmd += " -n {}".format(name)
1098             __salt__["cmd.retcode"](cmd, python_shell=False)
1099         raise CommandExecutionError(
1100             "Container could not be created with cmd '{}': {}".format(
1101                 cmd, ret["stderr"]
1102             )
1103         )
1104 def create(
1105     name, config=None, profile=None, network_profile=None, nic_opts=None, **kwargs
1106 ):
1107     download_template_deps = ("dist", "release", "arch")
1108     cmd = "lxc-create -n {}".format(name)
1109     profile = get_container_profile(copy.deepcopy(profile))
1110     kw_overrides = copy.deepcopy(kwargs)
1111     def select(key, default=None):
1112         kw_overrides_match = kw_overrides.pop(key, None)
1113         profile_match = profile.pop(key, default)
1114         if kw_overrides_match is None:
1115             return profile_match
1116         return kw_overrides_match
1117     path = select("path")
1118     if exists(name, path=path):
1119         raise CommandExecutionError("Container '{}' already exists".format(name))
1120     tvg = select("vgname")
1121     vgname = tvg if tvg else __salt__["config.get"]("lxc.vgname")
1122     template = select("template")
1123     image = select("image")
1124     if template and image:
1125         raise SaltInvocationError("Only one of 'template' and 'image' is permitted")
1126     elif not any((template, image, profile)):
1127         raise SaltInvocationError(
1128             "At least one of 'template', 'image', and 'profile' is required"
1129         )
1130     options = select("options") or {}
1131     backing = select("backing")
1132     if vgname and not backing:
1133         backing = "lvm"
1134     lvname = select("lvname")
1135     thinpool = select("thinpool")
1136     fstype = select("fstype")
1137     size = select("size", "1G")
1138     zfsroot = select("zfsroot")
1139     if backing in ("dir", "overlayfs", "btrfs", "zfs"):
1140         fstype = None
1141         size = None
1142     if backing in ("aufs", "dir", "overlayfs", "btrfs"):
1143         lvname = vgname = thinpool = None
1144     if image:
1145         img_tar = __salt__["cp.cache_file"](image)
1146         template = os.path.join(
1147             os.path.dirname(salt.__file__), "templates", "lxc", "salt_tarball"
1148         )
1149         options["imgtar"] = img_tar
1150     if path:
1151         cmd += " -P {}".format(pipes.quote(path))
1152         if not os.path.exists(path):
1153             os.makedirs(path)
1154     if config:
1155         cmd += " -f {}".format(config)
1156     if template:
1157         cmd += " -t {}".format(template)
1158     if backing:
1159         backing = backing.lower()
1160         cmd += " -B {}".format(backing)
1161         if backing in ("zfs",):
1162             if zfsroot:
1163                 cmd += " --zfsroot {}".format(zfsroot)
1164         if backing in ("lvm",):
1165             if lvname:
1166                 cmd += " --lvname {}".format(lvname)
1167             if vgname:
1168                 cmd += " --vgname {}".format(vgname)
1169             if thinpool:
1170                 cmd += " --thinpool {}".format(thinpool)
1171         if backing not in ("dir", "overlayfs"):
1172             if fstype:
1173                 cmd += " --fstype {}".format(fstype)
1174             if size:
1175                 cmd += " --fssize {}".format(size)
1176     if options:
1177         if template == "download":
1178             missing_deps = [x for x in download_template_deps if x not in options]
1179             if missing_deps:
1180                 raise SaltInvocationError(
1181                     "Missing params in 'options' dict: {}".format(
1182                         ", ".join(missing_deps)
1183                     )
1184                 )
1185         cmd += " --"
1186         for key, val in options.items():
1187             cmd += " --{} {}".format(key, val)
1188     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1189     return _after_ignition_network_profile(
1190         cmd, ret, name, network_profile, path, nic_opts
1191     )
1192 def clone(name, orig, profile=None, network_profile=None, nic_opts=None, **kwargs):
1193     profile = get_container_profile(copy.deepcopy(profile))
1194     kw_overrides = copy.deepcopy(kwargs)
1195     def select(key, default=None):
1196         kw_overrides_match = kw_overrides.pop(key, None)
1197         profile_match = profile.pop(key, default)
1198         if kw_overrides_match is None:
1199             return profile_match
1200         return kw_overrides_match
1201     path = select("path")
1202     if exists(name, path=path):
1203         raise CommandExecutionError("Container '{}' already exists".format(name))
1204     _ensure_exists(orig, path=path)
1205     if state(orig, path=path) != "stopped":
1206         raise CommandExecutionError(
1207             "Container '{}' must be stopped to be cloned".format(orig)
1208         )
1209     backing = select("backing")
1210     snapshot = select("snapshot")
1211     if backing in ("dir",):
1212         snapshot = False
1213     if not snapshot:
1214         snapshot = ""
1215     else:
1216         snapshot = "-s"
1217     size = select("size", "1G")
1218     if backing in ("dir", "overlayfs", "btrfs"):
1219         size = None
1220     if _LooseVersion(version()) &gt;= _LooseVersion("2.0"):
1221         cmd = "lxc-copy"
1222         cmd += " {} -n {} -N {}".format(snapshot, orig, name)
1223     else:
1224         cmd = "lxc-clone"
1225         cmd += " {} -o {} -n {}".format(snapshot, orig, name)
1226     if path:
1227         cmd += " -P {}".format(pipes.quote(path))
1228         if not os.path.exists(path):
1229             os.makedirs(path)
1230     if backing:
1231         backing = backing.lower()
1232         cmd += " -B {}".format(backing)
1233         if backing not in ("dir", "overlayfs"):
1234             if size:
1235                 cmd += " -L {}".format(size)
1236     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1237     return _after_ignition_network_profile(
1238         cmd, ret, name, network_profile, path, nic_opts
1239     )
1240 def ls_(active=None, cache=True, path=None):
1241     contextvar = "lxc.ls{}".format(path)
1242     if active:
1243         contextvar += ".active"
1244     if cache and (contextvar in __context__):
1245         return __context__[contextvar]
1246     else:
1247         ret = []
1248         cmd = "lxc-ls"
1249         if path:
1250             cmd += " -P {}".format(pipes.quote(path))
1251         if active:
1252             cmd += " --active"
1253         output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
1254         for line in output.splitlines():
1255             ret.extend(line.split())
1256         __context__[contextvar] = ret
1257         return ret
1258 def list_(extra=False, limit=None, path=None):
1259     ctnrs = ls_(path=path)
1260     if extra:
1261         stopped = {}
1262         frozen = {}
1263         running = {}
1264     else:
1265         stopped = []
1266         frozen = []
1267         running = []
1268     ret = {"running": running, "stopped": stopped, "frozen": frozen}
1269     for container in ctnrs:
1270         cmd = "lxc-info"
1271         if path:
1272             cmd += " -P {}".format(pipes.quote(path))
1273         cmd += " -n {}".format(container)
1274         c_info = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="debug")
1275         c_state = None
1276         for line in c_info.splitlines():
1277             stat = line.split(":")
1278             if stat[0] in ("State", "state"):
1279                 c_state = stat[1].strip()
1280                 break
1281         if not c_state or (limit is not None and c_state.lower() != limit):
1282             continue
1283         if extra:
1284             infos = info(container, path=path)
1285             method = "update"
1286             value = {container: infos}
1287         else:
1288             method = "append"
1289             value = container
1290         if c_state == "STOPPED":
1291             getattr(stopped, method)(value)
1292             continue
1293         if c_state == "FROZEN":
1294             getattr(frozen, method)(value)
1295             continue
1296         if c_state == "RUNNING":
1297             getattr(running, method)(value)
1298             continue
1299     if limit is not None:
1300         return ret.get(limit, {} if extra else [])
1301     return ret
1302 def _change_state(
1303     cmd,
1304     name,
1305     expected,
1306     stdin=_marker,
1307     stdout=_marker,
1308     stderr=_marker,
1309     with_communicate=_marker,
1310     use_vt=_marker,
1311     path=None,
1312 ):
1313     pre = state(name, path=path)
1314     if pre == expected:
1315         return {
1316             "result": True,
1317             "state": {"old": expected, "new": expected},
1318             "comment": "Container '{}' already {}".format(name, expected),
1319         }
1320     if cmd == "lxc-destroy":
1321         scmd = "lxc-stop"
1322         if path:
1323             scmd += " -P {}".format(pipes.quote(path))
1324         scmd += " -k -n {}".format(name)
1325         __salt__["cmd.run"](scmd, python_shell=False)
1326     if path and " -P " not in cmd:
1327         cmd += " -P {}".format(pipes.quote(path))
1328     cmd += " -n {}".format(name)
1329     pkwargs = {
1330         "python_shell": False,
1331         "redirect_stderr": True,
1332         "with_communicate": with_communicate,
1333         "use_vt": use_vt,
1334         "stdin": stdin,
1335         "stdout": stdout,
1336     }
1337     for i in [a for a in pkwargs]:
1338         val = pkwargs[i]
1339         if val is _marker:
1340             pkwargs.pop(i, None)
1341     _cmdout = __salt__["cmd.run_all"](cmd, **pkwargs)
1342     if _cmdout["retcode"] != 0:
1343         raise CommandExecutionError(
1344             "Error changing state for container '{}' using command '{}': {}".format(
1345                 name, cmd, _cmdout["stdout"]
1346             )
1347         )
1348     if expected is not None:
1349         rcmd = "lxc-wait"
1350         if path:
1351             rcmd += " -P {}".format(pipes.quote(path))
1352         rcmd += " -n {} -s {}".format(name, expected.upper())
1353         __salt__["cmd.run"](rcmd, python_shell=False, timeout=30)
1354     _clear_context()
1355     post = state(name, path=path)
1356     ret = {"result": post == expected, "state": {"old": pre, "new": post}}
1357     return ret
1358 def _ensure_exists(name, path=None):
1359     if not exists(name, path=path):
1360         raise CommandExecutionError("Container '{}' does not exist".format(name))
1361 def _ensure_running(name, no_start=False, path=None):
1362     _ensure_exists(name, path=path)
1363     pre = state(name, path=path)
1364     if pre == "running":
1365         return start(name, path=path)
1366     elif pre == "stopped":
1367         if no_start:
1368             raise CommandExecutionError("Container '{}' is not running".format(name))
1369         return start(name, path=path)
1370     elif pre == "frozen":
1371         if no_start:
1372             raise CommandExecutionError("Container '{}' is not running".format(name))
1373         return unfreeze(name, path=path)
1374 def restart(name, path=None, lxc_config=None, force=False):
1375     _ensure_exists(name, path=path)
1376     orig_state = state(name, path=path)
1377     if orig_state != "stopped":
1378         stop(name, kill=force, path=path)
1379     ret = start(name, path=path, lxc_config=lxc_config)
1380     ret["state"]["old"] = orig_state
1381     if orig_state != "stopped":
1382         ret["restarted"] = True
1383     return ret
1384 def start(name, **kwargs):
1385     path = kwargs.get("path", None)
1386     cpath = get_root_path(path)
1387     lxc_config = kwargs.get("lxc_config", None)
1388     cmd = "lxc-start"
1389     if not lxc_config:
1390         lxc_config = os.path.join(cpath, name, "config")
1391     if os.path.exists(lxc_config):
1392         cmd += " -f {}".format(pipes.quote(lxc_config))
1393     cmd += " -d"
1394     _ensure_exists(name, path=path)
1395     if state(name, path=path) == "frozen":
1396         raise CommandExecutionError(
1397             "Container '{}' is frozen, use lxc.unfreeze".format(name)
1398         )
1399     use_vt = kwargs.get("use_vt", None)
1400     with_communicate = kwargs.get("with_communicate", False)
1401     return _change_state(
1402         cmd,
1403         name,
1404         "running",
1405         stdout=None,
1406         stderr=None,
1407         stdin=None,
1408         with_communicate=with_communicate,
1409         path=path,
1410         use_vt=use_vt,
1411     )
1412 def stop(name, kill=False, path=None, use_vt=None):
1413     _ensure_exists(name, path=path)
1414     orig_state = state(name, path=path)
1415     if orig_state == "frozen" and not kill:
1416         unfreeze(name, path=path)
1417     cmd = "lxc-stop"
1418     if kill:
1419         cmd += " -k"
1420     ret = _change_state(cmd, name, "stopped", use_vt=use_vt, path=path)
1421     ret["state"]["old"] = orig_state
1422     return ret
1423 def freeze(name, **kwargs):
1424     use_vt = kwargs.get("use_vt", None)
1425     path = kwargs.get("path", None)
1426     _ensure_exists(name, path=path)
1427     orig_state = state(name, path=path)
1428     start_ = kwargs.get("start", False)
1429     if orig_state == "stopped":
1430         if not start_:
1431             raise CommandExecutionError("Container '{}' is stopped".format(name))
1432         start(name, path=path)
1433     cmd = "lxc-freeze"
1434     if path:
1435         cmd += " -P {}".format(pipes.quote(path))
1436     ret = _change_state(cmd, name, "frozen", use_vt=use_vt, path=path)
1437     if orig_state == "stopped" and start_:
1438         ret["state"]["old"] = orig_state
1439         ret["started"] = True
1440     ret["state"]["new"] = state(name, path=path)
1441     return ret
1442 def unfreeze(name, path=None, use_vt=None):
1443     _ensure_exists(name, path=path)
1444     if state(name, path=path) == "stopped":
1445         raise CommandExecutionError("Container '{}' is stopped".format(name))
1446     cmd = "lxc-unfreeze"
1447     if path:
1448         cmd += " -P {}".format(pipes.quote(path))
1449     return _change_state(cmd, name, "running", path=path, use_vt=use_vt)
1450 def destroy(name, stop=False, path=None):
1451     _ensure_exists(name, path=path)
1452     if not stop and state(name, path=path) != "stopped":
1453         raise CommandExecutionError("Container '{}' is not stopped".format(name))
1454     return _change_state("lxc-destroy", name, None, path=path)
1455 remove = salt.utils.functools.alias_function(destroy, "remove")
1456 def exists(name, path=None):
1457     _exists = name in ls_(path=path)
1458     if not _exists:
1459         _exists = name in ls_(cache=False, path=path)
1460     return _exists
1461 def state(name, path=None):
1462     cachekey = "lxc.state.{}{}".format(name, path)
1463     try:
1464         return __context__[cachekey]
1465     except KeyError:
1466         if not exists(name, path=path):
1467             __context__[cachekey] = None
1468         else:
1469             cmd = "lxc-info"
1470             if path:
1471                 cmd += " -P {}".format(pipes.quote(path))
1472             cmd += " -n {}".format(name)
1473             ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1474             if ret["retcode"] != 0:
1475                 _clear_context()
1476                 raise CommandExecutionError(
1477                     "Unable to get state of container '{}'".format(name)
1478                 )
1479             c_infos = ret["stdout"].splitlines()
1480             c_state = None
1481             for c_info in c_infos:
1482                 stat = c_info.split(":")
1483                 if stat[0].lower() == "state":
1484                     c_state = stat[1].strip().lower()
1485                     break
1486             __context__[cachekey] = c_state
1487     return __context__[cachekey]
1488 def get_parameter(name, parameter, path=None):
1489     _ensure_exists(name, path=path)
1490     cmd = "lxc-cgroup"
1491     if path:
1492         cmd += " -P {}".format(pipes.quote(path))
1493     cmd += " -n {} {}".format(name, parameter)
1494     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1495     if ret["retcode"] != 0:
1496         raise CommandExecutionError(
1497             "Unable to retrieve value for '{}'".format(parameter)
1498         )
1499     return ret["stdout"].strip()
1500 def set_parameter(name, parameter, value, path=None):
1501     if not exists(name, path=path):
1502         return None
1503     cmd = "lxc-cgroup"
1504     if path:
1505         cmd += " -P {}".format(pipes.quote(path))
1506     cmd += " -n {} {} {}".format(name, parameter, value)
1507     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
1508     if ret["retcode"] != 0:
1509         return False
1510     else:
1511         return True
1512 def info(name, path=None):
1513     cachekey = "lxc.info.{}{}".format(name, path)
1514     try:
1515         return __context__[cachekey]
1516     except KeyError:
1517         _ensure_exists(name, path=path)
1518         cpath = get_root_path(path)
1519         try:
1520             conf_file = os.path.join(cpath, name, "config")
1521         except AttributeError:
1522             conf_file = os.path.join(cpath, str(name), "config")
1523         if not os.path.isfile(conf_file):
1524             raise CommandExecutionError(
1525                 "LXC config file {} does not exist".format(conf_file)
1526             )
1527         ret = {}
1528         config = []
1529         with salt.utils.files.fopen(conf_file) as fp_:
1530             for line in fp_:
1531                 line = salt.utils.stringutils.to_unicode(line)
1532                 comps = [x.strip() for x in line.split("#", 1)[0].strip().split("=", 1)]
1533                 if len(comps) == 2:
1534                     config.append(tuple(comps))
1535         ifaces = []
1536         current = {}
1537         for key, val in config:
1538             if key == "lxc.network.type":
1539                 current = {"type": val}
1540                 ifaces.append(current)
1541             elif not current:
1542                 continue
1543             elif key.startswith("lxc.network."):
1544                 current[key.replace("lxc.network.", "", 1)] = val
1545         if ifaces:
1546             ret["nics"] = ifaces
1547         ret["rootfs"] = next((x[1] for x in config if x[0] == "lxc.rootfs"), None)
1548         ret["state"] = state(name, path=path)
1549         ret["ips"] = []
1550         ret["public_ips"] = []
1551         ret["private_ips"] = []
1552         ret["public_ipv4_ips"] = []
1553         ret["public_ipv6_ips"] = []
1554         ret["private_ipv4_ips"] = []
1555         ret["private_ipv6_ips"] = []
1556         ret["ipv4_ips"] = []
1557         ret["ipv6_ips"] = []
1558         ret["size"] = None
1559         ret["config"] = conf_file
1560         if ret["state"] == "running":
1561             try:
1562                 limit = int(get_parameter(name, "memory.limit_in_bytes"))
1563             except (CommandExecutionError, TypeError, ValueError):
1564                 limit = 0
1565             try:
1566                 usage = int(get_parameter(name, "memory.usage_in_bytes"))
1567             except (CommandExecutionError, TypeError, ValueError):
1568                 usage = 0
1569             free = limit - usage
1570             ret["memory_limit"] = limit
1571             ret["memory_free"] = free
1572             size = run_stdout(name, "df /", path=path, python_shell=False)
1573             ret["size"] = size.splitlines()[-1].split()[1]
1574             ip_cmd = run_all(name, "ip link show", path=path, python_shell=False)
1575             if ip_cmd["retcode"] == 0:
1576                 ip_data = ip_cmd["stdout"]
1577                 ip_cmd = run_all(name, "ip addr show", path=path, python_shell=False)
1578                 ip_data += "\n" + ip_cmd["stdout"]
1579                 ip_data = salt.utils.network._interfaces_ip(ip_data)
1580             else:
1581                 ip_cmd = run_all(name, "ifconfig", path=path, python_shell=False)
1582                 if ip_cmd["retcode"] == 0:
1583                     ip_data = salt.utils.network._interfaces_ifconfig(ip_cmd["stdout"])
1584                 else:
1585                     log.warning("Unable to run ip or ifconfig in container '%s'", name)
1586                     ip_data = {}
1587             ret["ipv4_ips"] = salt.utils.network.ip_addrs(
1588                 include_loopback=True, interface_data=ip_data
1589             )
1590             ret["ipv6_ips"] = salt.utils.network.ip_addrs6(
1591                 include_loopback=True, interface_data=ip_data
1592             )
1593             ret["ips"] = ret["ipv4_ips"] + ret["ipv6_ips"]
1594             for address in ret["ipv4_ips"]:
1595                 if address == "127.0.0.1":
1596                     ret["private_ips"].append(address)
1597                     ret["private_ipv4_ips"].append(address)
1598                 elif salt.utils.cloud.is_public_ip(address):
1599                     ret["public_ips"].append(address)
1600                     ret["public_ipv4_ips"].append(address)
1601                 else:
1602                     ret["private_ips"].append(address)
1603                     ret["private_ipv4_ips"].append(address)
1604             for address in ret["ipv6_ips"]:
1605                 if address == "::1" or address.startswith("fe80"):
1606                     ret["private_ips"].append(address)
1607                     ret["private_ipv6_ips"].append(address)
1608                 else:
1609                     ret["public_ips"].append(address)
1610                     ret["public_ipv6_ips"].append(address)
1611         for key in [x for x in ret if x == "ips" or x.endswith("ips")]:
1612             ret[key].sort(key=_ip_sort)
1613         __context__[cachekey] = ret
1614     return __context__[cachekey]
1615 def set_password(name, users, password, encrypted=True, path=None):
1616     def _bad_user_input():
1617         raise SaltInvocationError("Invalid input for 'users' parameter")
1618     if not isinstance(users, list):
1619         try:
1620             users = users.split(",")
1621         except AttributeError:
1622             _bad_user_input()
1623     if not users:
1624         _bad_user_input()
1625     failed_users = []
1626     for user in users:
1627         result = retcode(
1628             name,
1629             "chpasswd{}".format(" -e" if encrypted else ""),
1630             stdin=":".join((user, password)),
1631             python_shell=False,
1632             path=path,
1633             chroot_fallback=True,
1634             output_loglevel="quiet",
1635         )
1636         if result != 0:
1637             failed_users.append(user)
1638     if failed_users:
1639         raise CommandExecutionError(
1640             "Password change failed for the following user(s): {}".format(
1641                 ", ".join(failed_users)
1642             )
1643         )
1644     return True
1645 set_pass = salt.utils.functools.alias_function(set_password, "set_pass")
1646 def update_lxc_conf(name, lxc_conf, lxc_conf_unset, path=None):
1647     _ensure_exists(name, path=path)
1648     cpath = get_root_path(path)
1649     lxc_conf_p = os.path.join(cpath, name, "config")
1650     if not os.path.exists(lxc_conf_p):
1651         raise SaltInvocationError(
1652             "Configuration file {} does not exist".format(lxc_conf_p)
1653         )
1654     changes = {"edited": [], "added": [], "removed": []}
1655     ret = {"changes": changes, "result": True, "comment": ""}
1656     with salt.utils.files.fopen(lxc_conf_p, "r") as fic:
1657         filtered_lxc_conf = []
1658         for row in lxc_conf:
1659             if not row:
1660                 continue
1661             for conf in row:
1662                 filtered_lxc_conf.append((conf.strip(), row[conf].strip()))
1663         ret["comment"] = "lxc.conf is up to date"
1664         lines = []
1665         orig_config = salt.utils.stringutils.to_unicode(fic.read())
1666         for line in orig_config.splitlines():
1667                 lines.append([line, ""])
1668             else:
1669                 line = line<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.split("=")
1670                 index = line.pop(0)
1671                 val = (index.strip(), "=".join(line).strip(</b></font>))
1672                 if val not in lines:
1673                     lines.append(val)
1674         for key, item in filtered_lxc_conf:
1675             matched = False
1676             for idx, line in enumerate(lines[:]):
1677                 if line[0] == key:
1678                     matched = True
1679                     lines[idx] = (key, item)
1680                     if "=".join(line[1:]).strip() != item.strip():
1681                         changes["edited"].append(({line[0]: line[1:]}, {key: item}))
1682                         break
1683             if not matched:
1684                 if (key, item) not in lines:
1685                     lines.append((key, item))
1686                 changes["added"].append({key: item})
1687         dest_lxc_conf = []
1688         if lxc_conf_unset:
1689             for line in lines:
1690                 for opt in lxc_conf_unset:
1691                     if not line[0].startswith(opt) and line not in dest_lxc_conf:
1692                         dest_lxc_conf.append(line)
1693                     else:
1694                         changes["removed"].append(opt)
1695         else:
1696             dest_lxc_conf = lines
1697         conf = ""
1698         for key, val in dest_lxc_conf:
1699             if not val:
1700                 conf += "{}\n".format(key)
1701             else:
1702                 conf += "{} = {}\n".format(key.strip(), val.strip())
1703         conf_changed = conf != orig_config
1704         chrono = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
1705         if conf_changed:
1706             with salt.utils.files.fopen(
1707                 "{}.{}".format(lxc_conf_p, chrono), "w"
1708             ) as wfic:
1709                 wfic.write(salt.utils.stringutils.to_str(conf))
1710             with salt.utils.files.fopen(lxc_conf_p, "w") as wfic:
1711                 wfic.write(salt.utils.stringutils.to_str(conf))
1712             ret["comment"] = "Updated"
1713             ret["result"] = True
1714     if not any(changes[x] for x in changes):
1715         ret["changes"] = {}
1716     return ret
1717 def set_dns(name, dnsservers=None, searchdomains=None, path=None):
1718     if dnsservers is None:
1719         dnsservers = ["8.8.8.8", "4.4.4.4"]
1720     elif not isinstance(dnsservers, list):
1721         try:
1722             dnsservers = dnsservers.split(",")
1723         except AttributeError:
1724             raise SaltInvocationError("Invalid input for 'dnsservers' parameter")
1725     if searchdomains is None:
1726         searchdomains = []
1727     elif not isinstance(searchdomains, list):
1728         try:
1729             searchdomains = searchdomains.split(",")
1730         except AttributeError:
1731             raise SaltInvocationError("Invalid input for 'searchdomains' parameter")
1732     dns = ["nameserver {}".format(x) for x in dnsservers]
1733     dns.extend(["search {}".format(x) for x in searchdomains])
1734     dns = "\n".join(dns) + "\n"
1735     rstr = __salt__["test.random_hash"]()
1736     script = "/sbin/{}_dns.sh".format(rstr)
1737     DNS_SCRIPT = "\n".join(
1738         [
1739             "#!/usr/bin/env bash",
1740             "if [ -h /etc/resolv.conf ];then",
1741             ' if [ "x$(readlink /etc/resolv.conf)"'
1742             ' = "x../run/resolvconf/resolv.conf" ];then',
1743             "  if [ ! -d /run/resolvconf/ ];then",
1744             "   mkdir -p /run/resolvconf",
1745             "  fi",
1746             "  cat &gt; /etc/resolvconf/resolv.conf.d/head &lt;&lt;EOF",
1747             dns,
1748             "EOF",
1749             "",
1750             " fi",
1751             "fi",
1752             "cat &gt; /etc/resolv.conf &lt;&lt;EOF",
1753             dns,
1754             "EOF",
1755             "",
1756         ]
1757     )
1758     result = run_all(
1759         name, "tee {}".format(script), path=path, stdin=DNS_SCRIPT, python_shell=True
1760     )
1761     if result["retcode"] == 0:
1762         result = run_all(
1763             name,
1764             'sh -c "chmod +x {0};{0}"'.format(script),
1765             path=path,
1766             python_shell=True,
1767         )
1768     run_all(
1769         name,
1770         'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1771         path=path,
1772         python_shell=True,
1773     )
1774     if result["retcode"] != 0:
1775         error = "Unable to write to /etc/resolv.conf in container '{}'".format(name)
1776         if result["stderr"]:
1777             error += ": {}".format(result["stderr"])
1778         raise CommandExecutionError(error)
1779     return True
1780 def running_systemd(name, cache=True, path=None):
1781     k = "lxc.systemd.test.{}{}".format(name, path)
1782     ret = __context__.get(k, None)
1783     if ret is None or not cache:
1784         rstr = __salt__["test.random_hash"]()
1785         script = "/sbin/{}_testsystemd.sh".format(rstr)
1786         _script = textwrap.dedent(
1787         )
1788         result = run_all(
1789             name, "tee {}".format(script), path=path, stdin=_script, python_shell=True
1790         )
1791         if result["retcode"] == 0:
1792             result = run_all(
1793                 name,
1794                 'sh -c "chmod +x {0};{0}"'.format(script),
1795                 path=path,
1796                 python_shell=True,
1797             )
1798         else:
1799             raise CommandExecutionError(
1800                 "lxc {} failed to copy initd tester".format(name)
1801             )
1802         run_all(
1803             name,
1804             'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1805             path=path,
1806             ignore_retcode=True,
1807             python_shell=True,
1808         )
1809         if result["retcode"] != 0:
1810             error = (
1811                 "Unable to determine if the container '{}'"
1812                 " was running systemd, assmuming it is not."
1813                 "".format(name)
1814             )
1815             if result["stderr"]:
1816                 error += ": {}".format(result["stderr"])
1817         if result["retcode"] in (0, 2):
1818             __context__[k] = ret = not result["retcode"]
1819     return ret
1820 def systemd_running_state(name, path=None):
1821     try:
1822         ret = run_all(
1823             name, "systemctl is-system-running", path=path, ignore_retcode=True
1824         )["stdout"]
1825     except CommandExecutionError:
1826         ret = ""
1827     return ret
1828 def test_sd_started_state(name, path=None):
1829     qstate = systemd_running_state(name, path=path)
1830     if qstate in ("initializing", "starting"):
1831         return False
1832     elif qstate == "":
1833         return None
1834     else:
1835         return True
1836 def test_bare_started_state(name, path=None):
1837     try:
1838         ret = run_all(name, "ls", path=path, ignore_retcode=True)["retcode"] == 0
1839     except (CommandExecutionError,):
1840         ret = None
1841     return ret
1842 def wait_started(name, path=None, timeout=300):
1843     if not exists(name, path=path):
1844         raise CommandExecutionError("Container {} does does exists".format(name))
1845     if not state(name, path=path) == "running":
1846         raise CommandExecutionError("Container {} is not running".format(name))
1847     ret = False
1848     if running_systemd(name, path=path):
1849         test_started = test_sd_started_state
1850         logger = log.error
1851     else:
1852         test_started = test_bare_started_state
1853         logger = log.debug
1854     now = time.time()
1855     expire = now + timeout
1856     now = time.time()
1857     started = test_started(name, path=path)
1858     while time.time() &lt; expire and not started:
1859         time.sleep(0.3)
1860         started = test_started(name, path=path)
1861     if started is None:
1862         logger(
1863             "Assuming %s is started, although we failed to detect that"
1864             " is fully started correctly",
1865             name,
1866         )
1867         ret = True
1868     else:
1869         ret = started
1870     return ret
1871 def _needs_install(name, path=None):
1872     ret = 0
1873     has_minion = retcode(name, "which salt-minion", path=path, ignore_retcode=True)
1874     if has_minion:
1875         processes = run_stdout(name, "ps aux", path=path)
1876         if "salt-minion" not in processes:
1877             ret = 1
1878         else:
1879             retcode(name, "salt-call --local service.stop salt-minion")
1880     else:
1881         ret = 1
1882     return ret
1883 def bootstrap(
1884     name,
1885     config=None,
1886     approve_key=True,
1887     install=True,
1888     pub_key=None,
1889     priv_key=None,
1890     bootstrap_url=None,
1891     force_install=False,
1892     unconditional_install=False,
1893     path=None,
1894     bootstrap_delay=None,
1895     bootstrap_args=None,
1896     bootstrap_shell=None,
1897 ):
1898     wait_started(name, path=path)
1899     if bootstrap_delay is not None:
1900         try:
1901             log.info("LXC %s: bootstrap_delay: %s", name, bootstrap_delay)
1902             time.sleep(bootstrap_delay)
1903         except TypeError:
1904             time.sleep(5)
1905     c_info = info(name, path=path)
1906     if not c_info:
1907         return None
1908     if bootstrap_args:
1909         if "{0}" not in bootstrap_args:
1910             bootstrap_args += " -c {0}"
1911     else:
1912         bootstrap_args = "-c {0}"
1913     if not bootstrap_shell:
1914         bootstrap_shell = "sh"
1915     orig_state = _ensure_running(name, path=path)
1916     if not orig_state:
1917         return orig_state
1918     if not force_install:
1919         needs_install = _needs_install(name, path=path)
1920     else:
1921         needs_install = True
1922     seeded = (
1923         retcode(
1924             name,
1925             "test -e '{}'".format(SEED_MARKER),
1926             path=path,
1927             chroot_fallback=True,
1928             ignore_retcode=True,
1929         )
1930         == 0
1931     )
1932     tmp = tempfile.mkdtemp()
1933     if seeded and not unconditional_install:
1934         ret = True
1935     else:
1936         ret = False
1937         cfg_files = __salt__["seed.mkconfig"](
1938             config,
1939             tmp=tmp,
1940             id_=name,
1941             approve_key=approve_key,
1942             pub_key=pub_key,
1943             priv_key=priv_key,
1944         )
1945         if needs_install or force_install or unconditional_install:
1946             if install:
1947                 rstr = __salt__["test.random_hash"]()
1948                 configdir = "/var/tmp/.c_{}".format(rstr)
1949                 cmd = "install -m 0700 -d {}".format(configdir)
1950                 if run_all(name, cmd, path=path, python_shell=False)["retcode"] != 0:
1951                     log.error("tmpdir %s creation failed %s", configdir, cmd)
1952                     return False
1953                 bs_ = __salt__["config.gather_bootstrap_script"](
1954                     bootstrap=bootstrap_url
1955                 )
1956                 script = "/sbin/{}_bootstrap.sh".format(rstr)
1957                 copy_to(name, bs_, script, path=path)
1958                 result = run_all(
1959                     name,
1960                     'sh -c "chmod +x {}"'.format(script),
1961                     path=path,
1962                     python_shell=True,
1963                 )
1964                 copy_to(
1965                     name,
1966                     cfg_files["config"],
1967                     os.path.join(configdir, "minion"),
1968                     path=path,
1969                 )
1970                 copy_to(
1971                     name,
1972                     cfg_files["privkey"],
1973                     os.path.join(configdir, "minion.pem"),
1974                     path=path,
1975                 )
1976                 copy_to(
1977                     name,
1978                     cfg_files["pubkey"],
1979                     os.path.join(configdir, "minion.pub"),
1980                     path=path,
1981                 )
1982                 bootstrap_args = bootstrap_args.format(configdir)
1983                 cmd = "{0} {2} {1}".format(
1984                     bootstrap_shell, bootstrap_args.replace("'", "''"), script
1985                 )
1986                 log.info("Running %s in LXC container '%s'", cmd, name)
1987                 ret = (
1988                     retcode(name, cmd, output_loglevel="info", path=path, use_vt=True)
1989                     == 0
1990                 )
1991                 run_all(
1992                     name,
1993                     'sh -c \'if [ -f "{0}" ];then rm -f "{0}";fi\''.format(script),
1994                     path=path,
1995                     ignore_retcode=True,
1996                     python_shell=True,
1997                 )
1998             else:
1999                 ret = False
2000         else:
2001             minion_config = salt.config.minion_config(cfg_files["config"])
2002             pki_dir = minion_config["pki_dir"]
2003             copy_to(name, cfg_files["config"], "/etc/salt/minion", path=path)
2004             copy_to(
2005                 name,
2006                 cfg_files["privkey"],
2007                 os.path.join(pki_dir, "minion.pem"),
2008                 path=path,
2009             )
2010             copy_to(
2011                 name,
2012                 cfg_files["pubkey"],
2013                 os.path.join(pki_dir, "minion.pub"),
2014                 path=path,
2015             )
2016             run(
2017                 name,
2018                 "salt-call --local service.enable salt-minion",
2019                 path=path,
2020                 python_shell=False,
2021             )
2022             ret = True
2023         shutil.rmtree(tmp)
2024         if orig_state == "stopped":
2025             stop(name, path=path)
2026         elif orig_state == "frozen":
2027             freeze(name, path=path)
2028         if ret:
2029             run(name, "touch '{}'".format(SEED_MARKER), path=path, python_shell=False)
2030     return ret
2031 def attachable(name, path=None):
2032     cachekey = "lxc.attachable{}{}".format(name, path)
2033     try:
2034         return __context__[cachekey]
2035     except KeyError:
2036         _ensure_exists(name, path=path)
2037         log.debug("Checking if LXC container %s is attachable", name)
2038         cmd = "lxc-attach"
2039         if path:
2040             cmd += " -P {}".format(pipes.quote(path))
2041         cmd += " --clear-env -n {} -- /usr/bin/env".format(name)
2042         result = (
2043             __salt__["cmd.retcode"](
2044                 cmd, python_shell=False, output_loglevel="quiet", ignore_retcode=True
2045             )
2046             == 0
2047         )
2048         __context__[cachekey] = result
2049     return __context__[cachekey]
2050 def _run(
2051     name,
2052     cmd,
2053     output=None,
2054     no_start=False,
2055     preserve_state=True,
2056     stdin=None,
2057     python_shell=True,
2058     output_loglevel="debug",
2059     use_vt=False,
2060     path=None,
2061     ignore_retcode=False,
2062     chroot_fallback=None,
2063     keep_env="http_proxy,https_proxy,no_proxy",
2064 ):
2065     orig_state = state(name, path=path)
2066     try:
2067         if attachable(name, path=path):
2068             ret = __salt__["container_resource.run"](
2069                 name,
2070                 cmd,
2071                 path=path,
2072                 container_type=__virtualname__,
2073                 exec_driver=EXEC_DRIVER,
2074                 output=output,
2075                 no_start=no_start,
2076                 stdin=stdin,
2077                 python_shell=python_shell,
2078                 output_loglevel=output_loglevel,
2079                 ignore_retcode=ignore_retcode,
2080                 use_vt=use_vt,
2081                 keep_env=keep_env,
2082             )
2083         else:
2084             if not chroot_fallback:
2085                 raise CommandExecutionError("{} is not attachable.".format(name))
2086             rootfs = info(name, path=path).get("rootfs")
2087             __context__["cmd.run_chroot.func"] = __salt__["cmd.run"]
2088             ret = __salt__["cmd.run_chroot"](
2089                 rootfs,
2090                 cmd,
2091                 stdin=stdin,
2092                 python_shell=python_shell,
2093                 output_loglevel=output_loglevel,
2094                 ignore_retcode=ignore_retcode,
2095             )
2096     finally:
2097         new_state = state(name, path=path)
2098         if preserve_state:
2099             if orig_state == "stopped" and new_state != "stopped":
2100                 stop(name, path=path)
2101             elif orig_state == "frozen" and new_state != "frozen":
2102                 freeze(name, start=True, path=path)
2103     if output in (None, "all"):
2104         return ret
2105     else:
2106         return ret[output]
2107 def run(
2108     name,
2109     cmd,
2110     no_start=False,
2111     preserve_state=True,
2112     stdin=None,
2113     python_shell=True,
2114     output_loglevel="debug",
2115     use_vt=False,
2116     path=None,
2117     ignore_retcode=False,
2118     chroot_fallback=False,
2119     keep_env="http_proxy,https_proxy,no_proxy",
2120 ):
2121     return _run(
2122         name,
2123         cmd,
2124         path=path,
2125         output=None,
2126         no_start=no_start,
2127         preserve_state=preserve_state,
2128         stdin=stdin,
2129         python_shell=python_shell,
2130         output_loglevel=output_loglevel,
2131         use_vt=use_vt,
2132         ignore_retcode=ignore_retcode,
2133         chroot_fallback=chroot_fallback,
2134         keep_env=keep_env,
2135     )
2136 def run_stdout(
2137     name,
2138     cmd,
2139     no_start=False,
2140     preserve_state=True,
2141     stdin=None,
2142     python_shell=True,
2143     output_loglevel="debug",
2144     use_vt=False,
2145     path=None,
2146     ignore_retcode=False,
2147     chroot_fallback=False,
2148     keep_env="http_proxy,https_proxy,no_proxy",
2149 ):
2150     return _run(
2151         name,
2152         cmd,
2153         path=path,
2154         output="stdout",
2155         no_start=no_start,
2156         preserve_state=preserve_state,
2157         stdin=stdin,
2158         python_shell=python_shell,
2159         output_loglevel=output_loglevel,
2160         use_vt=use_vt,
2161         ignore_retcode=ignore_retcode,
2162         chroot_fallback=chroot_fallback,
2163         keep_env=keep_env,
2164     )
2165 def run_stderr(
2166     name,
2167     cmd,
2168     no_start=False,
2169     preserve_state=True,
2170     stdin=None,
2171     python_shell=True,
2172     output_loglevel="debug",
2173     use_vt=False,
2174     path=None,
2175     ignore_retcode=False,
2176     chroot_fallback=False,
2177     keep_env="http_proxy,https_proxy,no_proxy",
2178 ):
2179     return _run(
2180         name,
2181         cmd,
2182         path=path,
2183         output="stderr",
2184         no_start=no_start,
2185         preserve_state=preserve_state,
2186         stdin=stdin,
2187         python_shell=python_shell,
2188         output_loglevel=output_loglevel,
2189         use_vt=use_vt,
2190         ignore_retcode=ignore_retcode,
2191         chroot_fallback=chroot_fallback,
2192         keep_env=keep_env,
2193     )
2194 def retcode(
2195     name,
2196     cmd,
2197     no_start=False,
2198     preserve_state=True,
2199     stdin=None,
2200     python_shell=True,
2201     output_loglevel="debug",
2202     use_vt=False,
2203     path=None,
2204     ignore_retcode=False,
2205     chroot_fallback=False,
2206     keep_env="http_proxy,https_proxy,no_proxy",
2207 ):
2208     return _run(
2209         name,
2210         cmd,
2211         output="retcode",
2212         path=path,
2213         no_start=no_start,
2214         preserve_state=preserve_state,
2215         stdin=stdin,
2216         python_shell=python_shell,
2217         output_loglevel=output_loglevel,
2218         use_vt=use_vt,
2219         ignore_retcode=ignore_retcode,
2220         chroot_fallback=chroot_fallback,
2221         keep_env=keep_env,
2222     )
2223 def run_all(
2224     name,
2225     cmd,
2226     no_start=False,
2227     preserve_state=True,
2228     stdin=None,
2229     python_shell=True,
2230     output_loglevel="debug",
2231     use_vt=False,
2232     path=None,
2233     ignore_retcode=False,
2234     chroot_fallback=False,
2235     keep_env="http_proxy,https_proxy,no_proxy",
2236 ):
2237     return _run(
2238         name,
2239         cmd,
2240         output="all",
2241         no_start=no_start,
2242         preserve_state=preserve_state,
2243         stdin=stdin,
2244         python_shell=python_shell,
2245         output_loglevel=output_loglevel,
2246         use_vt=use_vt,
2247         path=path,
2248         ignore_retcode=ignore_retcode,
2249         chroot_fallback=chroot_fallback,
2250         keep_env=keep_env,
2251     )
2252 def _get_md5(name, path):
2253     output = run_stdout(
2254         name, 'md5sum "{}"'.format(path), chroot_fallback=True, ignore_retcode=True
2255     )
2256     try:
2257         return output.split()[0]
2258     except IndexError:
2259         return None
2260 def copy_to(name, source, dest, overwrite=False, makedirs=False, path=None):
2261     _ensure_running(name, no_start=True, path=path)
2262     return __salt__["container_resource.copy_to"](
2263         name,
2264         source,
2265         dest,
2266         container_type=__virtualname__,
2267         path=path,
2268         exec_driver=EXEC_DRIVER,
2269         overwrite=overwrite,
2270         makedirs=makedirs,
2271     )
2272 cp = salt.utils.functools.alias_function(copy_to, "cp")
2273 def read_conf(conf_file, out_format="simple"):
2274     ret_commented = []
2275     ret_simple = {}
2276     with salt.utils.files.fopen(conf_file, "r") as fp_:
2277         for line in salt.utils.data.decode(fp_.readlines()):
2278             if "=" not in line:
2279                 ret_commented.append(line)
2280                 continue
2281             comps = line.split("=")
2282             value = "=".join(comps[1:]).strip()
2283             comment = None
2284             if value.strip().startswith("#"):
2285                 vcomps = value.strip().split("#")
2286                 comment = "#".join(vcomps[1:]).strip()
2287                 ret_commented.append(
2288                     {<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>comps[0].strip(): {"value": value, "comment": comment}}
2289                 )
2290             else:
2291                 ret_commented.append({comps[0].strip(): value})
2292                 ret_simple[</b></font>comps[0].strip()] = value
2293     if out_format == "simple":
2294         return ret_simple
2295     return ret_commented
2296 def write_conf(conf_file, conf):
2297     if not isinstance(conf, list):
2298         raise SaltInvocationError("Configuration must be passed as a list")
2299     content = ""
2300     for line in conf:
2301         if isinstance(line, (str, (str,))):
2302             content += line
2303         elif isinstance(line, dict):
2304             for key in list(line.keys()):
2305                 out_line = None
2306                 if isinstance(
2307                     line[key],
2308                     (str, (str,), (int,), float),
2309                 ):
2310                     out_line = " = ".join((key, "{}".format(line[key])))
2311                 elif isinstance(line[key], dict):
2312                     out_line = " = ".join((key, line[key]["value"]))
2313                     if "comment" in line[key]:
2314                         out_line = " # ".join((out_line, line[key]["comment"]))
2315                 if out_line:
2316                     content += out_line
2317                     content += "\n"
2318     with salt.utils.files.fopen(conf_file, "w") as fp_:
2319         fp_.write(salt.utils.stringutils.to_str(content))
2320     return {}
2321 def edit_conf(
2322     conf_file, out_format="simple", read_only=False, lxc_config=None, **kwargs
2323 ):
2324     data = []
2325     try:
2326         conf = read_conf(conf_file, out_format=out_format)
2327     except Exception:  # pylint: disable=broad-except
2328         conf = []
2329     if not lxc_config:
2330         lxc_config = []
2331     lxc_config = copy.deepcopy(lxc_config)
2332     net_config = []
2333     for lxc_kws in lxc_config + [kwargs]:
2334         net_params = {}
2335         for kwarg in [a for a in lxc_kws]:
2336             if kwarg.startswith("__"):
2337                 continue
2338             if kwarg.startswith("lxc.network."):
2339                 net_params[kwarg] = lxc_kws[kwarg]
2340                 lxc_kws.pop(kwarg, None)
2341         if net_params:
2342             net_config.append(net_params)
2343     nic_opts = salt.utils.odict.OrderedDict()
2344     for params in net_config:
2345         dev = params.get("lxc.network.name", DEFAULT_NIC)
2346         dev_opts = nic_opts.setdefault(dev, salt.utils.odict.OrderedDict())
2347         for param in params:
2348             opt = param.replace("lxc.network.", "")
2349             opt = {"hwaddr": "mac"}.get(opt, opt)
2350             dev_opts[opt] = params[param]
2351     net_changes = []
2352     if nic_opts:
2353         net_changes = _config_list(
2354             conf,
2355             only_net=True,
2356             **{"network_profile": DEFAULT_NIC, "nic_opts": nic_opts}
2357         )
2358         if net_changes:
2359             lxc_config.extend(net_changes)
2360     for line in conf:
2361         if not isinstance(line, dict):
2362             data.append(line)
2363             continue
2364         else:
2365             for key in list(line.keys()):
2366                 val = line[key]
2367                 if net_changes and key.startswith("lxc.network."):
2368                     continue
2369                 found = False
2370                 for kw in lxc_config:
2371                     if key in kw:
2372                         found = True
2373                         data.append({key: kw[key]})
2374                         del kw[key]
2375                 if not found:
2376                     data.append({key: val})
2377     for lxc_kws in lxc_config:
2378         for kwarg in lxc_kws:
2379             data.append({kwarg: lxc_kws[kwarg]})
2380     if read_only:
2381         return data
2382     write_conf(conf_file, data)
2383     return read_conf(conf_file, out_format)
2384 def reboot(name, path=None):
2385     ret = {"result": True, "changes": {}, "comment": "{} rebooted".format(name)}
2386     does_exist = exists(name, path=path)
2387     if does_exist and (state(name, path=path) == "running"):
2388         try:
2389             stop(name, path=path)
2390         except (SaltInvocationError, CommandExecutionError) as exc:
2391             ret["comment"] = "Unable to stop container: {}".format(exc)
2392             ret["result"] = False
2393             return ret
2394     if does_exist and (state(name, path=path) != "running"):
2395         try:
2396             start(name, path=path)
2397         except (SaltInvocationError, CommandExecutionError) as exc:
2398             ret["comment"] = "Unable to stop container: {}".format(exc)
2399             ret["result"] = False
2400             return ret
2401     ret["changes"][name] = "rebooted"
2402     return ret
2403 def reconfigure(
2404     name,
2405     cpu=None,
2406     cpuset=None,
2407     cpushare=None,
2408     memory=None,
2409     profile=None,
2410     network_profile=None,
2411     nic_opts=None,
2412     bridge=None,
2413     gateway=None,
2414     autostart=None,
2415     utsname=None,
2416     rootfs=None,
2417     path=None,
2418     **kwargs
2419 ):
2420     changes = {}
2421     cpath = get_root_path(path)
2422     path = os.path.join(cpath, name, "config")
2423     ret = {
2424         "name": name,
2425         "comment": "config for {} up to date".format(name),
2426         "result": True,
2427         "changes": changes,
2428     }
2429     profile = get_container_profile(copy.deepcopy(profile))
2430     kw_overrides = copy.deepcopy(kwargs)
2431     def select(key, default=None):
2432         kw_overrides_match = kw_overrides.pop(key, _marker)
2433         profile_match = profile.pop(key, default)
2434         if kw_overrides_match is _marker:
2435             return profile_match
2436         return kw_overrides_match
2437     if nic_opts is not None and not network_profile:
2438         network_profile = DEFAULT_NIC
2439     if autostart is not None:
2440         autostart = select("autostart", autostart)
2441     else:
2442         autostart = "keep"
2443     if not utsname:
2444         utsname = select("utsname", utsname)
2445     if os.path.exists(path):
2446         old_chunks = read_conf(path, out_format="commented")
2447         make_kw = salt.utils.odict.OrderedDict(
2448             [
2449                 ("utsname", utsname),
2450                 ("rootfs", rootfs),
2451                 ("autostart", autostart),
2452                 ("cpu", cpu),
2453                 ("gateway", gateway),
2454                 ("cpuset", cpuset),
2455                 ("cpushare", cpushare),
2456                 ("network_profile", network_profile),
2457                 ("nic_opts", nic_opts),
2458                 ("bridge", bridge),
2459             ]
2460         )
2461         if memory:
2462             make_kw["memory"] = memory
2463         kw = salt.utils.odict.OrderedDict()
2464         for key, val in make_kw.items():
2465             if val is not None:
2466                 kw[key] = val
2467         new_cfg = _config_list(conf_tuples=old_chunks, **kw)
2468         if new_cfg:
2469             edit_conf(path, out_format="commented", lxc_config=new_cfg)
2470         chunks = read_conf(path, out_format="commented")
2471         if old_chunks != chunks:
2472             ret["comment"] = "{} lxc config updated".format(name)
2473             if state(name, path=path) == "running":
2474                 cret = reboot(name, path=path)
2475                 ret["result"] = cret["result"]
2476     return ret
2477 def apply_network_profile(name, network_profile, nic_opts=None, path=None):
2478     cpath = get_root_path(path)
2479     cfgpath = os.path.join(cpath, name, "config")
2480     before = []
2481     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2482         for line in fp_:
2483             before.append(line)
2484     lxcconfig = _LXCConfig(name=name, path=path)
2485     old_net = lxcconfig._filter_data("lxc.network")
2486     network_params = {}
2487     for param in _network_conf(
2488         conf_tuples=old_net, network_profile=network_profile, nic_opts=nic_opts
2489     ):
2490         network_params.update(param)
2491     if network_params:
2492         edit_conf(cfgpath, out_format="commented", **network_params)
2493     after = []
2494     with salt.utils.files.fopen(cfgpath, "r") as fp_:
2495         for line in fp_:
2496             after.append(line)
2497     diff = ""
2498     for line in difflib.unified_diff(before, after, fromfile="before", tofile="after"):
2499         diff += line
2500     return diff
2501 def get_pid(name, path=None):
2502     if name not in list_(limit="running", path=path):
2503         raise CommandExecutionError(
2504             "Container {} is not running, can't determine PID".format(name)
2505         )
2506     info = __salt__["cmd.run"]("lxc-info -n {}".format(name)).split("\n")
2507     pid = [
2508         line.split(":")[1].strip()
2509         for line in info
2510         if re.match(r"\s*PID", line) is not None
2511     ][0]
2512     return pid
2513 def add_veth(name, interface_name, bridge=None, path=None):
2514     pid = get_pid(name, path=path)
2515     while True:
2516         random_veth = "veth" + "".join(
2517             random.choice(string.ascii_uppercase + string.digits) for _ in range(6)
2518         )
2519         if random_veth not in __salt__["network.interfaces"]().keys():
2520             break
2521     if not __salt__["file.directory_exists"]("/var/run/"):
2522         raise CommandExecutionError(
2523             "Directory /var/run required for lxc.add_veth doesn't exists"
2524         )
2525     if not __salt__["file.file_exists"]("/proc/{}/ns/net".format(pid)):
2526         raise CommandExecutionError(
2527             "Proc file for container {} network namespace doesn't exists".format(name)
2528         )
2529     if not __salt__["file.directory_exists"]("/var/run/netns"):
2530         __salt__["file.mkdir"]("/var/run/netns")
2531     if __salt__["file.is_link"]("/var/run/netns/{}".format(name)):
2532         __salt__["file.remove"]("/var/run/netns/{}".format(name))
2533     __salt__["file.symlink"](
2534         "/proc/{}/ns/net".format(pid), "/var/run/netns/{}".format(name)
2535     )
2536     interface_exists = 0 == __salt__["cmd.retcode"](
2537         "ip netns exec {netns} ip address list {interface}".format(
2538             netns=name, interface=interface_name
2539         )
2540     )
2541     if interface_exists:
2542         raise CommandExecutionError(
2543             "Interface {interface} already exists in {container}".format(
2544                 interface=interface_name, container=name
2545             )
2546         )
2547     if (
2548         __salt__["cmd.retcode"](
2549             "ip link add name {veth} type veth peer name {veth}_c".format(
2550                 veth=random_veth
2551             )
2552         )
2553         != 0
2554     ):
2555         raise CommandExecutionError(
2556             "Error while creating the veth pair {}".format(random_veth)
2557         )
2558     if __salt__["cmd.retcode"]("ip link set dev {} up".format(random_veth)) != 0:
2559         raise CommandExecutionError(
2560             "Error while bringing up host-side veth {}".format(random_veth)
2561         )
2562     attached = 0 == __salt__["cmd.retcode"](
2563         "ip link set dev {veth}_c netns {container} name {interface_name}".format(
2564             veth=random_veth, container=name, interface_name=interface_name
2565         )
2566     )
2567     if not attached:
2568         raise CommandExecutionError(
2569             "Error while attaching the veth {veth} to container {container}".format(
2570                 veth=random_veth, container=name
2571             )
2572         )
2573     __salt__["file.remove"]("/var/run/netns/{}".format(name))
2574     if bridge is not None:
2575         __salt__["bridge.addif"](bridge, random_veth)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
