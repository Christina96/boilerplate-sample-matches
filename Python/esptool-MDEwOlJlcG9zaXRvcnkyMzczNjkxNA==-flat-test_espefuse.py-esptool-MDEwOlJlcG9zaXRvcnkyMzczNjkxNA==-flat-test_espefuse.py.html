
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, "images", "efuse")
10  S_IMAGES_DIR = os.path.join(TEST_DIR, "secure_images")
11  EFUSE_S_DIR = os.path.join(TEST_DIR, "efuse_scripts")
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f"{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}")
24  print(f"\nHost tests of espefuse.py for {arg_chip}:")
25  print("Running espefuse.py tests...")
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f"{sys.executable} -m espefuse --chip {arg_chip} "
33                  f"--virt --path-efuse-file {self.efuse_file.name} -d"
34              )
35          else:
36              self.base_cmd = (
37                  f"{sys.executable} -m espefuse --chip {arg_chip} "
38                  f"--port {arg_port} -d"
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py("burn_efuse CODING_SCHEME 1")
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, "rb") as f:
72              data = BitStream("0x00") * offset + BitStream(f)
73              blk = data.readlist(f"{data.len // 8}*uint:8")
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = " ".join(f"{num:02x}" for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = " ".join((f"{sys.executable} -m espefuse", cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = " ".join(
82              [self.base_cmd, "--do-not-confirm" if do_not_confirm else "", cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              " ".join([self.base_cmd, "check_error"]), "No errors detected", 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py("--help", check_msg="usage: __main__.py [-h]")
114          self.espefuse_not_virt_py(f"--chip {arg_chip} --help")
115      def test_help2(self):
116          self.espefuse_not_virt_py("", check_msg="usage: __main__.py [-h]", ret_code=1)
117      def test_dump(self):
118          self.espefuse_py("dump -h")
119          self.espefuse_py("dump")
120      def test_summary(self):
121          self.espefuse_py("summary -h")
122          self.espefuse_py("summary")
123      def test_summary_json(self):
124          self.espefuse_py("summary --format json")
125      def test_get_custom_mac(self):
126          self.espefuse_py("get_custom_mac -h")
127          if arg_chip == "esp32":
128              right_msg = "Custom MAC Address is not set in the device."
129          else:
130              right_msg = "Custom MAC Address: 00:00:00:00:00:00 (OK)"
131          self.espefuse_py("get_custom_mac", check_msg=right_msg)
132      def test_adc_info(self):
133          self.espefuse_py("adc_info -h")
134          self.espefuse_py("adc_info")
135      def test_check_error(self):
136          self.espefuse_py("check_error -h")
137          self.espefuse_py("check_error")
138          self.espefuse_py("check_error --recovery")
139  class TestReadProtectionCommands(EfuseTestCase):
140      def test_read_protect_efuse(self):
141          self.espefuse_py("read_protect_efuse -h")
142          if arg_chip == "esp32":
143              cmd = "read_protect_efuse \
144                     CODING_SCHEME \
145                     MAC_VERSION \
146                     BLOCK1 \
147                     BLOCK2 \
148                     BLOCK3"
149              count_protects = 5
150          elif arg_chip == "esp32c2":
151              cmd = "read_protect_efuse \
152                     BLOCK_KEY0_LOW_128"
153              count_protects = 1
154          else:
155              self.espefuse_py(
156                  "burn_efuse \
157                  KEY_PURPOSE_0 HMAC_UP \
158                  KEY_PURPOSE_1 XTS_AES_128_KEY \
159                  KEY_PURPOSE_2 XTS_AES_128_KEY \
160                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
161                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
162                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE"
163              )
164              cmd = "read_protect_efuse \
165                     BLOCK_KEY0 \
166                     BLOCK_KEY1 \
167                     BLOCK_KEY2 \
168                     BLOCK_KEY3 \
169                     BLOCK_KEY4 \
170                     BLOCK_KEY5"
171              count_protects = 6
172          self.espefuse_py(cmd)
173          output = self.espefuse_py(cmd)
174          assert count_protects == output.count("is already read protected")
175      def test_read_protect_efuse2(self):
176          self.espefuse_py("write_protect_efuse RD_DIS")
177          if arg_chip == "esp32":
178              efuse_name = "CODING_SCHEME"
179          elif arg_chip == "esp32c2":
180              efuse_name = "BLOCK_KEY0_HI_128"
181          else:
182              efuse_name = "BLOCK_SYS_DATA2"
183          self.espefuse_py(
184              f"read_protect_efuse {efuse_name}",
185              check_msg="A fatal error occurred: This efuse cannot be read-disabled "
186              "due the to RD_DIS field is already write-disabled",
187              ret_code=2,
188          )
189      @pytest.mark.skipif(arg_chip != "esp32", reason="when the purpose of BLOCK2 is set")
190      def test_read_protect_efuse3(self):
191          self.espefuse_py("burn_efuse ABS_DONE_1 1")
192          self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
193          self.espefuse_py(
194              "read_protect_efuse BLOCK2",
195              check_msg="Secure Boot V2 is on (ABS_DONE_1 = True), "
196              "BLOCK2 must be readable, stop this operation!",
197              ret_code=2,
198          )
199      def test_read_protect_efuse4(self):
200          if arg_chip == "esp32":
201              self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
202              msg = "must be readable, please stop this operation!"
203              self.espefuse_py("read_protect_efuse BLOCK2", check_msg=msg)
204          elif arg_chip == "esp32c2":
205              self.espefuse_py(
206                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
207              )
208              self.espefuse_py(
209                  "read_protect_efuse BLOCK_KEY0",
210                  check_msg="A fatal error occurred: "
211                  "BLOCK_KEY0 must be readable, stop this operation!",
212                  ret_code=2,
213              )
214          else:
215              self.espefuse_py(
216                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
217                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
218                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
219                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
220                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
221                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP"
222              )
223              self.espefuse_py(
224                  "read_protect_efuse BLOCK_KEY0",
225                  check_msg="A fatal error occurred: "
226                  "BLOCK_KEY0 must be readable, stop this operation!",
227                  ret_code=2,
228              )
229              self.espefuse_py(
230                  "read_protect_efuse BLOCK_KEY1",
231                  check_msg="A fatal error occurred: "
232                  "BLOCK_KEY1 must be readable, stop this operation!",
233                  ret_code=2,
234              )
235              self.espefuse_py(
236                  "read_protect_efuse BLOCK_KEY2",
237                  check_msg="A fatal error occurred: "
238                  "BLOCK_KEY2 must be readable, stop this operation!",
239                  ret_code=2,
240              )
241              self.espefuse_py(
242                  "read_protect_efuse BLOCK_KEY3",
243                  check_msg="A fatal error occurred: "
244                  "BLOCK_KEY3 must be readable, stop this operation!",
245                  ret_code=2,
246              )
247              self.espefuse_py(
248                  "read_protect_efuse BLOCK_KEY4",
249                  check_msg="A fatal error occurred: "
250                  "BLOCK_KEY4 must be readable, stop this operation!",
251                  ret_code=2,
252              )
253              self.espefuse_py("read_protect_efuse BLOCK_KEY5")
254      @pytest.mark.skipif(
255          arg_chip != "esp32",
256          reason="system parameters efuse read-protection is supported only by esp32, "
257          "other chips protect whole blocks",
258      )
259      def test_burn_and_read_protect_efuse(self):
260          self.espefuse_py(
261              "burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8",
262              check_msg="Efuse FLASH_CRYPT_CONFIG is read-protected. "
263              "Read back the burn value is not possible.",
264          )
265  class TestWriteProtectionCommands(EfuseTestCase):
266      def test_write_protect_efuse(self):
267          self.espefuse_py("write_protect_efuse -h")
268          if arg_chip == "esp32":
269              efuse_lists = 
270              efuse_lists2 = "WR_DIS RD_DIS"
271          elif arg_chip == "esp32c2":
272              efuse_lists = 
273              efuse_lists2 = "RD_DIS DIS_DOWNLOAD_ICACHE"
274          else:
275              efuse_lists = 
276              if arg_chip not in ["esp32h2", "esp32h2beta1"] and arg_chip not in [
277                  "esp32c6"
278              ]:
279                  efuse_lists += 
280              efuse_lists2 = "RD_DIS DIS_ICACHE"
281          self.espefuse_py(f"write_protect_efuse {efuse_lists}")
282          output = self.espefuse_py(f"write_protect_efuse {efuse_lists2}")
283          assert output.count("is already write protected") == 2
284      def test_write_protect_efuse2(self):
285          if arg_chip == "esp32":
286              self.espefuse_py("write_protect_efuse WR_DIS")
287              self.espefuse_py(
288                  "write_protect_efuse CODING_SCHEME",
289                  check_msg="A fatal error occurred: This efuse cannot be write-disabled "
290                  "due to the WR_DIS field is already write-disabled",
291                  ret_code=2,
292              )
293  class TestBurnCustomMacCommands(EfuseTestCase):
294      def test_burn_custom_mac(self):
295          self.espefuse_py("burn_custom_mac -h")
296          cmd = "burn_custom_mac AA:CD:EF:11:22:33"
297          mac = "aa:cd:ef:11:22:33"
298          if arg_chip == "esp32":
299              self.espefuse_py(
300                  cmd, check_msg=f"Custom MAC Address version 1: {mac} (CRC 0x63 OK)"
301              )
302          else:
303              self.espefuse_py(cmd, check_msg=f"Custom MAC Address: {mac} (OK)")
304      def test_burn_custom_mac2(self):
305          self.espefuse_py(
306              "burn_custom_mac AA:CD:EF:11:22:33:44",
307              check_msg="A fatal error occurred: MAC Address needs to be a 6-byte "
308              "hexadecimal format separated by colons (:)!",
309              ret_code=2,
310          )
311      def test_burn_custom_mac3(self):
312          self.espefuse_py(
313              "burn_custom_mac AB:CD:EF:11:22:33",
314              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
315              ret_code=2,
316          )
317      @pytest.mark.skipif(
318          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
319      )
320      def test_burn_custom_mac_with_34_coding_scheme(self):
321          self._set_34_coding_scheme()
322          self.espefuse_py("burn_custom_mac -h")
323          self.espefuse_py(
324              "burn_custom_mac AA:CD:EF:01:02:03",
325              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
326          )
327          self.espefuse_py(
328              "get_custom_mac",
329              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
330          )
331          self.espefuse_py(
332              "burn_custom_mac FE:22:33:44:55:66",
333              check_msg="New value contains some bits that cannot be cleared "
334              "(value will be 0x675745ffeffe)",
335              ret_code=2,
336          )
337  @pytest.mark.skipif(
338      arg_chip in ["esp32c2", "esp32h2beta1", "esp32c3", "esp32c6", "esp32h2"],
339      reason=f"TODO: add support set_flash_voltage for {arg_chip}",
340  )
341  class TestSetFlashVoltageCommands(EfuseTestCase):
342      def test_set_flash_voltage_1_8v(self):
343          self.espefuse_py("set_flash_voltage -h")
<span onclick='openModal()' class='match'>344          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
345          self.espefuse_py(
346              "set_flash_voltage 1.8V",
347              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
348          )
349          if arg_chip == "esp32":
</span>350              error_msg = "A fatal error occurred: "
351              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
352          else:
353              error_msg = "A fatal error occurred: "
354              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
355          self.espefuse_py(
356              "set_flash_voltage 3.3V",
357              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
358          )
359          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
360      def test_set_flash_voltage_3_3v(self):
361          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
362          self.espefuse_py(
363              "set_flash_voltage 3.3V",
364              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
365          )
366          if arg_chip == "esp32":
367              error_msg = "A fatal error occurred: "
368              "Can't set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned"
369          else:
370              error_msg = "A fatal error occurred: "
371              "Can't set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned"
372          self.espefuse_py("set_flash_voltage 1.8V", check_msg=error_msg, ret_code=2)
373          if arg_chip == "esp32":
374              error_msg = "A fatal error occurred: "
375              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
376          else:
377              error_msg = "A fatal error occurred: "
378              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
379          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
380      def test_set_flash_voltage_off(self):
381          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
382          self.espefuse_py(
383              "set_flash_voltage OFF",
384              check_msg=f"Disable internal flash voltage regulator ({vdd})",
385          )
386          self.espefuse_py(
387              "set_flash_voltage 3.3V",
388              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
389          )
390      def test_set_flash_voltage_off2(self):
391          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
392          self.espefuse_py(
393              "set_flash_voltage OFF",
394              check_msg=f"Disable internal flash voltage regulator ({vdd})",
395          )
396          self.espefuse_py(
397              "set_flash_voltage 1.8V",
398              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
399          )
400  @pytest.mark.skipif(arg_chip != "esp32c3", reason="Not necessary fo all chips")
401  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
402      def test_efuse_is_bool_given_none(self):
403          self.espefuse_py("burn_efuse SECURE_BOOT_KEY_REVOKE0")
404      def test_efuse_is_bool_given_0(self):
405          self.espefuse_py(
406              "burn_efuse SECURE_BOOT_KEY_REVOKE0 0",
407              check_msg="A fatal error occurred: "
408              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
409              "(will always burn 0->1), given value=0",
410              ret_code=2,
411          )
412      def test_efuse_is_bool_given_2(self):
413          self.espefuse_py(
414              "burn_efuse SECURE_BOOT_KEY_REVOKE0 2",
415              check_msg="A fatal error occurred: "
416              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
417              "(will always burn 0->1), given value=2",
418              ret_code=2,
419          )
420      def test_efuse_is_bytes_ok(self):
421          self.espefuse_py(
422              "burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678"
423          )
424      def test_efuse_is_bytes_given_short_val(self):
425          self.espefuse_py(
426              "burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678",
427              check_msg="A fatal error occurred: "
428              "The length of efuse 'OPTIONAL_UNIQUE_ID' (128 bits) "
429              "(given len of the new value= 64 bits)",
430              ret_code=2,
431          )
432      def test_efuse_is_bytes_given_none(self):
433          self.espefuse_py(
434              "burn_efuse OPTIONAL_UNIQUE_ID",
435              check_msg="A fatal error occurred: "
436              "New value required for efuse 'OPTIONAL_UNIQUE_ID' (given None)",
437              ret_code=2,
438          )
439      def test_efuse_is_int_ok(self):
440          self.espefuse_py("burn_efuse SPI_PAD_CONFIG_D 7")
441      def test_efuse_is_int_given_out_of_range_val(self):
442          self.espefuse_py(
443              "burn_efuse SPI_PAD_CONFIG_D 200",
444              check_msg="A fatal error occurred: "
445              "200 is too large an unsigned integer for a bitstring "
446              "of length 6. The allowed range is [0, 63].",
447              ret_code=2,
448          )
449      def test_efuse_is_int_given_none(self):
450          self.espefuse_py(
451              "burn_efuse SPI_PAD_CONFIG_D",
452              check_msg="A fatal error occurred: "
453              "New value required for efuse 'SPI_PAD_CONFIG_D' (given None)",
454              ret_code=2,
455          )
456      def test_efuse_is_int_given_0(self):
457          self.espefuse_py(
458              "burn_efuse SPI_PAD_CONFIG_D 0",
459              check_msg="A fatal error occurred: "
460              "New value should not be 0 for 'SPI_PAD_CONFIG_D' "
461              "(given value= 0)",
462              ret_code=2,
463          )
464      def test_efuse_is_bitcount_given_out_of_range_val(self):
465          self.espefuse_py(
466              "burn_efuse SPI_BOOT_CRYPT_CNT 9",
467              check_msg="A fatal error occurred: "
468              "9 is too large an unsigned integer for a bitstring "
469              "of length 3. The allowed range is [0, 7].",
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_increase_over_max(self):
473          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
474          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
475          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
476          self.espefuse_py(
477              "burn_efuse SPI_BOOT_CRYPT_CNT",
478              check_msg="A fatal error occurred: "
479              "15 is too large an unsigned integer for a bitstring "
480              "of length 3. The allowed range is [0, 7].",
481              ret_code=2,
482          )
483  class TestBurnEfuseCommands(EfuseTestCase):
484      @pytest.mark.skipif(
485          arg_chip != "esp32",
486          reason="IO pins 30 & 31 cannot be set for SPI flash only on esp32",
487      )
488      def test_set_spi_flash_pin_efuses(self):
489          self.espefuse_py(
490              "burn_efuse SPI_PAD_CONFIG_HD 30",
491              check_msg="A fatal error occurred: "
492              "IO pins 30 & 31 cannot be set for SPI flash. 0-29, 32 & 33 only.",
493              ret_code=2,
494          )
495          self.espefuse_py(
496              "burn_efuse SPI_PAD_CONFIG_Q 0x23",
497              check_msg="A fatal error occurred: "
498              "IO pin 35 cannot be set for SPI flash. 0-29, 32 & 33 only.",
499              ret_code=2,
500          )
501          output = self.espefuse_py("burn_efuse SPI_PAD_CONFIG_CS0 33")
502          assert "(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -> 0b11111" in output
503          assert "BURN BLOCK0  - OK (all write block bits are set)" in output
504      def test_burn_mac_custom_efuse(self):
505          crc_msg = "(OK)"
506          self.espefuse_py("burn_efuse -h")
507          if arg_chip == "esp32":
508              self.espefuse_py(
509                  "burn_efuse MAC AA:CD:EF:01:02:03",
510                  check_msg="Writing Factory MAC address is not supported",
511                  ret_code=2,
512              )
513              self.espefuse_py("burn_efuse MAC_VERSION 1")
514              crc_msg = "(CRC 0x56 OK)"
515          if arg_chip == "esp32c2":
516              self.espefuse_py("burn_efuse CUSTOM_MAC_USED 1")
517          self.espefuse_py("burn_efuse -h")
518          self.espefuse_py(
519              "burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03",
520              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
521              ret_code=2,
522          )
523          self.espefuse_py("burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03")
524          self.espefuse_py("get_custom_mac", check_msg=f"aa:cd:ef:01:02:03 {crc_msg}")
525      def test_burn_efuse(self):
526          self.espefuse_py("burn_efuse -h")
527          if arg_chip == "esp32":
528              self.espefuse_py(
529                  "burn_efuse \
530                  CHIP_VER_REV2 1 \
531                  DISABLE_DL_ENCRYPT 1 \
532                  CONSOLE_DEBUG_DISABLE 1"
533              )
534              blk1 = "BLOCK1"
535              blk2 = "BLOCK2"
536          elif arg_chip == "esp32c2":
537              self.espefuse_py(
538                  "burn_efuse \
539                  XTS_KEY_LENGTH_256 1 \
540                  UART_PRINT_CONTROL 1 \
541                  FORCE_SEND_RESUME 1"
542              )
543              blk1 = "BLOCK_KEY0"
544              blk2 = None
545          else:
546              self.espefuse_py(
547                  "burn_efuse \
548                  SECURE_BOOT_EN 1 \
549                  UART_PRINT_CONTROL 1"
550              )
551              self.espefuse_py(
552                  "burn_efuse \
553                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168",
554                  check_msg="-> 0x2328ad5ac9145f698f843a26d6eae168",
555              )
556              output = self.espefuse_py("summary -d")
557              assert (
558                  "read_regs: d6eae168 8f843a26 c9145f69 2328ad5a "
559                  "00000000 00000000 00000000 00000000"
560              ) in output
561              assert "= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W" in output
562              efuse_from_blk2 = "BLK_VERSION_MAJOR"
563              if arg_chip == "esp32s2":
564                  efuse_from_blk2 = "BLK_VERSION_MINOR"
565              if arg_chip != "esp32c6":
566                  self.espefuse_py(
567                      f"burn_efuse {efuse_from_blk2} 1",
568                      check_msg="Burn into BLOCK_SYS_DATA is forbidden "
569                      "(RS coding scheme does not allow this).",
570                      ret_code=2,
571                  )
572              blk1 = "BLOCK_KEY1"
573              blk2 = "BLOCK_KEY2"
574          output = self.espefuse_py(
575              f"burn_efuse {blk1}"
576              + " 0x00010203040506070809111111111111111111111111111111110000112233FF"
577          )
578          assert (
579              "-> 0x00010203040506070809111111111111111111111111111111110000112233ff"
580              in output
581          )
582          output = self.espefuse_py("summary -d")
583          assert (
584              "read_regs: 112233ff 11110000 11111111 11111111 "
585              "11111111 08091111 04050607 00010203"
586          ) in output
587          assert (
588              "= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 "
589              "11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W"
590          ) in output
591          if blk2 is not None:
592              output = self.espefuse_py(
593                  f"burn_efuse {blk2}"
594                  + " 00010203040506070809111111111111111111111111111111110000112233FF"
595              )
596              assert (
597                  "-> 0xff33221100001111111111111111111111111111111109080706050403020100"
598                  in output
599              )
600              output = self.espefuse_py("summary -d")
601              assert (
602                  "read_regs: 03020100 07060504 11110908 11111111 "
603                  "11111111 11111111 00001111 ff332211"
604              ) in output
605              assert (
606                  "= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 "
607                  "11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W"
608              ) in output
609      @pytest.mark.skipif(
610          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
611      )
612      def test_burn_efuse_with_34_coding_scheme(self):
613          self._set_34_coding_scheme()
614          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
615          self.espefuse_py("burn_efuse ADC1_TP_LOW 50")
616          self.espefuse_py(
617              "burn_efuse ADC1_TP_HIGH 55",
618              check_msg="Burn into BLOCK3 is forbidden "
619              "(3/4 coding scheme does not allow this)",
620              ret_code=2,
621          )
622      @pytest.mark.skipif(
623          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
624      )
625      def test_burn_efuse_with_34_coding_scheme2(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
628          self.espefuse_py(
629              "burn_efuse \
630              ADC1_TP_LOW 50 \
631              ADC1_TP_HIGH 55 \
632              ADC2_TP_LOW 40 \
633              ADC2_TP_HIGH 45"
634          )
635  class TestBurnKeyCommands(EfuseTestCase):
636      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
637      def test_burn_key_3_key_blocks(self):
638          self.espefuse_py("burn_key -h")
639          self.espefuse_py(
640              f"burn_key BLOCK1 {IMAGES_DIR}/192bit",
641              check_msg="A fatal error occurred: Incorrect key file size 24. "
642              "Key file must be 32 bytes (256 bits) of raw binary key data.",
643              ret_code=2,
644          )
645          self.espefuse_py(
646              f"burn_key \
647              BLOCK1 {IMAGES_DIR}/256bit \
648              BLOCK2 {IMAGES_DIR}/256bit_1 \
649              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key"
650          )
651          output = self.espefuse_py("summary -d")
652          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
653          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
654          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
655          self.espefuse_py(
656              f"burn_key \
657              BLOCK1 {IMAGES_DIR}/256bit \
658              BLOCK2 {IMAGES_DIR}/256bit_1 \
659              BLOCK3 {IMAGES_DIR}/256bit_2"
660          )
661          output = self.espefuse_py("summary -d")
662          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
663          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
664          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
665      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
666      def test_burn_key_1_key_block(self):
667          self.espefuse_py("burn_key -h")
668          self.espefuse_py(
669              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY",
670              check_msg="A fatal error occurred: Incorrect key file size 16. "
671              "Key file must be 32 bytes (256 bits) of raw binary key data.",
672              ret_code=2,
673          )
674          self.espefuse_py(
675              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect"
676          )
677          output = self.espefuse_py("summary -d")
678          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
679          self.espefuse_py(f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY")
680          output = self.espefuse_py("summary -d")
681          assert (
682              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
683              "00000000 00000000 00000000 00000000"
684          ) in output
685          assert (
686              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
687              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
688          ) in output
689      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
690      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
691          self.espefuse_py("burn_key -h")
692          self.espefuse_py(
693              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
694              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST",
695              check_msg="A fatal error occurred: These keypurposes are incompatible "
696              "['XTS_AES_128_KEY', 'SECURE_BOOT_DIGEST']",
697              ret_code=2,
698          )
699          self.espefuse_py(
700              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
701              f"XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
702              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect"
703          )
704          output = self.espefuse_py("summary -d")
705          assert (
706              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
707              "03020100 07060504 0b0a0908 0f0e0d0c"
708          ) in output
709          self.espefuse_py(
710              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
711              "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
712              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
713          )
714          output = self.espefuse_py("summary -d")
715          assert (
716              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
717              "03020100 07060504 0b0a0908 0f0e0d0c"
718          ) in output
719          assert (
720              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
721              "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-"
722          ) in output
723          assert "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
724          assert "= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-" in output
725      @pytest.mark.skipif(
726          arg_chip
727          not in [
728              "esp32s2",
729              "esp32s3",
730              "esp32s3beta1",
731              "esp32c3",
732              "esp32h2beta1",
733              "esp32c6",
734              "esp32h2",
735          ],
736          reason="Only chips with 6 keys",
737      )
738      def test_burn_key_with_6_keys(self):
739          cmd = f"burn_key \
740                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
741                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
742                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY"
743          if arg_chip in ["esp32c3", "esp32c6"] or arg_chip in [
744              "esp32h2",
745              "esp32h2beta1",
746          ]:
747              cmd = cmd.replace("XTS_AES_256_KEY_1", "XTS_AES_128_KEY")
748              cmd = cmd.replace("XTS_AES_256_KEY_2", "XTS_AES_128_KEY")
749          self.espefuse_py(cmd + " --no-read-protect --no-write-protect")
750          output = self.espefuse_py("summary -d")
751          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
752          self.check_data_block_in_log(
753              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
754          )
755          self.check_data_block_in_log(
756              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
757          )
758          self.espefuse_py(cmd)
759          output = self.espefuse_py("summary -d")
760          assert (
761              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
762              "00000000 00000000 00000000 00000000"
763          ) in output
764          assert (
765              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
766              "00000000 00000000 00000000 00000000"
767          ) in output
768          assert (
769              "[6 ] read_regs: 00000000 00000000 00000000 00000000 "
770              "00000000 00000000 00000000 00000000"
771          ) in output
772          self.espefuse_py(
773              f"burn_key \
774              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
775              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
776              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2"
777          )
778          output = self.espefuse_py("summary -d")
779          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
780          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
781          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
782      @pytest.mark.skipif(
783          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
784      )
785      def test_burn_key_with_34_coding_scheme(self):
786          self._set_34_coding_scheme()
787          self.espefuse_py(
788              f"burn_key BLOCK1 {IMAGES_DIR}/256bit",
789              check_msg="A fatal error occurred: Incorrect key file size 32. "
790              "Key file must be 24 bytes (192 bits) of raw binary key data.",
791              ret_code=2,
792          )
793          self.espefuse_py(
794              f"burn_key \
795              BLOCK1 {IMAGES_DIR}/192bit \
796              BLOCK2 {IMAGES_DIR}/192bit_1 \
797              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key"
798          )
799          output = self.espefuse_py("summary -d")
800          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
801          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
802          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
803          self.espefuse_py(
804              f"burn_key \
805              BLOCK1 {IMAGES_DIR}/192bit \
806              BLOCK2 {IMAGES_DIR}/192bit_1 \
807              BLOCK3 {IMAGES_DIR}/192bit_2"
808          )
809          output = self.espefuse_py("summary -d")
810          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
811          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
812          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
813      @pytest.mark.skipif(
814          arg_chip not in ["esp32s2", "esp32s3"],
815          reason="512 bit keys are only supported on ESP32-S2 and S3",
816      )
817      def test_burn_key_512bit(self):
818          self.espefuse_py(
819              f"burn_key \
820              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
821              XTS_AES_256_KEY --no-read-protect --no-write-protect"
822          )
823          output = self.espefuse_py("summary -d")
824          self.check_data_block_in_log(
825              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
826          )
827          self.check_data_block_in_log(
828              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
829          )
830      @pytest.mark.skipif(
831          arg_chip not in ["esp32s2", "esp32s3"],
832          reason="512 bit keys are only supported on ESP32-S2 and S3",
833      )
834      def test_burn_key_512bit_non_consecutive_blocks(self):
835          self.espefuse_py(
836              f"burn_key \
837              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY"
838          )
839          self.espefuse_py(
840              f"burn_key \
841              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0"
842          )
843          self.espefuse_py(
844              f"burn_key \
845              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
846              XTS_AES_256_KEY --no-read-protect --no-write-protect"
847          )
848          self.espefuse_py(
849              f"burn_key \
850              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect"
851          )
852          output = self.espefuse_py("summary -d")
853          self.check_data_block_in_log(
854              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
855          )
856          self.check_data_block_in_log(
857              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
858          )
859          assert (
860              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 "
861              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
862          ) in output
863          assert (
864              "[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 "
865              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
866          ) in output
867      @pytest.mark.skipif(
868          arg_chip not in ["esp32s2", "esp32s3"],
869          reason="512 bit keys are only supported on ESP32-S2 and S3",
870      )
871      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
872          self.espefuse_py(
873              f"burn_key \
874              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
875              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
876              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
877              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
878              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
879              XTS_AES_256_KEY --no-read-protect --no-write-protect"
880          )
881          output = self.espefuse_py("summary -d")
882          self.check_data_block_in_log(
883              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
884          )
885          self.check_data_block_in_log(
886              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
887          )
888          assert (
889              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 "
890              "acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
891          ) in output
892          assert (
893              "[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 "
894              "acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
895          ) in output
896      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
897      def test_burn_key_ecdsa_key(self):
898          self.espefuse_py(
899              f"burn_key \
900              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
901              ECDSA_KEY \
902              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
903              ECDSA_KEY"
904          )
905          output = self.espefuse_py("summary -d")
906          assert 2 == output.count(
907              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
908              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
909          )
910          assert (
911              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
912              "00000000 00000000 00000000 00000000"
913          ) in output
914          assert (
915              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
916              "00000000 00000000 00000000 00000000"
917          ) in output
918      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
919      def test_burn_key_ecdsa_key_check_byte_order(self):
920          self.espefuse_py(
921              f"burn_key \
922              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
923              ECDSA_KEY \
924              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
925              ECDSA_KEY \
926              --no-read-protect"
927          )
928          output = self.espefuse_py("summary -d")
929          assert (
930              "= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 "
931              "cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-"
932          ) in output
933          assert (
934              "= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b "
935              "38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-"
936          ) in output
937          assert (
938              "[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 "
939              "238123cb 4f71b795 00000000 00000000"
940          ) in output
941          assert (
942              "[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed "
943              "8450c238 c39d087a 90066a66 b4548b23"
944          ) in output
945  class TestBurnBlockDataCommands(EfuseTestCase):
946      def test_burn_block_data_check_args(self):
947          self.espefuse_py("burn_block_data -h")
948          blk0 = "BLOCK0"
949          blk1 = "BLOCK1"
950          self.espefuse_py(
951              f"burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}",
952              check_msg="A fatal error occurred: "
953              "The number of block_name (2) and datafile (1) should be the same.",
954              ret_code=2,
955          )
956      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
957      def test_burn_block_data_with_3_key_blocks(self):
958          self.espefuse_py(
959              f"burn_block_data \
960              BLOCK0 {IMAGES_DIR}/224bit \
961              BLOCK3 {IMAGES_DIR}/256bit"
962          )
963          output = self.espefuse_py("summary -d")
964          assert (
965              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
966              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
967          ) in output
968          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
969          self.espefuse_py(
970              f"burn_block_data \
971              BLOCK2 {IMAGES_DIR}/256bit_1"
972          )
973          self.check_data_block_in_log(
974              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
975          )
976          self.espefuse_py(
977              f"burn_block_data \
978              BLOCK1 {IMAGES_DIR}/256bit_2"
979          )
980          self.check_data_block_in_log(
981              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_2"
982          )
983      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
984      def test_burn_block_data_with_1_key_block(self):
985          self.espefuse_py(
986              f"burn_block_data \
987              BLOCK0 {IMAGES_DIR}/64bit \
988              BLOCK1 {IMAGES_DIR}/96bit \
989              BLOCK2 {IMAGES_DIR}/256bit \
990              BLOCK3 {IMAGES_DIR}/256bit"
991          )
992          output = self.espefuse_py("summary -d")
993          assert "[0 ] read_regs: 00000001 0000000c" in output
994          assert "[1 ] read_regs: 03020100 07060504 000a0908" in output
995          assert (
996              "[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
997              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
998          ) in output
999          assert (
1000              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1001              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1002          ) in output
1003      @pytest.mark.skipif(
1004          arg_chip
1005          not in [
1006              "esp32s2",
1007              "esp32s3",
1008              "esp32s3beta1",
1009              "esp32c3",
1010              "esp32h2beta1",
1011              "esp32c6",
1012              "esp32h2",
1013          ],
1014          reason="Only chip with 6 keys",
1015      )
1016      def test_burn_block_data_with_6_keys(self):
1017          self.espefuse_py(
1018              f"burn_block_data \
1019              BLOCK0 {IMAGES_DIR}/192bit \
1020              BLOCK3 {IMAGES_DIR}/256bit"
1021          )
1022          output = self.espefuse_py("summary -d")
1023          assert (
1024              "[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1025              in output
1026          )
1027          assert (
1028              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1029              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1030          ) in output
1031          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1032          self.espefuse_py(
1033              f"burn_block_data \
1034              BLOCK10 {IMAGES_DIR}/256bit_1"
1035          )
1036          self.check_data_block_in_log(
1037              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
1038          )
1039          self.espefuse_py(
1040              f"burn_block_data \
1041              BLOCK1 {IMAGES_DIR}/192bit \
1042              BLOCK5 {IMAGES_DIR}/256bit_1 \
1043              BLOCK6 {IMAGES_DIR}/256bit_2"
1044          )
1045          output = self.espefuse_py("summary -d")
1046          assert (
1047              "[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1048              in output
1049          )
1050          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1051          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1", 2)
1052          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
1053      def test_burn_block_data_check_errors(self):
1054          self.espefuse_py(
1055              f"burn_block_data \
1056              BLOCK2 {IMAGES_DIR}/192bit \
1057              BLOCK2 {IMAGES_DIR}/192bit_1",
1058              check_msg="A fatal error occurred: Found repeated",
1059              ret_code=2,
1060          )
1061          self.espefuse_py(
1062              f"burn_block_data \
1063              BLOCK2 {IMAGES_DIR}/192bit \
1064              BLOCK3 {IMAGES_DIR}/192bit_1 \
1065              --offset 4",
1066              check_msg="A fatal error occurred: "
1067              "The 'offset' option is not applicable when a few blocks are passed.",
1068              ret_code=2,
1069          )
1070          self.espefuse_py(
1071              f"burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33",
1072              check_msg="A fatal error occurred: Invalid offset: the block0 only holds",
1073              ret_code=2,
1074          )
1075          self.espefuse_py(
1076              f"burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4",
1077              check_msg="A fatal error occurred: Data does not fit:",
1078              ret_code=2,
1079          )
1080      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1081      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1082          offset = 1
1083          self.espefuse_py(
1084              f"burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit"
1085          )
1086          offset = 4
1087          self.espefuse_py(
1088              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1"
1089          )
1090          self.check_data_block_in_log(
1091              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1092          )
1093          offset = 6
1094          self.espefuse_py(
1095              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2"
1096          )
1097          self.check_data_block_in_log(
1098              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1099          )
1100          offset = 8
1101          self.espefuse_py(
1102              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1103          )
1104          self.check_data_block_in_log(
1105              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1106          )
1107      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1108      def test_burn_block_data_with_offset_1_key_block(self):
1109          offset = 4
1110          self.espefuse_py(f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit")
1111          output = self.espefuse_py("summary -d")
1112          assert "[1 ] read_regs: 00000000 03020100 00060504" in output
1113          offset = 6
1114          self.espefuse_py(
1115              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1"
1116          )
1117          output = self.espefuse_py("summary -d")
1118          assert (
1119              "[2 ] read_regs: 00000000 00110000 05000000 09080706 "
1120              "0d0c0b0a 11100f0e 15141312 00002116"
1121          ) in output
1122          offset = 8
1123          self.espefuse_py(
1124              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1125          )
1126          self.check_data_block_in_log(
1127              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1128          )
1129      @pytest.mark.skipif(
1130          arg_chip
1131          not in [
1132              "esp32s2",
1133              "esp32s3",
1134              "esp32s3beta1",
1135              "esp32c3",
1136              "esp32h2beta1",
1137              "esp32c6",
1138              "esp32h2",
1139          ],
1140          reason="Only chips with 6 keys",
1141      )
1142      def test_burn_block_data_with_offset_6_keys(self):
1143          offset = 4
1144          self.espefuse_py(
1145              f"burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1"
1146          )
1147          self.check_data_block_in_log(
1148              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1149          )
1150          offset = 6
1151          self.espefuse_py(
1152              f"burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2"
1153          )
1154          self.check_data_block_in_log(
1155              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1156          )
1157          offset = 8
1158          self.espefuse_py(
1159              f"burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2"
1160          )
1161          self.check_data_block_in_log(
1162              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1163          )
1164      @pytest.mark.skipif(
1165          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1166      )
1167      def test_burn_block_data_with_34_coding_scheme(self):
1168          self._set_34_coding_scheme()
1169          self.espefuse_py(
1170              f"burn_block_data BLOCK1 {IMAGES_DIR}/256bit",
1171              check_msg="A fatal error occurred: Data does not fit: "
1172              "the block1 size is 24 bytes, data file is 32 bytes, offset 0",
1173              ret_code=2,
1174          )
1175          self.espefuse_py(
1176              f"burn_block_data \
1177              BLOCK1 {IMAGES_DIR}/192bit \
1178              BLOCK2 {IMAGES_DIR}/192bit_1 \
1179              BLOCK3 {IMAGES_DIR}/192bit_2"
1180          )
1181          output = self.espefuse_py("summary -d")
1182          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
1183          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
1184          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
1185      @pytest.mark.skipif(
1186          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1187      )
1188      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1189          self._set_34_coding_scheme()
1190          offset = 4
1191          self.espefuse_py(
1192              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit"
1193          )
1194          self.check_data_block_in_log(
1195              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1196          )
1197          offset = 6
1198          self.espefuse_py(
1199              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit"
1200          )
1201          self.check_data_block_in_log(
1202              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1203          )
1204          offset = 8
1205          self.espefuse_py(
1206              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit"
1207          )
1208          self.check_data_block_in_log(
1209              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1210          )
1211  @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only, supports 2 key blocks")
1212  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1213      def test_burn_key_digest(self):
1214          self.espefuse_py("burn_key_digest -h")
1215          esp = self.get_esptool()
1216          if esp.get_chip_revision() >= 300:
1217              self.espefuse_py(
1218                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1219              )
1220              output = self.espefuse_py("summary -d")
1221              assert (
1222                  " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1223                  "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1224              ) in output
1225          else:
1226              self.espefuse_py(
1227                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1228                  check_msg="Incorrect chip revision for Secure boot v2.",
1229                  ret_code=2,
1230              )
1231      def test_burn_key_from_digest(self):
1232          self.espefuse_py(
1233              f"burn_key \
1234              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key"
1235          )
1236          output = self.espefuse_py("summary -d")
1237          assert 1 == output.count(
1238              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1239              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W"
1240          )
1241      def test_burn_key_digest_with_34_coding_scheme(self):
1242          self._set_34_coding_scheme()
1243          self.espefuse_py(
1244              f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1245              check_msg="burn_key_digest only works with 'None' coding scheme",
1246              ret_code=2,
1247          )
1248  @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only, supports 1 key block")
1249  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1250      def test_burn_key_digest1(self):
1251          self.espefuse_py("burn_key_digest -h")
1252          self.espefuse_py(
1253              f"burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem"
1254          )
1255          output = self.espefuse_py("summary -d")
1256          assert " = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-" in output
1257          assert (
1258              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1259              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1260          ) in output
1261      def test_burn_key_digest2(self):
1262          self.espefuse_py("burn_key_digest -h")
1263          self.espefuse_py(
1264              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem"
1265          )
1266          output = self.espefuse_py("summary -d")
1267          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1268          assert (
1269              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1270              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1271          ) in output
1272      def test_burn_key_from_digest1(self):
1273          self.espefuse_py(
1274              "burn_key BLOCK_KEY0 "
1275              f"{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1276          )
1277          output = self.espefuse_py("summary -d")
1278          assert (
1279              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1280              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1281          ) in output
1282      def test_burn_key_from_digest2(self):
1283          self.espefuse_py(
1284              "burn_key BLOCK_KEY0 "
1285              f"{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1286          )
1287          output = self.espefuse_py("summary -d")
1288          assert (
1289              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1290              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1291          ) in output
1292  @pytest.mark.skipif(
1293      arg_chip
1294      not in [
1295          "esp32s2",
1296          "esp32s3",
1297          "esp32s3beta1",
1298          "esp32c3",
1299          "esp32h2beta1",
1300          "esp32c6",
1301          "esp32h2",
1302      ],
1303      reason="Supports 6 key blocks",
1304  )
1305  class TestBurnKeyDigestCommands(EfuseTestCase):
1306      def test_burn_key_digest(self):
1307          self.espefuse_py("burn_key_digest -h")
1308          self.espefuse_py(
1309              f"burn_key_digest \
1310              BLOCK_KEY0 \
1311              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1312              BLOCK_KEY1 \
1313              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1314              BLOCK_KEY2 ",
1315              check_msg="A fatal error occurred: The number of blocks (3), "
1316              "datafile (2) and keypurpose (2) should be the same.",
1317              ret_code=2,
1318          )
1319          self.espefuse_py(
1320              f"burn_key_digest \
1321              BLOCK_KEY0 \
1322              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1323              BLOCK_KEY1 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1325              BLOCK_KEY2 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2"
1327          )
1328          output = self.espefuse_py("summary -d")
1329          assert 1 == output.count(
1330              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1331              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1332          )
1333          assert 2 == output.count(
1334              " = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 "
1335              "6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-"
1336          )
1337      def test_burn_key_from_digest(self):
1338          self.espefuse_py(
1339              f"burn_key \
1340              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1341          )
1342          output = self.espefuse_py("summary -d")
1343          assert 1 == output.count(
1344              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1345              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1346          )
1347          self.espefuse_py(
1348              f"burn_key_digest \
1349              BLOCK_KEY1 \
1350              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1"
1351          )
1352          output = self.espefuse_py("summary -d")
1353          assert 2 == output.count(
1354              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1355              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1356          )
1357  class TestBurnBitCommands(EfuseTestCase):
1358      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1359      def test_burn_bit_for_chips_with_3_key_blocks(self):
1360          self.espefuse_py("burn_bit -h")
1361          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1362          self.espefuse_py(
1363              "summary",
1364              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 "
1365              "00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1366          )
1367          self.espefuse_py(
1368              "burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254"
1369          )
1370          self.espefuse_py(
1371              "summary",
1372              check_msg="ff ff 01 80 01 00 00 80 01 00 00 80 01 "
1373              "00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0",
1374          )
1375      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1376      def test_burn_bit_for_chips_with_1_key_block(self):
1377          self.espefuse_py("burn_bit -h")
1378          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1379          self.espefuse_py(
1380              "summary",
1381              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1382              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1383          )
1384          self.espefuse_py(
1385              "burn_bit BLOCK3 100",
1386              check_msg="Burn into BLOCK_KEY0 is forbidden "
1387              "(RS coding scheme does not allow this)",
1388              ret_code=2,
1389          )
1390          self.espefuse_py("burn_bit BLOCK0 0 1 2")
1391          self.espefuse_py("summary", check_msg="[0 ] read_regs: 00000007 00000000")
1392      @pytest.mark.skipif(
1393          arg_chip
1394          not in [
1395              "esp32s2",
1396              "esp32s3",
1397              "esp32s3beta1",
1398              "esp32c3",
1399              "esp32h2beta1",
1400              "esp32c6",
1401              "esp32h2",
1402          ],
1403          reason="Only chip with 6 keys",
1404      )
1405      def test_burn_bit_for_chips_with_6_key_blocks(self):
1406          self.espefuse_py("burn_bit -h")
1407          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1408          self.espefuse_py(
1409              "summary",
1410              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1411              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1412          )
1413          self.espefuse_py(
1414              "burn_bit BLOCK3 100",
1415              check_msg="Burn into BLOCK_USR_DATA is forbidden "
1416              "(RS coding scheme does not allow this)",
1417              ret_code=2,
1418          )
1419          self.espefuse_py("burn_bit BLOCK0 13")
1420          self.espefuse_py(
1421              "summary",
1422              check_msg="[0 ] read_regs: 00002000 00000000 00000000 "
1423              "00000000 00000000 00000000",
1424          )
1425          self.espefuse_py("burn_bit BLOCK0 24")
1426          self.espefuse_py(
1427              "summary",
1428              check_msg="[0 ] read_regs: 01002000 00000000 00000000 "
1429              "00000000 00000000 00000000",
1430          )
1431      @pytest.mark.skipif(
1432          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1433      )
1434      def test_burn_bit_with_34_coding_scheme(self):
1435          self._set_34_coding_scheme()
1436          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191")
1437          self.espefuse_py(
1438              "summary",
1439              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1440              "00 00 01 00 00 00 01 00 00 80",
1441          )
1442          self.espefuse_py(
1443              "burn_bit BLOCK3 17",
1444              check_msg="Burn into BLOCK3 is forbidden "
1445              "(3/4 coding scheme does not allow this).",
1446              ret_code=2,
1447          )
1448  @pytest.mark.skipif(
1449      arg_chip != "esp32", reason="Tests are only for esp32. (TODO: add for all chips)"
1450  )
1451  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1452      def test_1_secure_boot_v1(self):
1453          if arg_chip == "esp32":
1454              self.espefuse_py(
1455                  f"burn_key \
1456                  flash_encryption {IMAGES_DIR}/256bit \
1457                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key"
1458              )
1459              output = self.espefuse_py("summary -d")
1460              self.check_data_block_in_log(
1461                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1462              )
1463              self.check_data_block_in_log(
1464                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
1465              )
1466              self.espefuse_py(
1467                  f"burn_key \
1468                  flash_encryption  {IMAGES_DIR}/256bit \
1469                  secure_boot_v1    {IMAGES_DIR}/256bit_1"
1470              )
1471              output = self.espefuse_py("summary -d")
1472              assert (
1473                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1474                  "00000000 00000000 00000000 00000000"
1475              ) in output
1476              assert (
1477                  "[2 ] read_regs: 00000000 00000000 00000000 00000000 "
1478                  "00000000 00000000 00000000 00000000"
1479              ) in output
1480              assert (
1481                  "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1482                  "00000000 00000000 00000000 00000000"
1483              ) in output
1484      def test_2_secure_boot_v1(self):
1485          if arg_chip == "esp32":
1486              self.espefuse_py(
1487                  f"burn_key \
1488                  flash_encryption {IMAGES_DIR}/256bit \
1489                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key"
1490              )
1491              output = self.espefuse_py("summary -d")
1492              self.check_data_block_in_log(
1493                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1494              )
1495              self.check_data_block_in_log(
1496                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1497              )
1498              self.espefuse_py(
1499                  f"burn_key \
1500                  flash_encryption {IMAGES_DIR}/256bit \
1501                  secure_boot_v2 {IMAGES_DIR}/256bit_1"
1502              )
1503              output = self.espefuse_py("summary -d")
1504              assert (
1505                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1506                  "00000000 00000000 00000000 00000000"
1507              ) in output
1508              self.check_data_block_in_log(
1509                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1510              )
1511  class TestExecuteScriptsCommands(EfuseTestCase):
1512      @classmethod
1513      def setup_class(self):
1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
1518      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1519      def test_execute_scripts_with_check_that_only_one_burn(self):
1520          self.espefuse_py("execute_scripts -h")
1521          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1522          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1523          self.espefuse_py("execute_scripts execute_efuse_script2.py")
1524      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1525      def test_execute_scripts_with_check(self):
1526          self.espefuse_py("execute_scripts -h")
1527          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1528          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1529          self.espefuse_py("execute_scripts execute_efuse_script.py")
1530      def test_execute_scripts_with_index_and_config(self):
1531          os.chdir(TEST_DIR)
1532          if arg_chip in ["esp32", "esp32c2"]:
1533              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1534              --configfiles {EFUSE_S_DIR}/esp32/config1.json"
1535          else:
1536              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1537              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json"
1538          self.espefuse_py(cmd)
1539          output = self.espefuse_py("summary -d")
1540          if arg_chip in ["esp32", "esp32c2"]:
1541              assert (
1542                  "[3 ] read_regs: e00007ff 00000000 00000000 00000000 "
1543                  "00000000 00000000 00000000 00000000"
1544              ) in output
1545          else:
1546              assert (
1547                  "[8 ] read_regs: e00007ff 00000000 00000000 00000000 "
1548                  "00000000 00000000 00000000 00000000"
1549              ) in output
1550      def test_execute_scripts_nesting(self):
1551          os.chdir(TEST_DIR)
1552          if arg_chip in ["esp32", "esp32c2"]:
1553              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1554              --configfiles {EFUSE_S_DIR}/esp32/config2.json"
1555          else:
1556              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1557              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json"
1558          self.espefuse_py(cmd)
1559          output = self.espefuse_py("summary -d")
1560          if arg_chip in ["esp32", "esp32c2"]:
1561              assert (
1562                  "[2 ] read_regs: 10000000 00000000 00000000 00000000 "
1563                  "00000000 00000000 00000000 00000000"
1564              ) in output
1565              assert (
1566                  "[3 ] read_regs: ffffffff 00000000 00000000 00000000 "
1567                  "00000000 00000000 00000000 00000000"
1568              ) in output
1569          else:
1570              assert (
1571                  "[7 ] read_regs: 10000000 00000000 00000000 00000000 "
1572                  "00000000 00000000 00000000 00000000"
1573              ) in output
1574              assert (
1575                  "[8 ] read_regs: ffffffff 00000000 00000000 00000000 "
1576                  "00000000 00000000 00000000 00000000"
1577              ) in output
1578  class TestMultipleCommands(EfuseTestCase):
1579      def test_multiple_cmds_help(self):
1580          if arg_chip == "esp32c2":
1581              command1 = (
1582                  f"burn_key_digest {S_IMAGES_DIR}"
1583                  "/ecdsa256_secure_boot_signing_key_v2.pem"
1584              )
1585              command2 = (
1586                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
1587                  "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS"
1588              )
1589          elif arg_chip == "esp32":
1590              command1 = f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1591              command2 = f"burn_key flash_encryption {IMAGES_DIR}/256bit"
1592          else:
1593              command1 = f"burn_key_digest BLOCK_KEY0 \
1594              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0"
1595              command2 = f"burn_key BLOCK_KEY0 \
1596              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1597          self.espefuse_py(
1598              f"-h {command1} {command2}",
1599              check_msg="usage: __main__.py [-h]",
1600          )
1601          self.espefuse_py(
1602              f"{command1} -h {command2}",
1603              check_msg="usage: __main__.py burn_key_digest [-h]",
1604          )
1605          self.espefuse_py(
1606              f"{command1} {command2} -h",
1607              check_msg="usage: __main__.py burn_key [-h]",
1608          )
1609      @pytest.mark.skipif(
1610          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1611      )
1612      def test_1_esp32c2(self):
1613          self.espefuse_py(
1614              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1615              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1616              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1617              summary"
1618          )
1619          output = self.espefuse_py("summary -d")
1620          assert (
1621              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
1622              "f66a0fbf 8b6dd38b a9dab353 040af633"
1623          ) in output
1624          assert " = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-" in output
1625          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1626      @pytest.mark.skipif(
1627          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1628      )
1629      def test_2_esp32c2(self):
1630          self.espefuse_py(
1631              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1632              burn_key BLOCK_KEY0 \
1633              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1634              summary"
1635          )
1636          output = self.espefuse_py("summary -d")
1637          assert (
1638              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1639              "f66a0fbf 8b6dd38b a9dab353 040af633"
1640          ) in output
1641          assert " = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
1642          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1643      def test_burn_bit(self):
1644          if arg_chip == "esp32":
1645              self._set_34_coding_scheme()
1646          self.espefuse_py(
1647              "burn_bit BLOCK2 0 1 2 3 \
1648              burn_bit BLOCK2 4 5 6 7 \
1649              burn_bit BLOCK2 8 9 10 11 \
1650              burn_bit BLOCK2 12 13 14 15 \
1651              summary"
1652          )
1653          output = self.espefuse_py("summary -d")
1654          assert "[2 ] read_regs: 0000ffff 00000000" in output
1655      def test_not_burn_cmds(self):
1656          self.espefuse_py(
1657              "summary \
1658              dump \
1659              get_custom_mac \
1660              adc_info \
1661              check_error"
1662          )
1663  @pytest.mark.skipif(
1664      arg_chip not in ["esp32c3", "esp32c6", "esp32h2", "esp32s3"],
1665      reason="These chips have a hardware bug that limits the use of the KEY5",
1666  )
1667  class TestKeyPurposes(EfuseTestCase):
1668      def test_burn_xts_aes_key_purpose(self):
1669          self.espefuse_py(
1670              "burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY",
1671              check_msg="A fatal error occurred: "
1672              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1673              "key due to a hardware bug (please see TRM for more details)",
1674              ret_code=2,
1675          )
1676      @pytest.mark.skipif(
1677          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1678      )
1679      def test_burn_ecdsa_key_purpose(self):
1680          self.espefuse_py(
1681              "burn_efuse KEY_PURPOSE_5 ECDSA_KEY",
1682              check_msg="A fatal error occurred: "
1683              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1684              "key due to a hardware bug (please see TRM for more details)",
1685              ret_code=2,
1686          )
1687      def test_burn_xts_aes_key(self):
1688          self.espefuse_py(
1689              f"burn_key \
1690              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY",
1691              check_msg="A fatal error occurred: "
1692              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1693              "key due to a hardware bug (please see TRM for more details)",
1694              ret_code=2,
1695          )
1696      @pytest.mark.skipif(
1697          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1698      )
1699      def test_burn_ecdsa_key(self):
1700          self.espefuse_py(
1701              f"burn_key \
1702              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1703              ECDSA_KEY",
1704              check_msg="A fatal error occurred: "
1705              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1706              "key due to a hardware bug (please see TRM for more details)",
1707              ret_code=2,
1708          )
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</h3>
            <pre><code>1  import os
2  import subprocess
3  import sys
4  import tempfile
5  import time
6  from bitstring import BitStream
7  from conftest import arg_chip, arg_port, arg_reset_port, need_to_install_package_err
8  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
9  IMAGES_DIR = os.path.join(TEST_DIR, "images", "efuse")
10  S_IMAGES_DIR = os.path.join(TEST_DIR, "secure_images")
11  EFUSE_S_DIR = os.path.join(TEST_DIR, "efuse_scripts")
12  import pytest
13  try:
14      from espefuse import SUPPORTED_CHIPS
15  except ImportError:
16      need_to_install_package_err()
17  SUPPORTED_CHIPS = list(SUPPORTED_CHIPS.keys())
18  import serial
19  reset_port = (
20      serial.Serial(arg_reset_port, 115200) if arg_reset_port is not None else None
21  )
22  if arg_chip not in SUPPORTED_CHIPS:
23      pytest.exit(f"{arg_chip} is not a supported target, choose from {SUPPORTED_CHIPS}")
24  print(f"\nHost tests of espefuse.py for {arg_chip}:")
25  print("Running espefuse.py tests...")
26  @pytest.mark.host_test
27  class EfuseTestCase:
28      def setup_method(self):
29          if reset_port is None:
30              self.efuse_file = tempfile.NamedTemporaryFile(delete=False)
31              self.base_cmd = (
32                  f"{sys.executable} -m espefuse --chip {arg_chip} "
33                  f"--virt --path-efuse-file {self.efuse_file.name} -d"
34              )
35          else:
36              self.base_cmd = (
37                  f"{sys.executable} -m espefuse --chip {arg_chip} "
38                  f"--port {arg_port} -d"
39              )
40              self.reset_efuses()
41      def teardown_method(self):
42          if reset_port is None:
43              self.efuse_file.close()
44              os.unlink(self.efuse_file.name)
45      def reset_efuses(self):
46          reset_port.dtr = False
47          reset_port.rts = False
48          time.sleep(0.05)
49          reset_port.dtr = True
50          reset_port.rts = True
51          time.sleep(0.05)
52          reset_port.dtr = False
53          reset_port.rts = False
54      def get_esptool(self):
55          if reset_port is not None:
56              import esptool
57              esp = esptool.cmds.detect_chip(port=arg_port)
58              del esptool
59          else:
60              import espefuse
61              efuse = espefuse.SUPPORTED_CHIPS[arg_chip].efuse_lib
62              esp = efuse.EmulateEfuseController(self.efuse_file.name)
63              del espefuse
64              del efuse
65          return esp
66      def _set_34_coding_scheme(self):
67          self.espefuse_py("burn_efuse CODING_SCHEME 1")
68      def check_data_block_in_log(
69          self, log, file_path, repeat=1, reverse_order=False, offset=0
70      ):
71          with open(file_path, "rb") as f:
72              data = BitStream("0x00") * offset + BitStream(f)
73              blk = data.readlist(f"{data.len // 8}*uint:8")
74              blk = blk[::-1] if reverse_order else blk
75              hex_blk = " ".join(f"{num:02x}" for num in blk)
76              assert repeat == log.count(hex_blk)
77      def espefuse_not_virt_py(self, cmd, check_msg=None, ret_code=0):
78          full_cmd = " ".join((f"{sys.executable} -m espefuse", cmd))
79          return self._run_command(full_cmd, check_msg, ret_code)
80      def espefuse_py(self, cmd, do_not_confirm=True, check_msg=None, ret_code=0):
81          full_cmd = " ".join(
82              [self.base_cmd, "--do-not-confirm" if do_not_confirm else "", cmd]
83          )
84          output = self._run_command(full_cmd, check_msg, ret_code)
85          self._run_command(
86              " ".join([self.base_cmd, "check_error"]), "No errors detected", 0
87          )
88          print(output)
89          return output
90      def _run_command(self, cmd, check_msg, ret_code):
91          try:
92              p = subprocess.Popen(
93                  cmd.split(),
94                  shell=False,
95                  stdin=subprocess.PIPE,
96                  stdout=subprocess.PIPE,
97                  universal_newlines=True,
98              )
99              output, _ = p.communicate()
100              returncode = p.returncode
101              if check_msg:
102                  assert check_msg in output
103              if returncode:
104                  print(output)
105                  print(cmd)
106              assert ret_code == returncode
107              return output
108          except subprocess.CalledProcessError as error:
109              print(error)
110              raise
111  class TestReadCommands(EfuseTestCase):
112      def test_help(self):
113          self.espefuse_not_virt_py("--help", check_msg="usage: __main__.py [-h]")
114          self.espefuse_not_virt_py(f"--chip {arg_chip} --help")
115      def test_help2(self):
116          self.espefuse_not_virt_py("", check_msg="usage: __main__.py [-h]", ret_code=1)
117      def test_dump(self):
118          self.espefuse_py("dump -h")
119          self.espefuse_py("dump")
120      def test_summary(self):
121          self.espefuse_py("summary -h")
122          self.espefuse_py("summary")
123      def test_summary_json(self):
124          self.espefuse_py("summary --format json")
125      def test_get_custom_mac(self):
126          self.espefuse_py("get_custom_mac -h")
127          if arg_chip == "esp32":
128              right_msg = "Custom MAC Address is not set in the device."
129          else:
130              right_msg = "Custom MAC Address: 00:00:00:00:00:00 (OK)"
131          self.espefuse_py("get_custom_mac", check_msg=right_msg)
132      def test_adc_info(self):
133          self.espefuse_py("adc_info -h")
134          self.espefuse_py("adc_info")
135      def test_check_error(self):
136          self.espefuse_py("check_error -h")
137          self.espefuse_py("check_error")
138          self.espefuse_py("check_error --recovery")
139  class TestReadProtectionCommands(EfuseTestCase):
140      def test_read_protect_efuse(self):
141          self.espefuse_py("read_protect_efuse -h")
142          if arg_chip == "esp32":
143              cmd = "read_protect_efuse \
144                     CODING_SCHEME \
145                     MAC_VERSION \
146                     BLOCK1 \
147                     BLOCK2 \
148                     BLOCK3"
149              count_protects = 5
150          elif arg_chip == "esp32c2":
151              cmd = "read_protect_efuse \
152                     BLOCK_KEY0_LOW_128"
153              count_protects = 1
154          else:
155              self.espefuse_py(
156                  "burn_efuse \
157                  KEY_PURPOSE_0 HMAC_UP \
158                  KEY_PURPOSE_1 XTS_AES_128_KEY \
159                  KEY_PURPOSE_2 XTS_AES_128_KEY \
160                  KEY_PURPOSE_3 HMAC_DOWN_ALL \
161                  KEY_PURPOSE_4 HMAC_DOWN_JTAG \
162                  KEY_PURPOSE_5 HMAC_DOWN_DIGITAL_SIGNATURE"
163              )
164              cmd = "read_protect_efuse \
165                     BLOCK_KEY0 \
166                     BLOCK_KEY1 \
167                     BLOCK_KEY2 \
168                     BLOCK_KEY3 \
169                     BLOCK_KEY4 \
170                     BLOCK_KEY5"
171              count_protects = 6
172          self.espefuse_py(cmd)
173          output = self.espefuse_py(cmd)
174          assert count_protects == output.count("is already read protected")
175      def test_read_protect_efuse2(self):
176          self.espefuse_py("write_protect_efuse RD_DIS")
177          if arg_chip == "esp32":
178              efuse_name = "CODING_SCHEME"
179          elif arg_chip == "esp32c2":
180              efuse_name = "BLOCK_KEY0_HI_128"
181          else:
182              efuse_name = "BLOCK_SYS_DATA2"
183          self.espefuse_py(
184              f"read_protect_efuse {efuse_name}",
185              check_msg="A fatal error occurred: This efuse cannot be read-disabled "
186              "due the to RD_DIS field is already write-disabled",
187              ret_code=2,
188          )
189      @pytest.mark.skipif(arg_chip != "esp32", reason="when the purpose of BLOCK2 is set")
190      def test_read_protect_efuse3(self):
191          self.espefuse_py("burn_efuse ABS_DONE_1 1")
192          self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
193          self.espefuse_py(
194              "read_protect_efuse BLOCK2",
195              check_msg="Secure Boot V2 is on (ABS_DONE_1 = True), "
196              "BLOCK2 must be readable, stop this operation!",
197              ret_code=2,
198          )
199      def test_read_protect_efuse4(self):
200          if arg_chip == "esp32":
201              self.espefuse_py(f"burn_key BLOCK2 {IMAGES_DIR}/256bit")
202              msg = "must be readable, please stop this operation!"
203              self.espefuse_py("read_protect_efuse BLOCK2", check_msg=msg)
204          elif arg_chip == "esp32c2":
205              self.espefuse_py(
206                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
207              )
208              self.espefuse_py(
209                  "read_protect_efuse BLOCK_KEY0",
210                  check_msg="A fatal error occurred: "
211                  "BLOCK_KEY0 must be readable, stop this operation!",
212                  ret_code=2,
213              )
214          else:
215              self.espefuse_py(
216                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit USER \
217                  BLOCK_KEY1 {IMAGES_DIR}/256bit RESERVED \
218                  BLOCK_KEY2 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
219                  BLOCK_KEY3 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
220                  BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST2 \
221                  BLOCK_KEY5 {IMAGES_DIR}/256bit HMAC_UP"
222              )
223              self.espefuse_py(
224                  "read_protect_efuse BLOCK_KEY0",
225                  check_msg="A fatal error occurred: "
226                  "BLOCK_KEY0 must be readable, stop this operation!",
227                  ret_code=2,
228              )
229              self.espefuse_py(
230                  "read_protect_efuse BLOCK_KEY1",
231                  check_msg="A fatal error occurred: "
232                  "BLOCK_KEY1 must be readable, stop this operation!",
233                  ret_code=2,
234              )
235              self.espefuse_py(
236                  "read_protect_efuse BLOCK_KEY2",
237                  check_msg="A fatal error occurred: "
238                  "BLOCK_KEY2 must be readable, stop this operation!",
239                  ret_code=2,
240              )
241              self.espefuse_py(
242                  "read_protect_efuse BLOCK_KEY3",
243                  check_msg="A fatal error occurred: "
244                  "BLOCK_KEY3 must be readable, stop this operation!",
245                  ret_code=2,
246              )
247              self.espefuse_py(
248                  "read_protect_efuse BLOCK_KEY4",
249                  check_msg="A fatal error occurred: "
250                  "BLOCK_KEY4 must be readable, stop this operation!",
251                  ret_code=2,
252              )
253              self.espefuse_py("read_protect_efuse BLOCK_KEY5")
254      @pytest.mark.skipif(
255          arg_chip != "esp32",
256          reason="system parameters efuse read-protection is supported only by esp32, "
257          "other chips protect whole blocks",
258      )
259      def test_burn_and_read_protect_efuse(self):
260          self.espefuse_py(
261              "burn_efuse FLASH_CRYPT_CONFIG 15 RD_DIS 8",
262              check_msg="Efuse FLASH_CRYPT_CONFIG is read-protected. "
263              "Read back the burn value is not possible.",
264          )
265  class TestWriteProtectionCommands(EfuseTestCase):
266      def test_write_protect_efuse(self):
267          self.espefuse_py("write_protect_efuse -h")
268          if arg_chip == "esp32":
269              efuse_lists = 
270              efuse_lists2 = "WR_DIS RD_DIS"
271          elif arg_chip == "esp32c2":
272              efuse_lists = 
273              efuse_lists2 = "RD_DIS DIS_DOWNLOAD_ICACHE"
274          else:
275              efuse_lists = 
276              if arg_chip not in ["esp32h2", "esp32h2beta1"] and arg_chip not in [
277                  "esp32c6"
278              ]:
279                  efuse_lists += 
280              efuse_lists2 = "RD_DIS DIS_ICACHE"
281          self.espefuse_py(f"write_protect_efuse {efuse_lists}")
282          output = self.espefuse_py(f"write_protect_efuse {efuse_lists2}")
283          assert output.count("is already write protected") == 2
284      def test_write_protect_efuse2(self):
285          if arg_chip == "esp32":
286              self.espefuse_py("write_protect_efuse WR_DIS")
287              self.espefuse_py(
288                  "write_protect_efuse CODING_SCHEME",
289                  check_msg="A fatal error occurred: This efuse cannot be write-disabled "
290                  "due to the WR_DIS field is already write-disabled",
291                  ret_code=2,
292              )
293  class TestBurnCustomMacCommands(EfuseTestCase):
294      def test_burn_custom_mac(self):
295          self.espefuse_py("burn_custom_mac -h")
296          cmd = "burn_custom_mac AA:CD:EF:11:22:33"
297          mac = "aa:cd:ef:11:22:33"
298          if arg_chip == "esp32":
299              self.espefuse_py(
300                  cmd, check_msg=f"Custom MAC Address version 1: {mac} (CRC 0x63 OK)"
301              )
302          else:
303              self.espefuse_py(cmd, check_msg=f"Custom MAC Address: {mac} (OK)")
304      def test_burn_custom_mac2(self):
305          self.espefuse_py(
306              "burn_custom_mac AA:CD:EF:11:22:33:44",
307              check_msg="A fatal error occurred: MAC Address needs to be a 6-byte "
308              "hexadecimal format separated by colons (:)!",
309              ret_code=2,
310          )
311      def test_burn_custom_mac3(self):
312          self.espefuse_py(
313              "burn_custom_mac AB:CD:EF:11:22:33",
314              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
315              ret_code=2,
316          )
317      @pytest.mark.skipif(
318          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
319      )
320      def test_burn_custom_mac_with_34_coding_scheme(self):
321          self._set_34_coding_scheme()
322          self.espefuse_py("burn_custom_mac -h")
323          self.espefuse_py(
324              "burn_custom_mac AA:CD:EF:01:02:03",
325              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
326          )
327          self.espefuse_py(
328              "get_custom_mac",
329              check_msg="Custom MAC Address version 1: aa:cd:ef:01:02:03 (CRC 0x56 OK)",
330          )
331          self.espefuse_py(
332              "burn_custom_mac FE:22:33:44:55:66",
333              check_msg="New value contains some bits that cannot be cleared "
334              "(value will be 0x675745ffeffe)",
335              ret_code=2,
336          )
337  @pytest.mark.skipif(
338      arg_chip in ["esp32c2", "esp32h2beta1", "esp32c3", "esp32c6", "esp32h2"],
339      reason=f"TODO: add support set_flash_voltage for {arg_chip}",
340  )
341  class TestSetFlashVoltageCommands(EfuseTestCase):
342      def test_set_flash_voltage_1_8v(self):
343          self.espefuse_py("set_flash_voltage -h")
344          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
345          self.espefuse_py(
346              "set_flash_voltage 1.8V",
347              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
348          )
349          if arg_chip == "esp32":
350              error_msg = "A fatal error occurred: "
351              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
352          else:
353              error_msg = "A fatal error occurred: "
354              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
355          self.espefuse_py(
356              "set_flash_voltage 3.3V",
357              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
358          )
359          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
360      def test_set_flash_voltage_3_3v(self):
<span onclick='openModal()' class='match'>361          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
362          self.espefuse_py(
363              "set_flash_voltage 3.3V",
364              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
365          )
366          if arg_chip == "esp32":
</span>367              error_msg = "A fatal error occurred: "
368              "Can't set regulator to 1.8V is XPD_SDIO_TIEH efuse is already burned"
369          else:
370              error_msg = "A fatal error occurred: "
371              "Can't set regulator to 1.8V is VDD_SPI_TIEH efuse is already burned"
372          self.espefuse_py("set_flash_voltage 1.8V", check_msg=error_msg, ret_code=2)
373          if arg_chip == "esp32":
374              error_msg = "A fatal error occurred: "
375              "Can't set flash regulator to OFF as XPD_SDIO_REG efuse is already burned"
376          else:
377              error_msg = "A fatal error occurred: "
378              "Can't set flash regulator to OFF as VDD_SPI_XPD efuse is already burned"
379          self.espefuse_py("set_flash_voltage OFF", check_msg=error_msg, ret_code=2)
380      def test_set_flash_voltage_off(self):
381          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
382          self.espefuse_py(
383              "set_flash_voltage OFF",
384              check_msg=f"Disable internal flash voltage regulator ({vdd})",
385          )
386          self.espefuse_py(
387              "set_flash_voltage 3.3V",
388              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
389          )
390      def test_set_flash_voltage_off2(self):
391          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
392          self.espefuse_py(
393              "set_flash_voltage OFF",
394              check_msg=f"Disable internal flash voltage regulator ({vdd})",
395          )
396          self.espefuse_py(
397              "set_flash_voltage 1.8V",
398              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
399          )
400  @pytest.mark.skipif(arg_chip != "esp32c3", reason="Not necessary fo all chips")
401  class TestValueArgForBurnEfuseCommands(EfuseTestCase):
402      def test_efuse_is_bool_given_none(self):
403          self.espefuse_py("burn_efuse SECURE_BOOT_KEY_REVOKE0")
404      def test_efuse_is_bool_given_0(self):
405          self.espefuse_py(
406              "burn_efuse SECURE_BOOT_KEY_REVOKE0 0",
407              check_msg="A fatal error occurred: "
408              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
409              "(will always burn 0->1), given value=0",
410              ret_code=2,
411          )
412      def test_efuse_is_bool_given_2(self):
413          self.espefuse_py(
414              "burn_efuse SECURE_BOOT_KEY_REVOKE0 2",
415              check_msg="A fatal error occurred: "
416              "New value is not accepted for efuse 'SECURE_BOOT_KEY_REVOKE0' "
417              "(will always burn 0->1), given value=2",
418              ret_code=2,
419          )
420      def test_efuse_is_bytes_ok(self):
421          self.espefuse_py(
422              "burn_efuse OPTIONAL_UNIQUE_ID 0x12345678123456781234567812345678"
423          )
424      def test_efuse_is_bytes_given_short_val(self):
425          self.espefuse_py(
426              "burn_efuse OPTIONAL_UNIQUE_ID 0x1234567812345678",
427              check_msg="A fatal error occurred: "
428              "The length of efuse 'OPTIONAL_UNIQUE_ID' (128 bits) "
429              "(given len of the new value= 64 bits)",
430              ret_code=2,
431          )
432      def test_efuse_is_bytes_given_none(self):
433          self.espefuse_py(
434              "burn_efuse OPTIONAL_UNIQUE_ID",
435              check_msg="A fatal error occurred: "
436              "New value required for efuse 'OPTIONAL_UNIQUE_ID' (given None)",
437              ret_code=2,
438          )
439      def test_efuse_is_int_ok(self):
440          self.espefuse_py("burn_efuse SPI_PAD_CONFIG_D 7")
441      def test_efuse_is_int_given_out_of_range_val(self):
442          self.espefuse_py(
443              "burn_efuse SPI_PAD_CONFIG_D 200",
444              check_msg="A fatal error occurred: "
445              "200 is too large an unsigned integer for a bitstring "
446              "of length 6. The allowed range is [0, 63].",
447              ret_code=2,
448          )
449      def test_efuse_is_int_given_none(self):
450          self.espefuse_py(
451              "burn_efuse SPI_PAD_CONFIG_D",
452              check_msg="A fatal error occurred: "
453              "New value required for efuse 'SPI_PAD_CONFIG_D' (given None)",
454              ret_code=2,
455          )
456      def test_efuse_is_int_given_0(self):
457          self.espefuse_py(
458              "burn_efuse SPI_PAD_CONFIG_D 0",
459              check_msg="A fatal error occurred: "
460              "New value should not be 0 for 'SPI_PAD_CONFIG_D' "
461              "(given value= 0)",
462              ret_code=2,
463          )
464      def test_efuse_is_bitcount_given_out_of_range_val(self):
465          self.espefuse_py(
466              "burn_efuse SPI_BOOT_CRYPT_CNT 9",
467              check_msg="A fatal error occurred: "
468              "9 is too large an unsigned integer for a bitstring "
469              "of length 3. The allowed range is [0, 7].",
470              ret_code=2,
471          )
472      def test_efuse_is_bitcount_given_increase_over_max(self):
473          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
474          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
475          self.espefuse_py("burn_efuse SPI_BOOT_CRYPT_CNT")
476          self.espefuse_py(
477              "burn_efuse SPI_BOOT_CRYPT_CNT",
478              check_msg="A fatal error occurred: "
479              "15 is too large an unsigned integer for a bitstring "
480              "of length 3. The allowed range is [0, 7].",
481              ret_code=2,
482          )
483  class TestBurnEfuseCommands(EfuseTestCase):
484      @pytest.mark.skipif(
485          arg_chip != "esp32",
486          reason="IO pins 30 & 31 cannot be set for SPI flash only on esp32",
487      )
488      def test_set_spi_flash_pin_efuses(self):
489          self.espefuse_py(
490              "burn_efuse SPI_PAD_CONFIG_HD 30",
491              check_msg="A fatal error occurred: "
492              "IO pins 30 & 31 cannot be set for SPI flash. 0-29, 32 & 33 only.",
493              ret_code=2,
494          )
495          self.espefuse_py(
496              "burn_efuse SPI_PAD_CONFIG_Q 0x23",
497              check_msg="A fatal error occurred: "
498              "IO pin 35 cannot be set for SPI flash. 0-29, 32 & 33 only.",
499              ret_code=2,
500          )
501          output = self.espefuse_py("burn_efuse SPI_PAD_CONFIG_CS0 33")
502          assert "(Override SD_CMD pad (GPIO11/SPICS0)) 0b00000 -> 0b11111" in output
503          assert "BURN BLOCK0  - OK (all write block bits are set)" in output
504      def test_burn_mac_custom_efuse(self):
505          crc_msg = "(OK)"
506          self.espefuse_py("burn_efuse -h")
507          if arg_chip == "esp32":
508              self.espefuse_py(
509                  "burn_efuse MAC AA:CD:EF:01:02:03",
510                  check_msg="Writing Factory MAC address is not supported",
511                  ret_code=2,
512              )
513              self.espefuse_py("burn_efuse MAC_VERSION 1")
514              crc_msg = "(CRC 0x56 OK)"
515          if arg_chip == "esp32c2":
516              self.espefuse_py("burn_efuse CUSTOM_MAC_USED 1")
517          self.espefuse_py("burn_efuse -h")
518          self.espefuse_py(
519              "burn_efuse CUSTOM_MAC AB:CD:EF:01:02:03",
520              check_msg="A fatal error occurred: Custom MAC must be a unicast MAC!",
521              ret_code=2,
522          )
523          self.espefuse_py("burn_efuse CUSTOM_MAC AA:CD:EF:01:02:03")
524          self.espefuse_py("get_custom_mac", check_msg=f"aa:cd:ef:01:02:03 {crc_msg}")
525      def test_burn_efuse(self):
526          self.espefuse_py("burn_efuse -h")
527          if arg_chip == "esp32":
528              self.espefuse_py(
529                  "burn_efuse \
530                  CHIP_VER_REV2 1 \
531                  DISABLE_DL_ENCRYPT 1 \
532                  CONSOLE_DEBUG_DISABLE 1"
533              )
534              blk1 = "BLOCK1"
535              blk2 = "BLOCK2"
536          elif arg_chip == "esp32c2":
537              self.espefuse_py(
538                  "burn_efuse \
539                  XTS_KEY_LENGTH_256 1 \
540                  UART_PRINT_CONTROL 1 \
541                  FORCE_SEND_RESUME 1"
542              )
543              blk1 = "BLOCK_KEY0"
544              blk2 = None
545          else:
546              self.espefuse_py(
547                  "burn_efuse \
548                  SECURE_BOOT_EN 1 \
549                  UART_PRINT_CONTROL 1"
550              )
551              self.espefuse_py(
552                  "burn_efuse \
553                  OPTIONAL_UNIQUE_ID 0x2328ad5ac9145f698f843a26d6eae168",
554                  check_msg="-> 0x2328ad5ac9145f698f843a26d6eae168",
555              )
556              output = self.espefuse_py("summary -d")
557              assert (
558                  "read_regs: d6eae168 8f843a26 c9145f69 2328ad5a "
559                  "00000000 00000000 00000000 00000000"
560              ) in output
561              assert "= 68 e1 ea d6 26 3a 84 8f 69 5f 14 c9 5a ad 28 23 R/W" in output
562              efuse_from_blk2 = "BLK_VERSION_MAJOR"
563              if arg_chip == "esp32s2":
564                  efuse_from_blk2 = "BLK_VERSION_MINOR"
565              if arg_chip != "esp32c6":
566                  self.espefuse_py(
567                      f"burn_efuse {efuse_from_blk2} 1",
568                      check_msg="Burn into BLOCK_SYS_DATA is forbidden "
569                      "(RS coding scheme does not allow this).",
570                      ret_code=2,
571                  )
572              blk1 = "BLOCK_KEY1"
573              blk2 = "BLOCK_KEY2"
574          output = self.espefuse_py(
575              f"burn_efuse {blk1}"
576              + " 0x00010203040506070809111111111111111111111111111111110000112233FF"
577          )
578          assert (
579              "-> 0x00010203040506070809111111111111111111111111111111110000112233ff"
580              in output
581          )
582          output = self.espefuse_py("summary -d")
583          assert (
584              "read_regs: 112233ff 11110000 11111111 11111111 "
585              "11111111 08091111 04050607 00010203"
586          ) in output
587          assert (
588              "= ff 33 22 11 00 00 11 11 11 11 11 11 11 11 11 11 "
589              "11 11 11 11 11 11 09 08 07 06 05 04 03 02 01 00 R/W"
590          ) in output
591          if blk2 is not None:
592              output = self.espefuse_py(
593                  f"burn_efuse {blk2}"
594                  + " 00010203040506070809111111111111111111111111111111110000112233FF"
595              )
596              assert (
597                  "-> 0xff33221100001111111111111111111111111111111109080706050403020100"
598                  in output
599              )
600              output = self.espefuse_py("summary -d")
601              assert (
602                  "read_regs: 03020100 07060504 11110908 11111111 "
603                  "11111111 11111111 00001111 ff332211"
604              ) in output
605              assert (
606                  "= 00 01 02 03 04 05 06 07 08 09 11 11 11 11 11 11 "
607                  "11 11 11 11 11 11 11 11 11 11 00 00 11 22 33 ff R/W"
608              ) in output
609      @pytest.mark.skipif(
610          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
611      )
612      def test_burn_efuse_with_34_coding_scheme(self):
613          self._set_34_coding_scheme()
614          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
615          self.espefuse_py("burn_efuse ADC1_TP_LOW 50")
616          self.espefuse_py(
617              "burn_efuse ADC1_TP_HIGH 55",
618              check_msg="Burn into BLOCK3 is forbidden "
619              "(3/4 coding scheme does not allow this)",
620              ret_code=2,
621          )
622      @pytest.mark.skipif(
623          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
624      )
625      def test_burn_efuse_with_34_coding_scheme2(self):
626          self._set_34_coding_scheme()
627          self.espefuse_py("burn_efuse BLK3_PART_RESERVE 1")
628          self.espefuse_py(
629              "burn_efuse \
630              ADC1_TP_LOW 50 \
631              ADC1_TP_HIGH 55 \
632              ADC2_TP_LOW 40 \
633              ADC2_TP_HIGH 45"
634          )
635  class TestBurnKeyCommands(EfuseTestCase):
636      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
637      def test_burn_key_3_key_blocks(self):
638          self.espefuse_py("burn_key -h")
639          self.espefuse_py(
640              f"burn_key BLOCK1 {IMAGES_DIR}/192bit",
641              check_msg="A fatal error occurred: Incorrect key file size 24. "
642              "Key file must be 32 bytes (256 bits) of raw binary key data.",
643              ret_code=2,
644          )
645          self.espefuse_py(
646              f"burn_key \
647              BLOCK1 {IMAGES_DIR}/256bit \
648              BLOCK2 {IMAGES_DIR}/256bit_1 \
649              BLOCK3 {IMAGES_DIR}/256bit_2 --no-protect-key"
650          )
651          output = self.espefuse_py("summary -d")
652          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
653          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
654          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
655          self.espefuse_py(
656              f"burn_key \
657              BLOCK1 {IMAGES_DIR}/256bit \
658              BLOCK2 {IMAGES_DIR}/256bit_1 \
659              BLOCK3 {IMAGES_DIR}/256bit_2"
660          )
661          output = self.espefuse_py("summary -d")
662          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
663          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
664          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
665      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
666      def test_burn_key_1_key_block(self):
667          self.espefuse_py("burn_key -h")
668          self.espefuse_py(
669              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit XTS_AES_128_KEY",
670              check_msg="A fatal error occurred: Incorrect key file size 16. "
671              "Key file must be 32 bytes (256 bits) of raw binary key data.",
672              ret_code=2,
673          )
674          self.espefuse_py(
675              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY --no-read-protect"
676          )
677          output = self.espefuse_py("summary -d")
678          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
679          self.espefuse_py(f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY")
680          output = self.espefuse_py("summary -d")
681          assert (
682              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
683              "00000000 00000000 00000000 00000000"
684          ) in output
685          assert (
686              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
687              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
688          ) in output
689      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
690      def test_burn_key_one_key_block_with_fe_and_sb_keys(self):
691          self.espefuse_py("burn_key -h")
692          self.espefuse_py(
693              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
694              BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST",
695              check_msg="A fatal error occurred: These keypurposes are incompatible "
696              "['XTS_AES_128_KEY', 'SECURE_BOOT_DIGEST']",
697              ret_code=2,
698          )
699          self.espefuse_py(
700              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
701              f"XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
702              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST --no-read-protect"
703          )
704          output = self.espefuse_py("summary -d")
705          assert (
706              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
707              "03020100 07060504 0b0a0908 0f0e0d0c"
708          ) in output
709          self.espefuse_py(
710              f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
711              "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS "
712              f"BLOCK_KEY0 {IMAGES_DIR}/128bit_key SECURE_BOOT_DIGEST"
713          )
714          output = self.espefuse_py("summary -d")
715          assert (
716              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
717              "03020100 07060504 0b0a0908 0f0e0d0c"
718          ) in output
719          assert (
720              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
721              "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f -/-"
722          ) in output
723          assert "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
724          assert "= 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f R/-" in output
725      @pytest.mark.skipif(
726          arg_chip
727          not in [
728              "esp32s2",
729              "esp32s3",
730              "esp32s3beta1",
731              "esp32c3",
732              "esp32h2beta1",
733              "esp32c6",
734              "esp32h2",
735          ],
736          reason="Only chips with 6 keys",
737      )
738      def test_burn_key_with_6_keys(self):
739          cmd = f"burn_key \
740                 BLOCK_KEY0 {IMAGES_DIR}/256bit   XTS_AES_256_KEY_1 \
741                 BLOCK_KEY1 {IMAGES_DIR}/256bit_1 XTS_AES_256_KEY_2 \
742                 BLOCK_KEY2 {IMAGES_DIR}/256bit_2 XTS_AES_128_KEY"
743          if arg_chip in ["esp32c3", "esp32c6"] or arg_chip in [
744              "esp32h2",
745              "esp32h2beta1",
746          ]:
747              cmd = cmd.replace("XTS_AES_256_KEY_1", "XTS_AES_128_KEY")
748              cmd = cmd.replace("XTS_AES_256_KEY_2", "XTS_AES_128_KEY")
749          self.espefuse_py(cmd + " --no-read-protect --no-write-protect")
750          output = self.espefuse_py("summary -d")
751          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit", reverse_order=True)
752          self.check_data_block_in_log(
753              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
754          )
755          self.check_data_block_in_log(
756              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
757          )
758          self.espefuse_py(cmd)
759          output = self.espefuse_py("summary -d")
760          assert (
761              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
762              "00000000 00000000 00000000 00000000"
763          ) in output
764          assert (
765              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
766              "00000000 00000000 00000000 00000000"
767          ) in output
768          assert (
769              "[6 ] read_regs: 00000000 00000000 00000000 00000000 "
770              "00000000 00000000 00000000 00000000"
771          ) in output
772          self.espefuse_py(
773              f"burn_key \
774              BLOCK_KEY3 {IMAGES_DIR}/256bit   SECURE_BOOT_DIGEST0 \
775              BLOCK_KEY4 {IMAGES_DIR}/256bit_1 SECURE_BOOT_DIGEST1 \
776              BLOCK_KEY5 {IMAGES_DIR}/256bit_2 SECURE_BOOT_DIGEST2"
777          )
778          output = self.espefuse_py("summary -d")
779          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
780          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1")
781          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
782      @pytest.mark.skipif(
783          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
784      )
785      def test_burn_key_with_34_coding_scheme(self):
786          self._set_34_coding_scheme()
787          self.espefuse_py(
788              f"burn_key BLOCK1 {IMAGES_DIR}/256bit",
789              check_msg="A fatal error occurred: Incorrect key file size 32. "
790              "Key file must be 24 bytes (192 bits) of raw binary key data.",
791              ret_code=2,
792          )
793          self.espefuse_py(
794              f"burn_key \
795              BLOCK1 {IMAGES_DIR}/192bit \
796              BLOCK2 {IMAGES_DIR}/192bit_1 \
797              BLOCK3 {IMAGES_DIR}/192bit_2 --no-protect-key"
798          )
799          output = self.espefuse_py("summary -d")
800          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
801          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
802          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
803          self.espefuse_py(
804              f"burn_key \
805              BLOCK1 {IMAGES_DIR}/192bit \
806              BLOCK2 {IMAGES_DIR}/192bit_1 \
807              BLOCK3 {IMAGES_DIR}/192bit_2"
808          )
809          output = self.espefuse_py("summary -d")
810          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
811          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
812          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
813      @pytest.mark.skipif(
814          arg_chip not in ["esp32s2", "esp32s3"],
815          reason="512 bit keys are only supported on ESP32-S2 and S3",
816      )
817      def test_burn_key_512bit(self):
818          self.espefuse_py(
819              f"burn_key \
820              BLOCK_KEY0 {IMAGES_DIR}/256bit_1_256bit_2_combined \
821              XTS_AES_256_KEY --no-read-protect --no-write-protect"
822          )
823          output = self.espefuse_py("summary -d")
824          self.check_data_block_in_log(
825              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
826          )
827          self.check_data_block_in_log(
828              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
829          )
830      @pytest.mark.skipif(
831          arg_chip not in ["esp32s2", "esp32s3"],
832          reason="512 bit keys are only supported on ESP32-S2 and S3",
833      )
834      def test_burn_key_512bit_non_consecutive_blocks(self):
835          self.espefuse_py(
836              f"burn_key \
837              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY"
838          )
839          self.espefuse_py(
840              f"burn_key \
841              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0"
842          )
843          self.espefuse_py(
844              f"burn_key \
845              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
846              XTS_AES_256_KEY --no-read-protect --no-write-protect"
847          )
848          self.espefuse_py(
849              f"burn_key \
850              BLOCK_KEY5 {IMAGES_DIR}/256bit USER --no-read-protect --no-write-protect"
851          )
852          output = self.espefuse_py("summary -d")
853          self.check_data_block_in_log(
854              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
855          )
856          self.check_data_block_in_log(
857              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
858          )
859          assert (
860              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 "
861              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
862          ) in output
863          assert (
864              "[7 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 "
865              "b0b1b2b3 acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
866          ) in output
867      @pytest.mark.skipif(
868          arg_chip not in ["esp32s2", "esp32s3"],
869          reason="512 bit keys are only supported on ESP32-S2 and S3",
870      )
871      def test_burn_key_512bit_non_consecutive_blocks_loop_around(self):
872          self.espefuse_py(
873              f"burn_key \
874              BLOCK_KEY2 {IMAGES_DIR}/256bit XTS_AES_128_KEY \
875              BLOCK_KEY3 {IMAGES_DIR}/256bit USER \
876              BLOCK_KEY4 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST0 \
877              BLOCK_KEY5 {IMAGES_DIR}/256bit SECURE_BOOT_DIGEST1 \
878              BLOCK_KEY1 {IMAGES_DIR}/256bit_1_256bit_2_combined \
879              XTS_AES_256_KEY --no-read-protect --no-write-protect"
880          )
881          output = self.espefuse_py("summary -d")
882          self.check_data_block_in_log(
883              output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
884          )
885          self.check_data_block_in_log(
886              output, f"{IMAGES_DIR}/256bit_2", reverse_order=True
887          )
888          assert (
889              "[5 ] read_regs: bcbd11bf b8b9babb b4b5b6b7 b0b1b2b3 "
890              "acadaeaf a8a9aaab a4a5a6a7 11a1a2a3"
891          ) in output
892          assert (
893              "[4 ] read_regs: bcbd22bf b8b9babb b4b5b6b7 b0b1b2b3 "
894              "acadaeaf a8a9aaab a4a5a6a7 22a1a2a3"
895          ) in output
896      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
897      def test_burn_key_ecdsa_key(self):
898          self.espefuse_py(
899              f"burn_key \
900              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
901              ECDSA_KEY \
902              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
903              ECDSA_KEY"
904          )
905          output = self.espefuse_py("summary -d")
906          assert 2 == output.count(
907              "= ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? "
908              "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-"
909          )
910          assert (
911              "[4 ] read_regs: 00000000 00000000 00000000 00000000 "
912              "00000000 00000000 00000000 00000000"
913          ) in output
914          assert (
915              "[5 ] read_regs: 00000000 00000000 00000000 00000000 "
916              "00000000 00000000 00000000 00000000"
917          ) in output
918      @pytest.mark.skipif(arg_chip != "esp32h2", reason="Only for ESP32-H2 chips")
919      def test_burn_key_ecdsa_key_check_byte_order(self):
920          self.espefuse_py(
921              f"burn_key \
922              BLOCK_KEY0 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
923              ECDSA_KEY \
924              BLOCK_KEY1 {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
925              ECDSA_KEY \
926              --no-read-protect"
927          )
928          output = self.espefuse_py("summary -d")
929          assert (
930              "= c8 c4 5d 62 9e 05 05 bd cb 04 a4 7c 06 f5 86 14 "
931              "cb 23 81 23 95 b7 71 4f 00 00 00 00 00 00 00 00 R/-"
932          ) in output
933          assert (
934              "= fc 6b ec 75 64 37 7d 3b 88 8d 34 05 ed 91 06 1b "
935              "38 c2 50 84 7a 08 9d c3 66 6a 06 90 23 8b 54 b4 R/-"
936          ) in output
937          assert (
938              "[4 ] read_regs: 625dc4c8 bd05059e 7ca404cb 1486f506 "
939              "238123cb 4f71b795 00000000 00000000"
940          ) in output
941          assert (
942              "[5 ] read_regs: 75ec6bfc 3b7d3764 05348d88 1b0691ed "
943              "8450c238 c39d087a 90066a66 b4548b23"
944          ) in output
945  class TestBurnBlockDataCommands(EfuseTestCase):
946      def test_burn_block_data_check_args(self):
947          self.espefuse_py("burn_block_data -h")
948          blk0 = "BLOCK0"
949          blk1 = "BLOCK1"
950          self.espefuse_py(
951              f"burn_block_data {blk0} {IMAGES_DIR}/224bit {blk1}",
952              check_msg="A fatal error occurred: "
953              "The number of block_name (2) and datafile (1) should be the same.",
954              ret_code=2,
955          )
956      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
957      def test_burn_block_data_with_3_key_blocks(self):
958          self.espefuse_py(
959              f"burn_block_data \
960              BLOCK0 {IMAGES_DIR}/224bit \
961              BLOCK3 {IMAGES_DIR}/256bit"
962          )
963          output = self.espefuse_py("summary -d")
964          assert (
965              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
966              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
967          ) in output
968          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
969          self.espefuse_py(
970              f"burn_block_data \
971              BLOCK2 {IMAGES_DIR}/256bit_1"
972          )
973          self.check_data_block_in_log(
974              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
975          )
976          self.espefuse_py(
977              f"burn_block_data \
978              BLOCK1 {IMAGES_DIR}/256bit_2"
979          )
980          self.check_data_block_in_log(
981              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_2"
982          )
983      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
984      def test_burn_block_data_with_1_key_block(self):
985          self.espefuse_py(
986              f"burn_block_data \
987              BLOCK0 {IMAGES_DIR}/64bit \
988              BLOCK1 {IMAGES_DIR}/96bit \
989              BLOCK2 {IMAGES_DIR}/256bit \
990              BLOCK3 {IMAGES_DIR}/256bit"
991          )
992          output = self.espefuse_py("summary -d")
993          assert "[0 ] read_regs: 00000001 0000000c" in output
994          assert "[1 ] read_regs: 03020100 07060504 000a0908" in output
995          assert (
996              "[2 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
997              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
998          ) in output
999          assert (
1000              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1001              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1002          ) in output
1003      @pytest.mark.skipif(
1004          arg_chip
1005          not in [
1006              "esp32s2",
1007              "esp32s3",
1008              "esp32s3beta1",
1009              "esp32c3",
1010              "esp32h2beta1",
1011              "esp32c6",
1012              "esp32h2",
1013          ],
1014          reason="Only chip with 6 keys",
1015      )
1016      def test_burn_block_data_with_6_keys(self):
1017          self.espefuse_py(
1018              f"burn_block_data \
1019              BLOCK0 {IMAGES_DIR}/192bit \
1020              BLOCK3 {IMAGES_DIR}/256bit"
1021          )
1022          output = self.espefuse_py("summary -d")
1023          assert (
1024              "[0 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1025              in output
1026          )
1027          assert (
1028              "[3 ] read_regs: a3a2a1a0 a7a6a5a4 abaaa9a8 afaeadac "
1029              "b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc"
1030          ) in output
1031          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1032          self.espefuse_py(
1033              f"burn_block_data \
1034              BLOCK10 {IMAGES_DIR}/256bit_1"
1035          )
1036          self.check_data_block_in_log(
1037              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/256bit_1"
1038          )
1039          self.espefuse_py(
1040              f"burn_block_data \
1041              BLOCK1 {IMAGES_DIR}/192bit \
1042              BLOCK5 {IMAGES_DIR}/256bit_1 \
1043              BLOCK6 {IMAGES_DIR}/256bit_2"
1044          )
1045          output = self.espefuse_py("summary -d")
1046          assert (
1047              "[1 ] read_regs: 00000000 07060500 00000908 00000000 13000000 00161514"
1048              in output
1049          )
1050          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit")
1051          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_1", 2)
1052          self.check_data_block_in_log(output, f"{IMAGES_DIR}/256bit_2")
1053      def test_burn_block_data_check_errors(self):
1054          self.espefuse_py(
1055              f"burn_block_data \
1056              BLOCK2 {IMAGES_DIR}/192bit \
1057              BLOCK2 {IMAGES_DIR}/192bit_1",
1058              check_msg="A fatal error occurred: Found repeated",
1059              ret_code=2,
1060          )
1061          self.espefuse_py(
1062              f"burn_block_data \
1063              BLOCK2 {IMAGES_DIR}/192bit \
1064              BLOCK3 {IMAGES_DIR}/192bit_1 \
1065              --offset 4",
1066              check_msg="A fatal error occurred: "
1067              "The 'offset' option is not applicable when a few blocks are passed.",
1068              ret_code=2,
1069          )
1070          self.espefuse_py(
1071              f"burn_block_data BLOCK0 {IMAGES_DIR}/192bit --offset 33",
1072              check_msg="A fatal error occurred: Invalid offset: the block0 only holds",
1073              ret_code=2,
1074          )
1075          self.espefuse_py(
1076              f"burn_block_data BLOCK0 {IMAGES_DIR}/256bit --offset 4",
1077              check_msg="A fatal error occurred: Data does not fit:",
1078              ret_code=2,
1079          )
1080      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1081      def test_burn_block_data_with_offset_for_3_key_blocks(self):
1082          offset = 1
1083          self.espefuse_py(
1084              f"burn_block_data --offset {offset} BLOCK0 {IMAGES_DIR}/192bit"
1085          )
1086          offset = 4
1087          self.espefuse_py(
1088              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/192bit_1"
1089          )
1090          self.check_data_block_in_log(
1091              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1092          )
1093          offset = 6
1094          self.espefuse_py(
1095              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_2"
1096          )
1097          self.check_data_block_in_log(
1098              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1099          )
1100          offset = 8
1101          self.espefuse_py(
1102              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1103          )
1104          self.check_data_block_in_log(
1105              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1106          )
1107      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1108      def test_burn_block_data_with_offset_1_key_block(self):
1109          offset = 4
1110          self.espefuse_py(f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/92bit")
1111          output = self.espefuse_py("summary -d")
1112          assert "[1 ] read_regs: 00000000 03020100 00060504" in output
1113          offset = 6
1114          self.espefuse_py(
1115              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/192bit_1"
1116          )
1117          output = self.espefuse_py("summary -d")
1118          assert (
1119              "[2 ] read_regs: 00000000 00110000 05000000 09080706 "
1120              "0d0c0b0a 11100f0e 15141312 00002116"
1121          ) in output
1122          offset = 8
1123          self.espefuse_py(
1124              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/192bit_2"
1125          )
1126          self.check_data_block_in_log(
1127              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1128          )
1129      @pytest.mark.skipif(
1130          arg_chip
1131          not in [
1132              "esp32s2",
1133              "esp32s3",
1134              "esp32s3beta1",
1135              "esp32c3",
1136              "esp32h2beta1",
1137              "esp32c6",
1138              "esp32h2",
1139          ],
1140          reason="Only chips with 6 keys",
1141      )
1142      def test_burn_block_data_with_offset_6_keys(self):
1143          offset = 4
1144          self.espefuse_py(
1145              f"burn_block_data --offset {offset} BLOCK_KEY0 {IMAGES_DIR}/192bit_1"
1146          )
1147          self.check_data_block_in_log(
1148              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_1", offset=offset
1149          )
1150          offset = 6
1151          self.espefuse_py(
1152              f"burn_block_data --offset {offset} BLOCK_KEY1 {IMAGES_DIR}/192bit_2"
1153          )
1154          self.check_data_block_in_log(
1155              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1156          )
1157          offset = 8
1158          self.espefuse_py(
1159              f"burn_block_data --offset {offset} BLOCK_KEY2 {IMAGES_DIR}/192bit_2"
1160          )
1161          self.check_data_block_in_log(
1162              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/192bit_2", offset=offset
1163          )
1164      @pytest.mark.skipif(
1165          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1166      )
1167      def test_burn_block_data_with_34_coding_scheme(self):
1168          self._set_34_coding_scheme()
1169          self.espefuse_py(
1170              f"burn_block_data BLOCK1 {IMAGES_DIR}/256bit",
1171              check_msg="A fatal error occurred: Data does not fit: "
1172              "the block1 size is 24 bytes, data file is 32 bytes, offset 0",
1173              ret_code=2,
1174          )
1175          self.espefuse_py(
1176              f"burn_block_data \
1177              BLOCK1 {IMAGES_DIR}/192bit \
1178              BLOCK2 {IMAGES_DIR}/192bit_1 \
1179              BLOCK3 {IMAGES_DIR}/192bit_2"
1180          )
1181          output = self.espefuse_py("summary -d")
1182          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit")
1183          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_1")
1184          self.check_data_block_in_log(output, f"{IMAGES_DIR}/192bit_2")
1185      @pytest.mark.skipif(
1186          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1187      )
1188      def test_burn_block_data_with_34_coding_scheme_and_offset(self):
1189          self._set_34_coding_scheme()
1190          offset = 4
1191          self.espefuse_py(
1192              f"burn_block_data --offset {offset} BLOCK1 {IMAGES_DIR}/128bit"
1193          )
1194          self.check_data_block_in_log(
1195              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1196          )
1197          offset = 6
1198          self.espefuse_py(
1199              f"burn_block_data --offset {offset} BLOCK2 {IMAGES_DIR}/128bit"
1200          )
1201          self.check_data_block_in_log(
1202              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1203          )
1204          offset = 8
1205          self.espefuse_py(
1206              f"burn_block_data --offset {offset} BLOCK3 {IMAGES_DIR}/128bit"
1207          )
1208          self.check_data_block_in_log(
1209              self.espefuse_py("summary -d"), f"{IMAGES_DIR}/128bit", offset=offset
1210          )
1211  @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only, supports 2 key blocks")
1212  class TestBurnKeyDigestCommandsEsp32(EfuseTestCase):
1213      def test_burn_key_digest(self):
1214          self.espefuse_py("burn_key_digest -h")
1215          esp = self.get_esptool()
1216          if esp.get_chip_revision() >= 300:
1217              self.espefuse_py(
1218                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1219              )
1220              output = self.espefuse_py("summary -d")
1221              assert (
1222                  " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1223                  "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1224              ) in output
1225          else:
1226              self.espefuse_py(
1227                  f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1228                  check_msg="Incorrect chip revision for Secure boot v2.",
1229                  ret_code=2,
1230              )
1231      def test_burn_key_from_digest(self):
1232          self.espefuse_py(
1233              f"burn_key \
1234              BLOCK2 {S_IMAGES_DIR}/rsa_public_key_digest.bin --no-protect-key"
1235          )
1236          output = self.espefuse_py("summary -d")
1237          assert 1 == output.count(
1238              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1239              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/W"
1240          )
1241      def test_burn_key_digest_with_34_coding_scheme(self):
1242          self._set_34_coding_scheme()
1243          self.espefuse_py(
1244              f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem",
1245              check_msg="burn_key_digest only works with 'None' coding scheme",
1246              ret_code=2,
1247          )
1248  @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only, supports 1 key block")
1249  class TestBurnKeyDigestCommandsEsp32C2(EfuseTestCase):
1250      def test_burn_key_digest1(self):
1251          self.espefuse_py("burn_key_digest -h")
1252          self.espefuse_py(
1253              f"burn_key_digest {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem"
1254          )
1255          output = self.espefuse_py("summary -d")
1256          assert " = 1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-" in output
1257          assert (
1258              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1259              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1260          ) in output
1261      def test_burn_key_digest2(self):
1262          self.espefuse_py("burn_key_digest -h")
1263          self.espefuse_py(
1264              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem"
1265          )
1266          output = self.espefuse_py("summary -d")
1267          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1268          assert (
1269              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1270              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1271          ) in output
1272      def test_burn_key_from_digest1(self):
1273          self.espefuse_py(
1274              "burn_key BLOCK_KEY0 "
1275              f"{S_IMAGES_DIR}/ecdsa192_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1276          )
1277          output = self.espefuse_py("summary -d")
1278          assert (
1279              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1280              "1e 3d 15 16 96 ca 7f 22 a6 e8 8b d5 27 a0 3b 3b R/-"
1281          ) in output
1282      def test_burn_key_from_digest2(self):
1283          self.espefuse_py(
1284              "burn_key BLOCK_KEY0 "
1285              f"{S_IMAGES_DIR}/ecdsa256_public_key_digest_v2.bin SECURE_BOOT_DIGEST"
1286          )
1287          output = self.espefuse_py("summary -d")
1288          assert (
1289              " = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 "
1290              "bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-"
1291          ) in output
1292  @pytest.mark.skipif(
1293      arg_chip
1294      not in [
1295          "esp32s2",
1296          "esp32s3",
1297          "esp32s3beta1",
1298          "esp32c3",
1299          "esp32h2beta1",
1300          "esp32c6",
1301          "esp32h2",
1302      ],
1303      reason="Supports 6 key blocks",
1304  )
1305  class TestBurnKeyDigestCommands(EfuseTestCase):
1306      def test_burn_key_digest(self):
1307          self.espefuse_py("burn_key_digest -h")
1308          self.espefuse_py(
1309              f"burn_key_digest \
1310              BLOCK_KEY0 \
1311              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1312              BLOCK_KEY1 \
1313              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1314              BLOCK_KEY2 ",
1315              check_msg="A fatal error occurred: The number of blocks (3), "
1316              "datafile (2) and keypurpose (2) should be the same.",
1317              ret_code=2,
1318          )
1319          self.espefuse_py(
1320              f"burn_key_digest \
1321              BLOCK_KEY0 \
1322              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0 \
1323              BLOCK_KEY1 \
1324              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST1 \
1325              BLOCK_KEY2 \
1326              {S_IMAGES_DIR}/rsa_secure_boot_signing_key2.pem SECURE_BOOT_DIGEST2"
1327          )
1328          output = self.espefuse_py("summary -d")
1329          assert 1 == output.count(
1330              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1331              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1332          )
1333          assert 2 == output.count(
1334              " = 90 1a 74 09 23 8d 52 d4 cb f9 6f 56 3f b3 f4 29 "
1335              "6d ab d6 6a 33 f5 3b 15 ee cd 8c b3 e7 ec 45 d3 R/-"
1336          )
1337      def test_burn_key_from_digest(self):
1338          self.espefuse_py(
1339              f"burn_key \
1340              BLOCK_KEY0 {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1341          )
1342          output = self.espefuse_py("summary -d")
1343          assert 1 == output.count(
1344              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1345              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1346          )
1347          self.espefuse_py(
1348              f"burn_key_digest \
1349              BLOCK_KEY1 \
1350              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST1"
1351          )
1352          output = self.espefuse_py("summary -d")
1353          assert 2 == output.count(
1354              " = cb 27 91 a3 71 b0 c0 32 2b f7 37 04 78 ba 09 62 "
1355              "22 4c ab 1c f2 28 78 79 e4 29 67 3e 7d a8 44 63 R/-"
1356          )
1357  class TestBurnBitCommands(EfuseTestCase):
1358      @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32-only")
1359      def test_burn_bit_for_chips_with_3_key_blocks(self):
1360          self.espefuse_py("burn_bit -h")
1361          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1362          self.espefuse_py(
1363              "summary",
1364              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 00 "
1365              "00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1366          )
1367          self.espefuse_py(
1368              "burn_bit BLOCK3 3 5 6 7 9 10 11 12 13 14 15 31 63 95 127 159 191 223 254"
1369          )
1370          self.espefuse_py(
1371              "summary",
1372              check_msg="ff ff 01 80 01 00 00 80 01 00 00 80 01 "
1373              "00 00 80 01 00 00 80 01 00 00 80 01 00 00 80 01 00 00 c0",
1374          )
1375      @pytest.mark.skipif(arg_chip != "esp32c2", reason="ESP32-C2-only")
1376      def test_burn_bit_for_chips_with_1_key_block(self):
1377          self.espefuse_py("burn_bit -h")
1378          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1379          self.espefuse_py(
1380              "summary",
1381              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1382              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1383          )
1384          self.espefuse_py(
1385              "burn_bit BLOCK3 100",
1386              check_msg="Burn into BLOCK_KEY0 is forbidden "
1387              "(RS coding scheme does not allow this)",
1388              ret_code=2,
1389          )
1390          self.espefuse_py("burn_bit BLOCK0 0 1 2")
1391          self.espefuse_py("summary", check_msg="[0 ] read_regs: 00000007 00000000")
1392      @pytest.mark.skipif(
1393          arg_chip
1394          not in [
1395              "esp32s2",
1396              "esp32s3",
1397              "esp32s3beta1",
1398              "esp32c3",
1399              "esp32h2beta1",
1400              "esp32c6",
1401              "esp32h2",
1402          ],
1403          reason="Only chip with 6 keys",
1404      )
1405      def test_burn_bit_for_chips_with_6_key_blocks(self):
1406          self.espefuse_py("burn_bit -h")
1407          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 192 224 255")
1408          self.espefuse_py(
1409              "summary",
1410              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1411              "00 00 01 00 00 00 01 00 00 00 01 00 00 00 01 00 00 80",
1412          )
1413          self.espefuse_py(
1414              "burn_bit BLOCK3 100",
1415              check_msg="Burn into BLOCK_USR_DATA is forbidden "
1416              "(RS coding scheme does not allow this)",
1417              ret_code=2,
1418          )
1419          self.espefuse_py("burn_bit BLOCK0 13")
1420          self.espefuse_py(
1421              "summary",
1422              check_msg="[0 ] read_regs: 00002000 00000000 00000000 "
1423              "00000000 00000000 00000000",
1424          )
1425          self.espefuse_py("burn_bit BLOCK0 24")
1426          self.espefuse_py(
1427              "summary",
1428              check_msg="[0 ] read_regs: 01002000 00000000 00000000 "
1429              "00000000 00000000 00000000",
1430          )
1431      @pytest.mark.skipif(
1432          arg_chip != "esp32", reason="3/4 coding scheme is only in esp32"
1433      )
1434      def test_burn_bit_with_34_coding_scheme(self):
1435          self._set_34_coding_scheme()
1436          self.espefuse_py("burn_bit BLOCK3 0 1 2 4 8 16 32 64 96 128 160 191")
1437          self.espefuse_py(
1438              "summary",
1439              check_msg="17 01 01 00 01 00 00 00 01 00 00 00 01 00 "
1440              "00 00 01 00 00 00 01 00 00 80",
1441          )
1442          self.espefuse_py(
1443              "burn_bit BLOCK3 17",
1444              check_msg="Burn into BLOCK3 is forbidden "
1445              "(3/4 coding scheme does not allow this).",
1446              ret_code=2,
1447          )
1448  @pytest.mark.skipif(
1449      arg_chip != "esp32", reason="Tests are only for esp32. (TODO: add for all chips)"
1450  )
1451  class TestByteOrderBurnKeyCommand(EfuseTestCase):
1452      def test_1_secure_boot_v1(self):
1453          if arg_chip == "esp32":
1454              self.espefuse_py(
1455                  f"burn_key \
1456                  flash_encryption {IMAGES_DIR}/256bit \
1457                  secure_boot_v1 {IMAGES_DIR}/256bit_1 --no-protect-key"
1458              )
1459              output = self.espefuse_py("summary -d")
1460              self.check_data_block_in_log(
1461                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1462              )
1463              self.check_data_block_in_log(
1464                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=True
1465              )
1466              self.espefuse_py(
1467                  f"burn_key \
1468                  flash_encryption  {IMAGES_DIR}/256bit \
1469                  secure_boot_v1    {IMAGES_DIR}/256bit_1"
1470              )
1471              output = self.espefuse_py("summary -d")
1472              assert (
1473                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1474                  "00000000 00000000 00000000 00000000"
1475              ) in output
1476              assert (
1477                  "[2 ] read_regs: 00000000 00000000 00000000 00000000 "
1478                  "00000000 00000000 00000000 00000000"
1479              ) in output
1480              assert (
1481                  "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1482                  "00000000 00000000 00000000 00000000"
1483              ) in output
1484      def test_2_secure_boot_v1(self):
1485          if arg_chip == "esp32":
1486              self.espefuse_py(
1487                  f"burn_key \
1488                  flash_encryption {IMAGES_DIR}/256bit \
1489                  secure_boot_v2 {IMAGES_DIR}/256bit_1 --no-protect-key"
1490              )
1491              output = self.espefuse_py("summary -d")
1492              self.check_data_block_in_log(
1493                  output, f"{IMAGES_DIR}/256bit", reverse_order=True
1494              )
1495              self.check_data_block_in_log(
1496                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1497              )
1498              self.espefuse_py(
1499                  f"burn_key \
1500                  flash_encryption {IMAGES_DIR}/256bit \
1501                  secure_boot_v2 {IMAGES_DIR}/256bit_1"
1502              )
1503              output = self.espefuse_py("summary -d")
1504              assert (
1505                  "[1 ] read_regs: 00000000 00000000 00000000 00000000 "
1506                  "00000000 00000000 00000000 00000000"
1507              ) in output
1508              self.check_data_block_in_log(
1509                  output, f"{IMAGES_DIR}/256bit_1", reverse_order=False
1510              )
1511  class TestExecuteScriptsCommands(EfuseTestCase):
1512      @classmethod
1513      def setup_class(self):
1514          self.stored_dir = os.getcwd()
1515      @classmethod
1516      def teardown_class(self):
1517          os.chdir(self.stored_dir)
1518      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1519      def test_execute_scripts_with_check_that_only_one_burn(self):
1520          self.espefuse_py("execute_scripts -h")
1521          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1522          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1523          self.espefuse_py("execute_scripts execute_efuse_script2.py")
1524      @pytest.mark.skipif(arg_chip == "esp32c2", reason="TODO: Add tests for esp32c2")
1525      def test_execute_scripts_with_check(self):
1526          self.espefuse_py("execute_scripts -h")
1527          name = arg_chip if arg_chip in ["esp32", "esp32c2"] else "esp32xx"
1528          os.chdir(os.path.join(TEST_DIR, "efuse_scripts", name))
1529          self.espefuse_py("execute_scripts execute_efuse_script.py")
1530      def test_execute_scripts_with_index_and_config(self):
1531          os.chdir(TEST_DIR)
1532          if arg_chip in ["esp32", "esp32c2"]:
1533              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1534              --configfiles {EFUSE_S_DIR}/esp32/config1.json"
1535          else:
1536              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn1.py --index 10 \
1537              --configfiles {EFUSE_S_DIR}/esp32xx/config1.json"
1538          self.espefuse_py(cmd)
1539          output = self.espefuse_py("summary -d")
1540          if arg_chip in ["esp32", "esp32c2"]:
1541              assert (
1542                  "[3 ] read_regs: e00007ff 00000000 00000000 00000000 "
1543                  "00000000 00000000 00000000 00000000"
1544              ) in output
1545          else:
1546              assert (
1547                  "[8 ] read_regs: e00007ff 00000000 00000000 00000000 "
1548                  "00000000 00000000 00000000 00000000"
1549              ) in output
1550      def test_execute_scripts_nesting(self):
1551          os.chdir(TEST_DIR)
1552          if arg_chip in ["esp32", "esp32c2"]:
1553              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1554              --configfiles {EFUSE_S_DIR}/esp32/config2.json"
1555          else:
1556              cmd = f"execute_scripts {EFUSE_S_DIR}/efuse_burn2.py --index 28 \
1557              --configfiles {EFUSE_S_DIR}/esp32xx/config2.json"
1558          self.espefuse_py(cmd)
1559          output = self.espefuse_py("summary -d")
1560          if arg_chip in ["esp32", "esp32c2"]:
1561              assert (
1562                  "[2 ] read_regs: 10000000 00000000 00000000 00000000 "
1563                  "00000000 00000000 00000000 00000000"
1564              ) in output
1565              assert (
1566                  "[3 ] read_regs: ffffffff 00000000 00000000 00000000 "
1567                  "00000000 00000000 00000000 00000000"
1568              ) in output
1569          else:
1570              assert (
1571                  "[7 ] read_regs: 10000000 00000000 00000000 00000000 "
1572                  "00000000 00000000 00000000 00000000"
1573              ) in output
1574              assert (
1575                  "[8 ] read_regs: ffffffff 00000000 00000000 00000000 "
1576                  "00000000 00000000 00000000 00000000"
1577              ) in output
1578  class TestMultipleCommands(EfuseTestCase):
1579      def test_multiple_cmds_help(self):
1580          if arg_chip == "esp32c2":
1581              command1 = (
1582                  f"burn_key_digest {S_IMAGES_DIR}"
1583                  "/ecdsa256_secure_boot_signing_key_v2.pem"
1584              )
1585              command2 = (
1586                  f"burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key "
1587                  "XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS"
1588              )
1589          elif arg_chip == "esp32":
1590              command1 = f"burn_key_digest {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem"
1591              command2 = f"burn_key flash_encryption {IMAGES_DIR}/256bit"
1592          else:
1593              command1 = f"burn_key_digest BLOCK_KEY0 \
1594              {S_IMAGES_DIR}/rsa_secure_boot_signing_key.pem SECURE_BOOT_DIGEST0"
1595              command2 = f"burn_key BLOCK_KEY0 \
1596              {S_IMAGES_DIR}/rsa_public_key_digest.bin SECURE_BOOT_DIGEST0"
1597          self.espefuse_py(
1598              f"-h {command1} {command2}",
1599              check_msg="usage: __main__.py [-h]",
1600          )
1601          self.espefuse_py(
1602              f"{command1} -h {command2}",
1603              check_msg="usage: __main__.py burn_key_digest [-h]",
1604          )
1605          self.espefuse_py(
1606              f"{command1} {command2} -h",
1607              check_msg="usage: __main__.py burn_key [-h]",
1608          )
1609      @pytest.mark.skipif(
1610          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1611      )
1612      def test_1_esp32c2(self):
1613          self.espefuse_py(
1614              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1615              burn_key BLOCK_KEY0 {IMAGES_DIR}/128bit_key \
1616              XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS --no-read-protect \
1617              summary"
1618          )
1619          output = self.espefuse_py("summary -d")
1620          assert (
1621              "[3 ] read_regs: 0c0d0e0f 08090a0b 04050607 00010203 "
1622              "f66a0fbf 8b6dd38b a9dab353 040af633"
1623          ) in output
1624          assert " = 0f 0e 0d 0c 0b 0a 09 08 07 06 05 04 03 02 01 00 R/-" in output
1625          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1626      @pytest.mark.skipif(
1627          arg_chip != "esp32c2", reason="For this chip, FE and SB keys go into one BLOCK"
1628      )
1629      def test_2_esp32c2(self):
1630          self.espefuse_py(
1631              f"burn_key_digest {S_IMAGES_DIR}/ecdsa256_secure_boot_signing_key_v2.pem \
1632              burn_key BLOCK_KEY0 \
1633              {IMAGES_DIR}/128bit_key XTS_AES_128_KEY_DERIVED_FROM_128_EFUSE_BITS \
1634              summary"
1635          )
1636          output = self.espefuse_py("summary -d")
1637          assert (
1638              "[3 ] read_regs: 00000000 00000000 00000000 00000000 "
1639              "f66a0fbf 8b6dd38b a9dab353 040af633"
1640          ) in output
1641          assert " = ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? -/-" in output
1642          assert " = bf 0f 6a f6 8b d3 6d 8b 53 b3 da a9 33 f6 0a 04 R/-" in output
1643      def test_burn_bit(self):
1644          if arg_chip == "esp32":
1645              self._set_34_coding_scheme()
1646          self.espefuse_py(
1647              "burn_bit BLOCK2 0 1 2 3 \
1648              burn_bit BLOCK2 4 5 6 7 \
1649              burn_bit BLOCK2 8 9 10 11 \
1650              burn_bit BLOCK2 12 13 14 15 \
1651              summary"
1652          )
1653          output = self.espefuse_py("summary -d")
1654          assert "[2 ] read_regs: 0000ffff 00000000" in output
1655      def test_not_burn_cmds(self):
1656          self.espefuse_py(
1657              "summary \
1658              dump \
1659              get_custom_mac \
1660              adc_info \
1661              check_error"
1662          )
1663  @pytest.mark.skipif(
1664      arg_chip not in ["esp32c3", "esp32c6", "esp32h2", "esp32s3"],
1665      reason="These chips have a hardware bug that limits the use of the KEY5",
1666  )
1667  class TestKeyPurposes(EfuseTestCase):
1668      def test_burn_xts_aes_key_purpose(self):
1669          self.espefuse_py(
1670              "burn_efuse KEY_PURPOSE_5 XTS_AES_128_KEY",
1671              check_msg="A fatal error occurred: "
1672              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1673              "key due to a hardware bug (please see TRM for more details)",
1674              ret_code=2,
1675          )
1676      @pytest.mark.skipif(
1677          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1678      )
1679      def test_burn_ecdsa_key_purpose(self):
1680          self.espefuse_py(
1681              "burn_efuse KEY_PURPOSE_5 ECDSA_KEY",
1682              check_msg="A fatal error occurred: "
1683              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1684              "key due to a hardware bug (please see TRM for more details)",
1685              ret_code=2,
1686          )
1687      def test_burn_xts_aes_key(self):
1688          self.espefuse_py(
1689              f"burn_key \
1690              BLOCK_KEY5 {IMAGES_DIR}/256bit XTS_AES_128_KEY",
1691              check_msg="A fatal error occurred: "
1692              "KEY_PURPOSE_5 can not have XTS_AES_128_KEY "
1693              "key due to a hardware bug (please see TRM for more details)",
1694              ret_code=2,
1695          )
1696      @pytest.mark.skipif(
1697          arg_chip != "esp32h2", reason="esp32h2 can not have ECDSA key in KEY5"
1698      )
1699      def test_burn_ecdsa_key(self):
1700          self.espefuse_py(
1701              f"burn_key \
1702              BLOCK_KEY5 {S_IMAGES_DIR}/ecdsa192_secure_boot_signing_key_v2.pem \
1703              ECDSA_KEY",
1704              check_msg="A fatal error occurred: "
1705              "KEY_PURPOSE_5 can not have ECDSA_KEY "
1706              "key due to a hardware bug (please see TRM for more details)",
1707              ret_code=2,
1708          )
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_espefuse.py</div>
                </div>
                <div class="column column_space"><pre><code>344          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
345          self.espefuse_py(
346              "set_flash_voltage 1.8V",
347              check_msg=f"Set internal flash voltage regulator ({vdd}) to 1.8V.",
348          )
349          if arg_chip == "esp32":
</pre></code></div>
                <div class="column column_space"><pre><code>361          vdd = "VDD_SDIO" if arg_chip == "esp32" else "VDD_SPI"
362          self.espefuse_py(
363              "set_flash_voltage 3.3V",
364              check_msg=f"Enable internal flash voltage regulator ({vdd}) to 3.3V.",
365          )
366          if arg_chip == "esp32":
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    