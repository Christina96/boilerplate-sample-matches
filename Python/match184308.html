<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_syslog_ng_1.py &amp; test_file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_syslog_ng_1.py &amp; test_file_2.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_syslog_ng_1.py (15.748032%)<th>test_file_2.py (0.98364687%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(186-194)<td><a href="#" name="0">(378-386)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(336-340)<td><a href="#" name="1">(456-462)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(176-182)<td><a href="#" name="2">(2767-2774)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(157-163)<td><a href="#" name="3">(2414-2420)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(343-347)<td><a href="#" name="4">(2722-2729)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(84-87)<td><a href="#" name="5">(2926-2938)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_syslog_ng_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 from textwrap import dedent
3 import salt.modules.syslog_ng as syslog_ng
4 import salt.utils.platform
5 from tests.support.mixins import LoaderModuleMockMixin
6 from tests.support.mock import MagicMock, patch
7 from tests.support.unit import TestCase, skipIf
8 _VERSION = "3.6.0alpha0"
9 _MODULES = (
10     "syslogformat,json-plugin,basicfuncs,afstomp,afsocket,cryptofuncs,"
11     "afmongodb,dbparser,system-source,affile,pseudofile,afamqp,"
12     "afsocket-notls,csvparser,linux-kmsg-format,afuser,confgen,afprog"
13 )
14 VERSION_OUTPUT = """syslog-ng {0}
15 Installer-Version: {0}
16 Revision:
17 Compile-Date: Apr  4 2014 20:26:18
18 Error opening plugin module; module='afsocket-tls', error='/home/tibi/install/syslog-ng/lib/syslog-ng/libafsocket-tls.so: undefined symbol: tls_context_setup_session'
19 Available-Modules: {1}
20 Enable-Debug: on
21 Enable-GProf: off
22 Enable-Memtrace: off
23 Enable-IPv6: on
24 Enable-Spoof-Source: off
25 Enable-TCP-Wrapper: off
26 Enable-Linux-Caps: off""".format(
27     _VERSION, _MODULES
28 )
29 STATS_OUTPUT = """SourceName;SourceId;SourceInstance;State;Type;Number
30 center;;received;a;processed;0
31 destination;#anon-destination0;;a;processed;0
32 destination;#anon-destination1;;a;processed;0
33 source;s_gsoc2014;;a;processed;0
34 center;;queued;a;processed;0
35 global;payload_reallocs;;a;processed;0
36 global;sdata_updates;;a;processed;0
37 global;msg_clones;;a;processed;0"""
38 _SYSLOG_NG_NOT_INSTALLED_RETURN_VALUE = {
39     "retcode": -1,
40     "stderr": "Unable to execute the command 'syslog-ng'. It is not in the PATH.",
41 }
42 _SYSLOG_NG_CTL_NOT_INSTALLED_RETURN_VALUE = {
43     "retcode": -1,
44     "stderr": "Unable to execute the command 'syslog-ng-ctl'. It is not in the PATH.",
45 }
46 class SyslogNGTestCase(TestCase, LoaderModuleMockMixin):
47     orig_env = {"PATH": "/foo:/bar"}
48     bin_dir = "/baz"
49     mocked_env = {"PATH": "/foo:/bar:/baz"}
50     def setup_loader_modules(self):
51         return {syslog_ng: {}}
52     def test_statement_without_options(self):
53         s = syslog_ng.Statement("source", "s_local", options=[])
54         b = s.build()
55         self.assertEqual(
56             dedent(
57             ),
58             b,
59 <a name="5"></a>        )
60     def test_non_empty_statement(self):
61         o1 = syslog_ng<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Option("file")
62         o2 = syslog_ng.Option("tcp")
63         s = syslog_ng.Statement("source", "s_local", options=[o1, o2])
64         b = s.</b></font>build()
65         self.assertEqual(
66             dedent(
67             ),
68             b,
69         )
70     def test_option_with_parameters(self):
71         o1 = syslog_ng.Option("file")
72         p1 = syslog_ng.SimpleParameter('"/var/log/messages"')
73         p2 = syslog_ng.SimpleParameter()
74         p3 = syslog_ng.TypedParameter()
75         p3.type = "tls"
76         p2.value = '"/var/log/syslog"'
77         o1.add_parameter(p1)
78         o1.add_parameter(p2)
79         o1.add_parameter(p3)
80         b = o1.build()
81         self.assertEqual(
82             dedent(
83             ),
84             b,
85         )
86     def test_parameter_with_values(self):
87         p = syslog_ng.TypedParameter()
88         p.type = "tls"
89         v1 = syslog_ng.TypedParameterValue()
90         v1.type = "key_file"
91         v2 = syslog_ng.TypedParameterValue()
92         v2.type = "cert_file"
93         p.add_value(v1)
94         p.add_value(v2)
95         b = p.build()
96         self.assertEqual(
97             dedent(
98         a1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
99         a2 = syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
100         t.add_argument(a1)
101         t.add_argument(a2)
102         b = t.build(</b></font>)
103         self.assertEqual(
104             dedent(
105         s = syslog_ng<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Statement("source", "s_tls")
106         o = syslog_ng.Option("tcp")
107         ip = syslog_ng.TypedParameter("ip")
108         ip.add_value(syslog_ng.SimpleParameterValue("'192.168.42.2'"))
109         o.</b></font>add_parameter(ip)
110 <a name="0"></a>
111         port = syslog_ng.TypedParameter("port")
112         port.add_value(syslog_ng.SimpleParameterValue(514))
113         o<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_parameter(port)
114         tls = syslog_ng.TypedParameter("tls")
115         key_file = syslog_ng.TypedParameterValue("key_file")
116         key_file.add_argument(
117             syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
118         )
119         cert_file = syslog_ng.TypedParameterValue("cert_file")
120         cert_file.add_argument(</b></font>
121             syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/cert.d/syslog-ng.cert"')
122         )
123         peer_verify = syslog_ng.TypedParameterValue("peer_verify")
124         peer_verify.add_argument(syslog_ng.Argument("optional-untrusted"))
125         tls.add_value(key_file)
126         tls.add_value(cert_file)
127         tls.add_value(peer_verify)
128         o.add_parameter(tls)
129         s.add_child(o)
130         b = s.build()
131         self.assertEqual(
132             dedent(
133             ),
134             b,
135         )
136     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
137     def test_version(self):
138         cmd_ret = {"retcode": 0, "stdout": VERSION_OUTPUT}
139         expected_output = {"retcode": 0, "stdout": _VERSION}
140         cmd_args = ["syslog-ng", "-V"]
141         cmd_mock = MagicMock(return_value=cmd_ret)
142         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
143             os.environ, self.orig_env
144         ):
145             result = syslog_ng.version()
146             self.assertEqual(result, expected_output)
147             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
148         cmd_mock = MagicMock(return_value=cmd_ret)
149         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
150             os.environ, self.orig_env
151         ):
152             result = syslog_ng.version(syslog_ng_sbin_dir=self.bin_dir)
153             self.assertEqual(result, expected_output)
154             cmd_mock.assert_called_once_with(
155                 cmd_args, env=self.mocked_env, python_shell=False
156             )
157     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
158     def test_stats(self):
159         cmd_ret = {"retcode": 0, "stdout": STATS_OUTPUT}
160         cmd_args = ["syslog-ng-ctl", "stats"]
161         cmd_mock = MagicMock(return_value=cmd_ret)
162         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
163             os.environ, self.orig_env
164         ):
165             result = syslog_ng.stats()
166             self.assertEqual(result, cmd_ret)
167             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
168         cmd_mock = MagicMock(return_value=cmd_ret)
169         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
170             os.environ, self.orig_env
171         ):
172             result = syslog_ng.stats(syslog_ng_sbin_dir=self.bin_dir)
173             self.assertEqual(result, cmd_ret)
174             cmd_mock.assert_called_once_with(
175                 cmd_args, env=self.mocked_env, python_shell=False
176             )
177     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
178     def test_modules(self):
179         cmd_ret = {"retcode": 0, "stdout": VERSION_OUTPUT}
180         expected_output = {"retcode": 0, "stdout": _MODULES}
181         cmd_args = ["syslog-ng", "-V"]
182         cmd_mock = MagicMock(return_value=cmd_ret)
183         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
184             os.environ, self.orig_env
185         ):
186             result = syslog_ng.modules()
187             self.assertEqual(result, expected_output)
188             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
189         cmd_mock = MagicMock(return_value=cmd_ret)
190         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
191             os.environ, self.orig_env
192         ):
193             result = syslog_ng.modules(syslog_ng_sbin_dir=self.bin_dir)
194             self.assertEqual(result, expected_output)
195             cmd_mock.assert_called_once_with(
196                 cmd_args, env=self.mocked_env, python_shell=False
197             )
198     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
199     def test_config_test(self):
200         cmd_ret = {"retcode": 0, "stderr": "", "stdout": "Foo"}
201         cmd_args = ["syslog-ng", "--syntax-only"]
202         cmd_mock = MagicMock(return_value=cmd_ret)
203         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
204             os.environ, self.orig_env
205         ):
206             result = syslog_ng.config_test()
207             self.assertEqual(result, cmd_ret)
208             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
209         cmd_mock = MagicMock(return_value=cmd_ret)
210         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
211             os.environ, self.orig_env
212         ):
213             result = syslog_ng.config_test(syslog_ng_sbin_dir=self.bin_dir)
214             self.assertEqual(result, cmd_ret)
215             cmd_mock.assert_called_once_with(
216                 cmd_args, env=self.mocked_env, python_shell=False
217             )
218     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
219     def test_config_test_cfgfile(self):
220         cfgfile = "/path/to/syslog-ng.conf"
221         cmd_ret = {"retcode": 1, "stderr": "Syntax error...", "stdout": ""}
222 <a name="1"></a>        cmd_args = ["syslog-ng", "--syntax-only", "--cfgfile={}".format(cfgfile)]
223         cmd_mock = MagicMock(return_value=cmd_ret)
224         with patch.dict(syslog_ng.__salt__, {<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"cmd.run_all": cmd_mock}), patch.dict(
225             os.environ, self.orig_env
226         ):
227             self.assertEqual(syslog_ng.config_test(cfgfile=cfgfile), cmd_ret)
228 <a name="4"></a>            cmd_mock.assert_called_once_with(cmd_args, env=</b></font>None, python_shell=False)
229         cmd_mock = MagicMock(return_value=cmd_ret)
230         with patch<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
231             os.environ, self.orig_env
232         ):
233             self.assertEqual(
234                 syslog_ng.config_test(</b></font>syslog_ng_sbin_dir=self.bin_dir, cfgfile=cfgfile),
235                 cmd_ret,
236             )
237             cmd_mock.assert_called_once_with(
238                 cmd_args, env=self.mocked_env, python_shell=False
239             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import filecmp
3 import logging
4 import os
5 import pathlib
6 import re
7 import shutil
8 import stat
9 import sys
10 import tempfile
11 import textwrap
12 import pytest
13 import salt.serializers.configparser
14 import salt.serializers.plist
15 import salt.utils.atomicfile
16 import salt.utils.data
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.path
20 import salt.utils.platform
21 import salt.utils.stringutils
22 from salt.utils.versions import LooseVersion as _LooseVersion
23 from tests.support.case import ModuleCase
24 from tests.support.helpers import (
25     Webserver,
26     dedent,
27     requires_system_grains,
28     with_system_user_and_group,
29     with_tempdir,
30     with_tempfile,
31 )
32 from tests.support.mixins import SaltReturnAssertsMixin
33 from tests.support.runtests import RUNTIME_VARS
34 from tests.support.unit import skipIf
35 log = logging.getLogger(__name__)
36 HAS_PWD = True
37 try:
38     import pwd
39 except ImportError:
40     HAS_PWD = False
41 HAS_GRP = True
42 try:
43     import grp
44 except ImportError:
45     HAS_GRP = False
46 IS_WINDOWS = salt.utils.platform.is_windows()
47 BINARY_FILE = b"GIF89a\x01\x00\x01\x00\x80\x00\x00\x05\x04\x04\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;"
48 TEST_SYSTEM_USER = "test_system_user"
49 TEST_SYSTEM_GROUP = "test_system_group"
50 DEFAULT_ENDING = salt.utils.stringutils.to_bytes(os.linesep)
51 pytestmark = [
52     pytest.mark.skip_on_freebsd(reason="These tests timeout on FreeBSD"),
53 ]
54 def _test_managed_file_mode_keep_helper(testcase, local=False):
55     name = testcase.tmp_dir / "scene33"
56     testcase.addCleanup(salt.utils.files.safe_rm, str(name))
57     grail_fs_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
58     grail = "salt://grail/scene33" if not local else grail_fs_path
59     grail_fs_mode = int(testcase.run_function("file.get_mode", [grail_fs_path]), 8)
60     initial_mode = 0o770
61     new_mode_1 = 0o600
62     new_mode_2 = 0o644
63     ret = testcase.run_state(
64         "file.managed",
65         name=str(name),
66         mode=oct(initial_mode),
67         source=grail,
68     )
69     if IS_WINDOWS:
70         testcase.assertSaltFalseReturn(ret)
71         return
72     testcase.assertSaltTrueReturn(ret)
73     try:
74         os.chmod(grail_fs_path, new_mode_1)
75         ret = testcase.run_state(
76             "file.managed",
77             name=str(name),
78             mode="keep",
79             source=grail,
80         )
81         testcase.assertSaltTrueReturn(ret)
82         managed_mode = stat.S_IMODE(name.stat().st_mode)
83         testcase.assertEqual(oct(managed_mode), oct(new_mode_1))
84         os.chmod(grail_fs_path, new_mode_2)
85         ret = testcase.run_state(
86             "file.managed",
87             name=str(name),
88             mode="keep",
89             source=grail,
90         )
91         testcase.assertSaltTrueReturn(ret)
92         managed_mode = stat.S_IMODE(name.stat().st_mode)
93         testcase.assertEqual(oct(managed_mode), oct(new_mode_2))
94     finally:
95         os.chmod(grail_fs_path, grail_fs_mode)
96 @pytest.mark.windows_whitelisted
97 class FileTest(ModuleCase, SaltReturnAssertsMixin):
98     @classmethod
99     def setUpClass(cls):
100         cls.tmp_dir = pathlib.Path(tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)).resolve()
101         def _reline(path, ending=DEFAULT_ENDING):
102             with salt.utils.files.fopen(path, "rb") as fhr:
103                 lines = fhr.read().splitlines()
104             with salt.utils.atomicfile.atomic_open(path, "wb") as fhw:
105                 for line in lines:
106                     fhw.write(line + ending)
107         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "firstif")
108         _reline(destpath)
109         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "secondif")
110         _reline(destpath)
111     @classmethod
112     def tearDownClass(cls):
113         salt.utils.files.rm_rf(str(cls.tmp_dir))
114     def _delete_file(self, path):
115         try:
116             os.remove(path)
117         except OSError as exc:
118             if exc.errno != errno.ENOENT:
119                 log.error("Failed to remove %s: %s", path, exc)
120     def tearDown(self):
121         user = "salt"
122         if user in str(self.run_function("user.list_users")):
123             self.run_function("user.delete", [user])
124     def test_symlink(self):
125         name = self.tmp_dir / "symlink"
126         tgt = self.tmp_dir / "target"
127         if IS_WINDOWS and not tgt.is_dir():
128             tgt.mkdir()
129         if IS_WINDOWS and name.is_symlink():
130             name.unlink()
131         ret = self.run_state("file.symlink", name=str(name), target=str(tgt))
132         self.assertSaltTrueReturn(ret)
133     def test_test_symlink(self):
134         name = self.tmp_dir / "symlink2"
135         tgt = self.tmp_dir / "target2"
136         ret = self.run_state("file.symlink", test=True, name=str(name), target=str(tgt))
137         self.assertSaltNoneReturn(ret)
138     def test_absent_file(self):
139         name = self.tmp_dir / "file_to_kill"
140         name.write_text("killme")
141         ret = self.run_state("file.absent", name=str(name))
142         self.assertSaltTrueReturn(ret)
143         self.assertFalse(name.is_file())
144     def test_absent_dir(self):
145         name = self.tmp_dir / "dir_to_kill"
146         name.mkdir(exist_ok=True)
147         ret = self.run_state("file.absent", name=str(name))
148         self.assertSaltTrueReturn(ret)
149         self.assertFalse(name.is_dir())
150     def test_absent_link(self):
151         name = self.tmp_dir / "link_to_kill"
152         self.addCleanup(salt.utils.files.safe_rm, str(name))
153         tgt = self.tmp_dir / "link_to_kill.tgt"
154         self.addCleanup(salt.utils.files.safe_rm, str(tgt))
155         tgt.symlink_to(name, target_is_directory=IS_WINDOWS)
156         ret = self.run_state("file.absent", name=str(name))
157         self.assertSaltTrueReturn(ret)
158         self.assertFalse(name.exists())
159         self.assertFalse(name.is_symlink())
160     @with_tempfile()
161     def test_test_absent(self, name):
162         with salt.utils.files.fopen(name, "w+") as fp_:
163             fp_.write("killme")
164         ret = self.run_state("file.absent", test=True, name=name)
165         self.assertSaltNoneReturn(ret)
166         self.assertTrue(os.path.isfile(name))
167     def test_managed(self):
168         name = self.tmp_dir / "grail_scene33"
169         self.addCleanup(salt.utils.files.safe_rm, str(name))
170         ret = self.run_state(
171             "file.managed", name=str(name), source="salt://grail/scene33"
172         )
173         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "grail" / "scene33"
174         master_data = src.read_text()
175         minion_data = name.read_text()
176         self.assertEqual(master_data, minion_data)
177         self.assertSaltTrueReturn(ret)
178     def test_managed_file_mode(self):
179         desired_mode = 504  # 0770 octal
180         name = self.tmp_dir / "grail_scene33"
181         self.addCleanup(salt.utils.files.safe_rm, str(name))
182         ret = self.run_state(
183             "file.managed", name=str(name), mode="0770", source="salt://grail/scene33"
184         )
185         if IS_WINDOWS:
186             expected = "The 'mode' option is not supported on Windows"
187             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
188             self.assertSaltFalseReturn(ret)
189             return
190         resulting_mode = stat.S_IMODE(name.stat().st_mode)
191         self.assertEqual(oct(desired_mode), oct(resulting_mode))
192         self.assertSaltTrueReturn(ret)
193     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
194     def test_managed_file_mode_keep(self):
195         _test_managed_file_mode_keep_helper(self, local=False)
196     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
197     def test_managed_file_mode_keep_local_source(self):
198         _test_managed_file_mode_keep_helper(self, local=True)
199     def test_managed_file_mode_file_exists_replace(self):
200         initial_mode = 504  # 0770 octal
201         desired_mode = 384  # 0600 octal
202         name = self.tmp_dir / "grail_scene33"
203         self.addCleanup(salt.utils.files.safe_rm, str(name))
204         ret = self.run_state(
205             "file.managed",
206             name=str(name),
207             mode=oct(initial_mode),
208             source="salt://grail/scene33",
209         )
210         if IS_WINDOWS:
211             expected = "The 'mode' option is not supported on Windows"
212             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
213             self.assertSaltFalseReturn(ret)
214             return
215         resulting_mode = stat.S_IMODE(name.stat().st_mode)
216         self.assertEqual(oct(initial_mode), oct(resulting_mode))
217         ret = self.run_state(
218             "file.managed",
219             name=str(name),
220             replace=True,
221             mode=oct(desired_mode),
222             source="salt://grail/scene33",
223         )
224         resulting_mode = stat.S_IMODE(name.stat().st_mode)
225         self.assertEqual(oct(desired_mode), oct(resulting_mode))
226         self.assertSaltTrueReturn(ret)
227     def test_managed_file_mode_file_exists_noreplace(self):
228         initial_mode = 504  # 0770 octal
229         desired_mode = 384  # 0600 octal
230         name = self.tmp_dir / "grail_scene33"
231         self.addCleanup(salt.utils.files.safe_rm, str(name))
232         ret = self.run_state(
233             "file.managed",
234             name=str(name),
235             replace=True,
236             mode=oct(initial_mode),
237             source="salt://grail/scene33",
238         )
239         if IS_WINDOWS:
240             expected = "The 'mode' option is not supported on Windows"
241             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
242             self.assertSaltFalseReturn(ret)
243             return
244         ret = self.run_state(
245             "file.managed",
246             name=str(name),
247             replace=False,
248             mode=oct(desired_mode),
249             source="salt://grail/scene33",
250         )
251         resulting_mode = stat.S_IMODE(name.stat().st_mode)
252         self.assertEqual(oct(desired_mode), oct(resulting_mode))
253         self.assertSaltTrueReturn(ret)
254     def test_managed_file_with_grains_data(self):
255         grain_path = self.tmp_dir / "file-grain-test"
256         self.addCleanup(salt.utils.files<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.safe_rm, str(grain_path))
257         state_file = "file-grainget"
258         self.run_function(
259             "state.sls", [state_file], pillar={"grain_path": str(grain_path)}
260         )
261         self.assertTrue(grain_path.exists())
262         file_contents = grain_path.read_text().splitlines(</b></font>True)
263         match = "^minion\n"
264         self.assertTrue(re.match(match, file_contents[0]))
265     def test_managed_file_with_pillardefault_sls(self):
266         file_pillar_def = os.path.join(RUNTIME_VARS.TMP, "filepillar-defaultvalue")
267         self.addCleanup(self._delete_file, file_pillar_def)
268         state_name = "file-pillardefaultget"
269         log.warning("File Path: %s", file_pillar_def)
270         ret = self.run_function("state.sls", [state_name])
271         self.assertSaltTrueReturn(ret)
272         check_file = self.run_function("file.file_exists", [file_pillar_def])
273         self.assertTrue(check_file)
274     @pytest.mark.skip_if_not_root
275     def test_managed_dir_mode(self):
276         desired_mode = 511  # 0777 in octal
277         name = self.tmp_dir / "a" / "managed_dir_mode_test_file"
278         self.addCleanup(salt.utils.files.safe_rm, str(name))
279         desired_owner = "nobody"
280         ret = self.run_state(
281             "file.managed",
282             name=str(name),
283             source="salt://grail/scene33",
284             mode=600,
285             makedirs=True,
286             user=desired_owner,
287             dir_mode=oct(desired_mode),  # 0777
288         )
289         if IS_WINDOWS:
290             expected = "The 'mode' option is not supported on Windows"
291             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
292             self.assertSaltFalseReturn(ret)
293             return
294         resulting_mode = stat.S_IMODE(name.parent.stat().st_mode)
295         resulting_owner = pwd.getpwuid(name.parent.stat().st_uid).pw_name
296         self.assertEqual(oct(desired_mode), oct(resulting_mode))
297         self.assertSaltTrueReturn(ret)
298         self.assertEqual(desired_owner, resulting_owner)
299     def test_test_managed(self):
300         name = self.tmp_dir / "grail_not_not_scene33"
301         self.addCleanup(salt.utils.files.safe_rm, str(name))
302         ret = self.run_state(
303             "file.managed", test=True, name=str(name), source="salt://grail/scene33"
304         )
305         self.assertSaltNoneReturn(ret)
306         self.assertFalse(name.is_file())
307     def test_managed_show_changes_false(self):
308 <a name="1"></a>        """
309         file.managed test interface
310         name = self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tmp_dir / "grail_not_scene33"
311         self.addCleanup(salt.utils.files.safe_rm, str(name))
312         name.write_bytes(b"test_managed_show_changes_false\n")
313         ret = self.run_state(
314             "file.managed",
315             name=</b></font>str(name),
316             source="salt://grail/scene33",
317             show_changes=False,
318         )
319         changes = next(iter(ret.values()))["changes"]
320         self.assertEqual("&lt;show_changes=False&gt;", changes["diff"])
321     def test_managed_show_changes_true(self):
322         name = self.tmp_dir / "grail_not_scene33"
323         self.addCleanup(salt.utils.files.safe_rm, str(name))
324         name.write_bytes(b"test_managed_show_changes_false\n")
325         ret = self.run_state(
326             "file.managed",
327             name=str(name),
328             source="salt://grail/scene33",
329         )
330         changes = next(iter(ret.values()))["changes"]
331         self.assertIn("diff", changes)
332     @skipIf(IS_WINDOWS, "Don't know how to fix for Windows")
333     def test_managed_escaped_file_path(self):
334         funny_file = salt.utils.files.mkstemp(
335             prefix="?f!le? n@=3&amp;", suffix=".file type"
336         )
337         funny_file_name = os.path.split(funny_file)[1]
338         funny_url = "salt://|" + funny_file_name
339         funny_url_path = os.path.join(RUNTIME_VARS.BASE_FILES, funny_file_name)
340         state_name = "funny_file"
341         state_file_name = state_name + ".sls"
342         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_file_name)
343         state_key = "file_|-{0}_|-{0}_|-managed".format(funny_file)
344         self.addCleanup(os.remove, state_file)
345         self.addCleanup(os.remove, funny_file)
346         self.addCleanup(os.remove, funny_url_path)
347         with salt.utils.files.fopen(funny_url_path, "w"):
348             pass
349         with salt.utils.files.fopen(state_file, "w") as fp_:
350             fp_.write(
351                 textwrap.dedent(
352                         funny_file, funny_url
353                     )
354                 )
355             )
356         ret = self.run_function("state.sls", [state_name])
357         self.assertTrue(ret[state_key]["result"])
358     def test_managed_contents(self):
359         state_name = "file-FileTest-test_managed_contents"
360         state_filename = state_name + ".sls"
361         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
362         managed_files = {}
363         state_keys = {}
364         for typ in ("bool", "str", "int", "float", "list", "dict"):
365             managed_files[typ] = salt.utils.files.mkstemp()
366             state_keys[typ] = "file_|-{} file_|-{}_|-managed".format(
367                 typ, managed_files[typ]
368             )
369         try:
370             with salt.utils.files.fopen(state_file, "w") as fd_:
371                 fd_.write(
372                     textwrap.dedent(
373                             **managed_files
374                         )
375                     )
376                 )
377             ret = self.run_function("state.sls", [state_name])
378             self.assertSaltTrueReturn(ret)
379             for typ in state_keys:
380                 self.assertTrue(ret[state_keys[typ]]["result"])
381                 self.assertIn("diff", ret[state_keys[typ]]["changes"])
382         finally:
383             if os.path.exists(state_file):
384                 os.remove(state_file)
385             for typ in managed_files:
386                 if os.path.exists(managed_files[typ]):
387                     os.remove(managed_files[typ])
388     def test_onchanges_any_recursive_error_issues_50811(self):
389         state_name = "onchanges_any_recursive_error"
390         state_filename = state_name + ".sls"
391         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
392         try:
393             with salt.utils.files.fopen(state_file, "w") as fd_:
394                 fd_.write(
395                     textwrap.dedent(
396                     )
397                 )
398             ret = self.run_function("state.sls", [state_name])
399             self.assertSaltFalseReturn(ret)
400         finally:
401             if os.path.exists(state_file):
402                 os.remove(state_file)
403     def test_prerequired_issues_55775(self):
404         state_name = "Test_Issues_55775"
405         state_filename = state_name + ".sls"
406         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
407         test_file = os.path.join(RUNTIME_VARS.BASE_FILES, "Issues_55775.txt")
408         try:
409             with salt.utils.files.fopen(state_file, "w") as fd_:
410                 fd_.write(
411                     textwrap.dedent(
412                             test_file
413                         )
414                     )
415                 )
416             ret = self.run_function("state.sls", [state_name])
417             self.assertSaltTrueReturn(ret)
418         finally:
419             for fpath in (state_file, test_file):
420                 if os.path.exists(fpath):
421                     os.remove(fpath)
422     def test_managed_contents_with_contents_newline(self):
423         contents = "test_managed_contents_with_newline_one"
424         name = self.tmp_dir / "foo"
425         self.addCleanup(salt.utils.files.safe_rm, str(name))
426         self.run_state(
427             "file.managed", name=str(name), contents=contents, contents_newline=True
428         )
429         last_line = name.read_text()
430         self.assertEqual((contents + "\n"), last_line)
431     def test_managed_contents_with_contents_newline_false(self):
432         contents = "test_managed_contents_with_newline_one"
433         name = self.tmp_dir / "bar"
434         self.addCleanup(salt.utils.files.safe_rm, str(name))
435         self.run_state(
436             "file.managed", name=str(name), contents=contents, contents_newline=False
437         )
438         last_line = name.read_text()
439         self.assertEqual(contents, last_line)
440     def test_managed_multiline_contents_with_contents_newline(self):
441         contents = "this is a cookie\nthis is another cookie"
442         name = self.tmp_dir / "bar"
443         self.addCleanup(salt.utils.files.safe_rm, str(name))
444         self.run_state(
445             "file.managed", name=str(name), contents=contents, contents_newline=True
446         )
447         last_line = name.read_text()
448         self.assertEqual((contents + "\n"), last_line)
449     def test_managed_multiline_contents_with_contents_newline_false(self):
450         contents = "this is a cookie\nthis is another cookie"
451         name = self.tmp_dir / "bar"
452         self.addCleanup(salt.utils.files.safe_rm, str(name))
453         self.run_state(
454             "file.managed", name=str(name), contents=contents, contents_newline=False
455         )
456         last_line = name.read_text()
457         self.assertEqual(contents, last_line)
458     @pytest.mark.skip_if_not_root
459     @skipIf(IS_WINDOWS, 'Windows does not support "mode" kwarg. Skipping.')
460     @skipIf(not salt.utils.path.which("visudo"), "sudo is missing")
461     def test_managed_check_cmd(self):
462         r_group = "root"
463         if salt.utils.platform.is_darwin() or salt.utils.platform.is_freebsd():
464             r_group = "wheel"
465         name = self.tmp_dir / "sudoers"
466         self.addCleanup(salt.utils.files.safe_rm, str(name))
467         ret = self.run_state(
468             "file.managed",
469             name=str(name),
470             user="root",
471             group=r_group,
472             mode=440,
473             check_cmd="visudo -c -s -f",
474         )
475         self.assertSaltTrueReturn(ret)
476         self.assertInSaltComment("Empty file", ret)
477         self.assertEqual(
478             ret["file_|-{0}_|-{0}_|-managed".format(name)]["changes"],
479             {"new": "file {} created".format(name), "mode": "0440"},
480         )
481     def test_managed_local_source_with_source_hash(self):
482         name = self.tmp_dir / "local_source_with_source_hash"
483         self.addCleanup(salt.utils.files.safe_rm, str(name))
484         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
485         actual_hash = "567fd840bf1548edc35c48eb66cdd78bfdfcccff"
486         if IS_WINDOWS:
487             actual_hash = "f658a0ec121d9c17088795afcc6ff3c43cb9842a"
488         bad_hash = actual_hash[::-1]
489         def remove_file():
490             try:
491                 os.remove(str(name))
492             except OSError as exc:
493                 if exc.errno != errno.ENOENT:
494                     raise
495         def do_test(clean=False):
496             for proto in ("file://", ""):
497                 source = proto + local_path
498                 log.debug("Trying source %s", source)
499                 try:
500                     ret = self.run_state(
501                         "file.managed",
502                         name=str(name),
503                         source=source,
504                         source_hash="sha1={}".format(bad_hash),
505                     )
506                     self.assertSaltFalseReturn(ret)
507                     ret = ret[next(iter(ret))]
508                     self.assertFalse(ret["changes"])
509                     self.assertIn("does not match actual checksum", ret["comment"])
510                     ret = self.run_state(
511                         "file.managed",
512                         name=str(name),
513                         source=source,
514                         source_hash="sha1={}".format(actual_hash),
515                     )
516                     self.assertSaltTrueReturn(ret)
517                 finally:
518                     if clean:
519                         remove_file()
520         remove_file()
521         log.debug("Trying with nonexistant destination file")
522         do_test()
523         log.debug("Trying with destination file already present")
524         name.write_text("")
525         try:
526             do_test(clean=False)
527         finally:
528             remove_file()
529     def test_managed_local_source_does_not_exist(self):
530         name = self.tmp_dir / "local_source_does_not_exist"
531         self.addCleanup(salt.utils.files.safe_rm, str(name))
532         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene99")
533         for proto in ("file://", ""):
534             source = proto + local_path
535             log.debug("Trying source %s", source)
536             ret = self.run_state("file.managed", name=str(name), source=source)
537             self.assertSaltFalseReturn(ret)
538             ret = ret[next(iter(ret))]
539             self.assertFalse(ret["changes"])
540             self.assertIn("does not exist", ret["comment"])
541     def test_managed_unicode_jinja_with_tojson_filter(self):
542         test_file = self.tmp_dir / "test-tojson.txt"
543         self.addCleanup(salt.utils.files.safe_rm, str(test_file))
544         ret = self.run_function(
545             "state.apply", mods="tojson", pillar={"tojson-file": str(test_file)}
546         )
547         ret = ret[next(iter(ret))]
548         assert ret["result"], ret
549         managed = salt.utils.stringutils.to_unicode(test_file.read_bytes())
550         expected = dedent(
551         )
552         assert managed == expected, "{!r} != {!r}".format(managed, expected)
553     def test_managed_source_hash_indifferent_case(self):
554         name = self.tmp_dir / "source_hash_indifferent_case"
555         self.addCleanup(salt.utils.files.safe_rm, str(name))
556         state_name = "file_|-{0}_|-{0}_|-managed".format(name)
557         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "hello_world.txt")
558         actual_hash = "c98c24b677eff44860afea6f493bbaec5bb1c4cbb209c6fc2bbb47f66ff2ad31"
559         if IS_WINDOWS:
560             actual_hash = (
561                 "92b772380a3f8e27a93e57e6deeca6c01da07f5aadce78bb2fbb20de10a66925"
562             )
563         uppercase_hash = actual_hash.upper()
564         self.run_state(
565             "file.managed", name=str(name), source=local_path, source_hash=actual_hash
566         )
567         ret = self.run_state(
568             "file.managed",
569             name=str(name),
570             source=local_path,
571             source_hash=uppercase_hash,
572         )
573         assert ret[state_name]["result"] is True
574         assert ret[state_name]["changes"] == {}
575         ret = self.run_state(
576             "file.managed",
577             name=str(name),
578             source=local_path,
579             source_hash=uppercase_hash,
580             test=True,
581         )
582         assert ret[state_name]["result"] is True
583         assert ret[state_name]["changes"] == {}
584     @with_tempfile(create=False)
585     def test_managed_latin1_diff(self, name):
586         ret = self.run_state(
587             "file.managed", name=name, source="salt://issue-48777/old.html"
588         )
589         ret = ret[next(iter(ret))]
590         assert ret["result"] is True, ret
591         ret = self.run_state(
592             "file.managed", name=name, source="salt://issue-48777/new.html"
593         )
594         ret = ret[next(iter(ret))]
595         assert ret["result"] is True, ret
596         diff_lines = ret["changes"]["diff"].split(os.linesep)
597         assert "+räksmörgås" in diff_lines, diff_lines
598     @with_tempfile()
599     def test_managed_keep_source_false_salt(self, name):
600         source = "salt://grail/scene33"
601         saltenv = "base"
602         ret = self.run_state(
603             "file.managed", name=name, source=source, saltenv=saltenv, keep_source=False
604         )
605         ret = ret[next(iter(ret))]
606         assert ret["result"] is True
607         result = self.run_function("cp.is_cached", [source, saltenv])
608         assert result == "", "File is still cached at {}".format(result)
609     @with_tempfile(create=False)
610     @with_tempfile(create=False)
611     def test_file_managed_onchanges(self, file1, file2):
612         pillar = {
613             "file1": file1,
614             "file2": file2,
615             "source": "salt://testfile",
616             "req": "onchanges",
617         }
618         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
619         ret = self.repack_state_returns(
620             self.run_function(
621                 "state.apply",
622                 mods="onchanges_prereq",
623                 pillar=pillar,
624                 test=True,
625             )
626         )
627         assert ret["one"]["result"] is None, ret["one"]["result"]
628         assert ret["three"]["result"] is True, ret["three"]["result"]
629         assert ret["one"]["changes"]
630         assert not ret["three"]["changes"], ret["three"]["changes"]
631         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
632         assert (
633             ret["four"]["comment"]
634             == "State was not run because none of the onchanges reqs changed"
635         ), ret["four"]["comment"]
636     @with_tempfile(create=False)
637     @with_tempfile(create=False)
638     def test_file_managed_prereq(self, file1, file2):
639         pillar = {
640             "file1": file1,
641             "file2": file2,
642             "source": "salt://testfile",
643             "req": "prereq",
644         }
645         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
646         ret = self.repack_state_returns(
647             self.run_function(
648                 "state.apply",
649                 mods="onchanges_prereq",
650                 pillar=pillar,
651                 test=True,
652             )
653         )
654         assert ret["one"]["result"] is None, ret["one"]["result"]
655         assert ret["three"]["result"] is True, ret["three"]["result"]
656         assert ret["one"]["changes"]
657         assert not ret["three"]["changes"], ret["three"]["changes"]
658         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
659         assert ret["four"]["comment"] == "No changes detected", ret["four"]["comment"]
660     def test_directory(self):
661         name = self.tmp_dir / "a_new_dir"
662         self.addCleanup(salt.utils.files.rm_rf, str(name))
663         ret = self.run_state("file.directory", name=str(name))
664         self.assertSaltTrueReturn(ret)
665         self.assertTrue(name.is_dir())
666     def test_directory_symlink_dry_run(self):
667         tmp_dir = self.tmp_dir / "pgdata"
668         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
669         sym_dir = self.tmp_dir / "pg_data"
670         self.addCleanup(salt.utils.files.safe_rm, str(sym_dir))
671         tmp_dir.mkdir(0o0700)
672         sym_dir.symlink_to(tmp_dir, target_is_directory=IS_WINDOWS)
673         if IS_WINDOWS:
674             ret = self.run_state(
675                 "file.directory",
676                 test=True,
677                 name=str(sym_dir),
678                 follow_symlinks=True,
679                 win_owner="Administrators",
680             )
681         else:
682             ret = self.run_state(
683                 "file.directory",
684                 test=True,
685                 name=str(sym_dir),
686                 follow_symlinks=True,
687                 mode=700,
688             )
689         self.assertSaltTrueReturn(ret)
690     @requires_system_grains
691     @pytest.mark.skip_if_not_root
692     @skipIf(IS_WINDOWS, "Mode not available in Windows")
693     def test_directory_max_depth(self, grains):
694         def _get_oct_mode(name):
695             return salt.utils.files.normalize_mode(oct(os.stat(name).st_mode &amp; 0o777))
696         top = os.path.join(RUNTIME_VARS.TMP, "top_dir")
697         self.addCleanup(salt.utils.files.rm_rf, top)
698         sub = os.path.join(top, "sub_dir")
699         subsub = os.path.join(sub, "sub_sub_dir")
700         dirs = [top, sub, subsub]
701         initial_mode = "0111"
702         changed_mode = "0555"
703         if grains["os"] in ("VMware Photon OS",):
704             initial_modes = {
705                 0: {sub: "0750", subsub: "0110"},
706                 1: {sub: "0110", subsub: "0110"},
707                 2: {sub: "0110", subsub: "0110"},
708             }
709         else:
710             initial_modes = {
711                 0: {sub: "0755", subsub: "0111"},
712                 1: {sub: "0111", subsub: "0111"},
713                 2: {sub: "0111", subsub: "0111"},
714             }
715         if not os.path.isdir(subsub):
716             os.makedirs(subsub, int(initial_mode, 8))
717         for depth in range(0, 3):
718             ret = self.run_state(
719                 "file.directory",
720                 name=top,
721                 max_depth=depth,
722                 dir_mode=changed_mode,
723                 recurse=["mode"],
724             )
725             self.assertSaltTrueReturn(ret)
726             for changed_dir in dirs[0 : depth + 1]:
727                 self.assertEqual(changed_mode, _get_oct_mode(changed_dir))
728             for untouched_dir in dirs[depth + 1 :]:
729                 if sys.version_info &gt;= (3, 7):
730                     _mode = initial_modes[depth][untouched_dir]
731                     self.assertEqual(_mode, _get_oct_mode(untouched_dir))
732                 else:
733                     self.assertEqual(initial_mode, _get_oct_mode(untouched_dir))
734     def test_test_directory(self):
735         name = self.tmp_dir / "a_not_dir"
736         self.addCleanup(shutil.rmtree, str(name), ignore_errors=True)
737         ret = self.run_state("file.directory", test=True, name=str(name))
738         self.assertSaltNoneReturn(ret)
739         self.assertFalse(name.is_dir())
740     @with_tempdir()
741     def test_directory_clean(self, base_dir):
742         name = os.path.join(base_dir, "directory_clean_dir")
743         os.mkdir(name)
744         strayfile = os.path.join(name, "strayfile")
745         with salt.utils.files.fopen(strayfile, "w"):
746             pass
747         straydir = os.path.join(name, "straydir")
748         if not os.path.isdir(straydir):
749             os.makedirs(straydir)
750         with salt.utils.files.fopen(os.path.join(straydir, "strayfile2"), "w"):
751             pass
752         ret = self.run_state("file.directory", name=name, clean=True)
753         self.assertSaltTrueReturn(ret)
754         self.assertFalse(os.path.exists(strayfile))
755         self.assertFalse(os.path.exists(straydir))
756         self.assertTrue(os.path.isdir(name))
757     def test_directory_is_idempotent(self):
758         name = self.tmp_dir / "a_dir_twice"
759         self.addCleanup(salt.utils.files.rm_rf, str(name))
760         if IS_WINDOWS:
761             username = os.environ.get("USERNAME", "Administrators")
762             domain = os.environ.get("USERDOMAIN", "")
763             fullname = "{}\\{}".format(domain, username)
764             ret = self.run_state("file.directory", name=str(name), win_owner=fullname)
765         else:
766             ret = self.run_state("file.directory", name=str(name))
767         self.assertSaltTrueReturn(ret)
768         if IS_WINDOWS:
769             ret = self.run_state("file.directory", name=str(name), win_owner=username)
770         else:
771             ret = self.run_state("file.directory", name=str(name))
772         self.assertSaltTrueReturn(ret)
773         self.assertSaltStateChangesEqual(ret, {})
774     @with_tempdir()
775     def test_directory_clean_exclude(self, base_dir):
776         name = os.path.join(base_dir, "directory_clean_dir")
777         if not os.path.isdir(name):
778             os.makedirs(name)
779         strayfile = os.path.join(name, "strayfile")
780         with salt.utils.files.fopen(strayfile, "w"):
781             pass
782         straydir = os.path.join(name, "straydir")
783         if not os.path.isdir(straydir):
784             os.makedirs(straydir)
785         strayfile2 = os.path.join(straydir, "strayfile2")
786         with salt.utils.files.fopen(strayfile2, "w"):
787             pass
788         keepfile = os.path.join(straydir, "keepfile")
789         with salt.utils.files.fopen(keepfile, "w"):
790             pass
791         exclude_pat = "E@^straydir(|/keepfile)$"
792         if IS_WINDOWS:
793             exclude_pat = "E@^straydir(|\\\\keepfile)$"
794         ret = self.run_state(
795             "file.directory", name=name, clean=True, exclude_pat=exclude_pat
796         )
797         self.assertSaltTrueReturn(ret)
798         self.assertFalse(os.path.exists(strayfile))
799         self.assertFalse(os.path.exists(strayfile2))
800         self.assertTrue(os.path.exists(keepfile))
801     @skipIf(IS_WINDOWS, "Skip on windows")
802     @with_tempdir()
803     def test_test_directory_clean_exclude(self, base_dir):
804         name = os.path.join(base_dir, "directory_clean_dir")
805         os.mkdir(name)
806         strayfile = os.path.join(name, "strayfile")
807         with salt.utils.files.fopen(strayfile, "w"):
808             pass
809         straydir = os.path.join(name, "straydir")
810         if not os.path.isdir(straydir):
811             os.makedirs(straydir)
812         strayfile2 = os.path.join(straydir, "strayfile2")
813         with salt.utils.files.fopen(strayfile2, "w"):
814             pass
815         keepfile = os.path.join(straydir, "keepfile")
816         with salt.utils.files.fopen(keepfile, "w"):
817             pass
818         exclude_pat = "E@^straydir(|/keepfile)$"
819         if IS_WINDOWS:
820             exclude_pat = "E@^straydir(|\\\\keepfile)$"
821         ret = self.run_state(
822             "file.directory", test=True, name=name, clean=True, exclude_pat=exclude_pat
823         )
824         comment = next(iter(ret.values()))["comment"]
825         self.assertSaltNoneReturn(ret)
826         self.assertTrue(os.path.exists(strayfile))
827         self.assertTrue(os.path.exists(strayfile2))
828         self.assertTrue(os.path.exists(keepfile))
829         self.assertIn(strayfile, comment)
830         self.assertIn(strayfile2, comment)
831         self.assertNotIn(keepfile, comment)
832     @with_tempdir()
833     def test_directory_clean_require_in(self, name):
834         state_name = "file-FileTest-test_directory_clean_require_in"
835         state_filename = state_name + ".sls"
836         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
837         wrong_file = os.path.join(name, "wrong")
838         with salt.utils.files.fopen(wrong_file, "w") as fp:
839             fp.write("foo")
840         good_file = os.path.join(name, "bar")
841         with salt.utils.files.fopen(state_file, "w") as fp:
842             self.addCleanup(salt.utils.files.safe_rm, state_file)
843             fp.write(
844                 textwrap.dedent(
845                         name=name, good_file=good_file
846                     )
847                 )
848             )
849         ret = self.run_function("state.sls", [state_name])
850         self.assertTrue(os.path.exists(good_file))
851         self.assertFalse(os.path.exists(wrong_file))
852     @with_tempdir()
853     def test_directory_clean_require_in_with_id(self, name):
854         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
855         state_filename = state_name + ".sls"
856         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
857         wrong_file = os.path.join(name, "wrong")
858         with salt.utils.files.fopen(wrong_file, "w") as fp:
859             fp.write("foo")
860         good_file = os.path.join(name, "bar")
861         with salt.utils.files.fopen(state_file, "w") as fp:
862             self.addCleanup(salt.utils.files.safe_rm, state_file)
863             fp.write(
864                 textwrap.dedent(
865                         name=name, good_file=good_file
866                     )
867                 )
868             )
869         ret = self.run_function("state.sls", [state_name])
870         self.assertTrue(os.path.exists(good_file))
871         self.assertFalse(os.path.exists(wrong_file))
872     @skipIf(
873         salt.utils.platform.is_darwin(),
874         "WAR ROOM TEMPORARY SKIP, Test is flaky on macosx",
875     )
876     @with_tempdir()
877     def test_directory_clean_require_with_name(self, name):
878         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
879         state_filename = state_name + ".sls"
880         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
881         wrong_file = os.path.join(name, "wrong")
882         with salt.utils.files.fopen(wrong_file, "w") as fp:
883             fp.write("foo")
884         good_file = os.path.join(name, "bar")
885         with salt.utils.files.fopen(state_file, "w") as fp:
886             self.addCleanup(salt.utils.files.safe_rm, state_file)
887             fp.write(
888                 textwrap.dedent(
889                         name=name, good_file=good_file
890                     )
891                 )
892             )
893         ret = self.run_function("state.sls", [state_name])
894         self.assertTrue(os.path.exists(good_file))
895         self.assertFalse(os.path.exists(wrong_file))
896     def test_directory_broken_symlink(self):
897         tmp_dir = self.tmp_dir / "foo"
898         tmp_dir.mkdir(0o700)
899         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
900         null_file = tmp_dir / "null"
901         broken_link = tmp_dir / "broken"
902         broken_link.symlink_to(null_file)
903         if IS_WINDOWS:
904             ret = self.run_state(
905                 "file.directory",
906                 name=str(tmp_dir),
907                 recurse=["mode"],
908                 follow_symlinks=True,
909                 win_owner="Administrators",
910             )
911         else:
912             ret = self.run_state(
913                 "file.directory",
914                 name=str(tmp_dir),
915                 recurse=["mode"],
916                 file_mode=644,
917                 dir_mode=755,
918             )
919         self.assertSaltTrueReturn(ret)
920     @with_tempdir(create=False)
921     def test_recurse(self, name):
922         ret = self.run_state("file.recurse", name=name, source="salt://grail")
923         self.assertSaltTrueReturn(ret)
924         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
925     @with_tempdir(create=False)
926     @with_tempdir(create=False)
927     def test_recurse_specific_env(self, dir1, dir2):
928         ret = self.run_state(
929             "file.recurse", name=dir1, source="salt://holy", __env__="prod"
930         )
931         self.assertSaltTrueReturn(ret)
932         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
933         ret = self.run_state(
934             "file.recurse", name=dir2, source="salt://holy", saltenv="prod"
935         )
936         self.assertSaltTrueReturn(ret)
937         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
938     @with_tempdir(create=False)
939     @with_tempdir(create=False)
940     def test_recurse_specific_env_in_url(self, dir1, dir2):
941         ret = self.run_state(
942             "file.recurse", name=dir1, source="salt://holy?saltenv=prod"
943         )
944         self.assertSaltTrueReturn(ret)
945         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
946         ret = self.run_state(
947             "file.recurse", name=dir2, source="salt://holy?saltenv=prod"
948         )
949         self.assertSaltTrueReturn(ret)
950         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
951     @with_tempdir(create=False)
952     def test_test_recurse(self, name):
953         ret = self.run_state(
954             "file.recurse",
955             test=True,
956             name=name,
957             source="salt://grail",
958         )
959         self.assertSaltNoneReturn(ret)
960         self.assertFalse(os.path.isfile(os.path.join(name, "36", "scene")))
961         self.assertFalse(os.path.exists(name))
962     @with_tempdir(create=False)
963     @with_tempdir(create=False)
964     def test_test_recurse_specific_env(self, dir1, dir2):
965         ret = self.run_state(
966             "file.recurse", test=True, name=dir1, source="salt://holy", __env__="prod"
967         )
968         self.assertSaltNoneReturn(ret)
969         self.assertFalse(os.path.isfile(os.path.join(dir1, "32", "scene")))
970         self.assertFalse(os.path.exists(dir1))
971         ret = self.run_state(
972             "file.recurse", test=True, name=dir2, source="salt://holy", saltenv="prod"
973         )
974         self.assertSaltNoneReturn(ret)
975         self.assertFalse(os.path.isfile(os.path.join(dir2, "32", "scene")))
976         self.assertFalse(os.path.exists(dir2))
977     @with_tempdir(create=False)
978     def test_recurse_template(self, name):
979         _ts = "TEMPLATE TEST STRING"
980         ret = self.run_state(
981             "file.recurse",
982             name=name,
983             source="salt://grail",
984             template="jinja",
985             defaults={"spam": _ts},
986         )
987         self.assertSaltTrueReturn(ret)
988         with salt.utils.files.fopen(os.path.join(name, "scene33"), "r") as fp_:
989             contents = fp_.read()
990         self.assertIn(_ts, contents)
991     @with_tempdir()
992     def test_recurse_clean(self, name):
993         strayfile = os.path.join(name, "strayfile")
994         with salt.utils.files.fopen(strayfile, "w"):
995             pass
996         with salt.utils.files.fopen(os.path.join(name, "36"), "w"):
997             pass
998         os.makedirs(os.path.join(name, "scene33"))
999         ret = self.run_state(
1000             "file.recurse", name=name, source="salt://grail", clean=True
1001         )
1002         self.assertSaltTrueReturn(ret)
1003         self.assertFalse(os.path.exists(strayfile))
1004         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1005         self.assertTrue(os.path.isfile(os.path.join(name, "scene33")))
1006     @with_tempdir()
1007     def test_recurse_clean_specific_env(self, name):
1008         strayfile = os.path.join(name, "strayfile")
1009         with salt.utils.files.fopen(strayfile, "w"):
1010             pass
1011         with salt.utils.files.fopen(os.path.join(name, "32"), "w"):
1012             pass
1013         os.makedirs(os.path.join(name, "scene34"))
1014         ret = self.run_state(
1015             "file.recurse", name=name, source="salt://holy", clean=True, __env__="prod"
1016         )
1017         self.assertSaltTrueReturn(ret)
1018         self.assertFalse(os.path.exists(strayfile))
1019         self.assertTrue(os.path.isfile(os.path.join(name, "32", "scene")))
1020         self.assertTrue(os.path.isfile(os.path.join(name, "scene34")))
1021     @skipIf(IS_WINDOWS, "Skip on windows")
1022     @with_tempdir()
1023     def test_recurse_issue_34945(self, base_dir):
1024         dir_mode = "2775"
1025         issue_dir = "issue-34945"
1026         name = os.path.join(base_dir, issue_dir)
1027         ret = self.run_state(
1028             "file.recurse", name=name, source="salt://" + issue_dir, dir_mode=dir_mode
1029         )
1030         self.assertSaltTrueReturn(ret)
1031         actual_dir_mode = oct(stat.S_IMODE(os.stat(name).st_mode))[-4:]
1032         self.assertEqual(dir_mode, actual_dir_mode)
1033     @with_tempdir(create=False)
1034     def test_recurse_issue_40578(self, name):
1035         ret = self.run_state("file.recurse", name=name, source="salt://соль")
1036         self.assertSaltTrueReturn(ret)
1037         files = salt.utils.data.decode(os.listdir(name), normalize=True)
1038         self.assertEqual(
1039             sorted(files),
1040             sorted(["foo.txt", "спам.txt", "яйца.txt"]),
1041         )
1042     @with_tempfile()
1043     def test_replace(self, name):
1044         with salt.utils.files.fopen(name, "w+") as fp_:
1045             fp_.write("change_me")
1046         ret = self.run_state(
1047             "file.replace", name=name, pattern="change", repl="salt", backup=False
1048         )
1049         with salt.utils.files.fopen(name, "r") as fp_:
1050             self.assertIn("salt", fp_.read())
1051         self.assertSaltTrueReturn(ret)
1052     @with_tempdir()
1053     def test_replace_issue_18612(self, base_dir):
1054         test_name = "test_replace_issue_18612"
1055         path_test = os.path.join(base_dir, test_name)
1056         with salt.utils.files.fopen(path_test, "w+") as fp_test_:
1057             fp_test_.write("# en_US.UTF-8")
1058         ret = []
1059         for x in range(0, 3):
1060             ret.append(
1061                 self.run_state(
1062                     "file.replace",
1063                     name=path_test,
1064                     pattern="^# en_US.UTF-8$",
1065                     repl="en_US.UTF-8",
1066                     append_if_not_found=True,
1067                 )
1068             )
1069         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1070             self.assertTrue(sum(1 for _ in fp_test_) == 1)
1071         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1072             self.assertTrue(fp_test_.read().startswith("en_US.UTF-8"))
1073         for item in ret:
1074             self.assertSaltTrueReturn(item)
1075     @with_tempdir()
1076     def test_replace_issue_18612_prepend(self, base_dir):
1077         test_name = "test_replace_issue_18612_prepend"
1078         path_in = os.path.join(
1079             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1080         )
1081         path_out = os.path.join(
1082             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1083         )
1084         path_test = os.path.join(base_dir, test_name)
1085         shutil.copyfile(path_in, path_test)
1086         ret = []
1087         for x in range(0, 3):
1088             ret.append(
1089                 self.run_state(
1090                     "file.replace",
1091                     name=path_test,
1092                     pattern="^# en_US.UTF-8$",
1093                     repl="en_US.UTF-8",
1094                     prepend_if_not_found=True,
1095                 )
1096             )
1097         self.assertTrue(filecmp.cmp(path_test, path_out))
1098         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1099         for item in ret:
1100             self.assertSaltTrueReturn(item)
1101     @with_tempdir()
1102     def test_replace_issue_18612_append(self, base_dir):
1103         test_name = "test_replace_issue_18612_append"
1104         path_in = os.path.join(
1105             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1106         )
1107         path_out = os.path.join(
1108             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1109         )
1110         path_test = os.path.join(base_dir, test_name)
1111         shutil.copyfile(path_in, path_test)
1112         ret = []
1113         for x in range(0, 3):
1114             ret.append(
1115                 self.run_state(
1116                     "file.replace",
1117                     name=path_test,
1118                     pattern="^# en_US.UTF-8$",
1119                     repl="en_US.UTF-8",
1120                     append_if_not_found=True,
1121                 )
1122             )
1123         self.assertTrue(filecmp.cmp(path_test, path_out))
1124         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1125         for item in ret:
1126             self.assertSaltTrueReturn(item)
1127     @with_tempdir()
1128     def test_replace_issue_18612_append_not_found_content(self, base_dir):
1129         test_name = "test_replace_issue_18612_append_not_found_content"
1130         path_in = os.path.join(
1131             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1132         )
1133         path_out = os.path.join(
1134             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1135         )
1136         path_test = os.path.join(base_dir, test_name)
1137         shutil.copyfile(path_in, path_test)
1138         ret = []
1139         for x in range(0, 3):
1140             ret.append(
1141                 self.run_state(
1142                     "file.replace",
1143                     name=path_test,
1144                     pattern="^# en_US.UTF-8$",
1145                     repl="en_US.UTF-8",
1146                     append_if_not_found=True,
1147                     not_found_content=(
1148                         "THIS LINE WASN'T FOUND! SO WE'RE APPENDING IT HERE!"
1149                     ),
1150                 )
1151             )
1152         self.assertTrue(filecmp.cmp(path_test, path_out))
1153         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1154         for item in ret:
1155             self.assertSaltTrueReturn(item)
1156     @with_tempdir()
1157     def test_replace_issue_18612_change_mid_line_with_comment(self, base_dir):
1158         test_name = "test_replace_issue_18612_change_mid_line_with_comment"
1159         path_in = os.path.join(
1160             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1161         )
1162         path_out = os.path.join(
1163             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1164         )
1165         path_test = os.path.join(base_dir, test_name)
1166         shutil.copyfile(path_in, path_test)
1167         ret = []
1168         for x in range(0, 3):
1169             ret.append(
1170                 self.run_state(
1171                     "file.replace",
1172                     name=path_test,
1173                     pattern="^#foo=bar($|(?=\r\n))",
1174                     repl="foo=salt",
1175                     append_if_not_found=True,
1176                 )
1177             )
1178         self.assertTrue(filecmp.cmp(path_test, path_out))
1179         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1180         for item in ret:
1181             self.assertSaltTrueReturn(item)
1182     @with_tempdir()
1183     def test_replace_issue_18841_no_changes(self, base_dir):
1184         test_name = "test_replace_issue_18841_no_changes"
1185         path_in = os.path.join(
1186             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1187         )
1188         path_test = os.path.join(base_dir, test_name)
1189         shutil.copyfile(path_in, path_test)
1190         fstats_orig = os.stat(path_test)
1191         age = 5 * 24 * 60 * 60
1192         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1193         ret = self.run_state(
1194             "file.replace",
1195             name=path_test,
1196             pattern="^hello world$",
1197             repl="goodbye world",
1198             show_changes=True,
1199             flags=["IGNORECASE"],
1200             backup=False,
1201         )
1202         fstats_post = os.stat(path_test)
1203         self.assertTrue(filecmp.cmp(path_in, path_test))
1204         self.assertFalse(os.path.exists(path_test + ".bak"))
1205         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1206         self.assertSaltTrueReturn(ret)
1207     def test_serialize(self):
1208         path_test = self.tmp_dir / "test_serialize"
1209         self.addCleanup(salt.utils.files.safe_rm, str(path_test))
1210         ret = self.run_state(
1211             "file.serialize",
1212             name=str(path_test),
1213             dataset={
1214                 "name": "naive",
1215                 "description": "A basic test",
1216                 "a_list": ["first_element", "second_element"],
1217                 "finally": "the last item",
1218             },
1219             formatter="json",
1220         )
1221         serialized_file = salt.utils.stringutils.to_unicode(path_test.read_bytes())
1222         expected_file = "\n".join(
1223             [
1224                 "{",
1225                 '  "a_list": [',
1226                 '    "first_element",',
1227                 '    "second_element"',
1228                 "  ],",
1229                 '  "description": "A basic test",',
1230                 '  "finally": "the last item",',
1231                 '  "name": "naive"',
1232                 "}",
1233                 "",
1234             ]
1235         )
1236         self.assertEqual(serialized_file, expected_file)
1237     @with_tempfile(create=False)
1238     def test_serializer_deserializer_opts(self, name):
1239         data1 = {"foo": {"bar": "%(x)s"}}
1240         data2 = {"foo": {"abc": 123}}
1241         merged = {"foo": {"y": "not_used", "x": "baz", "abc": 123, "bar": "baz"}}
1242         ret = self.run_state(
1243             "file.serialize",
1244             name=name,
1245             dataset=data1,
1246             formatter="configparser",
1247             deserializer_opts=[{"defaults": {"y": "not_used"}}],
1248         )
1249         ret = ret[next(iter(ret))]
1250         assert ret["result"], ret
1251         assert "warnings" in ret
1252         ret = self.run_state(
1253             "file.serialize",
1254             name=name,
1255             dataset=data2,
1256             formatter="configparser",
1257             merge_if_exists=True,
1258             serializer_opts=[{"defaults": {"y": "not_used"}}],
1259             deserializer_opts=[{"defaults": {"x": "baz"}}],
1260         )
1261         ret = ret[next(iter(ret))]
1262         assert ret["result"], ret
1263         with salt.utils.files.fopen(name) as fp_:
1264             serialized_data = salt.serializers.configparser.deserialize(fp_)
1265         log.debug("serialized_data = %r", serialized_data)
1266         log.debug("merged = %r", merged)
1267         assert serialized_data["foo"]["y"] == merged["foo"]["y"]
1268         assert serialized_data["foo"]["bar"] == merged["foo"]["bar"]
1269     @with_tempfile(create=False)
1270     def test_serializer_plist_binary_file_open(self, name):
1271         data1 = {"foo": {"bar": "%(x)s"}}
1272         data2 = {"foo": {"abc": 123}}
1273         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1274         ret = self.run_state(
1275             "file.serialize",
1276             name=name,
1277             dataset=data1,
1278             formatter="plist",
1279             serializer_opts=[{"fmt": "FMT_BINARY"}],
1280         )
1281         ret = ret[next(iter(ret))]
1282         assert ret["result"], ret
1283         ret = self.run_state(
1284             "file.serialize",
1285             name=name,
1286             dataset=data2,
1287             formatter="plist",
1288             merge_if_exists=True,
1289             serializer_opts=[{"fmt": "FMT_BINARY"}],
1290         )
1291         ret = ret[next(iter(ret))]
1292         assert ret["result"], ret
1293         with salt.utils.files.fopen(name, "rb") as fp_:
1294             serialized_data = salt.serializers.plist.deserialize(fp_)
1295         assert serialized_data["foo"] == merged["foo"]
1296     @with_tempfile(create=False)
1297     def test_serializer_plist_file_open(self, name):
1298         data1 = {"foo": {"bar": "%(x)s"}}
1299         data2 = {"foo": {"abc": 123}}
1300         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1301         ret = self.run_state(
1302             "file.serialize",
1303             name=name,
1304             dataset=data1,
1305             formatter="plist",
1306         )
1307         ret = ret[next(iter(ret))]
1308         assert ret["result"], ret
1309         ret = self.run_state(
1310             "file.serialize",
1311             name=name,
1312             dataset=data2,
1313             formatter="plist",
1314             merge_if_exists=True,
1315         )
1316         ret = ret[next(iter(ret))]
1317         assert ret["result"], ret
1318         with salt.utils.files.fopen(name, "rb") as fp_:
1319             serialized_data = salt.serializers.plist.deserialize(fp_)
1320         assert serialized_data["foo"] == merged["foo"]
1321     @with_tempdir()
1322     def test_replace_issue_18841_omit_backup(self, base_dir):
1323         test_name = "test_replace_issue_18841_omit_backup"
1324         path_in = os.path.join(
1325             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1326         )
1327         path_test = os.path.join(base_dir, test_name)
1328         shutil.copyfile(path_in, path_test)
1329         fstats_orig = os.stat(path_test)
1330         age = 5 * 24 * 60 * 60
1331         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1332         ret = self.run_state(
1333             "file.replace",
1334             name=path_test,
1335             pattern="^hello world$",
1336             repl="goodbye world",
1337             show_changes=True,
1338             flags=["IGNORECASE"],
1339         )
1340         fstats_post = os.stat(path_test)
1341         self.assertTrue(filecmp.cmp(path_in, path_test))
1342         self.assertFalse(os.path.exists(path_test + ".bak"))
1343         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1344         self.assertSaltTrueReturn(ret)
1345     @with_tempfile()
1346     def test_comment(self, name):
1347         with salt.utils.files.fopen(name, "w+") as fp_:
1348             fp_.write("comment_me")
1349         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1350         self.assertSaltNoneReturn(ret)
1351         ret = self.run_state("file.comment", name=name, regex="^comment")
1352         self.assertSaltTrueReturn(ret)
1353         with salt.utils.files.fopen(name, "r") as fp_:
1354             self.assertTrue(fp_.read().startswith("#comment"))
1355         ret = self.run_state("file.comment", name=name, regex="^comment")
1356         self.assertSaltTrueReturn(ret)
1357         with salt.utils.files.fopen(name, "r") as fp_:
1358             self.assertTrue(fp_.read().startswith("#comment"))
1359         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1360         self.assertSaltTrueReturn(ret)
1361     @with_tempfile()
1362     def test_test_comment(self, name):
1363         with salt.utils.files.fopen(name, "w+") as fp_:
1364             fp_.write("comment_me")
1365         ret = self.run_state(
1366             "file.comment",
1367             test=True,
1368             name=name,
1369             regex=".*comment.*",
1370         )
1371         with salt.utils.files.fopen(name, "r") as fp_:
1372             self.assertNotIn("#comment", fp_.read())
1373         self.assertSaltNoneReturn(ret)
1374     @with_tempfile()
1375     def test_uncomment(self, name):
1376         with salt.utils.files.fopen(name, "w+") as fp_:
1377             fp_.write("#comment_me")
1378         ret = self.run_state("file.uncomment", name=name, regex="^comment")
1379         with salt.utils.files.fopen(name, "r") as fp_:
1380             self.assertNotIn("#comment", fp_.read())
1381         self.assertSaltTrueReturn(ret)
1382     @with_tempfile()
1383     def test_test_uncomment(self, name):
1384         with salt.utils.files.fopen(name, "w+") as fp_:
1385             fp_.write("#comment_me")
1386         ret = self.run_state("file.uncomment", test=True, name=name, regex="^comment.*")
1387         with salt.utils.files.fopen(name, "r") as fp_:
1388             self.assertIn("#comment", fp_.read())
1389         self.assertSaltNoneReturn(ret)
1390     @with_tempfile()
1391     def test_append(self, name):
1392         with salt.utils.files.fopen(name, "w+") as fp_:
1393             fp_.write("#salty!")
1394         ret = self.run_state("file.append", name=name, text="cheese")
1395         with salt.utils.files.fopen(name, "r") as fp_:
1396             self.assertIn("cheese", fp_.read())
1397         self.assertSaltTrueReturn(ret)
1398     @with_tempfile()
1399     def test_test_append(self, name):
1400         with salt.utils.files.fopen(name, "w+") as fp_:
1401             fp_.write("#salty!")
1402         ret = self.run_state("file.append", test=True, name=name, text="cheese")
1403         with salt.utils.files.fopen(name, "r") as fp_:
1404             self.assertNotIn("cheese", fp_.read())
1405         self.assertSaltNoneReturn(ret)
1406     @with_tempdir()
1407     def test_append_issue_1864_makedirs(self, base_dir):
1408         fname = "append_issue_1864_makedirs"
1409         name = os.path.join(base_dir, fname)
1410         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1411         self.assertSaltTrueReturn(ret)
1412         name = os.path.join(base_dir, "issue_1864", fname)
1413         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1414         self.assertSaltTrueReturn(ret)
1415         name = os.path.join(base_dir, "issue_1864", fname + "2")
1416         ret = self.run_state("file.append", name=name, text="cheese")
1417         self.assertSaltTrueReturn(ret)
1418         self.assertTrue(os.path.isfile(name))
1419     @with_tempdir()
1420     def test_prepend_issue_27401_makedirs(self, base_dir):
1421         fname = "prepend_issue_27401"
1422         name = os.path.join(base_dir, fname)
1423         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1424         self.assertSaltTrueReturn(ret)
1425         name = os.path.join(base_dir, "issue_27401", fname)
1426         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1427         self.assertSaltTrueReturn(ret)
1428         name = os.path.join(base_dir, "issue_27401", fname + "2")
1429         ret = self.run_state("file.prepend", name=name, text="cheese")
1430         self.assertSaltTrueReturn(ret)
1431         self.assertTrue(os.path.isfile(name))
1432     @with_tempfile()
1433     def test_touch(self, name):
1434         ret = self.run_state("file.touch", name=name)
1435         self.assertTrue(os.path.isfile(name))
1436         self.assertSaltTrueReturn(ret)
1437     @with_tempfile(create=False)
1438     def test_test_touch(self, name):
1439         ret = self.run_state("file.touch", test=True, name=name)
1440         self.assertFalse(os.path.isfile(name))
1441         self.assertSaltNoneReturn(ret)
1442     @with_tempdir()
1443     def test_touch_directory(self, base_dir):
1444         name = os.path.join(base_dir, "touch_test_dir")
1445         os.mkdir(name)
1446         ret = self.run_state("file.touch", name=name)
1447         self.assertSaltTrueReturn(ret)
1448         self.assertTrue(os.path.isdir(name))
1449     @with_tempdir()
1450     def test_issue_2227_file_append(self, base_dir):
1451         tmp_file_append = os.path.join(base_dir, "test.append")
1452         self.run_state("file.touch", name=tmp_file_append)
1453         self.run_state(
1454             "file.append", name=tmp_file_append, source="salt://testappend/firstif"
1455         )
1456         self.run_state(
1457             "file.append", name=tmp_file_append, source="salt://testappend/secondif"
1458         )
1459         try:
1460             ret = self.run_state(
1461                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1462             )
1463             self.assertSaltTrueReturn(ret)
1464             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1465                 contents_pre = fp_.read()
1466             ret = self.run_state(
1467                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1468             )
1469             self.assertSaltTrueReturn(ret)
1470             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1471                 contents_post = fp_.read()
1472             self.assertEqual(contents_pre, contents_post)
1473         except AssertionError:
1474             if os.path.exists(tmp_file_append):
1475                 shutil.copy(tmp_file_append, tmp_file_append + ".bak")
1476             raise
1477     @with_tempdir()
1478     def test_issue_2401_file_comment(self, base_dir):
1479         tmp_file = os.path.join(base_dir, "issue-2041-comment.txt")
1480         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1481             fp_.write("hello\nworld\n")
1482         template_lines = [
1483             "{}:".format(tmp_file),
1484             "  file.comment:",
1485             "    - regex: ^world",
1486 <a name="3"></a>        ]
1487         template = "\n".join(template_lines)
1488         try:
1489             ret <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.run_function("state.template_str", [template], timeout=120)
1490             self.assertSaltTrueReturn(ret)
1491             self.assertNotInSaltComment("Pattern already commented", ret)
1492             self.assertInSaltComment("Commented lines successfully", ret)
1493             ret = self.run_function(</b></font>"state.template_str", [template], timeout=120)
1494             self.assertSaltTrueReturn(ret)
1495             self.assertInSaltComment("Pattern already commented", ret)
1496         except AssertionError:
1497             shutil.copy(tmp_file, tmp_file + ".bak")
1498             raise
1499     @with_tempdir()
1500     def test_issue_2379_file_append(self, base_dir):
1501         tmp_file = os.path.join(base_dir, "issue-2379-file-append.txt")
1502         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1503             fp_.write(
1504                 "hello\nworld\n"  # Some junk
1505                 "#PermitRootLogin yes\n"  # Commented text
1506                 "# PermitRootLogin yes\n"  # Commented text with space
1507             )
1508         template_lines = [
1509             "{}:".format(tmp_file),
1510             "  file.append:",
1511             "    - text: PermitRootLogin yes",
1512         ]
1513         template = "\n".join(template_lines)
1514         try:
1515             ret = self.run_function("state.template_str", [template])
1516             self.assertSaltTrueReturn(ret)
1517             self.assertInSaltComment("Appended 1 lines", ret)
1518         except AssertionError:
1519             shutil.copy(tmp_file, tmp_file + ".bak")
1520             raise
1521     @skipIf(IS_WINDOWS, "Mode not available in Windows")
1522     @with_tempdir(create=False)
1523     @with_tempdir(create=False)
1524     def test_issue_2726_mode_kwarg(self, dir1, dir2):
1525         bad_mode_kwarg_testfile = os.path.join(dir1, "bad_mode_kwarg", "testfile")
1526         bad_template = [
1527             "{}:".format(bad_mode_kwarg_testfile),
1528             "  file.recurse:",
1529             "    - source: salt://testfile",
1530             "    - mode: 644",
1531         ]
1532         ret = self.run_function("state.template_str", [os.linesep.join(bad_template)])
1533         self.assertSaltFalseReturn(ret)
1534         self.assertInSaltComment(
1535             "'mode' is not allowed in 'file.recurse'. Please use "
1536             "'file_mode' and 'dir_mode'.",
1537             ret,
1538         )
1539         self.assertNotInSaltComment(
1540             "TypeError: managed() got multiple values for keyword argument 'mode'",
1541             ret,
1542         )
1543         good_mode_kwargs_testfile = os.path.join(dir2, "good_mode_kwargs", "testappend")
1544         good_template = [
1545             "{}:".format(good_mode_kwargs_testfile),
1546             "  file.recurse:",
1547             "    - source: salt://testappend",
1548             "    - dir_mode: 744",
1549             "    - file_mode: 644",
1550         ]
1551         ret = self.run_function("state.template_str", [os.linesep.join(good_template)])
1552         self.assertSaltTrueReturn(ret)
1553     @with_tempdir()
1554     def test_issue_8343_accumulated_require_in(self, base_dir):
1555         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8343.sls")
1556         testcase_filedest = os.path.join(base_dir, "issue-8343.txt")
1557         if os.path.exists(template_path):
1558             os.remove(template_path)
1559         if os.path.exists(testcase_filedest):
1560             os.remove(testcase_filedest)
1561         sls_template = [
1562             "{0}:",
1563             "  file.managed:",
1564             "    - contents: |",
1565             "                #",
1566             "",
1567             "prepend-foo-accumulator-from-pillar:",
1568             "  file.accumulated:",
1569             "    - require_in:",
1570             "      - file: prepend-foo-management",
1571             "    - filename: {0}",
1572             "    - text: |",
1573             "            foo",
1574             "",
1575             "append-foo-accumulator-from-pillar:",
1576             "  file.accumulated:",
1577             "    - require_in:",
1578             "      - file: append-foo-management",
1579             "    - filename: {0}",
1580             "    - text: |",
1581             "            bar",
1582             "",
1583             "prepend-foo-management:",
1584             "  file.blockreplace:",
1585             "    - name: {0}",
1586             '    - marker_start: "#-- start salt managed zonestart -- PLEASE, DO NOT'
1587             ' EDIT"',
1588             '    - marker_end: "#-- end salt managed zonestart --"',
1589             "    - content: ''",
1590             "    - prepend_if_not_found: True",
1591             "    - backup: '.bak'",
1592             "    - show_changes: True",
1593             "",
1594             "append-foo-management:",
1595             "  file.blockreplace:",
1596             "    - name: {0}",
1597             '    - marker_start: "#-- start salt managed zoneend -- PLEASE, DO NOT'
1598             ' EDIT"',
1599             '    - marker_end: "#-- end salt managed zoneend --"',
1600             "    - content: ''",
1601             "    - append_if_not_found: True",
1602             "    - backup: '.bak2'",
1603             "    - show_changes: True",
1604             "",
1605         ]
1606         with salt.utils.files.fopen(template_path, "w") as fp_:
1607             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
1608         ret = self.run_function("state.sls", mods="issue-8343")
1609         for name, step in ret.items():
1610             self.assertSaltTrueReturn({name: step})
1611         with salt.utils.files.fopen(testcase_filedest) as fp_:
1612             contents = fp_.read().split(os.linesep)
1613         expected = [
1614             "#-- start salt managed zonestart -- PLEASE, DO NOT EDIT",
1615             "foo",
1616             "#-- end salt managed zonestart --",
1617             "#",
1618             "#-- start salt managed zoneend -- PLEASE, DO NOT EDIT",
1619             "bar",
1620             "#-- end salt managed zoneend --",
1621             "",
1622         ]
1623         self.assertEqual(
1624             [salt.utils.stringutils.to_str(line) for line in expected], contents
1625         )
1626     @with_tempdir()
1627     def test_issue_11003_immutable_lazy_proxy_sum(self, base_dir):
1628         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-11003.sls")
1629         testcase_filedest = os.path.join(base_dir, "issue-11003.txt")
1630         sls_template = [
1631             "a{0}:",
1632             "  file.absent:",
1633             "    - name: {0}",
1634             "",
1635             "{0}:",
1636             "  file.managed:",
1637             "    - contents: |",
1638             "                #",
1639             "",
1640             "test-acc1:",
1641             "  file.accumulated:",
1642             "    - require_in:",
1643             "      - file: final",
1644             "    - filename: {0}",
1645             "    - text: |",
1646             "            bar",
1647             "",
1648             "test-acc2:",
1649             "  file.accumulated:",
1650             "    - watch_in:",
1651             "      - file: final",
1652             "    - filename: {0}",
1653             "    - text: |",
1654             "            baz",
1655             "",
1656             "final:",
1657             "  file.blockreplace:",
1658             "    - name: {0}",
1659             '    - marker_start: "#-- start managed zone PLEASE, DO NOT EDIT"',
1660             '    - marker_end: "#-- end managed zone"',
1661             "    - content: ''",
1662             "    - append_if_not_found: True",
1663             "    - show_changes: True",
1664         ]
1665         with salt.utils.files.fopen(template_path, "w") as fp_:
1666             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
1667         ret = self.run_function("state.sls", mods="issue-11003", timeout=600)
1668         for name, step in ret.items():
1669             self.assertSaltTrueReturn({name: step})
1670         with salt.utils.files.fopen(testcase_filedest) as fp_:
1671             contents = fp_.read().split(os.linesep)
1672         begin = contents.index("#-- start managed zone PLEASE, DO NOT EDIT") + 1
1673         end = contents.index("#-- end managed zone")
1674         block_contents = contents[begin:end]
1675         for item in ("", "bar", "baz"):
1676             block_contents.remove(item)
1677         self.assertEqual(block_contents, [])
1678     @with_tempdir()
1679     def test_issue_8947_utf8_sls(self, base_dir):
1680         self.maxDiff = None
1681         korean_1 = "한국어 시험"
1682         korean_2 = "첫 번째 행"
1683         korean_3 = "마지막 행"
1684         test_file = os.path.join(base_dir, "{}.txt".format(korean_1))
1685         test_file_encoded = test_file
1686         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8947.sls")
1687         template = textwrap.dedent(
1688                 **locals()
1689             )
1690         )
1691         if not salt.utils.platform.is_windows():
1692             template += textwrap.dedent(
1693                     **locals()
1694                 )
1695             )
1696         with salt.utils.files.fopen(template_path, "wb") as fp_:
1697             fp_.write(salt.utils.stringutils.to_bytes(template))
1698         try:
1699             result = self.run_function("state.sls", mods="issue-8947")
1700             if not isinstance(result, dict):
1701                 raise AssertionError(
1702                     "Something went really wrong while testing this sls: {!r}".format(
1703                         result
1704                     )
1705                 )
1706             diff = "--- \n+++ \n@@ -1 +1,3 @@\n"
1707             diff += "+첫 번째 행{0} 한국어 시험{0}+마지막 행{0}".format(os.linesep)
1708             ret = {x.split("_|-")[1]: y for x, y in result.items()}
1709             self.assertEqual(
1710                 ret["some-utf8-file-create"]["comment"],
1711                 "File {} updated".format(test_file_encoded),
1712             )
1713             self.assertEqual(
1714                 ret["some-utf8-file-create"]["changes"], {"diff": "New file"}
1715             )
1716             self.assertEqual(
1717                 ret["some-utf8-file-create2"]["comment"],
1718                 "File {} updated".format(test_file_encoded),
1719             )
1720             self.assertEqual(ret["some-utf8-file-create2"]["changes"], {"diff": diff})
1721             if salt.utils.platform.is_windows():
1722                 import subprocess
1723                 import win32api
1724                 proc = subprocess.run(
1725                     ["type", win32api.GetShortPathName(test_file)],
1726                     stdout=subprocess.PIPE,
1727                     stderr=subprocess.PIPE,
1728                     check=True,
1729                     shell=True,  # nosec
1730 <a name="4"></a>                )
1731                 self.assertEqual(
1732                     proc.stdout.decode("utf-8"),
1733                     os.linesep<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join((korean_2, korean_1, korean_3)) + os.linesep,
1734                 )
1735             else:
1736                 self.assertEqual(
1737                     ret["some-utf8-file-content-test"]["comment"],
1738                     'Command "cat "{}"" run'.format(test_file_encoded),
1739                 )
1740                 self.assertEqual(</b></font>
1741                     ret["some-utf8-file-content-test"]["changes"]["stdout"],
1742                     "\n".join((korean_2, korean_1, korean_3)),
1743                 )
1744         finally:
1745             try:
1746                 os.remove(template_path)
1747             except OSError:
1748                 pass
1749     @pytest.mark.skip_if_not_root
1750     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1751     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1752     @with_system_user_and_group(
1753         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1754     )
1755     @with_tempdir()
1756     @skipIf(salt.utils.platform.is_freebsd(), "Test is failing on FreeBSD")
1757     def test_issue_12209_follow_symlinks(self, tempdir, user, group):
1758         onedir = os.path.join(tempdir, "one")
1759         twodir = os.path.join(tempdir, "two")
1760         os.mkdir(onedir)
1761         os.symlink(onedir, twodir)
1762         ret = self.run_state(
1763             "file.directory",
1764             name=tempdir,
1765             follow_symlinks=True,
1766             user=user,
1767 <a name="2"></a>            group=group,
1768             recurse=["user", "group"],
1769         )
1770         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertSaltTrueReturn(ret)
1771         onestats = os.stat(onedir)
1772         twostats = os.lstat(twodir)
1773         self.assertEqual(pwd.getpwuid(onestats.</b></font>st_uid).pw_name, user)
1774         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, "root")
1775         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
1776         if salt.utils.path.which("id"):
1777             root_group = self.run_function("user.primary_group", ["root"])
1778             self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, root_group)
1779     @pytest.mark.skip_if_not_root
1780     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1781     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1782     @with_system_user_and_group(
1783         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1784     )
1785     @with_tempdir()
1786     def test_issue_12209_no_follow_symlinks(self, tempdir, user, group):
1787         onedir = os.path.join(tempdir, "one")
1788         twodir = os.path.join(tempdir, "two")
1789         os.mkdir(onedir)
1790         os.symlink(onedir, twodir)
1791         ret = self.run_state(
1792             "file.directory",
1793             name=tempdir,
1794             follow_symlinks=False,
1795             user=user,
1796             group=group,
1797             recurse=["user", "group"],
1798         )
1799         self.assertSaltTrueReturn(ret)
1800         onestats = os.stat(onedir)
1801         twostats = os.lstat(twodir)
1802         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
1803         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, user)
1804         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
1805         self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, group)
1806     @with_tempfile(create=False)
1807     @with_tempfile()
1808     def test_template_local_file(self, source, dest):
1809         with salt.utils.files.fopen(source, "w") as fp_:
1810             fp_.write("{{ foo }}\n")
1811         for prefix in ("file://", ""):
1812             ret = self.run_state(
1813                 "file.managed",
1814                 name=dest,
1815                 source=prefix + source,
1816                 template="jinja",
1817                 context={"foo": "Hello world!"},
1818             )
1819             self.assertSaltTrueReturn(ret)
1820     @with_tempfile()
1821     def test_template_local_file_noclobber(self, source):
1822         with salt.utils.files.fopen(source, "w") as fp_:
1823             fp_.write("{{ foo }}\n")
1824         ret = self.run_state(
1825             "file.managed",
1826             name=source,
1827             source=source,
1828             template="jinja",
1829             context={"foo": "Hello world!"},
1830         )
1831         self.assertSaltFalseReturn(ret)
1832         self.assertIn(
1833             "Source file cannot be the same as destination",
1834             ret[next(iter(ret))]["comment"],
1835         )
1836     @with_tempfile(create=False)
1837     @with_tempfile(create=False)
1838     def test_issue_25250_force_copy_deletes(self, source, dest):
1839         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
1840         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "file/base/cheese"), dest)
1841         self.run_state("file.copy", name=dest, source=source, force=True)
1842         self.assertTrue(os.path.exists(dest))
1843         self.assertTrue(filecmp.cmp(source, dest))
1844         os.remove(source)
1845         os.remove(dest)
1846     @pytest.mark.destructive_test
1847     @pytest.mark.skip_if_not_root
1848     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
1849     @with_tempfile()
1850     def test_file_copy_make_dirs(self, source):
1851         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
1852         dest = self.tmp_dir / "dir1" / "dir2" / "copied_file.txt"
1853         self.addCleanup(salt.utils.files.rm_rf, str(dest.parent.parent))
1854         user = "salt"
1855         mode = "0644"
1856         ret = self.run_function("user.add", [user])
1857         self.assertTrue(ret, "Failed to add user. Are you running as sudo?")
1858         ret = self.run_state(
1859             "file.copy",
1860             name=str(dest),
1861             source=source,
1862             user=user,
1863             makedirs=True,
1864             mode=mode,
1865         )
1866         self.assertSaltTrueReturn(ret)
1867         file_checks = [str(dest), str(dest.parent), str(dest.parent.parent)]
1868         for check in file_checks:
1869             user_check = self.run_function("file.get_user", [check])
1870             mode_check = self.run_function("file.get_mode", [check])
1871             self.assertEqual(user_check, user)
1872             self.assertEqual(salt.utils.files.normalize_mode(mode_check), mode)
1873     @pytest.mark.skip_if_not_root
1874     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1875     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1876     @with_system_user_and_group(
1877         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1878     )
1879     def test_owner_after_setuid(self, user, group):
1880 <a name="5"></a>
1881         desired_file = self.tmp_dir / "file_with_setuid"
1882         self.addCleanup(salt.utils.files<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.safe_rm, str(desired_file))
1883         desired = {
1884             "file": str(desired_file),
1885             "user": user,
1886             "group": group,
1887             "mode": "4750",
1888         }
1889         ret = self.run_state(
1890             "file.managed",
1891             name=desired["file"],
1892             user=desired[</b></font>"user"],
1893             group=desired["group"],
1894             mode=desired["mode"],
1895         )
1896         file_stat = desired_file.stat()
1897         result = {
1898             "user": pwd.getpwuid(file_stat.st_uid).pw_name,
1899             "group": grp.getgrgid(file_stat.st_gid).gr_name,
1900             "mode": oct(stat.S_IMODE(file_stat.st_mode)),
1901         }
1902         self.assertSaltTrueReturn(ret)
1903         self.assertEqual(desired["user"], result["user"])
1904         self.assertEqual(desired["group"], result["group"])
1905         self.assertEqual(desired["mode"], result["mode"].lstrip("0Oo"))
1906     def test_binary_contents(self):
1907         name = self.tmp_dir / "1px.gif"
1908         self.addCleanup(salt.utils.files.safe_rm, str(name))
1909         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1910         self.assertSaltTrueReturn(ret)
1911     def test_binary_contents_twice(self):
1912         name = self.tmp_dir / "1px.gif"
1913         self.addCleanup(salt.utils.files.safe_rm, str(name))
1914         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1915         self.assertSaltTrueReturn(ret)
1916         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1917         self.assertSaltTrueReturn(ret)
1918     @pytest.mark.skip_if_not_root
1919     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1920     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1921     @with_system_user_and_group(
1922         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1923     )
1924     @with_tempdir()
1925     def test_issue_48336_file_managed_mode_setuid(self, tempdir, user, group):
1926         tempfile = os.path.join(tempdir, "temp_file_issue_48336")
1927         ret = self.run_state(
1928             "file.managed",
1929             name=tempfile,
1930             user=user,
1931             group=group,
1932             mode="4750",
1933         )
1934         self.assertSaltTrueReturn(ret)
1935         temp_file_stats = os.stat(tempfile)
1936         temp_file_mode = str(oct(stat.S_IMODE(temp_file_stats.st_mode)))
1937         temp_file_mode = salt.utils.files.normalize_mode(temp_file_mode)
1938         self.assertEqual(temp_file_mode, "4750")
1939         self.assertEqual(pwd.getpwuid(temp_file_stats.st_uid).pw_name, user)
1940         self.assertEqual(grp.getgrgid(temp_file_stats.st_gid).gr_name, group)
1941     @with_tempdir()
1942     def test_issue_48557(self, tempdir):
1943         tempfile = os.path.join(tempdir, "temp_file_issue_48557")
1944         with salt.utils.files.fopen(tempfile, "wb") as fp:
1945             fp.write(os.linesep.join(["test1", "test2", "test3", ""]).encode("utf-8"))
1946         ret = self.run_state(
1947             "file.line", name=tempfile, after="test2", mode="insert", content="test4"
1948         )
1949         self.assertSaltTrueReturn(ret)
1950         with salt.utils.files.fopen(tempfile, "rb") as fp:
1951             content = fp.read()
1952         self.assertEqual(
1953             content,
1954             os.linesep.join(["test1", "test2", "test4", "test3", ""]).encode("utf-8"),
1955         )
1956     def test_managed_file_issue_51208(self):
1957         name = self.tmp_dir / "issue_51208.txt"
1958         self.addCleanup(salt.utils.files.safe_rm, str(name))
1959         ret = self.run_state(
1960             "file.managed", name=str(name), source="salt://issue-51208/vimrc.stub"
1961         )
1962         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "issue-51208" / "vimrc.stub"
1963         master_data = src.read_text()
1964         minion_data = name.read_text()
1965         self.assertEqual(master_data, minion_data)
1966         self.assertSaltTrueReturn(ret)
1967     @with_tempfile()
1968     def test_keyvalue(self, name):
1969         content = dedent(
1970         )
1971         with salt.utils.files.fopen(name, "w+") as fp_:
1972             fp_.write(content)
1973         ret = self.run_state(
1974             "file.keyvalue",
1975             name=name,
1976             key="permitrootlogin",
1977             value="no",
1978             separator=" ",
1979             uncomment=" #",
1980             key_ignore_case=True,
1981         )
1982         with salt.utils.files.fopen(name, "r") as fp_:
1983             file_contents = fp_.read()
1984             self.assertNotIn("#PermitRootLogin", file_contents)
1985             self.assertNotIn("prohibit-password", file_contents)
1986             self.assertIn("PermitRootLogin no", file_contents)
1987         self.assertSaltTrueReturn(ret)
1988     @with_tempdir()
1989     @pytest.mark.slow_test
1990     def test_issue_1896_file_append_source(self, base_dir):
1991         testfile = os.path.join(base_dir, "test.append")
1992         ret = self.run_state("file.touch", name=testfile)
1993         self.assertSaltTrueReturn(ret)
1994         ret = self.run_state(
1995             "file.append", name=testfile, source="salt://testappend/firstif"
1996         )
1997         self.assertSaltTrueReturn(ret)
1998         ret = self.run_state(
1999             "file.append", name=testfile, source="salt://testappend/secondif"
2000         )
2001         self.assertSaltTrueReturn(ret)
2002         with salt.utils.files.fopen(testfile, "r") as fp_:
2003             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read())
2004         contents = textwrap.dedent(
2005         )
2006         if salt.utils.platform.is_windows():
2007             new_contents = contents.splitlines()
2008             contents = os.linesep.join(new_contents)
2009             contents += os.linesep
2010         self.assertMultiLineEqual(contents, testfile_contents)
2011         ret = self.run_state(
2012             "file.append", name=testfile, source="salt://testappend/secondif"
2013         )
2014         self.assertSaltTrueReturn(ret)
2015         ret = self.run_state(
2016             "file.append", name=testfile, source="salt://testappend/firstif"
2017         )
2018         self.assertSaltTrueReturn(ret)
2019         with salt.utils.files.fopen(testfile, "r") as fp_:
2020             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read())
2021         self.assertMultiLineEqual(contents, testfile_contents)
2022 @pytest.mark.windows_whitelisted
2023 class BlockreplaceTest(ModuleCase, SaltReturnAssertsMixin):
2024     marker_start = "# start"
2025     marker_end = "# end"
2026     content = dedent(
2027     )
2028     without_block = dedent(
2029     )
2030     with_non_matching_block = dedent(
2031     )
2032     with_non_matching_block_and_marker_end_not_after_newline = dedent(
2033     )
2034     with_matching_block = dedent(
2035     )
2036     with_matching_block_and_extra_newline = dedent(
2037     )
2038     with_matching_block_and_marker_end_not_after_newline = dedent(
2039     )
2040     content_explicit_posix_newlines = "Line 1 of block\nLine 2 of block\n"
2041     content_explicit_windows_newlines = "Line 1 of block\r\nLine 2 of block\r\n"
2042     without_block_explicit_posix_newlines = "Hello world!\n\n# comment here\n"
2043     without_block_explicit_windows_newlines = "Hello world!\r\n\r\n# comment here\r\n"
2044     with_block_prepended_explicit_posix_newlines = (
2045         "# start\n"
2046         "Line 1 of block\n"
2047         "Line 2 of block\n"
2048         "# end\n"
2049         "Hello world!\n\n"
2050         "# comment here\n"
2051     )
2052     with_block_prepended_explicit_windows_newlines = (
2053         "# start\r\n"
2054         "Line 1 of block\r\n"
2055         "Line 2 of block\r\n"
2056         "# end\r\n"
2057         "Hello world!\r\n\r\n"
2058         "# comment here\r\n"
2059     )
2060     with_block_appended_explicit_posix_newlines = (
2061         "Hello world!\n\n"
2062         "# comment here\n"
2063         "# start\n"
2064         "Line 1 of block\n"
2065         "Line 2 of block\n"
2066         "# end\n"
2067     )
2068     with_block_appended_explicit_windows_newlines = (
2069         "Hello world!\r\n\r\n"
2070         "# comment here\r\n"
2071         "# start\r\n"
2072         "Line 1 of block\r\n"
2073         "Line 2 of block\r\n"
2074         "# end\r\n"
2075     )
2076     @staticmethod
2077     def _write(dest, content):
2078         with salt.utils.files.fopen(dest, "wb") as fp_:
2079             fp_.write(salt.utils.stringutils.to_bytes(content))
2080     @staticmethod
2081     def _read(src):
2082         with salt.utils.files.fopen(src, "rb") as fp_:
2083             return salt.utils.stringutils.to_unicode(fp_.read())
2084     @with_tempfile()
2085     def test_prepend(self, name):
2086         expected = (
2087             self.marker_start
2088             + os.linesep
2089             + self.content
2090             + self.marker_end
2091             + os.linesep
2092             + self.without_block
2093         )
2094         self._write(name, self.without_block)
2095         ret = self.run_state(
2096             "file.blockreplace",
2097             name=name,
2098             content=self.content,
2099             marker_start=self.marker_start,
2100             marker_end=self.marker_end,
2101             prepend_if_not_found=True,
2102         )
2103         self.assertSaltTrueReturn(ret)
2104         self.assertTrue(ret[next(iter(ret))]["changes"])
2105         self.assertEqual(self._read(name), expected)
2106         ret = self.run_state(
2107             "file.blockreplace",
2108             name=name,
2109             content=self.content,
2110             marker_start=self.marker_start,
2111             marker_end=self.marker_end,
2112             prepend_if_not_found=True,
2113         )
2114         self.assertSaltTrueReturn(ret)
2115         self.assertFalse(ret[next(iter(ret))]["changes"])
2116         self.assertEqual(self._read(name), expected)
2117         self._write(name, self.without_block)
2118         ret = self.run_state(
2119             "file.blockreplace",
2120             name=name,
2121             content=self.content.rstrip("\r\n"),
2122             marker_start=self.marker_start,
2123             marker_end=self.marker_end,
2124             prepend_if_not_found=True,
2125         )
2126         self.assertSaltTrueReturn(ret)
2127         self.assertTrue(ret[next(iter(ret))]["changes"])
2128         self.assertEqual(self._read(name), expected)
2129         ret = self.run_state(
2130             "file.blockreplace",
2131             name=name,
2132             content=self.content.rstrip("\r\n"),
2133             marker_start=self.marker_start,
2134             marker_end=self.marker_end,
2135             prepend_if_not_found=True,
2136         )
2137         self.assertSaltTrueReturn(ret)
2138         self.assertFalse(ret[next(iter(ret))]["changes"])
2139         self.assertEqual(self._read(name), expected)
2140     @with_tempfile()
2141     def test_prepend_append_newline(self, name):
2142         expected = (
2143             self.marker_start
2144             + os.linesep
2145             + self.content
2146             + os.linesep
2147             + self.marker_end
2148             + os.linesep
2149             + self.without_block
2150         )
2151         self._write(name, self.without_block)
2152         ret = self.run_state(
2153             "file.blockreplace",
2154             name=name,
2155             content=self.content,
2156             marker_start=self.marker_start,
2157             marker_end=self.marker_end,
2158             prepend_if_not_found=True,
2159             append_newline=True,
2160         )
2161         self.assertSaltTrueReturn(ret)
2162         self.assertTrue(ret[next(iter(ret))]["changes"])
2163         self.assertEqual(self._read(name), expected)
2164         ret = self.run_state(
2165             "file.blockreplace",
2166             name=name,
2167             content=self.content,
2168             marker_start=self.marker_start,
2169             marker_end=self.marker_end,
2170             prepend_if_not_found=True,
2171             append_newline=True,
2172         )
2173         self.assertSaltTrueReturn(ret)
2174         self.assertFalse(ret[next(iter(ret))]["changes"])
2175         self.assertEqual(self._read(name), expected)
2176         expected = (
2177             self.marker_start
2178             + os.linesep
2179             + self.content
2180             + self.marker_end
2181             + os.linesep
2182             + self.without_block
2183         )
2184         self._write(name, self.without_block)
2185         ret = self.run_state(
2186             "file.blockreplace",
2187             name=name,
2188             content=self.content.rstrip("\r\n"),
2189             marker_start=self.marker_start,
2190             marker_end=self.marker_end,
2191             prepend_if_not_found=True,
2192             append_newline=True,
2193         )
2194         self.assertSaltTrueReturn(ret)
2195         self.assertTrue(ret[next(iter(ret))]["changes"])
2196         self.assertEqual(self._read(name), expected)
2197         ret = self.run_state(
2198             "file.blockreplace",
2199             name=name,
2200             content=self.content.rstrip("\r\n"),
2201             marker_start=self.marker_start,
2202             marker_end=self.marker_end,
2203             prepend_if_not_found=True,
2204             append_newline=True,
2205         )
2206         self.assertSaltTrueReturn(ret)
2207         self.assertFalse(ret[next(iter(ret))]["changes"])
2208         self.assertEqual(self._read(name), expected)
2209     @with_tempfile()
2210     def test_prepend_no_append_newline(self, name):
2211         expected = (
2212             self.marker_start
2213             + os.linesep
2214             + self.content
2215             + self.marker_end
2216             + os.linesep
2217             + self.without_block
2218         )
2219         self._write(name, self.without_block)
2220         ret = self.run_state(
2221             "file.blockreplace",
2222             name=name,
2223             content=self.content,
2224             marker_start=self.marker_start,
2225             marker_end=self.marker_end,
2226             prepend_if_not_found=True,
2227             append_newline=False,
2228         )
2229         self.assertSaltTrueReturn(ret)
2230         self.assertTrue(ret[next(iter(ret))]["changes"])
2231         self.assertEqual(self._read(name), expected)
2232         ret = self.run_state(
2233             "file.blockreplace",
2234             name=name,
2235             content=self.content,
2236             marker_start=self.marker_start,
2237             marker_end=self.marker_end,
2238             prepend_if_not_found=True,
2239             append_newline=False,
2240         )
2241         self.assertSaltTrueReturn(ret)
2242         self.assertFalse(ret[next(iter(ret))]["changes"])
2243         self.assertEqual(self._read(name), expected)
2244         expected = (
2245             self.marker_start
2246             + os.linesep
2247             + self.content.rstrip("\r\n")
2248             + self.marker_end
2249             + os.linesep
2250             + self.without_block
2251         )
2252         self._write(name, self.without_block)
2253         ret = self.run_state(
2254             "file.blockreplace",
2255             name=name,
2256             content=self.content.rstrip("\r\n"),
2257             marker_start=self.marker_start,
2258             marker_end=self.marker_end,
2259             prepend_if_not_found=True,
2260             append_newline=False,
2261         )
2262         self.assertSaltTrueReturn(ret)
2263         self.assertTrue(ret[next(iter(ret))]["changes"])
2264         self.assertEqual(self._read(name), expected)
2265         ret = self.run_state(
2266             "file.blockreplace",
2267             name=name,
2268             content=self.content.rstrip("\r\n"),
2269             marker_start=self.marker_start,
2270             marker_end=self.marker_end,
2271             prepend_if_not_found=True,
2272             append_newline=False,
2273         )
2274         self.assertSaltTrueReturn(ret)
2275         self.assertFalse(ret[next(iter(ret))]["changes"])
2276         self.assertEqual(self._read(name), expected)
2277     @with_tempfile()
2278     def test_append(self, name):
2279         expected = (
2280             self.without_block
2281             + self.marker_start
2282             + os.linesep
2283             + self.content
2284             + self.marker_end
2285             + os.linesep
2286         )
2287         self._write(name, self.without_block)
2288         ret = self.run_state(
2289             "file.blockreplace",
2290             name=name,
2291             content=self.content,
2292             marker_start=self.marker_start,
2293             marker_end=self.marker_end,
2294             append_if_not_found=True,
2295         )
2296         self.assertSaltTrueReturn(ret)
2297         self.assertTrue(ret[next(iter(ret))]["changes"])
2298         self.assertEqual(self._read(name), expected)
2299         ret = self.run_state(
2300             "file.blockreplace",
2301             name=name,
2302             content=self.content,
2303             marker_start=self.marker_start,
2304             marker_end=self.marker_end,
2305             append_if_not_found=True,
2306         )
2307         self.assertSaltTrueReturn(ret)
2308         self.assertFalse(ret[next(iter(ret))]["changes"])
2309         self.assertEqual(self._read(name), expected)
2310         self._write(name, self.without_block)
2311         ret = self.run_state(
2312             "file.blockreplace",
2313             name=name,
2314             content=self.content.rstrip("\r\n"),
2315             marker_start=self.marker_start,
2316             marker_end=self.marker_end,
2317             append_if_not_found=True,
2318         )
2319         self.assertSaltTrueReturn(ret)
2320         self.assertTrue(ret[next(iter(ret))]["changes"])
2321         self.assertEqual(self._read(name), expected)
2322         ret = self.run_state(
2323             "file.blockreplace",
2324             name=name,
2325             content=self.content.rstrip("\r\n"),
2326             marker_start=self.marker_start,
2327             marker_end=self.marker_end,
2328             append_if_not_found=True,
2329         )
2330         self.assertSaltTrueReturn(ret)
2331         self.assertFalse(ret[next(iter(ret))]["changes"])
2332         self.assertEqual(self._read(name), expected)
2333     @with_tempfile()
2334     def test_append_append_newline(self, name):
2335         expected = (
2336             self.without_block
2337             + self.marker_start
2338             + os.linesep
2339             + self.content
2340             + os.linesep
2341             + self.marker_end
2342             + os.linesep
2343         )
2344         self._write(name, self.without_block)
2345         ret = self.run_state(
2346             "file.blockreplace",
2347             name=name,
2348             content=self.content,
2349             marker_start=self.marker_start,
2350             marker_end=self.marker_end,
2351             append_if_not_found=True,
2352             append_newline=True,
2353         )
2354         self.assertSaltTrueReturn(ret)
2355         self.assertTrue(ret[next(iter(ret))]["changes"])
2356         self.assertEqual(self._read(name), expected)
2357         ret = self.run_state(
2358             "file.blockreplace",
2359             name=name,
2360             content=self.content,
2361             marker_start=self.marker_start,
2362             marker_end=self.marker_end,
2363             append_if_not_found=True,
2364             append_newline=True,
2365         )
2366         self.assertSaltTrueReturn(ret)
2367         self.assertFalse(ret[next(iter(ret))]["changes"])
2368         self.assertEqual(self._read(name), expected)
2369         expected = (
2370             self.without_block
2371             + self.marker_start
2372             + os.linesep
2373             + self.content
2374             + self.marker_end
2375             + os.linesep
2376         )
2377         self._write(name, self.without_block)
2378         ret = self.run_state(
2379             "file.blockreplace",
2380             name=name,
2381             content=self.content.rstrip("\r\n"),
2382             marker_start=self.marker_start,
2383             marker_end=self.marker_end,
2384             append_if_not_found=True,
2385             append_newline=True,
2386         )
2387         self.assertSaltTrueReturn(ret)
2388         self.assertTrue(ret[next(iter(ret))]["changes"])
2389         self.assertEqual(self._read(name), expected)
2390         ret = self.run_state(
2391             "file.blockreplace",
2392             name=name,
2393             content=self.content.rstrip("\r\n"),
2394             marker_start=self.marker_start,
2395             marker_end=self.marker_end,
2396             append_if_not_found=True,
2397             append_newline=True,
2398         )
2399         self.assertSaltTrueReturn(ret)
2400         self.assertFalse(ret[next(iter(ret))]["changes"])
2401         self.assertEqual(self._read(name), expected)
2402     @with_tempfile()
2403     def test_append_no_append_newline(self, name):
2404         expected = (
2405             self.without_block
2406             + self.marker_start
2407             + os.linesep
2408             + self.content
2409             + self.marker_end
2410             + os.linesep
2411         )
2412         self._write(name, self.without_block)
2413         ret = self.run_state(
2414             "file.blockreplace",
2415             name=name,
2416             content=self.content,
2417             marker_start=self.marker_start,
2418             marker_end=self.marker_end,
2419             append_if_not_found=True,
2420             append_newline=False,
2421         )
2422         self.assertSaltTrueReturn(ret)
2423         self.assertTrue(ret[next(iter(ret))]["changes"])
2424         self.assertEqual(self._read(name), expected)
2425         ret = self.run_state(
2426             "file.blockreplace",
2427             name=name,
2428             content=self.content,
2429             marker_start=self.marker_start,
2430             marker_end=self.marker_end,
2431             append_if_not_found=True,
2432             append_newline=False,
2433         )
2434         self.assertSaltTrueReturn(ret)
2435         self.assertFalse(ret[next(iter(ret))]["changes"])
2436         self.assertEqual(self._read(name), expected)
2437         expected = (
2438             self.without_block
2439             + self.marker_start
2440             + os.linesep
2441             + self.content.rstrip("\r\n")
2442             + self.marker_end
2443             + os.linesep
2444         )
2445         self._write(name, self.without_block)
2446         ret = self.run_state(
2447             "file.blockreplace",
2448             name=name,
2449             content=self.content.rstrip("\r\n"),
2450             marker_start=self.marker_start,
2451             marker_end=self.marker_end,
2452             append_if_not_found=True,
2453             append_newline=False,
2454         )
2455         self.assertSaltTrueReturn(ret)
2456         self.assertTrue(ret[next(iter(ret))]["changes"])
2457         self.assertEqual(self._read(name), expected)
2458         ret = self.run_state(
2459             "file.blockreplace",
2460             name=name,
2461             content=self.content.rstrip("\r\n"),
2462             marker_start=self.marker_start,
2463             marker_end=self.marker_end,
2464             append_if_not_found=True,
2465             append_newline=False,
2466         )
2467         self.assertSaltTrueReturn(ret)
2468         self.assertFalse(ret[next(iter(ret))]["changes"])
2469         self.assertEqual(self._read(name), expected)
2470     @with_tempfile()
2471     def test_prepend_auto_line_separator(self, name):
2472         self._write(name, self.without_block_explicit_windows_newlines)
2473         ret = self.run_state(
2474             "file.blockreplace",
2475             name=name,
2476             content=self.content_explicit_posix_newlines,
2477             marker_start=self.marker_start,
2478             marker_end=self.marker_end,
2479             prepend_if_not_found=True,
2480         )
2481         self.assertSaltTrueReturn(ret)
2482         self.assertTrue(ret[next(iter(ret))]["changes"])
2483         self.assertEqual(
2484             self._read(name), self.with_block_prepended_explicit_windows_newlines
2485         )
2486         ret = self.run_state(
2487             "file.blockreplace",
2488             name=name,
2489             content=self.content_explicit_posix_newlines,
2490             marker_start=self.marker_start,
2491             marker_end=self.marker_end,
2492             prepend_if_not_found=True,
2493         )
2494         self.assertSaltTrueReturn(ret)
2495         self.assertFalse(ret[next(iter(ret))]["changes"])
2496         self.assertEqual(
2497             self._read(name), self.with_block_prepended_explicit_windows_newlines
2498         )
2499         self._write(name, self.without_block_explicit_posix_newlines)
2500         ret = self.run_state(
2501             "file.blockreplace",
2502             name=name,
2503             content=self.content_explicit_windows_newlines,
2504             marker_start=self.marker_start,
2505             marker_end=self.marker_end,
2506             prepend_if_not_found=True,
2507         )
2508         self.assertSaltTrueReturn(ret)
2509         self.assertTrue(ret[next(iter(ret))]["changes"])
2510         self.assertEqual(
2511             self._read(name), self.with_block_prepended_explicit_posix_newlines
2512         )
2513         ret = self.run_state(
2514             "file.blockreplace",
2515             name=name,
2516             content=self.content_explicit_windows_newlines,
2517             marker_start=self.marker_start,
2518             marker_end=self.marker_end,
2519             prepend_if_not_found=True,
2520         )
2521         self.assertSaltTrueReturn(ret)
2522         self.assertFalse(ret[next(iter(ret))]["changes"])
2523         self.assertEqual(
2524             self._read(name), self.with_block_prepended_explicit_posix_newlines
2525         )
2526     @with_tempfile()
2527     def test_append_auto_line_separator(self, name):
2528         self._write(name, self.without_block_explicit_windows_newlines)
2529         ret = self.run_state(
2530             "file.blockreplace",
2531             name=name,
2532             content=self.content_explicit_posix_newlines,
2533             marker_start=self.marker_start,
2534             marker_end=self.marker_end,
2535             append_if_not_found=True,
2536         )
2537         self.assertSaltTrueReturn(ret)
2538         self.assertTrue(ret[next(iter(ret))]["changes"])
2539         self.assertEqual(
2540             self._read(name), self.with_block_appended_explicit_windows_newlines
2541         )
2542         ret = self.run_state(
2543             "file.blockreplace",
2544             name=name,
2545             content=self.content_explicit_posix_newlines,
2546             marker_start=self.marker_start,
2547             marker_end=self.marker_end,
2548             append_if_not_found=True,
2549         )
2550         self.assertSaltTrueReturn(ret)
2551         self.assertFalse(ret[next(iter(ret))]["changes"])
2552         self.assertEqual(
2553             self._read(name), self.with_block_appended_explicit_windows_newlines
2554         )
2555         self._write(name, self.without_block_explicit_posix_newlines)
2556         ret = self.run_state(
2557             "file.blockreplace",
2558             name=name,
2559             content=self.content_explicit_windows_newlines,
2560             marker_start=self.marker_start,
2561             marker_end=self.marker_end,
2562             append_if_not_found=True,
2563         )
2564         self.assertSaltTrueReturn(ret)
2565         self.assertTrue(ret[next(iter(ret))]["changes"])
2566         self.assertEqual(
2567             self._read(name), self.with_block_appended_explicit_posix_newlines
2568         )
2569         ret = self.run_state(
2570             "file.blockreplace",
2571             name=name,
2572             content=self.content_explicit_windows_newlines,
2573             marker_start=self.marker_start,
2574             marker_end=self.marker_end,
2575             append_if_not_found=True,
2576         )
2577         self.assertSaltTrueReturn(ret)
2578         self.assertFalse(ret[next(iter(ret))]["changes"])
2579         self.assertEqual(
2580             self._read(name), self.with_block_appended_explicit_posix_newlines
2581         )
2582     @with_tempfile()
2583     def test_non_matching_block(self, name):
2584         self._write(name, self.with_non_matching_block)
2585         ret = self.run_state(
2586             "file.blockreplace",
2587             name=name,
2588             content=self.content,
2589             marker_start=self.marker_start,
2590             marker_end=self.marker_end,
2591         )
2592         self.assertSaltTrueReturn(ret)
2593         self.assertTrue(ret[next(iter(ret))]["changes"])
2594         self.assertEqual(self._read(name), self.with_matching_block)
2595         ret = self.run_state(
2596             "file.blockreplace",
2597             name=name,
2598             content=self.content,
2599             marker_start=self.marker_start,
2600             marker_end=self.marker_end,
2601         )
2602         self.assertSaltTrueReturn(ret)
2603         self.assertFalse(ret[next(iter(ret))]["changes"])
2604         self.assertEqual(self._read(name), self.with_matching_block)
2605         self._write(name, self.with_non_matching_block)
2606         ret = self.run_state(
2607             "file.blockreplace",
2608             name=name,
2609             content=self.content.rstrip("\r\n"),
2610             marker_start=self.marker_start,
2611             marker_end=self.marker_end,
2612         )
2613         self.assertSaltTrueReturn(ret)
2614         self.assertTrue(ret[next(iter(ret))]["changes"])
2615         self.assertEqual(self._read(name), self.with_matching_block)
2616         ret = self.run_state(
2617             "file.blockreplace",
2618             name=name,
2619             content=self.content.rstrip("\r\n"),
2620             marker_start=self.marker_start,
2621             marker_end=self.marker_end,
2622         )
2623         self.assertSaltTrueReturn(ret)
2624         self.assertFalse(ret[next(iter(ret))]["changes"])
2625         self.assertEqual(self._read(name), self.with_matching_block)
2626     @with_tempfile()
2627     def test_non_matching_block_append_newline(self, name):
2628         self._write(name, self.with_non_matching_block)
2629         ret = self.run_state(
2630             "file.blockreplace",
2631             name=name,
2632             content=self.content,
2633             marker_start=self.marker_start,
2634             marker_end=self.marker_end,
2635             append_newline=True,
2636         )
2637         self.assertSaltTrueReturn(ret)
2638         self.assertTrue(ret[next(iter(ret))]["changes"])
2639         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2640         ret = self.run_state(
2641             "file.blockreplace",
2642             name=name,
2643             content=self.content,
2644             marker_start=self.marker_start,
2645             marker_end=self.marker_end,
2646             append_newline=True,
2647         )
2648         self.assertSaltTrueReturn(ret)
2649         self.assertFalse(ret[next(iter(ret))]["changes"])
2650         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2651         self._write(name, self.with_non_matching_block)
2652         ret = self.run_state(
2653             "file.blockreplace",
2654             name=name,
2655             content=self.content.rstrip("\r\n"),
2656             marker_start=self.marker_start,
2657             marker_end=self.marker_end,
2658             append_newline=True,
2659         )
2660         self.assertSaltTrueReturn(ret)
2661         self.assertTrue(ret[next(iter(ret))]["changes"])
2662         self.assertEqual(self._read(name), self.with_matching_block)
2663         ret = self.run_state(
2664             "file.blockreplace",
2665             name=name,
2666             content=self.content.rstrip("\r\n"),
2667             marker_start=self.marker_start,
2668             marker_end=self.marker_end,
2669             append_newline=True,
2670         )
2671         self.assertSaltTrueReturn(ret)
2672         self.assertFalse(ret[next(iter(ret))]["changes"])
2673         self.assertEqual(self._read(name), self.with_matching_block)
2674     @with_tempfile()
2675     def test_non_matching_block_no_append_newline(self, name):
2676         self._write(name, self.with_non_matching_block)
2677         ret = self.run_state(
2678             "file.blockreplace",
2679             name=name,
2680             content=self.content,
2681             marker_start=self.marker_start,
2682             marker_end=self.marker_end,
2683             append_newline=False,
2684         )
2685         self.assertSaltTrueReturn(ret)
2686         self.assertTrue(ret[next(iter(ret))]["changes"])
2687         self.assertEqual(self._read(name), self.with_matching_block)
2688         ret = self.run_state(
2689             "file.blockreplace",
2690             name=name,
2691             content=self.content,
2692             marker_start=self.marker_start,
2693             marker_end=self.marker_end,
2694             append_newline=False,
2695         )
2696         self.assertSaltTrueReturn(ret)
2697         self.assertFalse(ret[next(iter(ret))]["changes"])
2698         self.assertEqual(self._read(name), self.with_matching_block)
2699         self._write(name, self.with_non_matching_block)
2700         ret = self.run_state(
2701             "file.blockreplace",
2702             name=name,
2703             content=self.content.rstrip("\r\n"),
2704             marker_start=self.marker_start,
2705             marker_end=self.marker_end,
2706             append_newline=False,
2707         )
2708         self.assertSaltTrueReturn(ret)
2709         self.assertTrue(ret[next(iter(ret))]["changes"])
2710         self.assertEqual(
2711             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2712         )
2713         ret = self.run_state(
2714             "file.blockreplace",
2715             name=name,
2716             content=self.content.rstrip("\r\n"),
2717             marker_start=self.marker_start,
2718             marker_end=self.marker_end,
2719             append_newline=False,
2720         )
2721         self.assertSaltTrueReturn(ret)
2722         self.assertFalse(ret[next(iter(ret))]["changes"])
2723         self.assertEqual(
2724             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2725         )
2726     @with_tempfile()
2727     def test_non_matching_block_and_marker_not_after_newline(self, name):
2728         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2729         ret = self.run_state(
2730             "file.blockreplace",
2731             name=name,
2732             content=self.content,
2733             marker_start=self.marker_start,
2734             marker_end=self.marker_end,
2735         )
2736         self.assertSaltTrueReturn(ret)
2737         self.assertTrue(ret[next(iter(ret))]["changes"])
2738         self.assertEqual(self._read(name), self.with_matching_block)
2739         ret = self.run_state(
2740             "file.blockreplace",
2741             name=name,
2742             content=self.content,
2743             marker_start=self.marker_start,
2744             marker_end=self.marker_end,
2745         )
2746         self.assertSaltTrueReturn(ret)
2747         self.assertFalse(ret[next(iter(ret))]["changes"])
2748         self.assertEqual(self._read(name), self.with_matching_block)
2749         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2750         ret = self.run_state(
2751             "file.blockreplace",
2752             name=name,
2753             content=self.content.rstrip("\r\n"),
2754             marker_start=self.marker_start,
2755             marker_end=self.marker_end,
2756         )
2757         self.assertSaltTrueReturn(ret)
2758         self.assertTrue(ret[next(iter(ret))]["changes"])
2759         self.assertEqual(self._read(name), self.with_matching_block)
2760         ret = self.run_state(
2761             "file.blockreplace",
2762             name=name,
2763             content=self.content.rstrip("\r\n"),
2764             marker_start=self.marker_start,
2765             marker_end=self.marker_end,
2766         )
2767         self.assertSaltTrueReturn(ret)
2768         self.assertFalse(ret[next(iter(ret))]["changes"])
2769         self.assertEqual(self._read(name), self.with_matching_block)
2770     @with_tempfile()
2771     def test_non_matching_block_and_marker_not_after_newline_append_newline(self, name):
2772         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2773         ret = self.run_state(
2774             "file.blockreplace",
2775             name=name,
2776             content=self.content,
2777             marker_start=self.marker_start,
2778             marker_end=self.marker_end,
2779             append_newline=True,
2780         )
2781         self.assertSaltTrueReturn(ret)
2782         self.assertTrue(ret[next(iter(ret))]["changes"])
2783         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2784         ret = self.run_state(
2785             "file.blockreplace",
2786             name=name,
2787             content=self.content,
2788             marker_start=self.marker_start,
2789             marker_end=self.marker_end,
2790             append_newline=True,
2791         )
2792         self.assertSaltTrueReturn(ret)
2793         self.assertFalse(ret[next(iter(ret))]["changes"])
2794         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2795         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2796         ret = self.run_state(
2797             "file.blockreplace",
2798             name=name,
2799             content=self.content.rstrip("\r\n"),
2800             marker_start=self.marker_start,
2801             marker_end=self.marker_end,
2802             append_newline=True,
2803         )
2804         self.assertSaltTrueReturn(ret)
2805         self.assertTrue(ret[next(iter(ret))]["changes"])
2806         self.assertEqual(self._read(name), self.with_matching_block)
2807         ret = self.run_state(
2808             "file.blockreplace",
2809             name=name,
2810             content=self.content.rstrip("\r\n"),
2811             marker_start=self.marker_start,
2812             marker_end=self.marker_end,
2813             append_newline=True,
2814         )
2815         self.assertSaltTrueReturn(ret)
2816         self.assertFalse(ret[next(iter(ret))]["changes"])
2817         self.assertEqual(self._read(name), self.with_matching_block)
2818     @with_tempfile()
2819     def test_non_matching_block_and_marker_not_after_newline_no_append_newline(
2820         self, name
2821     ):
2822         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2823         ret = self.run_state(
2824             "file.blockreplace",
2825             name=name,
2826             content=self.content,
2827             marker_start=self.marker_start,
2828             marker_end=self.marker_end,
2829             append_newline=False,
2830         )
2831         self.assertSaltTrueReturn(ret)
2832         self.assertTrue(ret[next(iter(ret))]["changes"])
2833         self.assertEqual(self._read(name), self.with_matching_block)
2834         ret = self.run_state(
2835             "file.blockreplace",
2836             name=name,
2837             content=self.content,
2838             marker_start=self.marker_start,
2839             marker_end=self.marker_end,
2840             append_newline=False,
2841         )
2842         self.assertSaltTrueReturn(ret)
2843         self.assertFalse(ret[next(iter(ret))]["changes"])
2844         self.assertEqual(self._read(name), self.with_matching_block)
2845         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2846         ret = self.run_state(
2847             "file.blockreplace",
2848             name=name,
2849             content=self.content.rstrip("\r\n"),
2850             marker_start=self.marker_start,
2851             marker_end=self.marker_end,
2852             append_newline=False,
2853         )
2854         self.assertSaltTrueReturn(ret)
2855         self.assertTrue(ret[next(iter(ret))]["changes"])
2856         self.assertEqual(
2857             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2858         )
2859         ret = self.run_state(
2860             "file.blockreplace",
2861             name=name,
2862             content=self.content.rstrip("\r\n"),
2863             marker_start=self.marker_start,
2864             marker_end=self.marker_end,
2865             append_newline=False,
2866         )
2867         self.assertSaltTrueReturn(ret)
2868         self.assertFalse(ret[next(iter(ret))]["changes"])
2869         self.assertEqual(
2870             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2871         )
2872     @with_tempfile()
2873     def test_matching_block(self, name):
2874         self._write(name, self.with_matching_block)
2875         ret = self.run_state(
2876             "file.blockreplace",
2877             name=name,
2878             content=self.content,
2879             marker_start=self.marker_start,
2880             marker_end=self.marker_end,
2881         )
2882         self.assertSaltTrueReturn(ret)
2883         self.assertFalse(ret[next(iter(ret))]["changes"])
2884         self.assertEqual(self._read(name), self.with_matching_block)
2885         ret = self.run_state(
2886             "file.blockreplace",
2887             name=name,
2888             content=self.content,
2889             marker_start=self.marker_start,
2890             marker_end=self.marker_end,
2891         )
2892         self.assertSaltTrueReturn(ret)
2893         self.assertFalse(ret[next(iter(ret))]["changes"])
2894         self.assertEqual(self._read(name), self.with_matching_block)
2895         self._write(name, self.with_matching_block)
2896         ret = self.run_state(
2897             "file.blockreplace",
2898             name=name,
2899             content=self.content.rstrip("\r\n"),
2900             marker_start=self.marker_start,
2901             marker_end=self.marker_end,
2902         )
2903         self.assertSaltTrueReturn(ret)
2904         self.assertFalse(ret[next(iter(ret))]["changes"])
2905         self.assertEqual(self._read(name), self.with_matching_block)
2906         ret = self.run_state(
2907             "file.blockreplace",
2908             name=name,
2909             content=self.content.rstrip("\r\n"),
2910             marker_start=self.marker_start,
2911             marker_end=self.marker_end,
2912         )
2913         self.assertSaltTrueReturn(ret)
2914         self.assertFalse(ret[next(iter(ret))]["changes"])
2915         self.assertEqual(self._read(name), self.with_matching_block)
2916     @with_tempfile()
2917     def test_matching_block_append_newline(self, name):
2918         self._write(name, self.with_matching_block)
2919         ret = self.run_state(
2920             "file.blockreplace",
2921             name=name,
2922             content=self.content,
2923             marker_start=self.marker_start,
2924             marker_end=self.marker_end,
2925             append_newline=True,
2926         )
2927         self.assertSaltTrueReturn(ret)
2928         self.assertTrue(ret[next(iter(ret))]["changes"])
2929         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2930         ret = self.run_state(
2931             "file.blockreplace",
2932             name=name,
2933             content=self.content,
2934             marker_start=self.marker_start,
2935             marker_end=self.marker_end,
2936             append_newline=True,
2937         )
2938         self.assertSaltTrueReturn(ret)
2939         self.assertFalse(ret[next(iter(ret))]["changes"])
2940         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2941         self._write(name, self.with_matching_block)
2942         ret = self.run_state(
2943             "file.blockreplace",
2944             name=name,
2945             content=self.content.rstrip("\r\n"),
2946             marker_start=self.marker_start,
2947             marker_end=self.marker_end,
2948             append_newline=True,
2949         )
2950         self.assertSaltTrueReturn(ret)
2951         self.assertFalse(ret[next(iter(ret))]["changes"])
2952         self.assertEqual(self._read(name), self.with_matching_block)
2953         ret = self.run_state(
2954             "file.blockreplace",
2955             name=name,
2956             content=self.content.rstrip("\r\n"),
2957             marker_start=self.marker_start,
2958             marker_end=self.marker_end,
2959             append_newline=True,
2960         )
2961         self.assertSaltTrueReturn(ret)
2962         self.assertFalse(ret[next(iter(ret))]["changes"])
2963         self.assertEqual(self._read(name), self.with_matching_block)
2964     @with_tempfile()
2965     def test_matching_block_no_append_newline(self, name):
2966         self._write(name, self.with_matching_block)
2967         ret = self.run_state(
2968             "file.blockreplace",
2969             name=name,
2970             content=self.content,
2971             marker_start=self.marker_start,
2972             marker_end=self.marker_end,
2973             append_newline=False,
2974         )
2975         self.assertSaltTrueReturn(ret)
2976         self.assertFalse(ret[next(iter(ret))]["changes"])
2977         self.assertEqual(self._read(name), self.with_matching_block)
2978         ret = self.run_state(
2979             "file.blockreplace",
2980             name=name,
2981             content=self.content,
2982             marker_start=self.marker_start,
2983             marker_end=self.marker_end,
2984             append_newline=False,
2985         )
2986         self.assertSaltTrueReturn(ret)
2987         self.assertFalse(ret[next(iter(ret))]["changes"])
2988         self.assertEqual(self._read(name), self.with_matching_block)
2989         self._write(name, self.with_matching_block)
2990         ret = self.run_state(
2991             "file.blockreplace",
2992             name=name,
2993             content=self.content.rstrip("\r\n"),
2994             marker_start=self.marker_start,
2995             marker_end=self.marker_end,
2996             append_newline=False,
2997         )
2998         self.assertSaltTrueReturn(ret)
2999         self.assertTrue(ret[next(iter(ret))]["changes"])
3000         self.assertEqual(
3001             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3002         )
3003         ret = self.run_state(
3004             "file.blockreplace",
3005             name=name,
3006             content=self.content.rstrip("\r\n"),
3007             marker_start=self.marker_start,
3008             marker_end=self.marker_end,
3009             append_newline=False,
3010         )
3011         self.assertSaltTrueReturn(ret)
3012         self.assertFalse(ret[next(iter(ret))]["changes"])
3013         self.assertEqual(
3014             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3015         )
3016     @with_tempfile()
3017     def test_matching_block_and_marker_not_after_newline(self, name):
3018         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3019         ret = self.run_state(
3020             "file.blockreplace",
3021             name=name,
3022             content=self.content,
3023             marker_start=self.marker_start,
3024             marker_end=self.marker_end,
3025         )
3026         self.assertSaltTrueReturn(ret)
3027         self.assertTrue(ret[next(iter(ret))]["changes"])
3028         self.assertEqual(self._read(name), self.with_matching_block)
3029         ret = self.run_state(
3030             "file.blockreplace",
3031             name=name,
3032             content=self.content,
3033             marker_start=self.marker_start,
3034             marker_end=self.marker_end,
3035         )
3036         self.assertSaltTrueReturn(ret)
3037         self.assertFalse(ret[next(iter(ret))]["changes"])
3038         self.assertEqual(self._read(name), self.with_matching_block)
3039         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3040         ret = self.run_state(
3041             "file.blockreplace",
3042             name=name,
3043             content=self.content.rstrip("\r\n"),
3044             marker_start=self.marker_start,
3045             marker_end=self.marker_end,
3046         )
3047         self.assertSaltTrueReturn(ret)
3048         self.assertTrue(ret[next(iter(ret))]["changes"])
3049         self.assertEqual(self._read(name), self.with_matching_block)
3050         ret = self.run_state(
3051             "file.blockreplace",
3052             name=name,
3053             content=self.content.rstrip("\r\n"),
3054             marker_start=self.marker_start,
3055             marker_end=self.marker_end,
3056         )
3057         self.assertSaltTrueReturn(ret)
3058         self.assertFalse(ret[next(iter(ret))]["changes"])
3059         self.assertEqual(self._read(name), self.with_matching_block)
3060     @with_tempfile()
3061     def test_matching_block_and_marker_not_after_newline_append_newline(self, name):
3062         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3063         ret = self.run_state(
3064             "file.blockreplace",
3065             name=name,
3066             content=self.content,
3067             marker_start=self.marker_start,
3068             marker_end=self.marker_end,
3069             append_newline=True,
3070         )
3071         self.assertSaltTrueReturn(ret)
3072         self.assertTrue(ret[next(iter(ret))]["changes"])
3073         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3074         ret = self.run_state(
3075             "file.blockreplace",
3076             name=name,
3077             content=self.content,
3078             marker_start=self.marker_start,
3079             marker_end=self.marker_end,
3080             append_newline=True,
3081         )
3082         self.assertSaltTrueReturn(ret)
3083         self.assertFalse(ret[next(iter(ret))]["changes"])
3084         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3085         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3086         ret = self.run_state(
3087             "file.blockreplace",
3088             name=name,
3089             content=self.content.rstrip("\r\n"),
3090             marker_start=self.marker_start,
3091             marker_end=self.marker_end,
3092             append_newline=True,
3093         )
3094         self.assertSaltTrueReturn(ret)
3095         self.assertTrue(ret[next(iter(ret))]["changes"])
3096         self.assertEqual(self._read(name), self.with_matching_block)
3097         ret = self.run_state(
3098             "file.blockreplace",
3099             name=name,
3100             content=self.content.rstrip("\r\n"),
3101             marker_start=self.marker_start,
3102             marker_end=self.marker_end,
3103             append_newline=True,
3104         )
3105         self.assertSaltTrueReturn(ret)
3106         self.assertFalse(ret[next(iter(ret))]["changes"])
3107         self.assertEqual(self._read(name), self.with_matching_block)
3108     @with_tempfile()
3109     def test_matching_block_and_marker_not_after_newline_no_append_newline(self, name):
3110         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3111         ret = self.run_state(
3112             "file.blockreplace",
3113             name=name,
3114             content=self.content,
3115             marker_start=self.marker_start,
3116             marker_end=self.marker_end,
3117             append_newline=False,
3118         )
3119         self.assertSaltTrueReturn(ret)
3120         self.assertTrue(ret[next(iter(ret))]["changes"])
3121         self.assertEqual(self._read(name), self.with_matching_block)
3122         ret = self.run_state(
3123             "file.blockreplace",
3124             name=name,
3125             content=self.content,
3126             marker_start=self.marker_start,
3127             marker_end=self.marker_end,
3128             append_newline=False,
3129         )
3130         self.assertSaltTrueReturn(ret)
3131         self.assertFalse(ret[next(iter(ret))]["changes"])
3132         self.assertEqual(self._read(name), self.with_matching_block)
3133         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3134         ret = self.run_state(
3135             "file.blockreplace",
3136             name=name,
3137             content=self.content.rstrip("\r\n"),
3138             marker_start=self.marker_start,
3139             marker_end=self.marker_end,
3140             append_newline=False,
3141         )
3142         self.assertSaltTrueReturn(ret)
3143         self.assertFalse(ret[next(iter(ret))]["changes"])
3144         self.assertEqual(
3145             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3146         )
3147         ret = self.run_state(
3148             "file.blockreplace",
3149             name=name,
3150             content=self.content.rstrip("\r\n"),
3151             marker_start=self.marker_start,
3152             marker_end=self.marker_end,
3153             append_newline=False,
3154         )
3155         self.assertSaltTrueReturn(ret)
3156         self.assertFalse(ret[next(iter(ret))]["changes"])
3157         self.assertEqual(
3158             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3159         )
3160     @with_tempfile()
3161     def test_issue_49043(self, name):
3162         ret = self.run_function(
3163             "state.sls",
3164             mods="issue-49043",
3165             pillar={"name": name},
3166         )
3167         log.error("ret = %s", repr(ret))
3168         diff = "--- \n+++ \n@@ -0,0 +1,3 @@\n"
3169         diff += dedent(
3170         )
3171         job = "file_|-somefile-blockreplace_|-{}_|-blockreplace".format(name)
3172         self.assertEqual(ret[job]["changes"]["diff"], diff)
3173 @pytest.mark.windows_whitelisted
3174 class RemoteFileTest(ModuleCase, SaltReturnAssertsMixin):
3175     @classmethod
3176     def setUpClass(cls):
3177         cls.webserver = Webserver()
3178         cls.webserver.start()
3179         cls.source = cls.webserver.url("grail/scene33")
3180         if IS_WINDOWS:
3181             cls.source_hash = "21438b3d5fd2c0028bcab92f7824dc69"
3182         else:
3183             cls.source_hash = "d2feb3beb323c79fc7a0f44f1408b4a3"
3184     @classmethod
3185     def tearDownClass(cls):
3186         cls.webserver.stop()
3187     @with_tempfile(create=False)
3188     def setUp(self, name):  # pylint: disable=arguments-differ
3189         self.name = name
3190     def tearDown(self):
3191         try:
3192             os.remove(self.name)
3193         except OSError as exc:
3194             if exc.errno != errno.ENOENT:
3195                 raise
3196     def run_state(self, *args, **kwargs):  # pylint: disable=arguments-differ
3197         ret = super().run_state(*args, **kwargs)
3198         log.debug("ret = %s", ret)
3199         return ret
3200     def test_file_managed_http_source_no_hash(self):
3201         ret = self.run_state(
3202             "file.managed", name=self.name, source=self.source, skip_verify=False
3203         )
3204         self.assertSaltFalseReturn(ret)
3205     def test_file_managed_http_source(self):
3206         ret = self.run_state(
3207             "file.managed",
3208             name=self.name,
3209             source=self.source,
3210             source_hash=self.source_hash,
3211             skip_verify=False,
3212         )
3213         self.assertSaltTrueReturn(ret)
3214     def test_file_managed_http_source_skip_verify(self):
3215         ret = self.run_state(
3216             "file.managed", name=self.name, source=self.source, skip_verify=True
3217         )
3218         self.assertSaltTrueReturn(ret)
3219     def test_file_managed_keep_source_false_http(self):
3220         ret = self.run_state(
3221             "file.managed",
3222             name=self.name,
3223             source=self.source,
3224             source_hash=self.source_hash,
3225             keep_source=False,
3226         )
3227         ret = ret[next(iter(ret))]
3228         assert ret["result"] is True
3229         result = self.run_function("cp.is_cached", [self.source])
3230         assert result == "", "File is still cached at {}".format(result)
3231 @skipIf(not salt.utils.path.which("patch"), "patch is not installed")
3232 @pytest.mark.windows_whitelisted
3233 class PatchTest(ModuleCase, SaltReturnAssertsMixin):
3234     def _check_patch_version(self, min_version):
3235         version = self.run_function("cmd.run", ["patch --version"]).splitlines()[0]
3236         version = version.split()[1]
3237         if _LooseVersion(version) &lt; _LooseVersion(min_version):
3238             self.skipTest(
3239                 "Minimum patch version required: {}. "
3240                 "Patch version installed: {}".format(min_version, version)
3241             )
3242     @classmethod
3243     def setUpClass(cls):
3244         cls.webserver = Webserver()
3245         cls.webserver.start()
3246         cls.numbers_patch_name = "numbers.patch"
3247         cls.math_patch_name = "math.patch"
3248         cls.all_patch_name = "all.patch"
3249         cls.numbers_patch_template_name = cls.numbers_patch_name + ".jinja"
3250         cls.math_patch_template_name = cls.math_patch_name + ".jinja"
3251         cls.all_patch_template_name = cls.all_patch_name + ".jinja"
3252         cls.numbers_patch_path = "patches/" + cls.numbers_patch_name
3253         cls.math_patch_path = "patches/" + cls.math_patch_name
3254         cls.all_patch_path = "patches/" + cls.all_patch_name
3255         cls.numbers_patch_template_path = "patches/" + cls.numbers_patch_template_name
3256         cls.math_patch_template_path = "patches/" + cls.math_patch_template_name
3257         cls.all_patch_template_path = "patches/" + cls.all_patch_template_name
3258         cls.numbers_patch = "salt://" + cls.numbers_patch_path
3259         cls.math_patch = "salt://" + cls.math_patch_path
3260         cls.all_patch = "salt://" + cls.all_patch_path
3261         cls.numbers_patch_template = "salt://" + cls.numbers_patch_template_path
3262         cls.math_patch_template = "salt://" + cls.math_patch_template_path
3263         cls.all_patch_template = "salt://" + cls.all_patch_template_path
3264         cls.numbers_patch_http = cls.webserver.url(cls.numbers_patch_path)
3265         cls.math_patch_http = cls.webserver.url(cls.math_patch_path)
3266         cls.all_patch_http = cls.webserver.url(cls.all_patch_path)
3267         cls.numbers_patch_template_http = cls.webserver.url(
3268             cls.numbers_patch_template_path
3269         )
3270         cls.math_patch_template_http = cls.webserver.url(cls.math_patch_template_path)
3271         cls.all_patch_template_http = cls.webserver.url(cls.all_patch_template_path)
3272         patches_dir = os.path.join(RUNTIME_VARS.FILES, "file", "base", "patches")
3273         cls.numbers_patch_hash = salt.utils.hashutils.get_hash(
3274             os.path.join(patches_dir, cls.numbers_patch_name)
3275         )
3276         cls.math_patch_hash = salt.utils.hashutils.get_hash(
3277             os.path.join(patches_dir, cls.math_patch_name)
3278         )
3279         cls.all_patch_hash = salt.utils.hashutils.get_hash(
3280             os.path.join(patches_dir, cls.all_patch_name)
3281         )
3282         cls.numbers_patch_template_hash = salt.utils.hashutils.get_hash(
3283             os.path.join(patches_dir, cls.numbers_patch_template_name)
3284         )
3285         cls.math_patch_template_hash = salt.utils.hashutils.get_hash(
3286             os.path.join(patches_dir, cls.math_patch_template_name)
3287         )
3288         cls.all_patch_template_hash = salt.utils.hashutils.get_hash(
3289             os.path.join(patches_dir, cls.all_patch_template_name)
3290         )
3291         cls.context = {"two": "two", "ten": 10}
3292     @classmethod
3293     def tearDownClass(cls):
3294         cls.webserver.stop()
3295     def setUp(self):
3296         self.base_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
3297         os.makedirs(os.path.join(self.base_dir, "foo", "bar"))
3298         self.numbers_file = os.path.join(self.base_dir, "foo", "numbers.txt")
3299         self.math_file = os.path.join(self.base_dir, "foo", "bar", "math.txt")
3300         with salt.utils.files.fopen(self.numbers_file, "w") as fp_:
3301             fp_.write(
3302                 textwrap.dedent(
3303                 )
3304             )
3305         with salt.utils.files.fopen(self.math_file, "w") as fp_:
3306             fp_.write(
3307                 textwrap.dedent(
3308                 )
3309             )
3310         self.addCleanup(shutil.rmtree, self.base_dir, ignore_errors=True)
3311     def test_patch_single_file(self):
3312         ret = self.run_state(
3313             "file.patch",
3314             name=self.numbers_file,
3315             source=self.numbers_patch,
3316         )
3317         self.assertSaltTrueReturn(ret)
3318         ret = ret[next(iter(ret))]
3319         self.assertEqual(ret["comment"], "Patch successfully applied")
3320         ret = self.run_state(
3321             "file.patch",
3322             name=self.numbers_file,
3323             source=self.numbers_patch,
3324         )
3325         self.assertSaltTrueReturn(ret)
3326         ret = ret[next(iter(ret))]
3327         self.assertEqual(ret["comment"], "Patch was already applied")
3328         self.assertEqual(ret["changes"], {})
3329     def test_patch_directory(self):
3330         self._check_patch_version("2.6")
3331         ret = self.run_state(
3332             "file.patch",
3333             name=self.base_dir,
3334             source=self.all_patch,
3335             strip=1,
3336         )
3337         self.assertSaltTrueReturn(ret)
3338         ret = ret[next(iter(ret))]
3339         self.assertEqual(ret["comment"], "Patch successfully applied")
3340         ret = self.run_state(
3341             "file.patch",
3342             name=self.base_dir,
3343             source=self.all_patch,
3344             strip=1,
3345         )
3346         self.assertSaltTrueReturn(ret)
3347         ret = ret[next(iter(ret))]
3348         self.assertEqual(ret["comment"], "Patch was already applied")
3349         self.assertEqual(ret["changes"], {})
3350     def test_patch_strip_parsing(self):
3351         self._check_patch_version("2.6")
3352         ret = self.run_state(
3353             "file.patch",
3354             name=self.base_dir,
3355             source=self.all_patch,
3356             options="-p1",
3357         )
3358         self.assertSaltTrueReturn(ret)
3359         ret = ret[next(iter(ret))]
3360         self.assertEqual(ret["comment"], "Patch successfully applied")
3361         ret = self.run_state(
3362             "file.patch",
3363             name=self.base_dir,
3364             source=self.all_patch,
3365             options="--strip=1",
3366         )
3367         self.assertSaltTrueReturn(ret)
3368         ret = ret[next(iter(ret))]
3369         self.assertEqual(ret["comment"], "Patch was already applied")
3370         self.assertEqual(ret["changes"], {})
3371         ret = self.run_state(
3372             "file.patch",
3373             name=self.base_dir,
3374             source=self.all_patch,
3375             options="--strip 1",
3376         )
3377         self.assertSaltTrueReturn(ret)
3378         ret = ret[next(iter(ret))]
3379         self.assertEqual(ret["comment"], "Patch was already applied")
3380         self.assertEqual(ret["changes"], {})
3381     def test_patch_saltenv(self):
3382         ret = self.run_state(
3383             "file.patch",
3384             name=self.math_file,
3385             source=self.math_patch,
3386             saltenv="prod",
3387         )
3388         self.assertSaltFalseReturn(ret)
3389         ret = ret[next(iter(ret))]
3390         self.assertEqual(
3391             ret["comment"],
3392             "Source file {} not found in saltenv 'prod'".format(self.math_patch),
3393         )
3394     def test_patch_single_file_failure(self):
3395         with salt.utils.files.fopen(self.numbers_file, "w"):
3396             pass
3397         ret = self.run_state(
3398             "file.patch",
3399             name=self.numbers_file,
3400             source=self.numbers_patch,
3401         )
3402         self.assertSaltFalseReturn(ret)
3403         ret = ret[next(iter(ret))]
3404         self.assertIn("Patch would not apply cleanly", ret["comment"])
3405         reject_file = salt.utils.files.mkstemp()
3406         ret = self.run_state(
3407             "file.patch",
3408             name=self.numbers_file,
3409             source=self.numbers_patch,
3410             reject_file=reject_file,
3411             strip=1,
3412         )
3413         self.assertSaltFalseReturn(ret)
3414         ret = ret[next(iter(ret))]
3415         self.assertIn("Patch would not apply cleanly", ret["comment"])
3416         if IS_WINDOWS:
3417             reject_file = reject_file.replace("\\", "\\\\")
3418             reject_file = "'{}'".format(reject_file)
3419         self.assertRegex(
3420             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
3421         )
3422     def test_patch_directory_failure(self):
3423         with salt.utils.files.fopen(self.math_file, "w"):
3424             pass
3425         ret = self.run_state(
3426             "file.patch",
3427             name=self.base_dir,
3428             source=self.all_patch,
3429             strip=1,
3430         )
3431         self.assertSaltFalseReturn(ret)
3432         ret = ret[next(iter(ret))]
3433         self.assertIn("Patch would not apply cleanly", ret["comment"])
3434         reject_file = salt.utils.files.mkstemp()
3435         ret = self.run_state(
3436             "file.patch",
3437             name=self.base_dir,
3438             source=self.all_patch,
3439             reject_file=reject_file,
3440             strip=1,
3441         )
3442         self.assertSaltFalseReturn(ret)
3443         ret = ret[next(iter(ret))]
3444         self.assertIn("Patch would not apply cleanly", ret["comment"])
3445         if IS_WINDOWS:
3446             reject_file = reject_file.replace("\\", "\\\\")
3447             reject_file = "'{}'".format(reject_file)
3448         self.assertRegex(
3449             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
3450         )
3451     def test_patch_single_file_remote_source(self):
3452         ret = self.run_state(
3453             "file.patch",
3454             name=self.math_file,
3455             source=self.math_patch_http,
3456         )
3457         self.assertSaltFalseReturn(ret)
3458         ret = ret[next(iter(ret))]
3459         self.assertIn("Unable to verify upstream hash", ret["comment"])
3460         ret = self.run_state(
3461             "file.patch",
3462             name=self.math_file,
3463             source=self.math_patch_http,
3464             source_hash=self.math_patch_hash,
3465         )
3466         self.assertSaltTrueReturn(ret)
3467         ret = ret[next(iter(ret))]
3468         self.assertEqual(ret["comment"], "Patch successfully applied")
3469         ret = self.run_state(
3470             "file.patch",
3471             name=self.math_file,
3472             source=self.math_patch_http,
3473             skip_verify=True,
3474         )
3475         self.assertSaltTrueReturn(ret)
3476         ret = ret[next(iter(ret))]
3477         self.assertEqual(ret["comment"], "Patch was already applied")
3478         self.assertEqual(ret["changes"], {})
3479     def test_patch_directory_remote_source(self):
3480         self._check_patch_version("2.6")
3481         ret = self.run_state(
3482             "file.patch",
3483             name=self.base_dir,
3484             source=self.all_patch_http,
3485             strip=1,
3486         )
3487         self.assertSaltFalseReturn(ret)
3488         ret = ret[next(iter(ret))]
3489         self.assertIn("Unable to verify upstream hash", ret["comment"])
3490         ret = self.run_state(
3491             "file.patch",
3492             name=self.base_dir,
3493             source=self.all_patch_http,
3494             source_hash=self.all_patch_hash,
3495             strip=1,
3496         )
3497         self.assertSaltTrueReturn(ret)
3498         ret = ret[next(iter(ret))]
3499         self.assertEqual(ret["comment"], "Patch successfully applied")
3500         ret = self.run_state(
3501             "file.patch",
3502             name=self.base_dir,
3503             source=self.all_patch_http,
3504             strip=1,
3505             skip_verify=True,
3506         )
3507         self.assertSaltTrueReturn(ret)
3508         ret = ret[next(iter(ret))]
3509         self.assertEqual(ret["comment"], "Patch was already applied")
3510         self.assertEqual(ret["changes"], {})
3511     def test_patch_single_file_template(self):
3512         ret = self.run_state(
3513             "file.patch",
3514             name=self.numbers_file,
3515             source=self.numbers_patch_template,
3516             template="jinja",
3517             context=self.context,
3518         )
3519         self.assertSaltTrueReturn(ret)
3520         ret = ret[next(iter(ret))]
3521         self.assertEqual(ret["comment"], "Patch successfully applied")
3522         ret = self.run_state(
3523             "file.patch",
3524             name=self.numbers_file,
3525             source=self.numbers_patch_template,
3526             template="jinja",
3527             context=self.context,
3528         )
3529         self.assertSaltTrueReturn(ret)
3530         ret = ret[next(iter(ret))]
3531         self.assertEqual(ret["comment"], "Patch was already applied")
3532         self.assertEqual(ret["changes"], {})
3533     def test_patch_directory_template(self):
3534         self._check_patch_version("2.6")
3535         ret = self.run_state(
3536             "file.patch",
3537             name=self.base_dir,
3538             source=self.all_patch_template,
3539             template="jinja",
3540             context=self.context,
3541             strip=1,
3542         )
3543         self.assertSaltTrueReturn(ret)
3544         ret = ret[next(iter(ret))]
3545         self.assertEqual(ret["comment"], "Patch successfully applied")
3546         ret = self.run_state(
3547             "file.patch",
3548             name=self.base_dir,
3549             source=self.all_patch_template,
3550             template="jinja",
3551             context=self.context,
3552             strip=1,
3553         )
3554         self.assertSaltTrueReturn(ret)
3555         ret = ret[next(iter(ret))]
3556         self.assertEqual(ret["comment"], "Patch was already applied")
3557         self.assertEqual(ret["changes"], {})
3558     def test_patch_single_file_remote_source_template(self):
3559         ret = self.run_state(
3560             "file.patch",
3561             name=self.math_file,
3562             source=self.math_patch_template_http,
3563             template="jinja",
3564             context=self.context,
3565         )
3566         self.assertSaltFalseReturn(ret)
3567         ret = ret[next(iter(ret))]
3568         self.assertIn("Unable to verify upstream hash", ret["comment"])
3569         ret = self.run_state(
3570             "file.patch",
3571             name=self.math_file,
3572             source=self.math_patch_template_http,
3573             source_hash=self.math_patch_template_hash,
3574             template="jinja",
3575             context=self.context,
3576         )
3577         self.assertSaltTrueReturn(ret)
3578         ret = ret[next(iter(ret))]
3579         self.assertEqual(ret["comment"], "Patch successfully applied")
3580         ret = self.run_state(
3581             "file.patch",
3582             name=self.math_file,
3583             source=self.math_patch_template_http,
3584             template="jinja",
3585             context=self.context,
3586             skip_verify=True,
3587         )
3588         self.assertSaltTrueReturn(ret)
3589         ret = ret[next(iter(ret))]
3590         self.assertEqual(ret["comment"], "Patch was already applied")
3591         self.assertEqual(ret["changes"], {})
3592     def test_patch_directory_remote_source_template(self):
3593         self._check_patch_version("2.6")
3594         ret = self.run_state(
3595             "file.patch",
3596             name=self.base_dir,
3597             source=self.all_patch_template_http,
3598             template="jinja",
3599             context=self.context,
3600             strip=1,
3601         )
3602         self.assertSaltFalseReturn(ret)
3603         ret = ret[next(iter(ret))]
3604         self.assertIn("Unable to verify upstream hash", ret["comment"])
3605         ret = self.run_state(
3606             "file.patch",
3607             name=self.base_dir,
3608             source=self.all_patch_template_http,
3609             source_hash=self.all_patch_template_hash,
3610             template="jinja",
3611             context=self.context,
3612             strip=1,
3613         )
3614         self.assertSaltTrueReturn(ret)
3615         ret = ret[next(iter(ret))]
3616         self.assertEqual(ret["comment"], "Patch successfully applied")
3617         ret = self.run_state(
3618             "file.patch",
3619             name=self.base_dir,
3620             source=self.all_patch_template_http,
3621             template="jinja",
3622             context=self.context,
3623             strip=1,
3624             skip_verify=True,
3625         )
3626         self.assertSaltTrueReturn(ret)
3627         ret = ret[next(iter(ret))]
3628         self.assertEqual(ret["comment"], "Patch was already applied")
3629         self.assertEqual(ret["changes"], {})
3630     def test_patch_test_mode(self):
3631         ret = self.run_state(
3632             "file.patch",
3633             name=self.numbers_file,
3634             source=self.numbers_patch,
3635             test=True,
3636         )
3637         self.assertSaltNoneReturn(ret)
3638         ret = ret[next(iter(ret))]
3639         self.assertEqual(ret["comment"], "The patch would be applied")
3640         self.assertTrue(ret["changes"])
3641         ret = self.run_state(
3642             "file.patch",
3643             name=self.numbers_file,
3644             source=self.numbers_patch,
3645         )
3646         self.assertSaltTrueReturn(ret)
3647         ret = ret[next(iter(ret))]
3648         self.assertEqual(ret["comment"], "Patch successfully applied")
3649         self.assertTrue(ret["changes"])
3650         ret = self.run_state(
3651             "file.patch",
3652             name=self.numbers_file,
3653             source=self.numbers_patch,
3654             test=True,
3655         )
3656         self.assertSaltTrueReturn(ret)
3657         ret = ret[next(iter(ret))]
3658         self.assertEqual(ret["comment"], "Patch was already applied")
3659         self.assertEqual(ret["changes"], {})
3660         with salt.utils.files.fopen(self.numbers_file, "w"):
3661             pass
3662         ret = self.run_state(
3663             "file.patch",
3664             name=self.numbers_file,
3665             source=self.numbers_patch,
3666             test=True,
3667         )
3668         self.assertSaltFalseReturn(ret)
3669         ret = ret[next(iter(ret))]
3670         self.assertIn("Patch would not apply cleanly", ret["comment"])
3671         self.assertEqual(ret["changes"], {})
3672 WIN_TEST_FILE = "c:/testfile"
3673 @pytest.mark.destructive_test
3674 @skipIf(not IS_WINDOWS, "windows test only")
3675 @pytest.mark.windows_whitelisted
3676 class WinFileTest(ModuleCase):
3677     def setUp(self):
3678         self.run_state(
3679             "file.managed", name=WIN_TEST_FILE, makedirs=True, contents="Only a test"
3680         )
3681     def tearDown(self):
3682         self.run_state("file.absent", name=WIN_TEST_FILE)
3683     def test_file_managed(self):
3684         self.assertTrue(self.run_state("file.exists", name=WIN_TEST_FILE))
3685     def test_file_copy(self):
3686         ret = self.run_state(
3687             "file.copy", name="c:/testfile_copy", makedirs=True, source=WIN_TEST_FILE
3688         )
3689         self.assertTrue(ret)
3690     def test_file_comment(self):
3691         self.run_state("file.comment", name=WIN_TEST_FILE, regex="^Only")
3692         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
3693             self.assertTrue(fp_.read().startswith("#Only"))
3694     def test_file_replace(self):
3695         self.run_state(
3696             "file.replace", name=WIN_TEST_FILE, pattern="test", repl="testing"
3697         )
3698         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
3699             self.assertIn("testing", fp_.read())
3700     def test_file_absent(self):
3701         ret = self.run_state("file.absent", name=WIN_TEST_FILE)
3702         self.assertTrue(ret)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
