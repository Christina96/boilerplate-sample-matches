<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_syslog_ng_1.py &amp; test_file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_syslog_ng_1.py &amp; test_file_2.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_syslog_ng_1.py (15.748032%)<th>test_file_2.py (0.98364687%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(186-194)<td><a href="#" name="0">(378-386)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(336-340)<td><a href="#" name="1">(456-462)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(176-182)<td><a href="#" name="2">(2767-2774)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(157-163)<td><a href="#" name="3">(2414-2420)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(343-347)<td><a href="#" name="4">(2722-2729)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(84-87)<td><a href="#" name="5">(2926-2938)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_syslog_ng_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 from textwrap import dedent
3 import salt.modules.syslog_ng as syslog_ng
4 import salt.utils.platform
5 from tests.support.mixins import LoaderModuleMockMixin
6 from tests.support.mock import MagicMock, patch
7 from tests.support.unit import TestCase, skipIf
8 _VERSION = "3.6.0alpha0"
9 _MODULES = (
10     "syslogformat,json-plugin,basicfuncs,afstomp,afsocket,cryptofuncs,"
11     "afmongodb,dbparser,system-source,affile,pseudofile,afamqp,"
12     "afsocket-notls,csvparser,linux-kmsg-format,afuser,confgen,afprog"
13 )
14 VERSION_OUTPUT = """syslog-ng {0}
15 Installer-Version: {0}
16 Revision:
17 Compile-Date: Apr  4 2014 20:26:18
18 Error opening plugin module; module='afsocket-tls', error='/home/tibi/install/syslog-ng/lib/syslog-ng/libafsocket-tls.so: undefined symbol: tls_context_setup_session'
19 Available-Modules: {1}
20 Enable-Debug: on
21 Enable-GProf: off
22 Enable-Memtrace: off
23 Enable-IPv6: on
24 Enable-Spoof-Source: off
25 Enable-TCP-Wrapper: off
26 Enable-Linux-Caps: off""".format(
27     _VERSION, _MODULES
28 )
29 STATS_OUTPUT = """SourceName;SourceId;SourceInstance;State;Type;Number
30 center;;received;a;processed;0
31 destination;#anon-destination0;;a;processed;0
32 destination;#anon-destination1;;a;processed;0
33 source;s_gsoc2014;;a;processed;0
34 center;;queued;a;processed;0
35 global;payload_reallocs;;a;processed;0
36 global;sdata_updates;;a;processed;0
37 global;msg_clones;;a;processed;0"""
38 _SYSLOG_NG_NOT_INSTALLED_RETURN_VALUE = {
39     "retcode": -1,
40     "stderr": "Unable to execute the command 'syslog-ng'. It is not in the PATH.",
41 }
42 _SYSLOG_NG_CTL_NOT_INSTALLED_RETURN_VALUE = {
43     "retcode": -1,
44     "stderr": "Unable to execute the command 'syslog-ng-ctl'. It is not in the PATH.",
45 }
46 class SyslogNGTestCase(TestCase, LoaderModuleMockMixin):
47     orig_env = {"PATH": "/foo:/bar"}
48     bin_dir = "/baz"
49     mocked_env = {"PATH": "/foo:/bar:/baz"}
50     def setup_loader_modules(self):
51         return {syslog_ng: {}}
52     def test_statement_without_options(self):
53         s = syslog_ng.Statement("source", "s_local", options=[])
54         b = s.build()
55         self.assertEqual(
56             dedent(
57             ),
58             b,
59     def test_non_empty_statement(self):
60         o1 = syslog_ng<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Option("file")
61         o2 = syslog_ng.Option("tcp")
62         s = syslog_ng.Statement("source", "s_local", options=[o1, o2])
63         b = s.</b></font>build()
64         self.assertEqual(
65             dedent(
66             ),
67             b,
68         )
69     def test_option_with_parameters(self):
70         o1 = syslog_ng.Option("file")
71         p1 = syslog_ng.SimpleParameter('"/var/log/messages"')
72         p2 = syslog_ng.SimpleParameter()
73         p3 = syslog_ng.TypedParameter()
74         p3.type = "tls"
75         p2.value = '"/var/log/syslog"'
76         o1.add_parameter(p1)
77         o1.add_parameter(p2)
78         o1.add_parameter(p3)
79         b = o1.build()
80         self.assertEqual(
81             dedent(
82             ),
83             b,
84         )
85     def test_parameter_with_values(self):
86         p = syslog_ng.TypedParameter()
87         p.type = "tls"
88         v1 = syslog_ng.TypedParameterValue()
89         v1.type = "key_file"
90         v2 = syslog_ng.TypedParameterValue()
91         v2.type = "cert_file"
92         p.add_value(v1)
93         p.add_value(v2)
94         b = p.build()
95         self.assertEqual(
96             dedent(
97                 """\
98         a1 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
99         a2 = syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
100         t.add_argument(a1)
101         t.add_argument(a2)
102         b = t.build(</b></font>)
103         self.assertEqual(
104             dedent(
105                 """\
106             key_file(
107                 "/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"
108                 "/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"
109             )"""
110             ),
111             b,
112     def test_end_to_end_statement_generation(self):
113         s = syslog_ng<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Statement("source", "s_tls")
114         o = syslog_ng.Option("tcp")
115         ip = syslog_ng.TypedParameter("ip")
116         ip.add_value(syslog_ng.SimpleParameterValue("'192.168.42.2'"))
117         o.</b></font>add_parameter(ip)
118         port = syslog_ng.TypedParameter("port")
119         port.add_value(syslog_ng.SimpleParameterValue(514))
120         o<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_parameter(port)
121         tls = syslog_ng.TypedParameter("tls")
122         key_file = syslog_ng.TypedParameterValue("key_file")
123         key_file.add_argument(
124             syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"')
125         )
126         cert_file = syslog_ng.TypedParameterValue("cert_file")
127         cert_file.add_argument(</b></font>
128             syslog_ng.Argument('"/opt/syslog-ng/etc/syslog-ng/cert.d/syslog-ng.cert"')
129         )
130         peer_verify = syslog_ng.TypedParameterValue("peer_verify")
131         peer_verify.add_argument(syslog_ng.Argument("optional-untrusted"))
132         tls.add_value(key_file)
133         tls.add_value(cert_file)
134         tls.add_value(peer_verify)
135         o.add_parameter(tls)
136         s.add_child(o)
137         b = s.build()
138         self.assertEqual(
139             dedent(
140                 """\
141             source s_tls {
142                 tcp(
143                     ip(
144                         '192.168.42.2'
145                     ),
146                     port(
147                         514
148                     ),
149                     tls(
150                         key_file(
151                             "/opt/syslog-ng/etc/syslog-ng/key.d/syslog-ng.key"
152                         ),
153                         cert_file(
154                             "/opt/syslog-ng/etc/syslog-ng/cert.d/syslog-ng.cert"
155                         ),
156                         peer_verify(
157                             optional-untrusted
158                         )
159                     )
160                 );
161             };
162             """
163             ),
164             b,
165         )
166     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
167     def test_version(self):
168         cmd_ret = {"retcode": 0, "stdout": VERSION_OUTPUT}
169         expected_output = {"retcode": 0, "stdout": _VERSION}
170         cmd_args = ["syslog-ng", "-V"]
171         cmd_mock = MagicMock(return_value=cmd_ret)
172         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
173             os.environ, self.orig_env
174         ):
175             result = syslog_ng.version()
176             self.assertEqual(result, expected_output)
177             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
178         cmd_mock = MagicMock(return_value=cmd_ret)
179         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
180             os.environ, self.orig_env
181         ):
182             result = syslog_ng.version(syslog_ng_sbin_dir=self.bin_dir)
183             self.assertEqual(result, expected_output)
184             cmd_mock.assert_called_once_with(
185                 cmd_args, env=self.mocked_env, python_shell=False
186             )
187     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
188     def test_stats(self):
189         cmd_ret = {"retcode": 0, "stdout": STATS_OUTPUT}
190         cmd_args = ["syslog-ng-ctl", "stats"]
191         cmd_mock = MagicMock(return_value=cmd_ret)
192         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
193             os.environ, self.orig_env
194         ):
195             result = syslog_ng.stats()
196             self.assertEqual(result, cmd_ret)
197             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
198         cmd_mock = MagicMock(return_value=cmd_ret)
199         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
200             os.environ, self.orig_env
201         ):
202             result = syslog_ng.stats(syslog_ng_sbin_dir=self.bin_dir)
203             self.assertEqual(result, cmd_ret)
204             cmd_mock.assert_called_once_with(
205                 cmd_args, env=self.mocked_env, python_shell=False
206             )
207     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
208     def test_modules(self):
209         cmd_ret = {"retcode": 0, "stdout": VERSION_OUTPUT}
210         expected_output = {"retcode": 0, "stdout": _MODULES}
211         cmd_args = ["syslog-ng", "-V"]
212         cmd_mock = MagicMock(return_value=cmd_ret)
213         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
214             os.environ, self.orig_env
215         ):
216             result = syslog_ng.modules()
217             self.assertEqual(result, expected_output)
218             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
219         cmd_mock = MagicMock(return_value=cmd_ret)
220         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
221             os.environ, self.orig_env
222         ):
223             result = syslog_ng.modules(syslog_ng_sbin_dir=self.bin_dir)
224             self.assertEqual(result, expected_output)
225             cmd_mock.assert_called_once_with(
226                 cmd_args, env=self.mocked_env, python_shell=False
227             )
228     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
229     def test_config_test(self):
230         cmd_ret = {"retcode": 0, "stderr": "", "stdout": "Foo"}
231         cmd_args = ["syslog-ng", "--syntax-only"]
232         cmd_mock = MagicMock(return_value=cmd_ret)
233         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
234             os.environ, self.orig_env
235         ):
236             result = syslog_ng.config_test()
237             self.assertEqual(result, cmd_ret)
238             cmd_mock.assert_called_once_with(cmd_args, env=None, python_shell=False)
239         cmd_mock = MagicMock(return_value=cmd_ret)
240         with patch.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
241             os.environ, self.orig_env
242         ):
243             result = syslog_ng.config_test(syslog_ng_sbin_dir=self.bin_dir)
244             self.assertEqual(result, cmd_ret)
245             cmd_mock.assert_called_once_with(
246                 cmd_args, env=self.mocked_env, python_shell=False
247             )
248     @skipIf(salt.utils.platform.is_windows(), "Module not available on Windows")
249     def test_config_test_cfgfile(self):
250         cfgfile = "/path/to/syslog-ng.conf"
251         cmd_ret = {"retcode": 1, "stderr": "Syntax error...", "stdout": ""}
252         cmd_mock = MagicMock(return_value=cmd_ret)
253         with patch.dict(syslog_ng.__salt__, {<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"cmd.run_all": cmd_mock}), patch.dict(
254             os.environ, self.orig_env
255         ):
256             self.assertEqual(syslog_ng.config_test(cfgfile=cfgfile), cmd_ret)
257         cmd_mock = MagicMock(return_value=cmd_ret)
258         with patch<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.dict(syslog_ng.__salt__, {"cmd.run_all": cmd_mock}), patch.dict(
259             os.environ, self.orig_env
260         ):
261             self.assertEqual(
262                 syslog_ng.config_test(</b></font>syslog_ng_sbin_dir=self.bin_dir, cfgfile=cfgfile),
263                 cmd_ret,
264             )
265             cmd_mock.assert_called_once_with(
266                 cmd_args, env=self.mocked_env, python_shell=False
267             )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Tests for the file state
3 """
4 import errno
5 import filecmp
6 import logging
7 import os
8 import pathlib
9 import re
10 import shutil
11 import stat
12 import sys
13 import tempfile
14 import textwrap
15 import pytest
16 import salt.serializers.configparser
17 import salt.serializers.plist
18 import salt.utils.atomicfile
19 import salt.utils.data
20 import salt.utils.files
21 import salt.utils.json
22 import salt.utils.path
23 import salt.utils.platform
24 import salt.utils.stringutils
25 from salt.utils.versions import LooseVersion as _LooseVersion
26 from tests.support.case import ModuleCase
27 from tests.support.helpers import (
28     Webserver,
29     dedent,
30     requires_system_grains,
31     with_system_user_and_group,
32     with_tempdir,
33     with_tempfile,
34 )
35 from tests.support.mixins import SaltReturnAssertsMixin
36 from tests.support.runtests import RUNTIME_VARS
37 from tests.support.unit import skipIf
38 log = logging.getLogger(__name__)
39 HAS_PWD = True
40 try:
41     import pwd
42 except ImportError:
43     HAS_PWD = False
44 HAS_GRP = True
45 try:
46     import grp
47 except ImportError:
48     HAS_GRP = False
49 IS_WINDOWS = salt.utils.platform.is_windows()
50 BINARY_FILE = b"GIF89a\x01\x00\x01\x00\x80\x00\x00\x05\x04\x04\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;"
51 TEST_SYSTEM_USER = "test_system_user"
52 TEST_SYSTEM_GROUP = "test_system_group"
53 DEFAULT_ENDING = salt.utils.stringutils.to_bytes(os.linesep)
54 pytestmark = [
55     pytest.mark.skip_on_freebsd(reason="These tests timeout on FreeBSD"),
56 ]
57 def _test_managed_file_mode_keep_helper(testcase, local=False):
58     """
59     DRY helper function to run the same test with a local or remote path
60     """
61     name = testcase.tmp_dir / "scene33"
62     testcase.addCleanup(salt.utils.files.safe_rm, str(name))
63     grail_fs_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
64     grail = "salt://grail/scene33" if not local else grail_fs_path
65     grail_fs_mode = int(testcase.run_function("file.get_mode", [grail_fs_path]), 8)
66     initial_mode = 0o770
67     new_mode_1 = 0o600
68     new_mode_2 = 0o644
69     ret = testcase.run_state(
70         "file.managed",
71         name=str(name),
72         mode=oct(initial_mode),
73         source=grail,
74     )
75     if IS_WINDOWS:
76         testcase.assertSaltFalseReturn(ret)
77         return
78     testcase.assertSaltTrueReturn(ret)
79     try:
80         os.chmod(grail_fs_path, new_mode_1)
81         ret = testcase.run_state(
82             "file.managed",
83             name=str(name),
84             mode="keep",
85             source=grail,
86         )
87         testcase.assertSaltTrueReturn(ret)
88         managed_mode = stat.S_IMODE(name.stat().st_mode)
89         testcase.assertEqual(oct(managed_mode), oct(new_mode_1))
90         os.chmod(grail_fs_path, new_mode_2)
91         ret = testcase.run_state(
92             "file.managed",
93             name=str(name),
94             mode="keep",
95             source=grail,
96         )
97         testcase.assertSaltTrueReturn(ret)
98         managed_mode = stat.S_IMODE(name.stat().st_mode)
99         testcase.assertEqual(oct(managed_mode), oct(new_mode_2))
100     finally:
101         os.chmod(grail_fs_path, grail_fs_mode)
102 @pytest.mark.windows_whitelisted
103 class FileTest(ModuleCase, SaltReturnAssertsMixin):
104     """
105     Validate the file state
106     """
107     @classmethod
108     def setUpClass(cls):
109         cls.tmp_dir = pathlib.Path(tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)).resolve()
110         def _reline(path, ending=DEFAULT_ENDING):
111             """
112             Normalize the line endings of a file.
113             """
114             with salt.utils.files.fopen(path, "rb") as fhr:
115                 lines = fhr.read().splitlines()
116             with salt.utils.atomicfile.atomic_open(path, "wb") as fhw:
117                 for line in lines:
118                     fhw.write(line + ending)
119         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "firstif")
120         _reline(destpath)
121         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "secondif")
122         _reline(destpath)
123     @classmethod
124     def tearDownClass(cls):
125         salt.utils.files.rm_rf(str(cls.tmp_dir))
126     def _delete_file(self, path):
127         try:
128             os.remove(path)
129         except OSError as exc:
130             if exc.errno != errno.ENOENT:
131                 log.error("Failed to remove %s: %s", path, exc)
132     def tearDown(self):
133         """
134         remove files created in previous tests
135         """
136         user = "salt"
137         if user in str(self.run_function("user.list_users")):
138             self.run_function("user.delete", [user])
139     def test_symlink(self):
140         """
141         file.symlink
142         """
143         name = self.tmp_dir / "symlink"
144         tgt = self.tmp_dir / "target"
145         if IS_WINDOWS and not tgt.is_dir():
146             tgt.mkdir()
147         if IS_WINDOWS and name.is_symlink():
148             name.unlink()
149         ret = self.run_state("file.symlink", name=str(name), target=str(tgt))
150         self.assertSaltTrueReturn(ret)
151     def test_test_symlink(self):
152         """
153         file.symlink test interface
154         """
155         name = self.tmp_dir / "symlink2"
156         tgt = self.tmp_dir / "target2"
157         ret = self.run_state("file.symlink", test=True, name=str(name), target=str(tgt))
158         self.assertSaltNoneReturn(ret)
159     def test_absent_file(self):
160         """
161         file.absent
162         """
163         name = self.tmp_dir / "file_to_kill"
164         name.write_text("killme")
165         ret = self.run_state("file.absent", name=str(name))
166         self.assertSaltTrueReturn(ret)
167         self.assertFalse(name.is_file())
168     def test_absent_dir(self):
169         """
170         file.absent
171         """
172         name = self.tmp_dir / "dir_to_kill"
173         name.mkdir(exist_ok=True)
174         ret = self.run_state("file.absent", name=str(name))
175         self.assertSaltTrueReturn(ret)
176         self.assertFalse(name.is_dir())
177     def test_absent_link(self):
178         """
179         file.absent
180         """
181         name = self.tmp_dir / "link_to_kill"
182         self.addCleanup(salt.utils.files.safe_rm, str(name))
183         tgt = self.tmp_dir / "link_to_kill.tgt"
184         self.addCleanup(salt.utils.files.safe_rm, str(tgt))
185         tgt.symlink_to(name, target_is_directory=IS_WINDOWS)
186         ret = self.run_state("file.absent", name=str(name))
187         self.assertSaltTrueReturn(ret)
188         self.assertFalse(name.exists())
189         self.assertFalse(name.is_symlink())
190     @with_tempfile()
191     def test_test_absent(self, name):
192         """
193         file.absent test interface
194         """
195         with salt.utils.files.fopen(name, "w+") as fp_:
196             fp_.write("killme")
197         ret = self.run_state("file.absent", test=True, name=name)
198         self.assertSaltNoneReturn(ret)
199         self.assertTrue(os.path.isfile(name))
200     def test_managed(self):
201         """
202         file.managed
203         """
204         name = self.tmp_dir / "grail_scene33"
205         self.addCleanup(salt.utils.files.safe_rm, str(name))
206         ret = self.run_state(
207             "file.managed", name=str(name), source="salt://grail/scene33"
208         )
209         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "grail" / "scene33"
210         master_data = src.read_text()
211         minion_data = name.read_text()
212         self.assertEqual(master_data, minion_data)
213         self.assertSaltTrueReturn(ret)
214     def test_managed_file_mode(self):
215         """
216         file.managed, correct file permissions
217         """
218         desired_mode = 504  # 0770 octal
219         name = self.tmp_dir / "grail_scene33"
220         self.addCleanup(salt.utils.files.safe_rm, str(name))
221         ret = self.run_state(
222             "file.managed", name=str(name), mode="0770", source="salt://grail/scene33"
223         )
224         if IS_WINDOWS:
225             expected = "The 'mode' option is not supported on Windows"
226             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
227             self.assertSaltFalseReturn(ret)
228             return
229         resulting_mode = stat.S_IMODE(name.stat().st_mode)
230         self.assertEqual(oct(desired_mode), oct(resulting_mode))
231         self.assertSaltTrueReturn(ret)
232     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
233     def test_managed_file_mode_keep(self):
234         """
235         Test using "mode: keep" in a file.managed state
236         """
237         _test_managed_file_mode_keep_helper(self, local=False)
238     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
239     def test_managed_file_mode_keep_local_source(self):
240         """
241         Test using "mode: keep" in a file.managed state, with a local file path
242         as the source.
243         """
244         _test_managed_file_mode_keep_helper(self, local=True)
245     def test_managed_file_mode_file_exists_replace(self):
246         """
247         file.managed, existing file with replace=True, change permissions
248         """
249         initial_mode = 504  # 0770 octal
250         desired_mode = 384  # 0600 octal
251         name = self.tmp_dir / "grail_scene33"
252         self.addCleanup(salt.utils.files.safe_rm, str(name))
253         ret = self.run_state(
254             "file.managed",
255             name=str(name),
256             mode=oct(initial_mode),
257             source="salt://grail/scene33",
258         )
259         if IS_WINDOWS:
260             expected = "The 'mode' option is not supported on Windows"
261             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
262             self.assertSaltFalseReturn(ret)
263             return
264         resulting_mode = stat.S_IMODE(name.stat().st_mode)
265         self.assertEqual(oct(initial_mode), oct(resulting_mode))
266         ret = self.run_state(
267             "file.managed",
268             name=str(name),
269             replace=True,
270             mode=oct(desired_mode),
271             source="salt://grail/scene33",
272         )
273         resulting_mode = stat.S_IMODE(name.stat().st_mode)
274         self.assertEqual(oct(desired_mode), oct(resulting_mode))
275         self.assertSaltTrueReturn(ret)
276     def test_managed_file_mode_file_exists_noreplace(self):
277         """
278         file.managed, existing file with replace=False, change permissions
279         """
280         initial_mode = 504  # 0770 octal
281         desired_mode = 384  # 0600 octal
282         name = self.tmp_dir / "grail_scene33"
283         self.addCleanup(salt.utils.files.safe_rm, str(name))
284         ret = self.run_state(
285             "file.managed",
286             name=str(name),
287             replace=True,
288             mode=oct(initial_mode),
289             source="salt://grail/scene33",
290         )
291         if IS_WINDOWS:
292             expected = "The 'mode' option is not supported on Windows"
293             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
294             self.assertSaltFalseReturn(ret)
295             return
296         ret = self.run_state(
297             "file.managed",
298             name=str(name),
299             replace=False,
300             mode=oct(desired_mode),
301             source="salt://grail/scene33",
302         )
303         resulting_mode = stat.S_IMODE(name.stat().st_mode)
304         self.assertEqual(oct(desired_mode), oct(resulting_mode))
305         self.assertSaltTrueReturn(ret)
306     def test_managed_file_with_grains_data(self):
307         """
308         Test to ensure we can render grains data into a managed
309         """
310         grain_path = self.tmp_dir / "file-grain-test"
311         self.addCleanup(salt.utils.files<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.safe_rm, str(grain_path))
312         state_file = "file-grainget"
313         self.run_function(
314             "state.sls", [state_file], pillar={"grain_path": str(grain_path)}
315         )
316         self.assertTrue(grain_path.exists())
317         file_contents = grain_path.read_text().splitlines(</b></font>True)
318         match = "^minion\n"
319         self.assertTrue(re.match(match, file_contents[0]))
320     def test_managed_file_with_pillardefault_sls(self):
321         """
322         Test to ensure when pillar data is not available
323         in sls file with pillar.get it uses the default
324         value.
325         """
326         file_pillar_def = os.path.join(RUNTIME_VARS.TMP, "filepillar-defaultvalue")
327         self.addCleanup(self._delete_file, file_pillar_def)
328         state_name = "file-pillardefaultget"
329         log.warning("File Path: %s", file_pillar_def)
330         ret = self.run_function("state.sls", [state_name])
331         self.assertSaltTrueReturn(ret)
332         check_file = self.run_function("file.file_exists", [file_pillar_def])
333         self.assertTrue(check_file)
334     @pytest.mark.skip_if_not_root
335     def test_managed_dir_mode(self):
336         """
337         Tests to ensure that file.managed creates directories with the
338         permissions requested with the dir_mode argument
339         """
340         desired_mode = 511  # 0777 in octal
341         name = self.tmp_dir / "a" / "managed_dir_mode_test_file"
342         self.addCleanup(salt.utils.files.safe_rm, str(name))
343         desired_owner = "nobody"
344         ret = self.run_state(
345             "file.managed",
346             name=str(name),
347             source="salt://grail/scene33",
348             mode=600,
349             makedirs=True,
350             user=desired_owner,
351             dir_mode=oct(desired_mode),  # 0777
352         )
353         if IS_WINDOWS:
354             expected = "The 'mode' option is not supported on Windows"
355             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
356             self.assertSaltFalseReturn(ret)
357             return
358         resulting_mode = stat.S_IMODE(name.parent.stat().st_mode)
359         resulting_owner = pwd.getpwuid(name.parent.stat().st_uid).pw_name
360         self.assertEqual(oct(desired_mode), oct(resulting_mode))
361         self.assertSaltTrueReturn(ret)
362         self.assertEqual(desired_owner, resulting_owner)
363     def test_test_managed(self):
364         """
365         file.managed test interface
366         """
367         name = self.tmp_dir / "grail_not_not_scene33"
368         self.addCleanup(salt.utils.files.safe_rm, str(name))
369         ret = self.run_state(
370             "file.managed", test=True, name=str(name), source="salt://grail/scene33"
371         )
372         self.assertSaltNoneReturn(ret)
373         self.assertFalse(name.is_file())
374     def test_managed_show_changes_false(self):
375         file.managed test interface
376         """
377         name = self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.tmp_dir / "grail_not_scene33"
378         self.addCleanup(salt.utils.files.safe_rm, str(name))
379         name.write_bytes(b"test_managed_show_changes_false\n")
380         ret = self.run_state(
381             "file.managed",
382             name=</b></font>str(name),
383             source="salt://grail/scene33",
384             show_changes=False,
385         )
386         changes = next(iter(ret.values()))["changes"]
387         self.assertEqual("&lt;show_changes=False&gt;", changes["diff"])
388     def test_managed_show_changes_true(self):
389         """
390         file.managed test interface
391         """
392         name = self.tmp_dir / "grail_not_scene33"
393         self.addCleanup(salt.utils.files.safe_rm, str(name))
394         name.write_bytes(b"test_managed_show_changes_false\n")
395         ret = self.run_state(
396             "file.managed",
397             name=str(name),
398             source="salt://grail/scene33",
399         )
400         changes = next(iter(ret.values()))["changes"]
401         self.assertIn("diff", changes)
402     @skipIf(IS_WINDOWS, "Don't know how to fix for Windows")
403     def test_managed_escaped_file_path(self):
404         """
405         file.managed test that 'salt://|' protects unusual characters in file path
406         """
407         funny_file = salt.utils.files.mkstemp(
408             prefix="?f!le? n@=3&amp;", suffix=".file type"
409         )
410         funny_file_name = os.path.split(funny_file)[1]
411         funny_url = "salt://|" + funny_file_name
412         funny_url_path = os.path.join(RUNTIME_VARS.BASE_FILES, funny_file_name)
413         state_name = "funny_file"
414         state_file_name = state_name + ".sls"
415         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_file_name)
416         state_key = "file_|-{0}_|-{0}_|-managed".format(funny_file)
417         self.addCleanup(os.remove, state_file)
418         self.addCleanup(os.remove, funny_file)
419         self.addCleanup(os.remove, funny_url_path)
420         with salt.utils.files.fopen(funny_url_path, "w"):
421             pass
422         with salt.utils.files.fopen(state_file, "w") as fp_:
423             fp_.write(
424                 textwrap.dedent(
425                     """\
426             {}:
427               file.managed:
428                 - source: {}
429                 - makedirs: True
430             """.format(
431                         funny_file, funny_url
432                     )
433                 )
434             )
435         ret = self.run_function("state.sls", [state_name])
436         self.assertTrue(ret[state_key]["result"])
437     def test_managed_contents(self):
438         """
439         test file.managed with contents that is a boolean, string, integer,
440         float, list, and dictionary
441         """
442         state_name = "file-FileTest-test_managed_contents"
443         state_filename = state_name + ".sls"
444         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
445         managed_files = {}
446         state_keys = {}
447         for typ in ("bool", "str", "int", "float", "list", "dict"):
448             managed_files[typ] = salt.utils.files.mkstemp()
449             state_keys[typ] = "file_|-{} file_|-{}_|-managed".format(
450                 typ, managed_files[typ]
451             )
452         try:
453             with salt.utils.files.fopen(state_file, "w") as fd_:
454                 fd_.write(
455                     textwrap.dedent(
456                         """\
457                     bool file:
458                       file.managed:
459                         - name: {bool}
460                         - contents: True
461                     str file:
462                       file.managed:
463                         - name: {str}
464                         - contents: Salt was here.
465                     int file:
466                       file.managed:
467                         - name: {int}
468                         - contents: 340282366920938463463374607431768211456
469                     float file:
470                       file.managed:
471                         - name: {float}
472                         - contents: 1.7518e-45  # gravitational coupling constant
473                     list file:
474                       file.managed:
475                         - name: {list}
476                         - contents: [1, 1, 2, 3, 5, 8, 13]
477                     dict file:
478                       file.managed:
479                         - name: {dict}
480                         - contents:
481                             C: charge
482                             P: parity
483                             T: time
484                     """.format(
485                             **managed_files
486                         )
487                     )
488                 )
489             ret = self.run_function("state.sls", [state_name])
490             self.assertSaltTrueReturn(ret)
491             for typ in state_keys:
492                 self.assertTrue(ret[state_keys[typ]]["result"])
493                 self.assertIn("diff", ret[state_keys[typ]]["changes"])
494         finally:
495             if os.path.exists(state_file):
496                 os.remove(state_file)
497             for typ in managed_files:
498                 if os.path.exists(managed_files[typ]):
499                     os.remove(managed_files[typ])
500     def test_onchanges_any_recursive_error_issues_50811(self):
501         """
502         test that onchanges_any does not causes a recursive error
503         """
504         state_name = "onchanges_any_recursive_error"
505         state_filename = state_name + ".sls"
506         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
507         try:
508             with salt.utils.files.fopen(state_file, "w") as fd_:
509                 fd_.write(
510                     textwrap.dedent(
511                         """\
512                     command-test:
513                       cmd.run:
514                           - name: ls
515                           - onchanges_any:
516                             - file: /tmp/an-unfollowed-file
517                     """
518                     )
519                 )
520             ret = self.run_function("state.sls", [state_name])
521             self.assertSaltFalseReturn(ret)
522         finally:
523             if os.path.exists(state_file):
524                 os.remove(state_file)
525     def test_prerequired_issues_55775(self):
526         """
527         Test that __prereqired__ is filter from file.replace
528         if __prereqired__ is not filter from file.replace an error will be raised
529         """
530         state_name = "Test_Issues_55775"
531         state_filename = state_name + ".sls"
532         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
533         test_file = os.path.join(RUNTIME_VARS.BASE_FILES, "Issues_55775.txt")
534         try:
535             with salt.utils.files.fopen(state_file, "w") as fd_:
536                 fd_.write(
537                     textwrap.dedent(
538                         """\
539                     /tmp/bug.txt:
540                       file.managed:
541                         - name: {0}
542                         - contents:
543                           - foo
544                     file.replace:
545                       file.replace:
546                         - name: {0}
547                         - pattern: 'foo'
548                         - repl: 'bar'
549                         - prereq:
550                           - test no changes
551                           - test changes
552                     test no changes:
553                       test.succeed_without_changes:
554                         - name: no changes
555                     test changes:
556                       test.succeed_with_changes:
557                         - name: changes
558                         - require:
559                           - test: test no changes
560                     """.format(
561                             test_file
562                         )
563                     )
564                 )
565             ret = self.run_function("state.sls", [state_name])
566             self.assertSaltTrueReturn(ret)
567         finally:
568             for fpath in (state_file, test_file):
569                 if os.path.exists(fpath):
570                     os.remove(fpath)
571     def test_managed_contents_with_contents_newline(self):
572         """
573         test file.managed with contents by using the default content_newline
574         flag.
575         """
576         contents = "test_managed_contents_with_newline_one"
577         name = self.tmp_dir / "foo"
578         self.addCleanup(salt.utils.files.safe_rm, str(name))
579         self.run_state(
580             "file.managed", name=str(name), contents=contents, contents_newline=True
581         )
582         last_line = name.read_text()
583         self.assertEqual((contents + "\n"), last_line)
584     def test_managed_contents_with_contents_newline_false(self):
585         """
586         test file.managed with contents by using the non default content_newline
587         flag.
588         """
589         contents = "test_managed_contents_with_newline_one"
590         name = self.tmp_dir / "bar"
591         self.addCleanup(salt.utils.files.safe_rm, str(name))
592         self.run_state(
593             "file.managed", name=str(name), contents=contents, contents_newline=False
594         )
595         last_line = name.read_text()
596         self.assertEqual(contents, last_line)
597     def test_managed_multiline_contents_with_contents_newline(self):
598         """
599         test file.managed with contents by using the non default content_newline
600         flag.
601         """
602         contents = "this is a cookie\nthis is another cookie"
603         name = self.tmp_dir / "bar"
604         self.addCleanup(salt.utils.files.safe_rm, str(name))
605         self.run_state(
606             "file.managed", name=str(name), contents=contents, contents_newline=True
607         )
608         last_line = name.read_text()
609         self.assertEqual((contents + "\n"), last_line)
610     def test_managed_multiline_contents_with_contents_newline_false(self):
611         """
612         test file.managed with contents by using the non default content_newline
613         flag.
614         """
615         contents = "this is a cookie\nthis is another cookie"
616         name = self.tmp_dir / "bar"
617         self.addCleanup(salt.utils.files.safe_rm, str(name))
618         self.run_state(
619             "file.managed", name=str(name), contents=contents, contents_newline=False
620         )
621         last_line = name.read_text()
622         self.assertEqual(contents, last_line)
623     @pytest.mark.skip_if_not_root
624     @skipIf(IS_WINDOWS, 'Windows does not support "mode" kwarg. Skipping.')
625     @skipIf(not salt.utils.path.which("visudo"), "sudo is missing")
626     def test_managed_check_cmd(self):
627         """
628         Test file.managed passing a basic check_cmd kwarg. See Issue #38111.
629         """
630         r_group = "root"
631         if salt.utils.platform.is_darwin() or salt.utils.platform.is_freebsd():
632             r_group = "wheel"
633         name = self.tmp_dir / "sudoers"
634         self.addCleanup(salt.utils.files.safe_rm, str(name))
635         ret = self.run_state(
636             "file.managed",
637             name=str(name),
638             user="root",
639             group=r_group,
640             mode=440,
641             check_cmd="visudo -c -s -f",
642         )
643         self.assertSaltTrueReturn(ret)
644         self.assertInSaltComment("Empty file", ret)
645         self.assertEqual(
646             ret["file_|-{0}_|-{0}_|-managed".format(name)]["changes"],
647             {"new": "file {} created".format(name), "mode": "0440"},
648         )
649     def test_managed_local_source_with_source_hash(self):
650         """
651         Make sure that we enforce the source_hash even with local files
652         """
653         name = self.tmp_dir / "local_source_with_source_hash"
654         self.addCleanup(salt.utils.files.safe_rm, str(name))
655         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
656         actual_hash = "567fd840bf1548edc35c48eb66cdd78bfdfcccff"
657         if IS_WINDOWS:
658             actual_hash = "f658a0ec121d9c17088795afcc6ff3c43cb9842a"
659         bad_hash = actual_hash[::-1]
660         def remove_file():
661             try:
662                 os.remove(str(name))
663             except OSError as exc:
664                 if exc.errno != errno.ENOENT:
665                     raise
666         def do_test(clean=False):
667             for proto in ("file://", ""):
668                 source = proto + local_path
669                 log.debug("Trying source %s", source)
670                 try:
671                     ret = self.run_state(
672                         "file.managed",
673                         name=str(name),
674                         source=source,
675                         source_hash="sha1={}".format(bad_hash),
676                     )
677                     self.assertSaltFalseReturn(ret)
678                     ret = ret[next(iter(ret))]
679                     self.assertFalse(ret["changes"])
680                     self.assertIn("does not match actual checksum", ret["comment"])
681                     ret = self.run_state(
682                         "file.managed",
683                         name=str(name),
684                         source=source,
685                         source_hash="sha1={}".format(actual_hash),
686                     )
687                     self.assertSaltTrueReturn(ret)
688                 finally:
689                     if clean:
690                         remove_file()
691         remove_file()
692         log.debug("Trying with nonexistant destination file")
693         do_test()
694         log.debug("Trying with destination file already present")
695         name.write_text("")
696         try:
697             do_test(clean=False)
698         finally:
699             remove_file()
700     def test_managed_local_source_does_not_exist(self):
701         """
702         Make sure that we exit gracefully when a local source doesn't exist
703         """
704         name = self.tmp_dir / "local_source_does_not_exist"
705         self.addCleanup(salt.utils.files.safe_rm, str(name))
706         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene99")
707         for proto in ("file://", ""):
708             source = proto + local_path
709             log.debug("Trying source %s", source)
710             ret = self.run_state("file.managed", name=str(name), source=source)
711             self.assertSaltFalseReturn(ret)
712             ret = ret[next(iter(ret))]
713             self.assertFalse(ret["changes"])
714             self.assertIn("does not exist", ret["comment"])
715     def test_managed_unicode_jinja_with_tojson_filter(self):
716         """
717         Using {{ varname }} with a list or dictionary which contains unicode
718         types on Python 2 will result in Jinja rendering the "u" prefix on each
719         string. This tests that using the "tojson" jinja filter will dump them
720         to a format which can be successfully loaded by our YAML loader.
721         The two lines that should end up being rendered are meant to test two
722         issues that would trip up PyYAML if the "tojson" filter were not used:
723         1. A unicode string type would be loaded as a unicode literal with the
724            leading "u" as well as the quotes, rather than simply being loaded
725            as the proper unicode type which matches the content of the string
726            literal. In other words, u'foo' would be loaded literally as
727            u"u'foo'". This test includes actual non-ascii unicode in one of the
728            strings to confirm that this also handles these international
729            characters properly.
730         2. Any unicode string type (such as a URL) which contains a colon would
731            cause a ScannerError in PyYAML, as it would be assumed to delimit a
732            mapping node.
733         Dumping the data structure to JSON using the "tojson" jinja filter
734         should produce an inline data structure which is valid YAML and will be
735         loaded properly by our YAML loader.
736         """
737         test_file = self.tmp_dir / "test-tojson.txt"
738         self.addCleanup(salt.utils.files.safe_rm, str(test_file))
739         ret = self.run_function(
740             "state.apply", mods="tojson", pillar={"tojson-file": str(test_file)}
741         )
742         ret = ret[next(iter(ret))]
743         assert ret["result"], ret
744         managed = salt.utils.stringutils.to_unicode(test_file.read_bytes())
745         expected = dedent(
746             """\
747             Die Webseite ist https://saltproject.io.
748             Der Zucker ist süß.
749             """
750         )
751         assert managed == expected, "{!r} != {!r}".format(managed, expected)
752     def test_managed_source_hash_indifferent_case(self):
753         """
754         Test passing a source_hash as an uppercase hash.
755         This is a regression test for Issue #38914 and Issue #48230 (test=true use).
756         """
757         name = self.tmp_dir / "source_hash_indifferent_case"
758         self.addCleanup(salt.utils.files.safe_rm, str(name))
759         state_name = "file_|-{0}_|-{0}_|-managed".format(name)
760         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "hello_world.txt")
761         actual_hash = "c98c24b677eff44860afea6f493bbaec5bb1c4cbb209c6fc2bbb47f66ff2ad31"
762         if IS_WINDOWS:
763             actual_hash = (
764                 "92b772380a3f8e27a93e57e6deeca6c01da07f5aadce78bb2fbb20de10a66925"
765             )
766         uppercase_hash = actual_hash.upper()
767         self.run_state(
768             "file.managed", name=str(name), source=local_path, source_hash=actual_hash
769         )
770         ret = self.run_state(
771             "file.managed",
772             name=str(name),
773             source=local_path,
774             source_hash=uppercase_hash,
775         )
776         assert ret[state_name]["result"] is True
777         assert ret[state_name]["changes"] == {}
778         ret = self.run_state(
779             "file.managed",
780             name=str(name),
781             source=local_path,
782             source_hash=uppercase_hash,
783             test=True,
784         )
785         assert ret[state_name]["result"] is True
786         assert ret[state_name]["changes"] == {}
787     @with_tempfile(create=False)
788     def test_managed_latin1_diff(self, name):
789         """
790         Tests that latin-1 file contents are represented properly in the diff
791         """
792         ret = self.run_state(
793             "file.managed", name=name, source="salt://issue-48777/old.html"
794         )
795         ret = ret[next(iter(ret))]
796         assert ret["result"] is True, ret
797         ret = self.run_state(
798             "file.managed", name=name, source="salt://issue-48777/new.html"
799         )
800         ret = ret[next(iter(ret))]
801         assert ret["result"] is True, ret
802         diff_lines = ret["changes"]["diff"].split(os.linesep)
803         assert "+räksmörgås" in diff_lines, diff_lines
804     @with_tempfile()
805     def test_managed_keep_source_false_salt(self, name):
806         """
807         This test ensures that we properly clean the cached file if keep_source
808         is set to False, for source files using a salt:// URL
809         """
810         source = "salt://grail/scene33"
811         saltenv = "base"
812         ret = self.run_state(
813             "file.managed", name=name, source=source, saltenv=saltenv, keep_source=False
814         )
815         ret = ret[next(iter(ret))]
816         assert ret["result"] is True
817         result = self.run_function("cp.is_cached", [source, saltenv])
818         assert result == "", "File is still cached at {}".format(result)
819     @with_tempfile(create=False)
820     @with_tempfile(create=False)
821     def test_file_managed_onchanges(self, file1, file2):
822         """
823         Test file.managed state with onchanges
824         """
825         pillar = {
826             "file1": file1,
827             "file2": file2,
828             "source": "salt://testfile",
829             "req": "onchanges",
830         }
831         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
832         ret = self.repack_state_returns(
833             self.run_function(
834                 "state.apply",
835                 mods="onchanges_prereq",
836                 pillar=pillar,
837                 test=True,
838             )
839         )
840         assert ret["one"]["result"] is None, ret["one"]["result"]
841         assert ret["three"]["result"] is True, ret["three"]["result"]
842         assert ret["one"]["changes"]
843         assert not ret["three"]["changes"], ret["three"]["changes"]
844         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
845         assert (
846             ret["four"]["comment"]
847             == "State was not run because none of the onchanges reqs changed"
848         ), ret["four"]["comment"]
849     @with_tempfile(create=False)
850     @with_tempfile(create=False)
851     def test_file_managed_prereq(self, file1, file2):
852         """
853         Test file.managed state with prereq
854         """
855         pillar = {
856             "file1": file1,
857             "file2": file2,
858             "source": "salt://testfile",
859             "req": "prereq",
860         }
861         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
862         ret = self.repack_state_returns(
863             self.run_function(
864                 "state.apply",
865                 mods="onchanges_prereq",
866                 pillar=pillar,
867                 test=True,
868             )
869         )
870         assert ret["one"]["result"] is None, ret["one"]["result"]
871         assert ret["three"]["result"] is True, ret["three"]["result"]
872         assert ret["one"]["changes"]
873         assert not ret["three"]["changes"], ret["three"]["changes"]
874         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
875         assert ret["four"]["comment"] == "No changes detected", ret["four"]["comment"]
876     def test_directory(self):
877         """
878         file.directory
879         """
880         name = self.tmp_dir / "a_new_dir"
881         self.addCleanup(salt.utils.files.rm_rf, str(name))
882         ret = self.run_state("file.directory", name=str(name))
883         self.assertSaltTrueReturn(ret)
884         self.assertTrue(name.is_dir())
885     def test_directory_symlink_dry_run(self):
886         """
887         Ensure that symlinks are followed when file.directory is run with
888         test=True
889         """
890         tmp_dir = self.tmp_dir / "pgdata"
891         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
892         sym_dir = self.tmp_dir / "pg_data"
893         self.addCleanup(salt.utils.files.safe_rm, str(sym_dir))
894         tmp_dir.mkdir(0o0700)
895         sym_dir.symlink_to(tmp_dir, target_is_directory=IS_WINDOWS)
896         if IS_WINDOWS:
897             ret = self.run_state(
898                 "file.directory",
899                 test=True,
900                 name=str(sym_dir),
901                 follow_symlinks=True,
902                 win_owner="Administrators",
903             )
904         else:
905             ret = self.run_state(
906                 "file.directory",
907                 test=True,
908                 name=str(sym_dir),
909                 follow_symlinks=True,
910                 mode=700,
911             )
912         self.assertSaltTrueReturn(ret)
913     @requires_system_grains
914     @pytest.mark.skip_if_not_root
915     @skipIf(IS_WINDOWS, "Mode not available in Windows")
916     def test_directory_max_depth(self, grains):
917         """
918         file.directory
919         Test the max_depth option by iteratively increasing the depth and
920         checking that no changes deeper than max_depth have been attempted
921         """
922         def _get_oct_mode(name):
923             """
924             Return a string octal representation of the permissions for name
925             """
926             return salt.utils.files.normalize_mode(oct(os.stat(name).st_mode &amp; 0o777))
927         top = os.path.join(RUNTIME_VARS.TMP, "top_dir")
928         self.addCleanup(salt.utils.files.rm_rf, top)
929         sub = os.path.join(top, "sub_dir")
930         subsub = os.path.join(sub, "sub_sub_dir")
931         dirs = [top, sub, subsub]
932         initial_mode = "0111"
933         changed_mode = "0555"
934         if grains["os"] in ("VMware Photon OS",):
935             initial_modes = {
936                 0: {sub: "0750", subsub: "0110"},
937                 1: {sub: "0110", subsub: "0110"},
938                 2: {sub: "0110", subsub: "0110"},
939             }
940         else:
941             initial_modes = {
942                 0: {sub: "0755", subsub: "0111"},
943                 1: {sub: "0111", subsub: "0111"},
944                 2: {sub: "0111", subsub: "0111"},
945             }
946         if not os.path.isdir(subsub):
947             os.makedirs(subsub, int(initial_mode, 8))
948         for depth in range(0, 3):
949             ret = self.run_state(
950                 "file.directory",
951                 name=top,
952                 max_depth=depth,
953                 dir_mode=changed_mode,
954                 recurse=["mode"],
955             )
956             self.assertSaltTrueReturn(ret)
957             for changed_dir in dirs[0 : depth + 1]:
958                 self.assertEqual(changed_mode, _get_oct_mode(changed_dir))
959             for untouched_dir in dirs[depth + 1 :]:
960                 if sys.version_info &gt;= (3, 7):
961                     _mode = initial_modes[depth][untouched_dir]
962                     self.assertEqual(_mode, _get_oct_mode(untouched_dir))
963                 else:
964                     self.assertEqual(initial_mode, _get_oct_mode(untouched_dir))
965     def test_test_directory(self):
966         """
967         file.directory
968         """
969         name = self.tmp_dir / "a_not_dir"
970         self.addCleanup(shutil.rmtree, str(name), ignore_errors=True)
971         ret = self.run_state("file.directory", test=True, name=str(name))
972         self.assertSaltNoneReturn(ret)
973         self.assertFalse(name.is_dir())
974     @with_tempdir()
975     def test_directory_clean(self, base_dir):
976         """
977         file.directory with clean=True
978         """
979         name = os.path.join(base_dir, "directory_clean_dir")
980         os.mkdir(name)
981         strayfile = os.path.join(name, "strayfile")
982         with salt.utils.files.fopen(strayfile, "w"):
983             pass
984         straydir = os.path.join(name, "straydir")
985         if not os.path.isdir(straydir):
986             os.makedirs(straydir)
987         with salt.utils.files.fopen(os.path.join(straydir, "strayfile2"), "w"):
988             pass
989         ret = self.run_state("file.directory", name=name, clean=True)
990         self.assertSaltTrueReturn(ret)
991         self.assertFalse(os.path.exists(strayfile))
992         self.assertFalse(os.path.exists(straydir))
993         self.assertTrue(os.path.isdir(name))
994     def test_directory_is_idempotent(self):
995         """
996         Ensure the file.directory state produces no changes when rerun.
997         """
998         name = self.tmp_dir / "a_dir_twice"
999         self.addCleanup(salt.utils.files.rm_rf, str(name))
1000         if IS_WINDOWS:
1001             username = os.environ.get("USERNAME", "Administrators")
1002             domain = os.environ.get("USERDOMAIN", "")
1003             fullname = "{}\\{}".format(domain, username)
1004             ret = self.run_state("file.directory", name=str(name), win_owner=fullname)
1005         else:
1006             ret = self.run_state("file.directory", name=str(name))
1007         self.assertSaltTrueReturn(ret)
1008         if IS_WINDOWS:
1009             ret = self.run_state("file.directory", name=str(name), win_owner=username)
1010         else:
1011             ret = self.run_state("file.directory", name=str(name))
1012         self.assertSaltTrueReturn(ret)
1013         self.assertSaltStateChangesEqual(ret, {})
1014     @with_tempdir()
1015     def test_directory_clean_exclude(self, base_dir):
1016         """
1017         file.directory with clean=True and exclude_pat set
1018         """
1019         name = os.path.join(base_dir, "directory_clean_dir")
1020         if not os.path.isdir(name):
1021             os.makedirs(name)
1022         strayfile = os.path.join(name, "strayfile")
1023         with salt.utils.files.fopen(strayfile, "w"):
1024             pass
1025         straydir = os.path.join(name, "straydir")
1026         if not os.path.isdir(straydir):
1027             os.makedirs(straydir)
1028         strayfile2 = os.path.join(straydir, "strayfile2")
1029         with salt.utils.files.fopen(strayfile2, "w"):
1030             pass
1031         keepfile = os.path.join(straydir, "keepfile")
1032         with salt.utils.files.fopen(keepfile, "w"):
1033             pass
1034         exclude_pat = "E@^straydir(|/keepfile)$"
1035         if IS_WINDOWS:
1036             exclude_pat = "E@^straydir(|\\\\keepfile)$"
1037         ret = self.run_state(
1038             "file.directory", name=name, clean=True, exclude_pat=exclude_pat
1039         )
1040         self.assertSaltTrueReturn(ret)
1041         self.assertFalse(os.path.exists(strayfile))
1042         self.assertFalse(os.path.exists(strayfile2))
1043         self.assertTrue(os.path.exists(keepfile))
1044     @skipIf(IS_WINDOWS, "Skip on windows")
1045     @with_tempdir()
1046     def test_test_directory_clean_exclude(self, base_dir):
1047         """
1048         file.directory with test=True, clean=True and exclude_pat set
1049         Skipped on windows because clean and exclude_pat not supported by
1050         salt.sates.file._check_directory_win
1051         """
1052         name = os.path.join(base_dir, "directory_clean_dir")
1053         os.mkdir(name)
1054         strayfile = os.path.join(name, "strayfile")
1055         with salt.utils.files.fopen(strayfile, "w"):
1056             pass
1057         straydir = os.path.join(name, "straydir")
1058         if not os.path.isdir(straydir):
1059             os.makedirs(straydir)
1060         strayfile2 = os.path.join(straydir, "strayfile2")
1061         with salt.utils.files.fopen(strayfile2, "w"):
1062             pass
1063         keepfile = os.path.join(straydir, "keepfile")
1064         with salt.utils.files.fopen(keepfile, "w"):
1065             pass
1066         exclude_pat = "E@^straydir(|/keepfile)$"
1067         if IS_WINDOWS:
1068             exclude_pat = "E@^straydir(|\\\\keepfile)$"
1069         ret = self.run_state(
1070             "file.directory", test=True, name=name, clean=True, exclude_pat=exclude_pat
1071         )
1072         comment = next(iter(ret.values()))["comment"]
1073         self.assertSaltNoneReturn(ret)
1074         self.assertTrue(os.path.exists(strayfile))
1075         self.assertTrue(os.path.exists(strayfile2))
1076         self.assertTrue(os.path.exists(keepfile))
1077         self.assertIn(strayfile, comment)
1078         self.assertIn(strayfile2, comment)
1079         self.assertNotIn(keepfile, comment)
1080     @with_tempdir()
1081     def test_directory_clean_require_in(self, name):
1082         """
1083         file.directory test with clean=True and require_in file
1084         """
1085         state_name = "file-FileTest-test_directory_clean_require_in"
1086         state_filename = state_name + ".sls"
1087         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1088         wrong_file = os.path.join(name, "wrong")
1089         with salt.utils.files.fopen(wrong_file, "w") as fp:
1090             fp.write("foo")
1091         good_file = os.path.join(name, "bar")
1092         with salt.utils.files.fopen(state_file, "w") as fp:
1093             self.addCleanup(salt.utils.files.safe_rm, state_file)
1094             fp.write(
1095                 textwrap.dedent(
1096                     """\
1097                 some_dir:
1098                   file.directory:
1099                     - name: {name}
1100                     - clean: true
1101                 {good_file}:
1102                   file.managed:
1103                     - require_in:
1104                       - file: some_dir
1105                 """.format(
1106                         name=name, good_file=good_file
1107                     )
1108                 )
1109             )
1110         ret = self.run_function("state.sls", [state_name])
1111         self.assertTrue(os.path.exists(good_file))
1112         self.assertFalse(os.path.exists(wrong_file))
1113     @with_tempdir()
1114     def test_directory_clean_require_in_with_id(self, name):
1115         """
1116         file.directory test with clean=True and require_in file with an ID
1117         different from the file name
1118         """
1119         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
1120         state_filename = state_name + ".sls"
1121         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1122         wrong_file = os.path.join(name, "wrong")
1123         with salt.utils.files.fopen(wrong_file, "w") as fp:
1124             fp.write("foo")
1125         good_file = os.path.join(name, "bar")
1126         with salt.utils.files.fopen(state_file, "w") as fp:
1127             self.addCleanup(salt.utils.files.safe_rm, state_file)
1128             fp.write(
1129                 textwrap.dedent(
1130                     """\
1131                 some_dir:
1132                   file.directory:
1133                     - name: {name}
1134                     - clean: true
1135                 some_file:
1136                   file.managed:
1137                     - name: {good_file}
1138                     - require_in:
1139                       - file: some_dir
1140                 """.format(
1141                         name=name, good_file=good_file
1142                     )
1143                 )
1144             )
1145         ret = self.run_function("state.sls", [state_name])
1146         self.assertTrue(os.path.exists(good_file))
1147         self.assertFalse(os.path.exists(wrong_file))
1148     @skipIf(
1149         salt.utils.platform.is_darwin(),
1150         "WAR ROOM TEMPORARY SKIP, Test is flaky on macosx",
1151     )
1152     @with_tempdir()
1153     def test_directory_clean_require_with_name(self, name):
1154         """
1155         file.directory test with clean=True and require with a file state
1156         relatively to the state's name, not its ID.
1157         """
1158         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
1159         state_filename = state_name + ".sls"
1160         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1161         wrong_file = os.path.join(name, "wrong")
1162         with salt.utils.files.fopen(wrong_file, "w") as fp:
1163             fp.write("foo")
1164         good_file = os.path.join(name, "bar")
1165         with salt.utils.files.fopen(state_file, "w") as fp:
1166             self.addCleanup(salt.utils.files.safe_rm, state_file)
1167             fp.write(
1168                 textwrap.dedent(
1169                     """\
1170                 some_dir:
1171                   file.directory:
1172                     - name: {name}
1173                     - clean: true
1174                     - require:
1175                       - file: {good_file}
1176                 some_file:
1177                   file.managed:
1178                     - name: {good_file}
1179                 """.format(
1180                         name=name, good_file=good_file
1181                     )
1182                 )
1183             )
1184         ret = self.run_function("state.sls", [state_name])
1185         self.assertTrue(os.path.exists(good_file))
1186         self.assertFalse(os.path.exists(wrong_file))
1187     def test_directory_broken_symlink(self):
1188         """
1189         Ensure that file.directory works even if a directory
1190         contains broken symbolic link
1191         """
1192         tmp_dir = self.tmp_dir / "foo"
1193         tmp_dir.mkdir(0o700)
1194         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
1195         null_file = tmp_dir / "null"
1196         broken_link = tmp_dir / "broken"
1197         broken_link.symlink_to(null_file)
1198         if IS_WINDOWS:
1199             ret = self.run_state(
1200                 "file.directory",
1201                 name=str(tmp_dir),
1202                 recurse=["mode"],
1203                 follow_symlinks=True,
1204                 win_owner="Administrators",
1205             )
1206         else:
1207             ret = self.run_state(
1208                 "file.directory",
1209                 name=str(tmp_dir),
1210                 recurse=["mode"],
1211                 file_mode=644,
1212                 dir_mode=755,
1213             )
1214         self.assertSaltTrueReturn(ret)
1215     @with_tempdir(create=False)
1216     def test_recurse(self, name):
1217         """
1218         file.recurse
1219         """
1220         ret = self.run_state("file.recurse", name=name, source="salt://grail")
1221         self.assertSaltTrueReturn(ret)
1222         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1223     @with_tempdir(create=False)
1224     @with_tempdir(create=False)
1225     def test_recurse_specific_env(self, dir1, dir2):
1226         """
1227         file.recurse passing __env__
1228         """
1229         ret = self.run_state(
1230             "file.recurse", name=dir1, source="salt://holy", __env__="prod"
1231         )
1232         self.assertSaltTrueReturn(ret)
1233         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
1234         ret = self.run_state(
1235             "file.recurse", name=dir2, source="salt://holy", saltenv="prod"
1236         )
1237         self.assertSaltTrueReturn(ret)
1238         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
1239     @with_tempdir(create=False)
1240     @with_tempdir(create=False)
1241     def test_recurse_specific_env_in_url(self, dir1, dir2):
1242         """
1243         file.recurse passing __env__
1244         """
1245         ret = self.run_state(
1246             "file.recurse", name=dir1, source="salt://holy?saltenv=prod"
1247         )
1248         self.assertSaltTrueReturn(ret)
1249         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
1250         ret = self.run_state(
1251             "file.recurse", name=dir2, source="salt://holy?saltenv=prod"
1252         )
1253         self.assertSaltTrueReturn(ret)
1254         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
1255     @with_tempdir(create=False)
1256     def test_test_recurse(self, name):
1257         """
1258         file.recurse test interface
1259         """
1260         ret = self.run_state(
1261             "file.recurse",
1262             test=True,
1263             name=name,
1264             source="salt://grail",
1265         )
1266         self.assertSaltNoneReturn(ret)
1267         self.assertFalse(os.path.isfile(os.path.join(name, "36", "scene")))
1268         self.assertFalse(os.path.exists(name))
1269     @with_tempdir(create=False)
1270     @with_tempdir(create=False)
1271     def test_test_recurse_specific_env(self, dir1, dir2):
1272         """
1273         file.recurse test interface
1274         """
1275         ret = self.run_state(
1276             "file.recurse", test=True, name=dir1, source="salt://holy", __env__="prod"
1277         )
1278         self.assertSaltNoneReturn(ret)
1279         self.assertFalse(os.path.isfile(os.path.join(dir1, "32", "scene")))
1280         self.assertFalse(os.path.exists(dir1))
1281         ret = self.run_state(
1282             "file.recurse", test=True, name=dir2, source="salt://holy", saltenv="prod"
1283         )
1284         self.assertSaltNoneReturn(ret)
1285         self.assertFalse(os.path.isfile(os.path.join(dir2, "32", "scene")))
1286         self.assertFalse(os.path.exists(dir2))
1287     @with_tempdir(create=False)
1288     def test_recurse_template(self, name):
1289         """
1290         file.recurse with jinja template enabled
1291         """
1292         _ts = "TEMPLATE TEST STRING"
1293         ret = self.run_state(
1294             "file.recurse",
1295             name=name,
1296             source="salt://grail",
1297             template="jinja",
1298             defaults={"spam": _ts},
1299         )
1300         self.assertSaltTrueReturn(ret)
1301         with salt.utils.files.fopen(os.path.join(name, "scene33"), "r") as fp_:
1302             contents = fp_.read()
1303         self.assertIn(_ts, contents)
1304     @with_tempdir()
1305     def test_recurse_clean(self, name):
1306         """
1307         file.recurse with clean=True
1308         """
1309         strayfile = os.path.join(name, "strayfile")
1310         with salt.utils.files.fopen(strayfile, "w"):
1311             pass
1312         with salt.utils.files.fopen(os.path.join(name, "36"), "w"):
1313             pass
1314         os.makedirs(os.path.join(name, "scene33"))
1315         ret = self.run_state(
1316             "file.recurse", name=name, source="salt://grail", clean=True
1317         )
1318         self.assertSaltTrueReturn(ret)
1319         self.assertFalse(os.path.exists(strayfile))
1320         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1321         self.assertTrue(os.path.isfile(os.path.join(name, "scene33")))
1322     @with_tempdir()
1323     def test_recurse_clean_specific_env(self, name):
1324         """
1325         file.recurse with clean=True and __env__=prod
1326         """
1327         strayfile = os.path.join(name, "strayfile")
1328         with salt.utils.files.fopen(strayfile, "w"):
1329             pass
1330         with salt.utils.files.fopen(os.path.join(name, "32"), "w"):
1331             pass
1332         os.makedirs(os.path.join(name, "scene34"))
1333         ret = self.run_state(
1334             "file.recurse", name=name, source="salt://holy", clean=True, __env__="prod"
1335         )
1336         self.assertSaltTrueReturn(ret)
1337         self.assertFalse(os.path.exists(strayfile))
1338         self.assertTrue(os.path.isfile(os.path.join(name, "32", "scene")))
1339         self.assertTrue(os.path.isfile(os.path.join(name, "scene34")))
1340     @skipIf(IS_WINDOWS, "Skip on windows")
1341     @with_tempdir()
1342     def test_recurse_issue_34945(self, base_dir):
1343         """
1344         This tests the case where the source dir for the file.recurse state
1345         does not contain any files (only subdirectories), and the dir_mode is
1346         being managed. For a long time, this corner case resulted in the top
1347         level of the destination directory being created with the wrong initial
1348         permissions, a problem that would be corrected later on in the
1349         file.recurse state via running state.directory. However, the
1350         file.directory state only gets called when there are files to be
1351         managed in that directory, and when the source directory contains only
1352         subdirectories, the incorrectly-set initial perms would not be
1353         repaired.
1354         This was fixed in https://github.com/saltstack/salt/pull/35309
1355         Skipped on windows because dir_mode is not supported.
1356         """
1357         dir_mode = "2775"
1358         issue_dir = "issue-34945"
1359         name = os.path.join(base_dir, issue_dir)
1360         ret = self.run_state(
1361             "file.recurse", name=name, source="salt://" + issue_dir, dir_mode=dir_mode
1362         )
1363         self.assertSaltTrueReturn(ret)
1364         actual_dir_mode = oct(stat.S_IMODE(os.stat(name).st_mode))[-4:]
1365         self.assertEqual(dir_mode, actual_dir_mode)
1366     @with_tempdir(create=False)
1367     def test_recurse_issue_40578(self, name):
1368         """
1369         This ensures that the state doesn't raise an exception when it
1370         encounters a file with a unicode filename in the process of invoking
1371         file.source_list.
1372         """
1373         ret = self.run_state("file.recurse", name=name, source="salt://соль")
1374         self.assertSaltTrueReturn(ret)
1375         files = salt.utils.data.decode(os.listdir(name), normalize=True)
1376         self.assertEqual(
1377             sorted(files),
1378             sorted(["foo.txt", "спам.txt", "яйца.txt"]),
1379         )
1380     @with_tempfile()
1381     def test_replace(self, name):
1382         """
1383         file.replace
1384         """
1385         with salt.utils.files.fopen(name, "w+") as fp_:
1386             fp_.write("change_me")
1387         ret = self.run_state(
1388             "file.replace", name=name, pattern="change", repl="salt", backup=False
1389         )
1390         with salt.utils.files.fopen(name, "r") as fp_:
1391             self.assertIn("salt", fp_.read())
1392         self.assertSaltTrueReturn(ret)
1393     @with_tempdir()
1394     def test_replace_issue_18612(self, base_dir):
1395         """
1396         Test the (mis-)behaviour of file.replace as described in #18612:
1397         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1398         an infinitely growing file as 'file.replace' didn't check beforehand
1399         whether the changes had already been done to the file
1400         The tested file contains one commented line
1401         The commented line should be uncommented in the end, nothing else should change
1402         """
1403         test_name = "test_replace_issue_18612"
1404         path_test = os.path.join(base_dir, test_name)
1405         with salt.utils.files.fopen(path_test, "w+") as fp_test_:
1406             fp_test_.write("# en_US.UTF-8")
1407         ret = []
1408         for x in range(0, 3):
1409             ret.append(
1410                 self.run_state(
1411                     "file.replace",
1412                     name=path_test,
1413                     pattern="^# en_US.UTF-8$",
1414                     repl="en_US.UTF-8",
1415                     append_if_not_found=True,
1416                 )
1417             )
1418         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1419             self.assertTrue(sum(1 for _ in fp_test_) == 1)
1420         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1421             self.assertTrue(fp_test_.read().startswith("en_US.UTF-8"))
1422         for item in ret:
1423             self.assertSaltTrueReturn(item)
1424     @with_tempdir()
1425     def test_replace_issue_18612_prepend(self, base_dir):
1426         """
1427         Test the (mis-)behaviour of file.replace as described in #18612:
1428         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1429         an infinitely growing file as 'file.replace' didn't check beforehand
1430         whether the changes had already been done to the file
1431         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1432         The replacement pattern should be prepended to the file
1433         """
1434         test_name = "test_replace_issue_18612_prepend"
1435         path_in = os.path.join(
1436             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1437         )
1438         path_out = os.path.join(
1439             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1440         )
1441         path_test = os.path.join(base_dir, test_name)
1442         shutil.copyfile(path_in, path_test)
1443         ret = []
1444         for x in range(0, 3):
1445             ret.append(
1446                 self.run_state(
1447                     "file.replace",
1448                     name=path_test,
1449                     pattern="^# en_US.UTF-8$",
1450                     repl="en_US.UTF-8",
1451                     prepend_if_not_found=True,
1452                 )
1453             )
1454         self.assertTrue(filecmp.cmp(path_test, path_out))
1455         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1456         for item in ret:
1457             self.assertSaltTrueReturn(item)
1458     @with_tempdir()
1459     def test_replace_issue_18612_append(self, base_dir):
1460         """
1461         Test the (mis-)behaviour of file.replace as described in #18612:
1462         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1463         an infinitely growing file as 'file.replace' didn't check beforehand
1464         whether the changes had already been done to the file
1465         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1466         The replacement pattern should be appended to the file
1467         """
1468         test_name = "test_replace_issue_18612_append"
1469         path_in = os.path.join(
1470             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1471         )
1472         path_out = os.path.join(
1473             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1474         )
1475         path_test = os.path.join(base_dir, test_name)
1476         shutil.copyfile(path_in, path_test)
1477         ret = []
1478         for x in range(0, 3):
1479             ret.append(
1480                 self.run_state(
1481                     "file.replace",
1482                     name=path_test,
1483                     pattern="^# en_US.UTF-8$",
1484                     repl="en_US.UTF-8",
1485                     append_if_not_found=True,
1486                 )
1487             )
1488         self.assertTrue(filecmp.cmp(path_test, path_out))
1489         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1490         for item in ret:
1491             self.assertSaltTrueReturn(item)
1492     @with_tempdir()
1493     def test_replace_issue_18612_append_not_found_content(self, base_dir):
1494         """
1495         Test the (mis-)behaviour of file.replace as described in #18612:
1496         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1497         an infinitely growing file as 'file.replace' didn't check beforehand
1498         whether the changes had already been done to the file
1499         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1500         The 'not_found_content' value should be appended to the file
1501         """
1502         test_name = "test_replace_issue_18612_append_not_found_content"
1503         path_in = os.path.join(
1504             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1505         )
1506         path_out = os.path.join(
1507             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1508         )
1509         path_test = os.path.join(base_dir, test_name)
1510         shutil.copyfile(path_in, path_test)
1511         ret = []
1512         for x in range(0, 3):
1513             ret.append(
1514                 self.run_state(
1515                     "file.replace",
1516                     name=path_test,
1517                     pattern="^# en_US.UTF-8$",
1518                     repl="en_US.UTF-8",
1519                     append_if_not_found=True,
1520                     not_found_content=(
1521                         "THIS LINE WASN'T FOUND! SO WE'RE APPENDING IT HERE!"
1522                     ),
1523                 )
1524             )
1525         self.assertTrue(filecmp.cmp(path_test, path_out))
1526         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1527         for item in ret:
1528             self.assertSaltTrueReturn(item)
1529     @with_tempdir()
1530     def test_replace_issue_18612_change_mid_line_with_comment(self, base_dir):
1531         """
1532         Test the (mis-)behaviour of file.replace as described in #18612:
1533         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1534         an infinitely growing file as 'file.replace' didn't check beforehand
1535         whether the changes had already been done to the file
1536         The tested file contains 5 key=value pairs
1537         The commented key=value pair #foo=bar should be changed to foo=salt
1538         The comment char (#) in front of foo=bar should be removed
1539         """
1540         test_name = "test_replace_issue_18612_change_mid_line_with_comment"
1541         path_in = os.path.join(
1542             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1543         )
1544         path_out = os.path.join(
1545             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1546         )
1547         path_test = os.path.join(base_dir, test_name)
1548         shutil.copyfile(path_in, path_test)
1549         ret = []
1550         for x in range(0, 3):
1551             ret.append(
1552                 self.run_state(
1553                     "file.replace",
1554                     name=path_test,
1555                     pattern="^#foo=bar($|(?=\r\n))",
1556                     repl="foo=salt",
1557                     append_if_not_found=True,
1558                 )
1559             )
1560         self.assertTrue(filecmp.cmp(path_test, path_out))
1561         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1562         for item in ret:
1563             self.assertSaltTrueReturn(item)
1564     @with_tempdir()
1565     def test_replace_issue_18841_no_changes(self, base_dir):
1566         """
1567         Test the (mis-)behaviour of file.replace as described in #18841:
1568         Using file.replace in a way which shouldn't modify the file at all
1569         results in changed mtime of the original file and a backup file being created.
1570         The tested file contains multiple lines
1571         The tested file contains a line already matching the replacement (no change needed)
1572         The tested file's content shouldn't change at all
1573         The tested file's mtime shouldn't change at all
1574         No backup file should be created
1575         """
1576         test_name = "test_replace_issue_18841_no_changes"
1577         path_in = os.path.join(
1578             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1579         )
1580         path_test = os.path.join(base_dir, test_name)
1581         shutil.copyfile(path_in, path_test)
1582         fstats_orig = os.stat(path_test)
1583         age = 5 * 24 * 60 * 60
1584         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1585         ret = self.run_state(
1586             "file.replace",
1587             name=path_test,
1588             pattern="^hello world$",
1589             repl="goodbye world",
1590             show_changes=True,
1591             flags=["IGNORECASE"],
1592             backup=False,
1593         )
1594         fstats_post = os.stat(path_test)
1595         self.assertTrue(filecmp.cmp(path_in, path_test))
1596         self.assertFalse(os.path.exists(path_test + ".bak"))
1597         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1598         self.assertSaltTrueReturn(ret)
1599     def test_serialize(self):
1600         """
1601         Test to ensure that file.serialize returns a data structure that's
1602         both serialized and formatted properly
1603         """
1604         path_test = self.tmp_dir / "test_serialize"
1605         self.addCleanup(salt.utils.files.safe_rm, str(path_test))
1606         ret = self.run_state(
1607             "file.serialize",
1608             name=str(path_test),
1609             dataset={
1610                 "name": "naive",
1611                 "description": "A basic test",
1612                 "a_list": ["first_element", "second_element"],
1613                 "finally": "the last item",
1614             },
1615             formatter="json",
1616         )
1617         serialized_file = salt.utils.stringutils.to_unicode(path_test.read_bytes())
1618         expected_file = "\n".join(
1619             [
1620                 "{",
1621                 '  "a_list": [',
1622                 '    "first_element",',
1623                 '    "second_element"',
1624                 "  ],",
1625                 '  "description": "A basic test",',
1626                 '  "finally": "the last item",',
1627                 '  "name": "naive"',
1628                 "}",
1629                 "",
1630             ]
1631         )
1632         self.assertEqual(serialized_file, expected_file)
1633     @with_tempfile(create=False)
1634     def test_serializer_deserializer_opts(self, name):
1635         """
1636         Test the serializer_opts and deserializer_opts options
1637         """
1638         data1 = {"foo": {"bar": "%(x)s"}}
1639         data2 = {"foo": {"abc": 123}}
1640         merged = {"foo": {"y": "not_used", "x": "baz", "abc": 123, "bar": "baz"}}
1641         ret = self.run_state(
1642             "file.serialize",
1643             name=name,
1644             dataset=data1,
1645             formatter="configparser",
1646             deserializer_opts=[{"defaults": {"y": "not_used"}}],
1647         )
1648         ret = ret[next(iter(ret))]
1649         assert ret["result"], ret
1650         assert "warnings" in ret
1651         ret = self.run_state(
1652             "file.serialize",
1653             name=name,
1654             dataset=data2,
1655             formatter="configparser",
1656             merge_if_exists=True,
1657             serializer_opts=[{"defaults": {"y": "not_used"}}],
1658             deserializer_opts=[{"defaults": {"x": "baz"}}],
1659         )
1660         ret = ret[next(iter(ret))]
1661         assert ret["result"], ret
1662         with salt.utils.files.fopen(name) as fp_:
1663             serialized_data = salt.serializers.configparser.deserialize(fp_)
1664         log.debug("serialized_data = %r", serialized_data)
1665         log.debug("merged = %r", merged)
1666         assert serialized_data["foo"]["y"] == merged["foo"]["y"]
1667         assert serialized_data["foo"]["bar"] == merged["foo"]["bar"]
1668     @with_tempfile(create=False)
1669     def test_serializer_plist_binary_file_open(self, name):
1670         """
1671         Test the serialization and deserialization of plists which should include
1672         the "rb" file open arguments change specifically for this formatter to handle
1673         binary plists.
1674         """
1675         data1 = {"foo": {"bar": "%(x)s"}}
1676         data2 = {"foo": {"abc": 123}}
1677         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1678         ret = self.run_state(
1679             "file.serialize",
1680             name=name,
1681             dataset=data1,
1682             formatter="plist",
1683             serializer_opts=[{"fmt": "FMT_BINARY"}],
1684         )
1685         ret = ret[next(iter(ret))]
1686         assert ret["result"], ret
1687         ret = self.run_state(
1688             "file.serialize",
1689             name=name,
1690             dataset=data2,
1691             formatter="plist",
1692             merge_if_exists=True,
1693             serializer_opts=[{"fmt": "FMT_BINARY"}],
1694         )
1695         ret = ret[next(iter(ret))]
1696         assert ret["result"], ret
1697         with salt.utils.files.fopen(name, "rb") as fp_:
1698             serialized_data = salt.serializers.plist.deserialize(fp_)
1699         assert serialized_data["foo"] == merged["foo"]
1700     @with_tempfile(create=False)
1701     def test_serializer_plist_file_open(self, name):
1702         """
1703         Test the serialization and deserialization of non binary plists with
1704         the new line concatenation.
1705         """
1706         data1 = {"foo": {"bar": "%(x)s"}}
1707         data2 = {"foo": {"abc": 123}}
1708         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1709         ret = self.run_state(
1710             "file.serialize",
1711             name=name,
1712             dataset=data1,
1713             formatter="plist",
1714         )
1715         ret = ret[next(iter(ret))]
1716         assert ret["result"], ret
1717         ret = self.run_state(
1718             "file.serialize",
1719             name=name,
1720             dataset=data2,
1721             formatter="plist",
1722             merge_if_exists=True,
1723         )
1724         ret = ret[next(iter(ret))]
1725         assert ret["result"], ret
1726         with salt.utils.files.fopen(name, "rb") as fp_:
1727             serialized_data = salt.serializers.plist.deserialize(fp_)
1728         assert serialized_data["foo"] == merged["foo"]
1729     @with_tempdir()
1730     def test_replace_issue_18841_omit_backup(self, base_dir):
1731         """
1732         Test the (mis-)behaviour of file.replace as described in #18841:
1733         Using file.replace in a way which shouldn't modify the file at all
1734         results in changed mtime of the original file and a backup file being created.
1735         The tested file contains multiple lines
1736         The tested file contains a line already matching the replacement (no change needed)
1737         The tested file's content shouldn't change at all
1738         The tested file's mtime shouldn't change at all
1739         No backup file should be created, although backup=False isn't explicitly defined
1740         """
1741         test_name = "test_replace_issue_18841_omit_backup"
1742         path_in = os.path.join(
1743             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1744         )
1745         path_test = os.path.join(base_dir, test_name)
1746         shutil.copyfile(path_in, path_test)
1747         fstats_orig = os.stat(path_test)
1748         age = 5 * 24 * 60 * 60
1749         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1750         ret = self.run_state(
1751             "file.replace",
1752             name=path_test,
1753             pattern="^hello world$",
1754             repl="goodbye world",
1755             show_changes=True,
1756             flags=["IGNORECASE"],
1757         )
1758         fstats_post = os.stat(path_test)
1759         self.assertTrue(filecmp.cmp(path_in, path_test))
1760         self.assertFalse(os.path.exists(path_test + ".bak"))
1761         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1762         self.assertSaltTrueReturn(ret)
1763     @with_tempfile()
1764     def test_comment(self, name):
1765         """
1766         file.comment
1767         """
1768         with salt.utils.files.fopen(name, "w+") as fp_:
1769             fp_.write("comment_me")
1770         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1771         self.assertSaltNoneReturn(ret)
1772         ret = self.run_state("file.comment", name=name, regex="^comment")
1773         self.assertSaltTrueReturn(ret)
1774         with salt.utils.files.fopen(name, "r") as fp_:
1775             self.assertTrue(fp_.read().startswith("#comment"))
1776         ret = self.run_state("file.comment", name=name, regex="^comment")
1777         self.assertSaltTrueReturn(ret)
1778         with salt.utils.files.fopen(name, "r") as fp_:
1779             self.assertTrue(fp_.read().startswith("#comment"))
1780         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1781         self.assertSaltTrueReturn(ret)
1782     @with_tempfile()
1783     def test_test_comment(self, name):
1784         """
1785         file.comment test interface
1786         """
1787         with salt.utils.files.fopen(name, "w+") as fp_:
1788             fp_.write("comment_me")
1789         ret = self.run_state(
1790             "file.comment",
1791             test=True,
1792             name=name,
1793             regex=".*comment.*",
1794         )
1795         with salt.utils.files.fopen(name, "r") as fp_:
1796             self.assertNotIn("#comment", fp_.read())
1797         self.assertSaltNoneReturn(ret)
1798     @with_tempfile()
1799     def test_uncomment(self, name):
1800         """
1801         file.uncomment
1802         """
1803         with salt.utils.files.fopen(name, "w+") as fp_:
1804             fp_.write("#comment_me")
1805         ret = self.run_state("file.uncomment", name=name, regex="^comment")
1806         with salt.utils.files.fopen(name, "r") as fp_:
1807             self.assertNotIn("#comment", fp_.read())
1808         self.assertSaltTrueReturn(ret)
1809     @with_tempfile()
1810     def test_test_uncomment(self, name):
1811         """
1812         file.comment test interface
1813         """
1814         with salt.utils.files.fopen(name, "w+") as fp_:
1815             fp_.write("#comment_me")
1816         ret = self.run_state("file.uncomment", test=True, name=name, regex="^comment.*")
1817         with salt.utils.files.fopen(name, "r") as fp_:
1818             self.assertIn("#comment", fp_.read())
1819         self.assertSaltNoneReturn(ret)
1820     @with_tempfile()
1821     def test_append(self, name):
1822         """
1823         file.append
1824         """
1825         with salt.utils.files.fopen(name, "w+") as fp_:
1826             fp_.write("#salty!")
1827         ret = self.run_state("file.append", name=name, text="cheese")
1828         with salt.utils.files.fopen(name, "r") as fp_:
1829             self.assertIn("cheese", fp_.read())
1830         self.assertSaltTrueReturn(ret)
1831     @with_tempfile()
1832     def test_test_append(self, name):
1833         """
1834         file.append test interface
1835         """
1836         with salt.utils.files.fopen(name, "w+") as fp_:
1837             fp_.write("#salty!")
1838         ret = self.run_state("file.append", test=True, name=name, text="cheese")
1839         with salt.utils.files.fopen(name, "r") as fp_:
1840             self.assertNotIn("cheese", fp_.read())
1841         self.assertSaltNoneReturn(ret)
1842     @with_tempdir()
1843     def test_append_issue_1864_makedirs(self, base_dir):
1844         """
1845         file.append but create directories if needed as an option, and create
1846         the file if it doesn't exist
1847         """
1848         fname = "append_issue_1864_makedirs"
1849         name = os.path.join(base_dir, fname)
1850         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1851         self.assertSaltTrueReturn(ret)
1852         name = os.path.join(base_dir, "issue_1864", fname)
1853         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1854         self.assertSaltTrueReturn(ret)
1855         name = os.path.join(base_dir, "issue_1864", fname + "2")
1856         ret = self.run_state("file.append", name=name, text="cheese")
1857         self.assertSaltTrueReturn(ret)
1858         self.assertTrue(os.path.isfile(name))
1859     @with_tempdir()
1860     def test_prepend_issue_27401_makedirs(self, base_dir):
1861         """
1862         file.prepend but create directories if needed as an option, and create
1863         the file if it doesn't exist
1864         """
1865         fname = "prepend_issue_27401"
1866         name = os.path.join(base_dir, fname)
1867         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1868         self.assertSaltTrueReturn(ret)
1869         name = os.path.join(base_dir, "issue_27401", fname)
1870         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1871         self.assertSaltTrueReturn(ret)
1872         name = os.path.join(base_dir, "issue_27401", fname + "2")
1873         ret = self.run_state("file.prepend", name=name, text="cheese")
1874         self.assertSaltTrueReturn(ret)
1875         self.assertTrue(os.path.isfile(name))
1876     @with_tempfile()
1877     def test_touch(self, name):
1878         """
1879         file.touch
1880         """
1881         ret = self.run_state("file.touch", name=name)
1882         self.assertTrue(os.path.isfile(name))
1883         self.assertSaltTrueReturn(ret)
1884     @with_tempfile(create=False)
1885     def test_test_touch(self, name):
1886         """
1887         file.touch test interface
1888         """
1889         ret = self.run_state("file.touch", test=True, name=name)
1890         self.assertFalse(os.path.isfile(name))
1891         self.assertSaltNoneReturn(ret)
1892     @with_tempdir()
1893     def test_touch_directory(self, base_dir):
1894         """
1895         file.touch a directory
1896         """
1897         name = os.path.join(base_dir, "touch_test_dir")
1898         os.mkdir(name)
1899         ret = self.run_state("file.touch", name=name)
1900         self.assertSaltTrueReturn(ret)
1901         self.assertTrue(os.path.isdir(name))
1902     @with_tempdir()
1903     def test_issue_2227_file_append(self, base_dir):
1904         """
1905         Text to append includes a percent symbol
1906         """
1907         tmp_file_append = os.path.join(base_dir, "test.append")
1908         self.run_state("file.touch", name=tmp_file_append)
1909         self.run_state(
1910             "file.append", name=tmp_file_append, source="salt://testappend/firstif"
1911         )
1912         self.run_state(
1913             "file.append", name=tmp_file_append, source="salt://testappend/secondif"
1914         )
1915         try:
1916             ret = self.run_state(
1917                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1918             )
1919             self.assertSaltTrueReturn(ret)
1920             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1921                 contents_pre = fp_.read()
1922             ret = self.run_state(
1923                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1924             )
1925             self.assertSaltTrueReturn(ret)
1926             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1927                 contents_post = fp_.read()
1928             self.assertEqual(contents_pre, contents_post)
1929         except AssertionError:
1930             if os.path.exists(tmp_file_append):
1931                 shutil.copy(tmp_file_append, tmp_file_append + ".bak")
1932             raise
1933     @with_tempdir()
1934     def test_issue_2401_file_comment(self, base_dir):
1935         tmp_file = os.path.join(base_dir, "issue-2041-comment.txt")
1936         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1937             fp_.write("hello\nworld\n")
1938         template_lines = [
1939             "{}:".format(tmp_file),
1940             "  file.comment:",
1941             "    - regex: ^world",
1942         template = "\n".join(template_lines)
1943         try:
1944             ret <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.run_function("state.template_str", [template], timeout=120)
1945             self.assertSaltTrueReturn(ret)
1946             self.assertNotInSaltComment("Pattern already commented", ret)
1947             self.assertInSaltComment("Commented lines successfully", ret)
1948             ret = self.run_function(</b></font>"state.template_str", [template], timeout=120)
1949             self.assertSaltTrueReturn(ret)
1950             self.assertInSaltComment("Pattern already commented", ret)
1951         except AssertionError:
1952             shutil.copy(tmp_file, tmp_file + ".bak")
1953             raise
1954     @with_tempdir()
1955     def test_issue_2379_file_append(self, base_dir):
1956         tmp_file = os.path.join(base_dir, "issue-2379-file-append.txt")
1957         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1958             fp_.write(
1959                 "hello\nworld\n"  # Some junk
1960                 "#PermitRootLogin yes\n"  # Commented text
1961                 "# PermitRootLogin yes\n"  # Commented text with space
1962             )
1963         template_lines = [
1964             "{}:".format(tmp_file),
1965             "  file.append:",
1966             "    - text: PermitRootLogin yes",
1967         ]
1968         template = "\n".join(template_lines)
1969         try:
1970             ret = self.run_function("state.template_str", [template])
1971             self.assertSaltTrueReturn(ret)
1972             self.assertInSaltComment("Appended 1 lines", ret)
1973         except AssertionError:
1974             shutil.copy(tmp_file, tmp_file + ".bak")
1975             raise
1976     @skipIf(IS_WINDOWS, "Mode not available in Windows")
1977     @with_tempdir(create=False)
1978     @with_tempdir(create=False)
1979     def test_issue_2726_mode_kwarg(self, dir1, dir2):
1980         bad_mode_kwarg_testfile = os.path.join(dir1, "bad_mode_kwarg", "testfile")
1981         bad_template = [
1982             "{}:".format(bad_mode_kwarg_testfile),
1983             "  file.recurse:",
1984             "    - source: salt://testfile",
1985             "    - mode: 644",
1986         ]
1987         ret = self.run_function("state.template_str", [os.linesep.join(bad_template)])
1988         self.assertSaltFalseReturn(ret)
1989         self.assertInSaltComment(
1990             "'mode' is not allowed in 'file.recurse'. Please use "
1991             "'file_mode' and 'dir_mode'.",
1992             ret,
1993         )
1994         self.assertNotInSaltComment(
1995             "TypeError: managed() got multiple values for keyword argument 'mode'",
1996             ret,
1997         )
1998         good_mode_kwargs_testfile = os.path.join(dir2, "good_mode_kwargs", "testappend")
1999         good_template = [
2000             "{}:".format(good_mode_kwargs_testfile),
2001             "  file.recurse:",
2002             "    - source: salt://testappend",
2003             "    - dir_mode: 744",
2004             "    - file_mode: 644",
2005         ]
2006         ret = self.run_function("state.template_str", [os.linesep.join(good_template)])
2007         self.assertSaltTrueReturn(ret)
2008     @with_tempdir()
2009     def test_issue_8343_accumulated_require_in(self, base_dir):
2010         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8343.sls")
2011         testcase_filedest = os.path.join(base_dir, "issue-8343.txt")
2012         if os.path.exists(template_path):
2013             os.remove(template_path)
2014         if os.path.exists(testcase_filedest):
2015             os.remove(testcase_filedest)
2016         sls_template = [
2017             "{0}:",
2018             "  file.managed:",
2019             "    - contents: |",
2020             "                #",
2021             "",
2022             "prepend-foo-accumulator-from-pillar:",
2023             "  file.accumulated:",
2024             "    - require_in:",
2025             "      - file: prepend-foo-management",
2026             "    - filename: {0}",
2027             "    - text: |",
2028             "            foo",
2029             "",
2030             "append-foo-accumulator-from-pillar:",
2031             "  file.accumulated:",
2032             "    - require_in:",
2033             "      - file: append-foo-management",
2034             "    - filename: {0}",
2035             "    - text: |",
2036             "            bar",
2037             "",
2038             "prepend-foo-management:",
2039             "  file.blockreplace:",
2040             "    - name: {0}",
2041             '    - marker_start: "#-- start salt managed zonestart -- PLEASE, DO NOT'
2042             ' EDIT"',
2043             '    - marker_end: "#-- end salt managed zonestart --"',
2044             "    - content: ''",
2045             "    - prepend_if_not_found: True",
2046             "    - backup: '.bak'",
2047             "    - show_changes: True",
2048             "",
2049             "append-foo-management:",
2050             "  file.blockreplace:",
2051             "    - name: {0}",
2052             '    - marker_start: "#-- start salt managed zoneend -- PLEASE, DO NOT'
2053             ' EDIT"',
2054             '    - marker_end: "#-- end salt managed zoneend --"',
2055             "    - content: ''",
2056             "    - append_if_not_found: True",
2057             "    - backup: '.bak2'",
2058             "    - show_changes: True",
2059             "",
2060         ]
2061         with salt.utils.files.fopen(template_path, "w") as fp_:
2062             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
2063         ret = self.run_function("state.sls", mods="issue-8343")
2064         for name, step in ret.items():
2065             self.assertSaltTrueReturn({name: step})
2066         with salt.utils.files.fopen(testcase_filedest) as fp_:
2067             contents = fp_.read().split(os.linesep)
2068         expected = [
2069             "#-- start salt managed zonestart -- PLEASE, DO NOT EDIT",
2070             "foo",
2071             "#-- end salt managed zonestart --",
2072             "#",
2073             "#-- start salt managed zoneend -- PLEASE, DO NOT EDIT",
2074             "bar",
2075             "#-- end salt managed zoneend --",
2076             "",
2077         ]
2078         self.assertEqual(
2079             [salt.utils.stringutils.to_str(line) for line in expected], contents
2080         )
2081     @with_tempdir()
2082     def test_issue_11003_immutable_lazy_proxy_sum(self, base_dir):
2083         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-11003.sls")
2084         testcase_filedest = os.path.join(base_dir, "issue-11003.txt")
2085         sls_template = [
2086             "a{0}:",
2087             "  file.absent:",
2088             "    - name: {0}",
2089             "",
2090             "{0}:",
2091             "  file.managed:",
2092             "    - contents: |",
2093             "                #",
2094             "",
2095             "test-acc1:",
2096             "  file.accumulated:",
2097             "    - require_in:",
2098             "      - file: final",
2099             "    - filename: {0}",
2100             "    - text: |",
2101             "            bar",
2102             "",
2103             "test-acc2:",
2104             "  file.accumulated:",
2105             "    - watch_in:",
2106             "      - file: final",
2107             "    - filename: {0}",
2108             "    - text: |",
2109             "            baz",
2110             "",
2111             "final:",
2112             "  file.blockreplace:",
2113             "    - name: {0}",
2114             '    - marker_start: "#-- start managed zone PLEASE, DO NOT EDIT"',
2115             '    - marker_end: "#-- end managed zone"',
2116             "    - content: ''",
2117             "    - append_if_not_found: True",
2118             "    - show_changes: True",
2119         ]
2120         with salt.utils.files.fopen(template_path, "w") as fp_:
2121             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
2122         ret = self.run_function("state.sls", mods="issue-11003", timeout=600)
2123         for name, step in ret.items():
2124             self.assertSaltTrueReturn({name: step})
2125         with salt.utils.files.fopen(testcase_filedest) as fp_:
2126             contents = fp_.read().split(os.linesep)
2127         begin = contents.index("#-- start managed zone PLEASE, DO NOT EDIT") + 1
2128         end = contents.index("#-- end managed zone")
2129         block_contents = contents[begin:end]
2130         for item in ("", "bar", "baz"):
2131             block_contents.remove(item)
2132         self.assertEqual(block_contents, [])
2133     @with_tempdir()
2134     def test_issue_8947_utf8_sls(self, base_dir):
2135         """
2136         Test some file operation with utf-8 characters on the sls
2137         This is more generic than just a file test. Feel free to move
2138         """
2139         self.maxDiff = None
2140         korean_1 = "한국어 시험"
2141         korean_2 = "첫 번째 행"
2142         korean_3 = "마지막 행"
2143         test_file = os.path.join(base_dir, "{}.txt".format(korean_1))
2144         test_file_encoded = test_file
2145         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8947.sls")
2146         template = textwrap.dedent(
2147             """\
2148             some-utf8-file-create:
2149               file.managed:
2150                 - name: {test_file}
2151                 - contents: {korean_1}
2152                 - makedirs: True
2153                 - replace: True
2154                 - show_diff: True
2155             some-utf8-file-create2:
2156               file.managed:
2157                 - name: {test_file}
2158                 - contents: |
2159                    {korean_2}
2160                    {korean_1}
2161                    {korean_3}
2162                 - replace: True
2163                 - show_diff: True
2164             """.format(
2165                 **locals()
2166             )
2167         )
2168         if not salt.utils.platform.is_windows():
2169             template += textwrap.dedent(
2170                 """\
2171             some-utf8-file-content-test:
2172               cmd.run:
2173                 - name: 'cat "{test_file}"'
2174                 - require:
2175                   - file: some-utf8-file-create2
2176             """.format(
2177                     **locals()
2178                 )
2179             )
2180         with salt.utils.files.fopen(template_path, "wb") as fp_:
2181             fp_.write(salt.utils.stringutils.to_bytes(template))
2182         try:
2183             result = self.run_function("state.sls", mods="issue-8947")
2184             if not isinstance(result, dict):
2185                 raise AssertionError(
2186                     "Something went really wrong while testing this sls: {!r}".format(
2187                         result
2188                     )
2189                 )
2190             diff = "--- \n+++ \n@@ -1 +1,3 @@\n"
2191             diff += "+첫 번째 행{0} 한국어 시험{0}+마지막 행{0}".format(os.linesep)
2192             ret = {x.split("_|-")[1]: y for x, y in result.items()}
2193             self.assertEqual(
2194                 ret["some-utf8-file-create"]["comment"],
2195                 "File {} updated".format(test_file_encoded),
2196             )
2197             self.assertEqual(
2198                 ret["some-utf8-file-create"]["changes"], {"diff": "New file"}
2199             )
2200             self.assertEqual(
2201                 ret["some-utf8-file-create2"]["comment"],
2202                 "File {} updated".format(test_file_encoded),
2203             )
2204             self.assertEqual(ret["some-utf8-file-create2"]["changes"], {"diff": diff})
2205             if salt.utils.platform.is_windows():
2206                 import subprocess
2207                 import win32api
2208                 proc = subprocess.run(
2209                     ["type", win32api.GetShortPathName(test_file)],
2210                     stdout=subprocess.PIPE,
2211                     stderr=subprocess.PIPE,
2212                     check=True,
2213                     shell=True,  # nosec
2214                 self.assertEqual(
2215                     proc.stdout.decode("utf-8"),
2216                     os.linesep<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join((korean_2, korean_1, korean_3)) + os.linesep,
2217                 )
2218             else:
2219                 self.assertEqual(
2220                     ret["some-utf8-file-content-test"]["comment"],
2221                     'Command "cat "{}"" run'.format(test_file_encoded),
2222                 )
2223                 self.assertEqual(</b></font>
2224                     ret["some-utf8-file-content-test"]["changes"]["stdout"],
2225                     "\n".join((korean_2, korean_1, korean_3)),
2226                 )
2227         finally:
2228             try:
2229                 os.remove(template_path)
2230             except OSError:
2231                 pass
2232     @pytest.mark.skip_if_not_root
2233     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2234     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2235     @with_system_user_and_group(
2236         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2237     )
2238     @with_tempdir()
2239     @skipIf(salt.utils.platform.is_freebsd(), "Test is failing on FreeBSD")
2240     def test_issue_12209_follow_symlinks(self, tempdir, user, group):
2241         """
2242         Ensure that symlinks are properly chowned when recursing (following
2243         symlinks)
2244         """
2245         onedir = os.path.join(tempdir, "one")
2246         twodir = os.path.join(tempdir, "two")
2247         os.mkdir(onedir)
2248         os.symlink(onedir, twodir)
2249         ret = self.run_state(
2250             "file.directory",
2251             name=tempdir,
2252             follow_symlinks=True,
2253             user=user,
2254             recurse=["user", "group"],
2255         )
2256         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertSaltTrueReturn(ret)
2257         onestats = os.stat(onedir)
2258         twostats = os.lstat(twodir)
2259         self.assertEqual(pwd.getpwuid(onestats.</b></font>st_uid).pw_name, user)
2260         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, "root")
2261         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
2262         if salt.utils.path.which("id"):
2263             root_group = self.run_function("user.primary_group", ["root"])
2264             self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, root_group)
2265     @pytest.mark.skip_if_not_root
2266     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2267     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2268     @with_system_user_and_group(
2269         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2270     )
2271     @with_tempdir()
2272     def test_issue_12209_no_follow_symlinks(self, tempdir, user, group):
2273         """
2274         Ensure that symlinks are properly chowned when recursing (not following
2275         symlinks)
2276         """
2277         onedir = os.path.join(tempdir, "one")
2278         twodir = os.path.join(tempdir, "two")
2279         os.mkdir(onedir)
2280         os.symlink(onedir, twodir)
2281         ret = self.run_state(
2282             "file.directory",
2283             name=tempdir,
2284             follow_symlinks=False,
2285             user=user,
2286             group=group,
2287             recurse=["user", "group"],
2288         )
2289         self.assertSaltTrueReturn(ret)
2290         onestats = os.stat(onedir)
2291         twostats = os.lstat(twodir)
2292         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
2293         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, user)
2294         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
2295         self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, group)
2296     @with_tempfile(create=False)
2297     @with_tempfile()
2298     def test_template_local_file(self, source, dest):
2299         """
2300         Test a file.managed state with a local file as the source. Test both
2301         with the file:// protocol designation prepended, and without it.
2302         """
2303         with salt.utils.files.fopen(source, "w") as fp_:
2304             fp_.write("{{ foo }}\n")
2305         for prefix in ("file://", ""):
2306             ret = self.run_state(
2307                 "file.managed",
2308                 name=dest,
2309                 source=prefix + source,
2310                 template="jinja",
2311                 context={"foo": "Hello world!"},
2312             )
2313             self.assertSaltTrueReturn(ret)
2314     @with_tempfile()
2315     def test_template_local_file_noclobber(self, source):
2316         """
2317         Test the case where a source file is in the minion's local filesystem,
2318         and the source path is the same as the destination path.
2319         """
2320         with salt.utils.files.fopen(source, "w") as fp_:
2321             fp_.write("{{ foo }}\n")
2322         ret = self.run_state(
2323             "file.managed",
2324             name=source,
2325             source=source,
2326             template="jinja",
2327             context={"foo": "Hello world!"},
2328         )
2329         self.assertSaltFalseReturn(ret)
2330         self.assertIn(
2331             "Source file cannot be the same as destination",
2332             ret[next(iter(ret))]["comment"],
2333         )
2334     @with_tempfile(create=False)
2335     @with_tempfile(create=False)
2336     def test_issue_25250_force_copy_deletes(self, source, dest):
2337         """
2338         ensure force option in copy state does not delete target file
2339         """
2340         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
2341         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "file/base/cheese"), dest)
2342         self.run_state("file.copy", name=dest, source=source, force=True)
2343         self.assertTrue(os.path.exists(dest))
2344         self.assertTrue(filecmp.cmp(source, dest))
2345         os.remove(source)
2346         os.remove(dest)
2347     @pytest.mark.destructive_test
2348     @pytest.mark.skip_if_not_root
2349     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
2350     @with_tempfile()
2351     def test_file_copy_make_dirs(self, source):
2352         """
2353         ensure make_dirs creates correct user perms
2354         """
2355         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
2356         dest = self.tmp_dir / "dir1" / "dir2" / "copied_file.txt"
2357         self.addCleanup(salt.utils.files.rm_rf, str(dest.parent.parent))
2358         user = "salt"
2359         mode = "0644"
2360         ret = self.run_function("user.add", [user])
2361         self.assertTrue(ret, "Failed to add user. Are you running as sudo?")
2362         ret = self.run_state(
2363             "file.copy",
2364             name=str(dest),
2365             source=source,
2366             user=user,
2367             makedirs=True,
2368             mode=mode,
2369         )
2370         self.assertSaltTrueReturn(ret)
2371         file_checks = [str(dest), str(dest.parent), str(dest.parent.parent)]
2372         for check in file_checks:
2373             user_check = self.run_function("file.get_user", [check])
2374             mode_check = self.run_function("file.get_mode", [check])
2375             self.assertEqual(user_check, user)
2376             self.assertEqual(salt.utils.files.normalize_mode(mode_check), mode)
2377     @pytest.mark.skip_if_not_root
2378     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2379     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2380     @with_system_user_and_group(
2381         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2382     )
2383     def test_owner_after_setuid(self, user, group):
2384         """
2385         Test to check file user/group after setting setuid or setgid.
2386         Because Python os.chown() does reset the setuid/setgid to 0.
2387         https://github.com/saltstack/salt/pull/45257
2388         """
2389         desired_file = self.tmp_dir / "file_with_setuid"
2390         self.addCleanup(salt.utils.files<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.safe_rm, str(desired_file))
2391         desired = {
2392             "file": str(desired_file),
2393             "user": user,
2394             "group": group,
2395             "mode": "4750",
2396         }
2397         ret = self.run_state(
2398             "file.managed",
2399             name=desired["file"],
2400             user=desired[</b></font>"user"],
2401             group=desired["group"],
2402             mode=desired["mode"],
2403         )
2404         file_stat = desired_file.stat()
2405         result = {
2406             "user": pwd.getpwuid(file_stat.st_uid).pw_name,
2407             "group": grp.getgrgid(file_stat.st_gid).gr_name,
2408             "mode": oct(stat.S_IMODE(file_stat.st_mode)),
2409         }
2410         self.assertSaltTrueReturn(ret)
2411         self.assertEqual(desired["user"], result["user"])
2412         self.assertEqual(desired["group"], result["group"])
2413         self.assertEqual(desired["mode"], result["mode"].lstrip("0Oo"))
2414     def test_binary_contents(self):
2415         """
2416         This tests to ensure that binary contents do not cause a traceback.
2417         """
2418         name = self.tmp_dir / "1px.gif"
2419         self.addCleanup(salt.utils.files.safe_rm, str(name))
2420         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2421         self.assertSaltTrueReturn(ret)
2422     def test_binary_contents_twice(self):
2423         """
2424         This test ensures that after a binary file is created, salt can confirm
2425         that the file is in the correct state.
2426         """
2427         name = self.tmp_dir / "1px.gif"
2428         self.addCleanup(salt.utils.files.safe_rm, str(name))
2429         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2430         self.assertSaltTrueReturn(ret)
2431         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2432         self.assertSaltTrueReturn(ret)
2433     @pytest.mark.skip_if_not_root
2434     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2435     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2436     @with_system_user_and_group(
2437         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2438     )
2439     @with_tempdir()
2440     def test_issue_48336_file_managed_mode_setuid(self, tempdir, user, group):
2441         """
2442         Ensure that mode is correct with changing of ownership and group
2443         symlinks)
2444         """
2445         tempfile = os.path.join(tempdir, "temp_file_issue_48336")
2446         ret = self.run_state(
2447             "file.managed",
2448             name=tempfile,
2449             user=user,
2450             group=group,
2451             mode="4750",
2452         )
2453         self.assertSaltTrueReturn(ret)
2454         temp_file_stats = os.stat(tempfile)
2455         temp_file_mode = str(oct(stat.S_IMODE(temp_file_stats.st_mode)))
2456         temp_file_mode = salt.utils.files.normalize_mode(temp_file_mode)
2457         self.assertEqual(temp_file_mode, "4750")
2458         self.assertEqual(pwd.getpwuid(temp_file_stats.st_uid).pw_name, user)
2459         self.assertEqual(grp.getgrgid(temp_file_stats.st_gid).gr_name, group)
2460     @with_tempdir()
2461     def test_issue_48557(self, tempdir):
2462         tempfile = os.path.join(tempdir, "temp_file_issue_48557")
2463         with salt.utils.files.fopen(tempfile, "wb") as fp:
2464             fp.write(os.linesep.join(["test1", "test2", "test3", ""]).encode("utf-8"))
2465         ret = self.run_state(
2466             "file.line", name=tempfile, after="test2", mode="insert", content="test4"
2467         )
2468         self.assertSaltTrueReturn(ret)
2469         with salt.utils.files.fopen(tempfile, "rb") as fp:
2470             content = fp.read()
2471         self.assertEqual(
2472             content,
2473             os.linesep.join(["test1", "test2", "test4", "test3", ""]).encode("utf-8"),
2474         )
2475     def test_managed_file_issue_51208(self):
2476         """
2477         Test to ensure we can handle a file with escaped double-quotes
2478         """
2479         name = self.tmp_dir / "issue_51208.txt"
2480         self.addCleanup(salt.utils.files.safe_rm, str(name))
2481         ret = self.run_state(
2482             "file.managed", name=str(name), source="salt://issue-51208/vimrc.stub"
2483         )
2484         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "issue-51208" / "vimrc.stub"
2485         master_data = src.read_text()
2486         minion_data = name.read_text()
2487         self.assertEqual(master_data, minion_data)
2488         self.assertSaltTrueReturn(ret)
2489     @with_tempfile()
2490     def test_keyvalue(self, name):
2491         """
2492         file.keyvalue
2493         """
2494         content = dedent(
2495             """\
2496             """
2497         )
2498         with salt.utils.files.fopen(name, "w+") as fp_:
2499             fp_.write(content)
2500         ret = self.run_state(
2501             "file.keyvalue",
2502             name=name,
2503             key="permitrootlogin",
2504             value="no",
2505             separator=" ",
2506             uncomment=" #",
2507             key_ignore_case=True,
2508         )
2509         with salt.utils.files.fopen(name, "r") as fp_:
2510             file_contents = fp_.read()
2511             self.assertNotIn("#PermitRootLogin", file_contents)
2512             self.assertNotIn("prohibit-password", file_contents)
2513             self.assertIn("PermitRootLogin no", file_contents)
2514         self.assertSaltTrueReturn(ret)
2515     @with_tempdir()
2516     @pytest.mark.slow_test
2517     def test_issue_1896_file_append_source(self, base_dir):
2518         """
2519         Verify that we can append a file's contents
2520         """
2521         testfile = os.path.join(base_dir, "test.append")
2522         ret = self.run_state("file.touch", name=testfile)
2523         self.assertSaltTrueReturn(ret)
2524         ret = self.run_state(
2525             "file.append", name=testfile, source="salt://testappend/firstif"
2526         )
2527         self.assertSaltTrueReturn(ret)
2528         ret = self.run_state(
2529             "file.append", name=testfile, source="salt://testappend/secondif"
2530         )
2531         self.assertSaltTrueReturn(ret)
2532         with salt.utils.files.fopen(testfile, "r") as fp_:
2533             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read())
2534         contents = textwrap.dedent(
2535             """\
2536             if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
2537                 debian_chroot=$(cat /etc/debian_chroot)
2538             fi
2539             if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
2540                 . /etc/bash_completion
2541             fi
2542             """
2543         )
2544         if salt.utils.platform.is_windows():
2545             new_contents = contents.splitlines()
2546             contents = os.linesep.join(new_contents)
2547             contents += os.linesep
2548         self.assertMultiLineEqual(contents, testfile_contents)
2549         ret = self.run_state(
2550             "file.append", name=testfile, source="salt://testappend/secondif"
2551         )
2552         self.assertSaltTrueReturn(ret)
2553         ret = self.run_state(
2554             "file.append", name=testfile, source="salt://testappend/firstif"
2555         )
2556         self.assertSaltTrueReturn(ret)
2557         with salt.utils.files.fopen(testfile, "r") as fp_:
2558             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read())
2559         self.assertMultiLineEqual(contents, testfile_contents)
2560 @pytest.mark.windows_whitelisted
2561 class BlockreplaceTest(ModuleCase, SaltReturnAssertsMixin):
2562     marker_start = "# start"
2563     marker_end = "# end"
2564     content = dedent(
2565         """\
2566         Line 1 of block
2567         Line 2 of block
2568         """
2569     )
2570     without_block = dedent(
2571         """\
2572         Hello world!
2573         """
2574     )
2575     with_non_matching_block = dedent(
2576         """\
2577         Hello world!
2578         No match here
2579         """
2580     )
2581     with_non_matching_block_and_marker_end_not_after_newline = dedent(
2582         """\
2583         Hello world!
2584         No match here# end
2585         """
2586     )
2587     with_matching_block = dedent(
2588         """\
2589         Hello world!
2590         Line 1 of block
2591         Line 2 of block
2592         """
2593     )
2594     with_matching_block_and_extra_newline = dedent(
2595         """\
2596         Hello world!
2597         Line 1 of block
2598         Line 2 of block
2599         """
2600     )
2601     with_matching_block_and_marker_end_not_after_newline = dedent(
2602         """\
2603         Hello world!
2604         Line 1 of block
2605         Line 2 of block# end
2606         """
2607     )
2608     content_explicit_posix_newlines = "Line 1 of block\nLine 2 of block\n"
2609     content_explicit_windows_newlines = "Line 1 of block\r\nLine 2 of block\r\n"
2610     without_block_explicit_posix_newlines = "Hello world!\n\n# comment here\n"
2611     without_block_explicit_windows_newlines = "Hello world!\r\n\r\n# comment here\r\n"
2612     with_block_prepended_explicit_posix_newlines = (
2613         "# start\n"
2614         "Line 1 of block\n"
2615         "Line 2 of block\n"
2616         "# end\n"
2617         "Hello world!\n\n"
2618         "# comment here\n"
2619     )
2620     with_block_prepended_explicit_windows_newlines = (
2621         "# start\r\n"
2622         "Line 1 of block\r\n"
2623         "Line 2 of block\r\n"
2624         "# end\r\n"
2625         "Hello world!\r\n\r\n"
2626         "# comment here\r\n"
2627     )
2628     with_block_appended_explicit_posix_newlines = (
2629         "Hello world!\n\n"
2630         "# comment here\n"
2631         "# start\n"
2632         "Line 1 of block\n"
2633         "Line 2 of block\n"
2634         "# end\n"
2635     )
2636     with_block_appended_explicit_windows_newlines = (
2637         "Hello world!\r\n\r\n"
2638         "# comment here\r\n"
2639         "# start\r\n"
2640         "Line 1 of block\r\n"
2641         "Line 2 of block\r\n"
2642         "# end\r\n"
2643     )
2644     @staticmethod
2645     def _write(dest, content):
2646         with salt.utils.files.fopen(dest, "wb") as fp_:
2647             fp_.write(salt.utils.stringutils.to_bytes(content))
2648     @staticmethod
2649     def _read(src):
2650         with salt.utils.files.fopen(src, "rb") as fp_:
2651             return salt.utils.stringutils.to_unicode(fp_.read())
2652     @with_tempfile()
2653     def test_prepend(self, name):
2654         """
2655         Test blockreplace when prepend_if_not_found=True and block doesn't
2656         exist in file.
2657         """
2658         expected = (
2659             self.marker_start
2660             + os.linesep
2661             + self.content
2662             + self.marker_end
2663             + os.linesep
2664             + self.without_block
2665         )
2666         self._write(name, self.without_block)
2667         ret = self.run_state(
2668             "file.blockreplace",
2669             name=name,
2670             content=self.content,
2671             marker_start=self.marker_start,
2672             marker_end=self.marker_end,
2673             prepend_if_not_found=True,
2674         )
2675         self.assertSaltTrueReturn(ret)
2676         self.assertTrue(ret[next(iter(ret))]["changes"])
2677         self.assertEqual(self._read(name), expected)
2678         ret = self.run_state(
2679             "file.blockreplace",
2680             name=name,
2681             content=self.content,
2682             marker_start=self.marker_start,
2683             marker_end=self.marker_end,
2684             prepend_if_not_found=True,
2685         )
2686         self.assertSaltTrueReturn(ret)
2687         self.assertFalse(ret[next(iter(ret))]["changes"])
2688         self.assertEqual(self._read(name), expected)
2689         self._write(name, self.without_block)
2690         ret = self.run_state(
2691             "file.blockreplace",
2692             name=name,
2693             content=self.content.rstrip("\r\n"),
2694             marker_start=self.marker_start,
2695             marker_end=self.marker_end,
2696             prepend_if_not_found=True,
2697         )
2698         self.assertSaltTrueReturn(ret)
2699         self.assertTrue(ret[next(iter(ret))]["changes"])
2700         self.assertEqual(self._read(name), expected)
2701         ret = self.run_state(
2702             "file.blockreplace",
2703             name=name,
2704             content=self.content.rstrip("\r\n"),
2705             marker_start=self.marker_start,
2706             marker_end=self.marker_end,
2707             prepend_if_not_found=True,
2708         )
2709         self.assertSaltTrueReturn(ret)
2710         self.assertFalse(ret[next(iter(ret))]["changes"])
2711         self.assertEqual(self._read(name), expected)
2712     @with_tempfile()
2713     def test_prepend_append_newline(self, name):
2714         """
2715         Test blockreplace when prepend_if_not_found=True and block doesn't
2716         exist in file. Test with append_newline explicitly set to True.
2717         """
2718         expected = (
2719             self.marker_start
2720             + os.linesep
2721             + self.content
2722             + os.linesep
2723             + self.marker_end
2724             + os.linesep
2725             + self.without_block
2726         )
2727         self._write(name, self.without_block)
2728         ret = self.run_state(
2729             "file.blockreplace",
2730             name=name,
2731             content=self.content,
2732             marker_start=self.marker_start,
2733             marker_end=self.marker_end,
2734             prepend_if_not_found=True,
2735             append_newline=True,
2736         )
2737         self.assertSaltTrueReturn(ret)
2738         self.assertTrue(ret[next(iter(ret))]["changes"])
2739         self.assertEqual(self._read(name), expected)
2740         ret = self.run_state(
2741             "file.blockreplace",
2742             name=name,
2743             content=self.content,
2744             marker_start=self.marker_start,
2745             marker_end=self.marker_end,
2746             prepend_if_not_found=True,
2747             append_newline=True,
2748         )
2749         self.assertSaltTrueReturn(ret)
2750         self.assertFalse(ret[next(iter(ret))]["changes"])
2751         self.assertEqual(self._read(name), expected)
2752         expected = (
2753             self.marker_start
2754             + os.linesep
2755             + self.content
2756             + self.marker_end
2757             + os.linesep
2758             + self.without_block
2759         )
2760         self._write(name, self.without_block)
2761         ret = self.run_state(
2762             "file.blockreplace",
2763             name=name,
2764             content=self.content.rstrip("\r\n"),
2765             marker_start=self.marker_start,
2766             marker_end=self.marker_end,
2767             prepend_if_not_found=True,
2768             append_newline=True,
2769         )
2770         self.assertSaltTrueReturn(ret)
2771         self.assertTrue(ret[next(iter(ret))]["changes"])
2772         self.assertEqual(self._read(name), expected)
2773         ret = self.run_state(
2774             "file.blockreplace",
2775             name=name,
2776             content=self.content.rstrip("\r\n"),
2777             marker_start=self.marker_start,
2778             marker_end=self.marker_end,
2779             prepend_if_not_found=True,
2780             append_newline=True,
2781         )
2782         self.assertSaltTrueReturn(ret)
2783         self.assertFalse(ret[next(iter(ret))]["changes"])
2784         self.assertEqual(self._read(name), expected)
2785     @with_tempfile()
2786     def test_prepend_no_append_newline(self, name):
2787         """
2788         Test blockreplace when prepend_if_not_found=True and block doesn't
2789         exist in file. Test with append_newline explicitly set to False.
2790         """
2791         expected = (
2792             self.marker_start
2793             + os.linesep
2794             + self.content
2795             + self.marker_end
2796             + os.linesep
2797             + self.without_block
2798         )
2799         self._write(name, self.without_block)
2800         ret = self.run_state(
2801             "file.blockreplace",
2802             name=name,
2803             content=self.content,
2804             marker_start=self.marker_start,
2805             marker_end=self.marker_end,
2806             prepend_if_not_found=True,
2807             append_newline=False,
2808         )
2809         self.assertSaltTrueReturn(ret)
2810         self.assertTrue(ret[next(iter(ret))]["changes"])
2811         self.assertEqual(self._read(name), expected)
2812         ret = self.run_state(
2813             "file.blockreplace",
2814             name=name,
2815             content=self.content,
2816             marker_start=self.marker_start,
2817             marker_end=self.marker_end,
2818             prepend_if_not_found=True,
2819             append_newline=False,
2820         )
2821         self.assertSaltTrueReturn(ret)
2822         self.assertFalse(ret[next(iter(ret))]["changes"])
2823         self.assertEqual(self._read(name), expected)
2824         expected = (
2825             self.marker_start
2826             + os.linesep
2827             + self.content.rstrip("\r\n")
2828             + self.marker_end
2829             + os.linesep
2830             + self.without_block
2831         )
2832         self._write(name, self.without_block)
2833         ret = self.run_state(
2834             "file.blockreplace",
2835             name=name,
2836             content=self.content.rstrip("\r\n"),
2837             marker_start=self.marker_start,
2838             marker_end=self.marker_end,
2839             prepend_if_not_found=True,
2840             append_newline=False,
2841         )
2842         self.assertSaltTrueReturn(ret)
2843         self.assertTrue(ret[next(iter(ret))]["changes"])
2844         self.assertEqual(self._read(name), expected)
2845         ret = self.run_state(
2846             "file.blockreplace",
2847             name=name,
2848             content=self.content.rstrip("\r\n"),
2849             marker_start=self.marker_start,
2850             marker_end=self.marker_end,
2851             prepend_if_not_found=True,
2852             append_newline=False,
2853         )
2854         self.assertSaltTrueReturn(ret)
2855         self.assertFalse(ret[next(iter(ret))]["changes"])
2856         self.assertEqual(self._read(name), expected)
2857     @with_tempfile()
2858     def test_append(self, name):
2859         """
2860         Test blockreplace when append_if_not_found=True and block doesn't
2861         exist in file.
2862         """
2863         expected = (
2864             self.without_block
2865             + self.marker_start
2866             + os.linesep
2867             + self.content
2868             + self.marker_end
2869             + os.linesep
2870         )
2871         self._write(name, self.without_block)
2872         ret = self.run_state(
2873             "file.blockreplace",
2874             name=name,
2875             content=self.content,
2876             marker_start=self.marker_start,
2877             marker_end=self.marker_end,
2878             append_if_not_found=True,
2879         )
2880         self.assertSaltTrueReturn(ret)
2881         self.assertTrue(ret[next(iter(ret))]["changes"])
2882         self.assertEqual(self._read(name), expected)
2883         ret = self.run_state(
2884             "file.blockreplace",
2885             name=name,
2886             content=self.content,
2887             marker_start=self.marker_start,
2888             marker_end=self.marker_end,
2889             append_if_not_found=True,
2890         )
2891         self.assertSaltTrueReturn(ret)
2892         self.assertFalse(ret[next(iter(ret))]["changes"])
2893         self.assertEqual(self._read(name), expected)
2894         self._write(name, self.without_block)
2895         ret = self.run_state(
2896             "file.blockreplace",
2897             name=name,
2898             content=self.content.rstrip("\r\n"),
2899             marker_start=self.marker_start,
2900             marker_end=self.marker_end,
2901             append_if_not_found=True,
2902         )
2903         self.assertSaltTrueReturn(ret)
2904         self.assertTrue(ret[next(iter(ret))]["changes"])
2905         self.assertEqual(self._read(name), expected)
2906         ret = self.run_state(
2907             "file.blockreplace",
2908             name=name,
2909             content=self.content.rstrip("\r\n"),
2910             marker_start=self.marker_start,
2911             marker_end=self.marker_end,
2912             append_if_not_found=True,
2913         )
2914         self.assertSaltTrueReturn(ret)
2915         self.assertFalse(ret[next(iter(ret))]["changes"])
2916         self.assertEqual(self._read(name), expected)
2917     @with_tempfile()
2918     def test_append_append_newline(self, name):
2919         """
2920         Test blockreplace when append_if_not_found=True and block doesn't
2921         exist in file. Test with append_newline explicitly set to True.
2922         """
2923         expected = (
2924             self.without_block
2925             + self.marker_start
2926             + os.linesep
2927             + self.content
2928             + os.linesep
2929             + self.marker_end
2930             + os.linesep
2931         )
2932         self._write(name, self.without_block)
2933         ret = self.run_state(
2934             "file.blockreplace",
2935             name=name,
2936             content=self.content,
2937             marker_start=self.marker_start,
2938             marker_end=self.marker_end,
2939             append_if_not_found=True,
2940             append_newline=True,
2941         )
2942         self.assertSaltTrueReturn(ret)
2943         self.assertTrue(ret[next(iter(ret))]["changes"])
2944         self.assertEqual(self._read(name), expected)
2945         ret = self.run_state(
2946             "file.blockreplace",
2947             name=name,
2948             content=self.content,
2949             marker_start=self.marker_start,
2950             marker_end=self.marker_end,
2951             append_if_not_found=True,
2952             append_newline=True,
2953         )
2954         self.assertSaltTrueReturn(ret)
2955         self.assertFalse(ret[next(iter(ret))]["changes"])
2956         self.assertEqual(self._read(name), expected)
2957         expected = (
2958             self.without_block
2959             + self.marker_start
2960             + os.linesep
2961             + self.content
2962             + self.marker_end
2963             + os.linesep
2964         )
2965         self._write(name, self.without_block)
2966         ret = self.run_state(
2967             "file.blockreplace",
2968             name=name,
2969             content=self.content.rstrip("\r\n"),
2970             marker_start=self.marker_start,
2971             marker_end=self.marker_end,
2972             append_if_not_found=True,
2973             append_newline=True,
2974         )
2975         self.assertSaltTrueReturn(ret)
2976         self.assertTrue(ret[next(iter(ret))]["changes"])
2977         self.assertEqual(self._read(name), expected)
2978         ret = self.run_state(
2979             "file.blockreplace",
2980             name=name,
2981             content=self.content.rstrip("\r\n"),
2982             marker_start=self.marker_start,
2983             marker_end=self.marker_end,
2984             append_if_not_found=True,
2985             append_newline=True,
2986         )
2987         self.assertSaltTrueReturn(ret)
2988         self.assertFalse(ret[next(iter(ret))]["changes"])
2989         self.assertEqual(self._read(name), expected)
2990     @with_tempfile()
2991     def test_append_no_append_newline(self, name):
2992         """
2993         Test blockreplace when append_if_not_found=True and block doesn't
2994         exist in file. Test with append_newline explicitly set to False.
2995         """
2996         expected = (
2997             self.without_block
2998             + self.marker_start
2999             + os.linesep
3000             + self.content
3001             + self.marker_end
3002             + os.linesep
3003         )
3004         self._write(name, self.without_block)
3005         ret = self.run_state(
3006             "file.blockreplace",
3007             name=name,
3008             content=self.content,
3009             marker_start=self.marker_start,
3010             marker_end=self.marker_end,
3011             append_if_not_found=True,
3012             append_newline=False,
3013         )
3014         self.assertSaltTrueReturn(ret)
3015         self.assertTrue(ret[next(iter(ret))]["changes"])
3016         self.assertEqual(self._read(name), expected)
3017         ret = self.run_state(
3018             "file.blockreplace",
3019             name=name,
3020             content=self.content,
3021             marker_start=self.marker_start,
3022             marker_end=self.marker_end,
3023             append_if_not_found=True,
3024             append_newline=False,
3025         )
3026         self.assertSaltTrueReturn(ret)
3027         self.assertFalse(ret[next(iter(ret))]["changes"])
3028         self.assertEqual(self._read(name), expected)
3029         expected = (
3030             self.without_block
3031             + self.marker_start
3032             + os.linesep
3033             + self.content.rstrip("\r\n")
3034             + self.marker_end
3035             + os.linesep
3036         )
3037         self._write(name, self.without_block)
3038         ret = self.run_state(
3039             "file.blockreplace",
3040             name=name,
3041             content=self.content.rstrip("\r\n"),
3042             marker_start=self.marker_start,
3043             marker_end=self.marker_end,
3044             append_if_not_found=True,
3045             append_newline=False,
3046         )
3047         self.assertSaltTrueReturn(ret)
3048         self.assertTrue(ret[next(iter(ret))]["changes"])
3049         self.assertEqual(self._read(name), expected)
3050         ret = self.run_state(
3051             "file.blockreplace",
3052             name=name,
3053             content=self.content.rstrip("\r\n"),
3054             marker_start=self.marker_start,
3055             marker_end=self.marker_end,
3056             append_if_not_found=True,
3057             append_newline=False,
3058         )
3059         self.assertSaltTrueReturn(ret)
3060         self.assertFalse(ret[next(iter(ret))]["changes"])
3061         self.assertEqual(self._read(name), expected)
3062     @with_tempfile()
3063     def test_prepend_auto_line_separator(self, name):
3064         """
3065         This tests the line separator auto-detection when prepending the block
3066         """
3067         self._write(name, self.without_block_explicit_windows_newlines)
3068         ret = self.run_state(
3069             "file.blockreplace",
3070             name=name,
3071             content=self.content_explicit_posix_newlines,
3072             marker_start=self.marker_start,
3073             marker_end=self.marker_end,
3074             prepend_if_not_found=True,
3075         )
3076         self.assertSaltTrueReturn(ret)
3077         self.assertTrue(ret[next(iter(ret))]["changes"])
3078         self.assertEqual(
3079             self._read(name), self.with_block_prepended_explicit_windows_newlines
3080         )
3081         ret = self.run_state(
3082             "file.blockreplace",
3083             name=name,
3084             content=self.content_explicit_posix_newlines,
3085             marker_start=self.marker_start,
3086             marker_end=self.marker_end,
3087             prepend_if_not_found=True,
3088         )
3089         self.assertSaltTrueReturn(ret)
3090         self.assertFalse(ret[next(iter(ret))]["changes"])
3091         self.assertEqual(
3092             self._read(name), self.with_block_prepended_explicit_windows_newlines
3093         )
3094         self._write(name, self.without_block_explicit_posix_newlines)
3095         ret = self.run_state(
3096             "file.blockreplace",
3097             name=name,
3098             content=self.content_explicit_windows_newlines,
3099             marker_start=self.marker_start,
3100             marker_end=self.marker_end,
3101             prepend_if_not_found=True,
3102         )
3103         self.assertSaltTrueReturn(ret)
3104         self.assertTrue(ret[next(iter(ret))]["changes"])
3105         self.assertEqual(
3106             self._read(name), self.with_block_prepended_explicit_posix_newlines
3107         )
3108         ret = self.run_state(
3109             "file.blockreplace",
3110             name=name,
3111             content=self.content_explicit_windows_newlines,
3112             marker_start=self.marker_start,
3113             marker_end=self.marker_end,
3114             prepend_if_not_found=True,
3115         )
3116         self.assertSaltTrueReturn(ret)
3117         self.assertFalse(ret[next(iter(ret))]["changes"])
3118         self.assertEqual(
3119             self._read(name), self.with_block_prepended_explicit_posix_newlines
3120         )
3121     @with_tempfile()
3122     def test_append_auto_line_separator(self, name):
3123         """
3124         This tests the line separator auto-detection when appending the block
3125         """
3126         self._write(name, self.without_block_explicit_windows_newlines)
3127         ret = self.run_state(
3128             "file.blockreplace",
3129             name=name,
3130             content=self.content_explicit_posix_newlines,
3131             marker_start=self.marker_start,
3132             marker_end=self.marker_end,
3133             append_if_not_found=True,
3134         )
3135         self.assertSaltTrueReturn(ret)
3136         self.assertTrue(ret[next(iter(ret))]["changes"])
3137         self.assertEqual(
3138             self._read(name), self.with_block_appended_explicit_windows_newlines
3139         )
3140         ret = self.run_state(
3141             "file.blockreplace",
3142             name=name,
3143             content=self.content_explicit_posix_newlines,
3144             marker_start=self.marker_start,
3145             marker_end=self.marker_end,
3146             append_if_not_found=True,
3147         )
3148         self.assertSaltTrueReturn(ret)
3149         self.assertFalse(ret[next(iter(ret))]["changes"])
3150         self.assertEqual(
3151             self._read(name), self.with_block_appended_explicit_windows_newlines
3152         )
3153         self._write(name, self.without_block_explicit_posix_newlines)
3154         ret = self.run_state(
3155             "file.blockreplace",
3156             name=name,
3157             content=self.content_explicit_windows_newlines,
3158             marker_start=self.marker_start,
3159             marker_end=self.marker_end,
3160             append_if_not_found=True,
3161         )
3162         self.assertSaltTrueReturn(ret)
3163         self.assertTrue(ret[next(iter(ret))]["changes"])
3164         self.assertEqual(
3165             self._read(name), self.with_block_appended_explicit_posix_newlines
3166         )
3167         ret = self.run_state(
3168             "file.blockreplace",
3169             name=name,
3170             content=self.content_explicit_windows_newlines,
3171             marker_start=self.marker_start,
3172             marker_end=self.marker_end,
3173             append_if_not_found=True,
3174         )
3175         self.assertSaltTrueReturn(ret)
3176         self.assertFalse(ret[next(iter(ret))]["changes"])
3177         self.assertEqual(
3178             self._read(name), self.with_block_appended_explicit_posix_newlines
3179         )
3180     @with_tempfile()
3181     def test_non_matching_block(self, name):
3182         """
3183         Test blockreplace when block exists but its contents are not a
3184         match.
3185         """
3186         self._write(name, self.with_non_matching_block)
3187         ret = self.run_state(
3188             "file.blockreplace",
3189             name=name,
3190             content=self.content,
3191             marker_start=self.marker_start,
3192             marker_end=self.marker_end,
3193         )
3194         self.assertSaltTrueReturn(ret)
3195         self.assertTrue(ret[next(iter(ret))]["changes"])
3196         self.assertEqual(self._read(name), self.with_matching_block)
3197         ret = self.run_state(
3198             "file.blockreplace",
3199             name=name,
3200             content=self.content,
3201             marker_start=self.marker_start,
3202             marker_end=self.marker_end,
3203         )
3204         self.assertSaltTrueReturn(ret)
3205         self.assertFalse(ret[next(iter(ret))]["changes"])
3206         self.assertEqual(self._read(name), self.with_matching_block)
3207         self._write(name, self.with_non_matching_block)
3208         ret = self.run_state(
3209             "file.blockreplace",
3210             name=name,
3211             content=self.content.rstrip("\r\n"),
3212             marker_start=self.marker_start,
3213             marker_end=self.marker_end,
3214         )
3215         self.assertSaltTrueReturn(ret)
3216         self.assertTrue(ret[next(iter(ret))]["changes"])
3217         self.assertEqual(self._read(name), self.with_matching_block)
3218         ret = self.run_state(
3219             "file.blockreplace",
3220             name=name,
3221             content=self.content.rstrip("\r\n"),
3222             marker_start=self.marker_start,
3223             marker_end=self.marker_end,
3224         )
3225         self.assertSaltTrueReturn(ret)
3226         self.assertFalse(ret[next(iter(ret))]["changes"])
3227         self.assertEqual(self._read(name), self.with_matching_block)
3228     @with_tempfile()
3229     def test_non_matching_block_append_newline(self, name):
3230         """
3231         Test blockreplace when block exists but its contents are not a
3232         match. Test with append_newline explicitly set to True.
3233         """
3234         self._write(name, self.with_non_matching_block)
3235         ret = self.run_state(
3236             "file.blockreplace",
3237             name=name,
3238             content=self.content,
3239             marker_start=self.marker_start,
3240             marker_end=self.marker_end,
3241             append_newline=True,
3242         )
3243         self.assertSaltTrueReturn(ret)
3244         self.assertTrue(ret[next(iter(ret))]["changes"])
3245         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3246         ret = self.run_state(
3247             "file.blockreplace",
3248             name=name,
3249             content=self.content,
3250             marker_start=self.marker_start,
3251             marker_end=self.marker_end,
3252             append_newline=True,
3253         )
3254         self.assertSaltTrueReturn(ret)
3255         self.assertFalse(ret[next(iter(ret))]["changes"])
3256         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3257         self._write(name, self.with_non_matching_block)
3258         ret = self.run_state(
3259             "file.blockreplace",
3260             name=name,
3261             content=self.content.rstrip("\r\n"),
3262             marker_start=self.marker_start,
3263             marker_end=self.marker_end,
3264             append_newline=True,
3265         )
3266         self.assertSaltTrueReturn(ret)
3267         self.assertTrue(ret[next(iter(ret))]["changes"])
3268         self.assertEqual(self._read(name), self.with_matching_block)
3269         ret = self.run_state(
3270             "file.blockreplace",
3271             name=name,
3272             content=self.content.rstrip("\r\n"),
3273             marker_start=self.marker_start,
3274             marker_end=self.marker_end,
3275             append_newline=True,
3276         )
3277         self.assertSaltTrueReturn(ret)
3278         self.assertFalse(ret[next(iter(ret))]["changes"])
3279         self.assertEqual(self._read(name), self.with_matching_block)
3280     @with_tempfile()
3281     def test_non_matching_block_no_append_newline(self, name):
3282         """
3283         Test blockreplace when block exists but its contents are not a
3284         match. Test with append_newline explicitly set to False.
3285         """
3286         self._write(name, self.with_non_matching_block)
3287         ret = self.run_state(
3288             "file.blockreplace",
3289             name=name,
3290             content=self.content,
3291             marker_start=self.marker_start,
3292             marker_end=self.marker_end,
3293             append_newline=False,
3294         )
3295         self.assertSaltTrueReturn(ret)
3296         self.assertTrue(ret[next(iter(ret))]["changes"])
3297         self.assertEqual(self._read(name), self.with_matching_block)
3298         ret = self.run_state(
3299             "file.blockreplace",
3300             name=name,
3301             content=self.content,
3302             marker_start=self.marker_start,
3303             marker_end=self.marker_end,
3304             append_newline=False,
3305         )
3306         self.assertSaltTrueReturn(ret)
3307         self.assertFalse(ret[next(iter(ret))]["changes"])
3308         self.assertEqual(self._read(name), self.with_matching_block)
3309         self._write(name, self.with_non_matching_block)
3310         ret = self.run_state(
3311             "file.blockreplace",
3312             name=name,
3313             content=self.content.rstrip("\r\n"),
3314             marker_start=self.marker_start,
3315             marker_end=self.marker_end,
3316             append_newline=False,
3317         )
3318         self.assertSaltTrueReturn(ret)
3319         self.assertTrue(ret[next(iter(ret))]["changes"])
3320         self.assertEqual(
3321             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3322         )
3323         ret = self.run_state(
3324             "file.blockreplace",
3325             name=name,
3326             content=self.content.rstrip("\r\n"),
3327             marker_start=self.marker_start,
3328             marker_end=self.marker_end,
3329             append_newline=False,
3330         )
3331         self.assertSaltTrueReturn(ret)
3332         self.assertFalse(ret[next(iter(ret))]["changes"])
3333         self.assertEqual(
3334             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3335         )
3336     @with_tempfile()
3337     def test_non_matching_block_and_marker_not_after_newline(self, name):
3338         """
3339         Test blockreplace when block exists but its contents are not a
3340         match, and the marker_end is not directly preceded by a newline.
3341         """
3342         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3343         ret = self.run_state(
3344             "file.blockreplace",
3345             name=name,
3346             content=self.content,
3347             marker_start=self.marker_start,
3348             marker_end=self.marker_end,
3349         )
3350         self.assertSaltTrueReturn(ret)
3351         self.assertTrue(ret[next(iter(ret))]["changes"])
3352         self.assertEqual(self._read(name), self.with_matching_block)
3353         ret = self.run_state(
3354             "file.blockreplace",
3355             name=name,
3356             content=self.content,
3357             marker_start=self.marker_start,
3358             marker_end=self.marker_end,
3359         )
3360         self.assertSaltTrueReturn(ret)
3361         self.assertFalse(ret[next(iter(ret))]["changes"])
3362         self.assertEqual(self._read(name), self.with_matching_block)
3363         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3364         ret = self.run_state(
3365             "file.blockreplace",
3366             name=name,
3367             content=self.content.rstrip("\r\n"),
3368             marker_start=self.marker_start,
3369             marker_end=self.marker_end,
3370         )
3371         self.assertSaltTrueReturn(ret)
3372         self.assertTrue(ret[next(iter(ret))]["changes"])
3373         self.assertEqual(self._read(name), self.with_matching_block)
3374         ret = self.run_state(
3375             "file.blockreplace",
3376             name=name,
3377             content=self.content.rstrip("\r\n"),
3378             marker_start=self.marker_start,
3379             marker_end=self.marker_end,
3380         )
3381         self.assertSaltTrueReturn(ret)
3382         self.assertFalse(ret[next(iter(ret))]["changes"])
3383         self.assertEqual(self._read(name), self.with_matching_block)
3384     @with_tempfile()
3385     def test_non_matching_block_and_marker_not_after_newline_append_newline(self, name):
3386         """
3387         Test blockreplace when block exists but its contents are not a match,
3388         and the marker_end is not directly preceded by a newline. Test with
3389         append_newline explicitly set to True.
3390         """
3391         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3392         ret = self.run_state(
3393             "file.blockreplace",
3394             name=name,
3395             content=self.content,
3396             marker_start=self.marker_start,
3397             marker_end=self.marker_end,
3398             append_newline=True,
3399         )
3400         self.assertSaltTrueReturn(ret)
3401         self.assertTrue(ret[next(iter(ret))]["changes"])
3402         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3403         ret = self.run_state(
3404             "file.blockreplace",
3405             name=name,
3406             content=self.content,
3407             marker_start=self.marker_start,
3408             marker_end=self.marker_end,
3409             append_newline=True,
3410         )
3411         self.assertSaltTrueReturn(ret)
3412         self.assertFalse(ret[next(iter(ret))]["changes"])
3413         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3414         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3415         ret = self.run_state(
3416             "file.blockreplace",
3417             name=name,
3418             content=self.content.rstrip("\r\n"),
3419             marker_start=self.marker_start,
3420             marker_end=self.marker_end,
3421             append_newline=True,
3422         )
3423         self.assertSaltTrueReturn(ret)
3424         self.assertTrue(ret[next(iter(ret))]["changes"])
3425         self.assertEqual(self._read(name), self.with_matching_block)
3426         ret = self.run_state(
3427             "file.blockreplace",
3428             name=name,
3429             content=self.content.rstrip("\r\n"),
3430             marker_start=self.marker_start,
3431             marker_end=self.marker_end,
3432             append_newline=True,
3433         )
3434         self.assertSaltTrueReturn(ret)
3435         self.assertFalse(ret[next(iter(ret))]["changes"])
3436         self.assertEqual(self._read(name), self.with_matching_block)
3437     @with_tempfile()
3438     def test_non_matching_block_and_marker_not_after_newline_no_append_newline(
3439         self, name
3440     ):
3441         """
3442         Test blockreplace when block exists but its contents are not a match,
3443         and the marker_end is not directly preceded by a newline. Test with
3444         append_newline explicitly set to False.
3445         """
3446         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3447         ret = self.run_state(
3448             "file.blockreplace",
3449             name=name,
3450             content=self.content,
3451             marker_start=self.marker_start,
3452             marker_end=self.marker_end,
3453             append_newline=False,
3454         )
3455         self.assertSaltTrueReturn(ret)
3456         self.assertTrue(ret[next(iter(ret))]["changes"])
3457         self.assertEqual(self._read(name), self.with_matching_block)
3458         ret = self.run_state(
3459             "file.blockreplace",
3460             name=name,
3461             content=self.content,
3462             marker_start=self.marker_start,
3463             marker_end=self.marker_end,
3464             append_newline=False,
3465         )
3466         self.assertSaltTrueReturn(ret)
3467         self.assertFalse(ret[next(iter(ret))]["changes"])
3468         self.assertEqual(self._read(name), self.with_matching_block)
3469         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3470         ret = self.run_state(
3471             "file.blockreplace",
3472             name=name,
3473             content=self.content.rstrip("\r\n"),
3474             marker_start=self.marker_start,
3475             marker_end=self.marker_end,
3476             append_newline=False,
3477         )
3478         self.assertSaltTrueReturn(ret)
3479         self.assertTrue(ret[next(iter(ret))]["changes"])
3480         self.assertEqual(
3481             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3482         )
3483         ret = self.run_state(
3484             "file.blockreplace",
3485             name=name,
3486             content=self.content.rstrip("\r\n"),
3487             marker_start=self.marker_start,
3488             marker_end=self.marker_end,
3489             append_newline=False,
3490         )
3491         self.assertSaltTrueReturn(ret)
3492         self.assertFalse(ret[next(iter(ret))]["changes"])
3493         self.assertEqual(
3494             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3495         )
3496     @with_tempfile()
3497     def test_matching_block(self, name):
3498         """
3499         Test blockreplace when block exists and its contents are a match. No
3500         changes should be made.
3501         """
3502         self._write(name, self.with_matching_block)
3503         ret = self.run_state(
3504             "file.blockreplace",
3505             name=name,
3506             content=self.content,
3507             marker_start=self.marker_start,
3508             marker_end=self.marker_end,
3509         )
3510         self.assertSaltTrueReturn(ret)
3511         self.assertFalse(ret[next(iter(ret))]["changes"])
3512         self.assertEqual(self._read(name), self.with_matching_block)
3513         ret = self.run_state(
3514             "file.blockreplace",
3515             name=name,
3516             content=self.content,
3517             marker_start=self.marker_start,
3518             marker_end=self.marker_end,
3519         )
3520         self.assertSaltTrueReturn(ret)
3521         self.assertFalse(ret[next(iter(ret))]["changes"])
3522         self.assertEqual(self._read(name), self.with_matching_block)
3523         self._write(name, self.with_matching_block)
3524         ret = self.run_state(
3525             "file.blockreplace",
3526             name=name,
3527             content=self.content.rstrip("\r\n"),
3528             marker_start=self.marker_start,
3529             marker_end=self.marker_end,
3530         )
3531         self.assertSaltTrueReturn(ret)
3532         self.assertFalse(ret[next(iter(ret))]["changes"])
3533         self.assertEqual(self._read(name), self.with_matching_block)
3534         ret = self.run_state(
3535             "file.blockreplace",
3536             name=name,
3537             content=self.content.rstrip("\r\n"),
3538             marker_start=self.marker_start,
3539             marker_end=self.marker_end,
3540         )
3541         self.assertSaltTrueReturn(ret)
3542         self.assertFalse(ret[next(iter(ret))]["changes"])
3543         self.assertEqual(self._read(name), self.with_matching_block)
3544     @with_tempfile()
3545     def test_matching_block_append_newline(self, name):
3546         """
3547         Test blockreplace when block exists and its contents are a match. Test
3548         with append_newline explicitly set to True. This will result in an
3549         extra newline when the content ends in a newline, and will not when the
3550         content does not end in a newline.
3551         """
3552         self._write(name, self.with_matching_block)
3553         ret = self.run_state(
3554             "file.blockreplace",
3555             name=name,
3556             content=self.content,
3557             marker_start=self.marker_start,
3558             marker_end=self.marker_end,
3559             append_newline=True,
3560         )
3561         self.assertSaltTrueReturn(ret)
3562         self.assertTrue(ret[next(iter(ret))]["changes"])
3563         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3564         ret = self.run_state(
3565             "file.blockreplace",
3566             name=name,
3567             content=self.content,
3568             marker_start=self.marker_start,
3569             marker_end=self.marker_end,
3570             append_newline=True,
3571         )
3572         self.assertSaltTrueReturn(ret)
3573         self.assertFalse(ret[next(iter(ret))]["changes"])
3574         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3575         self._write(name, self.with_matching_block)
3576         ret = self.run_state(
3577             "file.blockreplace",
3578             name=name,
3579             content=self.content.rstrip("\r\n"),
3580             marker_start=self.marker_start,
3581             marker_end=self.marker_end,
3582             append_newline=True,
3583         )
3584         self.assertSaltTrueReturn(ret)
3585         self.assertFalse(ret[next(iter(ret))]["changes"])
3586         self.assertEqual(self._read(name), self.with_matching_block)
3587         ret = self.run_state(
3588             "file.blockreplace",
3589             name=name,
3590             content=self.content.rstrip("\r\n"),
3591             marker_start=self.marker_start,
3592             marker_end=self.marker_end,
3593             append_newline=True,
3594         )
3595         self.assertSaltTrueReturn(ret)
3596         self.assertFalse(ret[next(iter(ret))]["changes"])
3597         self.assertEqual(self._read(name), self.with_matching_block)
3598     @with_tempfile()
3599     def test_matching_block_no_append_newline(self, name):
3600         """
3601         Test blockreplace when block exists and its contents are a match. Test
3602         with append_newline explicitly set to False. This will result in the
3603         marker_end not being directly preceded by a newline when the content
3604         does not end in a newline.
3605         """
3606         self._write(name, self.with_matching_block)
3607         ret = self.run_state(
3608             "file.blockreplace",
3609             name=name,
3610             content=self.content,
3611             marker_start=self.marker_start,
3612             marker_end=self.marker_end,
3613             append_newline=False,
3614         )
3615         self.assertSaltTrueReturn(ret)
3616         self.assertFalse(ret[next(iter(ret))]["changes"])
3617         self.assertEqual(self._read(name), self.with_matching_block)
3618         ret = self.run_state(
3619             "file.blockreplace",
3620             name=name,
3621             content=self.content,
3622             marker_start=self.marker_start,
3623             marker_end=self.marker_end,
3624             append_newline=False,
3625         )
3626         self.assertSaltTrueReturn(ret)
3627         self.assertFalse(ret[next(iter(ret))]["changes"])
3628         self.assertEqual(self._read(name), self.with_matching_block)
3629         self._write(name, self.with_matching_block)
3630         ret = self.run_state(
3631             "file.blockreplace",
3632             name=name,
3633             content=self.content.rstrip("\r\n"),
3634             marker_start=self.marker_start,
3635             marker_end=self.marker_end,
3636             append_newline=False,
3637         )
3638         self.assertSaltTrueReturn(ret)
3639         self.assertTrue(ret[next(iter(ret))]["changes"])
3640         self.assertEqual(
3641             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3642         )
3643         ret = self.run_state(
3644             "file.blockreplace",
3645             name=name,
3646             content=self.content.rstrip("\r\n"),
3647             marker_start=self.marker_start,
3648             marker_end=self.marker_end,
3649             append_newline=False,
3650         )
3651         self.assertSaltTrueReturn(ret)
3652         self.assertFalse(ret[next(iter(ret))]["changes"])
3653         self.assertEqual(
3654             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3655         )
3656     @with_tempfile()
3657     def test_matching_block_and_marker_not_after_newline(self, name):
3658         """
3659         Test blockreplace when block exists and its contents are a match, but
3660         the marker_end is not directly preceded by a newline.
3661         """
3662         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3663         ret = self.run_state(
3664             "file.blockreplace",
3665             name=name,
3666             content=self.content,
3667             marker_start=self.marker_start,
3668             marker_end=self.marker_end,
3669         )
3670         self.assertSaltTrueReturn(ret)
3671         self.assertTrue(ret[next(iter(ret))]["changes"])
3672         self.assertEqual(self._read(name), self.with_matching_block)
3673         ret = self.run_state(
3674             "file.blockreplace",
3675             name=name,
3676             content=self.content,
3677             marker_start=self.marker_start,
3678             marker_end=self.marker_end,
3679         )
3680         self.assertSaltTrueReturn(ret)
3681         self.assertFalse(ret[next(iter(ret))]["changes"])
3682         self.assertEqual(self._read(name), self.with_matching_block)
3683         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3684         ret = self.run_state(
3685             "file.blockreplace",
3686             name=name,
3687             content=self.content.rstrip("\r\n"),
3688             marker_start=self.marker_start,
3689             marker_end=self.marker_end,
3690         )
3691         self.assertSaltTrueReturn(ret)
3692         self.assertTrue(ret[next(iter(ret))]["changes"])
3693         self.assertEqual(self._read(name), self.with_matching_block)
3694         ret = self.run_state(
3695             "file.blockreplace",
3696             name=name,
3697             content=self.content.rstrip("\r\n"),
3698             marker_start=self.marker_start,
3699             marker_end=self.marker_end,
3700         )
3701         self.assertSaltTrueReturn(ret)
3702         self.assertFalse(ret[next(iter(ret))]["changes"])
3703         self.assertEqual(self._read(name), self.with_matching_block)
3704     @with_tempfile()
3705     def test_matching_block_and_marker_not_after_newline_append_newline(self, name):
3706         """
3707         Test blockreplace when block exists and its contents are a match, but
3708         the marker_end is not directly preceded by a newline. Test with
3709         append_newline explicitly set to True. This will result in an extra
3710         newline when the content ends in a newline, and will not when the
3711         content does not end in a newline.
3712         """
3713         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3714         ret = self.run_state(
3715             "file.blockreplace",
3716             name=name,
3717             content=self.content,
3718             marker_start=self.marker_start,
3719             marker_end=self.marker_end,
3720             append_newline=True,
3721         )
3722         self.assertSaltTrueReturn(ret)
3723         self.assertTrue(ret[next(iter(ret))]["changes"])
3724         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3725         ret = self.run_state(
3726             "file.blockreplace",
3727             name=name,
3728             content=self.content,
3729             marker_start=self.marker_start,
3730             marker_end=self.marker_end,
3731             append_newline=True,
3732         )
3733         self.assertSaltTrueReturn(ret)
3734         self.assertFalse(ret[next(iter(ret))]["changes"])
3735         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3736         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3737         ret = self.run_state(
3738             "file.blockreplace",
3739             name=name,
3740             content=self.content.rstrip("\r\n"),
3741             marker_start=self.marker_start,
3742             marker_end=self.marker_end,
3743             append_newline=True,
3744         )
3745         self.assertSaltTrueReturn(ret)
3746         self.assertTrue(ret[next(iter(ret))]["changes"])
3747         self.assertEqual(self._read(name), self.with_matching_block)
3748         ret = self.run_state(
3749             "file.blockreplace",
3750             name=name,
3751             content=self.content.rstrip("\r\n"),
3752             marker_start=self.marker_start,
3753             marker_end=self.marker_end,
3754             append_newline=True,
3755         )
3756         self.assertSaltTrueReturn(ret)
3757         self.assertFalse(ret[next(iter(ret))]["changes"])
3758         self.assertEqual(self._read(name), self.with_matching_block)
3759     @with_tempfile()
3760     def test_matching_block_and_marker_not_after_newline_no_append_newline(self, name):
3761         """
3762         Test blockreplace when block exists and its contents are a match, but
3763         the marker_end is not directly preceded by a newline. Test with
3764         append_newline explicitly set to False.
3765         """
3766         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3767         ret = self.run_state(
3768             "file.blockreplace",
3769             name=name,
3770             content=self.content,
3771             marker_start=self.marker_start,
3772             marker_end=self.marker_end,
3773             append_newline=False,
3774         )
3775         self.assertSaltTrueReturn(ret)
3776         self.assertTrue(ret[next(iter(ret))]["changes"])
3777         self.assertEqual(self._read(name), self.with_matching_block)
3778         ret = self.run_state(
3779             "file.blockreplace",
3780             name=name,
3781             content=self.content,
3782             marker_start=self.marker_start,
3783             marker_end=self.marker_end,
3784             append_newline=False,
3785         )
3786         self.assertSaltTrueReturn(ret)
3787         self.assertFalse(ret[next(iter(ret))]["changes"])
3788         self.assertEqual(self._read(name), self.with_matching_block)
3789         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3790         ret = self.run_state(
3791             "file.blockreplace",
3792             name=name,
3793             content=self.content.rstrip("\r\n"),
3794             marker_start=self.marker_start,
3795             marker_end=self.marker_end,
3796             append_newline=False,
3797         )
3798         self.assertSaltTrueReturn(ret)
3799         self.assertFalse(ret[next(iter(ret))]["changes"])
3800         self.assertEqual(
3801             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3802         )
3803         ret = self.run_state(
3804             "file.blockreplace",
3805             name=name,
3806             content=self.content.rstrip("\r\n"),
3807             marker_start=self.marker_start,
3808             marker_end=self.marker_end,
3809             append_newline=False,
3810         )
3811         self.assertSaltTrueReturn(ret)
3812         self.assertFalse(ret[next(iter(ret))]["changes"])
3813         self.assertEqual(
3814             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3815         )
3816     @with_tempfile()
3817     def test_issue_49043(self, name):
3818         ret = self.run_function(
3819             "state.sls",
3820             mods="issue-49043",
3821             pillar={"name": name},
3822         )
3823         log.error("ret = %s", repr(ret))
3824         diff = "--- \n+++ \n@@ -0,0 +1,3 @@\n"
3825         diff += dedent(
3826             """\
3827         +#-- start managed zone --
3828         +äöü
3829         +#-- end managed zone --
3830         """
3831         )
3832         job = "file_|-somefile-blockreplace_|-{}_|-blockreplace".format(name)
3833         self.assertEqual(ret[job]["changes"]["diff"], diff)
3834 @pytest.mark.windows_whitelisted
3835 class RemoteFileTest(ModuleCase, SaltReturnAssertsMixin):
3836     """
3837     Uses a local tornado webserver to test http(s) file.managed states with and
3838     without skip_verify
3839     """
3840     @classmethod
3841     def setUpClass(cls):
3842         cls.webserver = Webserver()
3843         cls.webserver.start()
3844         cls.source = cls.webserver.url("grail/scene33")
3845         if IS_WINDOWS:
3846             cls.source_hash = "21438b3d5fd2c0028bcab92f7824dc69"
3847         else:
3848             cls.source_hash = "d2feb3beb323c79fc7a0f44f1408b4a3"
3849     @classmethod
3850     def tearDownClass(cls):
3851         cls.webserver.stop()
3852     @with_tempfile(create=False)
3853     def setUp(self, name):  # pylint: disable=arguments-differ
3854         self.name = name
3855     def tearDown(self):
3856         try:
3857             os.remove(self.name)
3858         except OSError as exc:
3859             if exc.errno != errno.ENOENT:
3860                 raise
3861     def run_state(self, *args, **kwargs):  # pylint: disable=arguments-differ
3862         ret = super().run_state(*args, **kwargs)
3863         log.debug("ret = %s", ret)
3864         return ret
3865     def test_file_managed_http_source_no_hash(self):
3866         """
3867         Test a remote file with no hash
3868         """
3869         ret = self.run_state(
3870             "file.managed", name=self.name, source=self.source, skip_verify=False
3871         )
3872         self.assertSaltFalseReturn(ret)
3873     def test_file_managed_http_source(self):
3874         """
3875         Test a remote file with no hash
3876         """
3877         ret = self.run_state(
3878             "file.managed",
3879             name=self.name,
3880             source=self.source,
3881             source_hash=self.source_hash,
3882             skip_verify=False,
3883         )
3884         self.assertSaltTrueReturn(ret)
3885     def test_file_managed_http_source_skip_verify(self):
3886         """
3887         Test a remote file using skip_verify
3888         """
3889         ret = self.run_state(
3890             "file.managed", name=self.name, source=self.source, skip_verify=True
3891         )
3892         self.assertSaltTrueReturn(ret)
3893     def test_file_managed_keep_source_false_http(self):
3894         """
3895         This test ensures that we properly clean the cached file if keep_source
3896         is set to False, for source files using an http:// URL
3897         """
3898         ret = self.run_state(
3899             "file.managed",
3900             name=self.name,
3901             source=self.source,
3902             source_hash=self.source_hash,
3903             keep_source=False,
3904         )
3905         ret = ret[next(iter(ret))]
3906         assert ret["result"] is True
3907         result = self.run_function("cp.is_cached", [self.source])
3908         assert result == "", "File is still cached at {}".format(result)
3909 @skipIf(not salt.utils.path.which("patch"), "patch is not installed")
3910 @pytest.mark.windows_whitelisted
3911 class PatchTest(ModuleCase, SaltReturnAssertsMixin):
3912     def _check_patch_version(self, min_version):
3913         """
3914         patch version check
3915         """
3916         version = self.run_function("cmd.run", ["patch --version"]).splitlines()[0]
3917         version = version.split()[1]
3918         if _LooseVersion(version) &lt; _LooseVersion(min_version):
3919             self.skipTest(
3920                 "Minimum patch version required: {}. "
3921                 "Patch version installed: {}".format(min_version, version)
3922             )
3923     @classmethod
3924     def setUpClass(cls):
3925         cls.webserver = Webserver()
3926         cls.webserver.start()
3927         cls.numbers_patch_name = "numbers.patch"
3928         cls.math_patch_name = "math.patch"
3929         cls.all_patch_name = "all.patch"
3930         cls.numbers_patch_template_name = cls.numbers_patch_name + ".jinja"
3931         cls.math_patch_template_name = cls.math_patch_name + ".jinja"
3932         cls.all_patch_template_name = cls.all_patch_name + ".jinja"
3933         cls.numbers_patch_path = "patches/" + cls.numbers_patch_name
3934         cls.math_patch_path = "patches/" + cls.math_patch_name
3935         cls.all_patch_path = "patches/" + cls.all_patch_name
3936         cls.numbers_patch_template_path = "patches/" + cls.numbers_patch_template_name
3937         cls.math_patch_template_path = "patches/" + cls.math_patch_template_name
3938         cls.all_patch_template_path = "patches/" + cls.all_patch_template_name
3939         cls.numbers_patch = "salt://" + cls.numbers_patch_path
3940         cls.math_patch = "salt://" + cls.math_patch_path
3941         cls.all_patch = "salt://" + cls.all_patch_path
3942         cls.numbers_patch_template = "salt://" + cls.numbers_patch_template_path
3943         cls.math_patch_template = "salt://" + cls.math_patch_template_path
3944         cls.all_patch_template = "salt://" + cls.all_patch_template_path
3945         cls.numbers_patch_http = cls.webserver.url(cls.numbers_patch_path)
3946         cls.math_patch_http = cls.webserver.url(cls.math_patch_path)
3947         cls.all_patch_http = cls.webserver.url(cls.all_patch_path)
3948         cls.numbers_patch_template_http = cls.webserver.url(
3949             cls.numbers_patch_template_path
3950         )
3951         cls.math_patch_template_http = cls.webserver.url(cls.math_patch_template_path)
3952         cls.all_patch_template_http = cls.webserver.url(cls.all_patch_template_path)
3953         patches_dir = os.path.join(RUNTIME_VARS.FILES, "file", "base", "patches")
3954         cls.numbers_patch_hash = salt.utils.hashutils.get_hash(
3955             os.path.join(patches_dir, cls.numbers_patch_name)
3956         )
3957         cls.math_patch_hash = salt.utils.hashutils.get_hash(
3958             os.path.join(patches_dir, cls.math_patch_name)
3959         )
3960         cls.all_patch_hash = salt.utils.hashutils.get_hash(
3961             os.path.join(patches_dir, cls.all_patch_name)
3962         )
3963         cls.numbers_patch_template_hash = salt.utils.hashutils.get_hash(
3964             os.path.join(patches_dir, cls.numbers_patch_template_name)
3965         )
3966         cls.math_patch_template_hash = salt.utils.hashutils.get_hash(
3967             os.path.join(patches_dir, cls.math_patch_template_name)
3968         )
3969         cls.all_patch_template_hash = salt.utils.hashutils.get_hash(
3970             os.path.join(patches_dir, cls.all_patch_template_name)
3971         )
3972         cls.context = {"two": "two", "ten": 10}
3973     @classmethod
3974     def tearDownClass(cls):
3975         cls.webserver.stop()
3976     def setUp(self):
3977         """
3978         Create a new unpatched set of files
3979         """
3980         self.base_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
3981         os.makedirs(os.path.join(self.base_dir, "foo", "bar"))
3982         self.numbers_file = os.path.join(self.base_dir, "foo", "numbers.txt")
3983         self.math_file = os.path.join(self.base_dir, "foo", "bar", "math.txt")
3984         with salt.utils.files.fopen(self.numbers_file, "w") as fp_:
3985             fp_.write(
3986                 textwrap.dedent(
3987                     """\
3988                 one
3989                 two
3990                 three
3991                 1
3992                 2
3993                 3
3994                 """
3995                 )
3996             )
3997         with salt.utils.files.fopen(self.math_file, "w") as fp_:
3998             fp_.write(
3999                 textwrap.dedent(
4000                     """\
4001                 Five plus five is ten
4002                 Four squared is sixteen
4003                 """
4004                 )
4005             )
4006         self.addCleanup(shutil.rmtree, self.base_dir, ignore_errors=True)
4007     def test_patch_single_file(self):
4008         """
4009         Test file.patch using a patch applied to a single file
4010         """
4011         ret = self.run_state(
4012             "file.patch",
4013             name=self.numbers_file,
4014             source=self.numbers_patch,
4015         )
4016         self.assertSaltTrueReturn(ret)
4017         ret = ret[next(iter(ret))]
4018         self.assertEqual(ret["comment"], "Patch successfully applied")
4019         ret = self.run_state(
4020             "file.patch",
4021             name=self.numbers_file,
4022             source=self.numbers_patch,
4023         )
4024         self.assertSaltTrueReturn(ret)
4025         ret = ret[next(iter(ret))]
4026         self.assertEqual(ret["comment"], "Patch was already applied")
4027         self.assertEqual(ret["changes"], {})
4028     def test_patch_directory(self):
4029         """
4030         Test file.patch using a patch applied to a directory, with changes
4031         spanning multiple files.
4032         """
4033         self._check_patch_version("2.6")
4034         ret = self.run_state(
4035             "file.patch",
4036             name=self.base_dir,
4037             source=self.all_patch,
4038             strip=1,
4039         )
4040         self.assertSaltTrueReturn(ret)
4041         ret = ret[next(iter(ret))]
4042         self.assertEqual(ret["comment"], "Patch successfully applied")
4043         ret = self.run_state(
4044             "file.patch",
4045             name=self.base_dir,
4046             source=self.all_patch,
4047             strip=1,
4048         )
4049         self.assertSaltTrueReturn(ret)
4050         ret = ret[next(iter(ret))]
4051         self.assertEqual(ret["comment"], "Patch was already applied")
4052         self.assertEqual(ret["changes"], {})
4053     def test_patch_strip_parsing(self):
4054         """
4055         Test that we successfuly parse -p/--strip when included in the options
4056         """
4057         self._check_patch_version("2.6")
4058         ret = self.run_state(
4059             "file.patch",
4060             name=self.base_dir,
4061             source=self.all_patch,
4062             options="-p1",
4063         )
4064         self.assertSaltTrueReturn(ret)
4065         ret = ret[next(iter(ret))]
4066         self.assertEqual(ret["comment"], "Patch successfully applied")
4067         ret = self.run_state(
4068             "file.patch",
4069             name=self.base_dir,
4070             source=self.all_patch,
4071             options="--strip=1",
4072         )
4073         self.assertSaltTrueReturn(ret)
4074         ret = ret[next(iter(ret))]
4075         self.assertEqual(ret["comment"], "Patch was already applied")
4076         self.assertEqual(ret["changes"], {})
4077         ret = self.run_state(
4078             "file.patch",
4079             name=self.base_dir,
4080             source=self.all_patch,
4081             options="--strip 1",
4082         )
4083         self.assertSaltTrueReturn(ret)
4084         ret = ret[next(iter(ret))]
4085         self.assertEqual(ret["comment"], "Patch was already applied")
4086         self.assertEqual(ret["changes"], {})
4087     def test_patch_saltenv(self):
4088         """
4089         Test that we attempt to download the patch from a non-base saltenv
4090         """
4091         ret = self.run_state(
4092             "file.patch",
4093             name=self.math_file,
4094             source=self.math_patch,
4095             saltenv="prod",
4096         )
4097         self.assertSaltFalseReturn(ret)
4098         ret = ret[next(iter(ret))]
4099         self.assertEqual(
4100             ret["comment"],
4101             "Source file {} not found in saltenv 'prod'".format(self.math_patch),
4102         )
4103     def test_patch_single_file_failure(self):
4104         """
4105         Test file.patch using a patch applied to a single file. This tests a
4106         failed patch.
4107         """
4108         with salt.utils.files.fopen(self.numbers_file, "w"):
4109             pass
4110         ret = self.run_state(
4111             "file.patch",
4112             name=self.numbers_file,
4113             source=self.numbers_patch,
4114         )
4115         self.assertSaltFalseReturn(ret)
4116         ret = ret[next(iter(ret))]
4117         self.assertIn("Patch would not apply cleanly", ret["comment"])
4118         reject_file = salt.utils.files.mkstemp()
4119         ret = self.run_state(
4120             "file.patch",
4121             name=self.numbers_file,
4122             source=self.numbers_patch,
4123             reject_file=reject_file,
4124             strip=1,
4125         )
4126         self.assertSaltFalseReturn(ret)
4127         ret = ret[next(iter(ret))]
4128         self.assertIn("Patch would not apply cleanly", ret["comment"])
4129         if IS_WINDOWS:
4130             reject_file = reject_file.replace("\\", "\\\\")
4131             reject_file = "'{}'".format(reject_file)
4132         self.assertRegex(
4133             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
4134         )
4135     def test_patch_directory_failure(self):
4136         """
4137         Test file.patch using a patch applied to a directory, with changes
4138         spanning multiple files.
4139         """
4140         with salt.utils.files.fopen(self.math_file, "w"):
4141             pass
4142         ret = self.run_state(
4143             "file.patch",
4144             name=self.base_dir,
4145             source=self.all_patch,
4146             strip=1,
4147         )
4148         self.assertSaltFalseReturn(ret)
4149         ret = ret[next(iter(ret))]
4150         self.assertIn("Patch would not apply cleanly", ret["comment"])
4151         reject_file = salt.utils.files.mkstemp()
4152         ret = self.run_state(
4153             "file.patch",
4154             name=self.base_dir,
4155             source=self.all_patch,
4156             reject_file=reject_file,
4157             strip=1,
4158         )
4159         self.assertSaltFalseReturn(ret)
4160         ret = ret[next(iter(ret))]
4161         self.assertIn("Patch would not apply cleanly", ret["comment"])
4162         if IS_WINDOWS:
4163             reject_file = reject_file.replace("\\", "\\\\")
4164             reject_file = "'{}'".format(reject_file)
4165         self.assertRegex(
4166             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
4167         )
4168     def test_patch_single_file_remote_source(self):
4169         """
4170         Test file.patch using a patch applied to a single file, with the patch
4171         coming from a remote source.
4172         """
4173         ret = self.run_state(
4174             "file.patch",
4175             name=self.math_file,
4176             source=self.math_patch_http,
4177         )
4178         self.assertSaltFalseReturn(ret)
4179         ret = ret[next(iter(ret))]
4180         self.assertIn("Unable to verify upstream hash", ret["comment"])
4181         ret = self.run_state(
4182             "file.patch",
4183             name=self.math_file,
4184             source=self.math_patch_http,
4185             source_hash=self.math_patch_hash,
4186         )
4187         self.assertSaltTrueReturn(ret)
4188         ret = ret[next(iter(ret))]
4189         self.assertEqual(ret["comment"], "Patch successfully applied")
4190         ret = self.run_state(
4191             "file.patch",
4192             name=self.math_file,
4193             source=self.math_patch_http,
4194             skip_verify=True,
4195         )
4196         self.assertSaltTrueReturn(ret)
4197         ret = ret[next(iter(ret))]
4198         self.assertEqual(ret["comment"], "Patch was already applied")
4199         self.assertEqual(ret["changes"], {})
4200     def test_patch_directory_remote_source(self):
4201         """
4202         Test file.patch using a patch applied to a directory, with changes
4203         spanning multiple files, and the patch file coming from a remote
4204         source.
4205         """
4206         self._check_patch_version("2.6")
4207         ret = self.run_state(
4208             "file.patch",
4209             name=self.base_dir,
4210             source=self.all_patch_http,
4211             strip=1,
4212         )
4213         self.assertSaltFalseReturn(ret)
4214         ret = ret[next(iter(ret))]
4215         self.assertIn("Unable to verify upstream hash", ret["comment"])
4216         ret = self.run_state(
4217             "file.patch",
4218             name=self.base_dir,
4219             source=self.all_patch_http,
4220             source_hash=self.all_patch_hash,
4221             strip=1,
4222         )
4223         self.assertSaltTrueReturn(ret)
4224         ret = ret[next(iter(ret))]
4225         self.assertEqual(ret["comment"], "Patch successfully applied")
4226         ret = self.run_state(
4227             "file.patch",
4228             name=self.base_dir,
4229             source=self.all_patch_http,
4230             strip=1,
4231             skip_verify=True,
4232         )
4233         self.assertSaltTrueReturn(ret)
4234         ret = ret[next(iter(ret))]
4235         self.assertEqual(ret["comment"], "Patch was already applied")
4236         self.assertEqual(ret["changes"], {})
4237     def test_patch_single_file_template(self):
4238         """
4239         Test file.patch using a patch applied to a single file, with jinja
4240         templating applied to the patch file.
4241         """
4242         ret = self.run_state(
4243             "file.patch",
4244             name=self.numbers_file,
4245             source=self.numbers_patch_template,
4246             template="jinja",
4247             context=self.context,
4248         )
4249         self.assertSaltTrueReturn(ret)
4250         ret = ret[next(iter(ret))]
4251         self.assertEqual(ret["comment"], "Patch successfully applied")
4252         ret = self.run_state(
4253             "file.patch",
4254             name=self.numbers_file,
4255             source=self.numbers_patch_template,
4256             template="jinja",
4257             context=self.context,
4258         )
4259         self.assertSaltTrueReturn(ret)
4260         ret = ret[next(iter(ret))]
4261         self.assertEqual(ret["comment"], "Patch was already applied")
4262         self.assertEqual(ret["changes"], {})
4263     def test_patch_directory_template(self):
4264         """
4265         Test file.patch using a patch applied to a directory, with changes
4266         spanning multiple files, and with jinja templating applied to the patch
4267         file.
4268         """
4269         self._check_patch_version("2.6")
4270         ret = self.run_state(
4271             "file.patch",
4272             name=self.base_dir,
4273             source=self.all_patch_template,
4274             template="jinja",
4275             context=self.context,
4276             strip=1,
4277         )
4278         self.assertSaltTrueReturn(ret)
4279         ret = ret[next(iter(ret))]
4280         self.assertEqual(ret["comment"], "Patch successfully applied")
4281         ret = self.run_state(
4282             "file.patch",
4283             name=self.base_dir,
4284             source=self.all_patch_template,
4285             template="jinja",
4286             context=self.context,
4287             strip=1,
4288         )
4289         self.assertSaltTrueReturn(ret)
4290         ret = ret[next(iter(ret))]
4291         self.assertEqual(ret["comment"], "Patch was already applied")
4292         self.assertEqual(ret["changes"], {})
4293     def test_patch_single_file_remote_source_template(self):
4294         """
4295         Test file.patch using a patch applied to a single file, with the patch
4296         coming from a remote source.
4297         """
4298         ret = self.run_state(
4299             "file.patch",
4300             name=self.math_file,
4301             source=self.math_patch_template_http,
4302             template="jinja",
4303             context=self.context,
4304         )
4305         self.assertSaltFalseReturn(ret)
4306         ret = ret[next(iter(ret))]
4307         self.assertIn("Unable to verify upstream hash", ret["comment"])
4308         ret = self.run_state(
4309             "file.patch",
4310             name=self.math_file,
4311             source=self.math_patch_template_http,
4312             source_hash=self.math_patch_template_hash,
4313             template="jinja",
4314             context=self.context,
4315         )
4316         self.assertSaltTrueReturn(ret)
4317         ret = ret[next(iter(ret))]
4318         self.assertEqual(ret["comment"], "Patch successfully applied")
4319         ret = self.run_state(
4320             "file.patch",
4321             name=self.math_file,
4322             source=self.math_patch_template_http,
4323             template="jinja",
4324             context=self.context,
4325             skip_verify=True,
4326         )
4327         self.assertSaltTrueReturn(ret)
4328         ret = ret[next(iter(ret))]
4329         self.assertEqual(ret["comment"], "Patch was already applied")
4330         self.assertEqual(ret["changes"], {})
4331     def test_patch_directory_remote_source_template(self):
4332         """
4333         Test file.patch using a patch applied to a directory, with changes
4334         spanning multiple files, and the patch file coming from a remote
4335         source.
4336         """
4337         self._check_patch_version("2.6")
4338         ret = self.run_state(
4339             "file.patch",
4340             name=self.base_dir,
4341             source=self.all_patch_template_http,
4342             template="jinja",
4343             context=self.context,
4344             strip=1,
4345         )
4346         self.assertSaltFalseReturn(ret)
4347         ret = ret[next(iter(ret))]
4348         self.assertIn("Unable to verify upstream hash", ret["comment"])
4349         ret = self.run_state(
4350             "file.patch",
4351             name=self.base_dir,
4352             source=self.all_patch_template_http,
4353             source_hash=self.all_patch_template_hash,
4354             template="jinja",
4355             context=self.context,
4356             strip=1,
4357         )
4358         self.assertSaltTrueReturn(ret)
4359         ret = ret[next(iter(ret))]
4360         self.assertEqual(ret["comment"], "Patch successfully applied")
4361         ret = self.run_state(
4362             "file.patch",
4363             name=self.base_dir,
4364             source=self.all_patch_template_http,
4365             template="jinja",
4366             context=self.context,
4367             strip=1,
4368             skip_verify=True,
4369         )
4370         self.assertSaltTrueReturn(ret)
4371         ret = ret[next(iter(ret))]
4372         self.assertEqual(ret["comment"], "Patch was already applied")
4373         self.assertEqual(ret["changes"], {})
4374     def test_patch_test_mode(self):
4375         """
4376         Test file.patch using test=True
4377         """
4378         ret = self.run_state(
4379             "file.patch",
4380             name=self.numbers_file,
4381             source=self.numbers_patch,
4382             test=True,
4383         )
4384         self.assertSaltNoneReturn(ret)
4385         ret = ret[next(iter(ret))]
4386         self.assertEqual(ret["comment"], "The patch would be applied")
4387         self.assertTrue(ret["changes"])
4388         ret = self.run_state(
4389             "file.patch",
4390             name=self.numbers_file,
4391             source=self.numbers_patch,
4392         )
4393         self.assertSaltTrueReturn(ret)
4394         ret = ret[next(iter(ret))]
4395         self.assertEqual(ret["comment"], "Patch successfully applied")
4396         self.assertTrue(ret["changes"])
4397         ret = self.run_state(
4398             "file.patch",
4399             name=self.numbers_file,
4400             source=self.numbers_patch,
4401             test=True,
4402         )
4403         self.assertSaltTrueReturn(ret)
4404         ret = ret[next(iter(ret))]
4405         self.assertEqual(ret["comment"], "Patch was already applied")
4406         self.assertEqual(ret["changes"], {})
4407         with salt.utils.files.fopen(self.numbers_file, "w"):
4408             pass
4409         ret = self.run_state(
4410             "file.patch",
4411             name=self.numbers_file,
4412             source=self.numbers_patch,
4413             test=True,
4414         )
4415         self.assertSaltFalseReturn(ret)
4416         ret = ret[next(iter(ret))]
4417         self.assertIn("Patch would not apply cleanly", ret["comment"])
4418         self.assertEqual(ret["changes"], {})
4419 WIN_TEST_FILE = "c:/testfile"
4420 @pytest.mark.destructive_test
4421 @skipIf(not IS_WINDOWS, "windows test only")
4422 @pytest.mark.windows_whitelisted
4423 class WinFileTest(ModuleCase):
4424     """
4425     Test for the file state on Windows
4426     """
4427     def setUp(self):
4428         self.run_state(
4429             "file.managed", name=WIN_TEST_FILE, makedirs=True, contents="Only a test"
4430         )
4431     def tearDown(self):
4432         self.run_state("file.absent", name=WIN_TEST_FILE)
4433     def test_file_managed(self):
4434         """
4435         Test file.managed on Windows
4436         """
4437         self.assertTrue(self.run_state("file.exists", name=WIN_TEST_FILE))
4438     def test_file_copy(self):
4439         """
4440         Test file.copy on Windows
4441         """
4442         ret = self.run_state(
4443             "file.copy", name="c:/testfile_copy", makedirs=True, source=WIN_TEST_FILE
4444         )
4445         self.assertTrue(ret)
4446     def test_file_comment(self):
4447         """
4448         Test file.comment on Windows
4449         """
4450         self.run_state("file.comment", name=WIN_TEST_FILE, regex="^Only")
4451         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
4452             self.assertTrue(fp_.read().startswith("#Only"))
4453     def test_file_replace(self):
4454         """
4455         Test file.replace on Windows
4456         """
4457         self.run_state(
4458             "file.replace", name=WIN_TEST_FILE, pattern="test", repl="testing"
4459         )
4460         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
4461             self.assertIn("testing", fp_.read())
4462     def test_file_absent(self):
4463         """
4464         Test file.absent on Windows
4465         """
4466         ret = self.run_state("file.absent", name=WIN_TEST_FILE)
4467         self.assertTrue(ret)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
