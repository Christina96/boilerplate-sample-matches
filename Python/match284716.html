<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_netbox.py &amp; schedule.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_netbox.py &amp; schedule.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_netbox.py (1.4380531%)<th>schedule.py (0.4571027%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1906-1915)<td><a href="#" name="0">(899-904)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_netbox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import salt.pillar.netbox as netbox
3 from tests.support.mock import patch
4 @pytest.fixture
5 def default_kwargs():
6     return {
7         "minion_id": "minion1",
8         "pillar": None,
9         "api_url": "http://netbox.example.com",
10         "api_token": "yeic5oocizei7owuichoesh8ooqu6oob3uWiey9a",
11         "api_query_result_limit": 65535,
12     }
13 @pytest.fixture
14 def headers():
15     return {"Authorization": "Token quin1Di5MoRooChaiph3Aenaxais5EeY1gie6eev"}
16 @pytest.fixture
17 def device_results():
18     return {
19         "dict": {
20             "count": 1,
21             "next": None,
22             "previous": None,
23             "results": [
24                 {
25                     "id": 511,
26                     "url": "https://netbox.example.com/api/dcim/devices/511/",
27                     "name": "minion1",
28                     "display_name": "minion1",
29                     "device_type": {
30                         "id": 4,
31                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
32                         "manufacturer": {
33                             "id": 1,
34                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
35                             "name": "Cisco",
36                             "slug": "cisco",
37                         },
38                         "model": "ISR2901",
39                         "slug": "isr2901",
40                         "display_name": "Cisco ISR2901",
41                     },
42                     "device_role": {
43                         "id": 45,
44                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
45                         "name": "Network",
46                         "slug": "network",
47                     },
48                     "node_type": "device",
49                     "tenant": None,
50                     "platform": {
51                         "id": 1,
52                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
53                         "name": "Cisco IOS",
54                         "slug": "ios",
55                     },
56                     "serial": "",
57                     "asset_tag": None,
58                     "site": {
59                         "id": 18,
60                         "url": "https://netbox.example.com/api/dcim/sites/18/",
61                         "name": "Site 1",
62                         "slug": "site1",
63                     },
64                     "rack": None,
65                     "position": None,
66                     "face": None,
67                     "parent_device": None,
68                     "status": {"value": "active", "label": "Active"},
69                     "primary_ip": {
70                         "id": 1146,
71                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
72                         "family": 4,
73                         "address": "192.0.2.1/24",
74                     },
75                     "primary_ip4": {
76                         "id": 1146,
77                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
78                         "family": 4,
79                         "address": "192.0.2.1/24",
80                     },
81                     "primary_ip6": None,
82                     "cluster": None,
83                     "virtual_chassis": None,
84                     "vc_position": None,
85                     "vc_priority": None,
86                     "comments": "",
87                     "local_context_data": None,
88                     "tags": [],
89                     "custom_fields": {},
90                     "config_context": {},
91                     "created": "2021-02-19",
92                     "last_updated": "2021-02-19T06:12:04.171105Z",
93                 }
94             ],
95         }
96     }
97 @pytest.fixture
98 def multiple_device_results():
99     return {
100         "dict": {
101             "count": 2,
102             "next": None,
103             "previous": None,
104             "results": [
105                 {
106                     "id": 511,
107                     "url": "https://netbox.example.com/api/dcim/devices/511/",
108                     "name": "minion1",
109                     "display_name": "minion1",
110                     "device_type": {
111                         "id": 4,
112                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
113                         "manufacturer": {
114                             "id": 1,
115                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
116                             "name": "Cisco",
117                             "slug": "cisco",
118                         },
119                         "model": "ISR2901",
120                         "slug": "isr2901",
121                         "display_name": "Cisco ISR2901",
122                     },
123                     "device_role": {
124                         "id": 45,
125                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
126                         "name": "Network",
127                         "slug": "network",
128                     },
129                     "node_type": "device",
130                     "tenant": None,
131                     "platform": {
132                         "id": 1,
133                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
134                         "name": "Cisco IOS",
135                         "slug": "ios",
136                     },
137                     "serial": "",
138                     "asset_tag": None,
139                     "site": {
140                         "id": 18,
141                         "url": "https://netbox.example.com/api/dcim/sites/18/",
142                         "name": "Site 1",
143                         "slug": "site1",
144                     },
145                     "rack": None,
146                     "position": None,
147                     "face": None,
148                     "parent_device": None,
149                     "status": {"value": "active", "label": "Active"},
150                     "primary_ip": {
151                         "id": 1146,
152                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
153                         "family": 4,
154                         "address": "192.0.2.1/24",
155                     },
156                     "primary_ip4": {
157                         "id": 1146,
158                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
159                         "family": 4,
160                         "address": "192.0.2.1/24",
161                     },
162                     "primary_ip6": None,
163                     "cluster": None,
164                     "virtual_chassis": None,
165                     "vc_position": None,
166                     "vc_priority": None,
167                     "comments": "",
168                     "local_context_data": None,
169                     "tags": [],
170                     "custom_fields": {},
171                     "config_context": {},
172                     "created": "2021-02-19",
173                     "last_updated": "2021-02-19T06:12:04.171105Z",
174                 },
175                 {
176                     "id": 512,
177                     "url": "https://netbox.example.com/api/dcim/devices/512/",
178                     "name": "minion1",
179                     "display_name": "minion1",
180                     "device_type": {
181                         "id": 4,
182                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
183                         "manufacturer": {
184                             "id": 1,
185                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
186                             "name": "Cisco",
187                             "slug": "cisco",
188                         },
189                         "model": "ISR2901",
190                         "slug": "isr2901",
191                         "display_name": "Cisco ISR2901",
192                     },
193                     "device_role": {
194                         "id": 45,
195                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
196                         "name": "Network",
197                         "slug": "network",
198                     },
199                     "node_type": "device",
200                     "tenant": None,
201                     "platform": {
202                         "id": 1,
203                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
204                         "name": "Cisco IOS",
205                         "slug": "ios",
206                     },
207                     "serial": "",
208                     "asset_tag": None,
209                     "site": {
210                         "id": 18,
211                         "url": "https://netbox.example.com/api/dcim/sites/18/",
212                         "name": "Site 1",
213                         "slug": "site1",
214                     },
215                     "rack": None,
216                     "position": None,
217                     "face": None,
218                     "parent_device": None,
219                     "status": {"value": "active", "label": "Active"},
220                     "primary_ip": {
221                         "id": 1150,
222                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1150/",
223                         "family": 4,
224                         "address": "192.0.2.3/24",
225                     },
226                     "primary_ip4": {
227                         "id": 1150,
228                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1150/",
229                         "family": 4,
230                         "address": "192.0.2.3/24",
231                     },
232                     "primary_ip6": None,
233                     "cluster": None,
234                     "virtual_chassis": None,
235                     "vc_position": None,
236                     "vc_priority": None,
237                     "comments": "",
238                     "local_context_data": None,
239                     "tags": [],
240                     "custom_fields": {},
241                     "config_context": {},
242                     "created": "2021-02-19",
243                     "last_updated": "2021-02-19T06:12:04.171105Z",
244                 },
245             ],
246         }
247     }
248 @pytest.fixture
249 def virtual_machine_results():
250     return {
251         "dict": {
252             "count": 1,
253             "next": None,
254             "previous": None,
255             "results": [
256                 {
257                     "id": 222,
258                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
259                     "name": "minion1",
260                     "status": {"value": "active", "label": "Active"},
261                     "site": {
262                         "id": 18,
263                         "url": "https://netbox.example.com/api/dcim/sites/18/",
264                         "name": "Site 1",
265                         "slug": "site1",
266                     },
267                     "cluster": {
268                         "id": 1,
269                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
270                         "name": "Cluster",
271                     },
272                     "role": {
273                         "id": 45,
274                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
275                         "name": "Network",
276                         "slug": "network",
277                     },
278                     "node_type": "virtual-machine",
279                     "tenant": None,
280                     "platform": {
281                         "id": 1,
282                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
283                         "name": "Cisco IOS",
284                         "slug": "ios",
285                     },
286                     "primary_ip": {
287                         "id": 1148,
288                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
289                         "family": 4,
290                         "address": "192.0.2.2/24",
291                     },
292                     "primary_ip4": {
293                         "id": 1148,
294                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
295                         "family": 4,
296                         "address": "192.0.2.2/24",
297                     },
298                     "primary_ip6": None,
299                     "vcpus": 1,
300                     "memory": 1024,
301                     "disk": 30,
302                     "comments": "",
303                     "local_context_data": None,
304                     "tags": [],
305                     "custom_fields": {},
306                     "config_context": {},
307                     "created": "2021-02-19",
308                     "last_updated": "2021-02-19T06:23:05.799541Z",
309                 }
310             ],
311         }
312     }
313 @pytest.fixture
314 def multiple_virtual_machine_results():
315     return {
316         "dict": {
317             "count": 1,
318             "next": None,
319             "previous": None,
320             "results": [
321                 {
322                     "id": 222,
323                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
324                     "name": "minion1",
325                     "status": {"value": "active", "label": "Active"},
326                     "site": {
327                         "id": 18,
328                         "url": "https://netbox.example.com/api/dcim/sites/18/",
329                         "name": "Site 1",
330                         "slug": "site1",
331                     },
332                     "cluster": {
333                         "id": 1,
334                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
335                         "name": "Cluster",
336                     },
337                     "role": {
338                         "id": 45,
339                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
340                         "name": "Network",
341                         "slug": "network",
342                     },
343                     "node_type": "virtual-machine",
344                     "tenant": None,
345                     "platform": {
346                         "id": 1,
347                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
348                         "name": "Cisco IOS",
349                         "slug": "ios",
350                     },
351                     "primary_ip": {
352                         "id": 1148,
353                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
354                         "family": 4,
355                         "address": "192.0.2.2/24",
356                     },
357                     "primary_ip4": {
358                         "id": 1148,
359                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
360                         "family": 4,
361                         "address": "192.0.2.2/24",
362                     },
363                     "primary_ip6": None,
364                     "vcpus": 1,
365                     "memory": 1024,
366                     "disk": 30,
367                     "comments": "",
368                     "local_context_data": None,
369                     "tags": [],
370                     "custom_fields": {},
371                     "config_context": {},
372                     "created": "2021-02-19",
373                     "last_updated": "2021-02-19T06:23:05.799541Z",
374                 },
375                 {
376                     "id": 223,
377                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/223/",
378                     "name": "minion1",
379                     "status": {"value": "active", "label": "Active"},
380                     "site": {
381                         "id": 18,
382                         "url": "https://netbox.example.com/api/dcim/sites/18/",
383                         "name": "Site 1",
384                         "slug": "site1",
385                     },
386                     "cluster": {
387                         "id": 1,
388                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
389                         "name": "Cluster",
390                     },
391                     "role": {
392                         "id": 45,
393                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
394                         "name": "Network",
395                         "slug": "network",
396                     },
397                     "node_type": "virtual-machine",
398                     "tenant": None,
399                     "platform": {
400                         "id": 1,
401                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
402                         "name": "Cisco IOS",
403                         "slug": "ios",
404                     },
405                     "primary_ip": {
406                         "id": 1152,
407                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1152/",
408                         "family": 4,
409                         "address": "192.0.2.4/24",
410                     },
411                     "primary_ip4": {
412                         "id": 1152,
413                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1152/",
414                         "family": 4,
415                         "address": "192.0.2.4/24",
416                     },
417                     "primary_ip6": None,
418                     "vcpus": 1,
419                     "memory": 1024,
420                     "disk": 30,
421                     "comments": "",
422                     "local_context_data": None,
423                     "tags": [],
424                     "custom_fields": {},
425                     "config_context": {},
426                     "created": "2021-02-19",
427                     "last_updated": "2021-02-19T06:23:05.799541Z",
428                 },
429             ],
430         }
431     }
432 @pytest.fixture
433 def no_results():
434     return {"dict": {"count": 0, "next": None, "previous": None, "results": []}}
435 @pytest.fixture
436 def http_error():
437     return {"error": "HTTP 404: Not Found", "status": 404}
438 @pytest.fixture
439 def device_interface_results():
440     return {
441         "dict": {
442             "count": 2,
443             "next": None,
444             "previous": None,
445             "results": [
446                 {
447                     "id": 8158,
448                     "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
449                     "device": {
450                         "id": 511,
451                         "url": "https://netbox.example.com/api/dcim/devices/511/",
452                         "name": "minion1",
453                         "display_name": "minion1",
454                     },
455                     "name": "GigabitEthernet0/0",
456                     "label": "",
457                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
458                     "enabled": True,
459                     "lag": None,
460                     "mtu": None,
461                     "mac_address": None,
462                     "mgmt_only": False,
463                     "description": "",
464                     "mode": None,
465                     "untagged_vlan": None,
466                     "tagged_vlans": [],
467                     "cable": None,
468                     "cable_peer": None,
469                     "cable_peer_type": None,
470                     "connected_endpoint": None,
471                     "connected_endpoint_type": None,
472                     "connected_endpoint_reachable": None,
473                     "tags": [],
474                     "count_ipaddresses": 1,
475                 },
476                 {
477                     "id": 8159,
478                     "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
479                     "device": {
480                         "id": 511,
481                         "url": "https://netbox.example.com/api/dcim/devices/511/",
482                         "name": "minion1",
483                         "display_name": "minion1",
484                     },
485                     "name": "GigabitEthernet0/1",
486                     "label": "",
487                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
488                     "enabled": True,
489                     "lag": None,
490                     "mtu": None,
491                     "mac_address": None,
492                     "mgmt_only": False,
493                     "description": "",
494                     "mode": None,
495                     "untagged_vlan": None,
496                     "tagged_vlans": [],
497                     "cable": None,
498                     "cable_peer": None,
499                     "cable_peer_type": None,
500                     "connected_endpoint": None,
501                     "connected_endpoint_type": None,
502                     "connected_endpoint_reachable": None,
503                     "tags": [],
504                     "count_ipaddresses": 1,
505                 },
506             ],
507         }
508     }
509 @pytest.fixture
510 def device_interfaces_list():
511     return [
512         {
513             "id": 8158,
514             "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
515             "name": "GigabitEthernet0/0",
516             "label": "",
517             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
518             "enabled": True,
519             "lag": None,
520             "mtu": None,
521             "mac_address": None,
522             "mgmt_only": False,
523             "description": "",
524             "mode": None,
525             "untagged_vlan": None,
526             "tagged_vlans": [],
527             "cable": None,
528             "cable_peer": None,
529             "cable_peer_type": None,
530             "connected_endpoint": None,
531             "connected_endpoint_type": None,
532             "connected_endpoint_reachable": None,
533             "tags": [],
534             "count_ipaddresses": 1,
535         },
536         {
537             "id": 8159,
538             "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
539             "name": "GigabitEthernet0/1",
540             "label": "",
541             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
542             "enabled": True,
543             "lag": None,
544             "mtu": None,
545             "mac_address": None,
546             "mgmt_only": False,
547             "description": "",
548             "mode": None,
549             "untagged_vlan": None,
550             "tagged_vlans": [],
551             "cable": None,
552             "cable_peer": None,
553             "cable_peer_type": None,
554             "connected_endpoint": None,
555             "connected_endpoint_type": None,
556             "connected_endpoint_reachable": None,
557             "tags": [],
558             "count_ipaddresses": 1,
559         },
560     ]
561 @pytest.fixture
562 def virtual_machine_interface_results():
563     return {
564         "dict": {
565             "count": 2,
566             "next": None,
567             "previous": None,
568             "results": [
569                 {
570                     "id": 668,
571                     "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
572                     "virtual_machine": {
573                         "id": 222,
574                         "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
575                         "name": "minion1",
576                     },
577                     "name": "GigabitEthernet0/0",
578                     "enabled": True,
579                     "mtu": None,
580                     "mac_address": None,
581                     "description": "",
582                     "mode": None,
583                     "untagged_vlan": None,
584                     "tagged_vlans": [],
585                     "tags": [],
586                 },
587                 {
588                     "id": 669,
589                     "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
590                     "virtual_machine": {
591                         "id": 222,
592                         "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
593                         "name": "minion1",
594                     },
595                     "name": "GigabitEthernet0/1",
596                     "enabled": True,
597                     "mtu": None,
598                     "mac_address": None,
599                     "description": "",
600                     "mode": None,
601                     "untagged_vlan": None,
602                     "tagged_vlans": [],
603                     "tags": [],
604                 },
605             ],
606         }
607     }
608 @pytest.fixture
609 def virtual_machine_interfaces_list():
610     return [
611         {
612             "id": 668,
613             "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
614             "name": "GigabitEthernet0/0",
615             "enabled": True,
616             "mtu": None,
617             "mac_address": None,
618             "description": "",
619             "mode": None,
620             "untagged_vlan": None,
621             "tagged_vlans": [],
622             "tags": [],
623         },
624         {
625             "id": 669,
626             "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
627             "name": "GigabitEthernet0/1",
628             "enabled": True,
629             "mtu": None,
630             "mac_address": None,
631             "description": "",
632             "mode": None,
633             "untagged_vlan": None,
634             "tagged_vlans": [],
635             "tags": [],
636         },
637     ]
638 @pytest.fixture
639 def device_ip_results():
640     return {
641         "dict": {
642             "count": 2,
643             "next": None,
644             "previous": None,
645             "results": [
646                 {
647                     "id": 1146,
648                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
649                     "family": {"value": 4, "label": "IPv4"},
650                     "address": "192.0.2.1/24",
651                     "vrf": None,
652                     "tenant": None,
653                     "status": {"value": "active", "label": "Active"},
654                     "role": None,
655                     "assigned_object_type": "dcim.interface",
656                     "assigned_object_id": 8158,
657                     "assigned_object": {
658                         "id": 8158,
659                         "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
660                         "device": {
661                             "id": 511,
662                             "url": "https://netbox.example.com/api/dcim/devices/511/",
663                             "name": "minion1",
664                             "display_name": "minion1",
665                         },
666                         "name": "GigabitEthernet0/0",
667                         "cable": None,
668                     },
669                     "nat_inside": None,
670                     "nat_outside": None,
671                     "dns_name": "",
672                     "description": "",
673                     "tags": [],
674                     "custom_fields": {},
675                     "created": "2021-02-19",
676                     "last_updated": "2021-02-19T06:12:04.153386Z",
677                 },
678                 {
679                     "id": 1147,
680                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
681                     "family": {"value": 4, "label": "IPv4"},
682                     "address": "198.51.100.1/24",
683                     "vrf": None,
684                     "tenant": None,
685                     "status": {"value": "active", "label": "Active"},
686                     "role": None,
687                     "assigned_object_type": "dcim.interface",
688                     "assigned_object_id": 8159,
689                     "assigned_object": {
690                         "id": 8159,
691                         "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
692                         "device": {
693                             "id": 511,
694                             "url": "https://netbox.example.com/api/dcim/devices/511/",
695                             "name": "minion1",
696                             "display_name": "minion1",
697                         },
698                         "name": "GigabitEthernet0/1",
699                         "cable": None,
700                     },
701                     "nat_inside": None,
702                     "nat_outside": None,
703                     "dns_name": "",
704                     "description": "",
705                     "tags": [],
706                     "custom_fields": {},
707                     "created": "2021-02-19",
708                     "last_updated": "2021-02-19T06:12:40.508154Z",
709                 },
710             ],
711         }
712     }
713 @pytest.fixture
714 def virtual_machine_ip_results():
715     return {
716         "dict": {
717             "count": 2,
718             "next": None,
719             "previous": None,
720             "results": [
721                 {
722                     "id": 1148,
723                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
724                     "family": {"value": 4, "label": "IPv4"},
725                     "address": "192.0.2.2/24",
726                     "vrf": None,
727                     "tenant": None,
728                     "status": {"value": "active", "label": "Active"},
729                     "role": None,
730                     "assigned_object_type": "virtualization.vminterface",
731                     "assigned_object_id": 668,
732                     "assigned_object": {
733                         "id": 668,
734                         "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
735                         "virtual_machine": {
736                             "id": 222,
737                             "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
738                             "name": "minion1",
739                         },
740                         "name": "GigabitEthernet0/0",
741                     },
742                     "nat_inside": None,
743                     "nat_outside": None,
744                     "dns_name": "",
745                     "description": "",
746                     "tags": [],
747                     "custom_fields": {},
748                     "created": "2021-02-19",
749                     "last_updated": "2021-02-19T06:23:05.784281Z",
750                 },
751                 {
752                     "id": 1149,
753                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1149/",
754                     "family": {"value": 4, "label": "IPv4"},
755                     "address": "198.51.100.2/24",
756                     "vrf": None,
757                     "tenant": None,
758                     "status": {"value": "active", "label": "Active"},
759                     "role": None,
760                     "assigned_object_type": "virtualization.vminterface",
761                     "assigned_object_id": 669,
762                     "assigned_object": {
763                         "id": 669,
764                         "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
765                         "virtual_machine": {
766                             "id": 222,
767                             "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
768                             "name": "minion1",
769                         },
770                         "name": "GigabitEthernet0/1",
771                     },
772                     "nat_inside": None,
773                     "nat_outside": None,
774                     "dns_name": "",
775                     "description": "",
776                     "tags": [],
777                     "custom_fields": {},
778                     "created": "2021-02-19",
779                     "last_updated": "2021-02-19T06:23:29.607428Z",
780                 },
781             ],
782         }
783     }
784 @pytest.fixture
785 def device_interfaces_ip_list():
786     return [
787         {
788             "id": 8158,
789             "ip_addresses": [
790                 {
791                     "id": 1146,
792                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
793                     "family": {"value": 4, "label": "IPv4"},
794                     "address": "192.0.2.1/24",
795                     "vrf": None,
796                     "tenant": None,
797                     "status": {"value": "active", "label": "Active"},
798                     "role": None,
799                     "nat_inside": None,
800                     "nat_outside": None,
801                     "dns_name": "",
802                     "description": "",
803                     "tags": [],
804                     "custom_fields": {},
805                     "created": "2021-02-19",
806                     "last_updated": "2021-02-19T06:12:04.153386Z",
807                 },
808             ],
809             "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
810             "name": "GigabitEthernet0/0",
811             "label": "",
812             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
813             "enabled": True,
814             "lag": None,
815             "mtu": None,
816             "mac_address": None,
817             "mgmt_only": False,
818             "description": "",
819             "mode": None,
820             "untagged_vlan": None,
821             "tagged_vlans": [],
822             "cable": None,
823             "cable_peer": None,
824             "cable_peer_type": None,
825             "connected_endpoint": None,
826             "connected_endpoint_type": None,
827             "connected_endpoint_reachable": None,
828             "tags": [],
829             "count_ipaddresses": 1,
830         },
831         {
832             "id": 8159,
833             "ip_addresses": [
834                 {
835                     "id": 1147,
836                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
837                     "family": {"value": 4, "label": "IPv4"},
838                     "address": "198.51.100.1/24",
839                     "vrf": None,
840                     "tenant": None,
841                     "status": {"value": "active", "label": "Active"},
842                     "role": None,
843                     "nat_inside": None,
844                     "nat_outside": None,
845                     "dns_name": "",
846                     "description": "",
847                     "tags": [],
848                     "custom_fields": {},
849                     "created": "2021-02-19",
850                     "last_updated": "2021-02-19T06:12:40.508154Z",
851                 },
852             ],
853             "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
854             "name": "GigabitEthernet0/1",
855             "label": "",
856             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
857             "enabled": True,
858             "lag": None,
859             "mtu": None,
860             "mac_address": None,
861             "mgmt_only": False,
862             "description": "",
863             "mode": None,
864             "untagged_vlan": None,
865             "tagged_vlans": [],
866             "cable": None,
867             "cable_peer": None,
868             "cable_peer_type": None,
869             "connected_endpoint": None,
870             "connected_endpoint_type": None,
871             "connected_endpoint_reachable": None,
872             "tags": [],
873             "count_ipaddresses": 1,
874         },
875     ]
876 @pytest.fixture
877 def virtual_machine_interfaces_ip_list():
878     return [
879         {
880             "id": 668,
881             "ip_addresses": [
882                 {
883                     "id": 1148,
884                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
885                     "family": {"value": 4, "label": "IPv4"},
886                     "address": "192.0.2.2/24",
887                     "vrf": None,
888                     "tenant": None,
889                     "status": {"value": "active", "label": "Active"},
890                     "role": None,
891                     "nat_inside": None,
892                     "nat_outside": None,
893                     "dns_name": "",
894                     "description": "",
895                     "tags": [],
896                     "custom_fields": {},
897                     "created": "2021-02-19",
898                     "last_updated": "2021-02-19T06:23:05.784281Z",
899                 },
900             ],
901             "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
902             "name": "GigabitEthernet0/0",
903             "enabled": True,
904             "mtu": None,
905             "mac_address": None,
906             "description": "",
907             "mode": None,
908             "untagged_vlan": None,
909             "tagged_vlans": [],
910             "tags": [],
911         },
912         {
913             "id": 669,
914             "ip_addresses": [
915                 {
916                     "id": 1149,
917                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1149/",
918                     "family": {"value": 4, "label": "IPv4"},
919                     "address": "198.51.100.2/24",
920                     "vrf": None,
921                     "tenant": None,
922                     "status": {"value": "active", "label": "Active"},
923                     "role": None,
924                     "nat_inside": None,
925                     "nat_outside": None,
926                     "dns_name": "",
927                     "description": "",
928                     "tags": [],
929                     "custom_fields": {},
930                     "created": "2021-02-19",
931                     "last_updated": "2021-02-19T06:23:29.607428Z",
932                 },
933             ],
934             "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
935             "name": "GigabitEthernet0/1",
936             "enabled": True,
937             "mtu": None,
938             "mac_address": None,
939             "description": "",
940             "mode": None,
941             "untagged_vlan": None,
942             "tagged_vlans": [],
943             "tags": [],
944         },
945     ]
946 @pytest.fixture
947 def site_results():
948     return {
949         "dict": {
950             "id": 18,
951             "url": "https://netbox.example.com/api/dcim/sites/18/",
952             "name": "Site 1",
953             "slug": "site1",
954             "status": {"value": "active", "label": "Active"},
955             "region": None,
956             "tenant": None,
957             "facility": "",
958             "asn": None,
959             "time_zone": None,
960             "description": "",
961             "physical_address": "",
962             "shipping_address": "",
963             "latitude": None,
964             "longitude": None,
965             "contact_name": "",
966             "contact_phone": "",
967             "contact_email": "",
968             "comments": "",
969             "tags": [],
970             "custom_fields": {},
971             "created": "2021-02-25",
972             "last_updated": "2021-02-25T14:21:07.898957Z",
973             "circuit_count": 0,
974             "device_count": 1,
975             "prefix_count": 2,
976             "rack_count": 0,
977             "virtualmachine_count": 1,
978             "vlan_count": 0,
979         }
980     }
981 @pytest.fixture
982 def site_prefixes_results():
983     return {
984         "dict": {
985             "count": 2,
986             "next": None,
987             "previous": None,
988             "results": [
989                 {
990                     "id": 284,
991                     "url": "https://netbox.example.com/api/ipam/prefixes/284/",
992                     "family": {"value": 4, "label": "IPv4"},
993                     "prefix": "192.0.2.0/24",
994                     "site": {
995                         "id": 18,
996                         "url": "https://netbox.example.com/api/dcim/sites/18/",
997                         "name": "Site 1",
998                         "slug": "site1",
999                     },
1000                     "vrf": None,
1001                     "tenant": None,
1002                     "vlan": None,
1003                     "status": {"value": "active", "label": "Active"},
1004                     "role": None,
1005                     "is_pool": False,
1006                     "description": "",
1007                     "tags": [],
1008                     "custom_fields": {},
1009                     "created": "2021-02-25",
1010                     "last_updated": "2021-02-25T15:08:27.136305Z",
1011                 },
1012                 {
1013                     "id": 285,
1014                     "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1015                     "family": {"value": 4, "label": "IPv4"},
1016                     "prefix": "198.51.100.0/24",
1017                     "site": {
1018                         "id": 18,
1019                         "url": "https://netbox.example.com/api/dcim/sites/18/",
1020                         "name": "Site 1",
1021                         "slug": "site1",
1022                     },
1023                     "vrf": None,
1024                     "tenant": None,
1025                     "vlan": None,
1026                     "status": {"value": "active", "label": "Active"},
1027                     "role": None,
1028                     "is_pool": False,
1029                     "description": "",
1030                     "tags": [],
1031                     "custom_fields": {},
1032                     "created": "2021-02-25",
1033                     "last_updated": "2021-02-25T15:08:59.880440Z",
1034                 },
1035             ],
1036         }
1037     }
1038 @pytest.fixture
1039 def site_prefixes():
1040     return [
1041         {
1042             "id": 284,
1043             "url": "https://netbox.example.com/api/ipam/prefixes/284/",
1044             "family": {"value": 4, "label": "IPv4"},
1045             "prefix": "192.0.2.0/24",
1046             "vrf": None,
1047             "tenant": None,
1048             "vlan": None,
1049             "status": {"value": "active", "label": "Active"},
1050             "role": None,
1051             "is_pool": False,
1052             "description": "",
1053             "tags": [],
1054             "custom_fields": {},
1055             "created": "2021-02-25",
1056             "last_updated": "2021-02-25T15:08:27.136305Z",
1057         },
1058         {
1059             "id": 285,
1060             "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1061             "family": {"value": 4, "label": "IPv4"},
1062             "prefix": "198.51.100.0/24",
1063             "vrf": None,
1064             "tenant": None,
1065             "vlan": None,
1066             "status": {"value": "active", "label": "Active"},
1067             "role": None,
1068             "is_pool": False,
1069             "description": "",
1070             "tags": [],
1071             "custom_fields": {},
1072             "created": "2021-02-25",
1073             "last_updated": "2021-02-25T15:08:59.880440Z",
1074         },
1075     ]
1076 @pytest.fixture
1077 def proxy_details_results():
1078     return {
1079         "dict": {
1080             "id": 1,
1081             "url": "https://netbox.example.com/api/dcim/platforms/1/",
1082             "name": "Cisco IOS",
1083             "slug": "ios",
1084             "manufacturer": {
1085                 "id": 1,
1086                 "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
1087                 "name": "Cisco",
1088                 "slug": "cisco",
1089             },
1090             "napalm_driver": "ios",
1091             "napalm_args": None,
1092             "description": "",
1093             "device_count": 152,
1094             "virtualmachine_count": 1,
1095         }
1096     }
1097 @pytest.fixture
1098 def proxy_details():
1099     return {
1100         "host": "192.0.2.1",
1101         "driver": "ios",
1102         "proxytype": "napalm",
1103     }
1104 @pytest.fixture
1105 def pillar_results():
1106     return {
1107         "netbox": {
1108             "id": 511,
1109             "url": "https://netbox.example.com/api/dcim/devices/511/",
1110             "name": "minion1",
1111             "node_type": "device",
1112             "display_name": "minion1",
1113             "device_type": {
1114                 "id": 4,
1115                 "url": "https://netbox.example.com/api/dcim/device-types/4/",
1116                 "manufacturer": {
1117                     "id": 1,
1118                     "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
1119                     "name": "Cisco",
1120                     "slug": "cisco",
1121                 },
1122                 "model": "ISR2901",
1123                 "slug": "isr2901",
1124                 "display_name": "Cisco ISR2901",
1125             },
1126             "device_role": {
1127                 "id": 45,
1128                 "url": "https://netbox.example.com/api/dcim/device-roles/45/",
1129                 "name": "Network",
1130                 "slug": "network",
1131             },
1132             "interfaces": [
1133                 {
1134                     "id": 8158,
1135                     "ip_addresses": [
1136                         {
1137                             "id": 1146,
1138                             "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1139                             "family": {"value": 4, "label": "IPv4"},
1140                             "address": "192.0.2.1/24",
1141                             "vrf": None,
1142                             "tenant": None,
1143                             "status": {"value": "active", "label": "Active"},
1144                             "role": None,
1145                             "nat_inside": None,
1146                             "nat_outside": None,
1147                             "dns_name": "",
1148                             "description": "",
1149                             "tags": [],
1150                             "custom_fields": {},
1151                             "created": "2021-02-19",
1152                             "last_updated": "2021-02-19T06:12:04.153386Z",
1153                         },
1154                     ],
1155                     "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
1156                     "name": "GigabitEthernet0/0",
1157                     "label": "",
1158                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
1159                     "enabled": True,
1160                     "lag": None,
1161                     "mtu": None,
1162                     "mac_address": None,
1163                     "mgmt_only": False,
1164                     "description": "",
1165                     "mode": None,
1166                     "untagged_vlan": None,
1167                     "tagged_vlans": [],
1168                     "cable": None,
1169                     "cable_peer": None,
1170                     "cable_peer_type": None,
1171                     "connected_endpoint": None,
1172                     "connected_endpoint_type": None,
1173                     "connected_endpoint_reachable": None,
1174                     "tags": [],
1175                     "count_ipaddresses": 1,
1176                 },
1177                 {
1178                     "id": 8159,
1179                     "ip_addresses": [
1180                         {
1181                             "id": 1147,
1182                             "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
1183                             "family": {"value": 4, "label": "IPv4"},
1184                             "address": "198.51.100.1/24",
1185                             "vrf": None,
1186                             "tenant": None,
1187                             "status": {"value": "active", "label": "Active"},
1188                             "role": None,
1189                             "nat_inside": None,
1190                             "nat_outside": None,
1191                             "dns_name": "",
1192                             "description": "",
1193                             "tags": [],
1194                             "custom_fields": {},
1195                             "created": "2021-02-19",
1196                             "last_updated": "2021-02-19T06:12:40.508154Z",
1197                         },
1198                     ],
1199                     "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
1200                     "name": "GigabitEthernet0/1",
1201                     "label": "",
1202                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
1203                     "enabled": True,
1204                     "lag": None,
1205                     "mtu": None,
1206                     "mac_address": None,
1207                     "mgmt_only": False,
1208                     "description": "",
1209                     "mode": None,
1210                     "untagged_vlan": None,
1211                     "tagged_vlans": [],
1212                     "cable": None,
1213                     "cable_peer": None,
1214                     "cable_peer_type": None,
1215                     "connected_endpoint": None,
1216                     "connected_endpoint_type": None,
1217                     "connected_endpoint_reachable": None,
1218                     "tags": [],
1219                     "count_ipaddresses": 1,
1220                 },
1221             ],
1222             "tenant": None,
1223             "platform": {
1224                 "id": 1,
1225                 "url": "https://netbox.example.com/api/dcim/platforms/1/",
1226                 "name": "Cisco IOS",
1227                 "slug": "ios",
1228             },
1229             "serial": "",
1230             "asset_tag": None,
1231             "site": {
1232                 "id": 18,
1233                 "url": "https://netbox.example.com/api/dcim/sites/18/",
1234                 "name": "Site 1",
1235                 "slug": "site1",
1236                 "status": {"value": "active", "label": "Active"},
1237                 "region": None,
1238                 "tenant": None,
1239                 "facility": "",
1240                 "asn": None,
1241                 "time_zone": None,
1242                 "description": "",
1243                 "physical_address": "",
1244                 "shipping_address": "",
1245                 "latitude": None,
1246                 "longitude": None,
1247                 "contact_name": "",
1248                 "contact_phone": "",
1249                 "contact_email": "",
1250                 "comments": "",
1251                 "tags": [],
1252                 "custom_fields": {},
1253                 "created": "2021-02-25",
1254                 "last_updated": "2021-02-25T14:21:07.898957Z",
1255                 "circuit_count": 0,
1256                 "device_count": 1,
1257                 "prefix_count": 2,
1258                 "rack_count": 0,
1259                 "virtualmachine_count": 1,
1260                 "vlan_count": 0,
1261                 "prefixes": [
1262                     {
1263                         "id": 284,
1264                         "url": "https://netbox.example.com/api/ipam/prefixes/284/",
1265                         "family": {"value": 4, "label": "IPv4"},
1266                         "prefix": "192.0.2.0/24",
1267                         "vrf": None,
1268                         "tenant": None,
1269                         "vlan": None,
1270                         "status": {"value": "active", "label": "Active"},
1271                         "role": None,
1272                         "is_pool": False,
1273                         "description": "",
1274                         "tags": [],
1275                         "custom_fields": {},
1276                         "created": "2021-02-25",
1277                         "last_updated": "2021-02-25T15:08:27.136305Z",
1278                     },
1279                     {
1280                         "id": 285,
1281                         "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1282                         "family": {"value": 4, "label": "IPv4"},
1283                         "prefix": "198.51.100.0/24",
1284                         "vrf": None,
1285                         "tenant": None,
1286                         "vlan": None,
1287                         "status": {"value": "active", "label": "Active"},
1288                         "role": None,
1289                         "is_pool": False,
1290                         "description": "",
1291                         "tags": [],
1292                         "custom_fields": {},
1293                         "created": "2021-02-25",
1294                         "last_updated": "2021-02-25T15:08:59.880440Z",
1295                     },
1296                 ],
1297             },
1298             "rack": None,
1299             "position": None,
1300             "face": None,
1301             "parent_device": None,
1302             "status": {"value": "active", "label": "Active"},
1303             "primary_ip": {
1304                 "id": 1146,
1305                 "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1306                 "family": 4,
1307                 "address": "192.0.2.1/24",
1308             },
1309             "primary_ip4": {
1310                 "id": 1146,
1311                 "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1312                 "family": 4,
1313                 "address": "192.0.2.1/24",
1314             },
1315             "primary_ip6": None,
1316             "cluster": None,
1317             "virtual_chassis": None,
1318             "vc_position": None,
1319             "vc_priority": None,
1320             "comments": "",
1321             "local_context_data": None,
1322             "tags": [],
1323             "custom_fields": {},
1324             "config_context": {},
1325             "created": "2021-02-19",
1326             "last_updated": "2021-02-19T06:12:04.171105Z",
1327         },
1328         "proxy": {"host": "192.0.2.1", "driver": "ios", "proxytype": "napalm"},
1329     }
1330 def test_when_minion_id_is_star_then_result_should_be_empty_dict(default_kwargs):
1331     expected_result = {}
1332     default_kwargs["minion_id"] = "*"
1333     actual_result = netbox.ext_pillar(**default_kwargs)
1334     assert actual_result == expected_result
1335 def test_when_api_url_is_not_http_or_https_then_error_message_should_be_logged(
1336     default_kwargs,
1337 ):
1338     default_kwargs["api_url"] = "ftp://netbox.example.com"
1339     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1340         netbox.ext_pillar(**default_kwargs)
1341         fake_error.assert_called_with(
1342             'Provided URL for api_url "%s" is malformed or is not an http/https URL',
1343             "ftp://netbox.example.com",
1344         )
1345 def test_when_neither_devices_or_virtual_machines_requested_then_error_message_should_be_logged(
1346     default_kwargs,
1347 ):
1348     default_kwargs["devices"] = default_kwargs["virtual_machines"] = False
1349     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1350         netbox.ext_pillar(**default_kwargs)
1351         fake_error.assert_called_with(
1352             "At least one of devices or virtual_machines must be True"
1353         )
1354 def test_when_interface_ips_requested_but_not_interfaces_then_error_message_should_be_logged(
1355     default_kwargs,
1356 ):
1357     default_kwargs["interfaces"] = False
1358     default_kwargs["interface_ips"] = True
1359     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1360         netbox.ext_pillar(**default_kwargs)
1361         fake_error.assert_called_with(
1362             "The value for interfaces must be True if interface_ips is True"
1363         )
1364 def test_when_api_query_result_limit_set_but_not_a_positive_integer_then_error_message_should_be_logged(
1365     default_kwargs,
1366 ):
1367     default_kwargs["api_query_result_limit"] = -1
1368     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1369         netbox.ext_pillar(**default_kwargs)
1370         fake_error.assert_called_with(
1371             "The value for api_query_result_limit must be a postive integer if set"
1372         )
1373 def test_when_api_token_not_set_then_error_message_should_be_logged(
1374     default_kwargs,
1375 ):
1376     default_kwargs["api_token"] = ""
1377     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1378         netbox.ext_pillar(**default_kwargs)
1379         fake_error.assert_called_with("The value for api_token is not set")
1380 def test_when_we_retrieve_a_single_device_then_return_list(
1381     default_kwargs, headers, device_results
1382 ):
1383     expected_result = device_results["dict"]["results"]
1384     with patch("salt.utils.http.query", autospec=True) as query:
1385         query.return_value = device_results
1386         actual_result = netbox._get_devices(
1387             default_kwargs["api_url"],
1388             default_kwargs["minion_id"],
1389             headers,
1390             default_kwargs["api_query_result_limit"],
1391         )
1392         assert actual_result == expected_result
1393 def test_when_we_retrieve_a_device_and_get_http_error_then_return_empty_list(
1394     default_kwargs, headers, http_error
1395 ):
1396     expected_result = []
1397     with patch("salt.utils.http.query", autospec=True) as query:
1398         query.return_value = http_error
1399         actual_result = netbox._get_devices(
1400             default_kwargs["api_url"],
1401             default_kwargs["minion_id"],
1402             headers,
1403             default_kwargs["api_query_result_limit"],
1404         )
1405         assert actual_result == expected_result
1406 def test_when_we_retrieve_a_single_virtual_machine_then_return_list(
1407     default_kwargs, headers, virtual_machine_results
1408 ):
1409     expected_result = virtual_machine_results["dict"]["results"]
1410     with patch("salt.utils.http.query", autospec=True) as query:
1411         query.return_value = virtual_machine_results
1412         actual_result = netbox._get_virtual_machines(
1413             default_kwargs["api_url"],
1414             default_kwargs["minion_id"],
1415             headers,
1416             default_kwargs["api_query_result_limit"],
1417         )
1418         assert actual_result == expected_result
1419 def test_when_we_retrieve_a_virtual_machine_and_get_http_error_then_return_empty_dict(
1420     default_kwargs, headers, http_error
1421 ):
1422     expected_result = []
1423     with patch("salt.utils.http.query", autospec=True) as query:
1424         query.return_value = http_error
1425         actual_result = netbox._get_virtual_machines(
1426             default_kwargs["api_url"],
1427             default_kwargs["minion_id"],
1428             headers,
1429             default_kwargs["api_query_result_limit"],
1430         )
1431         assert actual_result == expected_result
1432 def test_when_we_retrieve_device_interfaces_then_return_dict(
1433     default_kwargs, headers, device_interface_results, device_interfaces_list
1434 ):
1435     expected_result = device_interfaces_list
1436     with patch("salt.utils.http.query", autospec=True) as query:
1437         query.return_value = device_interface_results
1438         actual_result = netbox._get_interfaces(
1439             default_kwargs["api_url"],
1440             default_kwargs["minion_id"],
1441             511,
1442             "device",
1443             headers,
1444             default_kwargs["api_query_result_limit"],
1445         )
1446         assert actual_result == expected_result
1447 def test_when_we_retrieve_device_interfaces_and_get_http_error_then_return_empty_list(
1448     default_kwargs, headers, http_error
1449 ):
1450     expected_result = []
1451     with patch("salt.utils.http.query", autospec=True) as query:
1452         query.return_value = http_error
1453         actual_result = netbox._get_interfaces(
1454             default_kwargs["api_url"],
1455             default_kwargs["minion_id"],
1456             511,
1457             "device",
1458             headers,
1459             default_kwargs["api_query_result_limit"],
1460         )
1461         assert actual_result == expected_result
1462 def test_when_we_retrieve_virtual_machine_interfaces_then_return_list(
1463     default_kwargs,
1464     headers,
1465     virtual_machine_interface_results,
1466     virtual_machine_interfaces_list,
1467 ):
1468     expected_result = virtual_machine_interfaces_list
1469     with patch("salt.utils.http.query", autospec=True) as query:
1470         query.return_value = virtual_machine_interface_results
1471         actual_result = netbox._get_interfaces(
1472             default_kwargs["api_url"],
1473             default_kwargs["minion_id"],
1474             222,
1475             "virtual-machine",
1476             headers,
1477             default_kwargs["api_query_result_limit"],
1478         )
1479         assert actual_result == expected_result
1480 def test_when_we_retrieve_virtual_machine_interfaces_and_get_http_error_then_return_empty_list(
1481     default_kwargs, headers, http_error
1482 ):
1483     expected_result = []
1484     with patch("salt.utils.http.query", autospec=True) as query:
1485         query.return_value = http_error
1486         actual_result = netbox._get_interfaces(
1487             default_kwargs["api_url"],
1488             default_kwargs["minion_id"],
1489             222,
1490             "virtual-machine",
1491             headers,
1492             default_kwargs["api_query_result_limit"],
1493         )
1494         assert actual_result == expected_result
1495 def test_when_we_retrieve_device_interface_ips_then_return_list(
1496     default_kwargs, headers, device_ip_results
1497 ):
1498     expected_result = device_ip_results["dict"]["results"]
1499     with patch("salt.utils.http.query", autospec=True) as query:
1500         query.return_value = device_ip_results
1501         actual_result = netbox._get_interface_ips(
1502             default_kwargs["api_url"],
1503             default_kwargs["minion_id"],
1504             511,
1505             "device",
1506             headers,
1507             default_kwargs["api_query_result_limit"],
1508         )
1509         assert actual_result == expected_result
1510 def test_when_we_retrieve_device_interface_ips_and_get_http_error_then_return_empty_list(
1511     default_kwargs, headers, http_error
1512 ):
1513     expected_result = []
1514     with patch("salt.utils.http.query", autospec=True) as query:
1515         query.return_value = http_error
1516         actual_result = netbox._get_interface_ips(
1517             default_kwargs["api_url"],
1518             default_kwargs["minion_id"],
1519             511,
1520             "device",
1521             headers,
1522             default_kwargs["api_query_result_limit"],
1523         )
1524         assert actual_result == expected_result
1525 def test_when_we_retrieve_virtual_machine_interface_ips_then_return_list(
1526     default_kwargs, headers, virtual_machine_ip_results
1527 ):
1528     expected_result = virtual_machine_ip_results["dict"]["results"]
1529     with patch("salt.utils.http.query", autospec=True) as query:
1530         query.return_value = virtual_machine_ip_results
1531         actual_result = netbox._get_interface_ips(
1532             default_kwargs["api_url"],
1533             default_kwargs["minion_id"],
1534             222,
1535             "virtual-machine",
1536             headers,
1537             default_kwargs["api_query_result_limit"],
1538         )
1539         assert actual_result == expected_result
1540 def test_when_we_retrieve_virtual_machine_interface_ips_and_get_http_error_then_return_empty_list(
1541     default_kwargs, headers, http_error
1542 ):
1543     expected_result = []
1544     with patch("salt.utils.http.query", autospec=True) as query:
1545         query.return_value = http_error
1546         actual_result = netbox._get_interface_ips(
1547             default_kwargs["api_url"],
1548             default_kwargs["minion_id"],
1549             222,
1550             "virtual-machine",
1551             headers,
1552             default_kwargs["api_query_result_limit"],
1553         )
1554         assert actual_result == expected_result
1555 def test_associate_ips_to_interfaces_then_return_list(
1556     default_kwargs, device_interfaces_list, device_ip_results, device_interfaces_ip_list
1557 ):
1558     expected_result = device_interfaces_ip_list
1559     interfaces_list = device_interfaces_list
1560     interface_ips_list = device_ip_results["dict"]["results"]
1561     actual_result = netbox._associate_ips_to_interfaces(
1562         interfaces_list, interface_ips_list
1563     )
1564     assert actual_result == expected_result
1565 def test_associate_empty_ip_list_to_interfaces_then_return_list(
1566     default_kwargs, device_interfaces_list, device_ip_results
1567 ):
1568     expected_result = device_interfaces_list
1569     interfaces_list = device_interfaces_list
1570     interface_ips_list = []
1571     actual_result = netbox._associate_ips_to_interfaces(
1572         interfaces_list, interface_ips_list
1573     )
1574     assert actual_result == expected_result
1575 def test_when_we_retrieve_site_details_then_return_dict(
1576     default_kwargs, headers, site_results
1577 ):
1578     expected_result = site_results["dict"]
1579     with patch("salt.utils.http.query", autospec=True) as query:
1580         query.return_value = site_results
1581         actual_result = netbox._get_site_details(
1582             default_kwargs["api_url"],
1583             default_kwargs["minion_id"],
1584             "Site 1",
1585             18,
1586             headers,
1587         )
1588         assert actual_result == expected_result
1589 def test_when_we_retrieve_site_details_and_get_http_error_then_return_empty_dict(
1590     default_kwargs, headers, http_error
1591 ):
1592     expected_result = {}
1593     with patch("salt.utils.http.query", autospec=True) as query:
1594         query.return_value = http_error
1595         actual_result = netbox._get_site_details(
1596             default_kwargs["api_url"],
1597             default_kwargs["minion_id"],
1598             "Site 1",
1599             18,
1600             headers,
1601         )
1602         assert actual_result == expected_result
1603 def test_when_we_retrieve_site_prefixes_then_return_list(
1604     default_kwargs, headers, site_prefixes_results, site_prefixes
1605 ):
1606     expected_result = site_prefixes
1607     with patch("salt.utils.http.query", autospec=True) as query:
1608         query.return_value = site_prefixes_results
1609         actual_result = netbox._get_site_prefixes(
1610             default_kwargs["api_url"],
1611             default_kwargs["minion_id"],
1612             "Site 1",
1613             18,
1614             headers,
1615             default_kwargs["api_query_result_limit"],
1616         )
1617         assert actual_result == expected_result
1618 def test_when_we_retrieve_site_prefixes_and_get_http_error_then_return_empty_list(
1619     default_kwargs, headers, http_error
1620 ):
1621     expected_result = []
1622     with patch("salt.utils.http.query", autospec=True) as query:
1623         query.return_value = http_error
1624         actual_result = netbox._get_site_prefixes(
1625             default_kwargs["api_url"],
1626             default_kwargs["minion_id"],
1627             "Site 1",
1628             18,
1629             headers,
1630             default_kwargs["api_query_result_limit"],
1631         )
1632         assert actual_result == expected_result
1633 def test_when_we_retrieve_proxy_details_then_return_dict(
1634     default_kwargs, headers, proxy_details_results, proxy_details
1635 ):
1636     expected_result = proxy_details
1637     with patch("salt.utils.http.query", autospec=True) as query:
1638         query.return_value = proxy_details_results
1639         actual_result = netbox._get_proxy_details(
1640             default_kwargs["api_url"],
1641             default_kwargs["minion_id"],
1642             "192.0.2.1/24",
1643             1,
1644             headers,
1645         )
1646         assert actual_result == expected_result
1647 def test_when_we_retrieve_proxy_details_and_get_http_error_then_dont_return(
1648     default_kwargs, headers, http_error
1649 ):
1650     expected_result = None
1651     with patch("salt.utils.http.query", autospec=True) as query:
1652         query.return_value = http_error
1653         actual_result = netbox._get_proxy_details(
1654             default_kwargs["api_url"],
1655             default_kwargs["minion_id"],
1656             "192.0.2.1/24",
1657             1,
1658             headers,
1659         )
1660         assert actual_result == expected_result
1661 def test_when_we_retrieve_multiple_devices_then_error_message_should_be_logged(
1662     default_kwargs, multiple_device_results
1663 ):
1664     with patch(
1665         "salt.pillar.netbox._get_devices", autospec=True
1666     ) as multiple_devices, patch(
1667         "salt.pillar.netbox.log.error", autospec=True
1668     ) as fake_error:
1669         multiple_devices.return_value = multiple_device_results["dict"]["results"]
1670         netbox.ext_pillar(**default_kwargs)
1671         fake_error.assert_called_with(
1672             'More than one node found for "%s"',
1673             "minion1",
1674         )
1675 def test_when_we_retrieve_multiple_virtual_machines_then_error_message_should_be_logged(
1676     default_kwargs, multiple_virtual_machine_results
1677 ):
1678     default_kwargs["devices"] = False
1679     default_kwargs["virtual_machines"] = True
1680     with patch(
1681         "salt.pillar.netbox._get_virtual_machines", autospec=True
1682     ) as multiple_virtual_machines, patch(
1683         "salt.pillar.netbox.log.error", autospec=True
1684     ) as fake_error:
1685         multiple_virtual_machines.return_value = multiple_virtual_machine_results[
1686             "dict"
1687         ]["results"]
1688         netbox.ext_pillar(**default_kwargs)
1689         fake_error.assert_called_with(
1690             'More than one node found for "%s"',
1691             "minion1",
1692         )
1693 def test_when_we_retrieve_a_device_and_a_virtual_machine_then_error_message_should_be_logged(
1694     default_kwargs, device_results, virtual_machine_results
1695 ):
1696     default_kwargs["virtual_machines"] = True
1697     with patch("salt.pillar.netbox._get_devices", autospec=True) as device, patch(
1698         "salt.pillar.netbox._get_virtual_machines", autospec=True
1699     ) as virtual_machine, patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1700         "salt.pillar.netbox.log.error", autospec=True
1701     ) as fake_error:
1702         device.return_value = device_results["dict"]["results"]
1703         virtual_machine.return_value = virtual_machine_results["dict"]["results"]
1704         netbox.ext_pillar(**default_kwargs)
1705         fake_error.</b></font>assert_called_with(
1706             'More than one node found for "%s"',
1707             "minion1",
1708         )
1709 def test_when_we_retrieve_no_devices_then_error_message_should_be_logged(
1710     default_kwargs, no_results
1711 ):
1712     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1713         "salt.pillar.netbox.log.error", autospec=True
1714     ) as fake_error:
1715         devices.return_value = no_results["dict"]["results"]
1716         netbox.ext_pillar(**default_kwargs)
1717         fake_error.assert_called_with(
1718             'Unable to pull NetBox data for "%s"',
1719             "minion1",
1720         )
1721 def test_when_we_retrieve_no_virtual_machines_then_error_message_should_be_logged(
1722     default_kwargs, no_results
1723 ):
1724     default_kwargs["devices"] = False
1725     default_kwargs["virtual_machines"] = True
1726     with patch(
1727         "salt.pillar.netbox._get_virtual_machines", autospec=True
1728     ) as virtual_machines, patch(
1729         "salt.pillar.netbox.log.error", autospec=True
1730     ) as fake_error:
1731         virtual_machines.return_value = no_results["dict"]["results"]
1732         netbox.ext_pillar(**default_kwargs)
1733         fake_error.assert_called_with(
1734             'Unable to pull NetBox data for "%s"',
1735             "minion1",
1736         )
1737 def test_when_we_retrieve_everything_successfully_then_return_dict(
1738     default_kwargs,
1739     device_results,
1740     no_results,
1741     device_interfaces_list,
1742     device_ip_results,
1743     site_results,
1744     site_prefixes,
1745     proxy_details,
1746     pillar_results,
1747 ):
1748     expected_result = pillar_results
1749     default_kwargs["virtual_machines"] = False
1750     default_kwargs["interfaces"] = True
1751     default_kwargs["interface_ips"] = True
1752     default_kwargs["site_details"] = True
1753     default_kwargs["site_prefixes"] = True
1754     default_kwargs["proxy_return"] = True
1755     with patch("salt.pillar.netbox._get_devices", autospec=True) as get_devices, patch(
1756         "salt.pillar.netbox._get_virtual_machines", autospec=True
1757     ) as get_virtual_machines, patch(
1758         "salt.pillar.netbox._get_interfaces", autospec=True
1759     ) as get_interfaces, patch(
1760         "salt.pillar.netbox._get_interface_ips", autospec=True
1761     ) as get_interface_ips, patch(
1762         "salt.pillar.netbox._get_site_details", autospec=True
1763     ) as get_site_details, patch(
1764         "salt.pillar.netbox._get_site_prefixes", autospec=True
1765     ) as get_site_prefixes, patch(
1766         "salt.pillar.netbox._get_proxy_details", autospec=True
1767     ) as get_proxy_details:
1768         get_devices.return_value = device_results["dict"]["results"]
1769         get_virtual_machines.return_value = no_results["dict"]["results"]
1770         get_interfaces.return_value = device_interfaces_list
1771         get_interface_ips.return_value = device_ip_results["dict"]["results"]
1772         get_site_details.return_value = site_results["dict"]
1773         get_site_prefixes.return_value = site_prefixes
1774         get_proxy_details.return_value = proxy_details
1775         actual_result = netbox.ext_pillar(**default_kwargs)
1776         assert actual_result == expected_result
1777 def test_when_we_set_proxy_return_but_get_no_value_for_platform_then_error_message_should_be_logged(
1778     default_kwargs, headers, device_results
1779 ):
1780     default_kwargs["site_details"] = False
1781     default_kwargs["site_prefixes"] = False
1782     default_kwargs["proxy_return"] = True
1783     device_results["dict"]["results"][0]["platform"] = None
1784     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1785         "salt.pillar.netbox.log.error", autospec=True
1786     ) as fake_error:
1787         devices.return_value = device_results["dict"]["results"]
1788         netbox.ext_pillar(**default_kwargs)
1789         fake_error.assert_called_with(
1790             'You have set "proxy_return" to "True" but you have not set the platform in NetBox for "%s"',
1791             "minion1",
1792         )
1793 def test_when_we_set_proxy_return_but_get_no_value_for_primary_ip_then_error_message_should_be_logged(
1794     default_kwargs, headers, device_results
1795 ):
1796     default_kwargs["site_details"] = False
1797     default_kwargs["site_prefixes"] = False
1798     default_kwargs["proxy_return"] = True
1799     device_results["dict"]["results"][0]["primary_ip"] = None
1800     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1801         "salt.pillar.netbox.log.error", autospec=True
1802     ) as fake_error:
1803         devices.return_value = device_results["dict"]["results"]
1804         netbox.ext_pillar(**default_kwargs)
1805         fake_error.assert_called_with(
1806             'You have set "proxy_return" to "True" but you have not set the primary IPv4 or IPv6 address in NetBox for "%s"',
1807             "minion1",
1808         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>schedule.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import errno
4 import itertools
5 import logging
6 import os
7 import random
8 import signal
9 import sys
10 import threading
11 import time
12 import weakref
13 import salt.config
14 import salt.defaults.exitcodes
15 import salt.exceptions
16 import salt.loader
17 import salt.minion
18 import salt.payload
19 import salt.syspaths
20 import salt.utils.args
21 import salt.utils.error
22 import salt.utils.event
23 import salt.utils.files
24 import salt.utils.jid
25 import salt.utils.master
26 import salt.utils.minion
27 import salt.utils.platform
28 import salt.utils.process
29 import salt.utils.stringutils
30 import salt.utils.user
31 import salt.utils.yaml
32 from salt.exceptions import SaltInvocationError
33 from salt.utils.odict import OrderedDict
34 try:
35     import dateutil.parser as dateutil_parser
36     _WHEN_SUPPORTED = True
37     _RANGE_SUPPORTED = True
38 except ImportError:
39     _WHEN_SUPPORTED = False
40     _RANGE_SUPPORTED = False
41 try:
42     import croniter
43     _CRON_SUPPORTED = True
44 except ImportError:
45     _CRON_SUPPORTED = False
46 log = logging.getLogger(__name__)
47 class Schedule:
48     instance = None
49     def __new__(
50         cls,
51         opts,
52         functions,
53         returners=None,
54         intervals=None,
55         cleanup=None,
56         proxy=None,
57         standalone=False,
58         new_instance=False,
59         utils=None,
60         _subprocess_list=None,
61     ):
62         if cls.instance is None or new_instance is True:
63             log.debug("Initializing new Schedule")
64             instance = object.__new__(cls)
65             instance.__singleton_init__(
66                 opts,
67                 functions,
68                 returners=returners,
69                 intervals=intervals,
70                 cleanup=cleanup,
71                 proxy=proxy,
72                 standalone=standalone,
73                 utils=utils,
74                 _subprocess_list=_subprocess_list,
75             )
76             if new_instance is True:
77                 return instance
78             cls.instance = instance
79         else:
80             log.debug("Re-using Schedule")
81         return cls.instance
82     def __init__(
83         self,
84         opts,
85         functions,
86         returners=None,
87         intervals=None,
88         cleanup=None,
89         proxy=None,
90         standalone=False,
91         new_instance=False,
92         utils=None,
93         _subprocess_list=None,
94     ):
95         pass
96     def __singleton_init__(
97         self,
98         opts,
99         functions,
100         returners=None,
101         intervals=None,
102         cleanup=None,
103         proxy=None,
104         standalone=False,
105         utils=None,
106         _subprocess_list=None,
107     ):
108         self.opts = opts
109         self.proxy = proxy
110         self.functions = functions
111         self.utils = utils or salt.loader.utils(opts)
112         self.standalone = standalone
113         self.skip_function = None
114         self.skip_during_range = None
115         self.splay = None
116         self.enabled = True
117         if isinstance(intervals, dict):
118             self.intervals = intervals
119         else:
120             self.intervals = {}
121         if not self.standalone:
122             if hasattr(returners, "__getitem__"):
123                 self.returners = returners
124             else:
125                 self.returners = returners.loader.gen_functions()
126         try:
127             self.time_offset = self.functions.get(
128                 "timezone.get_offset", lambda: "0000"
129             )()
130         except Exception:  # pylint: disable=W0703
131             log.warning(
132                 "Unable to obtain correct timezone offset, defaulting to 0000",
133                 exc_info_on_loglevel=logging.DEBUG,
134             )
135             self.time_offset = "0000"
136         self.schedule_returner = self.option("schedule_returner")
137         self.loop_interval = sys.maxsize
138         if not self.standalone:
139             clean_proc_dir(opts)
140         if cleanup:
141             for prefix in cleanup:
142                 self.delete_job_prefix(prefix)
143         if _subprocess_list is None:
144             self._subprocess_list = salt.utils.process.SubprocessList()
145         else:
146             self._subprocess_list = _subprocess_list
147     def __getnewargs__(self):
148         return self.opts, self.functions, self.returners, self.intervals, None
149     def option(self, opt):
150         if "config.merge" in self.functions:
151             return self.functions["config.merge"](opt, {}, omit_master=True)
152         return self.opts.get(opt, {})
153     def _get_schedule(
154         self, include_opts=True, include_pillar=True, remove_hidden=False
155     ):
156         schedule = {}
157         if include_pillar:
158             pillar_schedule = self.opts.get("pillar", {}).get("schedule", {})
159             if not isinstance(pillar_schedule, dict):
160                 raise ValueError("Schedule must be of type dict.")
161             schedule.update(pillar_schedule)
162         if include_opts:
163             opts_schedule = self.opts.get("schedule", {})
164             if not isinstance(opts_schedule, dict):
165                 raise ValueError("Schedule must be of type dict.")
166             schedule.update(opts_schedule)
167         if remove_hidden:
168             _schedule = copy.deepcopy(schedule)
169             for job in _schedule:
170                 if isinstance(_schedule[job], dict):
171                     for item in _schedule[job]:
172                         if item.startswith("_"):
173                             del schedule[job][item]
174         return schedule
175     def _check_max_running(self, func, data, opts, now):
176         if "run" not in data or not data["run"]:
177             return data
178         if "jid_include" not in data or data["jid_include"]:
179             jobcount = 0
180             if self.opts["__role"] == "master":
181                 current_jobs = salt.utils.master.get_running_jobs(self.opts)
182             else:
183                 current_jobs = salt.utils.minion.running(self.opts)
184             for job in current_jobs:
185                 if "schedule" in job:
186                     log.debug(
187                         "schedule.handle_func: Checking job against fun %s: %s",
188                         func,
189                         job,
190                     )
191                     if data["name"] == job[
192                         "schedule"
193                     ] and salt.utils.process.os_is_running(job["pid"]):
194                         jobcount += 1
195                         log.debug(
196                             "schedule.handle_func: Incrementing jobcount, "
197                             "now %s, maxrunning is %s",
198                             jobcount,
199                             data["maxrunning"],
200                         )
201                         if jobcount &gt;= data["maxrunning"]:
202                             log.debug(
203                                 "schedule.handle_func: The scheduled job "
204                                 "%s was not started, %s already running",
205                                 data["name"],
206                                 data["maxrunning"],
207                             )
208                             data["_skip_reason"] = "maxrunning"
209                             data["_skipped"] = True
210                             data["_skipped_time"] = now
211                             data["run"] = False
212                             return data
213         return data
214     def persist(self):
215         config_dir = self.opts.get("conf_dir", None)
216         if config_dir is None and "conf_file" in self.opts:
217             config_dir = os.path.dirname(self.opts["conf_file"])
218         if config_dir is None:
219             config_dir = salt.syspaths.CONFIG_DIR
220         minion_d_dir = os.path.join(
221             config_dir,
222             os.path.dirname(
223                 self.opts.get(
224                     "default_include",
225                     salt.config.DEFAULT_MINION_OPTS["default_include"],
226                 )
227             ),
228         )
229         if not os.path.isdir(minion_d_dir):
230             os.makedirs(minion_d_dir)
231         schedule_conf = os.path.join(minion_d_dir, "_schedule.conf")
232         log.debug("Persisting schedule")
233         schedule_data = self._get_schedule(include_pillar=False, remove_hidden=True)
234         try:
235             with salt.utils.files.fopen(schedule_conf, "wb+") as fp_:
236                 fp_.write(
237                     salt.utils.stringutils.to_bytes(
238                         salt.utils.yaml.safe_dump({"schedule": schedule_data})
239                     )
240                 )
241         except OSError:
242             log.error(
243                 "Failed to persist the updated schedule",
244                 exc_info_on_loglevel=logging.DEBUG,
245             )
246     def delete_job(self, name, persist=True):
247         if name in self.opts["schedule"]:
248             del self.opts["schedule"][name]
249         elif name in self._get_schedule(include_opts=False):
250             log.warning("Cannot delete job %s, it's in the pillar!", name)
251         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
252             evt.fire_event(
253                 {"complete": True, "schedule": self._get_schedule()},
254                 tag="/salt/minion/minion_schedule_delete_complete",
255             )
256         if name in self.intervals:
257             del self.intervals[name]
258         if persist:
259             self.persist()
260     def reset(self):
261         self.skip_function = None
262         self.skip_during_range = None
263         self.enabled = True
264         self.splay = None
265         self.opts["schedule"] = {}
266     def delete_job_prefix(self, name, persist=True):
267         for job in list(self.opts["schedule"].keys()):
268             if job.startswith(name):
269                 del self.opts["schedule"][job]
270         for job in self._get_schedule(include_opts=False):
271             if job.startswith(name):
272                 log.warning("Cannot delete job %s, it's in the pillar!", job)
273         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
274             evt.fire_event(
275                 {"complete": True, "schedule": self._get_schedule()},
276                 tag="/salt/minion/minion_schedule_delete_complete",
277             )
278         for job in list(self.intervals.keys()):
279             if job.startswith(name):
280                 del self.intervals[job]
281         if persist:
282             self.persist()
283     def add_job(self, data, persist=True):
284         if not isinstance(data, dict):
285             raise ValueError("Scheduled jobs have to be of type dict.")
286         if not len(data) == 1:
287             raise ValueError("You can only schedule one new job at a time.")
288         for job in data:
289             if "enabled" not in data[job]:
290                 data[job]["enabled"] = True
291         new_job = next(iter(data.keys()))
292         if new_job in self._get_schedule(include_opts=False):
293             log.warning("Cannot update job %s, it's in the pillar!", new_job)
294         elif new_job in self.opts["schedule"]:
295             log.info("Updating job settings for scheduled job: %s", new_job)
296             self.opts["schedule"].update(data)
297         else:
298             log.info("Added new job %s to scheduler", new_job)
299             self.opts["schedule"].update(data)
300         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
301             evt.fire_event(
302                 {"complete": True, "schedule": self._get_schedule()},
303                 tag="/salt/minion/minion_schedule_add_complete",
304             )
305         if persist:
306             self.persist()
307     def enable_job(self, name, persist=True):
308         if name in self.opts["schedule"]:
309             self.opts["schedule"][name]["enabled"] = True
310             log.info("Enabling job %s in scheduler", name)
311         elif name in self._get_schedule(include_opts=False):
312             log.warning("Cannot modify job %s, it's in the pillar!", name)
313         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
314             evt.fire_event(
315                 {"complete": True, "schedule": self._get_schedule()},
316                 tag="/salt/minion/minion_schedule_enabled_job_complete",
317             )
318         if persist:
319             self.persist()
320     def disable_job(self, name, persist=True):
321         if name in self.opts["schedule"]:
322             self.opts["schedule"][name]["enabled"] = False
323             log.info("Disabling job %s in scheduler", name)
324         elif name in self._get_schedule(include_opts=False):
325             log.warning("Cannot modify job %s, it's in the pillar!", name)
326         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
327             evt.fire_event(
328                 {"complete": True, "schedule": self._get_schedule()},
329                 tag="/salt/minion/minion_schedule_disabled_job_complete",
330             )
331         if persist:
332             self.persist()
333     def modify_job(self, name, schedule, persist=True):
334         if name in self.opts["schedule"]:
335             self.delete_job(name, persist)
336         elif name in self._get_schedule(include_opts=False):
337             log.warning("Cannot modify job %s, it's in the pillar!", name)
338             return
339         self.opts["schedule"][name] = schedule
340         if persist:
341             self.persist()
342     def run_job(self, name):
343         data = self._get_schedule().get(name, {})
344         if "function" in data:
345             func = data["function"]
346         elif "func" in data:
347             func = data["func"]
348         elif "fun" in data:
349             func = data["fun"]
350         else:
351             func = None
352         if func not in self.functions:
353             log.info("Invalid function: %s in scheduled job %s.", func, name)
354         if "name" not in data:
355             data["name"] = name
356         if "run" not in data:
357             data["run"] = True
358         if not self.standalone:
359             data = self._check_max_running(
360                 func, data, self.opts, datetime.datetime.now()
361             )
362         if data.get("run"):
363             log.info("Running Job: %s", name)
364             self._run_job(func, data)
365     def enable_schedule(self, persist=True):
366         self.opts["schedule"]["enabled"] = True
367         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
368             evt.fire_event(
369                 {"complete": True, "schedule": self._get_schedule()},
370                 tag="/salt/minion/minion_schedule_enabled_complete",
371             )
372         if persist:
373             self.persist()
374     def disable_schedule(self, persist=True):
375         self.opts["schedule"]["enabled"] = False
376         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
377             evt.fire_event(
378                 {"complete": True, "schedule": self._get_schedule()},
379                 tag="/salt/minion/minion_schedule_disabled_complete",
380             )
381         if persist:
382             self.persist()
383     def reload(self, schedule):
384         self.intervals = {}
385         if "schedule" in schedule:
386             schedule = schedule["schedule"]
387         self.opts.setdefault("schedule", {}).update(schedule)
388     def list(self, where):
389         if where == "pillar":
390             schedule = self._get_schedule(include_opts=False)
391         elif where == "opts":
392             schedule = self._get_schedule(include_pillar=False)
393         else:
394             schedule = self._get_schedule()
395         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
396             evt.fire_event(
397                 {"complete": True, "schedule": schedule},
398                 tag="/salt/minion/minion_schedule_list_complete",
399             )
400     def save_schedule(self):
401         self.persist()
402         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
403             evt.fire_event({"complete": True}, tag="/salt/minion/minion_schedule_saved")
404     def postpone_job(self, name, data):
405         time = data["time"]
406         new_time = data["new_time"]
407         time_fmt = data.get("time_fmt", "%Y-%m-%dT%H:%M:%S")
408         if name in self.opts["schedule"]:
409             if "skip_explicit" not in self.opts["schedule"][name]:
410                 self.opts["schedule"][name]["skip_explicit"] = []
411             self.opts["schedule"][name]["skip_explicit"].append(
412                 {"time": time, "time_fmt": time_fmt}
413             )
414             if "run_explicit" not in self.opts["schedule"][name]:
415                 self.opts["schedule"][name]["run_explicit"] = []
416             self.opts["schedule"][name]["run_explicit"].append(
417                 {"time": new_time, "time_fmt": time_fmt}
418             )
419         elif name in self._get_schedule(include_opts=False):
420             log.warning("Cannot modify job %s, it's in the pillar!", name)
421         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
422             evt.fire_event(
423                 {"complete": True, "schedule": self._get_schedule()},
424                 tag="/salt/minion/minion_schedule_postpone_job_complete",
425             )
426     def skip_job(self, name, data):
427         time = data["time"]
428         time_fmt = data.get("time_fmt", "%Y-%m-%dT%H:%M:%S")
429         if name in self.opts["schedule"]:
430             if "skip_explicit" not in self.opts["schedule"][name]:
431                 self.opts["schedule"][name]["skip_explicit"] = []
432             self.opts["schedule"][name]["skip_explicit"].append(
433                 {"time": time, "time_fmt": time_fmt}
434             )
435         elif name in self._get_schedule(include_opts=False):
436             log.warning("Cannot modify job %s, it's in the pillar!", name)
437         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
438             evt.fire_event(
439                 {"complete": True, "schedule": self._get_schedule()},
440                 tag="/salt/minion/minion_schedule_skip_job_complete",
441             )
442     def get_next_fire_time(self, name, fmt="%Y-%m-%dT%H:%M:%S"):
443         schedule = self._get_schedule()
444         _next_fire_time = None
445         if schedule:
446             _next_fire_time = schedule.get(name, {}).get("_next_fire_time", None)
447             if _next_fire_time:
448                 _next_fire_time = _next_fire_time.strftime(fmt)
449         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
450             evt.fire_event(
451                 {"complete": True, "next_fire_time": _next_fire_time},
452                 tag="/salt/minion/minion_schedule_next_fire_time_complete",
453             )
454     def job_status(self, name, fire_event=False):
455         if fire_event:
456             schedule = self._get_schedule()
457             data = schedule.get(name, {})
458             with salt.utils.event.get_event(
459                 "minion", opts=self.opts, listen=False
460             ) as evt:
461                 evt.fire_event(
462                     {"complete": True, "data": data},
463                     tag="/salt/minion/minion_schedule_job_status_complete",
464                 )
465         else:
466             schedule = self._get_schedule()
467             return schedule.get(name, {})
468     def handle_func(self, multiprocessing_enabled, func, data, jid=None):
469         if salt.utils.platform.is_windows() or self.opts.get("transport") == "zeromq":
470             self.utils = salt.loader.utils(self.opts)
471             if self.opts["__role"] == "master":
472                 self.functions = salt.loader.runner(self.opts, utils=self.utils)
473             else:
474                 self.functions = salt.loader.minion_mods(
475                     self.opts, proxy=self.proxy, utils=self.utils
476                 )
477             self.returners = salt.loader.returners(
478                 self.opts, self.functions, proxy=self.proxy
479             )
480         if jid is None:
481             jid = salt.utils.jid.gen_jid(self.opts)
482         ret = {
483             "id": self.opts.get("id", "master"),
484             "fun": func,
485             "fun_args": [],
486             "schedule": data["name"],
487             "jid": jid,
488         }
489         if "metadata" in data:
490             if isinstance(data["metadata"], dict):
491                 ret["metadata"] = data["metadata"]
492                 ret["metadata"]["_TOS"] = self.time_offset
493                 ret["metadata"]["_TS"] = time.ctime()
494                 ret["metadata"]["_TT"] = time.strftime(
495                     "%Y %B %d %a %H %m", time.gmtime()
496                 )
497             else:
498                 log.warning(
499                     "schedule: The metadata parameter must be "
500                     "specified as a dictionary.  Ignoring."
501                 )
502         data_returner = data.get("returner", None)
503         if not self.standalone:
504             proc_fn = os.path.join(
505                 salt.minion.get_proc_dir(self.opts["cachedir"]), ret["jid"]
506             )
507         try:
508             minion_blackout_violation = False
509             if self.opts.get("pillar", {}).get("minion_blackout", False):
510                 whitelist = self.opts.get("pillar", {}).get(
511                     "minion_blackout_whitelist", []
512                 )
513                 if func != "saltutil.refresh_pillar" and func not in whitelist:
514                     minion_blackout_violation = True
515             elif self.opts.get("grains", {}).get("minion_blackout", False):
516                 whitelist = self.opts.get("grains", {}).get(
517                     "minion_blackout_whitelist", []
518                 )
519                 if func != "saltutil.refresh_pillar" and func not in whitelist:
520                     minion_blackout_violation = True
521             if minion_blackout_violation:
522                 raise SaltInvocationError(
523                     "Minion in blackout mode. Set 'minion_blackout' "
524                     "to False in pillar or grains to resume operations. Only "
525                     "saltutil.refresh_pillar allowed in blackout mode."
526                 )
527             ret["pid"] = os.getpid()
528             args = tuple()
529             if "args" in data:
530                 args = copy.deepcopy(data["args"])
531                 ret["fun_args"].extend(data["args"])
532             kwargs = {}
533             if "kwargs" in data:
534                 kwargs = copy.deepcopy(data["kwargs"])
535                 ret["fun_args"].append(copy.deepcopy(kwargs))
536             if func not in self.functions:
537                 ret["return"] = self.functions.missing_fun_string(func)
538                 salt.utils.error.raise_error(
539                     message=self.functions.missing_fun_string(func)
540                 )
541             if not self.standalone:
542                 if "jid_include" not in data or data["jid_include"]:
543                     log.debug(
544                         "schedule.handle_func: adding this job to the "
545                         "jobcache with data %s",
546                         ret,
547                     )
548                     with salt.utils.files.fopen(proc_fn, "w+b") as fp_:
549                         fp_.write(salt.payload.dumps(ret))
550             argspec = salt.utils.args.get_function_argspec(self.functions[func])
551             if argspec.keywords:
552                 for key, val in ret.items():
553                     if key != "kwargs":
554                         kwargs["__pub_{}".format(key)] = copy.deepcopy(val)
555             if self.opts["__role"] == "master":
556                 jid = salt.utils.jid.gen_jid(self.opts)
557                 tag = salt.utils.event.tagify(jid, prefix="salt/scheduler/")
558                 namespaced_event = salt.utils.event.NamespacedEvent(
559                     salt.utils.event.get_event(
560                         self.opts["__role"],
561                         self.opts["sock_dir"],
562                         opts=self.opts,
563                         listen=False,
564                     ),
565                     tag,
566                     print_func=None,
567                 )
568                 func_globals = {
569                     "__jid__": jid,
570                     "__user__": salt.utils.user.get_user(),
571                     "__tag__": tag,
572                     "__jid_event__": weakref.proxy(namespaced_event),
573                 }
574                 self_functions = copy.copy(self.functions)
575                 salt.utils.lazy.verify_fun(self_functions, func)
576                 completed_funcs = []
577                 for mod_name in self_functions.keys():
578                     if "." not in mod_name:
579                         continue
580                     mod, _ = mod_name.split(".", 1)
581                     if mod in completed_funcs:
582                         continue
583                     completed_funcs.append(mod)
584                     for global_key, value in func_globals.items():
585                         self.functions[mod_name].__globals__[global_key] = value
586             self.functions.pack["__context__"]["retcode"] = 0
587             ret["return"] = self.functions[func](*args, **kwargs)
588             if not self.standalone:
589                 if "retcode" in self.functions.pack["__context__"]:
590                     ret["retcode"] = self.functions.pack["__context__"]["retcode"]
591                 ret["success"] = True
592                 if data_returner or self.schedule_returner:
593                     if "return_config" in data:
594                         ret["ret_config"] = data["return_config"]
595                     if "return_kwargs" in data:
596                         ret["ret_kwargs"] = data["return_kwargs"]
597                     rets = []
598                     for returner in [data_returner, self.schedule_returner]:
599                         if isinstance(returner, str):
600                             rets.append(returner)
601                         elif isinstance(returner, list):
602                             rets.extend(returner)
603                     for returner in OrderedDict.fromkeys(rets):
604                         ret_str = "{}.returner".format(returner)
605                         if ret_str in self.returners:
606                             self.returners[ret_str](ret)
607                         else:
608                             log.info(
609                                 "Job %s using invalid returner: %s. Ignoring.",
610                                 func,
611                                 returner,
612                             )
613         except Exception:  # pylint: disable=broad-except
614             log.exception("Unhandled exception running %s", ret["fun"])
615             if "return" not in ret:
616                 ret["return"] = "Unhandled exception running {}".format(ret["fun"])
617             ret["success"] = False
618             ret["retcode"] = 254
619         finally:
620             if "__role" in self.opts and self.opts["__role"] in ("master", "minion"):
621                 if "return_job" in data and not data["return_job"]:
622                     pass
623                 else:
624                     mret = ret.copy()
625                     if not data_returner and not self.schedule_returner:
626                         mret["jid"] = "req"
627                         if data.get("return_job") == "nocache":
628                             mret["jid"] = "nocache"
629                     load = {"cmd": "_return", "id": self.opts["id"]}
630                     for key, value in mret.items():
631                     if "__role" in self.opts and self.opts["__role"] == "minion":
632                         event = salt.utils.event.get_event<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
633                             "minion", opts=self.opts, listen=False
634                         )
635                     elif "__role" in self.opts and self.opts["__role"] == "master":
636                         event = salt.utils.event.get_master_event(
637                             self.</b></font>opts, self.opts["sock_dir"]
638                         )
639                     try:
640                         event.fire_event(load, "__schedule_return")
641                     except Exception as exc:  # pylint: disable=broad-except
642                         log.exception(
643                             "Unhandled exception firing __schedule_return event"
644                         )
645                     finally:
646                         event.destroy()
647             if self.opts["__role"] == "master":
648                 namespaced_event.destroy()
649             if not self.standalone:
650                 log.debug("schedule.handle_func: Removing %s", proc_fn)
651                 try:
652                     os.unlink(proc_fn)
653                 except OSError as exc:
654                     if exc.errno == errno.EEXIST or exc.errno == errno.ENOENT:
655                         pass
656                     else:
657                         log.error("Failed to delete '%s': %s", proc_fn, exc.errno)
658                         raise
659                 finally:
660                     if multiprocessing_enabled:
661                         sys.exit(salt.defaults.exitcodes.EX_GENERIC)
662     def eval(self, now=None):
663         log.trace("==== evaluating schedule now %s =====", now)
664         jids = []
665         loop_interval = self.opts["loop_interval"]
666         if not isinstance(loop_interval, datetime.timedelta):
667             loop_interval = datetime.timedelta(seconds=loop_interval)
668         def _splay(splaytime):
669             splay_ = None
670             if isinstance(splaytime, dict):
671                 if splaytime["end"] &gt;= splaytime["start"]:
672                     splay_ = random.randint(splaytime["start"], splaytime["end"])
673                 else:
674                     log.error(
675                         "schedule.handle_func: Invalid Splay, "
676                         "end must be larger than start. Ignoring splay."
677                     )
678             else:
679                 splay_ = random.randint(1, splaytime)
680             return splay_
681         def _handle_time_elements(data):
682             if "_seconds" not in data:
683                 interval = int(data.get("seconds", 0))
684                 interval += int(data.get("minutes", 0)) * 60
685                 interval += int(data.get("hours", 0)) * 3600
686                 interval += int(data.get("days", 0)) * 86400
687                 data["_seconds"] = interval
688                 if not data["_next_fire_time"]:
689                     data["_next_fire_time"] = now + datetime.timedelta(
690                         seconds=data["_seconds"]
691                     )
692                 if interval &lt; self.loop_interval:
693                     self.loop_interval = interval
694                 data["_next_scheduled_fire_time"] = now + datetime.timedelta(
695                     seconds=data["_seconds"]
696                 )
697         def _handle_once(data, loop_interval):
698             if data["_next_fire_time"]:
699                 if (
700                     data["_next_fire_time"] &lt; now - loop_interval
701                     or data["_next_fire_time"] &gt; now
702                     and not data["_splay"]
703                 ):
704                     data["_continue"] = True
705             if not data["_next_fire_time"] and not data["_splay"]:
706                 once = data["once"]
707                 if not isinstance(once, datetime.datetime):
708                     once_fmt = data.get("once_fmt", "%Y-%m-%dT%H:%M:%S")
709                     try:
710                         once = datetime.datetime.strptime(data["once"], once_fmt)
711                     except (TypeError, ValueError):
712                         data["_error"] = (
713                             "Date string could not "
714                             "be parsed: {}, {}. "
715                             "Ignoring job {}.".format(
716                                 data["once"], once_fmt, data["name"]
717                             )
718                         )
719                         log.error(data["_error"])
720                         return
721                 data["_next_fire_time"] = once
722                 data["_next_scheduled_fire_time"] = once
723                 if once &lt; now - loop_interval:
724                     data["_continue"] = True
725         def _handle_when(data, loop_interval):
726             if not _WHEN_SUPPORTED:
727                 data["_error"] = "Missing python-dateutil. Ignoring job {}.".format(
728                     data["name"]
729                 )
730                 log.error(data["_error"])
731                 return
732             if not isinstance(data["when"], list):
733                 _when_data = [data["when"]]
734             else:
735                 _when_data = data["when"]
736             _when = []
737             for i in _when_data:
738                 if (
739                     "pillar" in self.opts
740                     and "whens" in self.opts["pillar"]
741                     and i in self.opts["pillar"]["whens"]
742                 ):
743                     if not isinstance(self.opts["pillar"]["whens"], dict):
744                         data["_error"] = (
745                             'Pillar item "whens" '
746                             "must be a dict. "
747                             "Ignoring job {}.".format(data["name"])
748                         )
749                         log.error(data["_error"])
750                         return
751                     when_ = self.opts["pillar"]["whens"][i]
752                 elif (
753                     "whens" in self.opts["grains"] and i in self.opts["grains"]["whens"]
754                 ):
755                     if not isinstance(self.opts["grains"]["whens"], dict):
756                         data[
757                             "_error"
758                         ] = 'Grain "whens" must be a dict. Ignoring job {}.'.format(
759                             data["name"]
760                         )
761                         log.error(data["_error"])
762                         return
763                     when_ = self.opts["grains"]["whens"][i]
764                 else:
765                     when_ = i
766                 if not isinstance(when_, datetime.datetime):
767                     try:
768                         when_ = dateutil_parser.parse(when_)
769                     except ValueError:
770                         data[
771                             "_error"
772                         ] = "Invalid date string {}. Ignoring job {}.".format(
773                             i, data["name"]
774                         )
775                         log.error(data["_error"])
776                         return
777                 _when.append(when_)
778             if data["_splay"]:
779                 _when.append(data["_splay"])
780             _when.sort()
781             for i in copy.deepcopy(_when):
782                 if len(_when) &gt; 1:
783                     if i &lt; now - loop_interval:
784                         _when.remove(i)
785             if _when:
786                 when = _when[0]
787                 if (
788                     when &lt; now - loop_interval
789                     and not data.get("_run", False)
790                     and not run
791                     and not data["_splay"]
792                 ):
793                     data["_next_fire_time"] = None
794                     data["_continue"] = True
795                     return
796                 if "_run" not in data:
797                     data["_run"] = bool(when &gt;= now - loop_interval)
798                 if not data["_next_fire_time"]:
799                     data["_next_fire_time"] = when
800                 data["_next_scheduled_fire_time"] = when
801                 if data["_next_fire_time"] &lt; when and not run and not data["_run"]:
802                     data["_next_fire_time"] = when
803                     data["_run"] = True
804             elif not data.get("_run", False):
805                 data["_next_fire_time"] = None
806                 data["_continue"] = True
807         def _handle_cron(data, loop_interval):
808             if not _CRON_SUPPORTED:
809                 data["_error"] = "Missing python-croniter. Ignoring job {}.".format(
810                     data["name"]
811                 )
812                 log.error(data["_error"])
813                 return
814             if data["_next_fire_time"] is None:
815                 try:
816                     data["_next_fire_time"] = croniter.croniter(
817                         data["cron"], now
818                     ).get_next(datetime.datetime)
819                     data["_next_scheduled_fire_time"] = croniter.croniter(
820                         data["cron"], now
821                     ).get_next(datetime.datetime)
822                 except (ValueError, KeyError):
823                     data["_error"] = "Invalid cron string. Ignoring job {}.".format(
824                         data["name"]
825                     )
826                     log.error(data["_error"])
827                     return
828                 interval = (now - data["_next_fire_time"]).total_seconds()
829                 if interval &gt;= 60 and interval &lt; self.loop_interval:
830                     self.loop_interval = interval
831         def _handle_run_explicit(data, loop_interval):
832             _run_explicit = []
833             for _run_time in data["run_explicit"]:
834                 if isinstance(_run_time, datetime.datetime):
835                     _run_explicit.append(_run_time)
836                 else:
837                     _run_explicit.append(
838                         datetime.datetime.strptime(
839                             _run_time["time"], _run_time["time_fmt"]
840                         )
841                     )
842             data["run"] = False
843             for i in copy.deepcopy(_run_explicit):
844                 if len(_run_explicit) &gt; 1:
845                     if i &lt; now - loop_interval:
846                         _run_explicit.remove(i)
847             if _run_explicit:
848                 if _run_explicit[0] &lt;= now &lt; _run_explicit[0] + loop_interval:
849                     data["run"] = True
850                     data["_next_fire_time"] = _run_explicit[0]
851         def _handle_skip_explicit(data, loop_interval):
852             data["run"] = False
853             _skip_explicit = []
854             for _skip_time in data["skip_explicit"]:
855                 if isinstance(_skip_time, datetime.datetime):
856                     _skip_explicit.append(_skip_time)
857                 else:
858                     _skip_explicit.append(
859                         datetime.datetime.strptime(
860                             _skip_time["time"], _skip_time["time_fmt"]
861                         )
862                     )
863             for i in copy.deepcopy(_skip_explicit):
864                 if i &lt; now - loop_interval:
865                     _skip_explicit.remove(i)
866             if _skip_explicit:
867                 if _skip_explicit[0] &lt;= now &lt;= (_skip_explicit[0] + loop_interval):
868                     if self.skip_function:
869                         data["run"] = True
870                         data["func"] = self.skip_function
871                     else:
872                         data["_skip_reason"] = "skip_explicit"
873                         data["_skipped_time"] = now
874                         data["_skipped"] = True
875                         data["run"] = False
876             else:
877                 data["run"] = True
878         def _handle_skip_during_range(data, loop_interval):
879             if not _RANGE_SUPPORTED:
880                 data["_error"] = "Missing python-dateutil. Ignoring job {}.".format(
881                     data["name"]
882                 )
883                 log.error(data["_error"])
884                 return
885             if not isinstance(data["skip_during_range"], dict):
886                 data["_error"] = (
887                     "schedule.handle_func: Invalid, range "
888                     "must be specified as a dictionary. "
889                     "Ignoring job {}.".format(data["name"])
890                 )
891                 log.error(data["_error"])
892                 return
893             start = data["skip_during_range"]["start"]
894             end = data["skip_during_range"]["end"]
895             if not isinstance(start, datetime.datetime):
896                 try:
897                     start = dateutil_parser.parse(start)
898                 except ValueError:
899                     data["_error"] = (
900                         "Invalid date string for start in "
901                         "skip_during_range. Ignoring "
902                         "job {}.".format(data["name"])
903                     )
904                     log.error(data["_error"])
905                     return
906             if not isinstance(end, datetime.datetime):
907                 try:
908                     end = dateutil_parser.parse(end)
909                 except ValueError:
910                     data["_error"] = (
911                         "Invalid date string for end in "
912                         "skip_during_range. Ignoring "
913                         "job {}.".format(data["name"])
914                     )
915                     log.error(data["_error"])
916                     return
917             if "run_after_skip_range" in data and data["run_after_skip_range"]:
918                 if "run_explicit" not in data:
919                     data["run_explicit"] = []
920                 _run_immediate = (end + loop_interval).strftime("%Y-%m-%dT%H:%M:%S")
921                 if _run_immediate not in data["run_explicit"]:
922                     data["run_explicit"].append(
923                         {"time": _run_immediate, "time_fmt": "%Y-%m-%dT%H:%M:%S"}
924                     )
925             if end &gt; start:
926                 if start &lt;= now &lt;= end:
927                     if self.skip_function:
928                         data["run"] = True
929                         data["func"] = self.skip_function
930                     else:
931                         data["_skip_reason"] = "in_skip_range"
932                         data["_skipped_time"] = now
933                         data["_skipped"] = True
934                         data["run"] = False
935                 else:
936                     data["run"] = True
937             else:
938                 data["_error"] = (
939                     "schedule.handle_func: Invalid "
940                     "range, end must be larger than "
941                     "start. Ignoring job {}.".format(data["name"])
942                 )
943                 log.error(data["_error"])
944         def _handle_range(data):
945             if not _RANGE_SUPPORTED:
946                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
947                     data["name"]
948                 )
949                 log.error(data["_error"])
950                 return
951             if not isinstance(data["range"], dict):
952                 data["_error"] = (
953                     "schedule.handle_func: Invalid, range "
954                     "must be specified as a dictionary."
955                     "Ignoring job {}.".format(data["name"])
956                 )
957                 log.error(data["_error"])
958                 return
959             start = data["range"]["start"]
960             end = data["range"]["end"]
961             if not isinstance(start, datetime.datetime):
962                 try:
963                     start = dateutil_parser.parse(start)
964                 except ValueError:
965                     data[
966                         "_error"
967                     ] = "Invalid date string for start. Ignoring job {}.".format(
968                         data["name"]
969                     )
970                     log.error(data["_error"])
971                     return
972             if not isinstance(end, datetime.datetime):
973                 try:
974                     end = dateutil_parser.parse(end)
975                 except ValueError:
976                     data[
977                         "_error"
978                     ] = "Invalid date string for end. Ignoring job {}.".format(
979                         data["name"]
980                     )
981                     log.error(data["_error"])
982                     return
983             if end &gt; start:
984                 if "invert" in data["range"] and data["range"]["invert"]:
985                     if now &lt;= start or now &gt;= end:
986                         data["run"] = True
987                     else:
988                         data["_skip_reason"] = "in_skip_range"
989                         data["run"] = False
990                 else:
991                     if start &lt;= now &lt;= end:
992                         data["run"] = True
993                     else:
994                         if self.skip_function:
995                             data["run"] = True
996                             data["func"] = self.skip_function
997                         else:
998                             data["_skip_reason"] = "not_in_range"
999                             data["run"] = False
1000             else:
1001                 data["_error"] = (
1002                     "schedule.handle_func: Invalid "
1003                     "range, end must be larger "
1004                     "than start. Ignoring job {}.".format(data["name"])
1005                 )
1006                 log.error(data["_error"])
1007         def _handle_after(data):
1008             if not _WHEN_SUPPORTED:
1009                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
1010                     data["name"]
1011                 )
1012                 log.error(data["_error"])
1013                 return
1014             after = data["after"]
1015             if not isinstance(after, datetime.datetime):
1016                 after = dateutil_parser.parse(after)
1017             if after &gt;= now:
1018                 log.debug("After time has not passed skipping job: %s.", data["name"])
1019                 data["_skip_reason"] = "after_not_passed"
1020                 data["_skipped_time"] = now
1021                 data["_skipped"] = True
1022                 data["run"] = False
1023             else:
1024                 data["run"] = True
1025         def _handle_until(data):
1026             if not _WHEN_SUPPORTED:
1027                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
1028                     data["name"]
1029                 )
1030                 log.error(data["_error"])
1031                 return
1032             until = data["until"]
1033             if not isinstance(until, datetime.datetime):
1034                 until = dateutil_parser.parse(until)
1035             if until &lt;= now:
1036                 log.debug("Until time has passed skipping job: %s.", data["name"])
1037                 data["_skip_reason"] = "until_passed"
1038                 data["_skipped_time"] = now
1039                 data["_skipped"] = True
1040                 data["run"] = False
1041             else:
1042                 data["run"] = True
1043         def _chop_ms(dt):
1044             return dt - datetime.timedelta(microseconds=dt.microsecond)
1045         schedule = self._get_schedule()
1046         if not isinstance(schedule, dict):
1047             raise ValueError("Schedule must be of type dict.")
1048         if "skip_function" in schedule:
1049             self.skip_function = schedule["skip_function"]
1050         if "skip_during_range" in schedule:
1051             self.skip_during_range = schedule["skip_during_range"]
1052         if "enabled" in schedule:
1053             self.enabled = schedule["enabled"]
1054         if "splay" in schedule:
1055             self.splay = schedule["splay"]
1056         _hidden = ["enabled", "skip_function", "skip_during_range", "splay"]
1057         for job, data in schedule.items():
1058             if job in _hidden:
1059                 continue
1060             for item in [
1061                 "_continue",
1062                 "_error",
1063                 "_enabled",
1064                 "_skipped",
1065                 "_skip_reason",
1066                 "_skipped_time",
1067             ]:
1068                 if item in data:
1069                     del data[item]
1070             run = False
1071             if "name" in data:
1072                 job_name = data["name"]
1073             else:
1074                 job_name = data["name"] = job
1075             if not isinstance(data, dict):
1076                 log.error(
1077                     'Scheduled job "%s" should have a dict value, not %s',
1078                     job_name,
1079                     type(data),
1080                 )
1081                 continue
1082             if "function" in data:
1083                 func = data["function"]
1084             elif "func" in data:
1085                 func = data["func"]
1086             elif "fun" in data:
1087                 func = data["fun"]
1088             else:
1089                 func = None
1090             if func not in self.functions:
1091                 log.info("Invalid function: %s in scheduled job %s.", func, job_name)
1092             if "_next_fire_time" not in data:
1093                 data["_next_fire_time"] = None
1094             if "_splay" not in data:
1095                 data["_splay"] = None
1096             if (
1097                 "run_on_start" in data
1098                 and data["run_on_start"]
1099                 and "_run_on_start" not in data
1100             ):
1101                 data["_run_on_start"] = True
1102             if not now:
1103                 now = datetime.datetime.now()
1104             schedule_keys = set(data.keys())
1105             time_elements = ("seconds", "minutes", "hours", "days")
1106             scheduling_elements = ("when", "cron", "once")
1107             invalid_sched_combos = [
1108                 set(i) for i in itertools.combinations(scheduling_elements, 2)
1109             ]
1110             if any(i &lt;= schedule_keys for i in invalid_sched_combos):
1111                 log.error(
1112                     'Unable to use "%s" options together. Ignoring.',
1113                     '", "'.join(scheduling_elements),
1114                 )
1115                 continue
1116             invalid_time_combos = []
1117             for item in scheduling_elements:
1118                 all_items = itertools.chain([item], time_elements)
1119                 invalid_time_combos.append(set(itertools.combinations(all_items, 2)))
1120             if any(set(x) &lt;= schedule_keys for x in invalid_time_combos):
1121                 log.error(
1122                     'Unable to use "%s" with "%s" options. Ignoring',
1123                     '", "'.join(time_elements),
1124                     '", "'.join(scheduling_elements),
1125                 )
1126                 continue
1127             if "run_explicit" in data:
1128                 _handle_run_explicit(data, loop_interval)
1129                 run = data["run"]
1130             if True in [True for item in time_elements if item in data]:
1131                 _handle_time_elements(data)
1132             elif "once" in data:
1133                 _handle_once(data, loop_interval)
1134             elif "when" in data:
1135                 _handle_when(data, loop_interval)
1136             elif "cron" in data:
1137                 _handle_cron(data, loop_interval)
1138             else:
1139                 continue
1140             if "_continue" in data and data["_continue"]:
1141                 continue
1142             if "_error" in data and data["_error"]:
1143                 continue
1144             seconds = int(
1145                 (_chop_ms(data["_next_fire_time"]) - _chop_ms(now)).total_seconds()
1146             )
1147             if "splay" not in data:
1148                 data["splay"] = self.splay
1149             if "splay" in data and data["splay"]:
1150                 if not data["_splay"]:
1151                     splay = _splay(data["splay"])
1152                     if now &lt; data["_next_fire_time"] + datetime.timedelta(
1153                         seconds=splay
1154                     ):
1155                         log.debug(
1156                             "schedule.handle_func: Adding splay of "
1157                             "%s seconds to next run.",
1158                             splay,
1159                         )
1160                         data["_splay"] = data["_next_fire_time"] + datetime.timedelta(
1161                             seconds=splay
1162                         )
1163                         if "when" in data:
1164                             data["_run"] = True
1165                     else:
1166                         run = True
1167                 if data["_splay"]:
1168                     seconds = (data["_splay"] - now).total_seconds()
1169                     if "when" in data:
1170                         data["_next_fire_time"] = data["_splay"]
1171             if "_seconds" in data:
1172                 if seconds &lt;= 0:
1173                     run = True
1174             elif "when" in data and data["_run"]:
1175                 if (
1176                     data["_next_fire_time"]
1177                     &lt;= now
1178                     &lt;= (data["_next_fire_time"] + loop_interval)
1179                 ):
1180                     data["_run"] = False
1181                     run = True
1182             elif "cron" in data:
1183                 if seconds &lt;= 0:
1184                     data["_next_fire_time"] = None
1185                     run = True
1186             elif "once" in data:
1187                 if (
1188                     data["_next_fire_time"]
1189                     &lt;= now
1190                     &lt;= (data["_next_fire_time"] + loop_interval)
1191                 ):
1192                     run = True
1193             elif seconds == 0:
1194                 run = True
1195             if "_run_on_start" in data and data["_run_on_start"]:
1196                 run = True
1197                 data["_run_on_start"] = False
1198             elif run:
1199                 if "range" in data:
1200                     _handle_range(data)
1201                     if "_error" in data and data["_error"]:
1202                         continue
1203                     run = data["run"]
1204                     if "func" in data:
1205                         func = data["func"]
1206                 if "skip_during_range" not in data and self.skip_during_range:
1207                     data["skip_during_range"] = self.skip_during_range
1208                 if "skip_during_range" in data and data["skip_during_range"]:
1209                     _handle_skip_during_range(data, loop_interval)
1210                     if "_error" in data and data["_error"]:
1211                         continue
1212                     run = data["run"]
1213                     if "func" in data:
1214                         func = data["func"]
1215                 if "skip_explicit" in data:
1216                     _handle_skip_explicit(data, loop_interval)
1217                     if "_error" in data and data["_error"]:
1218                         continue
1219                     run = data["run"]
1220                     if "func" in data:
1221                         func = data["func"]
1222                 if "until" in data:
1223                     _handle_until(data)
1224                     if "_error" in data and data["_error"]:
1225                         continue
1226                     run = data["run"]
1227                 if "after" in data:
1228                     _handle_after(data)
1229                     if "_error" in data and data["_error"]:
1230                         continue
1231                     run = data["run"]
1232             if "_continue" in data and data["_continue"]:
1233                 run = False
1234             if not self.enabled or not data.get("enabled", True):
1235                 log.trace("Job: %s is disabled", job_name)
1236                 data["_skip_reason"] = "disabled"
1237                 data["_skipped_time"] = now
1238                 data["_skipped"] = True
1239                 run = False
1240             miss_msg = ""
1241             if seconds &lt; 0:
1242                 miss_msg = " (runtime missed by {} seconds)".format(abs(seconds))
1243             try:
1244                 if run:
1245                     if "jid_include" not in data or data["jid_include"]:
1246                         data["jid_include"] = True
1247                         log.debug(
1248                             "schedule: Job %s was scheduled with jid_include, "
1249                             "adding to cache (jid_include defaults to True)",
1250                             job_name,
1251                         )
1252                         if "maxrunning" in data:
1253                             log.debug(
1254                                 "schedule: Job %s was scheduled with a max "
1255                                 "number of %s",
1256                                 job_name,
1257                                 data["maxrunning"],
1258                             )
1259                         else:
1260                             log.info(
1261                                 "schedule: maxrunning parameter was not specified for "
1262                                 "job %s, defaulting to 1.",
1263                                 job_name,
1264                             )
1265                             data["maxrunning"] = 1
1266                     if not self.standalone:
1267                         data["run"] = run
1268                         data = self._check_max_running(func, data, self.opts, now)
1269                         run = data["run"]
1270                 if run:
1271                     jid = salt.utils.jid.gen_jid(self.opts)
1272                     jids.append(jid)
1273                     log.info(
1274                         "Running scheduled job: %s%s with jid %s",
1275                         job_name,
1276                         miss_msg,
1277                         jid,
1278                     )
1279                     self._run_job(func, data, jid=jid)
1280             finally:
1281                 if run:
1282                     data["_last_run"] = now
1283                     data["_splay"] = None
1284                 if "_seconds" in data:
1285                     if self.standalone:
1286                         data["_next_fire_time"] = now + datetime.timedelta(
1287                             seconds=data["_seconds"]
1288                         )
1289                     elif "_skipped" in data and data["_skipped"]:
1290                         data["_next_fire_time"] = now + datetime.timedelta(
1291                             seconds=data["_seconds"]
1292                         )
1293                     elif run:
1294                         data["_next_fire_time"] = now + datetime.timedelta(
1295                             seconds=data["_seconds"]
1296                         )
1297         return jids
1298     def _run_job(self, func, data, jid=None):
1299         job_dry_run = data.get("dry_run", False)
1300         if job_dry_run:
1301             log.debug("Job %s has 'dry_run' set to True. Not running it.", data["name"])
1302             return
1303         multiprocessing_enabled = self.opts.get("multiprocessing", True)
1304         run_schedule_jobs_in_background = self.opts.get(
1305             "run_schedule_jobs_in_background", True
1306         )
1307         if run_schedule_jobs_in_background is False:
1308             self.handle_func(False, func, data, jid)
1309             return
1310         if multiprocessing_enabled and salt.utils.platform.is_windows():
1311             functions = self.functions
1312             self.functions = {}
1313             returners = self.returners
1314             self.returners = {}
1315             utils = self.utils
1316             self.utils = {}
1317         try:
1318             if multiprocessing_enabled:
1319                 thread_cls = salt.utils.process.SignalHandlingProcess
1320             else:
1321                 thread_cls = threading.Thread
1322             name = "Schedule(name={}, jid={})".format(data["name"], jid)
1323             if multiprocessing_enabled:
1324                 with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
1325                     proc = thread_cls(
1326                         target=self.handle_func,
1327                         args=(multiprocessing_enabled, func, data, jid),
1328                         name=name,
1329                     )
1330                     proc.start()
1331                     self._subprocess_list.add(proc)
1332             else:
1333                 proc = thread_cls(
1334                     target=self.handle_func,
1335                     args=(multiprocessing_enabled, func, data, jid),
1336                     name=name,
1337                 )
1338                 proc.start()
1339                 self._subprocess_list.add(proc)
1340         finally:
1341             if multiprocessing_enabled and salt.utils.platform.is_windows():
1342                 self.functions = functions
1343                 self.returners = returners
1344                 self.utils = utils
1345     def cleanup_subprocesses(self):
1346         self._subprocess_list.cleanup()
1347 def clean_proc_dir(opts):
1348     for basefilename in os.listdir(salt.minion.get_proc_dir(opts["cachedir"])):
1349         fn_ = os.path.join(salt.minion.get_proc_dir(opts["cachedir"]), basefilename)
1350         with salt.utils.files.fopen(fn_, "rb") as fp_:
1351             job = None
1352             try:
1353                 job = salt.payload.load(fp_)
1354             except Exception:  # pylint: disable=broad-except
1355                 if salt.utils.platform.is_windows():
1356                     fp_.close()
1357                 try:
1358                     os.unlink(fn_)
1359                     continue
1360                 except OSError:
1361                     continue
1362             log.debug(
1363                 "schedule.clean_proc_dir: checking job %s for process existence", job
1364             )
1365             if job is not None and "pid" in job:
1366                 if salt.utils.process.os_is_running(job["pid"]):
1367                     log.debug(
1368                         "schedule.clean_proc_dir: Cleaning proc dir, pid %s "
1369                         "still exists.",
1370                         job["pid"],
1371                     )
1372                 else:
1373                     if salt.utils.platform.is_windows():
1374                         fp_.close()
1375                     try:
1376                         os.unlink(fn_)
1377                     except OSError:
1378                         pass
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
