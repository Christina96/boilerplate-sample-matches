<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_netbox.py &amp; schedule.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_netbox.py &amp; schedule.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_netbox.py (1.4380531%)<th>schedule.py (0.4571027%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1906-1915)<td><a href="#" name="0">(899-904)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_netbox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import salt.pillar.netbox as netbox
3 from tests.support.mock import patch
4 @pytest.fixture
5 def default_kwargs():
6     return {
7         "minion_id": "minion1",
8         "pillar": None,
9         "api_url": "http://netbox.example.com",
10         "api_token": "yeic5oocizei7owuichoesh8ooqu6oob3uWiey9a",
11         "api_query_result_limit": 65535,
12     }
13 @pytest.fixture
14 def headers():
15     return {"Authorization": "Token quin1Di5MoRooChaiph3Aenaxais5EeY1gie6eev"}
16 @pytest.fixture
17 def device_results():
18     return {
19         "dict": {
20             "count": 1,
21             "next": None,
22             "previous": None,
23             "results": [
24                 {
25                     "id": 511,
26                     "url": "https://netbox.example.com/api/dcim/devices/511/",
27                     "name": "minion1",
28                     "display_name": "minion1",
29                     "device_type": {
30                         "id": 4,
31                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
32                         "manufacturer": {
33                             "id": 1,
34                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
35                             "name": "Cisco",
36                             "slug": "cisco",
37                         },
38                         "model": "ISR2901",
39                         "slug": "isr2901",
40                         "display_name": "Cisco ISR2901",
41                     },
42                     "device_role": {
43                         "id": 45,
44                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
45                         "name": "Network",
46                         "slug": "network",
47                     },
48                     "node_type": "device",
49                     "tenant": None,
50                     "platform": {
51                         "id": 1,
52                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
53                         "name": "Cisco IOS",
54                         "slug": "ios",
55                     },
56                     "serial": "",
57                     "asset_tag": None,
58                     "site": {
59                         "id": 18,
60                         "url": "https://netbox.example.com/api/dcim/sites/18/",
61                         "name": "Site 1",
62                         "slug": "site1",
63                     },
64                     "rack": None,
65                     "position": None,
66                     "face": None,
67                     "parent_device": None,
68                     "status": {"value": "active", "label": "Active"},
69                     "primary_ip": {
70                         "id": 1146,
71                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
72                         "family": 4,
73                         "address": "192.0.2.1/24",
74                     },
75                     "primary_ip4": {
76                         "id": 1146,
77                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
78                         "family": 4,
79                         "address": "192.0.2.1/24",
80                     },
81                     "primary_ip6": None,
82                     "cluster": None,
83                     "virtual_chassis": None,
84                     "vc_position": None,
85                     "vc_priority": None,
86                     "comments": "",
87                     "local_context_data": None,
88                     "tags": [],
89                     "custom_fields": {},
90                     "config_context": {},
91                     "created": "2021-02-19",
92                     "last_updated": "2021-02-19T06:12:04.171105Z",
93                 }
94             ],
95         }
96     }
97 @pytest.fixture
98 def multiple_device_results():
99     return {
100         "dict": {
101             "count": 2,
102             "next": None,
103             "previous": None,
104             "results": [
105                 {
106                     "id": 511,
107                     "url": "https://netbox.example.com/api/dcim/devices/511/",
108                     "name": "minion1",
109                     "display_name": "minion1",
110                     "device_type": {
111                         "id": 4,
112                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
113                         "manufacturer": {
114                             "id": 1,
115                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
116                             "name": "Cisco",
117                             "slug": "cisco",
118                         },
119                         "model": "ISR2901",
120                         "slug": "isr2901",
121                         "display_name": "Cisco ISR2901",
122                     },
123                     "device_role": {
124                         "id": 45,
125                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
126                         "name": "Network",
127                         "slug": "network",
128                     },
129                     "node_type": "device",
130                     "tenant": None,
131                     "platform": {
132                         "id": 1,
133                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
134                         "name": "Cisco IOS",
135                         "slug": "ios",
136                     },
137                     "serial": "",
138                     "asset_tag": None,
139                     "site": {
140                         "id": 18,
141                         "url": "https://netbox.example.com/api/dcim/sites/18/",
142                         "name": "Site 1",
143                         "slug": "site1",
144                     },
145                     "rack": None,
146                     "position": None,
147                     "face": None,
148                     "parent_device": None,
149                     "status": {"value": "active", "label": "Active"},
150                     "primary_ip": {
151                         "id": 1146,
152                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
153                         "family": 4,
154                         "address": "192.0.2.1/24",
155                     },
156                     "primary_ip4": {
157                         "id": 1146,
158                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
159                         "family": 4,
160                         "address": "192.0.2.1/24",
161                     },
162                     "primary_ip6": None,
163                     "cluster": None,
164                     "virtual_chassis": None,
165                     "vc_position": None,
166                     "vc_priority": None,
167                     "comments": "",
168                     "local_context_data": None,
169                     "tags": [],
170                     "custom_fields": {},
171                     "config_context": {},
172                     "created": "2021-02-19",
173                     "last_updated": "2021-02-19T06:12:04.171105Z",
174                 },
175                 {
176                     "id": 512,
177                     "url": "https://netbox.example.com/api/dcim/devices/512/",
178                     "name": "minion1",
179                     "display_name": "minion1",
180                     "device_type": {
181                         "id": 4,
182                         "url": "https://netbox.example.com/api/dcim/device-types/4/",
183                         "manufacturer": {
184                             "id": 1,
185                             "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
186                             "name": "Cisco",
187                             "slug": "cisco",
188                         },
189                         "model": "ISR2901",
190                         "slug": "isr2901",
191                         "display_name": "Cisco ISR2901",
192                     },
193                     "device_role": {
194                         "id": 45,
195                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
196                         "name": "Network",
197                         "slug": "network",
198                     },
199                     "node_type": "device",
200                     "tenant": None,
201                     "platform": {
202                         "id": 1,
203                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
204                         "name": "Cisco IOS",
205                         "slug": "ios",
206                     },
207                     "serial": "",
208                     "asset_tag": None,
209                     "site": {
210                         "id": 18,
211                         "url": "https://netbox.example.com/api/dcim/sites/18/",
212                         "name": "Site 1",
213                         "slug": "site1",
214                     },
215                     "rack": None,
216                     "position": None,
217                     "face": None,
218                     "parent_device": None,
219                     "status": {"value": "active", "label": "Active"},
220                     "primary_ip": {
221                         "id": 1150,
222                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1150/",
223                         "family": 4,
224                         "address": "192.0.2.3/24",
225                     },
226                     "primary_ip4": {
227                         "id": 1150,
228                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1150/",
229                         "family": 4,
230                         "address": "192.0.2.3/24",
231                     },
232                     "primary_ip6": None,
233                     "cluster": None,
234                     "virtual_chassis": None,
235                     "vc_position": None,
236                     "vc_priority": None,
237                     "comments": "",
238                     "local_context_data": None,
239                     "tags": [],
240                     "custom_fields": {},
241                     "config_context": {},
242                     "created": "2021-02-19",
243                     "last_updated": "2021-02-19T06:12:04.171105Z",
244                 },
245             ],
246         }
247     }
248 @pytest.fixture
249 def virtual_machine_results():
250     return {
251         "dict": {
252             "count": 1,
253             "next": None,
254             "previous": None,
255             "results": [
256                 {
257                     "id": 222,
258                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
259                     "name": "minion1",
260                     "status": {"value": "active", "label": "Active"},
261                     "site": {
262                         "id": 18,
263                         "url": "https://netbox.example.com/api/dcim/sites/18/",
264                         "name": "Site 1",
265                         "slug": "site1",
266                     },
267                     "cluster": {
268                         "id": 1,
269                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
270                         "name": "Cluster",
271                     },
272                     "role": {
273                         "id": 45,
274                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
275                         "name": "Network",
276                         "slug": "network",
277                     },
278                     "node_type": "virtual-machine",
279                     "tenant": None,
280                     "platform": {
281                         "id": 1,
282                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
283                         "name": "Cisco IOS",
284                         "slug": "ios",
285                     },
286                     "primary_ip": {
287                         "id": 1148,
288                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
289                         "family": 4,
290                         "address": "192.0.2.2/24",
291                     },
292                     "primary_ip4": {
293                         "id": 1148,
294                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
295                         "family": 4,
296                         "address": "192.0.2.2/24",
297                     },
298                     "primary_ip6": None,
299                     "vcpus": 1,
300                     "memory": 1024,
301                     "disk": 30,
302                     "comments": "",
303                     "local_context_data": None,
304                     "tags": [],
305                     "custom_fields": {},
306                     "config_context": {},
307                     "created": "2021-02-19",
308                     "last_updated": "2021-02-19T06:23:05.799541Z",
309                 }
310             ],
311         }
312     }
313 @pytest.fixture
314 def multiple_virtual_machine_results():
315     return {
316         "dict": {
317             "count": 1,
318             "next": None,
319             "previous": None,
320             "results": [
321                 {
322                     "id": 222,
323                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
324                     "name": "minion1",
325                     "status": {"value": "active", "label": "Active"},
326                     "site": {
327                         "id": 18,
328                         "url": "https://netbox.example.com/api/dcim/sites/18/",
329                         "name": "Site 1",
330                         "slug": "site1",
331                     },
332                     "cluster": {
333                         "id": 1,
334                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
335                         "name": "Cluster",
336                     },
337                     "role": {
338                         "id": 45,
339                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
340                         "name": "Network",
341                         "slug": "network",
342                     },
343                     "node_type": "virtual-machine",
344                     "tenant": None,
345                     "platform": {
346                         "id": 1,
347                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
348                         "name": "Cisco IOS",
349                         "slug": "ios",
350                     },
351                     "primary_ip": {
352                         "id": 1148,
353                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
354                         "family": 4,
355                         "address": "192.0.2.2/24",
356                     },
357                     "primary_ip4": {
358                         "id": 1148,
359                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
360                         "family": 4,
361                         "address": "192.0.2.2/24",
362                     },
363                     "primary_ip6": None,
364                     "vcpus": 1,
365                     "memory": 1024,
366                     "disk": 30,
367                     "comments": "",
368                     "local_context_data": None,
369                     "tags": [],
370                     "custom_fields": {},
371                     "config_context": {},
372                     "created": "2021-02-19",
373                     "last_updated": "2021-02-19T06:23:05.799541Z",
374                 },
375                 {
376                     "id": 223,
377                     "url": "https://netbox.example.com/api/virtualization/virtual-machines/223/",
378                     "name": "minion1",
379                     "status": {"value": "active", "label": "Active"},
380                     "site": {
381                         "id": 18,
382                         "url": "https://netbox.example.com/api/dcim/sites/18/",
383                         "name": "Site 1",
384                         "slug": "site1",
385                     },
386                     "cluster": {
387                         "id": 1,
388                         "url": "https://netbox.example.com/api/virtualization/clusters/1/",
389                         "name": "Cluster",
390                     },
391                     "role": {
392                         "id": 45,
393                         "url": "https://netbox.example.com/api/dcim/device-roles/45/",
394                         "name": "Network",
395                         "slug": "network",
396                     },
397                     "node_type": "virtual-machine",
398                     "tenant": None,
399                     "platform": {
400                         "id": 1,
401                         "url": "https://netbox.example.com/api/dcim/platforms/1/",
402                         "name": "Cisco IOS",
403                         "slug": "ios",
404                     },
405                     "primary_ip": {
406                         "id": 1152,
407                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1152/",
408                         "family": 4,
409                         "address": "192.0.2.4/24",
410                     },
411                     "primary_ip4": {
412                         "id": 1152,
413                         "url": "https://netbox.example.com/api/ipam/ip-addresses/1152/",
414                         "family": 4,
415                         "address": "192.0.2.4/24",
416                     },
417                     "primary_ip6": None,
418                     "vcpus": 1,
419                     "memory": 1024,
420                     "disk": 30,
421                     "comments": "",
422                     "local_context_data": None,
423                     "tags": [],
424                     "custom_fields": {},
425                     "config_context": {},
426                     "created": "2021-02-19",
427                     "last_updated": "2021-02-19T06:23:05.799541Z",
428                 },
429             ],
430         }
431     }
432 @pytest.fixture
433 def no_results():
434     return {"dict": {"count": 0, "next": None, "previous": None, "results": []}}
435 @pytest.fixture
436 def http_error():
437     return {"error": "HTTP 404: Not Found", "status": 404}
438 @pytest.fixture
439 def device_interface_results():
440     return {
441         "dict": {
442             "count": 2,
443             "next": None,
444             "previous": None,
445             "results": [
446                 {
447                     "id": 8158,
448                     "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
449                     "device": {
450                         "id": 511,
451                         "url": "https://netbox.example.com/api/dcim/devices/511/",
452                         "name": "minion1",
453                         "display_name": "minion1",
454                     },
455                     "name": "GigabitEthernet0/0",
456                     "label": "",
457                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
458                     "enabled": True,
459                     "lag": None,
460                     "mtu": None,
461                     "mac_address": None,
462                     "mgmt_only": False,
463                     "description": "",
464                     "mode": None,
465                     "untagged_vlan": None,
466                     "tagged_vlans": [],
467                     "cable": None,
468                     "cable_peer": None,
469                     "cable_peer_type": None,
470                     "connected_endpoint": None,
471                     "connected_endpoint_type": None,
472                     "connected_endpoint_reachable": None,
473                     "tags": [],
474                     "count_ipaddresses": 1,
475                 },
476                 {
477                     "id": 8159,
478                     "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
479                     "device": {
480                         "id": 511,
481                         "url": "https://netbox.example.com/api/dcim/devices/511/",
482                         "name": "minion1",
483                         "display_name": "minion1",
484                     },
485                     "name": "GigabitEthernet0/1",
486                     "label": "",
487                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
488                     "enabled": True,
489                     "lag": None,
490                     "mtu": None,
491                     "mac_address": None,
492                     "mgmt_only": False,
493                     "description": "",
494                     "mode": None,
495                     "untagged_vlan": None,
496                     "tagged_vlans": [],
497                     "cable": None,
498                     "cable_peer": None,
499                     "cable_peer_type": None,
500                     "connected_endpoint": None,
501                     "connected_endpoint_type": None,
502                     "connected_endpoint_reachable": None,
503                     "tags": [],
504                     "count_ipaddresses": 1,
505                 },
506             ],
507         }
508     }
509 @pytest.fixture
510 def device_interfaces_list():
511     return [
512         {
513             "id": 8158,
514             "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
515             "name": "GigabitEthernet0/0",
516             "label": "",
517             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
518             "enabled": True,
519             "lag": None,
520             "mtu": None,
521             "mac_address": None,
522             "mgmt_only": False,
523             "description": "",
524             "mode": None,
525             "untagged_vlan": None,
526             "tagged_vlans": [],
527             "cable": None,
528             "cable_peer": None,
529             "cable_peer_type": None,
530             "connected_endpoint": None,
531             "connected_endpoint_type": None,
532             "connected_endpoint_reachable": None,
533             "tags": [],
534             "count_ipaddresses": 1,
535         },
536         {
537             "id": 8159,
538             "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
539             "name": "GigabitEthernet0/1",
540             "label": "",
541             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
542             "enabled": True,
543             "lag": None,
544             "mtu": None,
545             "mac_address": None,
546             "mgmt_only": False,
547             "description": "",
548             "mode": None,
549             "untagged_vlan": None,
550             "tagged_vlans": [],
551             "cable": None,
552             "cable_peer": None,
553             "cable_peer_type": None,
554             "connected_endpoint": None,
555             "connected_endpoint_type": None,
556             "connected_endpoint_reachable": None,
557             "tags": [],
558             "count_ipaddresses": 1,
559         },
560     ]
561 @pytest.fixture
562 def virtual_machine_interface_results():
563     return {
564         "dict": {
565             "count": 2,
566             "next": None,
567             "previous": None,
568             "results": [
569                 {
570                     "id": 668,
571                     "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
572                     "virtual_machine": {
573                         "id": 222,
574                         "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
575                         "name": "minion1",
576                     },
577                     "name": "GigabitEthernet0/0",
578                     "enabled": True,
579                     "mtu": None,
580                     "mac_address": None,
581                     "description": "",
582                     "mode": None,
583                     "untagged_vlan": None,
584                     "tagged_vlans": [],
585                     "tags": [],
586                 },
587                 {
588                     "id": 669,
589                     "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
590                     "virtual_machine": {
591                         "id": 222,
592                         "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
593                         "name": "minion1",
594                     },
595                     "name": "GigabitEthernet0/1",
596                     "enabled": True,
597                     "mtu": None,
598                     "mac_address": None,
599                     "description": "",
600                     "mode": None,
601                     "untagged_vlan": None,
602                     "tagged_vlans": [],
603                     "tags": [],
604                 },
605             ],
606         }
607     }
608 @pytest.fixture
609 def virtual_machine_interfaces_list():
610     return [
611         {
612             "id": 668,
613             "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
614             "name": "GigabitEthernet0/0",
615             "enabled": True,
616             "mtu": None,
617             "mac_address": None,
618             "description": "",
619             "mode": None,
620             "untagged_vlan": None,
621             "tagged_vlans": [],
622             "tags": [],
623         },
624         {
625             "id": 669,
626             "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
627             "name": "GigabitEthernet0/1",
628             "enabled": True,
629             "mtu": None,
630             "mac_address": None,
631             "description": "",
632             "mode": None,
633             "untagged_vlan": None,
634             "tagged_vlans": [],
635             "tags": [],
636         },
637     ]
638 @pytest.fixture
639 def device_ip_results():
640     return {
641         "dict": {
642             "count": 2,
643             "next": None,
644             "previous": None,
645             "results": [
646                 {
647                     "id": 1146,
648                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
649                     "family": {"value": 4, "label": "IPv4"},
650                     "address": "192.0.2.1/24",
651                     "vrf": None,
652                     "tenant": None,
653                     "status": {"value": "active", "label": "Active"},
654                     "role": None,
655                     "assigned_object_type": "dcim.interface",
656                     "assigned_object_id": 8158,
657                     "assigned_object": {
658                         "id": 8158,
659                         "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
660                         "device": {
661                             "id": 511,
662                             "url": "https://netbox.example.com/api/dcim/devices/511/",
663                             "name": "minion1",
664                             "display_name": "minion1",
665                         },
666                         "name": "GigabitEthernet0/0",
667                         "cable": None,
668                     },
669                     "nat_inside": None,
670                     "nat_outside": None,
671                     "dns_name": "",
672                     "description": "",
673                     "tags": [],
674                     "custom_fields": {},
675                     "created": "2021-02-19",
676                     "last_updated": "2021-02-19T06:12:04.153386Z",
677                 },
678                 {
679                     "id": 1147,
680                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
681                     "family": {"value": 4, "label": "IPv4"},
682                     "address": "198.51.100.1/24",
683                     "vrf": None,
684                     "tenant": None,
685                     "status": {"value": "active", "label": "Active"},
686                     "role": None,
687                     "assigned_object_type": "dcim.interface",
688                     "assigned_object_id": 8159,
689                     "assigned_object": {
690                         "id": 8159,
691                         "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
692                         "device": {
693                             "id": 511,
694                             "url": "https://netbox.example.com/api/dcim/devices/511/",
695                             "name": "minion1",
696                             "display_name": "minion1",
697                         },
698                         "name": "GigabitEthernet0/1",
699                         "cable": None,
700                     },
701                     "nat_inside": None,
702                     "nat_outside": None,
703                     "dns_name": "",
704                     "description": "",
705                     "tags": [],
706                     "custom_fields": {},
707                     "created": "2021-02-19",
708                     "last_updated": "2021-02-19T06:12:40.508154Z",
709                 },
710             ],
711         }
712     }
713 @pytest.fixture
714 def virtual_machine_ip_results():
715     return {
716         "dict": {
717             "count": 2,
718             "next": None,
719             "previous": None,
720             "results": [
721                 {
722                     "id": 1148,
723                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
724                     "family": {"value": 4, "label": "IPv4"},
725                     "address": "192.0.2.2/24",
726                     "vrf": None,
727                     "tenant": None,
728                     "status": {"value": "active", "label": "Active"},
729                     "role": None,
730                     "assigned_object_type": "virtualization.vminterface",
731                     "assigned_object_id": 668,
732                     "assigned_object": {
733                         "id": 668,
734                         "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
735                         "virtual_machine": {
736                             "id": 222,
737                             "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
738                             "name": "minion1",
739                         },
740                         "name": "GigabitEthernet0/0",
741                     },
742                     "nat_inside": None,
743                     "nat_outside": None,
744                     "dns_name": "",
745                     "description": "",
746                     "tags": [],
747                     "custom_fields": {},
748                     "created": "2021-02-19",
749                     "last_updated": "2021-02-19T06:23:05.784281Z",
750                 },
751                 {
752                     "id": 1149,
753                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1149/",
754                     "family": {"value": 4, "label": "IPv4"},
755                     "address": "198.51.100.2/24",
756                     "vrf": None,
757                     "tenant": None,
758                     "status": {"value": "active", "label": "Active"},
759                     "role": None,
760                     "assigned_object_type": "virtualization.vminterface",
761                     "assigned_object_id": 669,
762                     "assigned_object": {
763                         "id": 669,
764                         "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
765                         "virtual_machine": {
766                             "id": 222,
767                             "url": "https://netbox.example.com/api/virtualization/virtual-machines/222/",
768                             "name": "minion1",
769                         },
770                         "name": "GigabitEthernet0/1",
771                     },
772                     "nat_inside": None,
773                     "nat_outside": None,
774                     "dns_name": "",
775                     "description": "",
776                     "tags": [],
777                     "custom_fields": {},
778                     "created": "2021-02-19",
779                     "last_updated": "2021-02-19T06:23:29.607428Z",
780                 },
781             ],
782         }
783     }
784 @pytest.fixture
785 def device_interfaces_ip_list():
786     return [
787         {
788             "id": 8158,
789             "ip_addresses": [
790                 {
791                     "id": 1146,
792                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
793                     "family": {"value": 4, "label": "IPv4"},
794                     "address": "192.0.2.1/24",
795                     "vrf": None,
796                     "tenant": None,
797                     "status": {"value": "active", "label": "Active"},
798                     "role": None,
799                     "nat_inside": None,
800                     "nat_outside": None,
801                     "dns_name": "",
802                     "description": "",
803                     "tags": [],
804                     "custom_fields": {},
805                     "created": "2021-02-19",
806                     "last_updated": "2021-02-19T06:12:04.153386Z",
807                 },
808             ],
809             "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
810             "name": "GigabitEthernet0/0",
811             "label": "",
812             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
813             "enabled": True,
814             "lag": None,
815             "mtu": None,
816             "mac_address": None,
817             "mgmt_only": False,
818             "description": "",
819             "mode": None,
820             "untagged_vlan": None,
821             "tagged_vlans": [],
822             "cable": None,
823             "cable_peer": None,
824             "cable_peer_type": None,
825             "connected_endpoint": None,
826             "connected_endpoint_type": None,
827             "connected_endpoint_reachable": None,
828             "tags": [],
829             "count_ipaddresses": 1,
830         },
831         {
832             "id": 8159,
833             "ip_addresses": [
834                 {
835                     "id": 1147,
836                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
837                     "family": {"value": 4, "label": "IPv4"},
838                     "address": "198.51.100.1/24",
839                     "vrf": None,
840                     "tenant": None,
841                     "status": {"value": "active", "label": "Active"},
842                     "role": None,
843                     "nat_inside": None,
844                     "nat_outside": None,
845                     "dns_name": "",
846                     "description": "",
847                     "tags": [],
848                     "custom_fields": {},
849                     "created": "2021-02-19",
850                     "last_updated": "2021-02-19T06:12:40.508154Z",
851                 },
852             ],
853             "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
854             "name": "GigabitEthernet0/1",
855             "label": "",
856             "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
857             "enabled": True,
858             "lag": None,
859             "mtu": None,
860             "mac_address": None,
861             "mgmt_only": False,
862             "description": "",
863             "mode": None,
864             "untagged_vlan": None,
865             "tagged_vlans": [],
866             "cable": None,
867             "cable_peer": None,
868             "cable_peer_type": None,
869             "connected_endpoint": None,
870             "connected_endpoint_type": None,
871             "connected_endpoint_reachable": None,
872             "tags": [],
873             "count_ipaddresses": 1,
874         },
875     ]
876 @pytest.fixture
877 def virtual_machine_interfaces_ip_list():
878     return [
879         {
880             "id": 668,
881             "ip_addresses": [
882                 {
883                     "id": 1148,
884                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1148/",
885                     "family": {"value": 4, "label": "IPv4"},
886                     "address": "192.0.2.2/24",
887                     "vrf": None,
888                     "tenant": None,
889                     "status": {"value": "active", "label": "Active"},
890                     "role": None,
891                     "nat_inside": None,
892                     "nat_outside": None,
893                     "dns_name": "",
894                     "description": "",
895                     "tags": [],
896                     "custom_fields": {},
897                     "created": "2021-02-19",
898                     "last_updated": "2021-02-19T06:23:05.784281Z",
899                 },
900             ],
901             "url": "https://netbox.example.com/api/virtualization/interfaces/668/",
902             "name": "GigabitEthernet0/0",
903             "enabled": True,
904             "mtu": None,
905             "mac_address": None,
906             "description": "",
907             "mode": None,
908             "untagged_vlan": None,
909             "tagged_vlans": [],
910             "tags": [],
911         },
912         {
913             "id": 669,
914             "ip_addresses": [
915                 {
916                     "id": 1149,
917                     "url": "https://netbox.example.com/api/ipam/ip-addresses/1149/",
918                     "family": {"value": 4, "label": "IPv4"},
919                     "address": "198.51.100.2/24",
920                     "vrf": None,
921                     "tenant": None,
922                     "status": {"value": "active", "label": "Active"},
923                     "role": None,
924                     "nat_inside": None,
925                     "nat_outside": None,
926                     "dns_name": "",
927                     "description": "",
928                     "tags": [],
929                     "custom_fields": {},
930                     "created": "2021-02-19",
931                     "last_updated": "2021-02-19T06:23:29.607428Z",
932                 },
933             ],
934             "url": "https://netbox.example.com/api/virtualization/interfaces/669/",
935             "name": "GigabitEthernet0/1",
936             "enabled": True,
937             "mtu": None,
938             "mac_address": None,
939             "description": "",
940             "mode": None,
941             "untagged_vlan": None,
942             "tagged_vlans": [],
943             "tags": [],
944         },
945     ]
946 @pytest.fixture
947 def site_results():
948     return {
949         "dict": {
950             "id": 18,
951             "url": "https://netbox.example.com/api/dcim/sites/18/",
952             "name": "Site 1",
953             "slug": "site1",
954             "status": {"value": "active", "label": "Active"},
955             "region": None,
956             "tenant": None,
957             "facility": "",
958             "asn": None,
959             "time_zone": None,
960             "description": "",
961             "physical_address": "",
962             "shipping_address": "",
963             "latitude": None,
964             "longitude": None,
965             "contact_name": "",
966             "contact_phone": "",
967             "contact_email": "",
968             "comments": "",
969             "tags": [],
970             "custom_fields": {},
971             "created": "2021-02-25",
972             "last_updated": "2021-02-25T14:21:07.898957Z",
973             "circuit_count": 0,
974             "device_count": 1,
975             "prefix_count": 2,
976             "rack_count": 0,
977             "virtualmachine_count": 1,
978             "vlan_count": 0,
979         }
980     }
981 @pytest.fixture
982 def site_prefixes_results():
983     return {
984         "dict": {
985             "count": 2,
986             "next": None,
987             "previous": None,
988             "results": [
989                 {
990                     "id": 284,
991                     "url": "https://netbox.example.com/api/ipam/prefixes/284/",
992                     "family": {"value": 4, "label": "IPv4"},
993                     "prefix": "192.0.2.0/24",
994                     "site": {
995                         "id": 18,
996                         "url": "https://netbox.example.com/api/dcim/sites/18/",
997                         "name": "Site 1",
998                         "slug": "site1",
999                     },
1000                     "vrf": None,
1001                     "tenant": None,
1002                     "vlan": None,
1003                     "status": {"value": "active", "label": "Active"},
1004                     "role": None,
1005                     "is_pool": False,
1006                     "description": "",
1007                     "tags": [],
1008                     "custom_fields": {},
1009                     "created": "2021-02-25",
1010                     "last_updated": "2021-02-25T15:08:27.136305Z",
1011                 },
1012                 {
1013                     "id": 285,
1014                     "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1015                     "family": {"value": 4, "label": "IPv4"},
1016                     "prefix": "198.51.100.0/24",
1017                     "site": {
1018                         "id": 18,
1019                         "url": "https://netbox.example.com/api/dcim/sites/18/",
1020                         "name": "Site 1",
1021                         "slug": "site1",
1022                     },
1023                     "vrf": None,
1024                     "tenant": None,
1025                     "vlan": None,
1026                     "status": {"value": "active", "label": "Active"},
1027                     "role": None,
1028                     "is_pool": False,
1029                     "description": "",
1030                     "tags": [],
1031                     "custom_fields": {},
1032                     "created": "2021-02-25",
1033                     "last_updated": "2021-02-25T15:08:59.880440Z",
1034                 },
1035             ],
1036         }
1037     }
1038 @pytest.fixture
1039 def site_prefixes():
1040     return [
1041         {
1042             "id": 284,
1043             "url": "https://netbox.example.com/api/ipam/prefixes/284/",
1044             "family": {"value": 4, "label": "IPv4"},
1045             "prefix": "192.0.2.0/24",
1046             "vrf": None,
1047             "tenant": None,
1048             "vlan": None,
1049             "status": {"value": "active", "label": "Active"},
1050             "role": None,
1051             "is_pool": False,
1052             "description": "",
1053             "tags": [],
1054             "custom_fields": {},
1055             "created": "2021-02-25",
1056             "last_updated": "2021-02-25T15:08:27.136305Z",
1057         },
1058         {
1059             "id": 285,
1060             "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1061             "family": {"value": 4, "label": "IPv4"},
1062             "prefix": "198.51.100.0/24",
1063             "vrf": None,
1064             "tenant": None,
1065             "vlan": None,
1066             "status": {"value": "active", "label": "Active"},
1067             "role": None,
1068             "is_pool": False,
1069             "description": "",
1070             "tags": [],
1071             "custom_fields": {},
1072             "created": "2021-02-25",
1073             "last_updated": "2021-02-25T15:08:59.880440Z",
1074         },
1075     ]
1076 @pytest.fixture
1077 def proxy_details_results():
1078     return {
1079         "dict": {
1080             "id": 1,
1081             "url": "https://netbox.example.com/api/dcim/platforms/1/",
1082             "name": "Cisco IOS",
1083             "slug": "ios",
1084             "manufacturer": {
1085                 "id": 1,
1086                 "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
1087                 "name": "Cisco",
1088                 "slug": "cisco",
1089             },
1090             "napalm_driver": "ios",
1091             "napalm_args": None,
1092             "description": "",
1093             "device_count": 152,
1094             "virtualmachine_count": 1,
1095         }
1096     }
1097 @pytest.fixture
1098 def proxy_details():
1099     return {
1100         "host": "192.0.2.1",
1101         "driver": "ios",
1102         "proxytype": "napalm",
1103     }
1104 @pytest.fixture
1105 def pillar_results():
1106     return {
1107         "netbox": {
1108             "id": 511,
1109             "url": "https://netbox.example.com/api/dcim/devices/511/",
1110             "name": "minion1",
1111             "node_type": "device",
1112             "display_name": "minion1",
1113             "device_type": {
1114                 "id": 4,
1115                 "url": "https://netbox.example.com/api/dcim/device-types/4/",
1116                 "manufacturer": {
1117                     "id": 1,
1118                     "url": "https://netbox.example.com/api/dcim/manufacturers/1/",
1119                     "name": "Cisco",
1120                     "slug": "cisco",
1121                 },
1122                 "model": "ISR2901",
1123                 "slug": "isr2901",
1124                 "display_name": "Cisco ISR2901",
1125             },
1126             "device_role": {
1127                 "id": 45,
1128                 "url": "https://netbox.example.com/api/dcim/device-roles/45/",
1129                 "name": "Network",
1130                 "slug": "network",
1131             },
1132             "interfaces": [
1133                 {
1134                     "id": 8158,
1135                     "ip_addresses": [
1136                         {
1137                             "id": 1146,
1138                             "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1139                             "family": {"value": 4, "label": "IPv4"},
1140                             "address": "192.0.2.1/24",
1141                             "vrf": None,
1142                             "tenant": None,
1143                             "status": {"value": "active", "label": "Active"},
1144                             "role": None,
1145                             "nat_inside": None,
1146                             "nat_outside": None,
1147                             "dns_name": "",
1148                             "description": "",
1149                             "tags": [],
1150                             "custom_fields": {},
1151                             "created": "2021-02-19",
1152                             "last_updated": "2021-02-19T06:12:04.153386Z",
1153                         },
1154                     ],
1155                     "url": "https://netbox.example.com/api/dcim/interfaces/8158/",
1156                     "name": "GigabitEthernet0/0",
1157                     "label": "",
1158                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
1159                     "enabled": True,
1160                     "lag": None,
1161                     "mtu": None,
1162                     "mac_address": None,
1163                     "mgmt_only": False,
1164                     "description": "",
1165                     "mode": None,
1166                     "untagged_vlan": None,
1167                     "tagged_vlans": [],
1168                     "cable": None,
1169                     "cable_peer": None,
1170                     "cable_peer_type": None,
1171                     "connected_endpoint": None,
1172                     "connected_endpoint_type": None,
1173                     "connected_endpoint_reachable": None,
1174                     "tags": [],
1175                     "count_ipaddresses": 1,
1176                 },
1177                 {
1178                     "id": 8159,
1179                     "ip_addresses": [
1180                         {
1181                             "id": 1147,
1182                             "url": "https://netbox.example.com/api/ipam/ip-addresses/1147/",
1183                             "family": {"value": 4, "label": "IPv4"},
1184                             "address": "198.51.100.1/24",
1185                             "vrf": None,
1186                             "tenant": None,
1187                             "status": {"value": "active", "label": "Active"},
1188                             "role": None,
1189                             "nat_inside": None,
1190                             "nat_outside": None,
1191                             "dns_name": "",
1192                             "description": "",
1193                             "tags": [],
1194                             "custom_fields": {},
1195                             "created": "2021-02-19",
1196                             "last_updated": "2021-02-19T06:12:40.508154Z",
1197                         },
1198                     ],
1199                     "url": "https://netbox.example.com/api/dcim/interfaces/8159/",
1200                     "name": "GigabitEthernet0/1",
1201                     "label": "",
1202                     "type": {"value": "1000base-t", "label": "1000BASE-T (1GE)"},
1203                     "enabled": True,
1204                     "lag": None,
1205                     "mtu": None,
1206                     "mac_address": None,
1207                     "mgmt_only": False,
1208                     "description": "",
1209                     "mode": None,
1210                     "untagged_vlan": None,
1211                     "tagged_vlans": [],
1212                     "cable": None,
1213                     "cable_peer": None,
1214                     "cable_peer_type": None,
1215                     "connected_endpoint": None,
1216                     "connected_endpoint_type": None,
1217                     "connected_endpoint_reachable": None,
1218                     "tags": [],
1219                     "count_ipaddresses": 1,
1220                 },
1221             ],
1222             "tenant": None,
1223             "platform": {
1224                 "id": 1,
1225                 "url": "https://netbox.example.com/api/dcim/platforms/1/",
1226                 "name": "Cisco IOS",
1227                 "slug": "ios",
1228             },
1229             "serial": "",
1230             "asset_tag": None,
1231             "site": {
1232                 "id": 18,
1233                 "url": "https://netbox.example.com/api/dcim/sites/18/",
1234                 "name": "Site 1",
1235                 "slug": "site1",
1236                 "status": {"value": "active", "label": "Active"},
1237                 "region": None,
1238                 "tenant": None,
1239                 "facility": "",
1240                 "asn": None,
1241                 "time_zone": None,
1242                 "description": "",
1243                 "physical_address": "",
1244                 "shipping_address": "",
1245                 "latitude": None,
1246                 "longitude": None,
1247                 "contact_name": "",
1248                 "contact_phone": "",
1249                 "contact_email": "",
1250                 "comments": "",
1251                 "tags": [],
1252                 "custom_fields": {},
1253                 "created": "2021-02-25",
1254                 "last_updated": "2021-02-25T14:21:07.898957Z",
1255                 "circuit_count": 0,
1256                 "device_count": 1,
1257                 "prefix_count": 2,
1258                 "rack_count": 0,
1259                 "virtualmachine_count": 1,
1260                 "vlan_count": 0,
1261                 "prefixes": [
1262                     {
1263                         "id": 284,
1264                         "url": "https://netbox.example.com/api/ipam/prefixes/284/",
1265                         "family": {"value": 4, "label": "IPv4"},
1266                         "prefix": "192.0.2.0/24",
1267                         "vrf": None,
1268                         "tenant": None,
1269                         "vlan": None,
1270                         "status": {"value": "active", "label": "Active"},
1271                         "role": None,
1272                         "is_pool": False,
1273                         "description": "",
1274                         "tags": [],
1275                         "custom_fields": {},
1276                         "created": "2021-02-25",
1277                         "last_updated": "2021-02-25T15:08:27.136305Z",
1278                     },
1279                     {
1280                         "id": 285,
1281                         "url": "https://netbox.example.com/api/ipam/prefixes/285/",
1282                         "family": {"value": 4, "label": "IPv4"},
1283                         "prefix": "198.51.100.0/24",
1284                         "vrf": None,
1285                         "tenant": None,
1286                         "vlan": None,
1287                         "status": {"value": "active", "label": "Active"},
1288                         "role": None,
1289                         "is_pool": False,
1290                         "description": "",
1291                         "tags": [],
1292                         "custom_fields": {},
1293                         "created": "2021-02-25",
1294                         "last_updated": "2021-02-25T15:08:59.880440Z",
1295                     },
1296                 ],
1297             },
1298             "rack": None,
1299             "position": None,
1300             "face": None,
1301             "parent_device": None,
1302             "status": {"value": "active", "label": "Active"},
1303             "primary_ip": {
1304                 "id": 1146,
1305                 "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1306                 "family": 4,
1307                 "address": "192.0.2.1/24",
1308             },
1309             "primary_ip4": {
1310                 "id": 1146,
1311                 "url": "https://netbox.example.com/api/ipam/ip-addresses/1146/",
1312                 "family": 4,
1313                 "address": "192.0.2.1/24",
1314             },
1315             "primary_ip6": None,
1316             "cluster": None,
1317             "virtual_chassis": None,
1318             "vc_position": None,
1319             "vc_priority": None,
1320             "comments": "",
1321             "local_context_data": None,
1322             "tags": [],
1323             "custom_fields": {},
1324             "config_context": {},
1325             "created": "2021-02-19",
1326             "last_updated": "2021-02-19T06:12:04.171105Z",
1327         },
1328         "proxy": {"host": "192.0.2.1", "driver": "ios", "proxytype": "napalm"},
1329     }
1330 def test_when_minion_id_is_star_then_result_should_be_empty_dict(default_kwargs):
1331     expected_result = {}
1332     default_kwargs["minion_id"] = "*"
1333     actual_result = netbox.ext_pillar(**default_kwargs)
1334     assert actual_result == expected_result
1335 def test_when_api_url_is_not_http_or_https_then_error_message_should_be_logged(
1336     default_kwargs,
1337 ):
1338     default_kwargs["api_url"] = "ftp://netbox.example.com"
1339     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1340         netbox.ext_pillar(**default_kwargs)
1341         fake_error.assert_called_with(
1342             'Provided URL for api_url "%s" is malformed or is not an http/https URL',
1343             "ftp://netbox.example.com",
1344         )
1345 def test_when_neither_devices_or_virtual_machines_requested_then_error_message_should_be_logged(
1346     default_kwargs,
1347 ):
1348     default_kwargs["devices"] = default_kwargs["virtual_machines"] = False
1349     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1350         netbox.ext_pillar(**default_kwargs)
1351         fake_error.assert_called_with(
1352             "At least one of devices or virtual_machines must be True"
1353         )
1354 def test_when_interface_ips_requested_but_not_interfaces_then_error_message_should_be_logged(
1355     default_kwargs,
1356 ):
1357     default_kwargs["interfaces"] = False
1358     default_kwargs["interface_ips"] = True
1359     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1360         netbox.ext_pillar(**default_kwargs)
1361         fake_error.assert_called_with(
1362             "The value for interfaces must be True if interface_ips is True"
1363         )
1364 def test_when_api_query_result_limit_set_but_not_a_positive_integer_then_error_message_should_be_logged(
1365     default_kwargs,
1366 ):
1367     default_kwargs["api_query_result_limit"] = -1
1368     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1369         netbox.ext_pillar(**default_kwargs)
1370         fake_error.assert_called_with(
1371             "The value for api_query_result_limit must be a postive integer if set"
1372         )
1373 def test_when_api_token_not_set_then_error_message_should_be_logged(
1374     default_kwargs,
1375 ):
1376     default_kwargs["api_token"] = ""
1377     with patch("salt.pillar.netbox.log.error", autospec=True) as fake_error:
1378         netbox.ext_pillar(**default_kwargs)
1379         fake_error.assert_called_with("The value for api_token is not set")
1380 def test_when_we_retrieve_a_single_device_then_return_list(
1381     default_kwargs, headers, device_results
1382 ):
1383     expected_result = device_results["dict"]["results"]
1384     with patch("salt.utils.http.query", autospec=True) as query:
1385         query.return_value = device_results
1386         actual_result = netbox._get_devices(
1387             default_kwargs["api_url"],
1388             default_kwargs["minion_id"],
1389             headers,
1390             default_kwargs["api_query_result_limit"],
1391         )
1392         assert actual_result == expected_result
1393 def test_when_we_retrieve_a_device_and_get_http_error_then_return_empty_list(
1394     default_kwargs, headers, http_error
1395 ):
1396     expected_result = []
1397     with patch("salt.utils.http.query", autospec=True) as query:
1398         query.return_value = http_error
1399         actual_result = netbox._get_devices(
1400             default_kwargs["api_url"],
1401             default_kwargs["minion_id"],
1402             headers,
1403             default_kwargs["api_query_result_limit"],
1404         )
1405         assert actual_result == expected_result
1406 def test_when_we_retrieve_a_single_virtual_machine_then_return_list(
1407     default_kwargs, headers, virtual_machine_results
1408 ):
1409     expected_result = virtual_machine_results["dict"]["results"]
1410     with patch("salt.utils.http.query", autospec=True) as query:
1411         query.return_value = virtual_machine_results
1412         actual_result = netbox._get_virtual_machines(
1413             default_kwargs["api_url"],
1414             default_kwargs["minion_id"],
1415             headers,
1416             default_kwargs["api_query_result_limit"],
1417         )
1418         assert actual_result == expected_result
1419 def test_when_we_retrieve_a_virtual_machine_and_get_http_error_then_return_empty_dict(
1420     default_kwargs, headers, http_error
1421 ):
1422     expected_result = []
1423     with patch("salt.utils.http.query", autospec=True) as query:
1424         query.return_value = http_error
1425         actual_result = netbox._get_virtual_machines(
1426             default_kwargs["api_url"],
1427             default_kwargs["minion_id"],
1428             headers,
1429             default_kwargs["api_query_result_limit"],
1430         )
1431         assert actual_result == expected_result
1432 def test_when_we_retrieve_device_interfaces_then_return_dict(
1433     default_kwargs, headers, device_interface_results, device_interfaces_list
1434 ):
1435     expected_result = device_interfaces_list
1436     with patch("salt.utils.http.query", autospec=True) as query:
1437         query.return_value = device_interface_results
1438         actual_result = netbox._get_interfaces(
1439             default_kwargs["api_url"],
1440             default_kwargs["minion_id"],
1441             511,
1442             "device",
1443             headers,
1444             default_kwargs["api_query_result_limit"],
1445         )
1446         assert actual_result == expected_result
1447 def test_when_we_retrieve_device_interfaces_and_get_http_error_then_return_empty_list(
1448     default_kwargs, headers, http_error
1449 ):
1450     expected_result = []
1451     with patch("salt.utils.http.query", autospec=True) as query:
1452         query.return_value = http_error
1453         actual_result = netbox._get_interfaces(
1454             default_kwargs["api_url"],
1455             default_kwargs["minion_id"],
1456             511,
1457             "device",
1458             headers,
1459             default_kwargs["api_query_result_limit"],
1460         )
1461         assert actual_result == expected_result
1462 def test_when_we_retrieve_virtual_machine_interfaces_then_return_list(
1463     default_kwargs,
1464     headers,
1465     virtual_machine_interface_results,
1466     virtual_machine_interfaces_list,
1467 ):
1468     expected_result = virtual_machine_interfaces_list
1469     with patch("salt.utils.http.query", autospec=True) as query:
1470         query.return_value = virtual_machine_interface_results
1471         actual_result = netbox._get_interfaces(
1472             default_kwargs["api_url"],
1473             default_kwargs["minion_id"],
1474             222,
1475             "virtual-machine",
1476             headers,
1477             default_kwargs["api_query_result_limit"],
1478         )
1479         assert actual_result == expected_result
1480 def test_when_we_retrieve_virtual_machine_interfaces_and_get_http_error_then_return_empty_list(
1481     default_kwargs, headers, http_error
1482 ):
1483     expected_result = []
1484     with patch("salt.utils.http.query", autospec=True) as query:
1485         query.return_value = http_error
1486         actual_result = netbox._get_interfaces(
1487             default_kwargs["api_url"],
1488             default_kwargs["minion_id"],
1489             222,
1490             "virtual-machine",
1491             headers,
1492             default_kwargs["api_query_result_limit"],
1493         )
1494         assert actual_result == expected_result
1495 def test_when_we_retrieve_device_interface_ips_then_return_list(
1496     default_kwargs, headers, device_ip_results
1497 ):
1498     expected_result = device_ip_results["dict"]["results"]
1499     with patch("salt.utils.http.query", autospec=True) as query:
1500         query.return_value = device_ip_results
1501         actual_result = netbox._get_interface_ips(
1502             default_kwargs["api_url"],
1503             default_kwargs["minion_id"],
1504             511,
1505             "device",
1506             headers,
1507             default_kwargs["api_query_result_limit"],
1508         )
1509         assert actual_result == expected_result
1510 def test_when_we_retrieve_device_interface_ips_and_get_http_error_then_return_empty_list(
1511     default_kwargs, headers, http_error
1512 ):
1513     expected_result = []
1514     with patch("salt.utils.http.query", autospec=True) as query:
1515         query.return_value = http_error
1516         actual_result = netbox._get_interface_ips(
1517             default_kwargs["api_url"],
1518             default_kwargs["minion_id"],
1519             511,
1520             "device",
1521             headers,
1522             default_kwargs["api_query_result_limit"],
1523         )
1524         assert actual_result == expected_result
1525 def test_when_we_retrieve_virtual_machine_interface_ips_then_return_list(
1526     default_kwargs, headers, virtual_machine_ip_results
1527 ):
1528     expected_result = virtual_machine_ip_results["dict"]["results"]
1529     with patch("salt.utils.http.query", autospec=True) as query:
1530         query.return_value = virtual_machine_ip_results
1531         actual_result = netbox._get_interface_ips(
1532             default_kwargs["api_url"],
1533             default_kwargs["minion_id"],
1534             222,
1535             "virtual-machine",
1536             headers,
1537             default_kwargs["api_query_result_limit"],
1538         )
1539         assert actual_result == expected_result
1540 def test_when_we_retrieve_virtual_machine_interface_ips_and_get_http_error_then_return_empty_list(
1541     default_kwargs, headers, http_error
1542 ):
1543     expected_result = []
1544     with patch("salt.utils.http.query", autospec=True) as query:
1545         query.return_value = http_error
1546         actual_result = netbox._get_interface_ips(
1547             default_kwargs["api_url"],
1548             default_kwargs["minion_id"],
1549             222,
1550             "virtual-machine",
1551             headers,
1552             default_kwargs["api_query_result_limit"],
1553         )
1554         assert actual_result == expected_result
1555 def test_associate_ips_to_interfaces_then_return_list(
1556     default_kwargs, device_interfaces_list, device_ip_results, device_interfaces_ip_list
1557 ):
1558     expected_result = device_interfaces_ip_list
1559     interfaces_list = device_interfaces_list
1560     interface_ips_list = device_ip_results["dict"]["results"]
1561     actual_result = netbox._associate_ips_to_interfaces(
1562         interfaces_list, interface_ips_list
1563     )
1564     assert actual_result == expected_result
1565 def test_associate_empty_ip_list_to_interfaces_then_return_list(
1566     default_kwargs, device_interfaces_list, device_ip_results
1567 ):
1568     expected_result = device_interfaces_list
1569     interfaces_list = device_interfaces_list
1570     interface_ips_list = []
1571     actual_result = netbox._associate_ips_to_interfaces(
1572         interfaces_list, interface_ips_list
1573     )
1574     assert actual_result == expected_result
1575 def test_when_we_retrieve_site_details_then_return_dict(
1576     default_kwargs, headers, site_results
1577 ):
1578     expected_result = site_results["dict"]
1579     with patch("salt.utils.http.query", autospec=True) as query:
1580         query.return_value = site_results
1581         actual_result = netbox._get_site_details(
1582             default_kwargs["api_url"],
1583             default_kwargs["minion_id"],
1584             "Site 1",
1585             18,
1586             headers,
1587         )
1588         assert actual_result == expected_result
1589 def test_when_we_retrieve_site_details_and_get_http_error_then_return_empty_dict(
1590     default_kwargs, headers, http_error
1591 ):
1592     expected_result = {}
1593     with patch("salt.utils.http.query", autospec=True) as query:
1594         query.return_value = http_error
1595         actual_result = netbox._get_site_details(
1596             default_kwargs["api_url"],
1597             default_kwargs["minion_id"],
1598             "Site 1",
1599             18,
1600             headers,
1601         )
1602         assert actual_result == expected_result
1603 def test_when_we_retrieve_site_prefixes_then_return_list(
1604     default_kwargs, headers, site_prefixes_results, site_prefixes
1605 ):
1606     expected_result = site_prefixes
1607     with patch("salt.utils.http.query", autospec=True) as query:
1608         query.return_value = site_prefixes_results
1609         actual_result = netbox._get_site_prefixes(
1610             default_kwargs["api_url"],
1611             default_kwargs["minion_id"],
1612             "Site 1",
1613             18,
1614             headers,
1615             default_kwargs["api_query_result_limit"],
1616         )
1617         assert actual_result == expected_result
1618 def test_when_we_retrieve_site_prefixes_and_get_http_error_then_return_empty_list(
1619     default_kwargs, headers, http_error
1620 ):
1621     expected_result = []
1622     with patch("salt.utils.http.query", autospec=True) as query:
1623         query.return_value = http_error
1624         actual_result = netbox._get_site_prefixes(
1625             default_kwargs["api_url"],
1626             default_kwargs["minion_id"],
1627             "Site 1",
1628             18,
1629             headers,
1630             default_kwargs["api_query_result_limit"],
1631         )
1632         assert actual_result == expected_result
1633 def test_when_we_retrieve_proxy_details_then_return_dict(
1634     default_kwargs, headers, proxy_details_results, proxy_details
1635 ):
1636     expected_result = proxy_details
1637     with patch("salt.utils.http.query", autospec=True) as query:
1638         query.return_value = proxy_details_results
1639         actual_result = netbox._get_proxy_details(
1640             default_kwargs["api_url"],
1641             default_kwargs["minion_id"],
1642             "192.0.2.1/24",
1643             1,
1644             headers,
1645         )
1646         assert actual_result == expected_result
1647 def test_when_we_retrieve_proxy_details_and_get_http_error_then_dont_return(
1648     default_kwargs, headers, http_error
1649 ):
1650     expected_result = None
1651     with patch("salt.utils.http.query", autospec=True) as query:
1652         query.return_value = http_error
1653         actual_result = netbox._get_proxy_details(
1654             default_kwargs["api_url"],
1655             default_kwargs["minion_id"],
1656             "192.0.2.1/24",
1657             1,
1658             headers,
1659         )
1660         assert actual_result == expected_result
1661 def test_when_we_retrieve_multiple_devices_then_error_message_should_be_logged(
1662     default_kwargs, multiple_device_results
1663 ):
1664     with patch(
1665         "salt.pillar.netbox._get_devices", autospec=True
1666     ) as multiple_devices, patch(
1667         "salt.pillar.netbox.log.error", autospec=True
1668     ) as fake_error:
1669         multiple_devices.return_value = multiple_device_results["dict"]["results"]
1670         netbox.ext_pillar(**default_kwargs)
1671         fake_error.assert_called_with(
1672             'More than one node found for "%s"',
1673             "minion1",
1674         )
1675 def test_when_we_retrieve_multiple_virtual_machines_then_error_message_should_be_logged(
1676     default_kwargs, multiple_virtual_machine_results
1677 ):
1678     default_kwargs["devices"] = False
1679     default_kwargs["virtual_machines"] = True
1680     with patch(
1681         "salt.pillar.netbox._get_virtual_machines", autospec=True
1682     ) as multiple_virtual_machines, patch(
1683         "salt.pillar.netbox.log.error", autospec=True
1684     ) as fake_error:
1685         multiple_virtual_machines.return_value = multiple_virtual_machine_results[
1686             "dict"
1687         ]["results"]
1688         netbox.ext_pillar(**default_kwargs)
1689         fake_error.assert_called_with(
1690             'More than one node found for "%s"',
1691             "minion1",
1692         )
1693 def test_when_we_retrieve_a_device_and_a_virtual_machine_then_error_message_should_be_logged(
1694     default_kwargs, device_results, virtual_machine_results
1695 ):
1696     default_kwargs["virtual_machines"] = True
1697 <a name="0"></a>
1698     with patch("salt.pillar.netbox._get_devices", autospec=True) as device, patch(
1699         "salt.pillar.netbox._get_virtual_machines", autospec=True
1700     ) as virtual_machine, patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1701         "salt.pillar.netbox.log.error", autospec=True
1702     ) as fake_error:
1703         device.return_value = device_results["dict"]["results"]
1704         virtual_machine.return_value = virtual_machine_results["dict"]["results"]
1705         netbox.ext_pillar(**default_kwargs)
1706         fake_error.</b></font>assert_called_with(
1707             'More than one node found for "%s"',
1708             "minion1",
1709         )
1710 def test_when_we_retrieve_no_devices_then_error_message_should_be_logged(
1711     default_kwargs, no_results
1712 ):
1713     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1714         "salt.pillar.netbox.log.error", autospec=True
1715     ) as fake_error:
1716         devices.return_value = no_results["dict"]["results"]
1717         netbox.ext_pillar(**default_kwargs)
1718         fake_error.assert_called_with(
1719             'Unable to pull NetBox data for "%s"',
1720             "minion1",
1721         )
1722 def test_when_we_retrieve_no_virtual_machines_then_error_message_should_be_logged(
1723     default_kwargs, no_results
1724 ):
1725     default_kwargs["devices"] = False
1726     default_kwargs["virtual_machines"] = True
1727     with patch(
1728         "salt.pillar.netbox._get_virtual_machines", autospec=True
1729     ) as virtual_machines, patch(
1730         "salt.pillar.netbox.log.error", autospec=True
1731     ) as fake_error:
1732         virtual_machines.return_value = no_results["dict"]["results"]
1733         netbox.ext_pillar(**default_kwargs)
1734         fake_error.assert_called_with(
1735             'Unable to pull NetBox data for "%s"',
1736             "minion1",
1737         )
1738 def test_when_we_retrieve_everything_successfully_then_return_dict(
1739     default_kwargs,
1740     device_results,
1741     no_results,
1742     device_interfaces_list,
1743     device_ip_results,
1744     site_results,
1745     site_prefixes,
1746     proxy_details,
1747     pillar_results,
1748 ):
1749     expected_result = pillar_results
1750     default_kwargs["virtual_machines"] = False
1751     default_kwargs["interfaces"] = True
1752     default_kwargs["interface_ips"] = True
1753     default_kwargs["site_details"] = True
1754     default_kwargs["site_prefixes"] = True
1755     default_kwargs["proxy_return"] = True
1756     with patch("salt.pillar.netbox._get_devices", autospec=True) as get_devices, patch(
1757         "salt.pillar.netbox._get_virtual_machines", autospec=True
1758     ) as get_virtual_machines, patch(
1759         "salt.pillar.netbox._get_interfaces", autospec=True
1760     ) as get_interfaces, patch(
1761         "salt.pillar.netbox._get_interface_ips", autospec=True
1762     ) as get_interface_ips, patch(
1763         "salt.pillar.netbox._get_site_details", autospec=True
1764     ) as get_site_details, patch(
1765         "salt.pillar.netbox._get_site_prefixes", autospec=True
1766     ) as get_site_prefixes, patch(
1767         "salt.pillar.netbox._get_proxy_details", autospec=True
1768     ) as get_proxy_details:
1769         get_devices.return_value = device_results["dict"]["results"]
1770         get_virtual_machines.return_value = no_results["dict"]["results"]
1771         get_interfaces.return_value = device_interfaces_list
1772         get_interface_ips.return_value = device_ip_results["dict"]["results"]
1773         get_site_details.return_value = site_results["dict"]
1774         get_site_prefixes.return_value = site_prefixes
1775         get_proxy_details.return_value = proxy_details
1776         actual_result = netbox.ext_pillar(**default_kwargs)
1777         assert actual_result == expected_result
1778 def test_when_we_set_proxy_return_but_get_no_value_for_platform_then_error_message_should_be_logged(
1779     default_kwargs, headers, device_results
1780 ):
1781     default_kwargs["site_details"] = False
1782     default_kwargs["site_prefixes"] = False
1783     default_kwargs["proxy_return"] = True
1784     device_results["dict"]["results"][0]["platform"] = None
1785     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1786         "salt.pillar.netbox.log.error", autospec=True
1787     ) as fake_error:
1788         devices.return_value = device_results["dict"]["results"]
1789         netbox.ext_pillar(**default_kwargs)
1790         fake_error.assert_called_with(
1791             'You have set "proxy_return" to "True" but you have not set the platform in NetBox for "%s"',
1792             "minion1",
1793         )
1794 def test_when_we_set_proxy_return_but_get_no_value_for_primary_ip_then_error_message_should_be_logged(
1795     default_kwargs, headers, device_results
1796 ):
1797     default_kwargs["site_details"] = False
1798     default_kwargs["site_prefixes"] = False
1799     default_kwargs["proxy_return"] = True
1800     device_results["dict"]["results"][0]["primary_ip"] = None
1801     with patch("salt.pillar.netbox._get_devices", autospec=True) as devices, patch(
1802         "salt.pillar.netbox.log.error", autospec=True
1803     ) as fake_error:
1804         devices.return_value = device_results["dict"]["results"]
1805         netbox.ext_pillar(**default_kwargs)
1806         fake_error.assert_called_with(
1807             'You have set "proxy_return" to "True" but you have not set the primary IPv4 or IPv6 address in NetBox for "%s"',
1808             "minion1",
1809         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>schedule.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import errno
4 import itertools
5 import logging
6 import os
7 import random
8 import signal
9 import sys
10 import threading
11 import time
12 import weakref
13 import salt.config
14 import salt.defaults.exitcodes
15 import salt.exceptions
16 import salt.loader
17 import salt.minion
18 import salt.payload
19 import salt.syspaths
20 import salt.utils.args
21 import salt.utils.error
22 import salt.utils.event
23 import salt.utils.files
24 import salt.utils.jid
25 import salt.utils.master
26 import salt.utils.minion
27 import salt.utils.platform
28 import salt.utils.process
29 import salt.utils.stringutils
30 import salt.utils.user
31 import salt.utils.yaml
32 from salt.exceptions import SaltInvocationError
33 from salt.utils.odict import OrderedDict
34 try:
35     import dateutil.parser as dateutil_parser
36     _WHEN_SUPPORTED = True
37     _RANGE_SUPPORTED = True
38 except ImportError:
39     _WHEN_SUPPORTED = False
40     _RANGE_SUPPORTED = False
41 try:
42     import croniter
43     _CRON_SUPPORTED = True
44 except ImportError:
45     _CRON_SUPPORTED = False
46 log = logging.getLogger(__name__)
47 class Schedule:
48     instance = None
49     def __new__(
50         cls,
51         opts,
52         functions,
53         returners=None,
54         intervals=None,
55         cleanup=None,
56         proxy=None,
57         standalone=False,
58         new_instance=False,
59         utils=None,
60         _subprocess_list=None,
61     ):
62         if cls.instance is None or new_instance is True:
63             log.debug("Initializing new Schedule")
64             instance = object.__new__(cls)
65             instance.__singleton_init__(
66                 opts,
67                 functions,
68                 returners=returners,
69                 intervals=intervals,
70                 cleanup=cleanup,
71                 proxy=proxy,
72                 standalone=standalone,
73                 utils=utils,
74                 _subprocess_list=_subprocess_list,
75             )
76             if new_instance is True:
77                 return instance
78             cls.instance = instance
79         else:
80             log.debug("Re-using Schedule")
81         return cls.instance
82     def __init__(
83         self,
84         opts,
85         functions,
86         returners=None,
87         intervals=None,
88         cleanup=None,
89         proxy=None,
90         standalone=False,
91         new_instance=False,
92         utils=None,
93         _subprocess_list=None,
94     ):
95         pass
96     def __singleton_init__(
97         self,
98         opts,
99         functions,
100         returners=None,
101         intervals=None,
102         cleanup=None,
103         proxy=None,
104         standalone=False,
105         utils=None,
106         _subprocess_list=None,
107     ):
108         self.opts = opts
109         self.proxy = proxy
110         self.functions = functions
111         self.utils = utils or salt.loader.utils(opts)
112         self.standalone = standalone
113         self.skip_function = None
114         self.skip_during_range = None
115         self.splay = None
116         self.enabled = True
117         if isinstance(intervals, dict):
118             self.intervals = intervals
119         else:
120             self.intervals = {}
121         if not self.standalone:
122             if hasattr(returners, "__getitem__"):
123                 self.returners = returners
124             else:
125                 self.returners = returners.loader.gen_functions()
126         try:
127             self.time_offset = self.functions.get(
128                 "timezone.get_offset", lambda: "0000"
129             )()
130         except Exception:  # pylint: disable=W0703
131             log.warning(
132                 "Unable to obtain correct timezone offset, defaulting to 0000",
133                 exc_info_on_loglevel=logging.DEBUG,
134             )
135             self.time_offset = "0000"
136         self.schedule_returner = self.option("schedule_returner")
137         self.loop_interval = sys.maxsize
138         if not self.standalone:
139             clean_proc_dir(opts)
140         if cleanup:
141             for prefix in cleanup:
142                 self.delete_job_prefix(prefix)
143         if _subprocess_list is None:
144             self._subprocess_list = salt.utils.process.SubprocessList()
145         else:
146             self._subprocess_list = _subprocess_list
147     def __getnewargs__(self):
148         return self.opts, self.functions, self.returners, self.intervals, None
149     def option(self, opt):
150         if "config.merge" in self.functions:
151             return self.functions["config.merge"](opt, {}, omit_master=True)
152         return self.opts.get(opt, {})
153     def _get_schedule(
154         self, include_opts=True, include_pillar=True, remove_hidden=False
155     ):
156         schedule = {}
157         if include_pillar:
158             pillar_schedule = self.opts.get("pillar", {}).get("schedule", {})
159             if not isinstance(pillar_schedule, dict):
160                 raise ValueError("Schedule must be of type dict.")
161             schedule.update(pillar_schedule)
162         if include_opts:
163             opts_schedule = self.opts.get("schedule", {})
164             if not isinstance(opts_schedule, dict):
165                 raise ValueError("Schedule must be of type dict.")
166             schedule.update(opts_schedule)
167         if remove_hidden:
168             _schedule = copy.deepcopy(schedule)
169             for job in _schedule:
170                 if isinstance(_schedule[job], dict):
171                     for item in _schedule[job]:
172                         if item.startswith("_"):
173                             del schedule[job][item]
174         return schedule
175     def _check_max_running(self, func, data, opts, now):
176         if "run" not in data or not data["run"]:
177             return data
178         if "jid_include" not in data or data["jid_include"]:
179             jobcount = 0
180             if self.opts["__role"] == "master":
181                 current_jobs = salt.utils.master.get_running_jobs(self.opts)
182             else:
183                 current_jobs = salt.utils.minion.running(self.opts)
184             for job in current_jobs:
185                 if "schedule" in job:
186                     log.debug(
187                         "schedule.handle_func: Checking job against fun %s: %s",
188                         func,
189                         job,
190                     )
191                     if data["name"] == job[
192                         "schedule"
193                     ] and salt.utils.process.os_is_running(job["pid"]):
194                         jobcount += 1
195                         log.debug(
196                             "schedule.handle_func: Incrementing jobcount, "
197                             "now %s, maxrunning is %s",
198                             jobcount,
199                             data["maxrunning"],
200                         )
201                         if jobcount &gt;= data["maxrunning"]:
202                             log.debug(
203                                 "schedule.handle_func: The scheduled job "
204                                 "%s was not started, %s already running",
205                                 data["name"],
206                                 data["maxrunning"],
207                             )
208                             data["_skip_reason"] = "maxrunning"
209                             data["_skipped"] = True
210                             data["_skipped_time"] = now
211                             data["run"] = False
212                             return data
213         return data
214     def persist(self):
215         config_dir = self.opts.get("conf_dir", None)
216         if config_dir is None and "conf_file" in self.opts:
217             config_dir = os.path.dirname(self.opts["conf_file"])
218         if config_dir is None:
219             config_dir = salt.syspaths.CONFIG_DIR
220         minion_d_dir = os.path.join(
221             config_dir,
222             os.path.dirname(
223                 self.opts.get(
224                     "default_include",
225                     salt.config.DEFAULT_MINION_OPTS["default_include"],
226                 )
227             ),
228         )
229         if not os.path.isdir(minion_d_dir):
230             os.makedirs(minion_d_dir)
231         schedule_conf = os.path.join(minion_d_dir, "_schedule.conf")
232         log.debug("Persisting schedule")
233         schedule_data = self._get_schedule(include_pillar=False, remove_hidden=True)
234         try:
235             with salt.utils.files.fopen(schedule_conf, "wb+") as fp_:
236                 fp_.write(
237                     salt.utils.stringutils.to_bytes(
238                         salt.utils.yaml.safe_dump({"schedule": schedule_data})
239                     )
240                 )
241         except OSError:
242             log.error(
243                 "Failed to persist the updated schedule",
244                 exc_info_on_loglevel=logging.DEBUG,
245             )
246     def delete_job(self, name, persist=True):
247         if name in self.opts["schedule"]:
248             del self.opts["schedule"][name]
249         elif name in self._get_schedule(include_opts=False):
250             log.warning("Cannot delete job %s, it's in the pillar!", name)
251         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
252             evt.fire_event(
253                 {"complete": True, "schedule": self._get_schedule()},
254                 tag="/salt/minion/minion_schedule_delete_complete",
255             )
256         if name in self.intervals:
257             del self.intervals[name]
258         if persist:
259             self.persist()
260     def reset(self):
261         self.skip_function = None
262         self.skip_during_range = None
263         self.enabled = True
264         self.splay = None
265         self.opts["schedule"] = {}
266     def delete_job_prefix(self, name, persist=True):
267         for job in list(self.opts["schedule"].keys()):
268             if job.startswith(name):
269                 del self.opts["schedule"][job]
270         for job in self._get_schedule(include_opts=False):
271             if job.startswith(name):
272                 log.warning("Cannot delete job %s, it's in the pillar!", job)
273         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
274             evt.fire_event(
275                 {"complete": True, "schedule": self._get_schedule()},
276                 tag="/salt/minion/minion_schedule_delete_complete",
277             )
278         for job in list(self.intervals.keys()):
279             if job.startswith(name):
280                 del self.intervals[job]
281         if persist:
282             self.persist()
283     def add_job(self, data, persist=True):
284         if not isinstance(data, dict):
285             raise ValueError("Scheduled jobs have to be of type dict.")
286         if not len(data) == 1:
287             raise ValueError("You can only schedule one new job at a time.")
288         for job in data:
289             if "enabled" not in data[job]:
290                 data[job]["enabled"] = True
291         new_job = next(iter(data.keys()))
292         if new_job in self._get_schedule(include_opts=False):
293             log.warning("Cannot update job %s, it's in the pillar!", new_job)
294         elif new_job in self.opts["schedule"]:
295             log.info("Updating job settings for scheduled job: %s", new_job)
296             self.opts["schedule"].update(data)
297         else:
298             log.info("Added new job %s to scheduler", new_job)
299             self.opts["schedule"].update(data)
300         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
301             evt.fire_event(
302                 {"complete": True, "schedule": self._get_schedule()},
303                 tag="/salt/minion/minion_schedule_add_complete",
304             )
305         if persist:
306             self.persist()
307     def enable_job(self, name, persist=True):
308         if name in self.opts["schedule"]:
309             self.opts["schedule"][name]["enabled"] = True
310             log.info("Enabling job %s in scheduler", name)
311         elif name in self._get_schedule(include_opts=False):
312             log.warning("Cannot modify job %s, it's in the pillar!", name)
313         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
314             evt.fire_event(
315                 {"complete": True, "schedule": self._get_schedule()},
316                 tag="/salt/minion/minion_schedule_enabled_job_complete",
317             )
318         if persist:
319             self.persist()
320     def disable_job(self, name, persist=True):
321         if name in self.opts["schedule"]:
322             self.opts["schedule"][name]["enabled"] = False
323             log.info("Disabling job %s in scheduler", name)
324         elif name in self._get_schedule(include_opts=False):
325             log.warning("Cannot modify job %s, it's in the pillar!", name)
326         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
327             evt.fire_event(
328                 {"complete": True, "schedule": self._get_schedule()},
329                 tag="/salt/minion/minion_schedule_disabled_job_complete",
330             )
331         if persist:
332             self.persist()
333     def modify_job(self, name, schedule, persist=True):
334         if name in self.opts["schedule"]:
335             self.delete_job(name, persist)
336         elif name in self._get_schedule(include_opts=False):
337             log.warning("Cannot modify job %s, it's in the pillar!", name)
338             return
339         self.opts["schedule"][name] = schedule
340         if persist:
341             self.persist()
342     def run_job(self, name):
343         data = self._get_schedule().get(name, {})
344         if "function" in data:
345             func = data["function"]
346         elif "func" in data:
347             func = data["func"]
348         elif "fun" in data:
349             func = data["fun"]
350         else:
351             func = None
352         if func not in self.functions:
353             log.info("Invalid function: %s in scheduled job %s.", func, name)
354         if "name" not in data:
355             data["name"] = name
356         if "run" not in data:
357             data["run"] = True
358         if not self.standalone:
359             data = self._check_max_running(
360                 func, data, self.opts, datetime.datetime.now()
361             )
362         if data.get("run"):
363             log.info("Running Job: %s", name)
364             self._run_job(func, data)
365     def enable_schedule(self, persist=True):
366         self.opts["schedule"]["enabled"] = True
367         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
368             evt.fire_event(
369                 {"complete": True, "schedule": self._get_schedule()},
370                 tag="/salt/minion/minion_schedule_enabled_complete",
371             )
372         if persist:
373             self.persist()
374     def disable_schedule(self, persist=True):
375         self.opts["schedule"]["enabled"] = False
376         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
377             evt.fire_event(
378                 {"complete": True, "schedule": self._get_schedule()},
379                 tag="/salt/minion/minion_schedule_disabled_complete",
380             )
381         if persist:
382             self.persist()
383     def reload(self, schedule):
384         self.intervals = {}
385         if "schedule" in schedule:
386             schedule = schedule["schedule"]
387         self.opts.setdefault("schedule", {}).update(schedule)
388     def list(self, where):
389         if where == "pillar":
390             schedule = self._get_schedule(include_opts=False)
391         elif where == "opts":
392             schedule = self._get_schedule(include_pillar=False)
393         else:
394             schedule = self._get_schedule()
395         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
396             evt.fire_event(
397                 {"complete": True, "schedule": schedule},
398                 tag="/salt/minion/minion_schedule_list_complete",
399             )
400     def save_schedule(self):
401         self.persist()
402         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
403             evt.fire_event({"complete": True}, tag="/salt/minion/minion_schedule_saved")
404     def postpone_job(self, name, data):
405         time = data["time"]
406         new_time = data["new_time"]
407         time_fmt = data.get("time_fmt", "%Y-%m-%dT%H:%M:%S")
408         if name in self.opts["schedule"]:
409             if "skip_explicit" not in self.opts["schedule"][name]:
410                 self.opts["schedule"][name]["skip_explicit"] = []
411             self.opts["schedule"][name]["skip_explicit"].append(
412                 {"time": time, "time_fmt": time_fmt}
413             )
414             if "run_explicit" not in self.opts["schedule"][name]:
415                 self.opts["schedule"][name]["run_explicit"] = []
416             self.opts["schedule"][name]["run_explicit"].append(
417                 {"time": new_time, "time_fmt": time_fmt}
418             )
419         elif name in self._get_schedule(include_opts=False):
420             log.warning("Cannot modify job %s, it's in the pillar!", name)
421         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
422             evt.fire_event(
423                 {"complete": True, "schedule": self._get_schedule()},
424                 tag="/salt/minion/minion_schedule_postpone_job_complete",
425             )
426     def skip_job(self, name, data):
427         time = data["time"]
428         time_fmt = data.get("time_fmt", "%Y-%m-%dT%H:%M:%S")
429         if name in self.opts["schedule"]:
430             if "skip_explicit" not in self.opts["schedule"][name]:
431                 self.opts["schedule"][name]["skip_explicit"] = []
432             self.opts["schedule"][name]["skip_explicit"].append(
433                 {"time": time, "time_fmt": time_fmt}
434             )
435         elif name in self._get_schedule(include_opts=False):
436             log.warning("Cannot modify job %s, it's in the pillar!", name)
437         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
438             evt.fire_event(
439                 {"complete": True, "schedule": self._get_schedule()},
440                 tag="/salt/minion/minion_schedule_skip_job_complete",
441             )
442     def get_next_fire_time(self, name, fmt="%Y-%m-%dT%H:%M:%S"):
443         schedule = self._get_schedule()
444         _next_fire_time = None
445         if schedule:
446             _next_fire_time = schedule.get(name, {}).get("_next_fire_time", None)
447             if _next_fire_time:
448                 _next_fire_time = _next_fire_time.strftime(fmt)
449         with salt.utils.event.get_event("minion", opts=self.opts, listen=False) as evt:
450             evt.fire_event(
451                 {"complete": True, "next_fire_time": _next_fire_time},
452                 tag="/salt/minion/minion_schedule_next_fire_time_complete",
453             )
454     def job_status(self, name, fire_event=False):
455         if fire_event:
456             schedule = self._get_schedule()
457             data = schedule.get(name, {})
458             with salt.utils.event.get_event(
459                 "minion", opts=self.opts, listen=False
460             ) as evt:
461                 evt.fire_event(
462                     {"complete": True, "data": data},
463                     tag="/salt/minion/minion_schedule_job_status_complete",
464                 )
465         else:
466             schedule = self._get_schedule()
467             return schedule.get(name, {})
468     def handle_func(self, multiprocessing_enabled, func, data, jid=None):
469         if salt.utils.platform.is_windows() or self.opts.get("transport") == "zeromq":
470             self.utils = salt.loader.utils(self.opts)
471             if self.opts["__role"] == "master":
472                 self.functions = salt.loader.runner(self.opts, utils=self.utils)
473             else:
474                 self.functions = salt.loader.minion_mods(
475                     self.opts, proxy=self.proxy, utils=self.utils
476                 )
477             self.returners = salt.loader.returners(
478                 self.opts, self.functions, proxy=self.proxy
479             )
480         if jid is None:
481             jid = salt.utils.jid.gen_jid(self.opts)
482         ret = {
483             "id": self.opts.get("id", "master"),
484             "fun": func,
485             "fun_args": [],
486             "schedule": data["name"],
487             "jid": jid,
488         }
489         if "metadata" in data:
490             if isinstance(data["metadata"], dict):
491                 ret["metadata"] = data["metadata"]
492                 ret["metadata"]["_TOS"] = self.time_offset
493                 ret["metadata"]["_TS"] = time.ctime()
494                 ret["metadata"]["_TT"] = time.strftime(
495                     "%Y %B %d %a %H %m", time.gmtime()
496                 )
497             else:
498                 log.warning(
499                     "schedule: The metadata parameter must be "
500                     "specified as a dictionary.  Ignoring."
501                 )
502         data_returner = data.get("returner", None)
503         if not self.standalone:
504             proc_fn = os.path.join(
505                 salt.minion.get_proc_dir(self.opts["cachedir"]), ret["jid"]
506             )
507         try:
508             minion_blackout_violation = False
509             if self.opts.get("pillar", {}).get("minion_blackout", False):
510                 whitelist = self.opts.get("pillar", {}).get(
511                     "minion_blackout_whitelist", []
512                 )
513                 if func != "saltutil.refresh_pillar" and func not in whitelist:
514                     minion_blackout_violation = True
515             elif self.opts.get("grains", {}).get("minion_blackout", False):
516                 whitelist = self.opts.get("grains", {}).get(
517                     "minion_blackout_whitelist", []
518                 )
519                 if func != "saltutil.refresh_pillar" and func not in whitelist:
520                     minion_blackout_violation = True
521             if minion_blackout_violation:
522                 raise SaltInvocationError(
523                     "Minion in blackout mode. Set 'minion_blackout' "
524                     "to False in pillar or grains to resume operations. Only "
525                     "saltutil.refresh_pillar allowed in blackout mode."
526                 )
527             ret["pid"] = os.getpid()
528             args = tuple()
529             if "args" in data:
530                 args = copy.deepcopy(data["args"])
531                 ret["fun_args"].extend(data["args"])
532             kwargs = {}
533             if "kwargs" in data:
534                 kwargs = copy.deepcopy(data["kwargs"])
535                 ret["fun_args"].append(copy.deepcopy(kwargs))
536             if func not in self.functions:
537                 ret["return"] = self.functions.missing_fun_string(func)
538                 salt.utils.error.raise_error(
539                     message=self.functions.missing_fun_string(func)
540                 )
541             if not self.standalone:
542                 if "jid_include" not in data or data["jid_include"]:
543                     log.debug(
544                         "schedule.handle_func: adding this job to the "
545                         "jobcache with data %s",
546                         ret,
547                     )
548                     with salt.utils.files.fopen(proc_fn, "w+b") as fp_:
549                         fp_.write(salt.payload.dumps(ret))
550             argspec = salt.utils.args.get_function_argspec(self.functions[func])
551             if argspec.keywords:
552                 for key, val in ret.items():
553                     if key != "kwargs":
554                         kwargs["__pub_{}".format(key)] = copy.deepcopy(val)
555             if self.opts["__role"] == "master":
556                 jid = salt.utils.jid.gen_jid(self.opts)
557                 tag = salt.utils.event.tagify(jid, prefix="salt/scheduler/")
558                 namespaced_event = salt.utils.event.NamespacedEvent(
559                     salt.utils.event.get_event(
560                         self.opts["__role"],
561                         self.opts["sock_dir"],
562                         opts=self.opts,
563                         listen=False,
564                     ),
565                     tag,
566                     print_func=None,
567                 )
568                 func_globals = {
569                     "__jid__": jid,
570                     "__user__": salt.utils.user.get_user(),
571                     "__tag__": tag,
572                     "__jid_event__": weakref.proxy(namespaced_event),
573                 }
574                 self_functions = copy.copy(self.functions)
575                 salt.utils.lazy.verify_fun(self_functions, func)
576                 completed_funcs = []
577                 for mod_name in self_functions.keys():
578                     if "." not in mod_name:
579                         continue
580                     mod, _ = mod_name.split(".", 1)
581                     if mod in completed_funcs:
582                         continue
583                     completed_funcs.append(mod)
584                     for global_key, value in func_globals.items():
585                         self.functions[mod_name].__globals__[global_key] = value
586             self.functions.pack["__context__"]["retcode"] = 0
587             ret["return"] = self.functions[func](*args, **kwargs)
588             if not self.standalone:
589                 if "retcode" in self.functions.pack["__context__"]:
590                     ret["retcode"] = self.functions.pack["__context__"]["retcode"]
591                 ret["success"] = True
592                 if data_returner or self.schedule_returner:
593                     if "return_config" in data:
594                         ret["ret_config"] = data["return_config"]
595                     if "return_kwargs" in data:
596                         ret["ret_kwargs"] = data["return_kwargs"]
597                     rets = []
598                     for returner in [data_returner, self.schedule_returner]:
599                         if isinstance(returner, str):
600                             rets.append(returner)
601                         elif isinstance(returner, list):
602                             rets.extend(returner)
603                     for returner in OrderedDict.fromkeys(rets):
604                         ret_str = "{}.returner".format(returner)
605                         if ret_str in self.returners:
606                             self.returners[ret_str](ret)
607                         else:
608                             log.info(
609                                 "Job %s using invalid returner: %s. Ignoring.",
610                                 func,
611                                 returner,
612                             )
613         except Exception:  # pylint: disable=broad-except
614             log.exception("Unhandled exception running %s", ret["fun"])
615             if "return" not in ret:
616                 ret["return"] = "Unhandled exception running {}".format(ret["fun"])
617             ret["success"] = False
618             ret["retcode"] = 254
619         finally:
620             if "__role" in self.opts and self.opts["__role"] in ("master", "minion"):
621                 if "return_job" in data and not data["return_job"]:
622                     pass
623                 else:
624                     mret = ret.copy()
625                     if not data_returner and not self.schedule_returner:
626                         mret["jid"] = "req"
627                         if data.get("return_job") == "nocache":
628                             mret["jid"] = "nocache"
629                     load = {"cmd": "_return", "id": self.opts["id"]}
630                     for key, value in mret.items():
631 <a name="0"></a>                        load[key] = value
632                     if "__role" in self.opts and self.opts["__role"] == "minion":
633                         event = salt.utils.event.get_event<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
634                             "minion", opts=self.opts, listen=False
635                         )
636                     elif "__role" in self.opts and self.opts["__role"] == "master":
637                         event = salt.utils.event.get_master_event(
638                             self.</b></font>opts, self.opts["sock_dir"]
639                         )
640                     try:
641                         event.fire_event(load, "__schedule_return")
642                     except Exception as exc:  # pylint: disable=broad-except
643                         log.exception(
644                             "Unhandled exception firing __schedule_return event"
645                         )
646                     finally:
647                         event.destroy()
648             if self.opts["__role"] == "master":
649                 namespaced_event.destroy()
650             if not self.standalone:
651                 log.debug("schedule.handle_func: Removing %s", proc_fn)
652                 try:
653                     os.unlink(proc_fn)
654                 except OSError as exc:
655                     if exc.errno == errno.EEXIST or exc.errno == errno.ENOENT:
656                         pass
657                     else:
658                         log.error("Failed to delete '%s': %s", proc_fn, exc.errno)
659                         raise
660                 finally:
661                     if multiprocessing_enabled:
662                         sys.exit(salt.defaults.exitcodes.EX_GENERIC)
663     def eval(self, now=None):
664         log.trace("==== evaluating schedule now %s =====", now)
665         jids = []
666         loop_interval = self.opts["loop_interval"]
667         if not isinstance(loop_interval, datetime.timedelta):
668             loop_interval = datetime.timedelta(seconds=loop_interval)
669         def _splay(splaytime):
670             splay_ = None
671             if isinstance(splaytime, dict):
672                 if splaytime["end"] &gt;= splaytime["start"]:
673                     splay_ = random.randint(splaytime["start"], splaytime["end"])
674                 else:
675                     log.error(
676                         "schedule.handle_func: Invalid Splay, "
677                         "end must be larger than start. Ignoring splay."
678                     )
679             else:
680                 splay_ = random.randint(1, splaytime)
681             return splay_
682         def _handle_time_elements(data):
683             if "_seconds" not in data:
684                 interval = int(data.get("seconds", 0))
685                 interval += int(data.get("minutes", 0)) * 60
686                 interval += int(data.get("hours", 0)) * 3600
687                 interval += int(data.get("days", 0)) * 86400
688                 data["_seconds"] = interval
689                 if not data["_next_fire_time"]:
690                     data["_next_fire_time"] = now + datetime.timedelta(
691                         seconds=data["_seconds"]
692                     )
693                 if interval &lt; self.loop_interval:
694                     self.loop_interval = interval
695                 data["_next_scheduled_fire_time"] = now + datetime.timedelta(
696                     seconds=data["_seconds"]
697                 )
698         def _handle_once(data, loop_interval):
699             if data["_next_fire_time"]:
700                 if (
701                     data["_next_fire_time"] &lt; now - loop_interval
702                     or data["_next_fire_time"] &gt; now
703                     and not data["_splay"]
704                 ):
705                     data["_continue"] = True
706             if not data["_next_fire_time"] and not data["_splay"]:
707                 once = data["once"]
708                 if not isinstance(once, datetime.datetime):
709                     once_fmt = data.get("once_fmt", "%Y-%m-%dT%H:%M:%S")
710                     try:
711                         once = datetime.datetime.strptime(data["once"], once_fmt)
712                     except (TypeError, ValueError):
713                         data["_error"] = (
714                             "Date string could not "
715                             "be parsed: {}, {}. "
716                             "Ignoring job {}.".format(
717                                 data["once"], once_fmt, data["name"]
718                             )
719                         )
720                         log.error(data["_error"])
721                         return
722                 data["_next_fire_time"] = once
723                 data["_next_scheduled_fire_time"] = once
724                 if once &lt; now - loop_interval:
725                     data["_continue"] = True
726         def _handle_when(data, loop_interval):
727             if not _WHEN_SUPPORTED:
728                 data["_error"] = "Missing python-dateutil. Ignoring job {}.".format(
729                     data["name"]
730                 )
731                 log.error(data["_error"])
732                 return
733             if not isinstance(data["when"], list):
734                 _when_data = [data["when"]]
735             else:
736                 _when_data = data["when"]
737             _when = []
738             for i in _when_data:
739                 if (
740                     "pillar" in self.opts
741                     and "whens" in self.opts["pillar"]
742                     and i in self.opts["pillar"]["whens"]
743                 ):
744                     if not isinstance(self.opts["pillar"]["whens"], dict):
745                         data["_error"] = (
746                             'Pillar item "whens" '
747                             "must be a dict. "
748                             "Ignoring job {}.".format(data["name"])
749                         )
750                         log.error(data["_error"])
751                         return
752                     when_ = self.opts["pillar"]["whens"][i]
753                 elif (
754                     "whens" in self.opts["grains"] and i in self.opts["grains"]["whens"]
755                 ):
756                     if not isinstance(self.opts["grains"]["whens"], dict):
757                         data[
758                             "_error"
759                         ] = 'Grain "whens" must be a dict. Ignoring job {}.'.format(
760                             data["name"]
761                         )
762                         log.error(data["_error"])
763                         return
764                     when_ = self.opts["grains"]["whens"][i]
765                 else:
766                     when_ = i
767                 if not isinstance(when_, datetime.datetime):
768                     try:
769                         when_ = dateutil_parser.parse(when_)
770                     except ValueError:
771                         data[
772                             "_error"
773                         ] = "Invalid date string {}. Ignoring job {}.".format(
774                             i, data["name"]
775                         )
776                         log.error(data["_error"])
777                         return
778                 _when.append(when_)
779             if data["_splay"]:
780                 _when.append(data["_splay"])
781             _when.sort()
782             for i in copy.deepcopy(_when):
783                 if len(_when) &gt; 1:
784                     if i &lt; now - loop_interval:
785                         _when.remove(i)
786             if _when:
787                 when = _when[0]
788                 if (
789                     when &lt; now - loop_interval
790                     and not data.get("_run", False)
791                     and not run
792                     and not data["_splay"]
793                 ):
794                     data["_next_fire_time"] = None
795                     data["_continue"] = True
796                     return
797                 if "_run" not in data:
798                     data["_run"] = bool(when &gt;= now - loop_interval)
799                 if not data["_next_fire_time"]:
800                     data["_next_fire_time"] = when
801                 data["_next_scheduled_fire_time"] = when
802                 if data["_next_fire_time"] &lt; when and not run and not data["_run"]:
803                     data["_next_fire_time"] = when
804                     data["_run"] = True
805             elif not data.get("_run", False):
806                 data["_next_fire_time"] = None
807                 data["_continue"] = True
808         def _handle_cron(data, loop_interval):
809             if not _CRON_SUPPORTED:
810                 data["_error"] = "Missing python-croniter. Ignoring job {}.".format(
811                     data["name"]
812                 )
813                 log.error(data["_error"])
814                 return
815             if data["_next_fire_time"] is None:
816                 try:
817                     data["_next_fire_time"] = croniter.croniter(
818                         data["cron"], now
819                     ).get_next(datetime.datetime)
820                     data["_next_scheduled_fire_time"] = croniter.croniter(
821                         data["cron"], now
822                     ).get_next(datetime.datetime)
823                 except (ValueError, KeyError):
824                     data["_error"] = "Invalid cron string. Ignoring job {}.".format(
825                         data["name"]
826                     )
827                     log.error(data["_error"])
828                     return
829                 interval = (now - data["_next_fire_time"]).total_seconds()
830                 if interval &gt;= 60 and interval &lt; self.loop_interval:
831                     self.loop_interval = interval
832         def _handle_run_explicit(data, loop_interval):
833             _run_explicit = []
834             for _run_time in data["run_explicit"]:
835                 if isinstance(_run_time, datetime.datetime):
836                     _run_explicit.append(_run_time)
837                 else:
838                     _run_explicit.append(
839                         datetime.datetime.strptime(
840                             _run_time["time"], _run_time["time_fmt"]
841                         )
842                     )
843             data["run"] = False
844             for i in copy.deepcopy(_run_explicit):
845                 if len(_run_explicit) &gt; 1:
846                     if i &lt; now - loop_interval:
847                         _run_explicit.remove(i)
848             if _run_explicit:
849                 if _run_explicit[0] &lt;= now &lt; _run_explicit[0] + loop_interval:
850                     data["run"] = True
851                     data["_next_fire_time"] = _run_explicit[0]
852         def _handle_skip_explicit(data, loop_interval):
853             data["run"] = False
854             _skip_explicit = []
855             for _skip_time in data["skip_explicit"]:
856                 if isinstance(_skip_time, datetime.datetime):
857                     _skip_explicit.append(_skip_time)
858                 else:
859                     _skip_explicit.append(
860                         datetime.datetime.strptime(
861                             _skip_time["time"], _skip_time["time_fmt"]
862                         )
863                     )
864             for i in copy.deepcopy(_skip_explicit):
865                 if i &lt; now - loop_interval:
866                     _skip_explicit.remove(i)
867             if _skip_explicit:
868                 if _skip_explicit[0] &lt;= now &lt;= (_skip_explicit[0] + loop_interval):
869                     if self.skip_function:
870                         data["run"] = True
871                         data["func"] = self.skip_function
872                     else:
873                         data["_skip_reason"] = "skip_explicit"
874                         data["_skipped_time"] = now
875                         data["_skipped"] = True
876                         data["run"] = False
877             else:
878                 data["run"] = True
879         def _handle_skip_during_range(data, loop_interval):
880             if not _RANGE_SUPPORTED:
881                 data["_error"] = "Missing python-dateutil. Ignoring job {}.".format(
882                     data["name"]
883                 )
884                 log.error(data["_error"])
885                 return
886             if not isinstance(data["skip_during_range"], dict):
887                 data["_error"] = (
888                     "schedule.handle_func: Invalid, range "
889                     "must be specified as a dictionary. "
890                     "Ignoring job {}.".format(data["name"])
891                 )
892                 log.error(data["_error"])
893                 return
894             start = data["skip_during_range"]["start"]
895             end = data["skip_during_range"]["end"]
896             if not isinstance(start, datetime.datetime):
897                 try:
898                     start = dateutil_parser.parse(start)
899                 except ValueError:
900                     data["_error"] = (
901                         "Invalid date string for start in "
902                         "skip_during_range. Ignoring "
903                         "job {}.".format(data["name"])
904                     )
905                     log.error(data["_error"])
906                     return
907             if not isinstance(end, datetime.datetime):
908                 try:
909                     end = dateutil_parser.parse(end)
910                 except ValueError:
911                     data["_error"] = (
912                         "Invalid date string for end in "
913                         "skip_during_range. Ignoring "
914                         "job {}.".format(data["name"])
915                     )
916                     log.error(data["_error"])
917                     return
918             if "run_after_skip_range" in data and data["run_after_skip_range"]:
919                 if "run_explicit" not in data:
920                     data["run_explicit"] = []
921                 _run_immediate = (end + loop_interval).strftime("%Y-%m-%dT%H:%M:%S")
922                 if _run_immediate not in data["run_explicit"]:
923                     data["run_explicit"].append(
924                         {"time": _run_immediate, "time_fmt": "%Y-%m-%dT%H:%M:%S"}
925                     )
926             if end &gt; start:
927                 if start &lt;= now &lt;= end:
928                     if self.skip_function:
929                         data["run"] = True
930                         data["func"] = self.skip_function
931                     else:
932                         data["_skip_reason"] = "in_skip_range"
933                         data["_skipped_time"] = now
934                         data["_skipped"] = True
935                         data["run"] = False
936                 else:
937                     data["run"] = True
938             else:
939                 data["_error"] = (
940                     "schedule.handle_func: Invalid "
941                     "range, end must be larger than "
942                     "start. Ignoring job {}.".format(data["name"])
943                 )
944                 log.error(data["_error"])
945         def _handle_range(data):
946             if not _RANGE_SUPPORTED:
947                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
948                     data["name"]
949                 )
950                 log.error(data["_error"])
951                 return
952             if not isinstance(data["range"], dict):
953                 data["_error"] = (
954                     "schedule.handle_func: Invalid, range "
955                     "must be specified as a dictionary."
956                     "Ignoring job {}.".format(data["name"])
957                 )
958                 log.error(data["_error"])
959                 return
960             start = data["range"]["start"]
961             end = data["range"]["end"]
962             if not isinstance(start, datetime.datetime):
963                 try:
964                     start = dateutil_parser.parse(start)
965                 except ValueError:
966                     data[
967                         "_error"
968                     ] = "Invalid date string for start. Ignoring job {}.".format(
969                         data["name"]
970                     )
971                     log.error(data["_error"])
972                     return
973             if not isinstance(end, datetime.datetime):
974                 try:
975                     end = dateutil_parser.parse(end)
976                 except ValueError:
977                     data[
978                         "_error"
979                     ] = "Invalid date string for end. Ignoring job {}.".format(
980                         data["name"]
981                     )
982                     log.error(data["_error"])
983                     return
984             if end &gt; start:
985                 if "invert" in data["range"] and data["range"]["invert"]:
986                     if now &lt;= start or now &gt;= end:
987                         data["run"] = True
988                     else:
989                         data["_skip_reason"] = "in_skip_range"
990                         data["run"] = False
991                 else:
992                     if start &lt;= now &lt;= end:
993                         data["run"] = True
994                     else:
995                         if self.skip_function:
996                             data["run"] = True
997                             data["func"] = self.skip_function
998                         else:
999                             data["_skip_reason"] = "not_in_range"
1000                             data["run"] = False
1001             else:
1002                 data["_error"] = (
1003                     "schedule.handle_func: Invalid "
1004                     "range, end must be larger "
1005                     "than start. Ignoring job {}.".format(data["name"])
1006                 )
1007                 log.error(data["_error"])
1008         def _handle_after(data):
1009             if not _WHEN_SUPPORTED:
1010                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
1011                     data["name"]
1012                 )
1013                 log.error(data["_error"])
1014                 return
1015             after = data["after"]
1016             if not isinstance(after, datetime.datetime):
1017                 after = dateutil_parser.parse(after)
1018             if after &gt;= now:
1019                 log.debug("After time has not passed skipping job: %s.", data["name"])
1020                 data["_skip_reason"] = "after_not_passed"
1021                 data["_skipped_time"] = now
1022                 data["_skipped"] = True
1023                 data["run"] = False
1024             else:
1025                 data["run"] = True
1026         def _handle_until(data):
1027             if not _WHEN_SUPPORTED:
1028                 data["_error"] = "Missing python-dateutil. Ignoring job {}".format(
1029                     data["name"]
1030                 )
1031                 log.error(data["_error"])
1032                 return
1033             until = data["until"]
1034             if not isinstance(until, datetime.datetime):
1035                 until = dateutil_parser.parse(until)
1036             if until &lt;= now:
1037                 log.debug("Until time has passed skipping job: %s.", data["name"])
1038                 data["_skip_reason"] = "until_passed"
1039                 data["_skipped_time"] = now
1040                 data["_skipped"] = True
1041                 data["run"] = False
1042             else:
1043                 data["run"] = True
1044         def _chop_ms(dt):
1045             return dt - datetime.timedelta(microseconds=dt.microsecond)
1046         schedule = self._get_schedule()
1047         if not isinstance(schedule, dict):
1048             raise ValueError("Schedule must be of type dict.")
1049         if "skip_function" in schedule:
1050             self.skip_function = schedule["skip_function"]
1051         if "skip_during_range" in schedule:
1052             self.skip_during_range = schedule["skip_during_range"]
1053         if "enabled" in schedule:
1054             self.enabled = schedule["enabled"]
1055         if "splay" in schedule:
1056             self.splay = schedule["splay"]
1057         _hidden = ["enabled", "skip_function", "skip_during_range", "splay"]
1058         for job, data in schedule.items():
1059             if job in _hidden:
1060                 continue
1061             for item in [
1062                 "_continue",
1063                 "_error",
1064                 "_enabled",
1065                 "_skipped",
1066                 "_skip_reason",
1067                 "_skipped_time",
1068             ]:
1069                 if item in data:
1070                     del data[item]
1071             run = False
1072             if "name" in data:
1073                 job_name = data["name"]
1074             else:
1075                 job_name = data["name"] = job
1076             if not isinstance(data, dict):
1077                 log.error(
1078                     'Scheduled job "%s" should have a dict value, not %s',
1079                     job_name,
1080                     type(data),
1081                 )
1082                 continue
1083             if "function" in data:
1084                 func = data["function"]
1085             elif "func" in data:
1086                 func = data["func"]
1087             elif "fun" in data:
1088                 func = data["fun"]
1089             else:
1090                 func = None
1091             if func not in self.functions:
1092                 log.info("Invalid function: %s in scheduled job %s.", func, job_name)
1093             if "_next_fire_time" not in data:
1094                 data["_next_fire_time"] = None
1095             if "_splay" not in data:
1096                 data["_splay"] = None
1097             if (
1098                 "run_on_start" in data
1099                 and data["run_on_start"]
1100                 and "_run_on_start" not in data
1101             ):
1102                 data["_run_on_start"] = True
1103             if not now:
1104                 now = datetime.datetime.now()
1105             schedule_keys = set(data.keys())
1106             time_elements = ("seconds", "minutes", "hours", "days")
1107             scheduling_elements = ("when", "cron", "once")
1108             invalid_sched_combos = [
1109                 set(i) for i in itertools.combinations(scheduling_elements, 2)
1110             ]
1111             if any(i &lt;= schedule_keys for i in invalid_sched_combos):
1112                 log.error(
1113                     'Unable to use "%s" options together. Ignoring.',
1114                     '", "'.join(scheduling_elements),
1115                 )
1116                 continue
1117             invalid_time_combos = []
1118             for item in scheduling_elements:
1119                 all_items = itertools.chain([item], time_elements)
1120                 invalid_time_combos.append(set(itertools.combinations(all_items, 2)))
1121             if any(set(x) &lt;= schedule_keys for x in invalid_time_combos):
1122                 log.error(
1123                     'Unable to use "%s" with "%s" options. Ignoring',
1124                     '", "'.join(time_elements),
1125                     '", "'.join(scheduling_elements),
1126                 )
1127                 continue
1128             if "run_explicit" in data:
1129                 _handle_run_explicit(data, loop_interval)
1130                 run = data["run"]
1131             if True in [True for item in time_elements if item in data]:
1132                 _handle_time_elements(data)
1133             elif "once" in data:
1134                 _handle_once(data, loop_interval)
1135             elif "when" in data:
1136                 _handle_when(data, loop_interval)
1137             elif "cron" in data:
1138                 _handle_cron(data, loop_interval)
1139             else:
1140                 continue
1141             if "_continue" in data and data["_continue"]:
1142                 continue
1143             if "_error" in data and data["_error"]:
1144                 continue
1145             seconds = int(
1146                 (_chop_ms(data["_next_fire_time"]) - _chop_ms(now)).total_seconds()
1147             )
1148             if "splay" not in data:
1149                 data["splay"] = self.splay
1150             if "splay" in data and data["splay"]:
1151                 if not data["_splay"]:
1152                     splay = _splay(data["splay"])
1153                     if now &lt; data["_next_fire_time"] + datetime.timedelta(
1154                         seconds=splay
1155                     ):
1156                         log.debug(
1157                             "schedule.handle_func: Adding splay of "
1158                             "%s seconds to next run.",
1159                             splay,
1160                         )
1161                         data["_splay"] = data["_next_fire_time"] + datetime.timedelta(
1162                             seconds=splay
1163                         )
1164                         if "when" in data:
1165                             data["_run"] = True
1166                     else:
1167                         run = True
1168                 if data["_splay"]:
1169                     seconds = (data["_splay"] - now).total_seconds()
1170                     if "when" in data:
1171                         data["_next_fire_time"] = data["_splay"]
1172             if "_seconds" in data:
1173                 if seconds &lt;= 0:
1174                     run = True
1175             elif "when" in data and data["_run"]:
1176                 if (
1177                     data["_next_fire_time"]
1178                     &lt;= now
1179                     &lt;= (data["_next_fire_time"] + loop_interval)
1180                 ):
1181                     data["_run"] = False
1182                     run = True
1183             elif "cron" in data:
1184                 if seconds &lt;= 0:
1185                     data["_next_fire_time"] = None
1186                     run = True
1187             elif "once" in data:
1188                 if (
1189                     data["_next_fire_time"]
1190                     &lt;= now
1191                     &lt;= (data["_next_fire_time"] + loop_interval)
1192                 ):
1193                     run = True
1194             elif seconds == 0:
1195                 run = True
1196             if "_run_on_start" in data and data["_run_on_start"]:
1197                 run = True
1198                 data["_run_on_start"] = False
1199             elif run:
1200                 if "range" in data:
1201                     _handle_range(data)
1202                     if "_error" in data and data["_error"]:
1203                         continue
1204                     run = data["run"]
1205                     if "func" in data:
1206                         func = data["func"]
1207                 if "skip_during_range" not in data and self.skip_during_range:
1208                     data["skip_during_range"] = self.skip_during_range
1209                 if "skip_during_range" in data and data["skip_during_range"]:
1210                     _handle_skip_during_range(data, loop_interval)
1211                     if "_error" in data and data["_error"]:
1212                         continue
1213                     run = data["run"]
1214                     if "func" in data:
1215                         func = data["func"]
1216                 if "skip_explicit" in data:
1217                     _handle_skip_explicit(data, loop_interval)
1218                     if "_error" in data and data["_error"]:
1219                         continue
1220                     run = data["run"]
1221                     if "func" in data:
1222                         func = data["func"]
1223                 if "until" in data:
1224                     _handle_until(data)
1225                     if "_error" in data and data["_error"]:
1226                         continue
1227                     run = data["run"]
1228                 if "after" in data:
1229                     _handle_after(data)
1230                     if "_error" in data and data["_error"]:
1231                         continue
1232                     run = data["run"]
1233             if "_continue" in data and data["_continue"]:
1234                 run = False
1235             if not self.enabled or not data.get("enabled", True):
1236                 log.trace("Job: %s is disabled", job_name)
1237                 data["_skip_reason"] = "disabled"
1238                 data["_skipped_time"] = now
1239                 data["_skipped"] = True
1240                 run = False
1241             miss_msg = ""
1242             if seconds &lt; 0:
1243                 miss_msg = " (runtime missed by {} seconds)".format(abs(seconds))
1244             try:
1245                 if run:
1246                     if "jid_include" not in data or data["jid_include"]:
1247                         data["jid_include"] = True
1248                         log.debug(
1249                             "schedule: Job %s was scheduled with jid_include, "
1250                             "adding to cache (jid_include defaults to True)",
1251                             job_name,
1252                         )
1253                         if "maxrunning" in data:
1254                             log.debug(
1255                                 "schedule: Job %s was scheduled with a max "
1256                                 "number of %s",
1257                                 job_name,
1258                                 data["maxrunning"],
1259                             )
1260                         else:
1261                             log.info(
1262                                 "schedule: maxrunning parameter was not specified for "
1263                                 "job %s, defaulting to 1.",
1264                                 job_name,
1265                             )
1266                             data["maxrunning"] = 1
1267                     if not self.standalone:
1268                         data["run"] = run
1269                         data = self._check_max_running(func, data, self.opts, now)
1270                         run = data["run"]
1271                 if run:
1272                     jid = salt.utils.jid.gen_jid(self.opts)
1273                     jids.append(jid)
1274                     log.info(
1275                         "Running scheduled job: %s%s with jid %s",
1276                         job_name,
1277                         miss_msg,
1278                         jid,
1279                     )
1280                     self._run_job(func, data, jid=jid)
1281             finally:
1282                 if run:
1283                     data["_last_run"] = now
1284                     data["_splay"] = None
1285                 if "_seconds" in data:
1286                     if self.standalone:
1287                         data["_next_fire_time"] = now + datetime.timedelta(
1288                             seconds=data["_seconds"]
1289                         )
1290                     elif "_skipped" in data and data["_skipped"]:
1291                         data["_next_fire_time"] = now + datetime.timedelta(
1292                             seconds=data["_seconds"]
1293                         )
1294                     elif run:
1295                         data["_next_fire_time"] = now + datetime.timedelta(
1296                             seconds=data["_seconds"]
1297                         )
1298         return jids
1299     def _run_job(self, func, data, jid=None):
1300         job_dry_run = data.get("dry_run", False)
1301         if job_dry_run:
1302             log.debug("Job %s has 'dry_run' set to True. Not running it.", data["name"])
1303             return
1304         multiprocessing_enabled = self.opts.get("multiprocessing", True)
1305         run_schedule_jobs_in_background = self.opts.get(
1306             "run_schedule_jobs_in_background", True
1307         )
1308         if run_schedule_jobs_in_background is False:
1309             self.handle_func(False, func, data, jid)
1310             return
1311         if multiprocessing_enabled and salt.utils.platform.is_windows():
1312             functions = self.functions
1313             self.functions = {}
1314             returners = self.returners
1315             self.returners = {}
1316             utils = self.utils
1317             self.utils = {}
1318         try:
1319             if multiprocessing_enabled:
1320                 thread_cls = salt.utils.process.SignalHandlingProcess
1321             else:
1322                 thread_cls = threading.Thread
1323             name = "Schedule(name={}, jid={})".format(data["name"], jid)
1324             if multiprocessing_enabled:
1325                 with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
1326                     proc = thread_cls(
1327                         target=self.handle_func,
1328                         args=(multiprocessing_enabled, func, data, jid),
1329                         name=name,
1330                     )
1331                     proc.start()
1332                     self._subprocess_list.add(proc)
1333             else:
1334                 proc = thread_cls(
1335                     target=self.handle_func,
1336                     args=(multiprocessing_enabled, func, data, jid),
1337                     name=name,
1338                 )
1339                 proc.start()
1340                 self._subprocess_list.add(proc)
1341         finally:
1342             if multiprocessing_enabled and salt.utils.platform.is_windows():
1343                 self.functions = functions
1344                 self.returners = returners
1345                 self.utils = utils
1346     def cleanup_subprocesses(self):
1347         self._subprocess_list.cleanup()
1348 def clean_proc_dir(opts):
1349     for basefilename in os.listdir(salt.minion.get_proc_dir(opts["cachedir"])):
1350         fn_ = os.path.join(salt.minion.get_proc_dir(opts["cachedir"]), basefilename)
1351         with salt.utils.files.fopen(fn_, "rb") as fp_:
1352             job = None
1353             try:
1354                 job = salt.payload.load(fp_)
1355             except Exception:  # pylint: disable=broad-except
1356                 if salt.utils.platform.is_windows():
1357                     fp_.close()
1358                 try:
1359                     os.unlink(fn_)
1360                     continue
1361                 except OSError:
1362                     continue
1363             log.debug(
1364                 "schedule.clean_proc_dir: checking job %s for process existence", job
1365             )
1366             if job is not None and "pid" in job:
1367                 if salt.utils.process.os_is_running(job["pid"]):
1368                     log.debug(
1369                         "schedule.clean_proc_dir: Cleaning proc dir, pid %s "
1370                         "still exists.",
1371                         job["pid"],
1372                     )
1373                 else:
1374                     if salt.utils.platform.is_windows():
1375                         fp_.close()
1376                     try:
1377                         os.unlink(fn_)
1378                     except OSError:
1379                         pass
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
