<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_netbox.py & schedule.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_netbox.py & schedule.py
      </h3>
      <h1 align="center">
        0.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_netbox.py (1.4380531%)<TH>schedule.py (0.4571027%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match284716-0.html#0',2,'match284716-1.html#0',3)" NAME="0">(1906-1915)<TD><A HREF="javascript:ZweiFrames('match284716-0.html#0',2,'match284716-1.html#0',3)" NAME="0">(899-904)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_netbox.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Gary T. Giesen &lt;ggiesen@giesen.me&gt;
&quot;&quot;&quot;

import pytest
import salt.pillar.netbox as netbox
from tests.support.mock import patch


@pytest.fixture
def default_kwargs():
    return {
        &quot;minion_id&quot;: &quot;minion1&quot;,
        &quot;pillar&quot;: None,
        &quot;api_url&quot;: &quot;http://netbox.example.com&quot;,
        &quot;api_token&quot;: &quot;yeic5oocizei7owuichoesh8ooqu6oob3uWiey9a&quot;,
        &quot;api_query_result_limit&quot;: 65535,
    }


@pytest.fixture
def headers():
    return {&quot;Authorization&quot;: &quot;Token quin1Di5MoRooChaiph3Aenaxais5EeY1gie6eev&quot;}


@pytest.fixture
def device_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 1,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 511,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;display_name&quot;: &quot;minion1&quot;,
                    &quot;device_type&quot;: {
                        &quot;id&quot;: 4,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-types/4/&quot;,
                        &quot;manufacturer&quot;: {
                            &quot;id&quot;: 1,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/manufacturers/1/&quot;,
                            &quot;name&quot;: &quot;Cisco&quot;,
                            &quot;slug&quot;: &quot;cisco&quot;,
                        },
                        &quot;model&quot;: &quot;ISR2901&quot;,
                        &quot;slug&quot;: &quot;isr2901&quot;,
                        &quot;display_name&quot;: &quot;Cisco ISR2901&quot;,
                    },
                    &quot;device_role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;device&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;serial&quot;: &quot;&quot;,
                    &quot;asset_tag&quot;: None,
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;rack&quot;: None,
                    &quot;position&quot;: None,
                    &quot;face&quot;: None,
                    &quot;parent_device&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1146,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1146,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;cluster&quot;: None,
                    &quot;virtual_chassis&quot;: None,
                    &quot;vc_position&quot;: None,
                    &quot;vc_priority&quot;: None,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.171105Z&quot;,
                }
            ],
        }
    }


@pytest.fixture
def multiple_device_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 511,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;display_name&quot;: &quot;minion1&quot;,
                    &quot;device_type&quot;: {
                        &quot;id&quot;: 4,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-types/4/&quot;,
                        &quot;manufacturer&quot;: {
                            &quot;id&quot;: 1,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/manufacturers/1/&quot;,
                            &quot;name&quot;: &quot;Cisco&quot;,
                            &quot;slug&quot;: &quot;cisco&quot;,
                        },
                        &quot;model&quot;: &quot;ISR2901&quot;,
                        &quot;slug&quot;: &quot;isr2901&quot;,
                        &quot;display_name&quot;: &quot;Cisco ISR2901&quot;,
                    },
                    &quot;device_role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;device&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;serial&quot;: &quot;&quot;,
                    &quot;asset_tag&quot;: None,
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;rack&quot;: None,
                    &quot;position&quot;: None,
                    &quot;face&quot;: None,
                    &quot;parent_device&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1146,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1146,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;cluster&quot;: None,
                    &quot;virtual_chassis&quot;: None,
                    &quot;vc_position&quot;: None,
                    &quot;vc_priority&quot;: None,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.171105Z&quot;,
                },
                {
                    &quot;id&quot;: 512,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/512/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;display_name&quot;: &quot;minion1&quot;,
                    &quot;device_type&quot;: {
                        &quot;id&quot;: 4,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-types/4/&quot;,
                        &quot;manufacturer&quot;: {
                            &quot;id&quot;: 1,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/manufacturers/1/&quot;,
                            &quot;name&quot;: &quot;Cisco&quot;,
                            &quot;slug&quot;: &quot;cisco&quot;,
                        },
                        &quot;model&quot;: &quot;ISR2901&quot;,
                        &quot;slug&quot;: &quot;isr2901&quot;,
                        &quot;display_name&quot;: &quot;Cisco ISR2901&quot;,
                    },
                    &quot;device_role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;device&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;serial&quot;: &quot;&quot;,
                    &quot;asset_tag&quot;: None,
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;rack&quot;: None,
                    &quot;position&quot;: None,
                    &quot;face&quot;: None,
                    &quot;parent_device&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1150,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1150/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.3/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1150,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1150/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.3/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;cluster&quot;: None,
                    &quot;virtual_chassis&quot;: None,
                    &quot;vc_position&quot;: None,
                    &quot;vc_priority&quot;: None,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.171105Z&quot;,
                },
            ],
        }
    }


@pytest.fixture
def virtual_machine_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 1,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 222,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;cluster&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/clusters/1/&quot;,
                        &quot;name&quot;: &quot;Cluster&quot;,
                    },
                    &quot;role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;virtual-machine&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1148,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1148,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;vcpus&quot;: 1,
                    &quot;memory&quot;: 1024,
                    &quot;disk&quot;: 30,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:05.799541Z&quot;,
                }
            ],
        }
    }


@pytest.fixture
def multiple_virtual_machine_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 1,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 222,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;cluster&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/clusters/1/&quot;,
                        &quot;name&quot;: &quot;Cluster&quot;,
                    },
                    &quot;role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;virtual-machine&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1148,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1148,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;vcpus&quot;: 1,
                    &quot;memory&quot;: 1024,
                    &quot;disk&quot;: 30,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:05.799541Z&quot;,
                },
                {
                    &quot;id&quot;: 223,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/223/&quot;,
                    &quot;name&quot;: &quot;minion1&quot;,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;cluster&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/clusters/1/&quot;,
                        &quot;name&quot;: &quot;Cluster&quot;,
                    },
                    &quot;role&quot;: {
                        &quot;id&quot;: 45,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                        &quot;name&quot;: &quot;Network&quot;,
                        &quot;slug&quot;: &quot;network&quot;,
                    },
                    &quot;node_type&quot;: &quot;virtual-machine&quot;,
                    &quot;tenant&quot;: None,
                    &quot;platform&quot;: {
                        &quot;id&quot;: 1,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                        &quot;name&quot;: &quot;Cisco IOS&quot;,
                        &quot;slug&quot;: &quot;ios&quot;,
                    },
                    &quot;primary_ip&quot;: {
                        &quot;id&quot;: 1152,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1152/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.4/24&quot;,
                    },
                    &quot;primary_ip4&quot;: {
                        &quot;id&quot;: 1152,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1152/&quot;,
                        &quot;family&quot;: 4,
                        &quot;address&quot;: &quot;192.0.2.4/24&quot;,
                    },
                    &quot;primary_ip6&quot;: None,
                    &quot;vcpus&quot;: 1,
                    &quot;memory&quot;: 1024,
                    &quot;disk&quot;: 30,
                    &quot;comments&quot;: &quot;&quot;,
                    &quot;local_context_data&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;config_context&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:05.799541Z&quot;,
                },
            ],
        }
    }


@pytest.fixture
def no_results():
    return {&quot;dict&quot;: {&quot;count&quot;: 0, &quot;next&quot;: None, &quot;previous&quot;: None, &quot;results&quot;: []}}


@pytest.fixture
def http_error():
    return {&quot;error&quot;: &quot;HTTP 404: Not Found&quot;, &quot;status&quot;: 404}


@pytest.fixture
def device_interface_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 8158,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8158/&quot;,
                    &quot;device&quot;: {
                        &quot;id&quot;: 511,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                        &quot;name&quot;: &quot;minion1&quot;,
                        &quot;display_name&quot;: &quot;minion1&quot;,
                    },
                    &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
                    &quot;label&quot;: &quot;&quot;,
                    &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
                    &quot;enabled&quot;: True,
                    &quot;lag&quot;: None,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;mgmt_only&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;cable&quot;: None,
                    &quot;cable_peer&quot;: None,
                    &quot;cable_peer_type&quot;: None,
                    &quot;connected_endpoint&quot;: None,
                    &quot;connected_endpoint_type&quot;: None,
                    &quot;connected_endpoint_reachable&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;count_ipaddresses&quot;: 1,
                },
                {
                    &quot;id&quot;: 8159,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8159/&quot;,
                    &quot;device&quot;: {
                        &quot;id&quot;: 511,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                        &quot;name&quot;: &quot;minion1&quot;,
                        &quot;display_name&quot;: &quot;minion1&quot;,
                    },
                    &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
                    &quot;label&quot;: &quot;&quot;,
                    &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
                    &quot;enabled&quot;: True,
                    &quot;lag&quot;: None,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;mgmt_only&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;cable&quot;: None,
                    &quot;cable_peer&quot;: None,
                    &quot;cable_peer_type&quot;: None,
                    &quot;connected_endpoint&quot;: None,
                    &quot;connected_endpoint_type&quot;: None,
                    &quot;connected_endpoint_reachable&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;count_ipaddresses&quot;: 1,
                },
            ],
        }
    }


@pytest.fixture
def device_interfaces_list():
    return [
        {
            &quot;id&quot;: 8158,
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8158/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
            &quot;label&quot;: &quot;&quot;,
            &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
            &quot;enabled&quot;: True,
            &quot;lag&quot;: None,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;mgmt_only&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;cable&quot;: None,
            &quot;cable_peer&quot;: None,
            &quot;cable_peer_type&quot;: None,
            &quot;connected_endpoint&quot;: None,
            &quot;connected_endpoint_type&quot;: None,
            &quot;connected_endpoint_reachable&quot;: None,
            &quot;tags&quot;: [],
            &quot;count_ipaddresses&quot;: 1,
        },
        {
            &quot;id&quot;: 8159,
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8159/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
            &quot;label&quot;: &quot;&quot;,
            &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
            &quot;enabled&quot;: True,
            &quot;lag&quot;: None,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;mgmt_only&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;cable&quot;: None,
            &quot;cable_peer&quot;: None,
            &quot;cable_peer_type&quot;: None,
            &quot;connected_endpoint&quot;: None,
            &quot;connected_endpoint_type&quot;: None,
            &quot;connected_endpoint_reachable&quot;: None,
            &quot;tags&quot;: [],
            &quot;count_ipaddresses&quot;: 1,
        },
    ]


@pytest.fixture
def virtual_machine_interface_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 668,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/668/&quot;,
                    &quot;virtual_machine&quot;: {
                        &quot;id&quot;: 222,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                        &quot;name&quot;: &quot;minion1&quot;,
                    },
                    &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
                    &quot;enabled&quot;: True,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;tags&quot;: [],
                },
                {
                    &quot;id&quot;: 669,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/669/&quot;,
                    &quot;virtual_machine&quot;: {
                        &quot;id&quot;: 222,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                        &quot;name&quot;: &quot;minion1&quot;,
                    },
                    &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
                    &quot;enabled&quot;: True,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;tags&quot;: [],
                },
            ],
        }
    }


@pytest.fixture
def virtual_machine_interfaces_list():
    return [
        {
            &quot;id&quot;: 668,
            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/668/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
            &quot;enabled&quot;: True,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;tags&quot;: [],
        },
        {
            &quot;id&quot;: 669,
            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/669/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
            &quot;enabled&quot;: True,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;tags&quot;: [],
        },
    ]


@pytest.fixture
def device_ip_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 1146,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;assigned_object_type&quot;: &quot;dcim.interface&quot;,
                    &quot;assigned_object_id&quot;: 8158,
                    &quot;assigned_object&quot;: {
                        &quot;id&quot;: 8158,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8158/&quot;,
                        &quot;device&quot;: {
                            &quot;id&quot;: 511,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                            &quot;name&quot;: &quot;minion1&quot;,
                            &quot;display_name&quot;: &quot;minion1&quot;,
                        },
                        &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
                        &quot;cable&quot;: None,
                    },
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.153386Z&quot;,
                },
                {
                    &quot;id&quot;: 1147,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1147/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;198.51.100.1/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;assigned_object_type&quot;: &quot;dcim.interface&quot;,
                    &quot;assigned_object_id&quot;: 8159,
                    &quot;assigned_object&quot;: {
                        &quot;id&quot;: 8159,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8159/&quot;,
                        &quot;device&quot;: {
                            &quot;id&quot;: 511,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
                            &quot;name&quot;: &quot;minion1&quot;,
                            &quot;display_name&quot;: &quot;minion1&quot;,
                        },
                        &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
                        &quot;cable&quot;: None,
                    },
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:40.508154Z&quot;,
                },
            ],
        }
    }


@pytest.fixture
def virtual_machine_ip_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 1148,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;assigned_object_type&quot;: &quot;virtualization.vminterface&quot;,
                    &quot;assigned_object_id&quot;: 668,
                    &quot;assigned_object&quot;: {
                        &quot;id&quot;: 668,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/668/&quot;,
                        &quot;virtual_machine&quot;: {
                            &quot;id&quot;: 222,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                            &quot;name&quot;: &quot;minion1&quot;,
                        },
                        &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
                    },
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:05.784281Z&quot;,
                },
                {
                    &quot;id&quot;: 1149,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1149/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;198.51.100.2/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;assigned_object_type&quot;: &quot;virtualization.vminterface&quot;,
                    &quot;assigned_object_id&quot;: 669,
                    &quot;assigned_object&quot;: {
                        &quot;id&quot;: 669,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/669/&quot;,
                        &quot;virtual_machine&quot;: {
                            &quot;id&quot;: 222,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/virtual-machines/222/&quot;,
                            &quot;name&quot;: &quot;minion1&quot;,
                        },
                        &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
                    },
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:29.607428Z&quot;,
                },
            ],
        }
    }


@pytest.fixture
def device_interfaces_ip_list():
    return [
        {
            &quot;id&quot;: 8158,
            &quot;ip_addresses&quot;: [
                {
                    &quot;id&quot;: 1146,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.153386Z&quot;,
                },
            ],
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8158/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
            &quot;label&quot;: &quot;&quot;,
            &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
            &quot;enabled&quot;: True,
            &quot;lag&quot;: None,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;mgmt_only&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;cable&quot;: None,
            &quot;cable_peer&quot;: None,
            &quot;cable_peer_type&quot;: None,
            &quot;connected_endpoint&quot;: None,
            &quot;connected_endpoint_type&quot;: None,
            &quot;connected_endpoint_reachable&quot;: None,
            &quot;tags&quot;: [],
            &quot;count_ipaddresses&quot;: 1,
        },
        {
            &quot;id&quot;: 8159,
            &quot;ip_addresses&quot;: [
                {
                    &quot;id&quot;: 1147,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1147/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;198.51.100.1/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:12:40.508154Z&quot;,
                },
            ],
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8159/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
            &quot;label&quot;: &quot;&quot;,
            &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
            &quot;enabled&quot;: True,
            &quot;lag&quot;: None,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;mgmt_only&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;cable&quot;: None,
            &quot;cable_peer&quot;: None,
            &quot;cable_peer_type&quot;: None,
            &quot;connected_endpoint&quot;: None,
            &quot;connected_endpoint_type&quot;: None,
            &quot;connected_endpoint_reachable&quot;: None,
            &quot;tags&quot;: [],
            &quot;count_ipaddresses&quot;: 1,
        },
    ]


@pytest.fixture
def virtual_machine_interfaces_ip_list():
    return [
        {
            &quot;id&quot;: 668,
            &quot;ip_addresses&quot;: [
                {
                    &quot;id&quot;: 1148,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1148/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;192.0.2.2/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:05.784281Z&quot;,
                },
            ],
            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/668/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
            &quot;enabled&quot;: True,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;tags&quot;: [],
        },
        {
            &quot;id&quot;: 669,
            &quot;ip_addresses&quot;: [
                {
                    &quot;id&quot;: 1149,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1149/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;address&quot;: &quot;198.51.100.2/24&quot;,
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;nat_inside&quot;: None,
                    &quot;nat_outside&quot;: None,
                    &quot;dns_name&quot;: &quot;&quot;,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-19&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-19T06:23:29.607428Z&quot;,
                },
            ],
            &quot;url&quot;: &quot;https://netbox.example.com/api/virtualization/interfaces/669/&quot;,
            &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
            &quot;enabled&quot;: True,
            &quot;mtu&quot;: None,
            &quot;mac_address&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;mode&quot;: None,
            &quot;untagged_vlan&quot;: None,
            &quot;tagged_vlans&quot;: [],
            &quot;tags&quot;: [],
        },
    ]


@pytest.fixture
def site_results():
    return {
        &quot;dict&quot;: {
            &quot;id&quot;: 18,
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
            &quot;name&quot;: &quot;Site 1&quot;,
            &quot;slug&quot;: &quot;site1&quot;,
            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
            &quot;region&quot;: None,
            &quot;tenant&quot;: None,
            &quot;facility&quot;: &quot;&quot;,
            &quot;asn&quot;: None,
            &quot;time_zone&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;physical_address&quot;: &quot;&quot;,
            &quot;shipping_address&quot;: &quot;&quot;,
            &quot;latitude&quot;: None,
            &quot;longitude&quot;: None,
            &quot;contact_name&quot;: &quot;&quot;,
            &quot;contact_phone&quot;: &quot;&quot;,
            &quot;contact_email&quot;: &quot;&quot;,
            &quot;comments&quot;: &quot;&quot;,
            &quot;tags&quot;: [],
            &quot;custom_fields&quot;: {},
            &quot;created&quot;: &quot;2021-02-25&quot;,
            &quot;last_updated&quot;: &quot;2021-02-25T14:21:07.898957Z&quot;,
            &quot;circuit_count&quot;: 0,
            &quot;device_count&quot;: 1,
            &quot;prefix_count&quot;: 2,
            &quot;rack_count&quot;: 0,
            &quot;virtualmachine_count&quot;: 1,
            &quot;vlan_count&quot;: 0,
        }
    }


@pytest.fixture
def site_prefixes_results():
    return {
        &quot;dict&quot;: {
            &quot;count&quot;: 2,
            &quot;next&quot;: None,
            &quot;previous&quot;: None,
            &quot;results&quot;: [
                {
                    &quot;id&quot;: 284,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/284/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;prefix&quot;: &quot;192.0.2.0/24&quot;,
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;vlan&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;is_pool&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-25&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-25T15:08:27.136305Z&quot;,
                },
                {
                    &quot;id&quot;: 285,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/285/&quot;,
                    &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                    &quot;prefix&quot;: &quot;198.51.100.0/24&quot;,
                    &quot;site&quot;: {
                        &quot;id&quot;: 18,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                        &quot;name&quot;: &quot;Site 1&quot;,
                        &quot;slug&quot;: &quot;site1&quot;,
                    },
                    &quot;vrf&quot;: None,
                    &quot;tenant&quot;: None,
                    &quot;vlan&quot;: None,
                    &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                    &quot;role&quot;: None,
                    &quot;is_pool&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;tags&quot;: [],
                    &quot;custom_fields&quot;: {},
                    &quot;created&quot;: &quot;2021-02-25&quot;,
                    &quot;last_updated&quot;: &quot;2021-02-25T15:08:59.880440Z&quot;,
                },
            ],
        }
    }


@pytest.fixture
def site_prefixes():
    return [
        {
            &quot;id&quot;: 284,
            &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/284/&quot;,
            &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
            &quot;prefix&quot;: &quot;192.0.2.0/24&quot;,
            &quot;vrf&quot;: None,
            &quot;tenant&quot;: None,
            &quot;vlan&quot;: None,
            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
            &quot;role&quot;: None,
            &quot;is_pool&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;tags&quot;: [],
            &quot;custom_fields&quot;: {},
            &quot;created&quot;: &quot;2021-02-25&quot;,
            &quot;last_updated&quot;: &quot;2021-02-25T15:08:27.136305Z&quot;,
        },
        {
            &quot;id&quot;: 285,
            &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/285/&quot;,
            &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
            &quot;prefix&quot;: &quot;198.51.100.0/24&quot;,
            &quot;vrf&quot;: None,
            &quot;tenant&quot;: None,
            &quot;vlan&quot;: None,
            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
            &quot;role&quot;: None,
            &quot;is_pool&quot;: False,
            &quot;description&quot;: &quot;&quot;,
            &quot;tags&quot;: [],
            &quot;custom_fields&quot;: {},
            &quot;created&quot;: &quot;2021-02-25&quot;,
            &quot;last_updated&quot;: &quot;2021-02-25T15:08:59.880440Z&quot;,
        },
    ]


@pytest.fixture
def proxy_details_results():
    return {
        &quot;dict&quot;: {
            &quot;id&quot;: 1,
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
            &quot;name&quot;: &quot;Cisco IOS&quot;,
            &quot;slug&quot;: &quot;ios&quot;,
            &quot;manufacturer&quot;: {
                &quot;id&quot;: 1,
                &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/manufacturers/1/&quot;,
                &quot;name&quot;: &quot;Cisco&quot;,
                &quot;slug&quot;: &quot;cisco&quot;,
            },
            &quot;napalm_driver&quot;: &quot;ios&quot;,
            &quot;napalm_args&quot;: None,
            &quot;description&quot;: &quot;&quot;,
            &quot;device_count&quot;: 152,
            &quot;virtualmachine_count&quot;: 1,
        }
    }


@pytest.fixture
def proxy_details():
    return {
        &quot;host&quot;: &quot;192.0.2.1&quot;,
        &quot;driver&quot;: &quot;ios&quot;,
        &quot;proxytype&quot;: &quot;napalm&quot;,
    }


@pytest.fixture
def pillar_results():
    return {
        &quot;netbox&quot;: {
            &quot;id&quot;: 511,
            &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/devices/511/&quot;,
            &quot;name&quot;: &quot;minion1&quot;,
            &quot;node_type&quot;: &quot;device&quot;,
            &quot;display_name&quot;: &quot;minion1&quot;,
            &quot;device_type&quot;: {
                &quot;id&quot;: 4,
                &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-types/4/&quot;,
                &quot;manufacturer&quot;: {
                    &quot;id&quot;: 1,
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/manufacturers/1/&quot;,
                    &quot;name&quot;: &quot;Cisco&quot;,
                    &quot;slug&quot;: &quot;cisco&quot;,
                },
                &quot;model&quot;: &quot;ISR2901&quot;,
                &quot;slug&quot;: &quot;isr2901&quot;,
                &quot;display_name&quot;: &quot;Cisco ISR2901&quot;,
            },
            &quot;device_role&quot;: {
                &quot;id&quot;: 45,
                &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/device-roles/45/&quot;,
                &quot;name&quot;: &quot;Network&quot;,
                &quot;slug&quot;: &quot;network&quot;,
            },
            &quot;interfaces&quot;: [
                {
                    &quot;id&quot;: 8158,
                    &quot;ip_addresses&quot;: [
                        {
                            &quot;id&quot;: 1146,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                            &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                            &quot;address&quot;: &quot;192.0.2.1/24&quot;,
                            &quot;vrf&quot;: None,
                            &quot;tenant&quot;: None,
                            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                            &quot;role&quot;: None,
                            &quot;nat_inside&quot;: None,
                            &quot;nat_outside&quot;: None,
                            &quot;dns_name&quot;: &quot;&quot;,
                            &quot;description&quot;: &quot;&quot;,
                            &quot;tags&quot;: [],
                            &quot;custom_fields&quot;: {},
                            &quot;created&quot;: &quot;2021-02-19&quot;,
                            &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.153386Z&quot;,
                        },
                    ],
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8158/&quot;,
                    &quot;name&quot;: &quot;GigabitEthernet0/0&quot;,
                    &quot;label&quot;: &quot;&quot;,
                    &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
                    &quot;enabled&quot;: True,
                    &quot;lag&quot;: None,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;mgmt_only&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;cable&quot;: None,
                    &quot;cable_peer&quot;: None,
                    &quot;cable_peer_type&quot;: None,
                    &quot;connected_endpoint&quot;: None,
                    &quot;connected_endpoint_type&quot;: None,
                    &quot;connected_endpoint_reachable&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;count_ipaddresses&quot;: 1,
                },
                {
                    &quot;id&quot;: 8159,
                    &quot;ip_addresses&quot;: [
                        {
                            &quot;id&quot;: 1147,
                            &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1147/&quot;,
                            &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                            &quot;address&quot;: &quot;198.51.100.1/24&quot;,
                            &quot;vrf&quot;: None,
                            &quot;tenant&quot;: None,
                            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                            &quot;role&quot;: None,
                            &quot;nat_inside&quot;: None,
                            &quot;nat_outside&quot;: None,
                            &quot;dns_name&quot;: &quot;&quot;,
                            &quot;description&quot;: &quot;&quot;,
                            &quot;tags&quot;: [],
                            &quot;custom_fields&quot;: {},
                            &quot;created&quot;: &quot;2021-02-19&quot;,
                            &quot;last_updated&quot;: &quot;2021-02-19T06:12:40.508154Z&quot;,
                        },
                    ],
                    &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/interfaces/8159/&quot;,
                    &quot;name&quot;: &quot;GigabitEthernet0/1&quot;,
                    &quot;label&quot;: &quot;&quot;,
                    &quot;type&quot;: {&quot;value&quot;: &quot;1000base-t&quot;, &quot;label&quot;: &quot;1000BASE-T (1GE)&quot;},
                    &quot;enabled&quot;: True,
                    &quot;lag&quot;: None,
                    &quot;mtu&quot;: None,
                    &quot;mac_address&quot;: None,
                    &quot;mgmt_only&quot;: False,
                    &quot;description&quot;: &quot;&quot;,
                    &quot;mode&quot;: None,
                    &quot;untagged_vlan&quot;: None,
                    &quot;tagged_vlans&quot;: [],
                    &quot;cable&quot;: None,
                    &quot;cable_peer&quot;: None,
                    &quot;cable_peer_type&quot;: None,
                    &quot;connected_endpoint&quot;: None,
                    &quot;connected_endpoint_type&quot;: None,
                    &quot;connected_endpoint_reachable&quot;: None,
                    &quot;tags&quot;: [],
                    &quot;count_ipaddresses&quot;: 1,
                },
            ],
            &quot;tenant&quot;: None,
            &quot;platform&quot;: {
                &quot;id&quot;: 1,
                &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/platforms/1/&quot;,
                &quot;name&quot;: &quot;Cisco IOS&quot;,
                &quot;slug&quot;: &quot;ios&quot;,
            },
            &quot;serial&quot;: &quot;&quot;,
            &quot;asset_tag&quot;: None,
            &quot;site&quot;: {
                &quot;id&quot;: 18,
                &quot;url&quot;: &quot;https://netbox.example.com/api/dcim/sites/18/&quot;,
                &quot;name&quot;: &quot;Site 1&quot;,
                &quot;slug&quot;: &quot;site1&quot;,
                &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                &quot;region&quot;: None,
                &quot;tenant&quot;: None,
                &quot;facility&quot;: &quot;&quot;,
                &quot;asn&quot;: None,
                &quot;time_zone&quot;: None,
                &quot;description&quot;: &quot;&quot;,
                &quot;physical_address&quot;: &quot;&quot;,
                &quot;shipping_address&quot;: &quot;&quot;,
                &quot;latitude&quot;: None,
                &quot;longitude&quot;: None,
                &quot;contact_name&quot;: &quot;&quot;,
                &quot;contact_phone&quot;: &quot;&quot;,
                &quot;contact_email&quot;: &quot;&quot;,
                &quot;comments&quot;: &quot;&quot;,
                &quot;tags&quot;: [],
                &quot;custom_fields&quot;: {},
                &quot;created&quot;: &quot;2021-02-25&quot;,
                &quot;last_updated&quot;: &quot;2021-02-25T14:21:07.898957Z&quot;,
                &quot;circuit_count&quot;: 0,
                &quot;device_count&quot;: 1,
                &quot;prefix_count&quot;: 2,
                &quot;rack_count&quot;: 0,
                &quot;virtualmachine_count&quot;: 1,
                &quot;vlan_count&quot;: 0,
                &quot;prefixes&quot;: [
                    {
                        &quot;id&quot;: 284,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/284/&quot;,
                        &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                        &quot;prefix&quot;: &quot;192.0.2.0/24&quot;,
                        &quot;vrf&quot;: None,
                        &quot;tenant&quot;: None,
                        &quot;vlan&quot;: None,
                        &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                        &quot;role&quot;: None,
                        &quot;is_pool&quot;: False,
                        &quot;description&quot;: &quot;&quot;,
                        &quot;tags&quot;: [],
                        &quot;custom_fields&quot;: {},
                        &quot;created&quot;: &quot;2021-02-25&quot;,
                        &quot;last_updated&quot;: &quot;2021-02-25T15:08:27.136305Z&quot;,
                    },
                    {
                        &quot;id&quot;: 285,
                        &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/prefixes/285/&quot;,
                        &quot;family&quot;: {&quot;value&quot;: 4, &quot;label&quot;: &quot;IPv4&quot;},
                        &quot;prefix&quot;: &quot;198.51.100.0/24&quot;,
                        &quot;vrf&quot;: None,
                        &quot;tenant&quot;: None,
                        &quot;vlan&quot;: None,
                        &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
                        &quot;role&quot;: None,
                        &quot;is_pool&quot;: False,
                        &quot;description&quot;: &quot;&quot;,
                        &quot;tags&quot;: [],
                        &quot;custom_fields&quot;: {},
                        &quot;created&quot;: &quot;2021-02-25&quot;,
                        &quot;last_updated&quot;: &quot;2021-02-25T15:08:59.880440Z&quot;,
                    },
                ],
            },
            &quot;rack&quot;: None,
            &quot;position&quot;: None,
            &quot;face&quot;: None,
            &quot;parent_device&quot;: None,
            &quot;status&quot;: {&quot;value&quot;: &quot;active&quot;, &quot;label&quot;: &quot;Active&quot;},
            &quot;primary_ip&quot;: {
                &quot;id&quot;: 1146,
                &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                &quot;family&quot;: 4,
                &quot;address&quot;: &quot;192.0.2.1/24&quot;,
            },
            &quot;primary_ip4&quot;: {
                &quot;id&quot;: 1146,
                &quot;url&quot;: &quot;https://netbox.example.com/api/ipam/ip-addresses/1146/&quot;,
                &quot;family&quot;: 4,
                &quot;address&quot;: &quot;192.0.2.1/24&quot;,
            },
            &quot;primary_ip6&quot;: None,
            &quot;cluster&quot;: None,
            &quot;virtual_chassis&quot;: None,
            &quot;vc_position&quot;: None,
            &quot;vc_priority&quot;: None,
            &quot;comments&quot;: &quot;&quot;,
            &quot;local_context_data&quot;: None,
            &quot;tags&quot;: [],
            &quot;custom_fields&quot;: {},
            &quot;config_context&quot;: {},
            &quot;created&quot;: &quot;2021-02-19&quot;,
            &quot;last_updated&quot;: &quot;2021-02-19T06:12:04.171105Z&quot;,
        },
        &quot;proxy&quot;: {&quot;host&quot;: &quot;192.0.2.1&quot;, &quot;driver&quot;: &quot;ios&quot;, &quot;proxytype&quot;: &quot;napalm&quot;},
    }


def test_when_minion_id_is_star_then_result_should_be_empty_dict(default_kwargs):
    expected_result = {}
    default_kwargs[&quot;minion_id&quot;] = &quot;*&quot;

    actual_result = netbox.ext_pillar(**default_kwargs)

    assert actual_result == expected_result


def test_when_api_url_is_not_http_or_https_then_error_message_should_be_logged(
    default_kwargs,
):
    default_kwargs[&quot;api_url&quot;] = &quot;ftp://netbox.example.com&quot;

    with patch(&quot;salt.pillar.netbox.log.error&quot;, autospec=True) as fake_error:
        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'Provided URL for api_url &quot;%s&quot; is malformed or is not an http/https URL',
            &quot;ftp://netbox.example.com&quot;,
        )


def test_when_neither_devices_or_virtual_machines_requested_then_error_message_should_be_logged(
    default_kwargs,
):
    default_kwargs[&quot;devices&quot;] = default_kwargs[&quot;virtual_machines&quot;] = False

    with patch(&quot;salt.pillar.netbox.log.error&quot;, autospec=True) as fake_error:
        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            &quot;At least one of devices or virtual_machines must be True&quot;
        )


def test_when_interface_ips_requested_but_not_interfaces_then_error_message_should_be_logged(
    default_kwargs,
):
    default_kwargs[&quot;interfaces&quot;] = False
    default_kwargs[&quot;interface_ips&quot;] = True

    with patch(&quot;salt.pillar.netbox.log.error&quot;, autospec=True) as fake_error:
        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            &quot;The value for interfaces must be True if interface_ips is True&quot;
        )


def test_when_api_query_result_limit_set_but_not_a_positive_integer_then_error_message_should_be_logged(
    default_kwargs,
):
    default_kwargs[&quot;api_query_result_limit&quot;] = -1

    with patch(&quot;salt.pillar.netbox.log.error&quot;, autospec=True) as fake_error:
        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            &quot;The value for api_query_result_limit must be a postive integer if set&quot;
        )


def test_when_api_token_not_set_then_error_message_should_be_logged(
    default_kwargs,
):

    default_kwargs[&quot;api_token&quot;] = &quot;&quot;

    with patch(&quot;salt.pillar.netbox.log.error&quot;, autospec=True) as fake_error:
        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(&quot;The value for api_token is not set&quot;)


def test_when_we_retrieve_a_single_device_then_return_list(
    default_kwargs, headers, device_results
):

    expected_result = device_results[&quot;dict&quot;][&quot;results&quot;]

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = device_results

        actual_result = netbox._get_devices(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_a_device_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):
    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_devices(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_a_single_virtual_machine_then_return_list(
    default_kwargs, headers, virtual_machine_results
):

    expected_result = virtual_machine_results[&quot;dict&quot;][&quot;results&quot;]

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = virtual_machine_results

        actual_result = netbox._get_virtual_machines(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_a_virtual_machine_and_get_http_error_then_return_empty_dict(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_virtual_machines(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_device_interfaces_then_return_dict(
    default_kwargs, headers, device_interface_results, device_interfaces_list
):

    expected_result = device_interfaces_list

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = device_interface_results

        actual_result = netbox._get_interfaces(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            511,
            &quot;device&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_device_interfaces_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_interfaces(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            511,
            &quot;device&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_virtual_machine_interfaces_then_return_list(
    default_kwargs,
    headers,
    virtual_machine_interface_results,
    virtual_machine_interfaces_list,
):

    expected_result = virtual_machine_interfaces_list

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = virtual_machine_interface_results

        actual_result = netbox._get_interfaces(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            222,
            &quot;virtual-machine&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_virtual_machine_interfaces_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_interfaces(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            222,
            &quot;virtual-machine&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_device_interface_ips_then_return_list(
    default_kwargs, headers, device_ip_results
):

    expected_result = device_ip_results[&quot;dict&quot;][&quot;results&quot;]

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = device_ip_results

        actual_result = netbox._get_interface_ips(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            511,
            &quot;device&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_device_interface_ips_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_interface_ips(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            511,
            &quot;device&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_virtual_machine_interface_ips_then_return_list(
    default_kwargs, headers, virtual_machine_ip_results
):

    expected_result = virtual_machine_ip_results[&quot;dict&quot;][&quot;results&quot;]

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = virtual_machine_ip_results

        actual_result = netbox._get_interface_ips(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            222,
            &quot;virtual-machine&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_virtual_machine_interface_ips_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_interface_ips(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            222,
            &quot;virtual-machine&quot;,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_associate_ips_to_interfaces_then_return_list(
    default_kwargs, device_interfaces_list, device_ip_results, device_interfaces_ip_list
):

    expected_result = device_interfaces_ip_list

    interfaces_list = device_interfaces_list
    interface_ips_list = device_ip_results[&quot;dict&quot;][&quot;results&quot;]

    actual_result = netbox._associate_ips_to_interfaces(
        interfaces_list, interface_ips_list
    )

    assert actual_result == expected_result


def test_associate_empty_ip_list_to_interfaces_then_return_list(
    default_kwargs, device_interfaces_list, device_ip_results
):

    expected_result = device_interfaces_list

    interfaces_list = device_interfaces_list
    interface_ips_list = []

    actual_result = netbox._associate_ips_to_interfaces(
        interfaces_list, interface_ips_list
    )

    assert actual_result == expected_result


def test_when_we_retrieve_site_details_then_return_dict(
    default_kwargs, headers, site_results
):

    expected_result = site_results[&quot;dict&quot;]

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = site_results

        actual_result = netbox._get_site_details(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;Site 1&quot;,
            18,
            headers,
        )

        assert actual_result == expected_result


def test_when_we_retrieve_site_details_and_get_http_error_then_return_empty_dict(
    default_kwargs, headers, http_error
):

    expected_result = {}

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_site_details(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;Site 1&quot;,
            18,
            headers,
        )

        assert actual_result == expected_result


def test_when_we_retrieve_site_prefixes_then_return_list(
    default_kwargs, headers, site_prefixes_results, site_prefixes
):

    expected_result = site_prefixes

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = site_prefixes_results

        actual_result = netbox._get_site_prefixes(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;Site 1&quot;,
            18,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_site_prefixes_and_get_http_error_then_return_empty_list(
    default_kwargs, headers, http_error
):

    expected_result = []

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_site_prefixes(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;Site 1&quot;,
            18,
            headers,
            default_kwargs[&quot;api_query_result_limit&quot;],
        )

        assert actual_result == expected_result


def test_when_we_retrieve_proxy_details_then_return_dict(
    default_kwargs, headers, proxy_details_results, proxy_details
):

    expected_result = proxy_details

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = proxy_details_results

        actual_result = netbox._get_proxy_details(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;192.0.2.1/24&quot;,
            1,
            headers,
        )

        assert actual_result == expected_result


def test_when_we_retrieve_proxy_details_and_get_http_error_then_dont_return(
    default_kwargs, headers, http_error
):

    expected_result = None

    with patch(&quot;salt.utils.http.query&quot;, autospec=True) as query:
        query.return_value = http_error

        actual_result = netbox._get_proxy_details(
            default_kwargs[&quot;api_url&quot;],
            default_kwargs[&quot;minion_id&quot;],
            &quot;192.0.2.1/24&quot;,
            1,
            headers,
        )

        assert actual_result == expected_result


def test_when_we_retrieve_multiple_devices_then_error_message_should_be_logged(
    default_kwargs, multiple_device_results
):

    with patch(
        &quot;salt.pillar.netbox._get_devices&quot;, autospec=True
    ) as multiple_devices, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        multiple_devices.return_value = multiple_device_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'More than one node found for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_retrieve_multiple_virtual_machines_then_error_message_should_be_logged(
    default_kwargs, multiple_virtual_machine_results
):
    default_kwargs[&quot;devices&quot;] = False
    default_kwargs[&quot;virtual_machines&quot;] = True

    with patch(
        &quot;salt.pillar.netbox._get_virtual_machines&quot;, autospec=True
    ) as multiple_virtual_machines, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        multiple_virtual_machines.return_value = multiple_virtual_machine_results[
            &quot;dict&quot;
        ][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'More than one node found for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_retrieve_a_device_and_a_virtual_machine_then_error_message_should_be_logged(
    default_kwargs, device_results, virtual_machine_results
):
    default_kwargs[&quot;virtual_machines&quot;] = True
<A NAME="0"></A>
    with patch(&quot;salt.pillar.netbox._get_devices&quot;, autospec=True) as device, patch(
        &quot;salt.pillar.netbox._get_virtual_machines&quot;, autospec=True
    ) as virtual_machine, patch<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match284716-1.html#0',3,'match284716-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        device.return_value = device_results[&quot;dict&quot;][&quot;results&quot;]
        virtual_machine.return_value = virtual_machine_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.</B></FONT>assert_called_with(
            'More than one node found for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_retrieve_no_devices_then_error_message_should_be_logged(
    default_kwargs, no_results
):

    with patch(&quot;salt.pillar.netbox._get_devices&quot;, autospec=True) as devices, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        devices.return_value = no_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'Unable to pull NetBox data for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_retrieve_no_virtual_machines_then_error_message_should_be_logged(
    default_kwargs, no_results
):
    default_kwargs[&quot;devices&quot;] = False
    default_kwargs[&quot;virtual_machines&quot;] = True

    with patch(
        &quot;salt.pillar.netbox._get_virtual_machines&quot;, autospec=True
    ) as virtual_machines, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:
        virtual_machines.return_value = no_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'Unable to pull NetBox data for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_retrieve_everything_successfully_then_return_dict(
    default_kwargs,
    device_results,
    no_results,
    device_interfaces_list,
    device_ip_results,
    site_results,
    site_prefixes,
    proxy_details,
    pillar_results,
):

    expected_result = pillar_results

    default_kwargs[&quot;virtual_machines&quot;] = False
    default_kwargs[&quot;interfaces&quot;] = True
    default_kwargs[&quot;interface_ips&quot;] = True
    default_kwargs[&quot;site_details&quot;] = True
    default_kwargs[&quot;site_prefixes&quot;] = True
    default_kwargs[&quot;proxy_return&quot;] = True

    with patch(&quot;salt.pillar.netbox._get_devices&quot;, autospec=True) as get_devices, patch(
        &quot;salt.pillar.netbox._get_virtual_machines&quot;, autospec=True
    ) as get_virtual_machines, patch(
        &quot;salt.pillar.netbox._get_interfaces&quot;, autospec=True
    ) as get_interfaces, patch(
        &quot;salt.pillar.netbox._get_interface_ips&quot;, autospec=True
    ) as get_interface_ips, patch(
        &quot;salt.pillar.netbox._get_site_details&quot;, autospec=True
    ) as get_site_details, patch(
        &quot;salt.pillar.netbox._get_site_prefixes&quot;, autospec=True
    ) as get_site_prefixes, patch(
        &quot;salt.pillar.netbox._get_proxy_details&quot;, autospec=True
    ) as get_proxy_details:

        get_devices.return_value = device_results[&quot;dict&quot;][&quot;results&quot;]
        get_virtual_machines.return_value = no_results[&quot;dict&quot;][&quot;results&quot;]
        get_interfaces.return_value = device_interfaces_list
        get_interface_ips.return_value = device_ip_results[&quot;dict&quot;][&quot;results&quot;]
        get_site_details.return_value = site_results[&quot;dict&quot;]
        get_site_prefixes.return_value = site_prefixes
        get_proxy_details.return_value = proxy_details

        actual_result = netbox.ext_pillar(**default_kwargs)

        assert actual_result == expected_result


def test_when_we_set_proxy_return_but_get_no_value_for_platform_then_error_message_should_be_logged(
    default_kwargs, headers, device_results
):

    default_kwargs[&quot;site_details&quot;] = False
    default_kwargs[&quot;site_prefixes&quot;] = False
    default_kwargs[&quot;proxy_return&quot;] = True
    device_results[&quot;dict&quot;][&quot;results&quot;][0][&quot;platform&quot;] = None

    with patch(&quot;salt.pillar.netbox._get_devices&quot;, autospec=True) as devices, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        devices.return_value = device_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'You have set &quot;proxy_return&quot; to &quot;True&quot; but you have not set the platform in NetBox for &quot;%s&quot;',
            &quot;minion1&quot;,
        )


def test_when_we_set_proxy_return_but_get_no_value_for_primary_ip_then_error_message_should_be_logged(
    default_kwargs, headers, device_results
):

    default_kwargs[&quot;site_details&quot;] = False
    default_kwargs[&quot;site_prefixes&quot;] = False
    default_kwargs[&quot;proxy_return&quot;] = True
    device_results[&quot;dict&quot;][&quot;results&quot;][0][&quot;primary_ip&quot;] = None

    with patch(&quot;salt.pillar.netbox._get_devices&quot;, autospec=True) as devices, patch(
        &quot;salt.pillar.netbox.log.error&quot;, autospec=True
    ) as fake_error:

        devices.return_value = device_results[&quot;dict&quot;][&quot;results&quot;]

        netbox.ext_pillar(**default_kwargs)

        fake_error.assert_called_with(
            'You have set &quot;proxy_return&quot; to &quot;True&quot; but you have not set the primary IPv4 or IPv6 address in NetBox for &quot;%s&quot;',
            &quot;minion1&quot;,
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>schedule.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# See doc/topics/jobs/index.rst
&quot;&quot;&quot;
Scheduling routines are located here. To activate the scheduler make the
``schedule`` option available to the master or minion configurations (master
config file or for the minion via config or pillar).

Detailed tutorial about scheduling jobs can be found :ref:`here
&lt;scheduling-jobs&gt;`.
&quot;&quot;&quot;


import copy
import datetime
import errno
import itertools
import logging
import os
import random
import signal
import sys
import threading
import time
import weakref

import salt.config
import salt.defaults.exitcodes
import salt.exceptions
import salt.loader
import salt.minion
import salt.payload
import salt.syspaths
import salt.utils.args
import salt.utils.error
import salt.utils.event
import salt.utils.files
import salt.utils.jid
import salt.utils.master
import salt.utils.minion
import salt.utils.platform
import salt.utils.process
import salt.utils.stringutils
import salt.utils.user
import salt.utils.yaml
from salt.exceptions import SaltInvocationError
from salt.utils.odict import OrderedDict

# pylint: disable=import-error
try:
    import dateutil.parser as dateutil_parser

    _WHEN_SUPPORTED = True
    _RANGE_SUPPORTED = True
except ImportError:
    _WHEN_SUPPORTED = False
    _RANGE_SUPPORTED = False

try:
    import croniter

    _CRON_SUPPORTED = True
except ImportError:
    _CRON_SUPPORTED = False
# pylint: enable=import-error

log = logging.getLogger(__name__)


class Schedule:
    &quot;&quot;&quot;
    Create a Schedule object, pass in the opts and the functions dict to use
    &quot;&quot;&quot;

    instance = None

    def __new__(
        cls,
        opts,
        functions,
        returners=None,
        intervals=None,
        cleanup=None,
        proxy=None,
        standalone=False,
        new_instance=False,
        utils=None,
        _subprocess_list=None,
    ):
        &quot;&quot;&quot;
        Only create one instance of Schedule
        &quot;&quot;&quot;
        if cls.instance is None or new_instance is True:
            log.debug(&quot;Initializing new Schedule&quot;)
            # we need to make a local variable for this, as we are going to store
            # it in a WeakValueDictionary-- which will remove the item if no one
            # references it-- this forces a reference while we return to the caller
            instance = object.__new__(cls)
            instance.__singleton_init__(
                opts,
                functions,
                returners=returners,
                intervals=intervals,
                cleanup=cleanup,
                proxy=proxy,
                standalone=standalone,
                utils=utils,
                _subprocess_list=_subprocess_list,
            )
            if new_instance is True:
                return instance
            cls.instance = instance
        else:
            log.debug(&quot;Re-using Schedule&quot;)
        return cls.instance

    # has to remain empty for singletons, since __init__ will *always* be called
    def __init__(
        self,
        opts,
        functions,
        returners=None,
        intervals=None,
        cleanup=None,
        proxy=None,
        standalone=False,
        new_instance=False,
        utils=None,
        _subprocess_list=None,
    ):
        pass

    # an init for the singleton instance to call
    def __singleton_init__(
        self,
        opts,
        functions,
        returners=None,
        intervals=None,
        cleanup=None,
        proxy=None,
        standalone=False,
        utils=None,
        _subprocess_list=None,
    ):
        self.opts = opts
        self.proxy = proxy
        self.functions = functions
        self.utils = utils or salt.loader.utils(opts)
        self.standalone = standalone
        self.skip_function = None
        self.skip_during_range = None
        self.splay = None
        self.enabled = True
        if isinstance(intervals, dict):
            self.intervals = intervals
        else:
            self.intervals = {}
        if not self.standalone:
            if hasattr(returners, &quot;__getitem__&quot;):
                self.returners = returners
            else:
                self.returners = returners.loader.gen_functions()
        try:
            self.time_offset = self.functions.get(
                &quot;timezone.get_offset&quot;, lambda: &quot;0000&quot;
            )()
        except Exception:  # pylint: disable=W0703
            # get_offset can fail, if that happens, default to 0000
            log.warning(
                &quot;Unable to obtain correct timezone offset, defaulting to 0000&quot;,
                exc_info_on_loglevel=logging.DEBUG,
            )
            self.time_offset = &quot;0000&quot;

        self.schedule_returner = self.option(&quot;schedule_returner&quot;)
        # Keep track of the lowest loop interval needed in this variable
        self.loop_interval = sys.maxsize
        if not self.standalone:
            clean_proc_dir(opts)
        if cleanup:
            for prefix in cleanup:
                self.delete_job_prefix(prefix)
        if _subprocess_list is None:
            self._subprocess_list = salt.utils.process.SubprocessList()
        else:
            self._subprocess_list = _subprocess_list

    def __getnewargs__(self):
        return self.opts, self.functions, self.returners, self.intervals, None

    def option(self, opt):
        &quot;&quot;&quot;
        Return options merged from config and pillar
        &quot;&quot;&quot;
        if &quot;config.merge&quot; in self.functions:
            return self.functions[&quot;config.merge&quot;](opt, {}, omit_master=True)
        return self.opts.get(opt, {})

    def _get_schedule(
        self, include_opts=True, include_pillar=True, remove_hidden=False
    ):
        &quot;&quot;&quot;
        Return the schedule data structure
        &quot;&quot;&quot;
        schedule = {}
        if include_pillar:
            pillar_schedule = self.opts.get(&quot;pillar&quot;, {}).get(&quot;schedule&quot;, {})
            if not isinstance(pillar_schedule, dict):
                raise ValueError(&quot;Schedule must be of type dict.&quot;)
            schedule.update(pillar_schedule)
        if include_opts:
            opts_schedule = self.opts.get(&quot;schedule&quot;, {})
            if not isinstance(opts_schedule, dict):
                raise ValueError(&quot;Schedule must be of type dict.&quot;)
            schedule.update(opts_schedule)

        if remove_hidden:
            _schedule = copy.deepcopy(schedule)
            for job in _schedule:
                if isinstance(_schedule[job], dict):
                    for item in _schedule[job]:
                        if item.startswith(&quot;_&quot;):
                            del schedule[job][item]
        return schedule

    def _check_max_running(self, func, data, opts, now):
        &quot;&quot;&quot;
        Return the schedule data structure
        &quot;&quot;&quot;
        # Check to see if there are other jobs with this
        # signature running.  If there are more than maxrunning
        # jobs present then don't start another.
        # If jid_include is False for this job we can ignore all this
        # NOTE--jid_include defaults to True, thus if it is missing from the data
        # dict we treat it like it was there and is True

        # Check if we're able to run
        if &quot;run&quot; not in data or not data[&quot;run&quot;]:
            return data
        if &quot;jid_include&quot; not in data or data[&quot;jid_include&quot;]:
            jobcount = 0
            if self.opts[&quot;__role&quot;] == &quot;master&quot;:
                current_jobs = salt.utils.master.get_running_jobs(self.opts)
            else:
                current_jobs = salt.utils.minion.running(self.opts)
            for job in current_jobs:
                if &quot;schedule&quot; in job:
                    log.debug(
                        &quot;schedule.handle_func: Checking job against fun %s: %s&quot;,
                        func,
                        job,
                    )
                    if data[&quot;name&quot;] == job[
                        &quot;schedule&quot;
                    ] and salt.utils.process.os_is_running(job[&quot;pid&quot;]):
                        jobcount += 1
                        log.debug(
                            &quot;schedule.handle_func: Incrementing jobcount, &quot;
                            &quot;now %s, maxrunning is %s&quot;,
                            jobcount,
                            data[&quot;maxrunning&quot;],
                        )
                        if jobcount &gt;= data[&quot;maxrunning&quot;]:
                            log.debug(
                                &quot;schedule.handle_func: The scheduled job &quot;
                                &quot;%s was not started, %s already running&quot;,
                                data[&quot;name&quot;],
                                data[&quot;maxrunning&quot;],
                            )
                            data[&quot;_skip_reason&quot;] = &quot;maxrunning&quot;
                            data[&quot;_skipped&quot;] = True
                            data[&quot;_skipped_time&quot;] = now
                            data[&quot;run&quot;] = False
                            return data
        return data

    def persist(self):
        &quot;&quot;&quot;
        Persist the modified schedule into &lt;&lt;configdir&gt;&gt;/&lt;&lt;default_include&gt;&gt;/_schedule.conf
        &quot;&quot;&quot;
        config_dir = self.opts.get(&quot;conf_dir&quot;, None)
        if config_dir is None and &quot;conf_file&quot; in self.opts:
            config_dir = os.path.dirname(self.opts[&quot;conf_file&quot;])
        if config_dir is None:
            config_dir = salt.syspaths.CONFIG_DIR

        minion_d_dir = os.path.join(
            config_dir,
            os.path.dirname(
                self.opts.get(
                    &quot;default_include&quot;,
                    salt.config.DEFAULT_MINION_OPTS[&quot;default_include&quot;],
                )
            ),
        )

        if not os.path.isdir(minion_d_dir):
            os.makedirs(minion_d_dir)

        schedule_conf = os.path.join(minion_d_dir, &quot;_schedule.conf&quot;)
        log.debug(&quot;Persisting schedule&quot;)
        schedule_data = self._get_schedule(include_pillar=False, remove_hidden=True)
        try:
            with salt.utils.files.fopen(schedule_conf, &quot;wb+&quot;) as fp_:
                fp_.write(
                    salt.utils.stringutils.to_bytes(
                        salt.utils.yaml.safe_dump({&quot;schedule&quot;: schedule_data})
                    )
                )
        except OSError:
            log.error(
                &quot;Failed to persist the updated schedule&quot;,
                exc_info_on_loglevel=logging.DEBUG,
            )

    def delete_job(self, name, persist=True):
        &quot;&quot;&quot;
        Deletes a job from the scheduler. Ignore jobs from pillar
        &quot;&quot;&quot;
        # ensure job exists, then delete it
        if name in self.opts[&quot;schedule&quot;]:
            del self.opts[&quot;schedule&quot;][name]
        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot delete job %s, it's in the pillar!&quot;, name)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_delete_complete&quot;,
            )

        # remove from self.intervals
        if name in self.intervals:
            del self.intervals[name]

        if persist:
            self.persist()

    def reset(self):
        &quot;&quot;&quot;
        Reset the scheduler to defaults
        &quot;&quot;&quot;
        self.skip_function = None
        self.skip_during_range = None
        self.enabled = True
        self.splay = None
        self.opts[&quot;schedule&quot;] = {}

    def delete_job_prefix(self, name, persist=True):
        &quot;&quot;&quot;
        Deletes a job from the scheduler. Ignores jobs from pillar
        &quot;&quot;&quot;
        # ensure job exists, then delete it
        for job in list(self.opts[&quot;schedule&quot;].keys()):
            if job.startswith(name):
                del self.opts[&quot;schedule&quot;][job]
        for job in self._get_schedule(include_opts=False):
            if job.startswith(name):
                log.warning(&quot;Cannot delete job %s, it's in the pillar!&quot;, job)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_delete_complete&quot;,
            )

        # remove from self.intervals
        for job in list(self.intervals.keys()):
            if job.startswith(name):
                del self.intervals[job]

        if persist:
            self.persist()

    def add_job(self, data, persist=True):
        &quot;&quot;&quot;
        Adds a new job to the scheduler. The format is the same as required in
        the configuration file. See the docs on how YAML is interpreted into
        python data-structures to make sure, you pass correct dictionaries.
        &quot;&quot;&quot;

        # we don't do any checking here besides making sure its a dict.
        # eval() already does for us and raises errors accordingly
        if not isinstance(data, dict):
            raise ValueError(&quot;Scheduled jobs have to be of type dict.&quot;)
        if not len(data) == 1:
            raise ValueError(&quot;You can only schedule one new job at a time.&quot;)

        # if enabled is not included in the job,
        # assume job is enabled.
        for job in data:
            if &quot;enabled&quot; not in data[job]:
                data[job][&quot;enabled&quot;] = True

        new_job = next(iter(data.keys()))

        if new_job in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot update job %s, it's in the pillar!&quot;, new_job)

        elif new_job in self.opts[&quot;schedule&quot;]:
            log.info(&quot;Updating job settings for scheduled job: %s&quot;, new_job)
            self.opts[&quot;schedule&quot;].update(data)

        else:
            log.info(&quot;Added new job %s to scheduler&quot;, new_job)
            self.opts[&quot;schedule&quot;].update(data)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_add_complete&quot;,
            )

        if persist:
            self.persist()

    def enable_job(self, name, persist=True):
        &quot;&quot;&quot;
        Enable a job in the scheduler. Ignores jobs from pillar
        &quot;&quot;&quot;
        # ensure job exists, then enable it
        if name in self.opts[&quot;schedule&quot;]:
            self.opts[&quot;schedule&quot;][name][&quot;enabled&quot;] = True
            log.info(&quot;Enabling job %s in scheduler&quot;, name)
        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot modify job %s, it's in the pillar!&quot;, name)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_enabled_job_complete&quot;,
            )

        if persist:
            self.persist()

    def disable_job(self, name, persist=True):
        &quot;&quot;&quot;
        Disable a job in the scheduler. Ignores jobs from pillar
        &quot;&quot;&quot;
        # ensure job exists, then disable it
        if name in self.opts[&quot;schedule&quot;]:
            self.opts[&quot;schedule&quot;][name][&quot;enabled&quot;] = False
            log.info(&quot;Disabling job %s in scheduler&quot;, name)
        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot modify job %s, it's in the pillar!&quot;, name)

        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            # Fire the complete event back along with updated list of schedule
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_disabled_job_complete&quot;,
            )

        if persist:
            self.persist()

    def modify_job(self, name, schedule, persist=True):
        &quot;&quot;&quot;
        Modify a job in the scheduler. Ignores jobs from pillar
        &quot;&quot;&quot;
        # ensure job exists, then replace it
        if name in self.opts[&quot;schedule&quot;]:
            self.delete_job(name, persist)
        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot modify job %s, it's in the pillar!&quot;, name)
            return

        self.opts[&quot;schedule&quot;][name] = schedule

        if persist:
            self.persist()

    def run_job(self, name):
        &quot;&quot;&quot;
        Run a schedule job now
        &quot;&quot;&quot;
        data = self._get_schedule().get(name, {})

        if &quot;function&quot; in data:
            func = data[&quot;function&quot;]
        elif &quot;func&quot; in data:
            func = data[&quot;func&quot;]
        elif &quot;fun&quot; in data:
            func = data[&quot;fun&quot;]
        else:
            func = None
        if func not in self.functions:
            log.info(&quot;Invalid function: %s in scheduled job %s.&quot;, func, name)

        if &quot;name&quot; not in data:
            data[&quot;name&quot;] = name

        # Assume run should be True until we check max_running
        if &quot;run&quot; not in data:
            data[&quot;run&quot;] = True

        if not self.standalone:
            data = self._check_max_running(
                func, data, self.opts, datetime.datetime.now()
            )

        # Grab run, assume True
        if data.get(&quot;run&quot;):
            log.info(&quot;Running Job: %s&quot;, name)
            self._run_job(func, data)

    def enable_schedule(self, persist=True):
        &quot;&quot;&quot;
        Enable the scheduler.
        &quot;&quot;&quot;
        self.opts[&quot;schedule&quot;][&quot;enabled&quot;] = True

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_enabled_complete&quot;,
            )

        if persist:
            self.persist()

    def disable_schedule(self, persist=True):
        &quot;&quot;&quot;
        Disable the scheduler.
        &quot;&quot;&quot;
        self.opts[&quot;schedule&quot;][&quot;enabled&quot;] = False

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_disabled_complete&quot;,
            )

        if persist:
            self.persist()

    def reload(self, schedule):
        &quot;&quot;&quot;
        Reload the schedule from saved schedule file.
        &quot;&quot;&quot;
        # Remove all jobs from self.intervals
        self.intervals = {}

        if &quot;schedule&quot; in schedule:
            schedule = schedule[&quot;schedule&quot;]
        self.opts.setdefault(&quot;schedule&quot;, {}).update(schedule)

    def list(self, where):
        &quot;&quot;&quot;
        List the current schedule items
        &quot;&quot;&quot;
        if where == &quot;pillar&quot;:
            schedule = self._get_schedule(include_opts=False)
        elif where == &quot;opts&quot;:
            schedule = self._get_schedule(include_pillar=False)
        else:
            schedule = self._get_schedule()

        # Fire the complete event back along with the list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: schedule},
                tag=&quot;/salt/minion/minion_schedule_list_complete&quot;,
            )

    def save_schedule(self):
        &quot;&quot;&quot;
        Save the current schedule
        &quot;&quot;&quot;
        self.persist()

        # Fire the complete event back along with the list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event({&quot;complete&quot;: True}, tag=&quot;/salt/minion/minion_schedule_saved&quot;)

    def postpone_job(self, name, data):
        &quot;&quot;&quot;
        Postpone a job in the scheduler.
        Ignores jobs from pillar
        &quot;&quot;&quot;
        time = data[&quot;time&quot;]
        new_time = data[&quot;new_time&quot;]
        time_fmt = data.get(&quot;time_fmt&quot;, &quot;%Y-%m-%dT%H:%M:%S&quot;)

        # ensure job exists, then disable it
        if name in self.opts[&quot;schedule&quot;]:
            if &quot;skip_explicit&quot; not in self.opts[&quot;schedule&quot;][name]:
                self.opts[&quot;schedule&quot;][name][&quot;skip_explicit&quot;] = []
            self.opts[&quot;schedule&quot;][name][&quot;skip_explicit&quot;].append(
                {&quot;time&quot;: time, &quot;time_fmt&quot;: time_fmt}
            )

            if &quot;run_explicit&quot; not in self.opts[&quot;schedule&quot;][name]:
                self.opts[&quot;schedule&quot;][name][&quot;run_explicit&quot;] = []
            self.opts[&quot;schedule&quot;][name][&quot;run_explicit&quot;].append(
                {&quot;time&quot;: new_time, &quot;time_fmt&quot;: time_fmt}
            )

        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot modify job %s, it's in the pillar!&quot;, name)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_postpone_job_complete&quot;,
            )

    def skip_job(self, name, data):
        &quot;&quot;&quot;
        Skip a job at a specific time in the scheduler.
        Ignores jobs from pillar
        &quot;&quot;&quot;
        time = data[&quot;time&quot;]
        time_fmt = data.get(&quot;time_fmt&quot;, &quot;%Y-%m-%dT%H:%M:%S&quot;)

        # ensure job exists, then disable it
        if name in self.opts[&quot;schedule&quot;]:
            if &quot;skip_explicit&quot; not in self.opts[&quot;schedule&quot;][name]:
                self.opts[&quot;schedule&quot;][name][&quot;skip_explicit&quot;] = []
            self.opts[&quot;schedule&quot;][name][&quot;skip_explicit&quot;].append(
                {&quot;time&quot;: time, &quot;time_fmt&quot;: time_fmt}
            )

        elif name in self._get_schedule(include_opts=False):
            log.warning(&quot;Cannot modify job %s, it's in the pillar!&quot;, name)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;schedule&quot;: self._get_schedule()},
                tag=&quot;/salt/minion/minion_schedule_skip_job_complete&quot;,
            )

    def get_next_fire_time(self, name, fmt=&quot;%Y-%m-%dT%H:%M:%S&quot;):
        &quot;&quot;&quot;
        Return the next fire time for the specified job
        &quot;&quot;&quot;

        schedule = self._get_schedule()
        _next_fire_time = None
        if schedule:
            _next_fire_time = schedule.get(name, {}).get(&quot;_next_fire_time&quot;, None)
            if _next_fire_time:
                _next_fire_time = _next_fire_time.strftime(fmt)

        # Fire the complete event back along with updated list of schedule
        with salt.utils.event.get_event(&quot;minion&quot;, opts=self.opts, listen=False) as evt:
            evt.fire_event(
                {&quot;complete&quot;: True, &quot;next_fire_time&quot;: _next_fire_time},
                tag=&quot;/salt/minion/minion_schedule_next_fire_time_complete&quot;,
            )

    def job_status(self, name, fire_event=False):
        &quot;&quot;&quot;
        Return the specified schedule item
        &quot;&quot;&quot;

        if fire_event:
            schedule = self._get_schedule()
            data = schedule.get(name, {})

            # Fire the complete event back along with updated list of schedule
            with salt.utils.event.get_event(
                &quot;minion&quot;, opts=self.opts, listen=False
            ) as evt:
                evt.fire_event(
                    {&quot;complete&quot;: True, &quot;data&quot;: data},
                    tag=&quot;/salt/minion/minion_schedule_job_status_complete&quot;,
                )
        else:
            schedule = self._get_schedule()
            return schedule.get(name, {})

    def handle_func(self, multiprocessing_enabled, func, data, jid=None):
        &quot;&quot;&quot;
        Execute this method in a multiprocess or thread
        &quot;&quot;&quot;
        if salt.utils.platform.is_windows() or self.opts.get(&quot;transport&quot;) == &quot;zeromq&quot;:
            # Since function references can't be pickled and pickling
            # is required when spawning new processes on Windows, regenerate
            # the functions and returners.
            # This also needed for ZeroMQ transport to reset all functions
            # context data that could keep paretns connections. ZeroMQ will
            # hang on polling parents connections from the child process.
            self.utils = salt.loader.utils(self.opts)
            if self.opts[&quot;__role&quot;] == &quot;master&quot;:
                self.functions = salt.loader.runner(self.opts, utils=self.utils)
            else:
                self.functions = salt.loader.minion_mods(
                    self.opts, proxy=self.proxy, utils=self.utils
                )
            self.returners = salt.loader.returners(
                self.opts, self.functions, proxy=self.proxy
            )
        if jid is None:
            jid = salt.utils.jid.gen_jid(self.opts)
        ret = {
            &quot;id&quot;: self.opts.get(&quot;id&quot;, &quot;master&quot;),
            &quot;fun&quot;: func,
            &quot;fun_args&quot;: [],
            &quot;schedule&quot;: data[&quot;name&quot;],
            &quot;jid&quot;: jid,
        }

        if &quot;metadata&quot; in data:
            if isinstance(data[&quot;metadata&quot;], dict):
                ret[&quot;metadata&quot;] = data[&quot;metadata&quot;]
                ret[&quot;metadata&quot;][&quot;_TOS&quot;] = self.time_offset
                ret[&quot;metadata&quot;][&quot;_TS&quot;] = time.ctime()
                ret[&quot;metadata&quot;][&quot;_TT&quot;] = time.strftime(
                    &quot;%Y %B %d %a %H %m&quot;, time.gmtime()
                )
            else:
                log.warning(
                    &quot;schedule: The metadata parameter must be &quot;
                    &quot;specified as a dictionary.  Ignoring.&quot;
                )

        data_returner = data.get(&quot;returner&quot;, None)

        if not self.standalone:
            proc_fn = os.path.join(
                salt.minion.get_proc_dir(self.opts[&quot;cachedir&quot;]), ret[&quot;jid&quot;]
            )

        # TODO: Make it readable! Splt to funcs, remove nested try-except-finally sections.
        try:

            minion_blackout_violation = False
            if self.opts.get(&quot;pillar&quot;, {}).get(&quot;minion_blackout&quot;, False):
                whitelist = self.opts.get(&quot;pillar&quot;, {}).get(
                    &quot;minion_blackout_whitelist&quot;, []
                )
                # this minion is blacked out. Only allow saltutil.refresh_pillar and the whitelist
                if func != &quot;saltutil.refresh_pillar&quot; and func not in whitelist:
                    minion_blackout_violation = True
            elif self.opts.get(&quot;grains&quot;, {}).get(&quot;minion_blackout&quot;, False):
                whitelist = self.opts.get(&quot;grains&quot;, {}).get(
                    &quot;minion_blackout_whitelist&quot;, []
                )
                if func != &quot;saltutil.refresh_pillar&quot; and func not in whitelist:
                    minion_blackout_violation = True
            if minion_blackout_violation:
                raise SaltInvocationError(
                    &quot;Minion in blackout mode. Set 'minion_blackout' &quot;
                    &quot;to False in pillar or grains to resume operations. Only &quot;
                    &quot;saltutil.refresh_pillar allowed in blackout mode.&quot;
                )

            ret[&quot;pid&quot;] = os.getpid()

            args = tuple()
            if &quot;args&quot; in data:
                args = copy.deepcopy(data[&quot;args&quot;])
                ret[&quot;fun_args&quot;].extend(data[&quot;args&quot;])

            kwargs = {}
            if &quot;kwargs&quot; in data:
                kwargs = copy.deepcopy(data[&quot;kwargs&quot;])
                ret[&quot;fun_args&quot;].append(copy.deepcopy(kwargs))

            if func not in self.functions:
                ret[&quot;return&quot;] = self.functions.missing_fun_string(func)
                salt.utils.error.raise_error(
                    message=self.functions.missing_fun_string(func)
                )

            if not self.standalone:
                if &quot;jid_include&quot; not in data or data[&quot;jid_include&quot;]:
                    log.debug(
                        &quot;schedule.handle_func: adding this job to the &quot;
                        &quot;jobcache with data %s&quot;,
                        ret,
                    )
                    # write this to /var/cache/salt/minion/proc
                    with salt.utils.files.fopen(proc_fn, &quot;w+b&quot;) as fp_:
                        fp_.write(salt.payload.dumps(ret))

            # if the func support **kwargs, lets pack in the pub data we have
            # TODO: pack the *same* pub data as a minion?
            argspec = salt.utils.args.get_function_argspec(self.functions[func])
            if argspec.keywords:
                # this function accepts **kwargs, pack in the publish data
                for key, val in ret.items():
                    if key != &quot;kwargs&quot;:
                        kwargs[&quot;__pub_{}&quot;.format(key)] = copy.deepcopy(val)

            # Only include these when running runner modules
            if self.opts[&quot;__role&quot;] == &quot;master&quot;:
                jid = salt.utils.jid.gen_jid(self.opts)
                tag = salt.utils.event.tagify(jid, prefix=&quot;salt/scheduler/&quot;)

                namespaced_event = salt.utils.event.NamespacedEvent(
                    salt.utils.event.get_event(
                        self.opts[&quot;__role&quot;],
                        self.opts[&quot;sock_dir&quot;],
                        opts=self.opts,
                        listen=False,
                    ),
                    tag,
                    print_func=None,
                )

                func_globals = {
                    &quot;__jid__&quot;: jid,
                    &quot;__user__&quot;: salt.utils.user.get_user(),
                    &quot;__tag__&quot;: tag,
                    &quot;__jid_event__&quot;: weakref.proxy(namespaced_event),
                }
                self_functions = copy.copy(self.functions)
                salt.utils.lazy.verify_fun(self_functions, func)

                # Inject some useful globals to *all* the function's global
                # namespace only once per module-- not per func
                completed_funcs = []

                for mod_name in self_functions.keys():
                    if &quot;.&quot; not in mod_name:
                        continue
                    mod, _ = mod_name.split(&quot;.&quot;, 1)
                    if mod in completed_funcs:
                        continue
                    completed_funcs.append(mod)
                    for global_key, value in func_globals.items():
                        self.functions[mod_name].__globals__[global_key] = value

            self.functions.pack[&quot;__context__&quot;][&quot;retcode&quot;] = 0

            ret[&quot;return&quot;] = self.functions[func](*args, **kwargs)

            if not self.standalone:
                # runners do not provide retcode
                if &quot;retcode&quot; in self.functions.pack[&quot;__context__&quot;]:
                    ret[&quot;retcode&quot;] = self.functions.pack[&quot;__context__&quot;][&quot;retcode&quot;]

                ret[&quot;success&quot;] = True

                if data_returner or self.schedule_returner:
                    if &quot;return_config&quot; in data:
                        ret[&quot;ret_config&quot;] = data[&quot;return_config&quot;]
                    if &quot;return_kwargs&quot; in data:
                        ret[&quot;ret_kwargs&quot;] = data[&quot;return_kwargs&quot;]
                    rets = []
                    for returner in [data_returner, self.schedule_returner]:
                        if isinstance(returner, str):
                            rets.append(returner)
                        elif isinstance(returner, list):
                            rets.extend(returner)
                    # simple de-duplication with order retained
                    for returner in OrderedDict.fromkeys(rets):
                        ret_str = &quot;{}.returner&quot;.format(returner)
                        if ret_str in self.returners:
                            self.returners[ret_str](ret)
                        else:
                            log.info(
                                &quot;Job %s using invalid returner: %s. Ignoring.&quot;,
                                func,
                                returner,
                            )

        except Exception:  # pylint: disable=broad-except
            log.exception(&quot;Unhandled exception running %s&quot;, ret[&quot;fun&quot;])
            # Although catch-all exception handlers are bad, the exception here
            # is to let the exception bubble up to the top of the thread context,
            # where the thread will die silently, which is worse.
            if &quot;return&quot; not in ret:
                ret[&quot;return&quot;] = &quot;Unhandled exception running {}&quot;.format(ret[&quot;fun&quot;])
            ret[&quot;success&quot;] = False
            ret[&quot;retcode&quot;] = 254
        finally:
            # Only attempt to return data to the master if the scheduled job is running
            # on a master itself or a minion.
            if &quot;__role&quot; in self.opts and self.opts[&quot;__role&quot;] in (&quot;master&quot;, &quot;minion&quot;):
                # The 'return_job' option is enabled by default even if not set
                if &quot;return_job&quot; in data and not data[&quot;return_job&quot;]:
                    pass
                else:
                    # Send back to master so the job is included in the job list
                    mret = ret.copy()
                    # No returners defined, so we're only sending back to the master
                    if not data_returner and not self.schedule_returner:
                        mret[&quot;jid&quot;] = &quot;req&quot;
                        if data.get(&quot;return_job&quot;) == &quot;nocache&quot;:
                            # overwrite 'req' to signal to master that
                            # this job shouldn't be stored
                            mret[&quot;jid&quot;] = &quot;nocache&quot;
                    load = {&quot;cmd&quot;: &quot;_return&quot;, &quot;id&quot;: self.opts[&quot;id&quot;]}
                    for key, value in mret.items():
<A NAME="0"></A>                        load[key] = value

                    if &quot;__role&quot; in self.opts and self.opts[&quot;__role&quot;] == &quot;minion&quot;:
                        event = salt.utils.event.get_event<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match284716-0.html#0',2,'match284716-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(
                            &quot;minion&quot;, opts=self.opts, listen=False
                        )
                    elif &quot;__role&quot; in self.opts and self.opts[&quot;__role&quot;] == &quot;master&quot;:
                        event = salt.utils.event.get_master_event(
                            self.</B></FONT>opts, self.opts[&quot;sock_dir&quot;]
                        )
                    try:
                        event.fire_event(load, &quot;__schedule_return&quot;)
                    except Exception as exc:  # pylint: disable=broad-except
                        log.exception(
                            &quot;Unhandled exception firing __schedule_return event&quot;
                        )
                    finally:
                        event.destroy()

            if self.opts[&quot;__role&quot;] == &quot;master&quot;:
                namespaced_event.destroy()

            if not self.standalone:
                log.debug(&quot;schedule.handle_func: Removing %s&quot;, proc_fn)

                try:
                    os.unlink(proc_fn)
                except OSError as exc:
                    if exc.errno == errno.EEXIST or exc.errno == errno.ENOENT:
                        # EEXIST and ENOENT are OK because the file is gone and that's what
                        # we wanted
                        pass
                    else:
                        log.error(&quot;Failed to delete '%s': %s&quot;, proc_fn, exc.errno)
                        # Otherwise, failing to delete this file is not something
                        # we can cleanly handle.
                        raise
                finally:
                    if multiprocessing_enabled:
                        # Let's make sure we exit the process!
                        sys.exit(salt.defaults.exitcodes.EX_GENERIC)

    def eval(self, now=None):
        &quot;&quot;&quot;
        Evaluate and execute the schedule

        :param datetime now: Override current time with a datetime object instance``

        &quot;&quot;&quot;

        log.trace(&quot;==== evaluating schedule now %s =====&quot;, now)

        jids = []
        loop_interval = self.opts[&quot;loop_interval&quot;]
        if not isinstance(loop_interval, datetime.timedelta):
            loop_interval = datetime.timedelta(seconds=loop_interval)

        def _splay(splaytime):
            &quot;&quot;&quot;
            Calculate splaytime
            &quot;&quot;&quot;
            splay_ = None
            if isinstance(splaytime, dict):
                if splaytime[&quot;end&quot;] &gt;= splaytime[&quot;start&quot;]:
                    splay_ = random.randint(splaytime[&quot;start&quot;], splaytime[&quot;end&quot;])
                else:
                    log.error(
                        &quot;schedule.handle_func: Invalid Splay, &quot;
                        &quot;end must be larger than start. Ignoring splay.&quot;
                    )
            else:
                splay_ = random.randint(1, splaytime)
            return splay_

        def _handle_time_elements(data):
            &quot;&quot;&quot;
            Handle schedule item with time elements
            seconds, minutes, hours, days
            &quot;&quot;&quot;
            if &quot;_seconds&quot; not in data:
                interval = int(data.get(&quot;seconds&quot;, 0))
                interval += int(data.get(&quot;minutes&quot;, 0)) * 60
                interval += int(data.get(&quot;hours&quot;, 0)) * 3600
                interval += int(data.get(&quot;days&quot;, 0)) * 86400

                data[&quot;_seconds&quot;] = interval

                if not data[&quot;_next_fire_time&quot;]:
                    data[&quot;_next_fire_time&quot;] = now + datetime.timedelta(
                        seconds=data[&quot;_seconds&quot;]
                    )

                if interval &lt; self.loop_interval:
                    self.loop_interval = interval

                data[&quot;_next_scheduled_fire_time&quot;] = now + datetime.timedelta(
                    seconds=data[&quot;_seconds&quot;]
                )

        def _handle_once(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with once
            &quot;&quot;&quot;
            if data[&quot;_next_fire_time&quot;]:
                if (
                    data[&quot;_next_fire_time&quot;] &lt; now - loop_interval
                    or data[&quot;_next_fire_time&quot;] &gt; now
                    and not data[&quot;_splay&quot;]
                ):
                    data[&quot;_continue&quot;] = True

            if not data[&quot;_next_fire_time&quot;] and not data[&quot;_splay&quot;]:
                once = data[&quot;once&quot;]
                if not isinstance(once, datetime.datetime):
                    once_fmt = data.get(&quot;once_fmt&quot;, &quot;%Y-%m-%dT%H:%M:%S&quot;)
                    try:
                        once = datetime.datetime.strptime(data[&quot;once&quot;], once_fmt)
                    except (TypeError, ValueError):
                        data[&quot;_error&quot;] = (
                            &quot;Date string could not &quot;
                            &quot;be parsed: {}, {}. &quot;
                            &quot;Ignoring job {}.&quot;.format(
                                data[&quot;once&quot;], once_fmt, data[&quot;name&quot;]
                            )
                        )
                        log.error(data[&quot;_error&quot;])
                        return
                data[&quot;_next_fire_time&quot;] = once
                data[&quot;_next_scheduled_fire_time&quot;] = once
                # If _next_fire_time is less than now, continue
                if once &lt; now - loop_interval:
                    data[&quot;_continue&quot;] = True

        def _handle_when(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with when
            &quot;&quot;&quot;
            if not _WHEN_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-dateutil. Ignoring job {}.&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            if not isinstance(data[&quot;when&quot;], list):
                _when_data = [data[&quot;when&quot;]]
            else:
                _when_data = data[&quot;when&quot;]

            _when = []
            for i in _when_data:
                if (
                    &quot;pillar&quot; in self.opts
                    and &quot;whens&quot; in self.opts[&quot;pillar&quot;]
                    and i in self.opts[&quot;pillar&quot;][&quot;whens&quot;]
                ):
                    if not isinstance(self.opts[&quot;pillar&quot;][&quot;whens&quot;], dict):
                        data[&quot;_error&quot;] = (
                            'Pillar item &quot;whens&quot; '
                            &quot;must be a dict. &quot;
                            &quot;Ignoring job {}.&quot;.format(data[&quot;name&quot;])
                        )
                        log.error(data[&quot;_error&quot;])
                        return
                    when_ = self.opts[&quot;pillar&quot;][&quot;whens&quot;][i]
                elif (
                    &quot;whens&quot; in self.opts[&quot;grains&quot;] and i in self.opts[&quot;grains&quot;][&quot;whens&quot;]
                ):
                    if not isinstance(self.opts[&quot;grains&quot;][&quot;whens&quot;], dict):
                        data[
                            &quot;_error&quot;
                        ] = 'Grain &quot;whens&quot; must be a dict. Ignoring job {}.'.format(
                            data[&quot;name&quot;]
                        )
                        log.error(data[&quot;_error&quot;])
                        return
                    when_ = self.opts[&quot;grains&quot;][&quot;whens&quot;][i]
                else:
                    when_ = i

                if not isinstance(when_, datetime.datetime):
                    try:
                        when_ = dateutil_parser.parse(when_)
                    except ValueError:
                        data[
                            &quot;_error&quot;
                        ] = &quot;Invalid date string {}. Ignoring job {}.&quot;.format(
                            i, data[&quot;name&quot;]
                        )
                        log.error(data[&quot;_error&quot;])
                        return

                _when.append(when_)

            if data[&quot;_splay&quot;]:
                _when.append(data[&quot;_splay&quot;])

            # Sort the list of &quot;whens&quot; from earlier to later schedules
            _when.sort()

            # Copy the list so we can loop through it
            for i in copy.deepcopy(_when):
                if len(_when) &gt; 1:
                    if i &lt; now - loop_interval:
                        # Remove all missed schedules except the latest one.
                        # We need it to detect if it was triggered previously.
                        _when.remove(i)

            if _when:
                # Grab the first element, which is the next run time or
                # last scheduled time in the past.
                when = _when[0]

                if (
                    when &lt; now - loop_interval
                    and not data.get(&quot;_run&quot;, False)
                    and not run
                    and not data[&quot;_splay&quot;]
                ):
                    data[&quot;_next_fire_time&quot;] = None
                    data[&quot;_continue&quot;] = True
                    return

                if &quot;_run&quot; not in data:
                    # Prevent run of jobs from the past
                    data[&quot;_run&quot;] = bool(when &gt;= now - loop_interval)

                if not data[&quot;_next_fire_time&quot;]:
                    data[&quot;_next_fire_time&quot;] = when

                data[&quot;_next_scheduled_fire_time&quot;] = when

                if data[&quot;_next_fire_time&quot;] &lt; when and not run and not data[&quot;_run&quot;]:
                    data[&quot;_next_fire_time&quot;] = when
                    data[&quot;_run&quot;] = True

            elif not data.get(&quot;_run&quot;, False):
                data[&quot;_next_fire_time&quot;] = None
                data[&quot;_continue&quot;] = True

        def _handle_cron(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with cron
            &quot;&quot;&quot;
            if not _CRON_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-croniter. Ignoring job {}.&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            if data[&quot;_next_fire_time&quot;] is None:
                # Get next time frame for a &quot;cron&quot; job if it has been never
                # executed before or already executed in the past.
                try:
                    data[&quot;_next_fire_time&quot;] = croniter.croniter(
                        data[&quot;cron&quot;], now
                    ).get_next(datetime.datetime)
                    data[&quot;_next_scheduled_fire_time&quot;] = croniter.croniter(
                        data[&quot;cron&quot;], now
                    ).get_next(datetime.datetime)
                except (ValueError, KeyError):
                    data[&quot;_error&quot;] = &quot;Invalid cron string. Ignoring job {}.&quot;.format(
                        data[&quot;name&quot;]
                    )
                    log.error(data[&quot;_error&quot;])
                    return

                # If next job run is scheduled more than 1 minute ahead and
                # configured loop interval is longer than that, we should
                # shorten it to get our job executed closer to the beginning
                # of desired time.
                interval = (now - data[&quot;_next_fire_time&quot;]).total_seconds()
                if interval &gt;= 60 and interval &lt; self.loop_interval:
                    self.loop_interval = interval

        def _handle_run_explicit(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with run_explicit
            &quot;&quot;&quot;
            _run_explicit = []
            for _run_time in data[&quot;run_explicit&quot;]:
                if isinstance(_run_time, datetime.datetime):
                    _run_explicit.append(_run_time)
                else:
                    _run_explicit.append(
                        datetime.datetime.strptime(
                            _run_time[&quot;time&quot;], _run_time[&quot;time_fmt&quot;]
                        )
                    )
            data[&quot;run&quot;] = False

            # Copy the list so we can loop through it
            for i in copy.deepcopy(_run_explicit):
                if len(_run_explicit) &gt; 1:
                    if i &lt; now - loop_interval:
                        _run_explicit.remove(i)

            if _run_explicit:
                if _run_explicit[0] &lt;= now &lt; _run_explicit[0] + loop_interval:
                    data[&quot;run&quot;] = True
                    data[&quot;_next_fire_time&quot;] = _run_explicit[0]

        def _handle_skip_explicit(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with skip_explicit
            &quot;&quot;&quot;
            data[&quot;run&quot;] = False

            _skip_explicit = []
            for _skip_time in data[&quot;skip_explicit&quot;]:
                if isinstance(_skip_time, datetime.datetime):
                    _skip_explicit.append(_skip_time)
                else:
                    _skip_explicit.append(
                        datetime.datetime.strptime(
                            _skip_time[&quot;time&quot;], _skip_time[&quot;time_fmt&quot;]
                        )
                    )

            # Copy the list so we can loop through it
            for i in copy.deepcopy(_skip_explicit):
                if i &lt; now - loop_interval:
                    _skip_explicit.remove(i)

            if _skip_explicit:
                if _skip_explicit[0] &lt;= now &lt;= (_skip_explicit[0] + loop_interval):
                    if self.skip_function:
                        data[&quot;run&quot;] = True
                        data[&quot;func&quot;] = self.skip_function
                    else:
                        data[&quot;_skip_reason&quot;] = &quot;skip_explicit&quot;
                        data[&quot;_skipped_time&quot;] = now
                        data[&quot;_skipped&quot;] = True
                        data[&quot;run&quot;] = False
            else:
                data[&quot;run&quot;] = True

        def _handle_skip_during_range(data, loop_interval):
            &quot;&quot;&quot;
            Handle schedule item with skip_explicit
            &quot;&quot;&quot;
            if not _RANGE_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-dateutil. Ignoring job {}.&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            if not isinstance(data[&quot;skip_during_range&quot;], dict):
                data[&quot;_error&quot;] = (
                    &quot;schedule.handle_func: Invalid, range &quot;
                    &quot;must be specified as a dictionary. &quot;
                    &quot;Ignoring job {}.&quot;.format(data[&quot;name&quot;])
                )
                log.error(data[&quot;_error&quot;])
                return

            start = data[&quot;skip_during_range&quot;][&quot;start&quot;]
            end = data[&quot;skip_during_range&quot;][&quot;end&quot;]
            if not isinstance(start, datetime.datetime):
                try:
                    start = dateutil_parser.parse(start)
                except ValueError:
                    data[&quot;_error&quot;] = (
                        &quot;Invalid date string for start in &quot;
                        &quot;skip_during_range. Ignoring &quot;
                        &quot;job {}.&quot;.format(data[&quot;name&quot;])
                    )
                    log.error(data[&quot;_error&quot;])
                    return

            if not isinstance(end, datetime.datetime):
                try:
                    end = dateutil_parser.parse(end)
                except ValueError:
                    data[&quot;_error&quot;] = (
                        &quot;Invalid date string for end in &quot;
                        &quot;skip_during_range. Ignoring &quot;
                        &quot;job {}.&quot;.format(data[&quot;name&quot;])
                    )
                    log.error(data[&quot;_error&quot;])
                    return

            # Check to see if we should run the job immediately
            # after the skip_during_range is over
            if &quot;run_after_skip_range&quot; in data and data[&quot;run_after_skip_range&quot;]:
                if &quot;run_explicit&quot; not in data:
                    data[&quot;run_explicit&quot;] = []
                # Add a run_explicit for immediately after the
                # skip_during_range ends
                _run_immediate = (end + loop_interval).strftime(&quot;%Y-%m-%dT%H:%M:%S&quot;)
                if _run_immediate not in data[&quot;run_explicit&quot;]:
                    data[&quot;run_explicit&quot;].append(
                        {&quot;time&quot;: _run_immediate, &quot;time_fmt&quot;: &quot;%Y-%m-%dT%H:%M:%S&quot;}
                    )

            if end &gt; start:
                if start &lt;= now &lt;= end:
                    if self.skip_function:
                        data[&quot;run&quot;] = True
                        data[&quot;func&quot;] = self.skip_function
                    else:
                        data[&quot;_skip_reason&quot;] = &quot;in_skip_range&quot;
                        data[&quot;_skipped_time&quot;] = now
                        data[&quot;_skipped&quot;] = True
                        data[&quot;run&quot;] = False
                else:
                    data[&quot;run&quot;] = True
            else:
                data[&quot;_error&quot;] = (
                    &quot;schedule.handle_func: Invalid &quot;
                    &quot;range, end must be larger than &quot;
                    &quot;start. Ignoring job {}.&quot;.format(data[&quot;name&quot;])
                )
                log.error(data[&quot;_error&quot;])

        def _handle_range(data):
            &quot;&quot;&quot;
            Handle schedule item with skip_explicit
            &quot;&quot;&quot;
            if not _RANGE_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-dateutil. Ignoring job {}&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            if not isinstance(data[&quot;range&quot;], dict):
                data[&quot;_error&quot;] = (
                    &quot;schedule.handle_func: Invalid, range &quot;
                    &quot;must be specified as a dictionary.&quot;
                    &quot;Ignoring job {}.&quot;.format(data[&quot;name&quot;])
                )
                log.error(data[&quot;_error&quot;])
                return

            start = data[&quot;range&quot;][&quot;start&quot;]
            end = data[&quot;range&quot;][&quot;end&quot;]
            if not isinstance(start, datetime.datetime):
                try:
                    start = dateutil_parser.parse(start)
                except ValueError:
                    data[
                        &quot;_error&quot;
                    ] = &quot;Invalid date string for start. Ignoring job {}.&quot;.format(
                        data[&quot;name&quot;]
                    )
                    log.error(data[&quot;_error&quot;])
                    return

            if not isinstance(end, datetime.datetime):
                try:
                    end = dateutil_parser.parse(end)
                except ValueError:
                    data[
                        &quot;_error&quot;
                    ] = &quot;Invalid date string for end. Ignoring job {}.&quot;.format(
                        data[&quot;name&quot;]
                    )
                    log.error(data[&quot;_error&quot;])
                    return

            if end &gt; start:
                if &quot;invert&quot; in data[&quot;range&quot;] and data[&quot;range&quot;][&quot;invert&quot;]:
                    if now &lt;= start or now &gt;= end:
                        data[&quot;run&quot;] = True
                    else:
                        data[&quot;_skip_reason&quot;] = &quot;in_skip_range&quot;
                        data[&quot;run&quot;] = False
                else:
                    if start &lt;= now &lt;= end:
                        data[&quot;run&quot;] = True
                    else:
                        if self.skip_function:
                            data[&quot;run&quot;] = True
                            data[&quot;func&quot;] = self.skip_function
                        else:
                            data[&quot;_skip_reason&quot;] = &quot;not_in_range&quot;
                            data[&quot;run&quot;] = False
            else:
                data[&quot;_error&quot;] = (
                    &quot;schedule.handle_func: Invalid &quot;
                    &quot;range, end must be larger &quot;
                    &quot;than start. Ignoring job {}.&quot;.format(data[&quot;name&quot;])
                )
                log.error(data[&quot;_error&quot;])

        def _handle_after(data):
            &quot;&quot;&quot;
            Handle schedule item with after
            &quot;&quot;&quot;
            if not _WHEN_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-dateutil. Ignoring job {}&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            after = data[&quot;after&quot;]
            if not isinstance(after, datetime.datetime):
                after = dateutil_parser.parse(after)

            if after &gt;= now:
                log.debug(&quot;After time has not passed skipping job: %s.&quot;, data[&quot;name&quot;])
                data[&quot;_skip_reason&quot;] = &quot;after_not_passed&quot;
                data[&quot;_skipped_time&quot;] = now
                data[&quot;_skipped&quot;] = True
                data[&quot;run&quot;] = False
            else:
                data[&quot;run&quot;] = True

        def _handle_until(data):
            &quot;&quot;&quot;
            Handle schedule item with until
            &quot;&quot;&quot;
            if not _WHEN_SUPPORTED:
                data[&quot;_error&quot;] = &quot;Missing python-dateutil. Ignoring job {}&quot;.format(
                    data[&quot;name&quot;]
                )
                log.error(data[&quot;_error&quot;])
                return

            until = data[&quot;until&quot;]
            if not isinstance(until, datetime.datetime):
                until = dateutil_parser.parse(until)

            if until &lt;= now:
                log.debug(&quot;Until time has passed skipping job: %s.&quot;, data[&quot;name&quot;])
                data[&quot;_skip_reason&quot;] = &quot;until_passed&quot;
                data[&quot;_skipped_time&quot;] = now
                data[&quot;_skipped&quot;] = True
                data[&quot;run&quot;] = False
            else:
                data[&quot;run&quot;] = True

        def _chop_ms(dt):
            &quot;&quot;&quot;
            Remove the microseconds from a datetime object
            &quot;&quot;&quot;
            return dt - datetime.timedelta(microseconds=dt.microsecond)

        schedule = self._get_schedule()
        if not isinstance(schedule, dict):
            raise ValueError(&quot;Schedule must be of type dict.&quot;)
        if &quot;skip_function&quot; in schedule:
            self.skip_function = schedule[&quot;skip_function&quot;]
        if &quot;skip_during_range&quot; in schedule:
            self.skip_during_range = schedule[&quot;skip_during_range&quot;]
        if &quot;enabled&quot; in schedule:
            self.enabled = schedule[&quot;enabled&quot;]
        if &quot;splay&quot; in schedule:
            self.splay = schedule[&quot;splay&quot;]

        _hidden = [&quot;enabled&quot;, &quot;skip_function&quot;, &quot;skip_during_range&quot;, &quot;splay&quot;]
        for job, data in schedule.items():

            # Skip anything that is a global setting
            if job in _hidden:
                continue

            # Clear these out between runs
            for item in [
                &quot;_continue&quot;,
                &quot;_error&quot;,
                &quot;_enabled&quot;,
                &quot;_skipped&quot;,
                &quot;_skip_reason&quot;,
                &quot;_skipped_time&quot;,
            ]:
                if item in data:
                    del data[item]
            run = False

            if &quot;name&quot; in data:
                job_name = data[&quot;name&quot;]
            else:
                job_name = data[&quot;name&quot;] = job

            if not isinstance(data, dict):
                log.error(
                    'Scheduled job &quot;%s&quot; should have a dict value, not %s',
                    job_name,
                    type(data),
                )
                continue

            if &quot;function&quot; in data:
                func = data[&quot;function&quot;]
            elif &quot;func&quot; in data:
                func = data[&quot;func&quot;]
            elif &quot;fun&quot; in data:
                func = data[&quot;fun&quot;]
            else:
                func = None

            if func not in self.functions:
                log.info(&quot;Invalid function: %s in scheduled job %s.&quot;, func, job_name)

            if &quot;_next_fire_time&quot; not in data:
                data[&quot;_next_fire_time&quot;] = None

            if &quot;_splay&quot; not in data:
                data[&quot;_splay&quot;] = None

            if (
                &quot;run_on_start&quot; in data
                and data[&quot;run_on_start&quot;]
                and &quot;_run_on_start&quot; not in data
            ):
                data[&quot;_run_on_start&quot;] = True

            if not now:
                now = datetime.datetime.now()

            # Used for quick lookups when detecting invalid option
            # combinations.
            schedule_keys = set(data.keys())

            time_elements = (&quot;seconds&quot;, &quot;minutes&quot;, &quot;hours&quot;, &quot;days&quot;)
            scheduling_elements = (&quot;when&quot;, &quot;cron&quot;, &quot;once&quot;)

            invalid_sched_combos = [
                set(i) for i in itertools.combinations(scheduling_elements, 2)
            ]

            if any(i &lt;= schedule_keys for i in invalid_sched_combos):
                log.error(
                    'Unable to use &quot;%s&quot; options together. Ignoring.',
                    '&quot;, &quot;'.join(scheduling_elements),
                )
                continue

            invalid_time_combos = []
            for item in scheduling_elements:
                all_items = itertools.chain([item], time_elements)
                invalid_time_combos.append(set(itertools.combinations(all_items, 2)))

            if any(set(x) &lt;= schedule_keys for x in invalid_time_combos):
                log.error(
                    'Unable to use &quot;%s&quot; with &quot;%s&quot; options. Ignoring',
                    '&quot;, &quot;'.join(time_elements),
                    '&quot;, &quot;'.join(scheduling_elements),
                )
                continue

            if &quot;run_explicit&quot; in data:
                _handle_run_explicit(data, loop_interval)
                run = data[&quot;run&quot;]

            if True in [True for item in time_elements if item in data]:
                _handle_time_elements(data)
            elif &quot;once&quot; in data:
                _handle_once(data, loop_interval)
            elif &quot;when&quot; in data:
                _handle_when(data, loop_interval)
            elif &quot;cron&quot; in data:
                _handle_cron(data, loop_interval)
            else:
                continue

            # Something told us to continue, so we continue
            if &quot;_continue&quot; in data and data[&quot;_continue&quot;]:
                continue

            # An error occurred so we bail out
            if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                continue

            seconds = int(
                (_chop_ms(data[&quot;_next_fire_time&quot;]) - _chop_ms(now)).total_seconds()
            )

            # If there is no job specific splay available,
            # grab the global which defaults to None.
            if &quot;splay&quot; not in data:
                data[&quot;splay&quot;] = self.splay

            if &quot;splay&quot; in data and data[&quot;splay&quot;]:
                # Got &quot;splay&quot; configured, make decision to run a job based on that
                if not data[&quot;_splay&quot;]:
                    # Try to add &quot;splay&quot; time only if next job fire time is
                    # still in the future. We should trigger job run
                    # immediately otherwise.
                    splay = _splay(data[&quot;splay&quot;])
                    if now &lt; data[&quot;_next_fire_time&quot;] + datetime.timedelta(
                        seconds=splay
                    ):
                        log.debug(
                            &quot;schedule.handle_func: Adding splay of &quot;
                            &quot;%s seconds to next run.&quot;,
                            splay,
                        )
                        data[&quot;_splay&quot;] = data[&quot;_next_fire_time&quot;] + datetime.timedelta(
                            seconds=splay
                        )
                        if &quot;when&quot; in data:
                            data[&quot;_run&quot;] = True
                    else:
                        run = True

                if data[&quot;_splay&quot;]:
                    # The &quot;splay&quot; configuration has been already processed, just use it
                    seconds = (data[&quot;_splay&quot;] - now).total_seconds()
                    if &quot;when&quot; in data:
                        data[&quot;_next_fire_time&quot;] = data[&quot;_splay&quot;]

            if &quot;_seconds&quot; in data:
                if seconds &lt;= 0:
                    run = True
            elif &quot;when&quot; in data and data[&quot;_run&quot;]:
                if (
                    data[&quot;_next_fire_time&quot;]
                    &lt;= now
                    &lt;= (data[&quot;_next_fire_time&quot;] + loop_interval)
                ):
                    data[&quot;_run&quot;] = False
                    run = True
            elif &quot;cron&quot; in data:
                # Reset next scheduled time because it is in the past now,
                # and we should trigger the job run, then wait for the next one.
                if seconds &lt;= 0:
                    data[&quot;_next_fire_time&quot;] = None
                    run = True
            elif &quot;once&quot; in data:
                if (
                    data[&quot;_next_fire_time&quot;]
                    &lt;= now
                    &lt;= (data[&quot;_next_fire_time&quot;] + loop_interval)
                ):
                    run = True
            elif seconds == 0:
                run = True

            if &quot;_run_on_start&quot; in data and data[&quot;_run_on_start&quot;]:
                run = True
                data[&quot;_run_on_start&quot;] = False
            elif run:
                if &quot;range&quot; in data:
                    _handle_range(data)

                    # An error occurred so we bail out
                    if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                        continue

                    run = data[&quot;run&quot;]
                    # Override the functiton if passed back
                    if &quot;func&quot; in data:
                        func = data[&quot;func&quot;]

                # If there is no job specific skip_during_range available,
                # grab the global which defaults to None.
                if &quot;skip_during_range&quot; not in data and self.skip_during_range:
                    data[&quot;skip_during_range&quot;] = self.skip_during_range

                if &quot;skip_during_range&quot; in data and data[&quot;skip_during_range&quot;]:
                    _handle_skip_during_range(data, loop_interval)

                    # An error occurred so we bail out
                    if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                        continue

                    run = data[&quot;run&quot;]
                    # Override the functiton if passed back
                    if &quot;func&quot; in data:
                        func = data[&quot;func&quot;]

                if &quot;skip_explicit&quot; in data:
                    _handle_skip_explicit(data, loop_interval)

                    # An error occurred so we bail out
                    if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                        continue

                    run = data[&quot;run&quot;]
                    # Override the functiton if passed back
                    if &quot;func&quot; in data:
                        func = data[&quot;func&quot;]

                if &quot;until&quot; in data:
                    _handle_until(data)

                    # An error occurred so we bail out
                    if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                        continue

                    run = data[&quot;run&quot;]

                if &quot;after&quot; in data:
                    _handle_after(data)

                    # An error occurred so we bail out
                    if &quot;_error&quot; in data and data[&quot;_error&quot;]:
                        continue

                    run = data[&quot;run&quot;]

            # If the job item has continue, then we set run to False
            # so the job does not run but we still get the important
            # information calculated, eg. _next_fire_time
            if &quot;_continue&quot; in data and data[&quot;_continue&quot;]:
                run = False

            # If globally disabled or job
            # is diabled skip the job
            if not self.enabled or not data.get(&quot;enabled&quot;, True):
                log.trace(&quot;Job: %s is disabled&quot;, job_name)
                data[&quot;_skip_reason&quot;] = &quot;disabled&quot;
                data[&quot;_skipped_time&quot;] = now
                data[&quot;_skipped&quot;] = True
                run = False

            miss_msg = &quot;&quot;
            if seconds &lt; 0:
                miss_msg = &quot; (runtime missed by {} seconds)&quot;.format(abs(seconds))

            try:
                if run:
                    if &quot;jid_include&quot; not in data or data[&quot;jid_include&quot;]:
                        data[&quot;jid_include&quot;] = True
                        log.debug(
                            &quot;schedule: Job %s was scheduled with jid_include, &quot;
                            &quot;adding to cache (jid_include defaults to True)&quot;,
                            job_name,
                        )
                        if &quot;maxrunning&quot; in data:
                            log.debug(
                                &quot;schedule: Job %s was scheduled with a max &quot;
                                &quot;number of %s&quot;,
                                job_name,
                                data[&quot;maxrunning&quot;],
                            )
                        else:
                            log.info(
                                &quot;schedule: maxrunning parameter was not specified for &quot;
                                &quot;job %s, defaulting to 1.&quot;,
                                job_name,
                            )
                            data[&quot;maxrunning&quot;] = 1

                    if not self.standalone:
                        data[&quot;run&quot;] = run
                        data = self._check_max_running(func, data, self.opts, now)
                        run = data[&quot;run&quot;]

                # Check run again, just in case _check_max_running
                # set run to False
                if run:
                    jid = salt.utils.jid.gen_jid(self.opts)
                    jids.append(jid)
                    log.info(
                        &quot;Running scheduled job: %s%s with jid %s&quot;,
                        job_name,
                        miss_msg,
                        jid,
                    )
                    self._run_job(func, data, jid=jid)

            finally:
                # Only set _last_run if the job ran
                if run:
                    data[&quot;_last_run&quot;] = now
                    data[&quot;_splay&quot;] = None
                if &quot;_seconds&quot; in data:
                    if self.standalone:
                        data[&quot;_next_fire_time&quot;] = now + datetime.timedelta(
                            seconds=data[&quot;_seconds&quot;]
                        )
                    elif &quot;_skipped&quot; in data and data[&quot;_skipped&quot;]:
                        data[&quot;_next_fire_time&quot;] = now + datetime.timedelta(
                            seconds=data[&quot;_seconds&quot;]
                        )
                    elif run:
                        data[&quot;_next_fire_time&quot;] = now + datetime.timedelta(
                            seconds=data[&quot;_seconds&quot;]
                        )
        return jids

    def _run_job(self, func, data, jid=None):
        job_dry_run = data.get(&quot;dry_run&quot;, False)
        if job_dry_run:
            log.debug(&quot;Job %s has 'dry_run' set to True. Not running it.&quot;, data[&quot;name&quot;])
            return

        multiprocessing_enabled = self.opts.get(&quot;multiprocessing&quot;, True)
        run_schedule_jobs_in_background = self.opts.get(
            &quot;run_schedule_jobs_in_background&quot;, True
        )

        if run_schedule_jobs_in_background is False:
            # Explicitly pass False for multiprocessing_enabled
            self.handle_func(False, func, data, jid)
            return

        if multiprocessing_enabled and salt.utils.platform.is_windows():
            # Temporarily stash our function references.
            # You can't pickle function references, and pickling is
            # required when spawning new processes on Windows.
            functions = self.functions
            self.functions = {}
            returners = self.returners
            self.returners = {}
            utils = self.utils
            self.utils = {}

        try:
            if multiprocessing_enabled:
                thread_cls = salt.utils.process.SignalHandlingProcess
            else:
                thread_cls = threading.Thread

            name = &quot;Schedule(name={}, jid={})&quot;.format(data[&quot;name&quot;], jid)
            if multiprocessing_enabled:
                with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
                    # Reset current signals before starting the process in
                    # order not to inherit the current signal handlers
                    proc = thread_cls(
                        target=self.handle_func,
                        args=(multiprocessing_enabled, func, data, jid),
                        name=name,
                    )
                    proc.start()
                    self._subprocess_list.add(proc)
            else:
                proc = thread_cls(
                    target=self.handle_func,
                    args=(multiprocessing_enabled, func, data, jid),
                    name=name,
                )
                proc.start()
                self._subprocess_list.add(proc)
        finally:
            if multiprocessing_enabled and salt.utils.platform.is_windows():
                # Restore our function references.
                self.functions = functions
                self.returners = returners
                self.utils = utils

    def cleanup_subprocesses(self):
        self._subprocess_list.cleanup()


def clean_proc_dir(opts):

    &quot;&quot;&quot;
    Loop through jid files in the minion proc directory (default /var/cache/salt/minion/proc)
    and remove any that refer to processes that no longer exist
    &quot;&quot;&quot;

    for basefilename in os.listdir(salt.minion.get_proc_dir(opts[&quot;cachedir&quot;])):
        fn_ = os.path.join(salt.minion.get_proc_dir(opts[&quot;cachedir&quot;]), basefilename)
        with salt.utils.files.fopen(fn_, &quot;rb&quot;) as fp_:
            job = None
            try:
                job = salt.payload.load(fp_)
            except Exception:  # pylint: disable=broad-except
                # It's corrupted
                # Windows cannot delete an open file
                if salt.utils.platform.is_windows():
                    fp_.close()
                try:
                    os.unlink(fn_)
                    continue
                except OSError:
                    continue
            log.debug(
                &quot;schedule.clean_proc_dir: checking job %s for process existence&quot;, job
            )
            if job is not None and &quot;pid&quot; in job:
                if salt.utils.process.os_is_running(job[&quot;pid&quot;]):
                    log.debug(
                        &quot;schedule.clean_proc_dir: Cleaning proc dir, pid %s &quot;
                        &quot;still exists.&quot;,
                        job[&quot;pid&quot;],
                    )
                else:
                    # Windows cannot delete an open file
                    if salt.utils.platform.is_windows():
                        fp_.close()
                    # Maybe the file is already gone
                    try:
                        os.unlink(fn_)
                    except OSError:
                        pass
</PRE>
</div>
  </div>
</body>
</html>
