<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_libcloud_storage.py &amp; web_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_libcloud_storage.py &amp; web_test.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_libcloud_storage.py (23.026316%)<th>web_test.py (0.65592206%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(99-111)<td><a href="#" name="0">(1905-1915)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(90-95)<td><a href="#" name="1">(1004-1010)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_libcloud_storage.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.libcloud_storage as libcloud_storage
2 from tests.support.mixins import LoaderModuleMockMixin
3 from tests.support.mock import MagicMock, patch
4 from tests.support.unit import TestCase, skipIf
5 try:
6     from libcloud.storage.base import Container, BaseDriver, Object
7     HAS_LIBCLOUD = True
8 except ImportError:
9     HAS_LIBCLOUD = False
10 if HAS_LIBCLOUD:
11     class MockStorageDriver(BaseDriver):
12         def __init__(self):  # pylint: disable=W0231
13             self._TEST_CONTAINER = Container(
14                 name="test_container", extra={}, driver=self
15             )
16             self._TEST_OBJECT = Object(
17                 name="test_obj",
18                 size=1234,
19                 hash="123sdfsdf",
20                 extra={},
21                 meta_data={"key": "value"},
22                 container=self._TEST_CONTAINER,
23                 driver=self,
24             )
25         def list_containers(self):
26             return [self._TEST_CONTAINER]
27         def get_container(self, container_name):
28             assert container_name == "test_container"
29             return self._TEST_CONTAINER
30         def list_container_objects(self, container):
31             assert container.name == "test_container"
32             return [self._TEST_OBJECT]
33         def create_container(self, container_name):
34             assert container_name == "new_test_container"
35             return self._TEST_CONTAINER
36         def get_container_object(self, container_name, object_name):
37             assert container_name == "test_container"
38             assert object_name == "test_obj"
39             return self._TEST_OBJECT
40 else:
41     MockStorageDriver = object
42 def get_mock_driver():
43     return MockStorageDriver()
44 @skipIf(not HAS_LIBCLOUD, "No libcloud installed")
45 @patch(
46     "salt.modules.libcloud_storage._get_driver",
47     MagicMock(return_value=MockStorageDriver()),
48 )
49 class LibcloudStorageModuleTestCase(TestCase, LoaderModuleMockMixin):
50     def setup_loader_modules(self):
51         module_globals = {
52             "__salt__": {
53                 "config.option": MagicMock(
54                     return_value={"test": {"driver": "test", "key": "2orgk34kgk34g"}}
55                 )
56             }
57         }
58         if libcloud_storage.HAS_LIBCLOUD is False:
59             module_globals["sys.modules"] = {"libcloud": MagicMock()}
60         return {libcloud_storage: module_globals}
61     def test_module_creation(self):
62         client = libcloud_storage._get_driver("test")
63         self.assertFalse(client is None)
64     def test_list_containers(self):
65         containers = libcloud_storage.list_containers("test")
66         self.assertEqual(len<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(containers), 1)
67         self.assertEqual(containers[0]["name"], "test_container")
68     def test_list_container_objects(self):
69         objects = libcloud_storage.list_container_objects("test_container", "test")
70         self.assertEqual(</b></font>len(objects), 1)
71         self.assertEqual(objects[0]["size"], 1234)
72     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def test_create_container(self):
73         container = libcloud_storage.create_container("new_test_container", "test")
74         self.assertEqual(container["name"], "test_container")
75     def test_get_container(self):
76         container = libcloud_storage.get_container("test_container", "test")
77         self.assertEqual(container["name"], "test_container")
78     def test_get_container_object(self):
79         obj = libcloud_storage.get_container_object(
80             "test_container", "test_obj", "test"
81         )
82         self.assertEqual(obj[</b></font>"name"], "test_obj")
83         self.assertEqual(obj["size"], 1234)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>web_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.concurrent import Future
3 from salt.ext.tornado import gen
4 from salt.ext.tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring
5 from salt.ext.tornado.httputil import format_timestamp
6 from salt.ext.tornado.ioloop import IOLoop
7 from salt.ext.tornado.iostream import IOStream
8 from salt.ext.tornado import locale
9 from salt.ext.tornado.log import app_log, gen_log
10 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
11 from salt.ext.tornado.template import DictLoader
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
14 from salt.ext.tornado.util import ObjectDict, unicode_type, timedelta_to_seconds, PY3
15 from salt.ext.tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError, stream_request_body, Finish, removeslash, addslash, RedirectHandler as WebRedirectHandler, get_signature_key_version, GZipContentEncoding
16 import binascii
17 import contextlib
18 import copy
19 import datetime
20 import email.utils
21 import gzip
22 from io import BytesIO
23 import itertools
24 import logging
25 import os
26 import re
27 import socket
28 if PY3:
29     import urllib.parse as urllib_parse  # py3
30 else:
31     import urllib as urllib_parse  # py2
32 wsgi_safe_tests = []
33 def relpath(*a):
34     return os.path.join(os.path.dirname(__file__), *a)
35 def wsgi_safe(cls):
36     wsgi_safe_tests.append(cls)
37     return cls
38 class WebTestCase(AsyncHTTPTestCase):
39     def get_app(self):
40         self.app = Application(self.get_handlers(), **self.get_app_kwargs())
41         return self.app
42     def get_handlers(self):
43         raise NotImplementedError()
44     def get_app_kwargs(self):
45         return {}
46 class SimpleHandlerTestCase(WebTestCase):
47     def get_handlers(self):
48         return [('/', self.Handler)]
49 class HelloHandler(RequestHandler):
50     def get(self):
51         self.write('hello')
52 class CookieTestRequestHandler(RequestHandler):
53     def __init__(self, cookie_secret='0123456789', key_version=None):
54         self._cookies = {}
55         if key_version is None:
56             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret))
57         else:
58             self.application = ObjectDict(settings=dict(cookie_secret=cookie_secret,
59                                                         key_version=key_version))
60     def get_cookie(self, name):
61         return self._cookies.get(name)
62     def set_cookie(self, name, value, expires_days=None):
63         self._cookies[name] = value
64 class SecureCookieV1Test(unittest.TestCase):
65     def test_round_trip(self):
66         handler = CookieTestRequestHandler()
67         handler.set_secure_cookie('foo', b'bar', version=1)
68         self.assertEqual(handler.get_secure_cookie('foo', min_version=1),
69                          b'bar')
70     def test_cookie_tampering_future_timestamp(self):
71         handler = CookieTestRequestHandler()
72         handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),
73                                   version=1)
74         cookie = handler._cookies['foo']
75         match = re.match(br'12345678\|([0-9]+)\|([0-9a-f]+)', cookie)
76         self.assertTrue(match)
77         timestamp = match.group(1)
78         sig = match.group(2)
79         self.assertEqual(
80             _create_signature_v1(handler.application.settings["cookie_secret"],
81                                  'foo', '12345678', timestamp),
82             sig)
83         self.assertEqual(
84             _create_signature_v1(handler.application.settings["cookie_secret"],
85                                  'foo', '1234', b'5678' + timestamp),
86             sig)
87         handler._cookies['foo'] = utf8('1234|5678%s|%s' % (
88             to_basestring(timestamp), to_basestring(sig)))
89         with ExpectLog(gen_log, "Cookie timestamp in future"):
90             self.assertTrue(
91                 handler.get_secure_cookie('foo', min_version=1) is None)
92     def test_arbitrary_bytes(self):
93         handler = CookieTestRequestHandler()
94         handler.set_secure_cookie('foo', b'\xe9', version=1)
95         self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\xe9')
96 class SecureCookieV2Test(unittest.TestCase):
97     KEY_VERSIONS = {
98         0: 'ajklasdf0ojaisdf',
99         1: 'aslkjasaolwkjsdf'
100     }
101     def test_round_trip(self):
102         handler = CookieTestRequestHandler()
103         handler.set_secure_cookie('foo', b'bar', version=2)
104         self.assertEqual(handler.get_secure_cookie('foo', min_version=2), b'bar')
105     def test_key_version_roundtrip(self):
106         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
107                                            key_version=0)
108         handler.set_secure_cookie('foo', b'bar')
109         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
110     def test_key_version_roundtrip_differing_version(self):
111         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
112                                            key_version=1)
113         handler.set_secure_cookie('foo', b'bar')
114         self.assertEqual(handler.get_secure_cookie('foo'), b'bar')
115     def test_key_version_increment_version(self):
116         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
117                                            key_version=0)
118         handler.set_secure_cookie('foo', b'bar')
119         new_handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
120                                                key_version=1)
121         new_handler._cookies = handler._cookies
122         self.assertEqual(new_handler.get_secure_cookie('foo'), b'bar')
123     def test_key_version_invalidate_version(self):
124         handler = CookieTestRequestHandler(cookie_secret=self.KEY_VERSIONS,
125                                            key_version=0)
126         handler.set_secure_cookie('foo', b'bar')
127         new_key_versions = self.KEY_VERSIONS.copy()
128         new_key_versions.pop(0)
129         new_handler = CookieTestRequestHandler(cookie_secret=new_key_versions,
130                                                key_version=1)
131         new_handler._cookies = handler._cookies
132         self.assertEqual(new_handler.get_secure_cookie('foo'), None)
133 class CookieTest(WebTestCase):
134     def get_handlers(self):
135         class SetCookieHandler(RequestHandler):
136             def get(self):
137                 self.set_cookie("str", "asdf")
138                 self.set_cookie("unicode", u"qwer")
139                 self.set_cookie("bytes", b"zxcv")
140         class GetCookieHandler(RequestHandler):
141             def get(self):
142                 self.write(self.get_cookie("foo", "default"))
143         class SetCookieDomainHandler(RequestHandler):
144             def get(self):
145                 self.set_cookie("unicode_args", "blah", domain=u"foo.com",
146                                 path=u"/foo")
147         class SetCookieSpecialCharHandler(RequestHandler):
148             def get(self):
149                 self.set_cookie("equals", "a=b")
150                 self.set_cookie("semicolon", "a;b")
151                 self.set_cookie("quote", 'a"b')
152         class SetCookieOverwriteHandler(RequestHandler):
153             def get(self):
154                 self.set_cookie("a", "b", domain="example.com")
155                 self.set_cookie("c", "d", domain="example.com")
156                 self.set_cookie("a", "e")
157         class SetCookieMaxAgeHandler(RequestHandler):
158             def get(self):
159                 self.set_cookie("foo", "bar", max_age=10)
160         class SetCookieExpiresDaysHandler(RequestHandler):
161             def get(self):
162                 self.set_cookie("foo", "bar", expires_days=10)
163         class SetCookieFalsyFlags(RequestHandler):
164             def get(self):
165                 self.set_cookie("a", "1", secure=True)
166                 self.set_cookie("b", "1", secure=False)
167                 self.set_cookie("c", "1", httponly=True)
168                 self.set_cookie("d", "1", httponly=False)
169         return [("/set", SetCookieHandler),
170                 ("/get", GetCookieHandler),
171                 ("/set_domain", SetCookieDomainHandler),
172                 ("/special_char", SetCookieSpecialCharHandler),
173                 ("/set_overwrite", SetCookieOverwriteHandler),
174                 ("/set_max_age", SetCookieMaxAgeHandler),
175                 ("/set_expires_days", SetCookieExpiresDaysHandler),
176                 ("/set_falsy_flags", SetCookieFalsyFlags)
177                 ]
178     def test_set_cookie(self):
179         response = self.fetch("/set")
180         self.assertEqual(sorted(response.headers.get_list("Set-Cookie")),
181                          ["bytes=zxcv; Path=/",
182                           "str=asdf; Path=/",
183                           "unicode=qwer; Path=/",
184                           ])
185     def test_get_cookie(self):
186         response = self.fetch("/get", headers={"Cookie": "foo=bar"})
187         self.assertEqual(response.body, b"bar")
188         response = self.fetch("/get", headers={"Cookie": 'foo="bar"'})
189         self.assertEqual(response.body, b"bar")
190         response = self.fetch("/get", headers={"Cookie": "/=exception;"})
191         self.assertEqual(response.body, b"default")
192     def test_set_cookie_domain(self):
193         response = self.fetch("/set_domain")
194         self.assertEqual(response.headers.get_list("Set-Cookie"),
195                          ["unicode_args=blah; Domain=foo.com; Path=/foo"])
196     def test_cookie_special_char(self):
197         response = self.fetch("/special_char")
198         headers = sorted(response.headers.get_list("Set-Cookie"))
199         self.assertEqual(len(headers), 3)
200         self.assertEqual(headers[0], 'equals="a=b"; Path=/')
201         self.assertEqual(headers[1], 'quote="a\\"b"; Path=/')
202         self.assertTrue(headers[2] in ('semicolon="a;b"; Path=/',
203                                        'semicolon="a\\073b"; Path=/'),
204                         headers[2])
205         data = [('foo=a=b', 'a=b'),
206                 ('foo="a=b"', 'a=b'),
207                 ('foo="a;b"', '"a'),  # even quoted, ";" is a delimiter
208                 ('foo=a\\073b', 'a\\073b'),  # escapes only decoded in quotes
209                 ('foo="a\\073b"', 'a;b'),
210                 ('foo="a\\"b"', 'a"b'),
211                 ]
212         for header, expected in data:
213             logging.debug("trying %r", header)
214             response = self.fetch("/get", headers={"Cookie": header})
215             self.assertEqual(response.body, utf8(expected))
216     def test_set_cookie_overwrite(self):
217         response = self.fetch("/set_overwrite")
218         headers = response.headers.get_list("Set-Cookie")
219         self.assertEqual(sorted(headers),
220                          ["a=e; Path=/", "c=d; Domain=example.com; Path=/"])
221     def test_set_cookie_max_age(self):
222         response = self.fetch("/set_max_age")
223         headers = response.headers.get_list("Set-Cookie")
224         self.assertEqual(sorted(headers),
225                          ["foo=bar; Max-Age=10; Path=/"])
226     def test_set_cookie_expires_days(self):
227         response = self.fetch("/set_expires_days")
228         header = response.headers.get("Set-Cookie")
229         match = re.match("foo=bar; expires=(?P&lt;expires&gt;.+); Path=/", header)
230         self.assertIsNotNone(match)
231         expires = datetime.datetime.utcnow() + datetime.timedelta(days=10)
232         header_expires = datetime.datetime(
233             *email.utils.parsedate(match.groupdict()["expires"])[:6])
234         self.assertTrue(abs(timedelta_to_seconds(expires - header_expires)) &lt; 10)
235     def test_set_cookie_false_flags(self):
236         response = self.fetch("/set_falsy_flags")
237         headers = sorted(response.headers.get_list("Set-Cookie"))
238         self.assertEqual(headers[0].lower(), 'a=1; path=/; secure')
239         self.assertEqual(headers[1].lower(), 'b=1; path=/')
240         self.assertEqual(headers[2].lower(), 'c=1; httponly; path=/')
241         self.assertEqual(headers[3].lower(), 'd=1; path=/')
242 class AuthRedirectRequestHandler(RequestHandler):
243     def initialize(self, login_url):
244         self.login_url = login_url
245     def get_login_url(self):
246         return self.login_url
247     @authenticated
248     def get(self):
249         self.send_error(500)
250 class AuthRedirectTest(WebTestCase):
251     def get_handlers(self):
252         return [('/relative', AuthRedirectRequestHandler,
253                  dict(login_url='/login')),
254                 ('/absolute', AuthRedirectRequestHandler,
255                  dict(login_url='http://example.com/login'))]
256     def test_relative_auth_redirect(self):
257         self.http_client.fetch(self.get_url('/relative'), self.stop,
258                                follow_redirects=False)
259         response = self.wait()
260         self.assertEqual(response.code, 302)
261         self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')
262     def test_absolute_auth_redirect(self):
263         self.http_client.fetch(self.get_url('/absolute'), self.stop,
264                                follow_redirects=False)
265         response = self.wait()
266         self.assertEqual(response.code, 302)
267         self.assertTrue(re.match(
268             'http://example.com/login\?next=http%3A%2F%2F127.0.0.1%3A[0-9]+%2Fabsolute',
269             response.headers['Location']), response.headers['Location'])
270 class ConnectionCloseHandler(RequestHandler):
271     def initialize(self, test):
272         self.test = test
273     @asynchronous
274     def get(self):
275         self.test.on_handler_waiting()
276     def on_connection_close(self):
277         self.test.on_connection_close()
278 class ConnectionCloseTest(WebTestCase):
279     def get_handlers(self):
280         return [('/', ConnectionCloseHandler, dict(test=self))]
281     def test_connection_close(self):
282         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
283         s.connect(("127.0.0.1", self.get_http_port()))
284         self.stream = IOStream(s, io_loop=self.io_loop)
285         self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
286         self.wait()
287     def on_handler_waiting(self):
288         logging.debug('handler waiting')
289         self.stream.close()
290     def on_connection_close(self):
291         logging.debug('connection closed')
292         self.stop()
293 class EchoHandler(RequestHandler):
294     def get(self, *path_args):
295         for key in self.request.arguments:
296             if type(key) != str:
297                 raise Exception("incorrect type for key: %r" % type(key))
298             for value in self.request.arguments[key]:
299                 if type(value) != bytes:
300                     raise Exception("incorrect type for value: %r" %
301                                     type(value))
302             for value in self.get_arguments(key):
303                 if type(value) != unicode_type:
304                     raise Exception("incorrect type for value: %r" %
305                                     type(value))
306         for arg in path_args:
307             if type(arg) != unicode_type:
308                 raise Exception("incorrect type for path arg: %r" % type(arg))
309         self.write(dict(path=self.request.path,
310                         path_args=path_args,
311                         args=recursive_unicode(self.request.arguments)))
312 class RequestEncodingTest(WebTestCase):
313     def get_handlers(self):
314         return [("/group/(.*)", EchoHandler),
315                 ("/slashes/([^/]*)/([^/]*)", EchoHandler),
316                 ]
317     def fetch_json(self, path):
318         return json_decode(self.fetch(path).body)
319     def test_group_question_mark(self):
320         self.assertEqual(self.fetch_json('/group/%3F'),
321                          dict(path='/group/%3F', path_args=['?'], args={}))
322         self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),
323                          dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))
324     def test_group_encoding(self):
325         self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),
326                          {u"path": u"/group/%C3%A9",
327                           u"path_args": [u"\u00e9"],
328                           u"args": {u"arg": [u"\u00e9"]}})
329     def test_slashes(self):
330         self.assertEqual(self.fetch_json('/slashes/foo/bar'),
331                          dict(path="/slashes/foo/bar",
332                               path_args=["foo", "bar"],
333                               args={}))
334         self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),
335                          dict(path="/slashes/a%2Fb/c%2Fd",
336                               path_args=["a/b", "c/d"],
337                               args={}))
338     def test_error(self):
339         with ExpectLog(gen_log, ".*Invalid unicode"):
340             self.fetch("/group/?arg=%25%e9")
341 class TypeCheckHandler(RequestHandler):
342     def prepare(self):
343         self.errors = {}
344         self.check_type('status', self.get_status(), int)
345         self.check_type('argument', self.get_argument('foo'), unicode_type)
346         self.check_type('cookie_key', list(self.cookies.keys())[0], str)
347         self.check_type('cookie_value', list(self.cookies.values())[0].value, str)
348         if list(self.cookies.keys()) != ['asdf']:
349             raise Exception("unexpected values for cookie keys: %r" %
350                             self.cookies.keys())
351         self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes)
352         self.check_type('get_cookie', self.get_cookie('asdf'), str)
353         self.check_type('xsrf_token', self.xsrf_token, bytes)
354         self.check_type('xsrf_form_html', self.xsrf_form_html(), str)
355         self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)
356         self.check_type('request_summary', self._request_summary(), str)
357     def get(self, path_component):
358         self.check_type('path_component', path_component, unicode_type)
359         self.write(self.errors)
360     def post(self, path_component):
361         self.check_type('path_component', path_component, unicode_type)
362         self.write(self.errors)
363     def check_type(self, name, obj, expected_type):
364         actual_type = type(obj)
365         if expected_type != actual_type:
366             self.errors[name] = "expected %s, got %s" % (expected_type,
367                                                          actual_type)
368 class DecodeArgHandler(RequestHandler):
369     def decode_argument(self, value, name=None):
370         if type(value) != bytes:
371             raise Exception("unexpected type for value: %r" % type(value))
372         if 'encoding' in self.request.arguments:
373             return value.decode(to_unicode(self.request.arguments['encoding'][0]))
374         else:
375             return value
376     def get(self, arg):
377         def describe(s):
378             if type(s) == bytes:
379                 return ["bytes", native_str(binascii.b2a_hex(s))]
380             elif type(s) == unicode_type:
381                 return ["unicode", s]
382             raise Exception("unknown type")
383         self.write({'path': describe(arg),
384                     'query': describe(self.get_argument("foo")),
385                     })
386 class LinkifyHandler(RequestHandler):
387     def get(self):
388         self.render("linkify.html", message="http://example.com")
389 class UIModuleResourceHandler(RequestHandler):
390     def get(self):
391         self.render("page.html", entries=[1, 2])
392 class OptionalPathHandler(RequestHandler):
393     def get(self, path):
394         self.write({"path": path})
395 class FlowControlHandler(RequestHandler):
396     @asynchronous
397     def get(self):
398         self.write("1")
399         self.flush(callback=self.step2)
400     def step2(self):
401         self.write("2")
402         self.flush(callback=self.step3)
403     def step3(self):
404         self.write("3")
405         self.finish()
406 class MultiHeaderHandler(RequestHandler):
407     def get(self):
408         self.set_header("x-overwrite", "1")
409         self.set_header("X-Overwrite", 2)
410         self.add_header("x-multi", 3)
411         self.add_header("X-Multi", "4")
412 class RedirectHandler(RequestHandler):
413     def get(self):
414         if self.get_argument('permanent', None) is not None:
415             self.redirect('/', permanent=int(self.get_argument('permanent')))
416         elif self.get_argument('status', None) is not None:
417             self.redirect('/', status=int(self.get_argument('status')))
418         else:
419             raise Exception("didn't get permanent or status arguments")
420 class EmptyFlushCallbackHandler(RequestHandler):
421     @asynchronous
422     @gen.engine
423     def get(self):
424         yield gen.Task(self.flush)  # "empty" flush, but writes headers
425         yield gen.Task(self.flush)  # empty flush
426         self.write("o")
427         yield self.flush()  # flushes the "o"
428         yield self.flush()  # empty flush
429         self.finish("k")
430 class HeaderInjectionHandler(RequestHandler):
431     def get(self):
432         try:
433             self.set_header("X-Foo", "foo\r\nX-Bar: baz")
434             raise Exception("Didn't get expected exception")
435         except ValueError as e:
436             if "Unsafe header value" in str(e):
437                 self.finish(b"ok")
438             else:
439                 raise
440 class GetArgumentHandler(RequestHandler):
441     def prepare(self):
442         if self.get_argument('source', None) == 'query':
443             method = self.get_query_argument
444         elif self.get_argument('source', None) == 'body':
445             method = self.get_body_argument
446         else:
447             method = self.get_argument
448         self.finish(method("foo", "default"))
449 class GetArgumentsHandler(RequestHandler):
450     def prepare(self):
451         self.finish(dict(default=self.get_arguments("foo"),
452                          query=self.get_query_arguments("foo"),
453                          body=self.get_body_arguments("foo")))
454 @wsgi_safe
455 class WSGISafeWebTest(WebTestCase):
456     COOKIE_SECRET = "WebTest.COOKIE_SECRET"
457     def get_app_kwargs(self):
458         loader = DictLoader({
459             "linkify.html": "{% module linkify(message) %}",
460             "page.html": """\
461 &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;
462 {% for e in entries %}
463 {% module Template("entry.html", entry=e) %}
464 {% end %}
465 &lt;/body&gt;&lt;/html&gt;""",
466             "entry.html": """\
467 {{ set_resources(embedded_css=".entry { margin-bottom: 1em; }", embedded_javascript="js_embed()", css_files=["/base.css", "/foo.css"], javascript_files="/common.js", html_head="&lt;meta&gt;", html_body='&lt;script src="/analytics.js"/&gt;') }}
468 &lt;div class="entry"&gt;...&lt;/div&gt;""",
469         })
470         return dict(template_loader=loader,
471                     autoescape="xhtml_escape",
472                     cookie_secret=self.COOKIE_SECRET)
473     def tearDown(self):
474         super(WSGISafeWebTest, self).tearDown()
475         RequestHandler._template_loaders.clear()
476     def get_handlers(self):
477         urls = [
478             url("/typecheck/(.*)", TypeCheckHandler, name='typecheck'),
479             url("/decode_arg/(.*)", DecodeArgHandler, name='decode_arg'),
480             url("/decode_arg_kw/(?P&lt;arg&gt;.*)", DecodeArgHandler),
481             url("/linkify", LinkifyHandler),
482             url("/uimodule_resources", UIModuleResourceHandler),
483             url("/optional_path/(.+)?", OptionalPathHandler),
484             url("/multi_header", MultiHeaderHandler),
485             url("/redirect", RedirectHandler),
486             url("/web_redirect_permanent", WebRedirectHandler, {"url": "/web_redirect_newpath"}),
487             url("/web_redirect", WebRedirectHandler, {"url": "/web_redirect_newpath", "permanent": False}),
488             url("//web_redirect_double_slash", WebRedirectHandler, {"url": '/web_redirect_newpath'}),
489             url("/header_injection", HeaderInjectionHandler),
490             url("/get_argument", GetArgumentHandler),
491             url("/get_arguments", GetArgumentsHandler),
492         ]
493         return urls
494     def fetch_json(self, *args, **kwargs):
495         response = self.fetch(*args, **kwargs)
496         response.rethrow()
497         return json_decode(response.body)
498     def test_types(self):
499         cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,
500                                                       "asdf", "qwer"))
501         response = self.fetch("/typecheck/asdf?foo=bar",
502                               headers={"Cookie": "asdf=" + cookie_value})
503         data = json_decode(response.body)
504         self.assertEqual(data, {})
505         response = self.fetch("/typecheck/asdf?foo=bar", method="POST",
506                               headers={"Cookie": "asdf=" + cookie_value},
507                               body="foo=bar")
508     def test_decode_argument(self):
509         urls = ["/decode_arg/%C3%A9?foo=%C3%A9&amp;encoding=utf-8",
510                 "/decode_arg/%E9?foo=%E9&amp;encoding=latin1",
511                 "/decode_arg_kw/%E9?foo=%E9&amp;encoding=latin1",
512                 ]
513         for req_url in urls:
514             response = self.fetch(req_url)
515             response.rethrow()
516             data = json_decode(response.body)
517             self.assertEqual(data, {u'path': [u'unicode', u'\u00e9'],
518                                     u'query': [u'unicode', u'\u00e9'],
519                                     })
520         response = self.fetch("/decode_arg/%C3%A9?foo=%C3%A9")
521         response.rethrow()
522         data = json_decode(response.body)
523         self.assertEqual(data, {u'path': [u'bytes', u'c3a9'],
524                                 u'query': [u'bytes', u'c3a9'],
525                                 })
526     def test_decode_argument_invalid_unicode(self):
527         with ExpectLog(gen_log, ".*Invalid unicode.*"):
528             response = self.fetch("/typecheck/invalid%FF")
529             self.assertEqual(response.code, 400)
530             response = self.fetch("/typecheck/invalid?foo=%FF")
531             self.assertEqual(response.code, 400)
532     def test_decode_argument_plus(self):
533         urls = ["/decode_arg/1%20%2B%201?foo=1%20%2B%201&amp;encoding=utf-8",
534                 "/decode_arg/1%20+%201?foo=1+%2B+1&amp;encoding=utf-8"]
535         for req_url in urls:
536             response = self.fetch(req_url)
537             response.rethrow()
538             data = json_decode(response.body)
539             self.assertEqual(data, {u'path': [u'unicode', u'1 + 1'],
540                                     u'query': [u'unicode', u'1 + 1'],
541                                     })
542     def test_reverse_url(self):
543         self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),
544                          '/decode_arg/foo')
545         self.assertEqual(self.app.reverse_url('decode_arg', 42),
546                          '/decode_arg/42')
547         self.assertEqual(self.app.reverse_url('decode_arg', b'\xe9'),
548                          '/decode_arg/%E9')
549         self.assertEqual(self.app.reverse_url('decode_arg', u'\u00e9'),
550                          '/decode_arg/%C3%A9')
551         self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),
552                          '/decode_arg/1%20%2B%201')
553     def test_uimodule_unescaped(self):
554         response = self.fetch("/linkify")
555         self.assertEqual(response.body,
556                          b"&lt;a href=\"http://example.com\"&gt;http://example.com&lt;/a&gt;")
557     def test_uimodule_resources(self):
558         response = self.fetch("/uimodule_resources")
559         self.assertEqual(response.body, b"""\
560 &lt;html&gt;&lt;head&gt;&lt;link href="/base.css" type="text/css" rel="stylesheet"/&gt;&lt;link href="/foo.css" type="text/css" rel="stylesheet"/&gt;
561 &lt;style type="text/css"&gt;
562 .entry { margin-bottom: 1em; }
563 &lt;/style&gt;
564 &lt;meta&gt;
565 &lt;/head&gt;&lt;body&gt;
566 &lt;div class="entry"&gt;...&lt;/div&gt;
567 &lt;div class="entry"&gt;...&lt;/div&gt;
568 &lt;script src="/common.js" type="text/javascript"&gt;&lt;/script&gt;
569 &lt;script type="text/javascript"&gt;
570 //&lt;![CDATA[
571 js_embed()
572 //]]&gt;
573 &lt;/script&gt;
574 &lt;script src="/analytics.js"/&gt;
575 &lt;/body&gt;&lt;/html&gt;""")
576     def test_optional_path(self):
577         self.assertEqual(self.fetch_json("/optional_path/foo"),
578                          {u"path": u"foo"})
579         self.assertEqual(self.fetch_json("/optional_path/"),
580                          {u"path": None})
581     def test_multi_header(self):
582         response = self.fetch("/multi_header")
583         self.assertEqual(response.headers["x-overwrite"], "2")
584         self.assertEqual(response.headers.get_list("x-multi"), ["3", "4"])
585     def test_redirect(self):
586         response = self.fetch("/redirect?permanent=1", follow_redirects=False)
587         self.assertEqual(response.code, 301)
588         response = self.fetch("/redirect?permanent=0", follow_redirects=False)
589         self.assertEqual(response.code, 302)
590         response = self.fetch("/redirect?status=307", follow_redirects=False)
591         self.assertEqual(response.code, 307)
592     def test_web_redirect(self):
593         response = self.fetch("/web_redirect_permanent", follow_redirects=False)
594         self.assertEqual(response.code, 301)
595         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
596         response = self.fetch("/web_redirect", follow_redirects=False)
597         self.assertEqual(response.code, 302)
598         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
599     def test_web_redirect_double_slash(self):
600         response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
601         self.assertEqual(response.code, 301)
602         self.assertEqual(response.headers['Location'], '/web_redirect_newpath')
603     def test_header_injection(self):
604         response = self.fetch("/header_injection")
605         self.assertEqual(response.body, b"ok")
606     def test_get_argument(self):
607         response = self.fetch("/get_argument?foo=bar")
608         self.assertEqual(response.body, b"bar")
609         response = self.fetch("/get_argument?foo=")
610         self.assertEqual(response.body, b"")
611         response = self.fetch("/get_argument")
612         self.assertEqual(response.body, b"default")
613         body = urllib_parse.urlencode(dict(foo="hello"))
614         response = self.fetch("/get_argument?foo=bar", method="POST", body=body)
615         self.assertEqual(response.body, b"hello")
616         response = self.fetch("/get_arguments?foo=bar",
617                               method="POST", body=body)
618         self.assertEqual(json_decode(response.body),
619                          dict(default=['bar', 'hello'],
620                               query=['bar'],
621                               body=['hello']))
622     def test_get_query_arguments(self):
623         body = urllib_parse.urlencode(dict(foo="hello"))
624         response = self.fetch("/get_argument?source=query&amp;foo=bar",
625                               method="POST", body=body)
626         self.assertEqual(response.body, b"bar")
627         response = self.fetch("/get_argument?source=query&amp;foo=",
628                               method="POST", body=body)
629         self.assertEqual(response.body, b"")
630         response = self.fetch("/get_argument?source=query",
631                               method="POST", body=body)
632         self.assertEqual(response.body, b"default")
633     def test_get_body_arguments(self):
634         body = urllib_parse.urlencode(dict(foo="bar"))
635         response = self.fetch("/get_argument?source=body&amp;foo=hello",
636                               method="POST", body=body)
637         self.assertEqual(response.body, b"bar")
638         body = urllib_parse.urlencode(dict(foo=""))
639         response = self.fetch("/get_argument?source=body&amp;foo=hello",
640                               method="POST", body=body)
641         self.assertEqual(response.body, b"")
642         body = urllib_parse.urlencode(dict())
643         response = self.fetch("/get_argument?source=body&amp;foo=hello",
644                               method="POST", body=body)
645         self.assertEqual(response.body, b"default")
646     def test_no_gzip(self):
647         response = self.fetch('/get_argument')
648         self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))
649         self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))
650 class NonWSGIWebTests(WebTestCase):
651     def get_handlers(self):
652         return [("/flow_control", FlowControlHandler),
653                 ("/empty_flush", EmptyFlushCallbackHandler),
654                 ]
655     def test_flow_control(self):
656         self.assertEqual(self.fetch("/flow_control").body, b"123")
657     def test_empty_flush(self):
658         response = self.fetch("/empty_flush")
659         self.assertEqual(response.body, b"ok")
660 @wsgi_safe
661 class ErrorResponseTest(WebTestCase):
662     def get_handlers(self):
663         class DefaultHandler(RequestHandler):
664             def get(self):
665                 if self.get_argument("status", None):
666                     raise HTTPError(int(self.get_argument("status")))
667                 1 / 0
668         class WriteErrorHandler(RequestHandler):
669             def get(self):
670                 if self.get_argument("status", None):
671                     self.send_error(int(self.get_argument("status")))
672                 else:
673                     1 / 0
674             def write_error(self, status_code, **kwargs):
675                 self.set_header("Content-Type", "text/plain")
676                 if "exc_info" in kwargs:
677                     self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
678                 else:
679                     self.write("Status: %d" % status_code)
680         class FailedWriteErrorHandler(RequestHandler):
681             def get(self):
682                 1 / 0
683             def write_error(self, status_code, **kwargs):
684                 raise Exception("exception in write_error")
685         return [url("/default", DefaultHandler),
686                 url("/write_error", WriteErrorHandler),
687                 url("/failed_write_error", FailedWriteErrorHandler),
688                 ]
689     def test_default(self):
690         with ExpectLog(app_log, "Uncaught exception"):
691             response = self.fetch("/default")
692             self.assertEqual(response.code, 500)
693             self.assertTrue(b"500: Internal Server Error" in response.body)
694             response = self.fetch("/default?status=503")
695             self.assertEqual(response.code, 503)
696             self.assertTrue(b"503: Service Unavailable" in response.body)
697     def test_write_error(self):
698         with ExpectLog(app_log, "Uncaught exception"):
699             response = self.fetch("/write_error")
700             self.assertEqual(response.code, 500)
701             self.assertEqual(b"Exception: ZeroDivisionError", response.body)
702             response = self.fetch("/write_error?status=503")
703             self.assertEqual(response.code, 503)
704             self.assertEqual(b"Status: 503", response.body)
705     def test_failed_write_error(self):
706         with ExpectLog(app_log, "Uncaught exception"):
707             response = self.fetch("/failed_write_error")
708             self.assertEqual(response.code, 500)
709             self.assertEqual(b"", response.body)
710 @wsgi_safe
711 class StaticFileTest(WebTestCase):
712     robots_txt_hash = b"f71d20196d4caf35b6a670db8c70b03d"
713     static_dir = os.path.join(os.path.dirname(__file__), 'static')
714     def get_handlers(self):
715         class StaticUrlHandler(RequestHandler):
716             def get(self, path):
717                 with_v = int(self.get_argument('include_version', 1))
718                 self.write(self.static_url(path, include_version=with_v))
719         class AbsoluteStaticUrlHandler(StaticUrlHandler):
720             include_host = True
721         class OverrideStaticUrlHandler(RequestHandler):
722             def get(self, path):
723                 do_include = bool(self.get_argument("include_host"))
724                 self.include_host = not do_include
725                 regular_url = self.static_url(path)
726                 override_url = self.static_url(path, include_host=do_include)
727                 if override_url == regular_url:
728                     return self.write(str(False))
729                 protocol = self.request.protocol + "://"
730                 protocol_length = len(protocol)
731                 check_regular = regular_url.find(protocol, 0, protocol_length)
732                 check_override = override_url.find(protocol, 0, protocol_length)
733                 if do_include:
734                     result = (check_override == 0 and check_regular == -1)
735                 else:
736                     result = (check_override == -1 and check_regular == 0)
737                 self.write(str(result))
738         return [('/static_url/(.*)', StaticUrlHandler),
739                 ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),
740                 ('/override_static_url/(.*)', OverrideStaticUrlHandler),
741                 ('/root_static/(.*)', StaticFileHandler, dict(path='/'))]
742     def get_app_kwargs(self):
743         return dict(static_path=relpath('static'))
744     def test_static_files(self):
745         response = self.fetch('/robots.txt')
746         self.assertTrue(b"Disallow: /" in response.body)
747         response = self.fetch('/static/robots.txt')
748         self.assertTrue(b"Disallow: /" in response.body)
749         self.assertEqual(response.headers.get("Content-Type"), "text/plain")
750     def test_static_compressed_files(self):
751         response = self.fetch("/static/sample.xml.gz")
752         self.assertEqual(response.headers.get("Content-Type"),
753                          "application/gzip")
754         response = self.fetch("/static/sample.xml.bz2")
755         self.assertEqual(response.headers.get("Content-Type"),
756                          "application/octet-stream")
757         response = self.fetch("/static/sample.xml")
758         self.assertTrue(response.headers.get("Content-Type")
759     def test_static_url(self):
760         response = self.fetch<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("/static_url/robots.txt")
761         self.assertEqual(response.body,
762                          b"/static/robots.txt?v=" + self.robots_txt_hash)
763     def test_absolute_static_url(self):
764         response = self.fetch("/abs_static_url/robots.txt")
765         self.assertEqual(</b></font>response.body, (
766             utf8(self.get_url("/")) +
767             b"static/robots.txt?v=" +
768             self.robots_txt_hash
769         ))
770     def test_relative_version_exclusion(self):
771         response = self.fetch("/static_url/robots.txt?include_version=0")
772         self.assertEqual(response.body, b"/static/robots.txt")
773     def test_absolute_version_exclusion(self):
774         response = self.fetch("/abs_static_url/robots.txt?include_version=0")
775         self.assertEqual(response.body,
776                          utf8(self.get_url("/") + "static/robots.txt"))
777     def test_include_host_override(self):
778         self._trigger_include_host_check(False)
779         self._trigger_include_host_check(True)
780     def _trigger_include_host_check(self, include_host):
781         path = "/override_static_url/robots.txt?include_host=%s"
782         response = self.fetch(path % int(include_host))
783         self.assertEqual(response.body, utf8(str(True)))
784     def get_and_head(self, *args, **kwargs):
785         head_response = self.fetch(*args, method="HEAD", **kwargs)
786         get_response = self.fetch(*args, method="GET", **kwargs)
787         content_headers = set()
788         for h in itertools.chain(head_response.headers, get_response.headers):
789             if h.startswith('Content-'):
790                 content_headers.add(h)
791         for h in content_headers:
792             self.assertEqual(head_response.headers.get(h),
793                              get_response.headers.get(h),
794                              "%s differs between GET (%s) and HEAD (%s)" %
795                              (h, head_response.headers.get(h),
796                               get_response.headers.get(h)))
797         return get_response
798     def test_static_304_if_modified_since(self):
799         response1 = self.get_and_head("/static/robots.txt")
800         response2 = self.get_and_head("/static/robots.txt", headers={
801             'If-Modified-Since': response1.headers['Last-Modified']})
802         self.assertEqual(response2.code, 304)
803         self.assertTrue('Content-Length' not in response2.headers)
804         self.assertTrue('Last-Modified' not in response2.headers)
805     def test_static_304_if_none_match(self):
806         response1 = self.get_and_head("/static/robots.txt")
807         response2 = self.get_and_head("/static/robots.txt", headers={
808             'If-None-Match': response1.headers['Etag']})
809         self.assertEqual(response2.code, 304)
810     def test_static_if_modified_since_pre_epoch(self):
811         response = self.get_and_head("/static/robots.txt", headers={
812             'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})
813         self.assertEqual(response.code, 200)
814     def test_static_if_modified_since_time_zone(self):
815         stat = os.stat(relpath('static/robots.txt'))
816         response = self.get_and_head('/static/robots.txt', headers={
817             'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})
818         self.assertEqual(response.code, 200)
819         response = self.get_and_head('/static/robots.txt', headers={
820             'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})
821         self.assertEqual(response.code, 304)
822     def test_static_etag(self):
823         response = self.get_and_head('/static/robots.txt')
824         self.assertEqual(utf8(response.headers.get("Etag")),
825                          b'"' + self.robots_txt_hash + b'"')
826     def test_static_with_range(self):
827         response = self.get_and_head('/static/robots.txt', headers={
828             'Range': 'bytes=0-9'})
829         self.assertEqual(response.code, 206)
830         self.assertEqual(response.body, b"User-agent")
831         self.assertEqual(utf8(response.headers.get("Etag")),
832                          b'"' + self.robots_txt_hash + b'"')
833         self.assertEqual(response.headers.get("Content-Length"), "10")
834         self.assertEqual(response.headers.get("Content-Range"),
835                          "bytes 0-9/26")
836     def test_static_with_range_full_file(self):
837         response = self.get_and_head('/static/robots.txt', headers={
838             'Range': 'bytes=0-'})
839         self.assertEqual(response.code, 200)
840         robots_file_path = os.path.join(self.static_dir, "robots.txt")
841         with open(robots_file_path) as f:
842             self.assertEqual(response.body, utf8(f.read()))
843         self.assertEqual(response.headers.get("Content-Length"), "26")
844         self.assertEqual(response.headers.get("Content-Range"), None)
845     def test_static_with_range_full_past_end(self):
846         response = self.get_and_head('/static/robots.txt', headers={
847             'Range': 'bytes=0-10000000'})
848         self.assertEqual(response.code, 200)
849         robots_file_path = os.path.join(self.static_dir, "robots.txt")
850         with open(robots_file_path) as f:
851             self.assertEqual(response.body, utf8(f.read()))
852         self.assertEqual(response.headers.get("Content-Length"), "26")
853         self.assertEqual(response.headers.get("Content-Range"), None)
854     def test_static_with_range_partial_past_end(self):
855         response = self.get_and_head('/static/robots.txt', headers={
856             'Range': 'bytes=1-10000000'})
857         self.assertEqual(response.code, 206)
858         robots_file_path = os.path.join(self.static_dir, "robots.txt")
859         with open(robots_file_path) as f:
860             self.assertEqual(response.body, utf8(f.read()[1:]))
861         self.assertEqual(response.headers.get("Content-Length"), "25")
862         self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
863     def test_static_with_range_end_edge(self):
864         response = self.get_and_head('/static/robots.txt', headers={
865             'Range': 'bytes=22-'})
866         self.assertEqual(response.body, b": /\n")
867         self.assertEqual(response.headers.get("Content-Length"), "4")
868         self.assertEqual(response.headers.get("Content-Range"),
869                          "bytes 22-25/26")
870     def test_static_with_range_neg_end(self):
871         response = self.get_and_head('/static/robots.txt', headers={
872             'Range': 'bytes=-4'})
873         self.assertEqual(response.body, b": /\n")
874         self.assertEqual(response.headers.get("Content-Length"), "4")
875         self.assertEqual(response.headers.get("Content-Range"),
876                          "bytes 22-25/26")
877     def test_static_invalid_range(self):
878         response = self.get_and_head('/static/robots.txt', headers={
879             'Range': 'asdf'})
880         self.assertEqual(response.code, 200)
881     def test_static_unsatisfiable_range_zero_suffix(self):
882         response = self.get_and_head('/static/robots.txt', headers={
883             'Range': 'bytes=-0'})
884         self.assertEqual(response.headers.get("Content-Range"),
885                          "bytes */26")
886         self.assertEqual(response.code, 416)
887     def test_static_unsatisfiable_range_invalid_start(self):
888         response = self.get_and_head('/static/robots.txt', headers={
889             'Range': 'bytes=26'})
890         self.assertEqual(response.code, 416)
891         self.assertEqual(response.headers.get("Content-Range"),
892                          "bytes */26")
893     def test_static_head(self):
894         response = self.fetch('/static/robots.txt', method='HEAD')
895         self.assertEqual(response.code, 200)
896         self.assertEqual(response.body, b'')
897         self.assertEqual(response.headers['Content-Length'], '26')
898         self.assertEqual(utf8(response.headers['Etag']),
899                          b'"' + self.robots_txt_hash + b'"')
900     def test_static_head_range(self):
901         response = self.fetch('/static/robots.txt', method='HEAD',
902                               headers={'Range': 'bytes=1-4'})
903         self.assertEqual(response.code, 206)
904         self.assertEqual(response.body, b'')
905         self.assertEqual(response.headers['Content-Length'], '4')
906         self.assertEqual(utf8(response.headers['Etag']),
907                          b'"' + self.robots_txt_hash + b'"')
908     def test_static_range_if_none_match(self):
909         response = self.get_and_head('/static/robots.txt', headers={
910             'Range': 'bytes=1-4',
911             'If-None-Match': b'"' + self.robots_txt_hash + b'"'})
912         self.assertEqual(response.code, 304)
913         self.assertEqual(response.body, b'')
914         self.assertTrue('Content-Length' not in response.headers)
915         self.assertEqual(utf8(response.headers['Etag']),
916                          b'"' + self.robots_txt_hash + b'"')
917     def test_static_404(self):
918         response = self.get_and_head('/static/blarg')
919         self.assertEqual(response.code, 404)
920     def test_path_traversal_protection(self):
921         self.http_client.close()
922         self.http_client = SimpleAsyncHTTPClient()
923         with ExpectLog(gen_log, ".*not in root static directory"):
924             response = self.get_and_head('/static/../static_foo.txt')
925         self.assertEqual(response.code, 403)
926     @unittest.skipIf(os.name != 'posix', 'non-posix OS')
927     def test_root_static_path(self):
928         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
929                             'static/robots.txt')
930         response = self.get_and_head('/root_static' + urllib_parse.quote(path))
931         self.assertEqual(response.code, 200)
932 @wsgi_safe
933 class StaticDefaultFilenameTest(WebTestCase):
934     def get_app_kwargs(self):
935         return dict(static_path=relpath('static'),
936                     static_handler_args=dict(default_filename='index.html'))
937     def get_handlers(self):
938         return []
939     def test_static_default_filename(self):
940         response = self.fetch('/static/dir/', follow_redirects=False)
941         self.assertEqual(response.code, 200)
942         self.assertEqual(b'this is the index\n', response.body)
943     def test_static_default_redirect(self):
944         response = self.fetch('/static/dir', follow_redirects=False)
945         self.assertEqual(response.code, 301)
946         self.assertTrue(response.headers['Location'].endswith('/static/dir/'))
947 @wsgi_safe
948 class StaticFileWithPathTest(WebTestCase):
949     def get_app_kwargs(self):
950         return dict(static_path=relpath('static'),
951                     static_handler_args=dict(default_filename='index.html'))
952     def get_handlers(self):
953         return [("/foo/(.*)", StaticFileHandler, {
954             "path": relpath("templates/"),
955         })]
956     def test_serve(self):
957         response = self.fetch("/foo/utf8.html")
958         self.assertEqual(response.body, b"H\xc3\xa9llo\n")
959 @wsgi_safe
960 class CustomStaticFileTest(WebTestCase):
961     def get_handlers(self):
962         class MyStaticFileHandler(StaticFileHandler):
963             @classmethod
964             def make_static_url(cls, settings, path):
965                 version_hash = cls.get_version(settings, path)
966                 extension_index = path.rindex('.')
967                 before_version = path[:extension_index]
968                 after_version = path[(extension_index + 1):]
969                 return '/static/%s.%s.%s' % (before_version, version_hash,
970                                              after_version)
971             def parse_url_path(self, url_path):
972                 extension_index = url_path.rindex('.')
973                 version_index = url_path.rindex('.', 0, extension_index)
974                 return '%s%s' % (url_path[:version_index],
975                                  url_path[extension_index:])
976             @classmethod
977             def get_absolute_path(cls, settings, path):
978                 return 'CustomStaticFileTest:' + path
979             def validate_absolute_path(self, root, absolute_path):
980                 return absolute_path
981             @classmethod
982             def get_content(self, path, start=None, end=None):
983                 assert start is None and end is None
984                 if path == 'CustomStaticFileTest:foo.txt':
985                     return b'bar'
986                 raise Exception("unexpected path %r" % path)
987             def get_content_size(self):
988                 if self.absolute_path == 'CustomStaticFileTest:foo.txt':
989                     return 3
990                 raise Exception("unexpected path %r" % self.absolute_path)
991             def get_modified_time(self):
992                 return None
993             @classmethod
994             def get_version(cls, settings, path):
995                 return "42"
996         class StaticUrlHandler(RequestHandler):
997             def get(self, path):
998                 self.write(self.static_url(path))
999         self.static_handler_class = MyStaticFileHandler
1000         return [("/static_url/(.*)", StaticUrlHandler)]
1001     def get_app_kwargs(self):
1002         return dict(static_path="dummy",
1003                     static_handler_class=self.static_handler_class)
1004     def test_serve(self):
1005         response = self.fetch("/static/foo.42.txt")
1006         self.assertEqual(response.body, b"bar")
1007     def test_static_url(self):
1008         with ExpectLog(gen_log, "Could not open static file", required=False):
1009             response = self.fetch("/static_url/foo.txt")
1010             self.assertEqual(response.body, b"/static/foo.42.txt")
1011 @wsgi_safe
1012 class HostMatchingTest(WebTestCase):
1013     class Handler(RequestHandler):
1014         def initialize(self, reply):
1015             self.reply = reply
1016         def get(self):
1017             self.write(self.reply)
1018     def get_handlers(self):
1019         return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
1020     def test_host_matching(self):
1021         self.app.add_handlers("www.example.com",
1022                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1023         self.app.add_handlers(r"www\.example\.com",
1024                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1025         self.app.add_handlers("www.example.com",
1026                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1027         self.app.add_handlers("www.e.*e.com",
1028                               [("/baz", HostMatchingTest.Handler, {"reply": "[3]"})])
1029         response = self.fetch("/foo")
1030         self.assertEqual(response.body, b"wildcard")
1031         response = self.fetch("/bar")
1032         self.assertEqual(response.code, 404)
1033         response = self.fetch("/baz")
1034         self.assertEqual(response.code, 404)
1035         response = self.fetch("/foo", headers={'Host': 'www.example.com'})
1036         self.assertEqual(response.body, b"[0]")
1037         response = self.fetch("/bar", headers={'Host': 'www.example.com'})
1038         self.assertEqual(response.body, b"[1]")
1039         response = self.fetch("/baz", headers={'Host': 'www.example.com'})
1040         self.assertEqual(response.body, b"[2]")
1041         response = self.fetch("/baz", headers={'Host': 'www.exe.com'})
1042         self.assertEqual(response.body, b"[3]")
1043 @wsgi_safe
1044 class DefaultHostMatchingTest(WebTestCase):
1045     def get_handlers(self):
1046         return []
1047     def get_app_kwargs(self):
1048         return {'default_host': "www.example.com"}
1049     def test_default_host_matching(self):
1050         self.app.add_handlers("www.example.com",
1051                               [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})])
1052         self.app.add_handlers(r"www\.example\.com",
1053                               [("/bar", HostMatchingTest.Handler, {"reply": "[1]"})])
1054         self.app.add_handlers("www.test.com",
1055                               [("/baz", HostMatchingTest.Handler, {"reply": "[2]"})])
1056         response = self.fetch("/foo")
1057         self.assertEqual(response.body, b"[0]")
1058         response = self.fetch("/bar")
1059         self.assertEqual(response.body, b"[1]")
1060         response = self.fetch("/baz")
1061         self.assertEqual(response.code, 404)
1062         response = self.fetch("/foo", headers={"X-Real-Ip": "127.0.0.1"})
1063         self.assertEqual(response.code, 404)
1064         self.app.default_host = "www.test.com"
1065         response = self.fetch("/baz")
1066         self.assertEqual(response.body, b"[2]")
1067 @wsgi_safe
1068 class NamedURLSpecGroupsTest(WebTestCase):
1069     def get_handlers(self):
1070         class EchoHandler(RequestHandler):
1071             def get(self, path):
1072                 self.write(path)
1073         return [("/str/(?P&lt;path&gt;.*)", EchoHandler),
1074                 (u"/unicode/(?P&lt;path&gt;.*)", EchoHandler)]
1075     def test_named_urlspec_groups(self):
1076         response = self.fetch("/str/foo")
1077         self.assertEqual(response.body, b"foo")
1078         response = self.fetch("/unicode/bar")
1079         self.assertEqual(response.body, b"bar")
1080 @wsgi_safe
1081 class ClearHeaderTest(SimpleHandlerTestCase):
1082     class Handler(RequestHandler):
1083         def get(self):
1084             self.set_header("h1", "foo")
1085             self.set_header("h2", "bar")
1086             self.clear_header("h1")
1087             self.clear_header("nonexistent")
1088     def test_clear_header(self):
1089         response = self.fetch("/")
1090         self.assertTrue("h1" not in response.headers)
1091         self.assertEqual(response.headers["h2"], "bar")
1092 class Header204Test(SimpleHandlerTestCase):
1093     class Handler(RequestHandler):
1094         def get(self):
1095             self.set_status(204)
1096             self.finish()
1097     def test_204_headers(self):
1098         response = self.fetch('/')
1099         self.assertEqual(response.code, 204)
1100         self.assertNotIn("Content-Length", response.headers)
1101         self.assertNotIn("Transfer-Encoding", response.headers)
1102 @wsgi_safe
1103 class Header304Test(SimpleHandlerTestCase):
1104     class Handler(RequestHandler):
1105         def get(self):
1106             self.set_header("Content-Language", "en_US")
1107             self.write("hello")
1108     def test_304_headers(self):
1109         response1 = self.fetch('/')
1110         self.assertEqual(response1.headers["Content-Length"], "5")
1111         self.assertEqual(response1.headers["Content-Language"], "en_US")
1112         response2 = self.fetch('/', headers={
1113             'If-None-Match': response1.headers["Etag"]})
1114         self.assertEqual(response2.code, 304)
1115         self.assertTrue("Content-Length" not in response2.headers)
1116         self.assertTrue("Content-Language" not in response2.headers)
1117         self.assertTrue("Transfer-Encoding" not in response2.headers)
1118 @wsgi_safe
1119 class StatusReasonTest(SimpleHandlerTestCase):
1120     class Handler(RequestHandler):
1121         def get(self):
1122             reason = self.request.arguments.get('reason', [])
1123             self.set_status(int(self.get_argument('code')),
1124                             reason=reason[0] if reason else None)
1125     def get_http_client(self):
1126         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1127     def test_status(self):
1128         response = self.fetch("/?code=304")
1129         self.assertEqual(response.code, 304)
1130         self.assertEqual(response.reason, "Not Modified")
1131         response = self.fetch("/?code=304&amp;reason=Foo")
1132         self.assertEqual(response.code, 304)
1133         self.assertEqual(response.reason, "Foo")
1134         response = self.fetch("/?code=682&amp;reason=Bar")
1135         self.assertEqual(response.code, 682)
1136         self.assertEqual(response.reason, "Bar")
1137         with ExpectLog(app_log, 'Uncaught exception'):
1138             response = self.fetch("/?code=682")
1139         self.assertEqual(response.code, 500)
1140 @wsgi_safe
1141 class DateHeaderTest(SimpleHandlerTestCase):
1142     class Handler(RequestHandler):
1143         def get(self):
1144             self.write("hello")
1145     def test_date_header(self):
1146         response = self.fetch('/')
1147         header_date = datetime.datetime(
1148             *email.utils.parsedate(response.headers['Date'])[:6])
1149         self.assertTrue(header_date - datetime.datetime.utcnow() &lt;
1150                         datetime.timedelta(seconds=2))
1151 @wsgi_safe
1152 class RaiseWithReasonTest(SimpleHandlerTestCase):
1153     class Handler(RequestHandler):
1154         def get(self):
1155             raise HTTPError(682, reason="Foo")
1156     def get_http_client(self):
1157         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1158     def test_raise_with_reason(self):
1159         response = self.fetch("/")
1160         self.assertEqual(response.code, 682)
1161         self.assertEqual(response.reason, "Foo")
1162         self.assertIn(b'682: Foo', response.body)
1163     def test_httperror_str(self):
1164         self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
1165     def test_httperror_str_from_httputil(self):
1166         self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
1167 @wsgi_safe
1168 class ErrorHandlerXSRFTest(WebTestCase):
1169     def get_handlers(self):
1170         return [('/error', ErrorHandler, dict(status_code=417))]
1171     def get_app_kwargs(self):
1172         return dict(xsrf_cookies=True)
1173     def test_error_xsrf(self):
1174         response = self.fetch('/error', method='POST', body='')
1175         self.assertEqual(response.code, 417)
1176     def test_404_xsrf(self):
1177         response = self.fetch('/404', method='POST', body='')
1178         self.assertEqual(response.code, 404)
1179 @wsgi_safe
1180 class GzipTestCase(SimpleHandlerTestCase):
1181     class Handler(RequestHandler):
1182         def get(self):
1183             for v in self.get_arguments('vary'):
1184                 self.add_header('Vary', v)
1185             self.write('hello world' + ('!' * GZipContentEncoding.MIN_LENGTH))
1186     def get_app_kwargs(self):
1187         return dict(
1188             gzip=True,
1189             static_path=os.path.join(os.path.dirname(__file__), 'static'))
1190     def assert_compressed(self, response):
1191         self.assertEqual(
1192             response.headers.get(
1193                 'Content-Encoding',
1194                 response.headers.get('X-Consumed-Content-Encoding')),
1195             'gzip')
1196     def test_gzip(self):
1197         response = self.fetch('/')
1198         self.assert_compressed(response)
1199         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1200     def test_gzip_static(self):
1201         response = self.fetch('/robots.txt')
1202         self.assert_compressed(response)
1203         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1204     def test_gzip_not_requested(self):
1205         response = self.fetch('/', use_gzip=False)
1206         self.assertNotIn('Content-Encoding', response.headers)
1207         self.assertEqual(response.headers['Vary'], 'Accept-Encoding')
1208     def test_vary_already_present(self):
1209         response = self.fetch('/?vary=Accept-Language')
1210         self.assert_compressed(response)
1211         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1212                          ['Accept-Language', 'Accept-Encoding'])
1213     def test_vary_already_present_multiple(self):
1214         response = self.fetch('/?vary=Accept-Language&amp;vary=Cookie')
1215         self.assert_compressed(response)
1216         self.assertEqual([s.strip() for s in response.headers['Vary'].split(',')],
1217                          ['Accept-Language', 'Cookie', 'Accept-Encoding'])
1218 @wsgi_safe
1219 class PathArgsInPrepareTest(WebTestCase):
1220     class Handler(RequestHandler):
1221         def prepare(self):
1222             self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
1223         def get(self, path):
1224             assert path == 'foo'
1225             self.finish()
1226     def get_handlers(self):
1227         return [('/pos/(.*)', self.Handler),
1228                 ('/kw/(?P&lt;path&gt;.*)', self.Handler)]
1229     def test_pos(self):
1230         response = self.fetch('/pos/foo')
1231         response.rethrow()
1232         data = json_decode(response.body)
1233         self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})
1234     def test_kw(self):
1235         response = self.fetch('/kw/foo')
1236         response.rethrow()
1237         data = json_decode(response.body)
1238         self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})
1239 @wsgi_safe
1240 class ClearAllCookiesTest(SimpleHandlerTestCase):
1241     class Handler(RequestHandler):
1242         def get(self):
1243             self.clear_all_cookies()
1244             self.write('ok')
1245     def test_clear_all_cookies(self):
1246         response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})
1247         set_cookies = sorted(response.headers.get_list('Set-Cookie'))
1248         self.assertTrue(set_cookies[0].startswith('baz=;') or
1249                         set_cookies[0].startswith('baz="";'))
1250         self.assertTrue(set_cookies[1].startswith('foo=;') or
1251                         set_cookies[1].startswith('foo="";'))
1252 class PermissionError(Exception):
1253     pass
1254 @wsgi_safe
1255 class ExceptionHandlerTest(SimpleHandlerTestCase):
1256     class Handler(RequestHandler):
1257         def get(self):
1258             exc = self.get_argument('exc')
1259             if exc == 'http':
1260                 raise HTTPError(410, "no longer here")
1261             elif exc == 'zero':
1262                 1 / 0
1263             elif exc == 'permission':
1264                 raise PermissionError('not allowed')
1265         def write_error(self, status_code, **kwargs):
1266             if 'exc_info' in kwargs:
1267                 typ, value, tb = kwargs['exc_info']
1268                 if isinstance(value, PermissionError):
1269                     self.set_status(403)
1270                     self.write('PermissionError')
1271                     return
1272             RequestHandler.write_error(self, status_code, **kwargs)
1273         def log_exception(self, typ, value, tb):
1274             if isinstance(value, PermissionError):
1275                 app_log.warning('custom logging for PermissionError: %s',
1276                                 value.args[0])
1277             else:
1278                 RequestHandler.log_exception(self, typ, value, tb)
1279     def test_http_error(self):
1280         with ExpectLog(gen_log, '.*no longer here'):
1281             response = self.fetch('/?exc=http')
1282             self.assertEqual(response.code, 410)
1283     def test_unknown_error(self):
1284         with ExpectLog(app_log, 'Uncaught exception'):
1285             response = self.fetch('/?exc=zero')
1286             self.assertEqual(response.code, 500)
1287     def test_known_error(self):
1288         with ExpectLog(app_log,
1289                        'custom logging for PermissionError: not allowed'):
1290             response = self.fetch('/?exc=permission')
1291             self.assertEqual(response.code, 403)
1292 @wsgi_safe
1293 class BuggyLoggingTest(SimpleHandlerTestCase):
1294     class Handler(RequestHandler):
1295         def get(self):
1296             1 / 0
1297         def log_exception(self, typ, value, tb):
1298             1 / 0
1299     def test_buggy_log_exception(self):
1300         with ExpectLog(app_log, '.*'):
1301             self.fetch('/')
1302 @wsgi_safe
1303 class UIMethodUIModuleTest(SimpleHandlerTestCase):
1304     class Handler(RequestHandler):
1305         def get(self):
1306             self.render('foo.html')
1307         def value(self):
1308             return self.get_argument("value")
1309     def get_app_kwargs(self):
1310         def my_ui_method(handler, x):
1311             return "In my_ui_method(%s) with handler value %s." % (
1312                 x, handler.value())
1313         class MyModule(UIModule):
1314             def render(self, x):
1315                 return "In MyModule(%s) with handler value %s." % (
1316                     x, self.handler.value())
1317         loader = DictLoader({
1318             'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',
1319         })
1320         return dict(template_loader=loader,
1321                     ui_methods={'my_ui_method': my_ui_method},
1322                     ui_modules={'MyModule': MyModule})
1323     def tearDown(self):
1324         super(UIMethodUIModuleTest, self).tearDown()
1325         RequestHandler._template_loaders.clear()
1326     def test_ui_method(self):
1327         response = self.fetch('/?value=asdf')
1328         self.assertEqual(response.body,
1329                          b'In my_ui_method(42) with handler value asdf. '
1330                          b'In MyModule(123) with handler value asdf.')
1331 @wsgi_safe
1332 class GetArgumentErrorTest(SimpleHandlerTestCase):
1333     class Handler(RequestHandler):
1334         def get(self):
1335             try:
1336                 self.get_argument('foo')
1337                 self.write({})
1338             except MissingArgumentError as e:
1339                 self.write({'arg_name': e.arg_name,
1340                             'log_message': e.log_message})
1341     def test_catch_error(self):
1342         response = self.fetch('/')
1343         self.assertEqual(json_decode(response.body),
1344                          {'arg_name': 'foo',
1345                           'log_message': 'Missing argument foo'})
1346 class MultipleExceptionTest(SimpleHandlerTestCase):
1347     class Handler(RequestHandler):
1348         exc_count = 0
1349         @asynchronous
1350         def get(self):
1351             from salt.ext.tornado.ioloop import IOLoop
1352             IOLoop.current().add_callback(lambda: 1 / 0)
1353             IOLoop.current().add_callback(lambda: 1 / 0)
1354         def log_exception(self, typ, value, tb):
1355             MultipleExceptionTest.Handler.exc_count += 1
1356     def test_multi_exception(self):
1357         response = self.fetch('/')
1358         self.assertEqual(response.code, 500)
1359         response = self.fetch('/')
1360         self.assertEqual(response.code, 500)
1361         self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)
1362 @wsgi_safe
1363 class SetLazyPropertiesTest(SimpleHandlerTestCase):
1364     class Handler(RequestHandler):
1365         def prepare(self):
1366             self.current_user = 'Ben'
1367             self.locale = locale.get('en_US')
1368         def get_user_locale(self):
1369             raise NotImplementedError()
1370         def get_current_user(self):
1371             raise NotImplementedError()
1372         def get(self):
1373             self.write('Hello %s (%s)' % (self.current_user, self.locale.code))
1374     def test_set_properties(self):
1375         response = self.fetch('/')
1376         self.assertEqual(response.body, b'Hello Ben (en_US)')
1377 @wsgi_safe
1378 class GetCurrentUserTest(WebTestCase):
1379     def get_app_kwargs(self):
1380         class WithoutUserModule(UIModule):
1381             def render(self):
1382                 return ''
1383         class WithUserModule(UIModule):
1384             def render(self):
1385                 return str(self.current_user)
1386         loader = DictLoader({
1387             'without_user.html': '',
1388             'with_user.html': '{{ current_user }}',
1389             'without_user_module.html': '{% module WithoutUserModule() %}',
1390             'with_user_module.html': '{% module WithUserModule() %}',
1391         })
1392         return dict(template_loader=loader,
1393                     ui_modules={'WithUserModule': WithUserModule,
1394                                 'WithoutUserModule': WithoutUserModule})
1395     def tearDown(self):
1396         super(GetCurrentUserTest, self).tearDown()
1397         RequestHandler._template_loaders.clear()
1398     def get_handlers(self):
1399         class CurrentUserHandler(RequestHandler):
1400             def prepare(self):
1401                 self.has_loaded_current_user = False
1402             def get_current_user(self):
1403                 self.has_loaded_current_user = True
1404                 return ''
1405         class WithoutUserHandler(CurrentUserHandler):
1406             def get(self):
1407                 self.render_string('without_user.html')
1408                 self.finish(str(self.has_loaded_current_user))
1409         class WithUserHandler(CurrentUserHandler):
1410             def get(self):
1411                 self.render_string('with_user.html')
1412                 self.finish(str(self.has_loaded_current_user))
1413         class CurrentUserModuleHandler(CurrentUserHandler):
1414             def get_template_namespace(self):
1415                 return self.ui
1416         class WithoutUserModuleHandler(CurrentUserModuleHandler):
1417             def get(self):
1418                 self.render_string('without_user_module.html')
1419                 self.finish(str(self.has_loaded_current_user))
1420         class WithUserModuleHandler(CurrentUserModuleHandler):
1421             def get(self):
1422                 self.render_string('with_user_module.html')
1423                 self.finish(str(self.has_loaded_current_user))
1424         return [('/without_user', WithoutUserHandler),
1425                 ('/with_user', WithUserHandler),
1426                 ('/without_user_module', WithoutUserModuleHandler),
1427                 ('/with_user_module', WithUserModuleHandler)]
1428     @unittest.skip('needs fix')
1429     def test_get_current_user_is_lazy(self):
1430         self.assertEqual(response.body, b'False')
1431     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def test_get_current_user_works(self):
1432         response = self.fetch('/with_user')
1433         self.assertEqual(response.body, b'True')
1434     def test_get_current_user_from_ui_module_is_lazy(self):
1435         response = self.fetch('/without_user_module')
1436         self.assertEqual(response.body, b'False')
1437     def test_get_current_user_from_ui_module_works(self):
1438         response = self.fetch('/with_user_module')
1439         self.assertEqual(response.</b></font>body, b'True')
1440 @wsgi_safe
1441 class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
1442     class Handler(RequestHandler):
1443         pass
1444     def test_unimplemented_standard_methods(self):
1445         for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:
1446             response = self.fetch('/', method=method)
1447             self.assertEqual(response.code, 405)
1448         for method in ['POST', 'PUT']:
1449             response = self.fetch('/', method=method, body=b'')
1450             self.assertEqual(response.code, 405)
1451 class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
1452     class Handler(RequestHandler):
1453         def other(self):
1454             self.write('other')
1455     def test_unimplemented_patch(self):
1456         response = self.fetch('/', method='PATCH', body=b'')
1457         self.assertEqual(response.code, 405)
1458     def test_unimplemented_other(self):
1459         response = self.fetch('/', method='OTHER',
1460                               allow_nonstandard_methods=True)
1461         self.assertEqual(response.code, 405)
1462 @wsgi_safe
1463 class AllHTTPMethodsTest(SimpleHandlerTestCase):
1464     class Handler(RequestHandler):
1465         def method(self):
1466             self.write(self.request.method)
1467         get = delete = options = post = put = method
1468     def test_standard_methods(self):
1469         response = self.fetch('/', method='HEAD')
1470         self.assertEqual(response.body, b'')
1471         for method in ['GET', 'DELETE', 'OPTIONS']:
1472             response = self.fetch('/', method=method)
1473             self.assertEqual(response.body, utf8(method))
1474         for method in ['POST', 'PUT']:
1475             response = self.fetch('/', method=method, body=b'')
1476             self.assertEqual(response.body, utf8(method))
1477 class PatchMethodTest(SimpleHandlerTestCase):
1478     class Handler(RequestHandler):
1479         SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)
1480         def patch(self):
1481             self.write('patch')
1482         def other(self):
1483             self.write('other')
1484     def test_patch(self):
1485         response = self.fetch('/', method='PATCH', body=b'')
1486         self.assertEqual(response.body, b'patch')
1487     def test_other(self):
1488         response = self.fetch('/', method='OTHER',
1489                               allow_nonstandard_methods=True)
1490         self.assertEqual(response.body, b'other')
1491 @wsgi_safe
1492 class FinishInPrepareTest(SimpleHandlerTestCase):
1493     class Handler(RequestHandler):
1494         def prepare(self):
1495             self.finish('done')
1496         def get(self):
1497             raise Exception('should not reach this method')
1498     def test_finish_in_prepare(self):
1499         response = self.fetch('/')
1500         self.assertEqual(response.body, b'done')
1501 @wsgi_safe
1502 class Default404Test(WebTestCase):
1503     def get_handlers(self):
1504         return [('/foo', RequestHandler)]
1505     def test_404(self):
1506         response = self.fetch('/')
1507         self.assertEqual(response.code, 404)
1508         self.assertEqual(response.body,
1509                          b'&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;'
1510                          b'&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;')
1511 @wsgi_safe
1512 class Custom404Test(WebTestCase):
1513     def get_handlers(self):
1514         return [('/foo', RequestHandler)]
1515     def get_app_kwargs(self):
1516         class Custom404Handler(RequestHandler):
1517             def get(self):
1518                 self.set_status(404)
1519                 self.write('custom 404 response')
1520         return dict(default_handler_class=Custom404Handler)
1521     def test_404(self):
1522         response = self.fetch('/')
1523         self.assertEqual(response.code, 404)
1524         self.assertEqual(response.body, b'custom 404 response')
1525 @wsgi_safe
1526 class DefaultHandlerArgumentsTest(WebTestCase):
1527     def get_handlers(self):
1528         return [('/foo', RequestHandler)]
1529     def get_app_kwargs(self):
1530         return dict(default_handler_class=ErrorHandler,
1531                     default_handler_args=dict(status_code=403))
1532     def test_403(self):
1533         response = self.fetch('/')
1534         self.assertEqual(response.code, 403)
1535 @wsgi_safe
1536 class HandlerByNameTest(WebTestCase):
1537     def get_handlers(self):
1538         return [('/hello1', HelloHandler),
1539                 ('/hello2', 'tornado.test.web_test.HelloHandler'),
1540                 url('/hello3', 'tornado.test.web_test.HelloHandler'),
1541                 ]
1542     def test_handler_by_name(self):
1543         resp = self.fetch('/hello1')
1544         self.assertEqual(resp.body, b'hello')
1545         resp = self.fetch('/hello2')
1546         self.assertEqual(resp.body, b'hello')
1547         resp = self.fetch('/hello3')
1548         self.assertEqual(resp.body, b'hello')
1549 class StreamingRequestBodyTest(WebTestCase):
1550     def get_handlers(self):
1551         @stream_request_body
1552         class StreamingBodyHandler(RequestHandler):
1553             def initialize(self, test):
1554                 self.test = test
1555             def prepare(self):
1556                 self.test.prepared.set_result(None)
1557             def data_received(self, data):
1558                 self.test.data.set_result(data)
1559             def get(self):
1560                 self.test.finished.set_result(None)
1561                 self.write({})
1562         @stream_request_body
1563         class EarlyReturnHandler(RequestHandler):
1564             def prepare(self):
1565                 raise HTTPError(401)
1566         @stream_request_body
1567         class CloseDetectionHandler(RequestHandler):
1568             def initialize(self, test):
1569                 self.test = test
1570             def on_connection_close(self):
1571                 super(CloseDetectionHandler, self).on_connection_close()
1572                 self.test.close_future.set_result(None)
1573         return [('/stream_body', StreamingBodyHandler, dict(test=self)),
1574                 ('/early_return', EarlyReturnHandler),
1575                 ('/close_detection', CloseDetectionHandler, dict(test=self))]
1576     def connect(self, url, connection_close):
1577         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
1578         s.connect(("127.0.0.1", self.get_http_port()))
1579         stream = IOStream(s, io_loop=self.io_loop)
1580         stream.write(b"GET " + url + b" HTTP/1.1\r\n")
1581         if connection_close:
1582             stream.write(b"Connection: close\r\n")
1583         stream.write(b"Transfer-Encoding: chunked\r\n\r\n")
1584         return stream
1585     @gen_test
1586     def test_streaming_body(self):
1587         self.prepared = Future()
1588         self.data = Future()
1589         self.finished = Future()
1590         stream = self.connect(b"/stream_body", connection_close=True)
1591         yield self.prepared
1592         stream.write(b"4\r\nasdf\r\n")
1593         data = yield self.data
1594         self.assertEqual(data, b"asdf")
1595         self.data = Future()
1596         stream.write(b"4\r\nqwer\r\n")
1597         data = yield self.data
1598         self.assertEquals(data, b"qwer")
1599         stream.write(b"0\r\n\r\n")
1600         yield self.finished
1601         data = yield gen.Task(stream.read_until_close)
1602         self.assertTrue(data.endswith(b"{}"))
1603         stream.close()
1604     @gen_test
1605     def test_early_return(self):
1606         stream = self.connect(b"/early_return", connection_close=False)
1607         data = yield gen.Task(stream.read_until_close)
1608         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1609     @gen_test
1610     def test_early_return_with_data(self):
1611         stream = self.connect(b"/early_return", connection_close=False)
1612         stream.write(b"4\r\nasdf\r\n")
1613         data = yield gen.Task(stream.read_until_close)
1614         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
1615     @gen_test
1616     def test_close_during_upload(self):
1617         self.close_future = Future()
1618         stream = self.connect(b"/close_detection", connection_close=False)
1619         stream.close()
1620         yield self.close_future
1621 @stream_request_body
1622 class BaseFlowControlHandler(RequestHandler):
1623     def initialize(self, test):
1624         self.test = test
1625         self.method = None
1626         self.methods = []
1627     @contextlib.contextmanager
1628     def in_method(self, method):
1629         if self.method is not None:
1630             self.test.fail("entered method %s while in %s" %
1631                            (method, self.method))
1632         self.method = method
1633         self.methods.append(method)
1634         try:
1635             yield
1636         finally:
1637             self.method = None
1638     @gen.coroutine
1639     def prepare(self):
1640         self.methods.append('prepare')
1641         yield gen.Task(IOLoop.current().add_callback)
1642     @gen.coroutine
1643     def post(self):
1644         with self.in_method('post'):
1645             yield gen.Task(IOLoop.current().add_callback)
1646         self.write(dict(methods=self.methods))
1647 class BaseStreamingRequestFlowControlTest(object):
1648     def get_httpserver_options(self):
1649         return dict(chunk_size=10, decompress_request=True)
1650     def get_http_client(self):
1651         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
1652     def test_flow_control_fixed_body(self):
1653         response = self.fetch('/', body='abcdefghijklmnopqrstuvwxyz',
1654                               method='POST')
1655         response.rethrow()
1656         self.assertEqual(json_decode(response.body),
1657                          dict(methods=['prepare', 'data_received',
1658                                        'data_received', 'data_received',
1659                                        'post']))
1660     def test_flow_control_chunked_body(self):
1661         chunks = [b'abcd', b'efgh', b'ijkl']
1662         @gen.coroutine
1663         def body_producer(write):
1664             for i in chunks:
1665                 yield write(i)
1666         response = self.fetch('/', body_producer=body_producer, method='POST')
1667         response.rethrow()
1668         self.assertEqual(json_decode(response.body),
1669                          dict(methods=['prepare', 'data_received',
1670                                        'data_received', 'data_received',
1671                                        'post']))
1672     def test_flow_control_compressed_body(self):
1673         bytesio = BytesIO()
1674         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
1675         gzip_file.write(b'abcdefghijklmnopqrstuvwxyz')
1676         gzip_file.close()
1677         compressed_body = bytesio.getvalue()
1678         response = self.fetch('/', body=compressed_body, method='POST',
1679                               headers={'Content-Encoding': 'gzip'})
1680         response.rethrow()
1681         self.assertEqual(json_decode(response.body),
1682                          dict(methods=['prepare', 'data_received',
1683                                        'data_received', 'data_received',
1684                                        'post']))
1685 class DecoratedStreamingRequestFlowControlTest(
1686         BaseStreamingRequestFlowControlTest,
1687         WebTestCase):
1688     def get_handlers(self):
1689         class DecoratedFlowControlHandler(BaseFlowControlHandler):
1690             @gen.coroutine
1691             def data_received(self, data):
1692                 with self.in_method('data_received'):
1693                     yield gen.Task(IOLoop.current().add_callback)
1694         return [('/', DecoratedFlowControlHandler, dict(test=self))]
1695 @skipBefore35
1696 class NativeStreamingRequestFlowControlTest(
1697         BaseStreamingRequestFlowControlTest,
1698         WebTestCase):
1699     def get_handlers(self):
1700         class NativeFlowControlHandler(BaseFlowControlHandler):
1701             data_received = exec_test(globals(), locals(), """
1702             async def data_received(self, data):
1703                 with self.in_method('data_received'):
1704                     await gen.Task(IOLoop.current().add_callback)
1705             """)["data_received"]
1706         return [('/', NativeFlowControlHandler, dict(test=self))]
1707 @wsgi_safe
1708 class IncorrectContentLengthTest(SimpleHandlerTestCase):
1709     def get_handlers(self):
1710         test = self
1711         self.server_error = None
1712         class TooHigh(RequestHandler):
1713             def get(self):
1714                 self.set_header("Content-Length", "42")
1715                 try:
1716                     self.finish("ok")
1717                 except Exception as e:
1718                     test.server_error = e
1719                     raise
1720         class TooLow(RequestHandler):
1721             def get(self):
1722                 self.set_header("Content-Length", "2")
1723                 try:
1724                     self.finish("hello")
1725                 except Exception as e:
1726                     test.server_error = e
1727                     raise
1728         return [('/high', TooHigh),
1729                 ('/low', TooLow)]
1730     def test_content_length_too_high(self):
1731         with ExpectLog(app_log, "(Uncaught exception|Exception in callback)"):
1732             with ExpectLog(gen_log,
1733                            "(Cannot send error response after headers written"
1734                            "|Failed to flush partial response)"):
1735                 response = self.fetch("/high")
1736         self.assertEqual(response.code, 599)
1737         self.assertEqual(str(self.server_error),
1738                          "Tried to write 40 bytes less than Content-Length")
1739     def test_content_length_too_low(self):
1740         with ExpectLog(app_log, "(Uncaught exception|Exception in callback)"):
1741             with ExpectLog(gen_log,
1742                            "(Cannot send error response after headers written"
1743                            "|Failed to flush partial response)"):
1744                 response = self.fetch("/low")
1745         self.assertEqual(response.code, 599)
1746         self.assertEqual(str(self.server_error),
1747                          "Tried to write more data than Content-Length")
1748 class ClientCloseTest(SimpleHandlerTestCase):
1749     class Handler(RequestHandler):
1750         def get(self):
1751             if self.request.version.startswith('HTTP/1'):
1752                 self.request.connection.stream.close()
1753                 self.write('hello')
1754             else:
1755                 self.write('requires HTTP/1.x')
1756     def test_client_close(self):
1757         response = self.fetch('/')
1758         if response.body == b'requires HTTP/1.x':
1759             self.skipTest('requires HTTP/1.x')
1760         self.assertEqual(response.code, 599)
1761 class SignedValueTest(unittest.TestCase):
1762     SECRET = "It's a secret to everybody"
1763     SECRET_DICT = {0: "asdfbasdf", 1: "12312312", 2: "2342342"}
1764     def past(self):
1765         return self.present() - 86400 * 32
1766     def present(self):
1767         return 1300000000
1768     def test_known_values(self):
1769         signed_v1 = create_signed_value(SignedValueTest.SECRET, "key", "value",
1770                                         version=1, clock=self.present)
1771         self.assertEqual(
1772             signed_v1,
1773             b"dmFsdWU=|1300000000|31c934969f53e48164c50768b40cbd7e2daaaa4f")
1774         signed_v2 = create_signed_value(SignedValueTest.SECRET, "key", "value",
1775                                         version=2, clock=self.present)
1776         self.assertEqual(
1777             signed_v2,
1778             b"2|1:0|10:1300000000|3:key|8:dmFsdWU=|"
1779             b"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152")
1780         signed_default = create_signed_value(SignedValueTest.SECRET,
1781                                              "key", "value", clock=self.present)
1782         self.assertEqual(signed_default, signed_v2)
1783         decoded_v1 = decode_signed_value(SignedValueTest.SECRET, "key",
1784                                          signed_v1, min_version=1,
1785                                          clock=self.present)
1786         self.assertEqual(decoded_v1, b"value")
1787         decoded_v2 = decode_signed_value(SignedValueTest.SECRET, "key",
1788                                          signed_v2, min_version=2,
1789                                          clock=self.present)
1790         self.assertEqual(decoded_v2, b"value")
1791     def test_name_swap(self):
1792         signed1 = create_signed_value(SignedValueTest.SECRET, "key1", "value",
1793                                       clock=self.present)
1794         signed2 = create_signed_value(SignedValueTest.SECRET, "key2", "value",
1795                                       clock=self.present)
1796         decoded1 = decode_signed_value(SignedValueTest.SECRET, "key2", signed1,
1797                                        clock=self.present)
1798         self.assertIs(decoded1, None)
1799         decoded2 = decode_signed_value(SignedValueTest.SECRET, "key1", signed2,
1800                                        clock=self.present)
1801         self.assertIs(decoded2, None)
1802     def test_expired(self):
1803         signed = create_signed_value(SignedValueTest.SECRET, "key1", "value",
1804                                      clock=self.past)
1805         decoded_past = decode_signed_value(SignedValueTest.SECRET, "key1",
1806                                            signed, clock=self.past)
1807         self.assertEqual(decoded_past, b"value")
1808         decoded_present = decode_signed_value(SignedValueTest.SECRET, "key1",
1809                                               signed, clock=self.present)
1810         self.assertIs(decoded_present, None)
1811     def test_payload_tampering(self):
1812         sig = "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"
1813         def validate(prefix):
1814             return (b'value' ==
1815                     decode_signed_value(SignedValueTest.SECRET, "key",
1816                                         prefix + sig, clock=self.present))
1817         self.assertTrue(validate("2|1:0|10:1300000000|3:key|8:dmFsdWU=|"))
1818         self.assertFalse(validate("2|1:1|10:1300000000|3:key|8:dmFsdWU=|"))
1819         self.assertFalse(validate("2|1:0|10:130000000|3:key|8:dmFsdWU=|"))
1820         self.assertFalse(validate("2|1:0|10:1300000000|3:keey|8:dmFsdWU=|"))
1821     def test_signature_tampering(self):
1822         prefix = "2|1:0|10:1300000000|3:key|8:dmFsdWU=|"
1823         def validate(sig):
1824             return (b'value' ==
1825                     decode_signed_value(SignedValueTest.SECRET, "key",
1826                                         prefix + sig, clock=self.present))
1827         self.assertTrue(validate(
1828             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"))
1829         self.assertFalse(validate("0" * 32))
1830         self.assertFalse(validate(
1831             "4d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"))
1832         self.assertFalse(validate(
1833             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e153"))
1834         self.assertFalse(validate(
1835             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e15"))
1836         self.assertFalse(validate(
1837             "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e1538"))
1838     def test_non_ascii(self):
1839         value = b"\xe9"
1840         signed = create_signed_value(SignedValueTest.SECRET, "key", value,
1841                                      clock=self.present)
1842         decoded = decode_signed_value(SignedValueTest.SECRET, "key", signed,
1843                                       clock=self.present)
1844         self.assertEqual(value, decoded)
1845     def test_key_versioning_read_write_default_key(self):
1846         value = b"\xe9"
1847         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1848                                      "key", value, clock=self.present,
1849                                      key_version=0)
1850         decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
1851                                       "key", signed, clock=self.present)
1852         self.assertEqual(value, decoded)
1853     def test_key_versioning_read_write_non_default_key(self):
1854         value = b"\xe9"
1855         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1856                                      "key", value, clock=self.present,
1857                                      key_version=1)
1858         decoded = decode_signed_value(SignedValueTest.SECRET_DICT,
1859                                       "key", signed, clock=self.present)
1860         self.assertEqual(value, decoded)
1861     def test_key_versioning_invalid_key(self):
1862         value = b"\xe9"
1863         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1864                                      "key", value, clock=self.present,
1865                                      key_version=0)
1866         newkeys = SignedValueTest.SECRET_DICT.copy()
1867         newkeys.pop(0)
1868         decoded = decode_signed_value(newkeys,
1869                                       "key", signed, clock=self.present)
1870         self.assertEqual(None, decoded)
1871     def test_key_version_retrieval(self):
1872         value = b"\xe9"
1873         signed = create_signed_value(SignedValueTest.SECRET_DICT,
1874                                      "key", value, clock=self.present,
1875                                      key_version=1)
1876         key_version = get_signature_key_version(signed)
1877         self.assertEqual(1, key_version)
1878 @wsgi_safe
1879 class XSRFTest(SimpleHandlerTestCase):
1880     class Handler(RequestHandler):
1881         def get(self):
1882             version = int(self.get_argument("version", "2"))
1883             self.settings["xsrf_cookie_version"] = version
1884             self.write(self.xsrf_token)
1885         def post(self):
1886             self.write("ok")
1887     def get_app_kwargs(self):
1888         return dict(xsrf_cookies=True)
1889     def setUp(self):
1890         super(XSRFTest, self).setUp()
1891         self.xsrf_token = self.get_token()
1892     def get_token(self, old_token=None, version=None):
1893         if old_token is not None:
1894             headers = self.cookie_headers(old_token)
1895         else:
1896             headers = None
1897         response = self.fetch(
1898             "/" if version is None else ("/?version=%d" % version),
1899             headers=headers)
1900         response.rethrow()
1901         return native_str(response.body)
1902     def cookie_headers(self, token=None):
1903         if token is None:
1904             token = self.xsrf_token
1905         return {"Cookie": "_xsrf=" + token}
1906     def test_xsrf_fail_no_token(self):
1907         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
1908             response = self.fetch("/", method="POST", body=b"")
1909         self.assertEqual(response.code, 403)
1910     def test_xsrf_fail_body_no_cookie(self):
1911         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
1912             response = self.fetch(
1913                 "/", method="POST",
1914                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
1915         self.assertEqual(response.code, 403)
1916     def test_xsrf_fail_argument_invalid_format(self):
1917         with ExpectLog(gen_log, ".*'_xsrf' argument has invalid format"):
1918             response = self.fetch(
1919                 "/", method="POST",
1920                 headers=self.cookie_headers(),
1921                 body=urllib_parse.urlencode(dict(_xsrf='3|')))
1922         self.assertEqual(response.code, 403)
1923     def test_xsrf_fail_cookie_invalid_format(self):
1924         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
1925             response = self.fetch(
1926                 "/", method="POST",
1927                 headers=self.cookie_headers(token='3|'),
1928                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))
1929         self.assertEqual(response.code, 403)
1930     def test_xsrf_fail_cookie_no_body(self):
1931         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
1932             response = self.fetch(
1933                 "/", method="POST", body=b"",
1934                 headers=self.cookie_headers())
1935         self.assertEqual(response.code, 403)
1936     def test_xsrf_success_short_token(self):
1937         response = self.fetch(
1938             "/", method="POST",
1939             body=urllib_parse.urlencode(dict(_xsrf='deadbeef')),
1940             headers=self.cookie_headers(token='deadbeef'))
1941         self.assertEqual(response.code, 200)
1942     def test_xsrf_success_non_hex_token(self):
1943         response = self.fetch(
1944             "/", method="POST",
1945             body=urllib_parse.urlencode(dict(_xsrf='xoxo')),
1946             headers=self.cookie_headers(token='xoxo'))
1947         self.assertEqual(response.code, 200)
1948     def test_xsrf_success_post_body(self):
1949         response = self.fetch(
1950             "/", method="POST",
1951             body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
1952             headers=self.cookie_headers())
1953         self.assertEqual(response.code, 200)
1954     def test_xsrf_success_query_string(self):
1955         response = self.fetch(
1956             "/?" + urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
1957             method="POST", body=b"",
1958             headers=self.cookie_headers())
1959         self.assertEqual(response.code, 200)
1960     def test_xsrf_success_header(self):
1961         response = self.fetch("/", method="POST", body=b"",
1962                               headers=dict({"X-Xsrftoken": self.xsrf_token},  # type: ignore
1963                                            **self.cookie_headers()))
1964         self.assertEqual(response.code, 200)
1965     def test_distinct_tokens(self):
1966         NUM_TOKENS = 10
1967         tokens = set()
1968         for i in range(NUM_TOKENS):
1969             tokens.add(self.get_token())
1970         self.assertEqual(len(tokens), NUM_TOKENS)
1971     def test_cross_user(self):
1972         token2 = self.get_token()
1973         for token in (self.xsrf_token, token2):
1974             response = self.fetch(
1975                 "/", method="POST",
1976                 body=urllib_parse.urlencode(dict(_xsrf=token)),
1977                 headers=self.cookie_headers(token))
1978             self.assertEqual(response.code, 200)
1979         for cookie_token, body_token in ((self.xsrf_token, token2),
1980                                          (token2, self.xsrf_token)):
1981             with ExpectLog(gen_log, '.*XSRF cookie does not match POST'):
1982                 response = self.fetch(
1983                     "/", method="POST",
1984                     body=urllib_parse.urlencode(dict(_xsrf=body_token)),
1985                     headers=self.cookie_headers(cookie_token))
1986             self.assertEqual(response.code, 403)
1987     def test_refresh_token(self):
1988         token = self.xsrf_token
1989         tokens_seen = set([token])
1990         for i in range(5):
1991             token = self.get_token(token)
1992             tokens_seen.add(token)
1993             response = self.fetch(
1994                 "/", method="POST",
1995                 body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),
1996                 headers=self.cookie_headers(token))
1997             self.assertEqual(response.code, 200)
1998         self.assertEqual(len(tokens_seen), 6)
1999     def test_versioning(self):
2000         self.assertNotEqual(self.get_token(version=1),
2001                             self.get_token(version=1))
2002         v1_token = self.get_token(version=1)
2003         for i in range(5):
2004             self.assertEqual(self.get_token(v1_token, version=1), v1_token)
2005         v2_token = self.get_token(v1_token)
2006         self.assertNotEqual(v1_token, v2_token)
2007         self.assertNotEqual(v2_token, self.get_token(v1_token))
2008         for cookie_token, body_token in ((v1_token, v2_token),
2009                                          (v2_token, v1_token)):
2010             response = self.fetch(
2011                 "/", method="POST",
2012                 body=urllib_parse.urlencode(dict(_xsrf=body_token)),
2013                 headers=self.cookie_headers(cookie_token))
2014             self.assertEqual(response.code, 200)
2015 @wsgi_safe
2016 class XSRFCookieKwargsTest(SimpleHandlerTestCase):
2017     class Handler(RequestHandler):
2018         def get(self):
2019             self.write(self.xsrf_token)
2020     def get_app_kwargs(self):
2021         return dict(xsrf_cookies=True,
2022                     xsrf_cookie_kwargs=dict(httponly=True))
2023     def test_xsrf_httponly(self):
2024         response = self.fetch("/")
2025         self.assertIn('httponly;', response.headers['Set-Cookie'].lower())
2026 @wsgi_safe
2027 class FinishExceptionTest(SimpleHandlerTestCase):
2028     class Handler(RequestHandler):
2029         def get(self):
2030             self.set_status(401)
2031             self.set_header('WWW-Authenticate', 'Basic realm="something"')
2032             if self.get_argument('finish_value', ''):
2033                 raise Finish('authentication required')
2034             else:
2035                 self.write('authentication required')
2036                 raise Finish()
2037     def test_finish_exception(self):
2038         for u in ['/', '/?finish_value=1']:
2039             response = self.fetch(u)
2040             self.assertEqual(response.code, 401)
2041             self.assertEqual('Basic realm="something"',
2042                              response.headers.get('WWW-Authenticate'))
2043             self.assertEqual(b'authentication required', response.body)
2044 @wsgi_safe
2045 class DecoratorTest(WebTestCase):
2046     def get_handlers(self):
2047         class RemoveSlashHandler(RequestHandler):
2048             @removeslash
2049             def get(self):
2050                 pass
2051         class AddSlashHandler(RequestHandler):
2052             @addslash
2053             def get(self):
2054                 pass
2055         return [("/removeslash/", RemoveSlashHandler),
2056                 ("/addslash", AddSlashHandler),
2057                 ]
2058     def test_removeslash(self):
2059         response = self.fetch("/removeslash/", follow_redirects=False)
2060         self.assertEqual(response.code, 301)
2061         self.assertEqual(response.headers['Location'], "/removeslash")
2062         response = self.fetch("/removeslash/?foo=bar", follow_redirects=False)
2063         self.assertEqual(response.code, 301)
2064         self.assertEqual(response.headers['Location'], "/removeslash?foo=bar")
2065     def test_addslash(self):
2066         response = self.fetch("/addslash", follow_redirects=False)
2067         self.assertEqual(response.code, 301)
2068         self.assertEqual(response.headers['Location'], "/addslash/")
2069         response = self.fetch("/addslash?foo=bar", follow_redirects=False)
2070         self.assertEqual(response.code, 301)
2071         self.assertEqual(response.headers['Location'], "/addslash/?foo=bar")
2072 @wsgi_safe
2073 class CacheTest(WebTestCase):
2074     def get_handlers(self):
2075         class EtagHandler(RequestHandler):
2076             def get(self, computed_etag):
2077                 self.write(computed_etag)
2078             def compute_etag(self):
2079                 return self._write_buffer[0]
2080         return [
2081             ('/etag/(.*)', EtagHandler)
2082         ]
2083     def test_wildcard_etag(self):
2084         computed_etag = '"xyzzy"'
2085         etags = '*'
2086         self._test_etag(computed_etag, etags, 304)
2087     def test_strong_etag_match(self):
2088         computed_etag = '"xyzzy"'
2089         etags = '"xyzzy"'
2090         self._test_etag(computed_etag, etags, 304)
2091     def test_multiple_strong_etag_match(self):
2092         computed_etag = '"xyzzy1"'
2093         etags = '"xyzzy1", "xyzzy2"'
2094         self._test_etag(computed_etag, etags, 304)
2095     def test_strong_etag_not_match(self):
2096         computed_etag = '"xyzzy"'
2097         etags = '"xyzzy1"'
2098         self._test_etag(computed_etag, etags, 200)
2099     def test_multiple_strong_etag_not_match(self):
2100         computed_etag = '"xyzzy"'
2101         etags = '"xyzzy1", "xyzzy2"'
2102         self._test_etag(computed_etag, etags, 200)
2103     def test_weak_etag_match(self):
2104         computed_etag = '"xyzzy1"'
2105         etags = 'W/"xyzzy1"'
2106         self._test_etag(computed_etag, etags, 304)
2107     def test_multiple_weak_etag_match(self):
2108         computed_etag = '"xyzzy2"'
2109         etags = 'W/"xyzzy1", W/"xyzzy2"'
2110         self._test_etag(computed_etag, etags, 304)
2111     def test_weak_etag_not_match(self):
2112         computed_etag = '"xyzzy2"'
2113         etags = 'W/"xyzzy1"'
2114         self._test_etag(computed_etag, etags, 200)
2115     def test_multiple_weak_etag_not_match(self):
2116         computed_etag = '"xyzzy3"'
2117         etags = 'W/"xyzzy1", W/"xyzzy2"'
2118         self._test_etag(computed_etag, etags, 200)
2119     def _test_etag(self, computed_etag, etags, status_code):
2120         response = self.fetch(
2121             '/etag/' + computed_etag,
2122             headers={'If-None-Match': etags}
2123         )
2124         self.assertEqual(response.code, status_code)
2125 @wsgi_safe
2126 class RequestSummaryTest(SimpleHandlerTestCase):
2127     class Handler(RequestHandler):
2128         def get(self):
2129             self.request.remote_ip = None
2130             self.finish(self._request_summary())
2131     def test_missing_remote_ip(self):
2132         resp = self.fetch("/")
2133         self.assertEqual(resp.body, b"GET / (None)")
2134 class HTTPErrorTest(unittest.TestCase):
2135     def test_copy(self):
2136         e = HTTPError(403, reason="Go away")
2137         e2 = copy.copy(e)
2138         self.assertIsNot(e, e2)
2139         self.assertEqual(e.status_code, e2.status_code)
2140         self.assertEqual(e.reason, e2.reason)
2141 class ApplicationTest(AsyncTestCase):
2142     def test_listen(self):
2143         app = Application([])
2144         server = app.listen(0, address='127.0.0.1')
2145         server.stop()
2146 class URLSpecReverseTest(unittest.TestCase):
2147     def test_reverse(self):
2148         self.assertEqual('/favicon.ico', url(r'/favicon\.ico', None).reverse())
2149         self.assertEqual('/favicon.ico', url(r'^/favicon\.ico$', None).reverse())
2150     def test_non_reversible(self):
2151         paths = [
2152             r'^/api/v\d+/foo/(\w+)$',
2153         ]
2154         for path in paths:
2155             url_spec = url(path, None)
2156             try:
2157                 result = url_spec.reverse()
2158                 self.fail("did not get expected exception when reversing %s. "
2159                           "result: %s" % (path, result))
2160             except ValueError:
2161                 pass
2162     def test_reverse_arguments(self):
2163         self.assertEqual('/api/v1/foo/bar',
2164                          url(r'^/api/v1/foo/(\w+)$', None).reverse('bar'))
2165 class RedirectHandlerTest(WebTestCase):
2166     def get_handlers(self):
2167         return [
2168             ('/src', WebRedirectHandler, {'url': '/dst'}),
2169             (r'/(.*?)/(.*?)/(.*)', WebRedirectHandler, {'url': '/{1}/{0}/{2}'})]
2170     def test_basic_redirect(self):
2171         response = self.fetch('/src', follow_redirects=False)
2172         self.assertEqual(response.code, 301)
2173         self.assertEqual(response.headers['Location'], '/dst')
2174     def test_redirect_pattern(self):
2175         response = self.fetch('/a/b/c', follow_redirects=False)
2176         self.assertEqual(response.code, 301)
2177         self.assertEqual(response.headers['Location'], '/b/a/c')
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
