<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for openstack.py &amp; boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for openstack.py &amp; boto_apigateway.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>openstack.py (1.3289037%)<th>boto_apigateway.py (0.4743083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(867-873)<td><a href="#" name="0">(1155-1163)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>openstack.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import logging
import os
import pprint
import socket
import salt.config as config
import salt.utils.versions
from salt.exceptions import (
    SaltCloudConfigError,
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
    SaltCloudSystemExit,
)
try:
    import shade
    import shade.openstackcloud
    import shade.exc
    import os_client_config
    HAS_SHADE = (
        salt.utils.versions._LooseVersion(shade.__version__)
        &gt;= salt.utils.versions._LooseVersion("1.19.0"),
        "Please install newer version of shade: &gt;= 1.19.0",
    )
except ImportError:
    HAS_SHADE = (False, "Install pypi module shade &gt;= 1.19.0")
log = logging.getLogger(__name__)
__virtualname__ = "openstack"
def __virtual__():
    if get_configured_provider() is False:
        return False
    if get_dependencies() is False:
        return HAS_SHADE
    return __virtualname__
def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__
def get_configured_provider():
    provider = config.is_provider_configured(
        __opts__,
        _get_active_provider_name() or __virtualname__,
        ("auth", "region_name"),
    )
    if provider:
        return provider
    return config.is_provider_configured(
        __opts__,
        _get_active_provider_name() or __virtualname__,
        ("cloud", "region_name"),
    )
def get_dependencies():
    if not HAS_SHADE:
        log.warning('"shade" not found')
        return False
    elif hasattr(HAS_SHADE, "__len__") and not HAS_SHADE[0]:
        log.warning(HAS_SHADE[1])
        return False
    deps = {"shade": HAS_SHADE[0], "os_client_config": HAS_SHADE[0]}
    return config.check_driver_dependencies(__virtualname__, deps)
def preferred_ip(vm_, ips):
    proto = config.get_cloud_config_value(
        "protocol", vm_, __opts__, default="ipv4", search_global=False
    )
    family = socket.AF_INET
    if proto == "ipv6":
        family = socket.AF_INET6
    for ip in ips:
        ignore_ip = ignore_cidr(vm_, ip)
        if ignore_ip:
            continue
        try:
            socket.inet_pton(family, ip)
            return ip
        except Exception:  # pylint: disable=broad-except
            continue
    return False
def ignore_cidr(vm_, ip):
    from ipaddress import ip_address, ip_network
    cidrs = config.get_cloud_config_value(
        "ignore_cidr", vm_, __opts__, default=[], search_global=False
    )
    if cidrs and isinstance(cidrs, str):
        cidrs = [cidrs]
    for cidr in cidrs or []:
        if ip_address(ip) in ip_network(cidr):
            log.warning("IP %r found within %r; ignoring it.", ip, cidr)
            return True
    return False
def ssh_interface(vm_):
    return config.get_cloud_config_value(
        "ssh_interface", vm_, __opts__, default="public_ips", search_global=False
    )
def get_conn():
    if _get_active_provider_name() in __context__:
        return __context__[_get_active_provider_name()]
    vm_ = get_configured_provider()
    profile = vm_.pop("profile", None)
    if profile is not None:
        vm_ = __utils__["dictupdate.update"](
            os_client_config.vendors.get_profile(profile), vm_
        )
    conn = shade.openstackcloud.OpenStackCloud(cloud_config=None, **vm_)
    if _get_active_provider_name() is not None:
        __context__[_get_active_provider_name()] = conn
    return conn
def list_nodes(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes function must be called with -f or --function."
        )
    ret = {}
    for node, info in list_nodes_full(conn=conn).items():
        for key in (
            "id",
            "name",
            "size",
            "state",
            "private_ips",
            "public_ips",
            "floating_ips",
            "fixed_ips",
            "image",
        ):
            ret.setdefault(node, {}).setdefault(key, info.get(key))
    return ret
def list_nodes_min(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes_min function must be called with -f or --function."
        )
    if conn is None:
        conn = get_conn()
    ret = {}
    for node in conn.list_servers(bare=True):
        ret[node.name] = {"id": node.id, "state": node.status}
    return ret
def _get_ips(node, addr_type="public"):
    ret = []
    for _, interface in node.addresses.items():
        for addr in interface:
            if addr_type in ("floating", "fixed") and addr_type == addr.get(
                "OS-EXT-IPS:type"
            ):
                ret.append(addr["addr"])
            elif addr_type == "public" and __utils__["cloud.is_public_ip"](
                addr["addr"]
            ):
                ret.append(addr["addr"])
            elif addr_type == "private" and not __utils__["cloud.is_public_ip"](
                addr["addr"]
            ):
                ret.append(addr["addr"])
    return ret
def list_nodes_full(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes_full function must be called with -f or --function."
        )
    if conn is None:
        conn = get_conn()
    ret = {}
    for node in conn.list_servers(detailed=True):
        ret[node.name] = dict(node)
        ret[node.name]["id"] = node.id
        ret[node.name]["name"] = node.name
        ret[node.name]["size"] = node.flavor.name
        ret[node.name]["state"] = node.status
        ret[node.name]["private_ips"] = _get_ips(node, "private")
        ret[node.name]["public_ips"] = _get_ips(node, "public")
        ret[node.name]["floating_ips"] = _get_ips(node, "floating")
        ret[node.name]["fixed_ips"] = _get_ips(node, "fixed")
        if isinstance(node.image, str):
            ret[node.name]["image"] = node.image
        else:
            ret[node.name]["image"] = getattr(
                conn.get_image(node.image.id), "name", node.image.id
            )
    return ret
def list_nodes_select(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes_select function must be called with -f or --function."
        )
    return __utils__["cloud.list_nodes_select"](
        list_nodes(conn, "function"), __opts__["query.selection"], call
    )
def show_instance(name, conn=None, call=None):
    if call != "action":
        raise SaltCloudSystemExit(
            "The show_instance action must be called with -a or --action."
        )
    if conn is None:
        conn = get_conn()
    node = conn.get_server(name, bare=True)
    ret = dict(node)
    ret["id"] = node.id
    ret["name"] = node.name
    ret["size"] = conn.get_flavor(node.flavor.id).name
    ret["state"] = node.status
    ret["private_ips"] = _get_ips(node, "private")
    ret["public_ips"] = _get_ips(node, "public")
    ret["floating_ips"] = _get_ips(node, "floating")
    ret["fixed_ips"] = _get_ips(node, "fixed")
    if isinstance(node.image, str):
        ret["image"] = node.image
    else:
        ret["image"] = getattr(conn.get_image(node.image.id), "name", node.image.id)
    return ret
def avail_images(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_images function must be called with "
            "-f or --function, or with the --list-images option"
        )
    if conn is None:
        conn = get_conn()
    return conn.list_images()
def avail_sizes(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_sizes function must be called with "
            "-f or --function, or with the --list-sizes option"
        )
    if conn is None:
        conn = get_conn()
    return conn.list_flavors()
def list_networks(conn=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_networks function must be called with -f or --function"
        )
    if conn is None:
        conn = get_conn()
    return conn.list_networks()
def list_subnets(conn=None, call=None, kwargs=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_subnets function must be called with -f or --function."
        )
    if conn is None:
        conn = get_conn()
    if kwargs is None or (isinstance(kwargs, dict) and "network" not in kwargs):
        raise SaltCloudSystemExit("A `network` must be specified")
    return conn.list_subnets(filters={"network": kwargs["network"]})
def _clean_create_kwargs(**kwargs):
    VALID_OPTS = {
        "name": (str,),
        "image": (str,),
        "flavor": (str,),
        "auto_ip": bool,
        "ips": list,
        "ip_pool": (str,),
        "root_volume": (str,),
        "boot_volume": (str,),
        "terminate_volume": bool,
        "volumes": list,
        "meta": dict,
        "files": dict,
        "reservation_id": (str,),
        "security_groups": list,
        "key_name": (str,),
        "availability_zone": (str,),
        "block_device_mapping": list,
        "block_device_mapping_v2": list,
        "nics": list,
        "scheduler_hints": dict,
        "config_drive": bool,
        "disk_config": (str,),  # AUTO or MANUAL
        "admin_pass": (str,),
        "wait": bool,
        "timeout": int,
        "reuse_ips": bool,
        "network": (dict, list),
        "boot_from_volume": bool,
        "volume_size": int,
        "nat_destination": (str,),
        "group": (str,),
        "userdata": (str,),
    }
    extra = kwargs.pop("extra", {})
    for key, value in kwargs.copy().items():
        if key in VALID_OPTS:
            if isinstance(value, VALID_OPTS[key]):
                continue
            log.error("Error %s: %s is not of type %s", key, value, VALID_OPTS[key])
        kwargs.pop(key)
    return __utils__["dictupdate.update"](kwargs, extra)
def request_instance(vm_, conn=None, call=None):
    if call == "function":
        raise SaltCloudSystemExit(
            "The request_instance action must be called with -a or --action."
        )
    kwargs = copy.deepcopy(vm_)
    log.info("Creating Cloud VM %s", vm_["name"])
    __utils__["cloud.check_name"](vm_["name"], "a-zA-Z0-9._-")
    if conn is None:
        conn = get_conn()
    userdata = config.get_cloud_config_value(
        "userdata", vm_, __opts__, search_global=False, default=None
    )
    if userdata is not None and os.path.isfile(userdata):
        try:
            with __utils__["files.fopen"](userdata, "r") as fp_:
                kwargs["userdata"] = __utils__["cloud.userdata_template"](
                    __opts__, vm_, fp_.read()
                )
        except Exception as exc:  # pylint: disable=broad-except
            log.exception("Failed to read userdata from %s: %s", userdata, exc)
    if "size" in kwargs:
        kwargs["flavor"] = kwargs.pop("size")
    kwargs["key_name"] = config.get_cloud_config_value(
        "ssh_key_name", vm_, __opts__, search_global=False, default=None
    )
    kwargs["wait"] = True
    try:
        conn.create_server(**_clean_create_kwargs(**kwargs))
    except shade.exc.OpenStackCloudException as exc:
        log.error("Error creating server %s: %s", vm_["name"], exc)
        destroy(vm_["name"], conn=conn, call="action")
        raise SaltCloudSystemExit(str(exc))
    return show_instance(vm_["name"], conn=conn, call="action")
def create(vm_):
    deploy = config.get_cloud_config_value("deploy", vm_, __opts__)
    key_filename = config.get_cloud_config_value(
        "ssh_key_file", vm_, __opts__, search_global=False, default=None
    )
    if key_filename is not None and not os.path.isfile(key_filename):
        raise SaltCloudConfigError(
            "The defined ssh_key_file '{}' does not exist".format(key_filename)
        )
    vm_["key_filename"] = key_filename
    __utils__["cloud.fire_event"](
        "event",
        "starting create",
        "salt/cloud/{}/creating".format(vm_["name"]),
        args=__utils__["cloud.filter_event"](
            "creating", vm_, ["name", "profile", "provider", "driver"]
        ),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    conn = get_conn()
    if "instance_id" in vm_:
        if "pub_key" not in vm_ and "priv_key" not in vm_:
            log.debug("Generating minion keys for '%s'", vm_["name"])
            vm_["priv_key"], vm_["pub_key"] = __utils__["cloud.gen_keys"](
                config.get_cloud_config_value("keysize", vm_, __opts__)
            )
    else:
        request_instance(conn=conn, call="action", vm_=vm_)
    data = show_instance(vm_.get("instance_id", vm_["name"]), conn=conn, call="action")
    log.debug("VM is now running")
    def __query_node(vm_):
        data = show_instance(vm_["name"], conn=conn, call="action")
        if "wait_for_metadata" in vm_:
            for key, value in vm_.get("wait_for_metadata", {}).items():
                log.debug("Waiting for metadata: %s=%s", key, value)
                if data["metadata"].get(key, None) != value:
                    log.debug(
                        "Metadata is not ready: %s=%s", key, data["metadata"].get(key)
                    )
                    return False
        return preferred_ip(vm_, data[ssh_interface(vm_)])
    try:
        ip_address = __utils__["cloud.wait_for_fun"](__query_node, vm_=vm_)
    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
        try:
            destroy(vm_["name"])
        except SaltCloudSystemExit:
            pass
        finally:
            raise SaltCloudSystemExit(str(exc))
    log.debug("Using IP address %s", ip_address)
    salt_interface = __utils__["cloud.get_salt_interface"](vm_, __opts__)
    salt_ip_address = preferred_ip(vm_, data[salt_interface])
    log.debug("Salt interface set to: %s", salt_ip_address)
    if not ip_address:
        raise SaltCloudSystemExit("A valid IP address was not found")
    vm_["ssh_host"] = ip_address
    vm_["salt_host"] = salt_ip_address
    ret = __utils__["cloud.bootstrap"](vm_, __opts__)
    ret.update(data)
    log.info("Created Cloud VM '%s'", vm_["name"])
    log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
    event_data = {
        "name": vm_["name"],
        "profile": vm_["profile"],
        "provider": vm_["driver"],
        "instance_id": data["id"],
        "floating_ips": data["floating_ips"],
        "fixed_ips": data["fixed_ips"],
        "private_ips": data["private_ips"],
        "public_ips": data["public_ips"],
    }
    __utils__["cloud.fire_event"](
        "event",
        "created instance",
        "salt/cloud/{}/created".format(vm_["name"]),
        args=__utils__["cloud.filter_event"]("created", event_data, list(event_data)),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    __utils__["cloud.cachedir_index_add"](
        vm_["name"], vm_["profile"], "nova", vm_["driver"]
    )
    return ret
def destroy(name, conn=None, call=None):
    if call == "function":
        raise SaltCloudSystemExit(
            "The destroy action must be called with -d, --destroy, -a or --action."
        )
    __utils__["cloud.fire_event"](
        "event",
        "destroying instance",
        "salt/cloud/{}/destroying".format(name),
        args={"name": name},
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    if not conn:
        conn = get_conn()
    node = show_instance(name, conn=conn, call="action")
    log.info("Destroying VM: %s", name)
    ret = conn.delete_server(name)
    if ret:
        log.info("Destroyed VM: %s", name)
<a name="0"></a>        __utils__["cloud.fire_event"](
            "event",
            "destroyed instance",
            "salt/cloud/{}/destroyed"<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(name),
            args={"name": name},
            sock_dir=__opts__["sock_dir"],
            transport=__opts__["transport"],
        )
        if __opts__.get("delete_sshkeys", False) is True:
            __utils__[</b></font>"cloud.remove_sshkey"](
                getattr(node, __opts__.get("ssh_interface", "public_ips"))[0]
            )
        if __opts__.get("update_cachedir", False) is True:
            __utils__["cloud.delete_minion_cachedir"](
                name, _get_active_provider_name().split(":")[0], __opts__
            )
        __utils__["cloud.cachedir_index_del"](name)
        return True
    log.error("Failed to Destroy VM: %s", name)
    return False
def call(conn=None, call=None, kwargs=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The call function must be called with -f or --function."
        )
    if "func" not in kwargs:
        raise SaltCloudSystemExit("No `func` argument passed")
    if conn is None:
        conn = get_conn()
    func = kwargs.pop("func")
    for key, value in kwargs.items():
        try:
            kwargs[key] = __utils__["json.loads"](value)
        except ValueError:
            continue
    try:
        return getattr(conn, func)(**kwargs)
    except shade.exc.OpenStackCloudException as exc:
        log.error("Error running %s: %s", func, exc)
        raise SaltCloudSystemExit(str(exc))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import hashlib
import logging
import os
import re
import salt.utils.files
import salt.utils.json
import salt.utils.yaml
log = logging.getLogger(__name__)
def __virtual__():
    if "boto_apigateway.describe_apis" in __salt__:
        return "boto_apigateway"
    return (False, "boto_apigateway module could not be loaded")
def present(
    name,
    api_name,
    swagger_file,
    stage_name,
    api_key_required,
    lambda_integration_role,
    lambda_region=None,
    stage_variables=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    lambda_funcname_format="{stage}_{api}_{resource}_{method}",
    authorization_type="NONE",
    error_response_template=None,
    response_template=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        swagger = _Swagger(
            api_name,
            stage_name,
            lambda_funcname_format,
            swagger_file,
            error_response_template,
            response_template,
            common_args,
        )
        stage_vars = _get_stage_variables(stage_variables)
        ret = swagger.verify_api(ret)
        if ret.get("publish"):
            if __opts__["test"]:
                ret["comment"] = (
                    "[stage: {}] will be reassociated to an already available "
                    "deployment that matched the given [api_name: {}] "
                    "and [swagger_file: {}].\n"
                    "Stage variables will be set "
                    "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
                )
                ret["result"] = None
                return ret
            return swagger.publish_api(ret, stage_vars)
        if ret.get("current"):
            if __opts__["test"]:
                ret["comment"] = (
                    "[stage: {}] is already at desired state with an associated "
                    "deployment matching the given [api_name: {}] "
                    "and [swagger_file: {}].\n"
                    "Stage variables will be set "
                    "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
                )
                ret["result"] = None
            return swagger.overwrite_stage_variables(ret, stage_vars)
        if __opts__["test"]:
            ret["comment"] = (
                "There is no deployment matching the given [api_name: {}] "
                "and [swagger_file: {}].  A new deployment will be "
                "created and the [stage_name: {}] will then be associated "
                "to the newly created deployment.\n"
                "Stage variables will be set "
                "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
            )
            ret["result"] = None
            return ret
        ret = swagger.deploy_api(ret)
        if ret.get("abort"):
            return ret
        ret = swagger.deploy_models(ret)
        if ret.get("abort"):
            return ret
        ret = swagger.deploy_resources(
            ret,
            api_key_required=api_key_required,
            lambda_integration_role=lambda_integration_role,
            lambda_region=lambda_region,
            authorization_type=authorization_type,
        )
        if ret.get("abort"):
            return ret
        ret = swagger.publish_api(ret, stage_vars)
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
def _get_stage_variables(stage_variables):
    ret = dict()
    if stage_variables is None:
        return ret
    if isinstance(stage_variables, str):
        if stage_variables in __opts__:
            ret = __opts__[stage_variables]
        master_opts = __pillar__.get("master", {})
        if stage_variables in master_opts:
            ret = master_opts[stage_variables]
        if stage_variables in __pillar__:
            ret = __pillar__[stage_variables]
    elif isinstance(stage_variables, dict):
        ret = stage_variables
    if not isinstance(ret, dict):
        ret = dict()
    return ret
def absent(
    name,
    api_name,
    stage_name,
    nuke_api=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
        if not swagger.restApiId:
            ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
            return ret
        if __opts__["test"]:
            if nuke_api:
                ret["comment"] = (
                    "[stage: {}] will be deleted, if there are no other "
                    "active stages, the [api: {} will also be "
                    "deleted.".format(stage_name, api_name)
                )
            else:
                ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
            ret["result"] = None
            return ret
        ret = swagger.delete_stage(ret)
        if ret.get("abort"):
            return ret
        if nuke_api and swagger.no_more_deployments_remain():
            ret = swagger.delete_api(ret)
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
def _gen_md5_filehash(fname, *args):
    _hash = hashlib.md5()
    with salt.utils.files.fopen(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            _hash.update(chunk)
    for extra_arg in args:
        _hash.update(str(extra_arg).encode())
    return _hash.hexdigest()
def _dict_to_json_pretty(d, sort_keys=True):
    return salt.utils.json.dumps(
        d, indent=4, separators=(",", ": "), sort_keys=sort_keys
    )
def _name_matches(name, matches):
    for m in matches:
        if name.endswith(m):
            return True
        if name.lower().endswith("_" + m.lower()):
            return True
        if name.lower() == m.lower():
            return True
    return False
def _object_reducer(
    o,
    names=(
        "id",
        "name",
        "path",
        "httpMethod",
        "statusCode",
        "Created",
        "Deleted",
        "Updated",
        "Flushed",
        "Associated",
        "Disassociated",
    ),
):
    result = {}
    if isinstance(o, dict):
        for k, v in o.items():
            if isinstance(v, dict):
                reduced = v if k == "variables" else _object_reducer(v, names)
                if reduced or _name_matches(k, names):
                    result[k] = reduced
            elif isinstance(v, list):
                newlist = []
                for val in v:
                    reduced = _object_reducer(val, names)
                    if reduced or _name_matches(k, names):
                        newlist.append(reduced)
                if newlist:
                    result[k] = newlist
            else:
                if _name_matches(k, names):
                    result[k] = v
    return result
def _log_changes(ret, changekey, changevalue):
    cl = ret["changes"].get("new", [])
    cl.append({changekey: _object_reducer(changevalue)})
    ret["changes"]["new"] = cl
    return ret
def _log_error_and_abort(ret, obj):
    ret["result"] = False
    ret["abort"] = True
    if "error" in obj:
        ret["comment"] = "{}".format(obj.get("error"))
    return ret
class _Swagger:
    SWAGGER_OBJ_V2_FIELDS = (
        "swagger",
        "info",
        "host",
        "basePath",
        "schemes",
        "consumes",
        "produces",
        "paths",
        "definitions",
        "parameters",
        "responses",
        "securityDefinitions",
        "security",
        "tags",
        "externalDocs",
    )
    SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
        "swagger",
        "info",
        "basePath",
        "schemes",
        "paths",
        "definitions",
    )
    SWAGGER_OPERATION_NAMES = (
        "get",
        "put",
        "post",
        "delete",
        "options",
        "head",
        "patch",
    )
    SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
    VENDOR_EXT_PATTERN = re.compile("^x-")
    JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
    REQUEST_TEMPLATE = {
        "application/json": (
            "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
            " = $input.params().header)\n#foreach( $param in $map.entrySet()"
            ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
            " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
            ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
            " $input.params().path)\n#foreach( $param in $map.entrySet()"
            ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
            ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
            ' "$context.requestId",\n"resourceId":'
            ' "$context.resourceId",\n"resourcePath":'
            ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
            ' "user":"$context.identity.user",\n '
            ' "userArn":"$context.identity.userArn",\n '
            ' "userAgent":"$context.identity.userAgent",\n '
            ' "sourceIp":"$context.identity.sourceIp",\n '
            ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
            ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
            ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
            '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
            '  "caller":"$context.identity.caller",\n '
            ' "apiKey":"$context.identity.apiKey",\n '
            ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
            " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
            ' $stageVariables.keySet())\n"$variable":'
            ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
            " #end\n#end\n}\n}"
        )
    }
    REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
    RESPONSE_TEMPLATE = {
        "application/json": (
            "#set($inputRoot = $input.path('$'))\n"
            "{\n"
            '  "errorMessage" : "$inputRoot.errorMessage",\n'
            '  "errorType" : "$inputRoot.errorType",\n'
            '  "stackTrace" : [\n'
            "#foreach($stackTrace in $inputRoot.stackTrace)\n"
            "    [\n"
            "#foreach($elem in $stackTrace)\n"
            '      "$elem"\n'
            "#if($foreach.hasNext),#end\n"
            "#end\n"
            "    ]\n"
            "#if($foreach.hasNext),#end\n"
            "#end\n"
            "  ]\n"
            "}"
        )
    }
    RESPONSE_OPTION_TEMPLATE = {}
    AWS_API_DESCRIPTION = _dict_to_json_pretty(
        {
            "provisioned_by": "Salt boto_apigateway.present State",
            "context": "See deployment or stage description",
        }
    )
    class SwaggerParameter:
        LOCATIONS = ("body", "query", "header", "path")
        def __init__(self, paramdict):
            self._paramdict = paramdict
        @property
        def location(self):
            _location = self._paramdict.get("in")
            if _location in _Swagger.SwaggerParameter.LOCATIONS:
                return _location
            raise ValueError(
                "Unsupported parameter location: {} in Parameter Object".format(
                    _location
                )
            )
        @property
        def name(self):
            _name = self._paramdict.get("name")
            if _name:
                if self.location == "header":
                    return "method.request.header.{}".format(_name)
                elif self.location == "query":
                    return "method.request.querystring.{}".format(_name)
                elif self.location == "path":
                    return "method.request.path.{}".format(_name)
                return None
            raise ValueError(
                "Parameter must have a name: {}".format(
                    _dict_to_json_pretty(self._paramdict)
                )
            )
        @property
        def schema(self):
            if self.location == "body":
                _schema = self._paramdict.get("schema")
                if _schema:
                    if "$ref" in _schema:
                        schema_name = _schema.get("$ref").split("/")[-1]
                        return schema_name
                    raise ValueError(
                        "Body parameter must have a JSON reference "
                        "to the schema definition due to Amazon API restrictions: {}".format(
                            self.name
                        )
                    )
                raise ValueError(
                    "Body parameter must have a schema: {}".format(self.name)
                )
            return None
    class SwaggerMethodResponse:
        def __init__(self, r):
            self._r = r
        @property
        def schema(self):
            _schema = self._r.get("schema")
            if _schema:
                if "$ref" in _schema:
                    return _schema.get("$ref").split("/")[-1]
                raise ValueError(
                    "Method response must have a JSON reference "
                    "to the schema definition: {}".format(_schema)
                )
            return None
        @property
        def headers(self):
            _headers = self._r.get("headers", {})
            return _headers
    def __init__(
        self,
        api_name,
        stage_name,
        lambda_funcname_format,
        swagger_file_path,
        error_response_template,
        response_template,
        common_aws_args,
    ):
        self._api_name = api_name
        self._stage_name = stage_name
        self._lambda_funcname_format = lambda_funcname_format
        self._common_aws_args = common_aws_args
        self._restApiId = ""
        self._deploymentId = ""
        self._error_response_template = error_response_template
        self._response_template = response_template
        if swagger_file_path is not None:
            if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
                self._swagger_file = swagger_file_path
                self._md5_filehash = _gen_md5_filehash(
                    self._swagger_file, error_response_template, response_template
                )
                with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
                    self._cfg = salt.utils.yaml.safe_load(sf)
                self._swagger_version = ""
            else:
                raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
            self._validate_swagger_file()
        self._validate_lambda_funcname_format()
        self._resolve_api_id()
    def _is_http_error_rescode(self, code):
        return bool(re.match(r"^\s*[45]\d\d\s*$", code))
    def _validate_error_response_model(self, paths, mods):
        for path, ops in paths:
            for opname, opobj in ops.items():
                if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
                    continue
                if "responses" not in opobj:
                    raise ValueError(
                        "missing mandatory responses field in path item object"
                    )
                for rescode, resobj in opobj.get("responses").items():
                    if not self._is_http_error_rescode(str(rescode)):
                        continue
                    if "schema" not in resobj:
                        raise ValueError(
                            "missing schema field in path {}, "
                            "op {}, response {}".format(path, opname, rescode)
                        )
                    schemaobj = resobj.get("schema")
                    if "$ref" not in schemaobj:
                        raise ValueError(
                            "missing $ref field under schema in "
                            "path {}, op {}, response {}".format(path, opname, rescode)
                        )
                    schemaobjref = schemaobj.get("$ref", "/")
                    modelname = schemaobjref.split("/")[-1]
                    if modelname not in mods:
                        raise ValueError(
                            "model schema {} reference not found "
                            "under /definitions".format(schemaobjref)
                        )
                    model = mods.get(modelname)
                    if model.get("type") != "object":
                        raise ValueError(
                            "model schema {} must be type object".format(modelname)
                        )
                    if "properties" not in model:
                        raise ValueError(
                            "model schema {} must have properties fields".format(
                                modelname
                            )
                        )
                    modelprops = model.get("properties")
                    if "errorMessage" not in modelprops:
                        raise ValueError(
                            "model schema {} must have errorMessage as a property to "
                            "match AWS convention. If pattern is not set, .+ will "
                            "be used".format(modelname)
                        )
    def _validate_lambda_funcname_format(self):
        try:
            if self._lambda_funcname_format:
                known_kwargs = dict(stage="", api="", resource="", method="")
                self._lambda_funcname_format.format(**known_kwargs)
            return True
        except Exception:  # pylint: disable=broad-except
            raise ValueError(
                "Invalid lambda_funcname_format {}.  Please review "
                "documentation for known substitutable keys".format(
                    self._lambda_funcname_format
                )
            )
    def _validate_swagger_file(self):
        for field in self._cfg:
            if (
                field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
                and not _Swagger.VENDOR_EXT_PATTERN.match(field)
            ):
                raise ValueError("Invalid Swagger Object Field: {}".format(field))
        for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
            if field not in self._cfg:
                raise ValueError("Missing Swagger Object Field: {}".format(field))
        self._swagger_version = self._cfg.get("swagger")
        if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
            raise ValueError(
                "Unsupported Swagger version: {},Supported versions are {}".format(
                    self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
                )
            )
        log.info(type(self._models))
        self._validate_error_response_model(self.paths, self._models())
    @property
    def md5_filehash(self):
        return self._md5_filehash
    @property
    def info(self):
        info = self._cfg.get("info")
        if not info:
            raise ValueError("Info Object has no values")
        return info
    @property
    def info_json(self):
        return _dict_to_json_pretty(self.info)
    @property
    def rest_api_name(self):
        return self._api_name
    @property
    def rest_api_version(self):
        version = self.info.get("version")
        if not version:
            raise ValueError("Missing version value in Info Object")
        return version
    def _models(self):
        models = self._cfg.get("definitions")
        if not models:
            raise ValueError(
                "Definitions Object has no values, You need to define them in your"
                " swagger file"
            )
        return models
    def models(self):
        model_dict = self._build_all_dependencies()
        while True:
            model = self._get_model_without_dependencies(model_dict)
            if not model:
                break
            yield (model, self._models().get(model))
    @property
    def paths(self):
        paths = self._cfg.get("paths")
        if not paths:
            raise ValueError(
                "Paths Object has no values, You need to define them in your swagger"
                " file"
            )
        for path in paths:
            if not path.startswith("/"):
                raise ValueError(
                    "Path object {} should start with /. Please fix it".format(path)
                )
        return paths.items()
    @property
    def basePath(self):
        basePath = self._cfg.get("basePath", "")
        return basePath
    @property
    def restApiId(self):
        return self._restApiId
    @restApiId.setter
    def restApiId(self, restApiId):
        self._restApiId = restApiId
    @property
    def deployment_label_json(self):
        return _dict_to_json_pretty(self.deployment_label)
    @property
    def deployment_label(self):
        label = dict()
        label["swagger_info_object"] = self.info
        label["api_name"] = self.rest_api_name
        label["swagger_file"] = os.path.basename(self._swagger_file)
        label["swagger_file_md5sum"] = self.md5_filehash
        return label
    def _one_or_more_stages_remain(self, deploymentId):
        stages = __salt__["boto_apigateway.describe_api_stages"](
            restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
        ).get("stages")
        return bool(stages)
    def no_more_deployments_remain(self):
        no_more_deployments = True
        deployments = __salt__["boto_apigateway.describe_api_deployments"](
            restApiId=self.restApiId, **self._common_aws_args
        ).get("deployments")
        if deployments:
            for deployment in deployments:
                deploymentId = deployment.get("id")
                stages = __salt__["boto_apigateway.describe_api_stages"](
                    restApiId=self.restApiId,
                    deploymentId=deploymentId,
                    **self._common_aws_args
                ).get("stages")
                if stages:
                    no_more_deployments = False
                    break
        return no_more_deployments
    def _get_current_deployment_id(self):
        deploymentId = ""
        stage = __salt__["boto_apigateway.describe_api_stage"](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            **self._common_aws_args
        ).get("stage")
        if stage:
            deploymentId = stage.get("deploymentId")
        return deploymentId
    def _get_current_deployment_label(self):
        deploymentId = self._get_current_deployment_id()
        deployment = __salt__["boto_apigateway.describe_api_deployment"](
            restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
        ).get("deployment")
        if deployment:
            return deployment.get("description")
        return None
    def _get_desired_deployment_id(self):
        deployments = __salt__["boto_apigateway.describe_api_deployments"](
            restApiId=self.restApiId, **self._common_aws_args
        ).get("deployments")
        if deployments:
            for deployment in deployments:
                if deployment.get("description") == self.deployment_label_json:
                    return deployment.get("id")
        return ""
    def overwrite_stage_variables(self, ret, stage_variables):
<a name="0"></a>        """
        overwrite the given stage_name's stage variables with the given stage_variables
        res = __salt__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto_apigateway.overwrite_api_stage_variables"](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            variables=stage_variables,
            **self._common_aws_args
        )
        if not res.get("overwrite"):
            ret[</b></font>"result"] = False
            ret["abort"] = True
            ret["comment"] = res.get("error")
        else:
            ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
        return ret
    def _set_current_deployment(self, stage_desc_json, stage_variables):
        stage = __salt__["boto_apigateway.describe_api_stage"](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            **self._common_aws_args
        ).get("stage")
        if not stage:
            stage = __salt__["boto_apigateway.create_api_stage"](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                deploymentId=self._deploymentId,
                description=stage_desc_json,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not stage.get("stage"):
                return {"set": False, "error": stage.get("error")}
        else:
            overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not overwrite.get("stage"):
                return {"set": False, "error": overwrite.get("error")}
        return __salt__["boto_apigateway.activate_api_deployment"](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            deploymentId=self._deploymentId,
            **self._common_aws_args
        )
    def _resolve_api_id(self):
        apis = __salt__["boto_apigateway.describe_apis"](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        ).get("restapi")
        if apis:
            if len(apis) == 1:
                self.restApiId = apis[0].get("id")
            else:
                raise ValueError(
                    "Multiple APIs matching given name {} and description {}".format(
                        self.rest_api_name, self.info_json
                    )
                )
    def delete_stage(self, ret):
        deploymentId = self._get_current_deployment_id()
        if deploymentId:
            result = __salt__["boto_apigateway.delete_api_stage"](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                **self._common_aws_args
            )
            if not result.get("deleted"):
                ret["abort"] = True
                ret["result"] = False
                ret["comment"] = "delete_stage delete_api_stage, {}".format(
                    result.get("error")
                )
            else:
                if not self._one_or_more_stages_remain(deploymentId):
                    result = __salt__["boto_apigateway.delete_api_deployment"](
                        restApiId=self.restApiId,
                        deploymentId=deploymentId,
                        **self._common_aws_args
                    )
                    if not result.get("deleted"):
                        ret["abort"] = True
                        ret["result"] = False
                        ret[
                            "comment"
                        ] = "delete_stage delete_api_deployment, {}".format(
                            result.get("error")
                        )
                else:
                    ret["comment"] = "stage {} has been deleted.\n".format(
                        self._stage_name
                    )
        else:
            ret["comment"] = "stage {} does not exist".format(self._stage_name)
        return ret
    def verify_api(self, ret):
        if self.restApiId:
            deployed_label_json = self._get_current_deployment_label()
            if deployed_label_json == self.deployment_label_json:
                ret["comment"] = (
                    "Already at desired state, the stage {} is already at the desired "
                    "deployment label:\n{}".format(
                        self._stage_name, deployed_label_json
                    )
                )
                ret["current"] = True
                return ret
            else:
                self._deploymentId = self._get_desired_deployment_id()
                if self._deploymentId:
                    ret["publish"] = True
        return ret
    def publish_api(self, ret, stage_variables):
        stage_desc = dict()
        stage_desc["current_deployment_label"] = self.deployment_label
        stage_desc_json = _dict_to_json_pretty(stage_desc)
        if self._deploymentId:
            res = self._set_current_deployment(stage_desc_json, stage_variables)
            if not res.get("set"):
                ret["abort"] = True
                ret["result"] = False
                ret["comment"] = res.get("error")
            else:
                ret = _log_changes(
                    ret,
                    "publish_api (reassociate deployment, set stage_variables)",
                    res.get("response"),
                )
        else:
            res = __salt__["boto_apigateway.create_api_deployment"](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                stageDescription=stage_desc_json,
                description=self.deployment_label_json,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not res.get("created"):
                ret["abort"] = True
                ret["result"] = False
                ret["comment"] = res.get("error")
            else:
                ret = _log_changes(
                    ret, "publish_api (new deployment)", res.get("deployment")
                )
        return ret
    def _cleanup_api(self):
        resources = __salt__["boto_apigateway.describe_api_resources"](
            restApiId=self.restApiId, **self._common_aws_args
        )
        if resources.get("resources"):
            res = resources.get("resources")[1:]
            res.reverse()
            for resource in res:
                delres = __salt__["boto_apigateway.delete_api_resources"](
                    restApiId=self.restApiId,
                    path=resource.get("path"),
                    **self._common_aws_args
                )
                if not delres.get("deleted"):
                    return delres
        models = __salt__["boto_apigateway.describe_api_models"](
            restApiId=self.restApiId, **self._common_aws_args
        )
        if models.get("models"):
            for model in models.get("models"):
                delres = __salt__["boto_apigateway.delete_api_model"](
                    restApiId=self.restApiId,
                    modelName=model.get("name"),
                    **self._common_aws_args
                )
                if not delres.get("deleted"):
                    return delres
        return {"deleted": True}
    def deploy_api(self, ret):
        if self.restApiId:
            res = self._cleanup_api()
            if not res.get("deleted"):
                ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
                ret["abort"] = True
                ret["result"] = False
                return ret
            return ret
        response = __salt__["boto_apigateway.create_api"](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        )
        if not response.get("created"):
            ret["result"] = False
            ret["abort"] = True
            if "error" in response:
                ret["comment"] = "Failed to create rest api: {}.".format(
                    response["error"]["message"]
                )
            return ret
        self.restApiId = response.get("restapi", {}).get("id")
        return _log_changes(ret, "deploy_api", response.get("restapi"))
    def delete_api(self, ret):
        exists_response = __salt__["boto_apigateway.api_exists"](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        )
        if exists_response.get("exists"):
            if __opts__["test"]:
                ret["comment"] = "Rest API named {} is set to be deleted.".format(
                    self.rest_api_name
                )
                ret["result"] = None
                ret["abort"] = True
                return ret
            delete_api_response = __salt__["boto_apigateway.delete_api"](
                name=self.rest_api_name,
                description=_Swagger.AWS_API_DESCRIPTION,
                **self._common_aws_args
            )
            if not delete_api_response.get("deleted"):
                ret["result"] = False
                ret["abort"] = True
                if "error" in delete_api_response:
                    ret["comment"] = "Failed to delete rest api: {}.".format(
                        delete_api_response["error"]["message"]
                    )
                return ret
            ret = _log_changes(ret, "delete_api", delete_api_response)
        else:
            ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
                self.rest_api_name, self.info_json
            )
        return ret
    def _aws_model_ref_from_swagger_ref(self, r):
        model_name = r.split("/")[-1]
        return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
            self.restApiId, model_name
        )
    def _update_schema_to_aws_notation(self, schema):
        result = {}
        for k, v in schema.items():
            if k == "$ref":
                v = self._aws_model_ref_from_swagger_ref(v)
            if isinstance(v, dict):
                v = self._update_schema_to_aws_notation(v)
            result[k] = v
        return result
    def _build_dependent_model_list(self, obj_schema):
        dep_models_list = []
        if obj_schema:
            obj_schema["type"] = obj_schema.get("type", "object")
        if obj_schema["type"] == "array":
            dep_models_list.extend(
                self._build_dependent_model_list(obj_schema.get("items", {}))
            )
        else:
            ref = obj_schema.get("$ref")
            if ref:
                ref_obj_model = ref.split("/")[-1]
                ref_obj_schema = self._models().get(ref_obj_model)
                dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
                dep_models_list.extend([ref_obj_model])
            else:
                properties = obj_schema.get("properties")
                if properties:
                    for _, prop_obj_schema in properties.items():
                        dep_models_list.extend(
                            self._build_dependent_model_list(prop_obj_schema)
                        )
        return list(set(dep_models_list))
    def _build_all_dependencies(self):
        ret = {}
        for model, schema in self._models().items():
            dep_list = self._build_dependent_model_list(schema)
            ret[model] = dep_list
        return ret
    def _get_model_without_dependencies(self, models_dict):
        next_model = None
        if not models_dict:
            return next_model
        for model, dependencies in models_dict.items():
            if dependencies == []:
                next_model = model
                break
        if next_model is None:
            raise ValueError(
                "incomplete model definitions, models in dependency "
                "list not defined: {}".format(models_dict)
            )
        models_dict.pop(next_model)
        for model, dep_list in models_dict.items():
            if next_model in dep_list:
                dep_list.remove(next_model)
        return next_model
    def deploy_models(self, ret):
        for model, schema in self.models():
            _schema = self._update_schema_to_aws_notation(schema)
            _schema.update(
                {
                    "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
                    "title": "{} Schema".format(model),
                }
            )
            model_exists_response = __salt__["boto_apigateway.api_model_exists"](
                restApiId=self.restApiId, modelName=model, **self._common_aws_args
            )
            if model_exists_response.get("exists"):
                update_model_schema_response = __salt__[
                    "boto_apigateway.update_api_model_schema"
                ](
                    restApiId=self.restApiId,
                    modelName=model,
                    schema=_dict_to_json_pretty(_schema),
                    **self._common_aws_args
                )
                if not update_model_schema_response.get("updated"):
                    ret["result"] = False
                    ret["abort"] = True
                    if "error" in update_model_schema_response:
                        ret[
                            "comment"
                        ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
                            model,
                            _dict_to_json_pretty(schema),
                            update_model_schema_response["error"]["message"],
                        )
                    return ret
                ret = _log_changes(ret, "deploy_models", update_model_schema_response)
            else:
                create_model_response = __salt__["boto_apigateway.create_api_model"](
                    restApiId=self.restApiId,
                    modelName=model,
                    modelDescription=model,
                    schema=_dict_to_json_pretty(_schema),
                    contentType="application/json",
                    **self._common_aws_args
                )
                if not create_model_response.get("created"):
                    ret["result"] = False
                    ret["abort"] = True
                    if "error" in create_model_response:
                        ret[
                            "comment"
                        ] = "Failed to create model {}, schema {}, error: {}".format(
                            model,
                            _dict_to_json_pretty(schema),
                            create_model_response["error"]["message"],
                        )
                    return ret
                ret = _log_changes(ret, "deploy_models", create_model_response)
        return ret
    def _lambda_name(self, resourcePath, httpMethod):
        lambda_name = self._lambda_funcname_format.format(
            stage=self._stage_name,
            api=self.rest_api_name,
            resource=resourcePath,
            method=httpMethod,
        )
        lambda_name = lambda_name.strip()
        lambda_name = re.sub(r"{|}", "", lambda_name)
        lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
        return re.sub(r"_+", "_", lambda_name)
    def _lambda_uri(self, lambda_name, lambda_region):
        profile = self._common_aws_args.get("profile")
        region = self._common_aws_args.get("region")
        lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
        apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
        lambda_desc = __salt__["boto_lambda.describe_function"](
            lambda_name, **self._common_aws_args
        )
        if lambda_region != apigw_region:
            if not lambda_desc.get("function"):
                lambda_desc = __salt__["boto_lambda.describe_function"](
                    lambda_name, **self._common_aws_args
                )
        if not lambda_desc.get("function"):
            raise ValueError(
                "Could not find lambda function {} in regions [{}, {}].".format(
                    lambda_name, lambda_region, apigw_region
                )
            )
        lambda_arn = lambda_desc.get("function").get("FunctionArn")
        lambda_uri = (
            "arn:aws:apigateway:{}:lambda:path/2015-03-31"
            "/functions/{}/invocations".format(apigw_region, lambda_arn)
        )
        return lambda_uri
    def _parse_method_data(self, method_name, method_data):
        method_params = {}
        method_models = {}
        if "parameters" in method_data:
            for param in method_data["parameters"]:
                p = _Swagger.SwaggerParameter(param)
                if p.name:
                    method_params[p.name] = True
                if p.schema:
                    method_models["application/json"] = p.schema
        request_templates = (
            _Swagger.REQUEST_OPTION_TEMPLATE
            if method_name == "options"
            else _Swagger.REQUEST_TEMPLATE
        )
        integration_type = "MOCK" if method_name == "options" else "AWS"
        return {
            "params": method_params,
            "models": method_models,
            "request_templates": request_templates,
            "integration_type": integration_type,
        }
    def _find_patterns(self, o):
        result = []
        if isinstance(o, dict):
            for k, v in o.items():
                if isinstance(v, dict):
                    result.extend(self._find_patterns(v))
                else:
                    if k == "pattern":
                        result.append(v)
        return result
    def _get_pattern_for_schema(self, schema_name, httpStatus):
        defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
        model = self._models().get(schema_name)
        patterns = self._find_patterns(model)
        return patterns[0] if patterns else defaultPattern
    def _get_response_template(self, method_name, http_status):
        if method_name == "options" or not self._is_http_error_rescode(http_status):
            response_templates = (
                {"application/json": self._response_template}
                if self._response_template
                else self.RESPONSE_OPTION_TEMPLATE
            )
        else:
            response_templates = (
                {"application/json": self._error_response_template}
                if self._error_response_template
                else self.RESPONSE_TEMPLATE
            )
        return response_templates
    def _parse_method_response(self, method_name, method_response, httpStatus):
        method_response_models = {}
        method_response_pattern = ".*"
        if method_response.schema:
            method_response_models["application/json"] = method_response.schema
            method_response_pattern = self._get_pattern_for_schema(
                method_response.schema, httpStatus
            )
        method_response_params = {}
        method_integration_response_params = {}
        for header in method_response.headers:
            response_header = "method.response.header.{}".format(header)
            method_response_params[response_header] = False
            header_data = method_response.headers.get(header)
            method_integration_response_params[response_header] = (
                "'{}'".format(header_data.get("default"))
                if "default" in header_data
                else "'*'"
            )
        response_templates = self._get_response_template(method_name, httpStatus)
        return {
            "params": method_response_params,
            "models": method_response_models,
            "integration_params": method_integration_response_params,
            "pattern": method_response_pattern,
            "response_templates": response_templates,
        }
    def _deploy_method(
        self,
        ret,
        resource_path,
        method_name,
        method_data,
        api_key_required,
        lambda_integration_role,
        lambda_region,
        authorization_type,
    ):
        method = self._parse_method_data(method_name.lower(), method_data)
        if method_name.lower() == "options":
            api_key_required = False
            authorization_type = "NONE"
        m = __salt__["boto_apigateway.create_api_method"](
            restApiId=self.restApiId,
            resourcePath=resource_path,
            httpMethod=method_name.upper(),
            authorizationType=authorization_type,
            apiKeyRequired=api_key_required,
            requestParameters=method.get("params"),
            requestModels=method.get("models"),
            **self._common_aws_args
        )
        if not m.get("created"):
            ret = _log_error_and_abort(ret, m)
            return ret
        ret = _log_changes(ret, "_deploy_method.create_api_method", m)
        lambda_uri = ""
        if method_name.lower() != "options":
            lambda_uri = self._lambda_uri(
                self._lambda_name(resource_path, method_name),
                lambda_region=lambda_region,
            )
        integration = __salt__["boto_apigateway.create_api_integration"](
            restApiId=self.restApiId,
            resourcePath=resource_path,
            httpMethod=method_name.upper(),
            integrationType=method.get("integration_type"),
            integrationHttpMethod="POST",
            uri=lambda_uri,
            credentials=lambda_integration_role,
            requestTemplates=method.get("request_templates"),
            **self._common_aws_args
        )
        if not integration.get("created"):
            ret = _log_error_and_abort(ret, integration)
            return ret
        ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
        if "responses" in method_data:
            for response, response_data in method_data["responses"].items():
                httpStatus = str(response)
                method_response = self._parse_method_response(
                    method_name.lower(),
                    _Swagger.SwaggerMethodResponse(response_data),
                    httpStatus,
                )
                mr = __salt__["boto_apigateway.create_api_method_response"](
                    restApiId=self.restApiId,
                    resourcePath=resource_path,
                    httpMethod=method_name.upper(),
                    statusCode=httpStatus,
                    responseParameters=method_response.get("params"),
                    responseModels=method_response.get("models"),
                    **self._common_aws_args
                )
                if not mr.get("created"):
                    ret = _log_error_and_abort(ret, mr)
                    return ret
                ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
                mir = __salt__["boto_apigateway.create_api_integration_response"](
                    restApiId=self.restApiId,
                    resourcePath=resource_path,
                    httpMethod=method_name.upper(),
                    statusCode=httpStatus,
                    selectionPattern=method_response.get("pattern"),
                    responseParameters=method_response.get("integration_params"),
                    responseTemplates=method_response.get("response_templates"),
                    **self._common_aws_args
                )
                if not mir.get("created"):
                    ret = _log_error_and_abort(ret, mir)
                    return ret
                ret = _log_changes(
                    ret, "_deploy_method.create_api_integration_response", mir
                )
        else:
            raise ValueError(
                "No responses specified for {} {}".format(resource_path, method_name)
            )
        return ret
    def deploy_resources(
        self,
        ret,
        api_key_required,
        lambda_integration_role,
        lambda_region,
        authorization_type,
    ):
        for path, pathData in self.paths:
            resource = __salt__["boto_apigateway.create_api_resources"](
                restApiId=self.restApiId, path=path, **self._common_aws_args
            )
            if not resource.get("created"):
                ret = _log_error_and_abort(ret, resource)
                return ret
            ret = _log_changes(ret, "deploy_resources", resource)
            for method, method_data in pathData.items():
                if method in _Swagger.SWAGGER_OPERATION_NAMES:
                    ret = self._deploy_method(
                        ret,
                        path,
                        method,
                        method_data,
                        api_key_required,
                        lambda_integration_role,
                        lambda_region,
                        authorization_type,
                    )
        return ret
def usage_plan_present(
    name,
    plan_name,
    description=None,
    throttle=None,
    quota=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    func_params = locals()
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        existing = __salt__["boto_apigateway.describe_usage_plans"](
            name=plan_name, **common_args
        )
        if "error" in existing:
            ret["result"] = False
            ret["comment"] = "Failed to describe existing usage plans"
            return ret
        if not existing["plans"]:
            if __opts__["test"]:
                ret["comment"] = "a new usage plan {} would be created".format(
                    plan_name
                )
                ret["result"] = None
                return ret
            result = __salt__["boto_apigateway.create_usage_plan"](
                name=plan_name,
                description=description,
                throttle=throttle,
                quota=quota,
                **common_args
            )
            if "error" in result:
                ret["result"] = False
                ret["comment"] = "Failed to create a usage plan {}, {}".format(
                    plan_name, result["error"]
                )
                return ret
            ret["changes"]["old"] = {"plan": None}
            ret["comment"] = "A new usage plan {} has been created".format(plan_name)
        else:
            plan = existing["plans"][0]
            needs_updating = False
            modifiable_params = (
                ("throttle", ("rateLimit", "burstLimit")),
                ("quota", ("limit", "offset", "period")),
            )
            for p, fields in modifiable_params:
                for f in fields:
                    actual_param = (
                        {} if func_params.get(p) is None else func_params.get(p)
                    )
                    if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
                        needs_updating = True
                        break
            if not needs_updating:
                ret["comment"] = "usage plan {} is already in a correct state".format(
                    plan_name
                )
                ret["result"] = True
                return ret
            if __opts__["test"]:
                ret["comment"] = "a new usage plan {} would be updated".format(
                    plan_name
                )
                ret["result"] = None
                return ret
            result = __salt__["boto_apigateway.update_usage_plan"](
                plan["id"], throttle=throttle, quota=quota, **common_args
            )
            if "error" in result:
                ret["result"] = False
                ret["comment"] = "Failed to update a usage plan {}, {}".format(
                    plan_name, result["error"]
                )
                return ret
            ret["changes"]["old"] = {"plan": plan}
            ret["comment"] = "usage plan {} has been updated".format(plan_name)
        newstate = __salt__["boto_apigateway.describe_usage_plans"](
            name=plan_name, **common_args
        )
        if "error" in existing:
            ret["result"] = False
            ret["comment"] = "Failed to describe existing usage plans after updates"
            return ret
        ret["changes"]["new"] = {"plan": newstate["plans"][0]}
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        existing = __salt__["boto_apigateway.describe_usage_plans"](
            name=plan_name, **common_args
        )
        if "error" in existing:
            ret["result"] = False
            ret["comment"] = "Failed to describe existing usage plans"
            return ret
        if not existing["plans"]:
            ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
            return ret
        if __opts__["test"]:
            ret["comment"] = "Usage plan {} exists and would be deleted".format(
                plan_name
            )
            ret["result"] = None
            return ret
        plan_id = existing["plans"][0]["id"]
        result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
        if "error" in result:
            ret["result"] = False
            ret["comment"] = "Failed to delete usage plan {}, {}".format(
                plan_name, result
            )
            return ret
        ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
        ret["changes"]["old"] = {"plan": existing["plans"][0]}
        ret["changes"]["new"] = {"plan": None}
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
def usage_plan_association_present(
    name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        existing = __salt__["boto_apigateway.describe_usage_plans"](
            name=plan_name, **common_args
        )
        if "error" in existing:
            ret["result"] = False
            ret["comment"] = "Failed to describe existing usage plans"
            return ret
        if not existing["plans"]:
            ret["comment"] = "Usage plan {} does not exist".format(plan_name)
            ret["result"] = False
            return ret
        if len(existing["plans"]) != 1:
            ret["comment"] = (
                "There are multiple usage plans with the same name - it is not"
                " supported"
            )
            ret["result"] = False
            return ret
        plan = existing["plans"][0]
        plan_id = plan["id"]
        plan_stages = plan.get("apiStages", [])
        stages_to_add = []
        for api in api_stages:
            if api not in plan_stages:
                stages_to_add.append(api)
        if not stages_to_add:
            ret["comment"] = "Usage plan is already asssociated to all api stages"
            return ret
        result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
            plan_id, stages_to_add, **common_args
        )
        if "error" in result:
            ret[
                "comment"
            ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
                plan_name, stages_to_add, result["error"]
            )
            ret["result"] = False
            return ret
        ret["comment"] = "successfully associated usage plan to apis"
        ret["changes"]["old"] = plan_stages
        ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
def usage_plan_association_absent(
    name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    try:
        common_args = dict(
            [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
        )
        existing = __salt__["boto_apigateway.describe_usage_plans"](
            name=plan_name, **common_args
        )
        if "error" in existing:
            ret["result"] = False
            ret["comment"] = "Failed to describe existing usage plans"
            return ret
        if not existing["plans"]:
            ret["comment"] = "Usage plan {} does not exist".format(plan_name)
            ret["result"] = False
            return ret
        if len(existing["plans"]) != 1:
            ret["comment"] = (
                "There are multiple usage plans with the same name - it is not"
                " supported"
            )
            ret["result"] = False
            return ret
        plan = existing["plans"][0]
        plan_id = plan["id"]
        plan_stages = plan.get("apiStages", [])
        if not plan_stages:
            ret["comment"] = "Usage plan {} has no associated stages already".format(
                plan_name
            )
            return ret
        stages_to_remove = []
        for api in api_stages:
            if api in plan_stages:
                stages_to_remove.append(api)
        if not stages_to_remove:
            ret["comment"] = "Usage plan is already not asssociated to any api stages"
            return ret
        result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
            plan_id, stages_to_remove, **common_args
        )
        if "error" in result:
            ret[
                "comment"
            ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
                plan_name, stages_to_remove, result["error"]
            )
            ret["result"] = False
            return ret
        ret["comment"] = "successfully disassociated usage plan from apis"
        ret["changes"]["old"] = plan_stages
        ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
    except (ValueError, OSError) as e:
        ret["result"] = False
        ret["comment"] = "{}".format(e.args)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
