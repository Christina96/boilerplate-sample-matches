<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for openstack.py &amp; boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for openstack.py &amp; boto_apigateway.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>openstack.py (1.3289037%)<th>boto_apigateway.py (0.4743083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(867-873)<td><a href="#" name="0">(1155-1163)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>openstack.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import os
4 import pprint
5 import socket
6 import salt.config as config
7 import salt.utils.versions
8 from salt.exceptions import (
9     SaltCloudConfigError,
10     SaltCloudExecutionFailure,
11     SaltCloudExecutionTimeout,
12     SaltCloudSystemExit,
13 )
14 try:
15     import shade
16     import shade.openstackcloud
17     import shade.exc
18     import os_client_config
19     HAS_SHADE = (
20         salt.utils.versions._LooseVersion(shade.__version__)
21         &gt;= salt.utils.versions._LooseVersion("1.19.0"),
22         "Please install newer version of shade: &gt;= 1.19.0",
23     )
24 except ImportError:
25     HAS_SHADE = (False, "Install pypi module shade &gt;= 1.19.0")
26 log = logging.getLogger(__name__)
27 __virtualname__ = "openstack"
28 def __virtual__():
29     if get_configured_provider() is False:
30         return False
31     if get_dependencies() is False:
32         return HAS_SHADE
33     return __virtualname__
34 def _get_active_provider_name():
35     try:
36         return __active_provider_name__.value()
37     except AttributeError:
38         return __active_provider_name__
39 def get_configured_provider():
40     provider = config.is_provider_configured(
41         __opts__,
42         _get_active_provider_name() or __virtualname__,
43         ("auth", "region_name"),
44     )
45     if provider:
46         return provider
47     return config.is_provider_configured(
48         __opts__,
49         _get_active_provider_name() or __virtualname__,
50         ("cloud", "region_name"),
51     )
52 def get_dependencies():
53     if not HAS_SHADE:
54         log.warning('"shade" not found')
55         return False
56     elif hasattr(HAS_SHADE, "__len__") and not HAS_SHADE[0]:
57         log.warning(HAS_SHADE[1])
58         return False
59     deps = {"shade": HAS_SHADE[0], "os_client_config": HAS_SHADE[0]}
60     return config.check_driver_dependencies(__virtualname__, deps)
61 def preferred_ip(vm_, ips):
62     proto = config.get_cloud_config_value(
63         "protocol", vm_, __opts__, default="ipv4", search_global=False
64     )
65     family = socket.AF_INET
66     if proto == "ipv6":
67         family = socket.AF_INET6
68     for ip in ips:
69         ignore_ip = ignore_cidr(vm_, ip)
70         if ignore_ip:
71             continue
72         try:
73             socket.inet_pton(family, ip)
74             return ip
75         except Exception:  # pylint: disable=broad-except
76             continue
77     return False
78 def ignore_cidr(vm_, ip):
79     from ipaddress import ip_address, ip_network
80     cidrs = config.get_cloud_config_value(
81         "ignore_cidr", vm_, __opts__, default=[], search_global=False
82     )
83     if cidrs and isinstance(cidrs, str):
84         cidrs = [cidrs]
85     for cidr in cidrs or []:
86         if ip_address(ip) in ip_network(cidr):
87             log.warning("IP %r found within %r; ignoring it.", ip, cidr)
88             return True
89     return False
90 def ssh_interface(vm_):
91     return config.get_cloud_config_value(
92         "ssh_interface", vm_, __opts__, default="public_ips", search_global=False
93     )
94 def get_conn():
95     if _get_active_provider_name() in __context__:
96         return __context__[_get_active_provider_name()]
97     vm_ = get_configured_provider()
98     profile = vm_.pop("profile", None)
99     if profile is not None:
100         vm_ = __utils__["dictupdate.update"](
101             os_client_config.vendors.get_profile(profile), vm_
102         )
103     conn = shade.openstackcloud.OpenStackCloud(cloud_config=None, **vm_)
104     if _get_active_provider_name() is not None:
105         __context__[_get_active_provider_name()] = conn
106     return conn
107 def list_nodes(conn=None, call=None):
108     if call == "action":
109         raise SaltCloudSystemExit(
110             "The list_nodes function must be called with -f or --function."
111         )
112     ret = {}
113     for node, info in list_nodes_full(conn=conn).items():
114         for key in (
115             "id",
116             "name",
117             "size",
118             "state",
119             "private_ips",
120             "public_ips",
121             "floating_ips",
122             "fixed_ips",
123             "image",
124         ):
125             ret.setdefault(node, {}).setdefault(key, info.get(key))
126     return ret
127 def list_nodes_min(conn=None, call=None):
128     if call == "action":
129         raise SaltCloudSystemExit(
130             "The list_nodes_min function must be called with -f or --function."
131         )
132     if conn is None:
133         conn = get_conn()
134     ret = {}
135     for node in conn.list_servers(bare=True):
136         ret[node.name] = {"id": node.id, "state": node.status}
137     return ret
138 def _get_ips(node, addr_type="public"):
139     ret = []
140     for _, interface in node.addresses.items():
141         for addr in interface:
142             if addr_type in ("floating", "fixed") and addr_type == addr.get(
143                 "OS-EXT-IPS:type"
144             ):
145                 ret.append(addr["addr"])
146             elif addr_type == "public" and __utils__["cloud.is_public_ip"](
147                 addr["addr"]
148             ):
149                 ret.append(addr["addr"])
150             elif addr_type == "private" and not __utils__["cloud.is_public_ip"](
151                 addr["addr"]
152             ):
153                 ret.append(addr["addr"])
154     return ret
155 def list_nodes_full(conn=None, call=None):
156     if call == "action":
157         raise SaltCloudSystemExit(
158             "The list_nodes_full function must be called with -f or --function."
159         )
160     if conn is None:
161         conn = get_conn()
162     ret = {}
163     for node in conn.list_servers(detailed=True):
164         ret[node.name] = dict(node)
165         ret[node.name]["id"] = node.id
166         ret[node.name]["name"] = node.name
167         ret[node.name]["size"] = node.flavor.name
168         ret[node.name]["state"] = node.status
169         ret[node.name]["private_ips"] = _get_ips(node, "private")
170         ret[node.name]["public_ips"] = _get_ips(node, "public")
171         ret[node.name]["floating_ips"] = _get_ips(node, "floating")
172         ret[node.name]["fixed_ips"] = _get_ips(node, "fixed")
173         if isinstance(node.image, str):
174             ret[node.name]["image"] = node.image
175         else:
176             ret[node.name]["image"] = getattr(
177                 conn.get_image(node.image.id), "name", node.image.id
178             )
179     return ret
180 def list_nodes_select(conn=None, call=None):
181     if call == "action":
182         raise SaltCloudSystemExit(
183             "The list_nodes_select function must be called with -f or --function."
184         )
185     return __utils__["cloud.list_nodes_select"](
186         list_nodes(conn, "function"), __opts__["query.selection"], call
187     )
188 def show_instance(name, conn=None, call=None):
189     if call != "action":
190         raise SaltCloudSystemExit(
191             "The show_instance action must be called with -a or --action."
192         )
193     if conn is None:
194         conn = get_conn()
195     node = conn.get_server(name, bare=True)
196     ret = dict(node)
197     ret["id"] = node.id
198     ret["name"] = node.name
199     ret["size"] = conn.get_flavor(node.flavor.id).name
200     ret["state"] = node.status
201     ret["private_ips"] = _get_ips(node, "private")
202     ret["public_ips"] = _get_ips(node, "public")
203     ret["floating_ips"] = _get_ips(node, "floating")
204     ret["fixed_ips"] = _get_ips(node, "fixed")
205     if isinstance(node.image, str):
206         ret["image"] = node.image
207     else:
208         ret["image"] = getattr(conn.get_image(node.image.id), "name", node.image.id)
209     return ret
210 def avail_images(conn=None, call=None):
211     if call == "action":
212         raise SaltCloudSystemExit(
213             "The avail_images function must be called with "
214             "-f or --function, or with the --list-images option"
215         )
216     if conn is None:
217         conn = get_conn()
218     return conn.list_images()
219 def avail_sizes(conn=None, call=None):
220     if call == "action":
221         raise SaltCloudSystemExit(
222             "The avail_sizes function must be called with "
223             "-f or --function, or with the --list-sizes option"
224         )
225     if conn is None:
226         conn = get_conn()
227     return conn.list_flavors()
228 def list_networks(conn=None, call=None):
229     if call == "action":
230         raise SaltCloudSystemExit(
231             "The list_networks function must be called with -f or --function"
232         )
233     if conn is None:
234         conn = get_conn()
235     return conn.list_networks()
236 def list_subnets(conn=None, call=None, kwargs=None):
237     if call == "action":
238         raise SaltCloudSystemExit(
239             "The list_subnets function must be called with -f or --function."
240         )
241     if conn is None:
242         conn = get_conn()
243     if kwargs is None or (isinstance(kwargs, dict) and "network" not in kwargs):
244         raise SaltCloudSystemExit("A `network` must be specified")
245     return conn.list_subnets(filters={"network": kwargs["network"]})
246 def _clean_create_kwargs(**kwargs):
247     VALID_OPTS = {
248         "name": (str,),
249         "image": (str,),
250         "flavor": (str,),
251         "auto_ip": bool,
252         "ips": list,
253         "ip_pool": (str,),
254         "root_volume": (str,),
255         "boot_volume": (str,),
256         "terminate_volume": bool,
257         "volumes": list,
258         "meta": dict,
259         "files": dict,
260         "reservation_id": (str,),
261         "security_groups": list,
262         "key_name": (str,),
263         "availability_zone": (str,),
264         "block_device_mapping": list,
265         "block_device_mapping_v2": list,
266         "nics": list,
267         "scheduler_hints": dict,
268         "config_drive": bool,
269         "disk_config": (str,),  # AUTO or MANUAL
270         "admin_pass": (str,),
271         "wait": bool,
272         "timeout": int,
273         "reuse_ips": bool,
274         "network": (dict, list),
275         "boot_from_volume": bool,
276         "volume_size": int,
277         "nat_destination": (str,),
278         "group": (str,),
279         "userdata": (str,),
280     }
281     extra = kwargs.pop("extra", {})
282     for key, value in kwargs.copy().items():
283         if key in VALID_OPTS:
284             if isinstance(value, VALID_OPTS[key]):
285                 continue
286             log.error("Error %s: %s is not of type %s", key, value, VALID_OPTS[key])
287         kwargs.pop(key)
288     return __utils__["dictupdate.update"](kwargs, extra)
289 def request_instance(vm_, conn=None, call=None):
290     if call == "function":
291         raise SaltCloudSystemExit(
292             "The request_instance action must be called with -a or --action."
293         )
294     kwargs = copy.deepcopy(vm_)
295     log.info("Creating Cloud VM %s", vm_["name"])
296     __utils__["cloud.check_name"](vm_["name"], "a-zA-Z0-9._-")
297     if conn is None:
298         conn = get_conn()
299     userdata = config.get_cloud_config_value(
300         "userdata", vm_, __opts__, search_global=False, default=None
301     )
302     if userdata is not None and os.path.isfile(userdata):
303         try:
304             with __utils__["files.fopen"](userdata, "r") as fp_:
305                 kwargs["userdata"] = __utils__["cloud.userdata_template"](
306                     __opts__, vm_, fp_.read()
307                 )
308         except Exception as exc:  # pylint: disable=broad-except
309             log.exception("Failed to read userdata from %s: %s", userdata, exc)
310     if "size" in kwargs:
311         kwargs["flavor"] = kwargs.pop("size")
312     kwargs["key_name"] = config.get_cloud_config_value(
313         "ssh_key_name", vm_, __opts__, search_global=False, default=None
314     )
315     kwargs["wait"] = True
316     try:
317         conn.create_server(**_clean_create_kwargs(**kwargs))
318     except shade.exc.OpenStackCloudException as exc:
319         log.error("Error creating server %s: %s", vm_["name"], exc)
320         destroy(vm_["name"], conn=conn, call="action")
321         raise SaltCloudSystemExit(str(exc))
322     return show_instance(vm_["name"], conn=conn, call="action")
323 def create(vm_):
324     deploy = config.get_cloud_config_value("deploy", vm_, __opts__)
325     key_filename = config.get_cloud_config_value(
326         "ssh_key_file", vm_, __opts__, search_global=False, default=None
327     )
328     if key_filename is not None and not os.path.isfile(key_filename):
329         raise SaltCloudConfigError(
330             "The defined ssh_key_file '{}' does not exist".format(key_filename)
331         )
332     vm_["key_filename"] = key_filename
333     __utils__["cloud.fire_event"](
334         "event",
335         "starting create",
336         "salt/cloud/{}/creating".format(vm_["name"]),
337         args=__utils__["cloud.filter_event"](
338             "creating", vm_, ["name", "profile", "provider", "driver"]
339         ),
340         sock_dir=__opts__["sock_dir"],
341         transport=__opts__["transport"],
342     )
343     conn = get_conn()
344     if "instance_id" in vm_:
345         if "pub_key" not in vm_ and "priv_key" not in vm_:
346             log.debug("Generating minion keys for '%s'", vm_["name"])
347             vm_["priv_key"], vm_["pub_key"] = __utils__["cloud.gen_keys"](
348                 config.get_cloud_config_value("keysize", vm_, __opts__)
349             )
350     else:
351         request_instance(conn=conn, call="action", vm_=vm_)
352     data = show_instance(vm_.get("instance_id", vm_["name"]), conn=conn, call="action")
353     log.debug("VM is now running")
354     def __query_node(vm_):
355         data = show_instance(vm_["name"], conn=conn, call="action")
356         if "wait_for_metadata" in vm_:
357             for key, value in vm_.get("wait_for_metadata", {}).items():
358                 log.debug("Waiting for metadata: %s=%s", key, value)
359                 if data["metadata"].get(key, None) != value:
360                     log.debug(
361                         "Metadata is not ready: %s=%s", key, data["metadata"].get(key)
362                     )
363                     return False
364         return preferred_ip(vm_, data[ssh_interface(vm_)])
365     try:
366         ip_address = __utils__["cloud.wait_for_fun"](__query_node, vm_=vm_)
367     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
368         try:
369             destroy(vm_["name"])
370         except SaltCloudSystemExit:
371             pass
372         finally:
373             raise SaltCloudSystemExit(str(exc))
374     log.debug("Using IP address %s", ip_address)
375     salt_interface = __utils__["cloud.get_salt_interface"](vm_, __opts__)
376     salt_ip_address = preferred_ip(vm_, data[salt_interface])
377     log.debug("Salt interface set to: %s", salt_ip_address)
378     if not ip_address:
379         raise SaltCloudSystemExit("A valid IP address was not found")
380     vm_["ssh_host"] = ip_address
381     vm_["salt_host"] = salt_ip_address
382     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
383     ret.update(data)
384     log.info("Created Cloud VM '%s'", vm_["name"])
385     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
386     event_data = {
387         "name": vm_["name"],
388         "profile": vm_["profile"],
389         "provider": vm_["driver"],
390         "instance_id": data["id"],
391         "floating_ips": data["floating_ips"],
392         "fixed_ips": data["fixed_ips"],
393         "private_ips": data["private_ips"],
394         "public_ips": data["public_ips"],
395     }
396     __utils__["cloud.fire_event"](
397         "event",
398         "created instance",
399         "salt/cloud/{}/created".format(vm_["name"]),
400         args=__utils__["cloud.filter_event"]("created", event_data, list(event_data)),
401         sock_dir=__opts__["sock_dir"],
402         transport=__opts__["transport"],
403     )
404     __utils__["cloud.cachedir_index_add"](
405         vm_["name"], vm_["profile"], "nova", vm_["driver"]
406     )
407     return ret
408 def destroy(name, conn=None, call=None):
409     if call == "function":
410         raise SaltCloudSystemExit(
411             "The destroy action must be called with -d, --destroy, -a or --action."
412         )
413     __utils__["cloud.fire_event"](
414         "event",
415         "destroying instance",
416         "salt/cloud/{}/destroying".format(name),
417         args={"name": name},
418         sock_dir=__opts__["sock_dir"],
419         transport=__opts__["transport"],
420     )
421     if not conn:
422         conn = get_conn()
423     node = show_instance(name, conn=conn, call="action")
424     log.info("Destroying VM: %s", name)
425     ret = conn.delete_server(name)
426     if ret:
427         log.info("Destroyed VM: %s", name)
428             "event",
429             "destroyed instance",
430             "salt/cloud/{}/destroyed"<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(name),
431             args={"name": name},
432             sock_dir=__opts__["sock_dir"],
433             transport=__opts__["transport"],
434         )
435         if __opts__.get("delete_sshkeys", False) is True:
436             __utils__[</b></font>"cloud.remove_sshkey"](
437                 getattr(node, __opts__.get("ssh_interface", "public_ips"))[0]
438             )
439         if __opts__.get("update_cachedir", False) is True:
440             __utils__["cloud.delete_minion_cachedir"](
441                 name, _get_active_provider_name().split(":")[0], __opts__
442             )
443         __utils__["cloud.cachedir_index_del"](name)
444         return True
445     log.error("Failed to Destroy VM: %s", name)
446     return False
447 def call(conn=None, call=None, kwargs=None):
448     if call == "action":
449         raise SaltCloudSystemExit(
450             "The call function must be called with -f or --function."
451         )
452     if "func" not in kwargs:
453         raise SaltCloudSystemExit("No `func` argument passed")
454     if conn is None:
455         conn = get_conn()
456     func = kwargs.pop("func")
457     for key, value in kwargs.items():
458         try:
459             kwargs[key] = __utils__["json.loads"](value)
460         except ValueError:
461             continue
462     try:
463         return getattr(conn, func)(**kwargs)
464     except shade.exc.OpenStackCloudException as exc:
465         log.error("Error running %s: %s", func, exc)
466         raise SaltCloudSystemExit(str(exc))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import hashlib
2 import logging
3 import os
4 import re
5 import salt.utils.files
6 import salt.utils.json
7 import salt.utils.yaml
8 log = logging.getLogger(__name__)
9 def __virtual__():
10     if "boto_apigateway.describe_apis" in __salt__:
11         return "boto_apigateway"
12     return (False, "boto_apigateway module could not be loaded")
13 def present(
14     name,
15     api_name,
16     swagger_file,
17     stage_name,
18     api_key_required,
19     lambda_integration_role,
20     lambda_region=None,
21     stage_variables=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     lambda_funcname_format="{stage}_{api}_{resource}_{method}",
27     authorization_type="NONE",
28     error_response_template=None,
29     response_template=None,
30 ):
31     ret = {"name": name, "result": True, "comment": "", "changes": {}}
32     try:
33         common_args = dict(
34             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
35         )
36         swagger = _Swagger(
37             api_name,
38             stage_name,
39             lambda_funcname_format,
40             swagger_file,
41             error_response_template,
42             response_template,
43             common_args,
44         )
45         stage_vars = _get_stage_variables(stage_variables)
46         ret = swagger.verify_api(ret)
47         if ret.get("publish"):
48             if __opts__["test"]:
49                 ret["comment"] = (
50                     "[stage: {}] will be reassociated to an already available "
51                     "deployment that matched the given [api_name: {}] "
52                     "and [swagger_file: {}].\n"
53                     "Stage variables will be set "
54                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
55                 )
56                 ret["result"] = None
57                 return ret
58             return swagger.publish_api(ret, stage_vars)
59         if ret.get("current"):
60             if __opts__["test"]:
61                 ret["comment"] = (
62                     "[stage: {}] is already at desired state with an associated "
63                     "deployment matching the given [api_name: {}] "
64                     "and [swagger_file: {}].\n"
65                     "Stage variables will be set "
66                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
67                 )
68                 ret["result"] = None
69             return swagger.overwrite_stage_variables(ret, stage_vars)
70         if __opts__["test"]:
71             ret["comment"] = (
72                 "There is no deployment matching the given [api_name: {}] "
73                 "and [swagger_file: {}].  A new deployment will be "
74                 "created and the [stage_name: {}] will then be associated "
75                 "to the newly created deployment.\n"
76                 "Stage variables will be set "
77                 "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
78             )
79             ret["result"] = None
80             return ret
81         ret = swagger.deploy_api(ret)
82         if ret.get("abort"):
83             return ret
84         ret = swagger.deploy_models(ret)
85         if ret.get("abort"):
86             return ret
87         ret = swagger.deploy_resources(
88             ret,
89             api_key_required=api_key_required,
90             lambda_integration_role=lambda_integration_role,
91             lambda_region=lambda_region,
92             authorization_type=authorization_type,
93         )
94         if ret.get("abort"):
95             return ret
96         ret = swagger.publish_api(ret, stage_vars)
97     except (ValueError, OSError) as e:
98         ret["result"] = False
99         ret["comment"] = "{}".format(e.args)
100     return ret
101 def _get_stage_variables(stage_variables):
102     ret = dict()
103     if stage_variables is None:
104         return ret
105     if isinstance(stage_variables, str):
106         if stage_variables in __opts__:
107             ret = __opts__[stage_variables]
108         master_opts = __pillar__.get("master", {})
109         if stage_variables in master_opts:
110             ret = master_opts[stage_variables]
111         if stage_variables in __pillar__:
112             ret = __pillar__[stage_variables]
113     elif isinstance(stage_variables, dict):
114         ret = stage_variables
115     if not isinstance(ret, dict):
116         ret = dict()
117     return ret
118 def absent(
119     name,
120     api_name,
121     stage_name,
122     nuke_api=False,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127 ):
128     ret = {"name": name, "result": True, "comment": "", "changes": {}}
129     try:
130         common_args = dict(
131             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
132         )
133         swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
134         if not swagger.restApiId:
135             ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
136             return ret
137         if __opts__["test"]:
138             if nuke_api:
139                 ret["comment"] = (
140                     "[stage: {}] will be deleted, if there are no other "
141                     "active stages, the [api: {} will also be "
142                     "deleted.".format(stage_name, api_name)
143                 )
144             else:
145                 ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
146             ret["result"] = None
147             return ret
148         ret = swagger.delete_stage(ret)
149         if ret.get("abort"):
150             return ret
151         if nuke_api and swagger.no_more_deployments_remain():
152             ret = swagger.delete_api(ret)
153     except (ValueError, OSError) as e:
154         ret["result"] = False
155         ret["comment"] = "{}".format(e.args)
156     return ret
157 def _gen_md5_filehash(fname, *args):
158     _hash = hashlib.md5()
159     with salt.utils.files.fopen(fname, "rb") as f:
160         for chunk in iter(lambda: f.read(4096), b""):
161             _hash.update(chunk)
162     for extra_arg in args:
163         _hash.update(str(extra_arg).encode())
164     return _hash.hexdigest()
165 def _dict_to_json_pretty(d, sort_keys=True):
166     return salt.utils.json.dumps(
167         d, indent=4, separators=(",", ": "), sort_keys=sort_keys
168     )
169 def _name_matches(name, matches):
170     for m in matches:
171         if name.endswith(m):
172             return True
173         if name.lower().endswith("_" + m.lower()):
174             return True
175         if name.lower() == m.lower():
176             return True
177     return False
178 def _object_reducer(
179     o,
180     names=(
181         "id",
182         "name",
183         "path",
184         "httpMethod",
185         "statusCode",
186         "Created",
187         "Deleted",
188         "Updated",
189         "Flushed",
190         "Associated",
191         "Disassociated",
192     ),
193 ):
194     result = {}
195     if isinstance(o, dict):
196         for k, v in o.items():
197             if isinstance(v, dict):
198                 reduced = v if k == "variables" else _object_reducer(v, names)
199                 if reduced or _name_matches(k, names):
200                     result[k] = reduced
201             elif isinstance(v, list):
202                 newlist = []
203                 for val in v:
204                     reduced = _object_reducer(val, names)
205                     if reduced or _name_matches(k, names):
206                         newlist.append(reduced)
207                 if newlist:
208                     result[k] = newlist
209             else:
210                 if _name_matches(k, names):
211                     result[k] = v
212     return result
213 def _log_changes(ret, changekey, changevalue):
214     cl = ret["changes"].get("new", [])
215     cl.append({changekey: _object_reducer(changevalue)})
216     ret["changes"]["new"] = cl
217     return ret
218 def _log_error_and_abort(ret, obj):
219     ret["result"] = False
220     ret["abort"] = True
221     if "error" in obj:
222         ret["comment"] = "{}".format(obj.get("error"))
223     return ret
224 class _Swagger:
225     SWAGGER_OBJ_V2_FIELDS = (
226         "swagger",
227         "info",
228         "host",
229         "basePath",
230         "schemes",
231         "consumes",
232         "produces",
233         "paths",
234         "definitions",
235         "parameters",
236         "responses",
237         "securityDefinitions",
238         "security",
239         "tags",
240         "externalDocs",
241     )
242     SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
243         "swagger",
244         "info",
245         "basePath",
246         "schemes",
247         "paths",
248         "definitions",
249     )
250     SWAGGER_OPERATION_NAMES = (
251         "get",
252         "put",
253         "post",
254         "delete",
255         "options",
256         "head",
257         "patch",
258     )
259     SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
260     VENDOR_EXT_PATTERN = re.compile("^x-")
261     JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
262     REQUEST_TEMPLATE = {
263         "application/json": (
264             "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
265             " = $input.params().header)\n#foreach( $param in $map.entrySet()"
266             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
267             ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
268             " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
269             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
270             ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
271             " $input.params().path)\n#foreach( $param in $map.entrySet()"
272             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
273             ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
274             ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
275             ' "$context.requestId",\n"resourceId":'
276             ' "$context.resourceId",\n"resourcePath":'
277             ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
278             ' "user":"$context.identity.user",\n '
279             ' "userArn":"$context.identity.userArn",\n '
280             ' "userAgent":"$context.identity.userAgent",\n '
281             ' "sourceIp":"$context.identity.sourceIp",\n '
282             ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
283             ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
284             ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
285             '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
286             '  "caller":"$context.identity.caller",\n '
287             ' "apiKey":"$context.identity.apiKey",\n '
288             ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
289             " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
290             ' $stageVariables.keySet())\n"$variable":'
291             ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
292             " #end\n#end\n}\n}"
293         )
294     }
295     REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
296     RESPONSE_TEMPLATE = {
297         "application/json": (
298             "#set($inputRoot = $input.path('$'))\n"
299             "{\n"
300             '  "errorMessage" : "$inputRoot.errorMessage",\n'
301             '  "errorType" : "$inputRoot.errorType",\n'
302             '  "stackTrace" : [\n'
303             "#foreach($stackTrace in $inputRoot.stackTrace)\n"
304             "    [\n"
305             "#foreach($elem in $stackTrace)\n"
306             '      "$elem"\n'
307             "#if($foreach.hasNext),#end\n"
308             "#end\n"
309             "    ]\n"
310             "#if($foreach.hasNext),#end\n"
311             "#end\n"
312             "  ]\n"
313             "}"
314         )
315     }
316     RESPONSE_OPTION_TEMPLATE = {}
317     AWS_API_DESCRIPTION = _dict_to_json_pretty(
318         {
319             "provisioned_by": "Salt boto_apigateway.present State",
320             "context": "See deployment or stage description",
321         }
322     )
323     class SwaggerParameter:
324         LOCATIONS = ("body", "query", "header", "path")
325         def __init__(self, paramdict):
326             self._paramdict = paramdict
327         @property
328         def location(self):
329             _location = self._paramdict.get("in")
330             if _location in _Swagger.SwaggerParameter.LOCATIONS:
331                 return _location
332             raise ValueError(
333                 "Unsupported parameter location: {} in Parameter Object".format(
334                     _location
335                 )
336             )
337         @property
338         def name(self):
339             _name = self._paramdict.get("name")
340             if _name:
341                 if self.location == "header":
342                     return "method.request.header.{}".format(_name)
343                 elif self.location == "query":
344                     return "method.request.querystring.{}".format(_name)
345                 elif self.location == "path":
346                     return "method.request.path.{}".format(_name)
347                 return None
348             raise ValueError(
349                 "Parameter must have a name: {}".format(
350                     _dict_to_json_pretty(self._paramdict)
351                 )
352             )
353         @property
354         def schema(self):
355             if self.location == "body":
356                 _schema = self._paramdict.get("schema")
357                 if _schema:
358                     if "$ref" in _schema:
359                         schema_name = _schema.get("$ref").split("/")[-1]
360                         return schema_name
361                     raise ValueError(
362                         "Body parameter must have a JSON reference "
363                         "to the schema definition due to Amazon API restrictions: {}".format(
364                             self.name
365                         )
366                     )
367                 raise ValueError(
368                     "Body parameter must have a schema: {}".format(self.name)
369                 )
370             return None
371     class SwaggerMethodResponse:
372         def __init__(self, r):
373             self._r = r
374         @property
375         def schema(self):
376             _schema = self._r.get("schema")
377             if _schema:
378                 if "$ref" in _schema:
379                     return _schema.get("$ref").split("/")[-1]
380                 raise ValueError(
381                     "Method response must have a JSON reference "
382                     "to the schema definition: {}".format(_schema)
383                 )
384             return None
385         @property
386         def headers(self):
387             _headers = self._r.get("headers", {})
388             return _headers
389     def __init__(
390         self,
391         api_name,
392         stage_name,
393         lambda_funcname_format,
394         swagger_file_path,
395         error_response_template,
396         response_template,
397         common_aws_args,
398     ):
399         self._api_name = api_name
400         self._stage_name = stage_name
401         self._lambda_funcname_format = lambda_funcname_format
402         self._common_aws_args = common_aws_args
403         self._restApiId = ""
404         self._deploymentId = ""
405         self._error_response_template = error_response_template
406         self._response_template = response_template
407         if swagger_file_path is not None:
408             if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
409                 self._swagger_file = swagger_file_path
410                 self._md5_filehash = _gen_md5_filehash(
411                     self._swagger_file, error_response_template, response_template
412                 )
413                 with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
414                     self._cfg = salt.utils.yaml.safe_load(sf)
415                 self._swagger_version = ""
416             else:
417                 raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
418             self._validate_swagger_file()
419         self._validate_lambda_funcname_format()
420         self._resolve_api_id()
421     def _is_http_error_rescode(self, code):
422         return bool(re.match(r"^\s*[45]\d\d\s*$", code))
423     def _validate_error_response_model(self, paths, mods):
424         for path, ops in paths:
425             for opname, opobj in ops.items():
426                 if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
427                     continue
428                 if "responses" not in opobj:
429                     raise ValueError(
430                         "missing mandatory responses field in path item object"
431                     )
432                 for rescode, resobj in opobj.get("responses").items():
433                     if not self._is_http_error_rescode(str(rescode)):
434                         continue
435                     if "schema" not in resobj:
436                         raise ValueError(
437                             "missing schema field in path {}, "
438                             "op {}, response {}".format(path, opname, rescode)
439                         )
440                     schemaobj = resobj.get("schema")
441                     if "$ref" not in schemaobj:
442                         raise ValueError(
443                             "missing $ref field under schema in "
444                             "path {}, op {}, response {}".format(path, opname, rescode)
445                         )
446                     schemaobjref = schemaobj.get("$ref", "/")
447                     modelname = schemaobjref.split("/")[-1]
448                     if modelname not in mods:
449                         raise ValueError(
450                             "model schema {} reference not found "
451                             "under /definitions".format(schemaobjref)
452                         )
453                     model = mods.get(modelname)
454                     if model.get("type") != "object":
455                         raise ValueError(
456                             "model schema {} must be type object".format(modelname)
457                         )
458                     if "properties" not in model:
459                         raise ValueError(
460                             "model schema {} must have properties fields".format(
461                                 modelname
462                             )
463                         )
464                     modelprops = model.get("properties")
465                     if "errorMessage" not in modelprops:
466                         raise ValueError(
467                             "model schema {} must have errorMessage as a property to "
468                             "match AWS convention. If pattern is not set, .+ will "
469                             "be used".format(modelname)
470                         )
471     def _validate_lambda_funcname_format(self):
472         try:
473             if self._lambda_funcname_format:
474                 known_kwargs = dict(stage="", api="", resource="", method="")
475                 self._lambda_funcname_format.format(**known_kwargs)
476             return True
477         except Exception:  # pylint: disable=broad-except
478             raise ValueError(
479                 "Invalid lambda_funcname_format {}.  Please review "
480                 "documentation for known substitutable keys".format(
481                     self._lambda_funcname_format
482                 )
483             )
484     def _validate_swagger_file(self):
485         for field in self._cfg:
486             if (
487                 field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
488                 and not _Swagger.VENDOR_EXT_PATTERN.match(field)
489             ):
490                 raise ValueError("Invalid Swagger Object Field: {}".format(field))
491         for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
492             if field not in self._cfg:
493                 raise ValueError("Missing Swagger Object Field: {}".format(field))
494         self._swagger_version = self._cfg.get("swagger")
495         if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
496             raise ValueError(
497                 "Unsupported Swagger version: {},Supported versions are {}".format(
498                     self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
499                 )
500             )
501         log.info(type(self._models))
502         self._validate_error_response_model(self.paths, self._models())
503     @property
504     def md5_filehash(self):
505         return self._md5_filehash
506     @property
507     def info(self):
508         info = self._cfg.get("info")
509         if not info:
510             raise ValueError("Info Object has no values")
511         return info
512     @property
513     def info_json(self):
514         return _dict_to_json_pretty(self.info)
515     @property
516     def rest_api_name(self):
517         return self._api_name
518     @property
519     def rest_api_version(self):
520         version = self.info.get("version")
521         if not version:
522             raise ValueError("Missing version value in Info Object")
523         return version
524     def _models(self):
525         models = self._cfg.get("definitions")
526         if not models:
527             raise ValueError(
528                 "Definitions Object has no values, You need to define them in your"
529                 " swagger file"
530             )
531         return models
532     def models(self):
533         model_dict = self._build_all_dependencies()
534         while True:
535             model = self._get_model_without_dependencies(model_dict)
536             if not model:
537                 break
538             yield (model, self._models().get(model))
539     @property
540     def paths(self):
541         paths = self._cfg.get("paths")
542         if not paths:
543             raise ValueError(
544                 "Paths Object has no values, You need to define them in your swagger"
545                 " file"
546             )
547         for path in paths:
548             if not path.startswith("/"):
549                 raise ValueError(
550                     "Path object {} should start with /. Please fix it".format(path)
551                 )
552         return paths.items()
553     @property
554     def basePath(self):
555         basePath = self._cfg.get("basePath", "")
556         return basePath
557     @property
558     def restApiId(self):
559         return self._restApiId
560     @restApiId.setter
561     def restApiId(self, restApiId):
562         self._restApiId = restApiId
563     @property
564     def deployment_label_json(self):
565         return _dict_to_json_pretty(self.deployment_label)
566     @property
567     def deployment_label(self):
568         label = dict()
569         label["swagger_info_object"] = self.info
570         label["api_name"] = self.rest_api_name
571         label["swagger_file"] = os.path.basename(self._swagger_file)
572         label["swagger_file_md5sum"] = self.md5_filehash
573         return label
574     def _one_or_more_stages_remain(self, deploymentId):
575         stages = __salt__["boto_apigateway.describe_api_stages"](
576             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
577         ).get("stages")
578         return bool(stages)
579     def no_more_deployments_remain(self):
580         no_more_deployments = True
581         deployments = __salt__["boto_apigateway.describe_api_deployments"](
582             restApiId=self.restApiId, **self._common_aws_args
583         ).get("deployments")
584         if deployments:
585             for deployment in deployments:
586                 deploymentId = deployment.get("id")
587                 stages = __salt__["boto_apigateway.describe_api_stages"](
588                     restApiId=self.restApiId,
589                     deploymentId=deploymentId,
590                     **self._common_aws_args
591                 ).get("stages")
592                 if stages:
593                     no_more_deployments = False
594                     break
595         return no_more_deployments
596     def _get_current_deployment_id(self):
597         deploymentId = ""
598         stage = __salt__["boto_apigateway.describe_api_stage"](
599             restApiId=self.restApiId,
600             stageName=self._stage_name,
601             **self._common_aws_args
602         ).get("stage")
603         if stage:
604             deploymentId = stage.get("deploymentId")
605         return deploymentId
606     def _get_current_deployment_label(self):
607         deploymentId = self._get_current_deployment_id()
608         deployment = __salt__["boto_apigateway.describe_api_deployment"](
609             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
610         ).get("deployment")
611         if deployment:
612             return deployment.get("description")
613         return None
614     def _get_desired_deployment_id(self):
615         deployments = __salt__["boto_apigateway.describe_api_deployments"](
616             restApiId=self.restApiId, **self._common_aws_args
617         ).get("deployments")
618         if deployments:
619             for deployment in deployments:
620                 if deployment.get("description") == self.deployment_label_json:
621                     return deployment.get("id")
622         return ""
623     def overwrite_stage_variables(self, ret, stage_variables):
624         overwrite the given stage_name's stage variables with the given stage_variables
625         """
626         res = __salt__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto_apigateway.overwrite_api_stage_variables"](
627             restApiId=self.restApiId,
628             stageName=self._stage_name,
629             variables=stage_variables,
630             **self._common_aws_args
631         )
632         if not res.get("overwrite"):
633             ret[</b></font>"result"] = False
634             ret["abort"] = True
635             ret["comment"] = res.get("error")
636         else:
637             ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
638         return ret
639     def _set_current_deployment(self, stage_desc_json, stage_variables):
640         """
641         Helper method to associate the stage_name to the given deploymentId and make this current
642         """
643         stage = __salt__["boto_apigateway.describe_api_stage"](
644             restApiId=self.restApiId,
645             stageName=self._stage_name,
646             **self._common_aws_args
647         ).get("stage")
648         if not stage:
649             stage = __salt__["boto_apigateway.create_api_stage"](
650                 restApiId=self.restApiId,
651                 stageName=self._stage_name,
652                 deploymentId=self._deploymentId,
653                 description=stage_desc_json,
654                 variables=stage_variables,
655                 **self._common_aws_args
656             )
657             if not stage.get("stage"):
658                 return {"set": False, "error": stage.get("error")}
659         else:
660             overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
661                 restApiId=self.restApiId,
662                 stageName=self._stage_name,
663                 variables=stage_variables,
664                 **self._common_aws_args
665             )
666             if not overwrite.get("stage"):
667                 return {"set": False, "error": overwrite.get("error")}
668         return __salt__["boto_apigateway.activate_api_deployment"](
669             restApiId=self.restApiId,
670             stageName=self._stage_name,
671             deploymentId=self._deploymentId,
672             **self._common_aws_args
673         )
674     def _resolve_api_id(self):
675         """
676         returns an Api Id that matches the given api_name and the hardcoded _Swagger.AWS_API_DESCRIPTION
677         as the api description
678         """
679         apis = __salt__["boto_apigateway.describe_apis"](
680             name=self.rest_api_name,
681             description=_Swagger.AWS_API_DESCRIPTION,
682             **self._common_aws_args
683         ).get("restapi")
684         if apis:
685             if len(apis) == 1:
686                 self.restApiId = apis[0].get("id")
687             else:
688                 raise ValueError(
689                     "Multiple APIs matching given name {} and description {}".format(
690                         self.rest_api_name, self.info_json
691                     )
692                 )
693     def delete_stage(self, ret):
694         """
695         Method to delete the given stage_name.  If the current deployment tied to the given
696         stage_name has no other stages associated with it, the deployment will be removed
697         as well
698         """
699         deploymentId = self._get_current_deployment_id()
700         if deploymentId:
701             result = __salt__["boto_apigateway.delete_api_stage"](
702                 restApiId=self.restApiId,
703                 stageName=self._stage_name,
704                 **self._common_aws_args
705             )
706             if not result.get("deleted"):
707                 ret["abort"] = True
708                 ret["result"] = False
709                 ret["comment"] = "delete_stage delete_api_stage, {}".format(
710                     result.get("error")
711                 )
712             else:
713                 if not self._one_or_more_stages_remain(deploymentId):
714                     result = __salt__["boto_apigateway.delete_api_deployment"](
715                         restApiId=self.restApiId,
716                         deploymentId=deploymentId,
717                         **self._common_aws_args
718                     )
719                     if not result.get("deleted"):
720                         ret["abort"] = True
721                         ret["result"] = False
722                         ret[
723                             "comment"
724                         ] = "delete_stage delete_api_deployment, {}".format(
725                             result.get("error")
726                         )
727                 else:
728                     ret["comment"] = "stage {} has been deleted.\n".format(
729                         self._stage_name
730                     )
731         else:
732             ret["comment"] = "stage {} does not exist".format(self._stage_name)
733         return ret
734     def verify_api(self, ret):
735         """
736         this method helps determine if the given stage_name is already on a deployment
737         label matching the input api_name, swagger_file.
738         If yes, returns abort with comment indicating already at desired state.
739         If not and there is previous deployment labels in AWS matching the given input api_name and
740         swagger file, indicate to the caller that we only need to reassociate stage_name to the
741         previously existing deployment label.
742         """
743         if self.restApiId:
744             deployed_label_json = self._get_current_deployment_label()
745             if deployed_label_json == self.deployment_label_json:
746                 ret["comment"] = (
747                     "Already at desired state, the stage {} is already at the desired "
748                     "deployment label:\n{}".format(
749                         self._stage_name, deployed_label_json
750                     )
751                 )
752                 ret["current"] = True
753                 return ret
754             else:
755                 self._deploymentId = self._get_desired_deployment_id()
756                 if self._deploymentId:
757                     ret["publish"] = True
758         return ret
759     def publish_api(self, ret, stage_variables):
760         """
761         this method tie the given stage_name to a deployment matching the given swagger_file
762         """
763         stage_desc = dict()
764         stage_desc["current_deployment_label"] = self.deployment_label
765         stage_desc_json = _dict_to_json_pretty(stage_desc)
766         if self._deploymentId:
767             res = self._set_current_deployment(stage_desc_json, stage_variables)
768             if not res.get("set"):
769                 ret["abort"] = True
770                 ret["result"] = False
771                 ret["comment"] = res.get("error")
772             else:
773                 ret = _log_changes(
774                     ret,
775                     "publish_api (reassociate deployment, set stage_variables)",
776                     res.get("response"),
777                 )
778         else:
779             res = __salt__["boto_apigateway.create_api_deployment"](
780                 restApiId=self.restApiId,
781                 stageName=self._stage_name,
782                 stageDescription=stage_desc_json,
783                 description=self.deployment_label_json,
784                 variables=stage_variables,
785                 **self._common_aws_args
786             )
787             if not res.get("created"):
788                 ret["abort"] = True
789                 ret["result"] = False
790                 ret["comment"] = res.get("error")
791             else:
792                 ret = _log_changes(
793                     ret, "publish_api (new deployment)", res.get("deployment")
794                 )
795         return ret
796     def _cleanup_api(self):
797         """
798         Helper method to clean up resources and models if we detected a change in the swagger file
799         for a stage
800         """
801         resources = __salt__["boto_apigateway.describe_api_resources"](
802             restApiId=self.restApiId, **self._common_aws_args
803         )
804         if resources.get("resources"):
805             res = resources.get("resources")[1:]
806             res.reverse()
807             for resource in res:
808                 delres = __salt__["boto_apigateway.delete_api_resources"](
809                     restApiId=self.restApiId,
810                     path=resource.get("path"),
811                     **self._common_aws_args
812                 )
813                 if not delres.get("deleted"):
814                     return delres
815         models = __salt__["boto_apigateway.describe_api_models"](
816             restApiId=self.restApiId, **self._common_aws_args
817         )
818         if models.get("models"):
819             for model in models.get("models"):
820                 delres = __salt__["boto_apigateway.delete_api_model"](
821                     restApiId=self.restApiId,
822                     modelName=model.get("name"),
823                     **self._common_aws_args
824                 )
825                 if not delres.get("deleted"):
826                     return delres
827         return {"deleted": True}
828     def deploy_api(self, ret):
829         """
830         this method create the top level rest api in AWS apigateway
831         """
832         if self.restApiId:
833             res = self._cleanup_api()
834             if not res.get("deleted"):
835                 ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
836                 ret["abort"] = True
837                 ret["result"] = False
838                 return ret
839             return ret
840         response = __salt__["boto_apigateway.create_api"](
841             name=self.rest_api_name,
842             description=_Swagger.AWS_API_DESCRIPTION,
843             **self._common_aws_args
844         )
845         if not response.get("created"):
846             ret["result"] = False
847             ret["abort"] = True
848             if "error" in response:
849                 ret["comment"] = "Failed to create rest api: {}.".format(
850                     response["error"]["message"]
851                 )
852             return ret
853         self.restApiId = response.get("restapi", {}).get("id")
854         return _log_changes(ret, "deploy_api", response.get("restapi"))
855     def delete_api(self, ret):
856         """
857         Method to delete a Rest Api named defined in the swagger file's Info Object's title value.
858         ret
859             a dictionary for returning status to Saltstack
860         """
861         exists_response = __salt__["boto_apigateway.api_exists"](
862             name=self.rest_api_name,
863             description=_Swagger.AWS_API_DESCRIPTION,
864             **self._common_aws_args
865         )
866         if exists_response.get("exists"):
867             if __opts__["test"]:
868                 ret["comment"] = "Rest API named {} is set to be deleted.".format(
869                     self.rest_api_name
870                 )
871                 ret["result"] = None
872                 ret["abort"] = True
873                 return ret
874             delete_api_response = __salt__["boto_apigateway.delete_api"](
875                 name=self.rest_api_name,
876                 description=_Swagger.AWS_API_DESCRIPTION,
877                 **self._common_aws_args
878             )
879             if not delete_api_response.get("deleted"):
880                 ret["result"] = False
881                 ret["abort"] = True
882                 if "error" in delete_api_response:
883                     ret["comment"] = "Failed to delete rest api: {}.".format(
884                         delete_api_response["error"]["message"]
885                     )
886                 return ret
887             ret = _log_changes(ret, "delete_api", delete_api_response)
888         else:
889             ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
890                 self.rest_api_name, self.info_json
891             )
892         return ret
893     def _aws_model_ref_from_swagger_ref(self, r):
894         """
895         Helper function to reference models created on aws apigw
896         """
897         model_name = r.split("/")[-1]
898         return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
899             self.restApiId, model_name
900         )
901     def _update_schema_to_aws_notation(self, schema):
902         """
903         Helper function to map model schema to aws notation
904         """
905         result = {}
906         for k, v in schema.items():
907             if k == "$ref":
908                 v = self._aws_model_ref_from_swagger_ref(v)
909             if isinstance(v, dict):
910                 v = self._update_schema_to_aws_notation(v)
911             result[k] = v
912         return result
913     def _build_dependent_model_list(self, obj_schema):
914         """
915         Helper function to build the list of models the given object schema is referencing.
916         """
917         dep_models_list = []
918         if obj_schema:
919             obj_schema["type"] = obj_schema.get("type", "object")
920         if obj_schema["type"] == "array":
921             dep_models_list.extend(
922                 self._build_dependent_model_list(obj_schema.get("items", {}))
923             )
924         else:
925             ref = obj_schema.get("$ref")
926             if ref:
927                 ref_obj_model = ref.split("/")[-1]
928                 ref_obj_schema = self._models().get(ref_obj_model)
929                 dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
930                 dep_models_list.extend([ref_obj_model])
931             else:
932                 properties = obj_schema.get("properties")
933                 if properties:
934                     for _, prop_obj_schema in properties.items():
935                         dep_models_list.extend(
936                             self._build_dependent_model_list(prop_obj_schema)
937                         )
938         return list(set(dep_models_list))
939     def _build_all_dependencies(self):
940         """
941         Helper function to build a map of model to their list of model reference dependencies
942         """
943         ret = {}
944         for model, schema in self._models().items():
945             dep_list = self._build_dependent_model_list(schema)
946             ret[model] = dep_list
947         return ret
948     def _get_model_without_dependencies(self, models_dict):
949         """
950         Helper function to find the next model that should be created
951         """
952         next_model = None
953         if not models_dict:
954             return next_model
955         for model, dependencies in models_dict.items():
956             if dependencies == []:
957                 next_model = model
958                 break
959         if next_model is None:
960             raise ValueError(
961                 "incomplete model definitions, models in dependency "
962                 "list not defined: {}".format(models_dict)
963             )
964         models_dict.pop(next_model)
965         for model, dep_list in models_dict.items():
966             if next_model in dep_list:
967                 dep_list.remove(next_model)
968         return next_model
969     def deploy_models(self, ret):
970         """
971         Method to deploy swagger file's definition objects and associated schema to AWS Apigateway as Models
972         ret
973             a dictionary for returning status to Saltstack
974         """
975         for model, schema in self.models():
976             _schema = self._update_schema_to_aws_notation(schema)
977             _schema.update(
978                 {
979                     "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
980                     "title": "{} Schema".format(model),
981                 }
982             )
983             model_exists_response = __salt__["boto_apigateway.api_model_exists"](
984                 restApiId=self.restApiId, modelName=model, **self._common_aws_args
985             )
986             if model_exists_response.get("exists"):
987                 update_model_schema_response = __salt__[
988                     "boto_apigateway.update_api_model_schema"
989                 ](
990                     restApiId=self.restApiId,
991                     modelName=model,
992                     schema=_dict_to_json_pretty(_schema),
993                     **self._common_aws_args
994                 )
995                 if not update_model_schema_response.get("updated"):
996                     ret["result"] = False
997                     ret["abort"] = True
998                     if "error" in update_model_schema_response:
999                         ret[
1000                             "comment"
1001                         ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
1002                             model,
1003                             _dict_to_json_pretty(schema),
1004                             update_model_schema_response["error"]["message"],
1005                         )
1006                     return ret
1007                 ret = _log_changes(ret, "deploy_models", update_model_schema_response)
1008             else:
1009                 create_model_response = __salt__["boto_apigateway.create_api_model"](
1010                     restApiId=self.restApiId,
1011                     modelName=model,
1012                     modelDescription=model,
1013                     schema=_dict_to_json_pretty(_schema),
1014                     contentType="application/json",
1015                     **self._common_aws_args
1016                 )
1017                 if not create_model_response.get("created"):
1018                     ret["result"] = False
1019                     ret["abort"] = True
1020                     if "error" in create_model_response:
1021                         ret[
1022                             "comment"
1023                         ] = "Failed to create model {}, schema {}, error: {}".format(
1024                             model,
1025                             _dict_to_json_pretty(schema),
1026                             create_model_response["error"]["message"],
1027                         )
1028                     return ret
1029                 ret = _log_changes(ret, "deploy_models", create_model_response)
1030         return ret
1031     def _lambda_name(self, resourcePath, httpMethod):
1032         """
1033         Helper method to construct lambda name based on the rule specified in doc string of
1034         boto_apigateway.api_present function
1035         """
1036         lambda_name = self._lambda_funcname_format.format(
1037             stage=self._stage_name,
1038             api=self.rest_api_name,
1039             resource=resourcePath,
1040             method=httpMethod,
1041         )
1042         lambda_name = lambda_name.strip()
1043         lambda_name = re.sub(r"{|}", "", lambda_name)
1044         lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
1045         return re.sub(r"_+", "_", lambda_name)
1046     def _lambda_uri(self, lambda_name, lambda_region):
1047         """
1048         Helper Method to construct the lambda uri for use in method integration
1049         """
1050         profile = self._common_aws_args.get("profile")
1051         region = self._common_aws_args.get("region")
1052         lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
1053         apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
1054         lambda_desc = __salt__["boto_lambda.describe_function"](
1055             lambda_name, **self._common_aws_args
1056         )
1057         if lambda_region != apigw_region:
1058             if not lambda_desc.get("function"):
1059                 lambda_desc = __salt__["boto_lambda.describe_function"](
1060                     lambda_name, **self._common_aws_args
1061                 )
1062         if not lambda_desc.get("function"):
1063             raise ValueError(
1064                 "Could not find lambda function {} in regions [{}, {}].".format(
1065                     lambda_name, lambda_region, apigw_region
1066                 )
1067             )
1068         lambda_arn = lambda_desc.get("function").get("FunctionArn")
1069         lambda_uri = (
1070             "arn:aws:apigateway:{}:lambda:path/2015-03-31"
1071             "/functions/{}/invocations".format(apigw_region, lambda_arn)
1072         )
1073         return lambda_uri
1074     def _parse_method_data(self, method_name, method_data):
1075         """
1076         Helper function to construct the method request params, models, request_templates and
1077         integration_type values needed to configure method request integration/mappings.
1078         """
1079         method_params = {}
1080         method_models = {}
1081         if "parameters" in method_data:
1082             for param in method_data["parameters"]:
1083                 p = _Swagger.SwaggerParameter(param)
1084                 if p.name:
1085                     method_params[p.name] = True
1086                 if p.schema:
1087                     method_models["application/json"] = p.schema
1088         request_templates = (
1089             _Swagger.REQUEST_OPTION_TEMPLATE
1090             if method_name == "options"
1091             else _Swagger.REQUEST_TEMPLATE
1092         )
1093         integration_type = "MOCK" if method_name == "options" else "AWS"
1094         return {
1095             "params": method_params,
1096             "models": method_models,
1097             "request_templates": request_templates,
1098             "integration_type": integration_type,
1099         }
1100     def _find_patterns(self, o):
1101         result = []
1102         if isinstance(o, dict):
1103             for k, v in o.items():
1104                 if isinstance(v, dict):
1105                     result.extend(self._find_patterns(v))
1106                 else:
1107                     if k == "pattern":
1108                         result.append(v)
1109         return result
1110     def _get_pattern_for_schema(self, schema_name, httpStatus):
1111         """
1112         returns the pattern specified in a response schema
1113         """
1114         defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
1115         model = self._models().get(schema_name)
1116         patterns = self._find_patterns(model)
1117         return patterns[0] if patterns else defaultPattern
1118     def _get_response_template(self, method_name, http_status):
1119         if method_name == "options" or not self._is_http_error_rescode(http_status):
1120             response_templates = (
1121                 {"application/json": self._response_template}
1122                 if self._response_template
1123                 else self.RESPONSE_OPTION_TEMPLATE
1124             )
1125         else:
1126             response_templates = (
1127                 {"application/json": self._error_response_template}
1128                 if self._error_response_template
1129                 else self.RESPONSE_TEMPLATE
1130             )
1131         return response_templates
1132     def _parse_method_response(self, method_name, method_response, httpStatus):
1133         """
1134         Helper function to construct the method response params, models, and integration_params
1135         values needed to configure method response integration/mappings.
1136         """
1137         method_response_models = {}
1138         method_response_pattern = ".*"
1139         if method_response.schema:
1140             method_response_models["application/json"] = method_response.schema
1141             method_response_pattern = self._get_pattern_for_schema(
1142                 method_response.schema, httpStatus
1143             )
1144         method_response_params = {}
1145         method_integration_response_params = {}
1146         for header in method_response.headers:
1147             response_header = "method.response.header.{}".format(header)
1148             method_response_params[response_header] = False
1149             header_data = method_response.headers.get(header)
1150             method_integration_response_params[response_header] = (
1151                 "'{}'".format(header_data.get("default"))
1152                 if "default" in header_data
1153                 else "'*'"
1154             )
1155         response_templates = self._get_response_template(method_name, httpStatus)
1156         return {
1157             "params": method_response_params,
1158             "models": method_response_models,
1159             "integration_params": method_integration_response_params,
1160             "pattern": method_response_pattern,
1161             "response_templates": response_templates,
1162         }
1163     def _deploy_method(
1164         self,
1165         ret,
1166         resource_path,
1167         method_name,
1168         method_data,
1169         api_key_required,
1170         lambda_integration_role,
1171         lambda_region,
1172         authorization_type,
1173     ):
1174         """
1175         Method to create a method for the given resource path, along with its associated
1176         request and response integrations.
1177         ret
1178             a dictionary for returning status to Saltstack
1179         resource_path
1180             the full resource path where the named method_name will be associated with.
1181         method_name
1182             a string that is one of the following values: 'delete', 'get', 'head', 'options',
1183             'patch', 'post', 'put'
1184         method_data
1185             the value dictionary for this method in the swagger definition file.
1186         api_key_required
1187             True or False, whether api key is required to access this method.
1188         lambda_integration_role
1189             name of the IAM role or IAM role arn that Api Gateway will assume when executing
1190             the associated lambda function
1191         lambda_region
1192             the region for the lambda function that Api Gateway will integrate to.
1193         authorization_type
1194             'NONE' or 'AWS_IAM'
1195         """
1196         method = self._parse_method_data(method_name.lower(), method_data)
1197         if method_name.lower() == "options":
1198             api_key_required = False
1199             authorization_type = "NONE"
1200         m = __salt__["boto_apigateway.create_api_method"](
1201             restApiId=self.restApiId,
1202             resourcePath=resource_path,
1203             httpMethod=method_name.upper(),
1204             authorizationType=authorization_type,
1205             apiKeyRequired=api_key_required,
1206             requestParameters=method.get("params"),
1207             requestModels=method.get("models"),
1208             **self._common_aws_args
1209         )
1210         if not m.get("created"):
1211             ret = _log_error_and_abort(ret, m)
1212             return ret
1213         ret = _log_changes(ret, "_deploy_method.create_api_method", m)
1214         lambda_uri = ""
1215         if method_name.lower() != "options":
1216             lambda_uri = self._lambda_uri(
1217                 self._lambda_name(resource_path, method_name),
1218                 lambda_region=lambda_region,
1219             )
1220         integration = __salt__["boto_apigateway.create_api_integration"](
1221             restApiId=self.restApiId,
1222             resourcePath=resource_path,
1223             httpMethod=method_name.upper(),
1224             integrationType=method.get("integration_type"),
1225             integrationHttpMethod="POST",
1226             uri=lambda_uri,
1227             credentials=lambda_integration_role,
1228             requestTemplates=method.get("request_templates"),
1229             **self._common_aws_args
1230         )
1231         if not integration.get("created"):
1232             ret = _log_error_and_abort(ret, integration)
1233             return ret
1234         ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
1235         if "responses" in method_data:
1236             for response, response_data in method_data["responses"].items():
1237                 httpStatus = str(response)
1238                 method_response = self._parse_method_response(
1239                     method_name.lower(),
1240                     _Swagger.SwaggerMethodResponse(response_data),
1241                     httpStatus,
1242                 )
1243                 mr = __salt__["boto_apigateway.create_api_method_response"](
1244                     restApiId=self.restApiId,
1245                     resourcePath=resource_path,
1246                     httpMethod=method_name.upper(),
1247                     statusCode=httpStatus,
1248                     responseParameters=method_response.get("params"),
1249                     responseModels=method_response.get("models"),
1250                     **self._common_aws_args
1251                 )
1252                 if not mr.get("created"):
1253                     ret = _log_error_and_abort(ret, mr)
1254                     return ret
1255                 ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
1256                 mir = __salt__["boto_apigateway.create_api_integration_response"](
1257                     restApiId=self.restApiId,
1258                     resourcePath=resource_path,
1259                     httpMethod=method_name.upper(),
1260                     statusCode=httpStatus,
1261                     selectionPattern=method_response.get("pattern"),
1262                     responseParameters=method_response.get("integration_params"),
1263                     responseTemplates=method_response.get("response_templates"),
1264                     **self._common_aws_args
1265                 )
1266                 if not mir.get("created"):
1267                     ret = _log_error_and_abort(ret, mir)
1268                     return ret
1269                 ret = _log_changes(
1270                     ret, "_deploy_method.create_api_integration_response", mir
1271                 )
1272         else:
1273             raise ValueError(
1274                 "No responses specified for {} {}".format(resource_path, method_name)
1275             )
1276         return ret
1277     def deploy_resources(
1278         self,
1279         ret,
1280         api_key_required,
1281         lambda_integration_role,
1282         lambda_region,
1283         authorization_type,
1284     ):
1285         """
1286         Method to deploy resources defined in the swagger file.
1287         ret
1288             a dictionary for returning status to Saltstack
1289         api_key_required
1290             True or False, whether api key is required to access this method.
1291         lambda_integration_role
1292             name of the IAM role or IAM role arn that Api Gateway will assume when executing
1293             the associated lambda function
1294         lambda_region
1295             the region for the lambda function that Api Gateway will integrate to.
1296         authorization_type
1297             'NONE' or 'AWS_IAM'
1298         """
1299         for path, pathData in self.paths:
1300             resource = __salt__["boto_apigateway.create_api_resources"](
1301                 restApiId=self.restApiId, path=path, **self._common_aws_args
1302             )
1303             if not resource.get("created"):
1304                 ret = _log_error_and_abort(ret, resource)
1305                 return ret
1306             ret = _log_changes(ret, "deploy_resources", resource)
1307             for method, method_data in pathData.items():
1308                 if method in _Swagger.SWAGGER_OPERATION_NAMES:
1309                     ret = self._deploy_method(
1310                         ret,
1311                         path,
1312                         method,
1313                         method_data,
1314                         api_key_required,
1315                         lambda_integration_role,
1316                         lambda_region,
1317                         authorization_type,
1318                     )
1319         return ret
1320 def usage_plan_present(
1321     name,
1322     plan_name,
1323     description=None,
1324     throttle=None,
1325     quota=None,
1326     region=None,
1327     key=None,
1328     keyid=None,
1329     profile=None,
1330 ):
1331     """
1332     Ensure the spcifieda usage plan with the corresponding metrics is deployed
1333     .. versionadded:: 2017.7.0
1334     name
1335         name of the state
1336     plan_name
1337         [Required] name of the usage plan
1338     throttle
1339         [Optional] throttling parameters expressed as a dictionary.
1340         If provided, at least one of the throttling parameters must be present
1341         rateLimit
1342             rate per second at which capacity bucket is populated
1343         burstLimit
1344             maximum rate allowed
1345     quota
1346         [Optional] quota on the number of api calls permitted by the plan.
1347         If provided, limit and period must be present
1348         limit
1349             [Required] number of calls permitted per quota period
1350         offset
1351             [Optional] number of calls to be subtracted from the limit at the beginning of the period
1352         period
1353             [Required] period to which quota applies. Must be DAY, WEEK or MONTH
1354     .. code-block:: yaml
1355         UsagePlanPresent:
1356           boto_apigateway.usage_plan_present:
1357             - plan_name: my_usage_plan
1358             - throttle:
1359                 rateLimit: 70
1360                 burstLimit: 100
1361             - quota:
1362                 limit: 1000
1363                 offset: 0
1364                 period: DAY
1365             - profile: my_profile
1366     """
1367     func_params = locals()
1368     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1369     try:
1370         common_args = dict(
1371             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1372         )
1373         existing = __salt__["boto_apigateway.describe_usage_plans"](
1374             name=plan_name, **common_args
1375         )
1376         if "error" in existing:
1377             ret["result"] = False
1378             ret["comment"] = "Failed to describe existing usage plans"
1379             return ret
1380         if not existing["plans"]:
1381             if __opts__["test"]:
1382                 ret["comment"] = "a new usage plan {} would be created".format(
1383                     plan_name
1384                 )
1385                 ret["result"] = None
1386                 return ret
1387             result = __salt__["boto_apigateway.create_usage_plan"](
1388                 name=plan_name,
1389                 description=description,
1390                 throttle=throttle,
1391                 quota=quota,
1392                 **common_args
1393             )
1394             if "error" in result:
1395                 ret["result"] = False
1396                 ret["comment"] = "Failed to create a usage plan {}, {}".format(
1397                     plan_name, result["error"]
1398                 )
1399                 return ret
1400             ret["changes"]["old"] = {"plan": None}
1401             ret["comment"] = "A new usage plan {} has been created".format(plan_name)
1402         else:
1403             plan = existing["plans"][0]
1404             needs_updating = False
1405             modifiable_params = (
1406                 ("throttle", ("rateLimit", "burstLimit")),
1407                 ("quota", ("limit", "offset", "period")),
1408             )
1409             for p, fields in modifiable_params:
1410                 for f in fields:
1411                     actual_param = (
1412                         {} if func_params.get(p) is None else func_params.get(p)
1413                     )
1414                     if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
1415                         needs_updating = True
1416                         break
1417             if not needs_updating:
1418                 ret["comment"] = "usage plan {} is already in a correct state".format(
1419                     plan_name
1420                 )
1421                 ret["result"] = True
1422                 return ret
1423             if __opts__["test"]:
1424                 ret["comment"] = "a new usage plan {} would be updated".format(
1425                     plan_name
1426                 )
1427                 ret["result"] = None
1428                 return ret
1429             result = __salt__["boto_apigateway.update_usage_plan"](
1430                 plan["id"], throttle=throttle, quota=quota, **common_args
1431             )
1432             if "error" in result:
1433                 ret["result"] = False
1434                 ret["comment"] = "Failed to update a usage plan {}, {}".format(
1435                     plan_name, result["error"]
1436                 )
1437                 return ret
1438             ret["changes"]["old"] = {"plan": plan}
1439             ret["comment"] = "usage plan {} has been updated".format(plan_name)
1440         newstate = __salt__["boto_apigateway.describe_usage_plans"](
1441             name=plan_name, **common_args
1442         )
1443         if "error" in existing:
1444             ret["result"] = False
1445             ret["comment"] = "Failed to describe existing usage plans after updates"
1446             return ret
1447         ret["changes"]["new"] = {"plan": newstate["plans"][0]}
1448     except (ValueError, OSError) as e:
1449         ret["result"] = False
1450         ret["comment"] = "{}".format(e.args)
1451     return ret
1452 def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
1453     """
1454     Ensures usage plan identified by name is no longer present
1455     .. versionadded:: 2017.7.0
1456     name
1457         name of the state
1458     plan_name
1459         name of the plan to remove
1460     .. code-block:: yaml
1461         usage plan absent:
1462           boto_apigateway.usage_plan_absent:
1463             - plan_name: my_usage_plan
1464             - profile: my_profile
1465     """
1466     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1467     try:
1468         common_args = dict(
1469             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1470         )
1471         existing = __salt__["boto_apigateway.describe_usage_plans"](
1472             name=plan_name, **common_args
1473         )
1474         if "error" in existing:
1475             ret["result"] = False
1476             ret["comment"] = "Failed to describe existing usage plans"
1477             return ret
1478         if not existing["plans"]:
1479             ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
1480             return ret
1481         if __opts__["test"]:
1482             ret["comment"] = "Usage plan {} exists and would be deleted".format(
1483                 plan_name
1484             )
1485             ret["result"] = None
1486             return ret
1487         plan_id = existing["plans"][0]["id"]
1488         result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
1489         if "error" in result:
1490             ret["result"] = False
1491             ret["comment"] = "Failed to delete usage plan {}, {}".format(
1492                 plan_name, result
1493             )
1494             return ret
1495         ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
1496         ret["changes"]["old"] = {"plan": existing["plans"][0]}
1497         ret["changes"]["new"] = {"plan": None}
1498     except (ValueError, OSError) as e:
1499         ret["result"] = False
1500         ret["comment"] = "{}".format(e.args)
1501     return ret
1502 def usage_plan_association_present(
1503     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1504 ):
1505     """
1506     Ensures usage plan identified by name is added to provided api_stages
1507     .. versionadded:: 2017.7.0
1508     name
1509         name of the state
1510     plan_name
1511         name of the plan to use
1512     api_stages
1513         list of dictionaries, where each dictionary consists of the following keys:
1514         apiId
1515             apiId of the api to attach usage plan to
1516         stage
1517             stage name of the api to attach usage plan to
1518     .. code-block:: yaml
1519         UsagePlanAssociationPresent:
1520           boto_apigateway.usage_plan_association_present:
1521             - plan_name: my_plan
1522             - api_stages:
1523               - apiId: 9kb0404ec0
1524                 stage: my_stage
1525               - apiId: l9v7o2aj90
1526                 stage: my_stage
1527             - profile: my_profile
1528     """
1529     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1530     try:
1531         common_args = dict(
1532             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1533         )
1534         existing = __salt__["boto_apigateway.describe_usage_plans"](
1535             name=plan_name, **common_args
1536         )
1537         if "error" in existing:
1538             ret["result"] = False
1539             ret["comment"] = "Failed to describe existing usage plans"
1540             return ret
1541         if not existing["plans"]:
1542             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1543             ret["result"] = False
1544             return ret
1545         if len(existing["plans"]) != 1:
1546             ret["comment"] = (
1547                 "There are multiple usage plans with the same name - it is not"
1548                 " supported"
1549             )
1550             ret["result"] = False
1551             return ret
1552         plan = existing["plans"][0]
1553         plan_id = plan["id"]
1554         plan_stages = plan.get("apiStages", [])
1555         stages_to_add = []
1556         for api in api_stages:
1557             if api not in plan_stages:
1558                 stages_to_add.append(api)
1559         if not stages_to_add:
1560             ret["comment"] = "Usage plan is already asssociated to all api stages"
1561             return ret
1562         result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
1563             plan_id, stages_to_add, **common_args
1564         )
1565         if "error" in result:
1566             ret[
1567                 "comment"
1568             ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
1569                 plan_name, stages_to_add, result["error"]
1570             )
1571             ret["result"] = False
1572             return ret
1573         ret["comment"] = "successfully associated usage plan to apis"
1574         ret["changes"]["old"] = plan_stages
1575         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1576     except (ValueError, OSError) as e:
1577         ret["result"] = False
1578         ret["comment"] = "{}".format(e.args)
1579     return ret
1580 def usage_plan_association_absent(
1581     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1582 ):
1583     """
1584     Ensures usage plan identified by name is removed from provided api_stages
1585     If a plan is associated to stages not listed in api_stages parameter,
1586     those associations remain intact.
1587     .. versionadded:: 2017.7.0
1588     name
1589         name of the state
1590     plan_name
1591         name of the plan to use
1592     api_stages
1593         list of dictionaries, where each dictionary consists of the following keys:
1594         apiId
1595             apiId of the api to detach usage plan from
1596         stage
1597             stage name of the api to detach usage plan from
1598     .. code-block:: yaml
1599         UsagePlanAssociationAbsent:
1600           boto_apigateway.usage_plan_association_absent:
1601             - plan_name: my_plan
1602             - api_stages:
1603               - apiId: 9kb0404ec0
1604                 stage: my_stage
1605               - apiId: l9v7o2aj90
1606                 stage: my_stage
1607             - profile: my_profile
1608     """
1609     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1610     try:
1611         common_args = dict(
1612             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1613         )
1614         existing = __salt__["boto_apigateway.describe_usage_plans"](
1615             name=plan_name, **common_args
1616         )
1617         if "error" in existing:
1618             ret["result"] = False
1619             ret["comment"] = "Failed to describe existing usage plans"
1620             return ret
1621         if not existing["plans"]:
1622             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1623             ret["result"] = False
1624             return ret
1625         if len(existing["plans"]) != 1:
1626             ret["comment"] = (
1627                 "There are multiple usage plans with the same name - it is not"
1628                 " supported"
1629             )
1630             ret["result"] = False
1631             return ret
1632         plan = existing["plans"][0]
1633         plan_id = plan["id"]
1634         plan_stages = plan.get("apiStages", [])
1635         if not plan_stages:
1636             ret["comment"] = "Usage plan {} has no associated stages already".format(
1637                 plan_name
1638             )
1639             return ret
1640         stages_to_remove = []
1641         for api in api_stages:
1642             if api in plan_stages:
1643                 stages_to_remove.append(api)
1644         if not stages_to_remove:
1645             ret["comment"] = "Usage plan is already not asssociated to any api stages"
1646             return ret
1647         result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
1648             plan_id, stages_to_remove, **common_args
1649         )
1650         if "error" in result:
1651             ret[
1652                 "comment"
1653             ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
1654                 plan_name, stages_to_remove, result["error"]
1655             )
1656             ret["result"] = False
1657             return ret
1658         ret["comment"] = "successfully disassociated usage plan from apis"
1659         ret["changes"]["old"] = plan_stages
1660         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1661     except (ValueError, OSError) as e:
1662         ret["result"] = False
1663         ret["comment"] = "{}".format(e.args)
1664     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
