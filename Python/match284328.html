<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for openstack.py &amp; boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for openstack.py &amp; boto_apigateway.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>openstack.py (1.3289037%)<th>boto_apigateway.py (0.4743083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(867-873)<td><a href="#" name="0">(1155-1163)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>openstack.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import os
4 import pprint
5 import socket
6 import salt.config as config
7 import salt.utils.versions
8 from salt.exceptions import (
9     SaltCloudConfigError,
10     SaltCloudExecutionFailure,
11     SaltCloudExecutionTimeout,
12     SaltCloudSystemExit,
13 )
14 try:
15     import shade
16     import shade.openstackcloud
17     import shade.exc
18     import os_client_config
19     HAS_SHADE = (
20         salt.utils.versions._LooseVersion(shade.__version__)
21         &gt;= salt.utils.versions._LooseVersion("1.19.0"),
22         "Please install newer version of shade: &gt;= 1.19.0",
23     )
24 except ImportError:
25     HAS_SHADE = (False, "Install pypi module shade &gt;= 1.19.0")
26 log = logging.getLogger(__name__)
27 __virtualname__ = "openstack"
28 def __virtual__():
29     if get_configured_provider() is False:
30         return False
31     if get_dependencies() is False:
32         return HAS_SHADE
33     return __virtualname__
34 def _get_active_provider_name():
35     try:
36         return __active_provider_name__.value()
37     except AttributeError:
38         return __active_provider_name__
39 def get_configured_provider():
40     provider = config.is_provider_configured(
41         __opts__,
42         _get_active_provider_name() or __virtualname__,
43         ("auth", "region_name"),
44     )
45     if provider:
46         return provider
47     return config.is_provider_configured(
48         __opts__,
49         _get_active_provider_name() or __virtualname__,
50         ("cloud", "region_name"),
51     )
52 def get_dependencies():
53     if not HAS_SHADE:
54         log.warning('"shade" not found')
55         return False
56     elif hasattr(HAS_SHADE, "__len__") and not HAS_SHADE[0]:
57         log.warning(HAS_SHADE[1])
58         return False
59     deps = {"shade": HAS_SHADE[0], "os_client_config": HAS_SHADE[0]}
60     return config.check_driver_dependencies(__virtualname__, deps)
61 def preferred_ip(vm_, ips):
62     proto = config.get_cloud_config_value(
63         "protocol", vm_, __opts__, default="ipv4", search_global=False
64     )
65     family = socket.AF_INET
66     if proto == "ipv6":
67         family = socket.AF_INET6
68     for ip in ips:
69         ignore_ip = ignore_cidr(vm_, ip)
70         if ignore_ip:
71             continue
72         try:
73             socket.inet_pton(family, ip)
74             return ip
75         except Exception:  # pylint: disable=broad-except
76             continue
77     return False
78 def ignore_cidr(vm_, ip):
79     from ipaddress import ip_address, ip_network
80     cidrs = config.get_cloud_config_value(
81         "ignore_cidr", vm_, __opts__, default=[], search_global=False
82     )
83     if cidrs and isinstance(cidrs, str):
84         cidrs = [cidrs]
85     for cidr in cidrs or []:
86         if ip_address(ip) in ip_network(cidr):
87             log.warning("IP %r found within %r; ignoring it.", ip, cidr)
88             return True
89     return False
90 def ssh_interface(vm_):
91     return config.get_cloud_config_value(
92         "ssh_interface", vm_, __opts__, default="public_ips", search_global=False
93     )
94 def get_conn():
95     if _get_active_provider_name() in __context__:
96         return __context__[_get_active_provider_name()]
97     vm_ = get_configured_provider()
98     profile = vm_.pop("profile", None)
99     if profile is not None:
100         vm_ = __utils__["dictupdate.update"](
101             os_client_config.vendors.get_profile(profile), vm_
102         )
103     conn = shade.openstackcloud.OpenStackCloud(cloud_config=None, **vm_)
104     if _get_active_provider_name() is not None:
105         __context__[_get_active_provider_name()] = conn
106     return conn
107 def list_nodes(conn=None, call=None):
108     if call == "action":
109         raise SaltCloudSystemExit(
110             "The list_nodes function must be called with -f or --function."
111         )
112     ret = {}
113     for node, info in list_nodes_full(conn=conn).items():
114         for key in (
115             "id",
116             "name",
117             "size",
118             "state",
119             "private_ips",
120             "public_ips",
121             "floating_ips",
122             "fixed_ips",
123             "image",
124         ):
125             ret.setdefault(node, {}).setdefault(key, info.get(key))
126     return ret
127 def list_nodes_min(conn=None, call=None):
128     if call == "action":
129         raise SaltCloudSystemExit(
130             "The list_nodes_min function must be called with -f or --function."
131         )
132     if conn is None:
133         conn = get_conn()
134     ret = {}
135     for node in conn.list_servers(bare=True):
136         ret[node.name] = {"id": node.id, "state": node.status}
137     return ret
138 def _get_ips(node, addr_type="public"):
139     ret = []
140     for _, interface in node.addresses.items():
141         for addr in interface:
142             if addr_type in ("floating", "fixed") and addr_type == addr.get(
143                 "OS-EXT-IPS:type"
144             ):
145                 ret.append(addr["addr"])
146             elif addr_type == "public" and __utils__["cloud.is_public_ip"](
147                 addr["addr"]
148             ):
149                 ret.append(addr["addr"])
150             elif addr_type == "private" and not __utils__["cloud.is_public_ip"](
151                 addr["addr"]
152             ):
153                 ret.append(addr["addr"])
154     return ret
155 def list_nodes_full(conn=None, call=None):
156     if call == "action":
157         raise SaltCloudSystemExit(
158             "The list_nodes_full function must be called with -f or --function."
159         )
160     if conn is None:
161         conn = get_conn()
162     ret = {}
163     for node in conn.list_servers(detailed=True):
164         ret[node.name] = dict(node)
165         ret[node.name]["id"] = node.id
166         ret[node.name]["name"] = node.name
167         ret[node.name]["size"] = node.flavor.name
168         ret[node.name]["state"] = node.status
169         ret[node.name]["private_ips"] = _get_ips(node, "private")
170         ret[node.name]["public_ips"] = _get_ips(node, "public")
171         ret[node.name]["floating_ips"] = _get_ips(node, "floating")
172         ret[node.name]["fixed_ips"] = _get_ips(node, "fixed")
173         if isinstance(node.image, str):
174             ret[node.name]["image"] = node.image
175         else:
176             ret[node.name]["image"] = getattr(
177                 conn.get_image(node.image.id), "name", node.image.id
178             )
179     return ret
180 def list_nodes_select(conn=None, call=None):
181     if call == "action":
182         raise SaltCloudSystemExit(
183             "The list_nodes_select function must be called with -f or --function."
184         )
185     return __utils__["cloud.list_nodes_select"](
186         list_nodes(conn, "function"), __opts__["query.selection"], call
187     )
188 def show_instance(name, conn=None, call=None):
189     if call != "action":
190         raise SaltCloudSystemExit(
191             "The show_instance action must be called with -a or --action."
192         )
193     if conn is None:
194         conn = get_conn()
195     node = conn.get_server(name, bare=True)
196     ret = dict(node)
197     ret["id"] = node.id
198     ret["name"] = node.name
199     ret["size"] = conn.get_flavor(node.flavor.id).name
200     ret["state"] = node.status
201     ret["private_ips"] = _get_ips(node, "private")
202     ret["public_ips"] = _get_ips(node, "public")
203     ret["floating_ips"] = _get_ips(node, "floating")
204     ret["fixed_ips"] = _get_ips(node, "fixed")
205     if isinstance(node.image, str):
206         ret["image"] = node.image
207     else:
208         ret["image"] = getattr(conn.get_image(node.image.id), "name", node.image.id)
209     return ret
210 def avail_images(conn=None, call=None):
211     if call == "action":
212         raise SaltCloudSystemExit(
213             "The avail_images function must be called with "
214             "-f or --function, or with the --list-images option"
215         )
216     if conn is None:
217         conn = get_conn()
218     return conn.list_images()
219 def avail_sizes(conn=None, call=None):
220     if call == "action":
221         raise SaltCloudSystemExit(
222             "The avail_sizes function must be called with "
223             "-f or --function, or with the --list-sizes option"
224         )
225     if conn is None:
226         conn = get_conn()
227     return conn.list_flavors()
228 def list_networks(conn=None, call=None):
229     if call == "action":
230         raise SaltCloudSystemExit(
231             "The list_networks function must be called with -f or --function"
232         )
233     if conn is None:
234         conn = get_conn()
235     return conn.list_networks()
236 def list_subnets(conn=None, call=None, kwargs=None):
237     if call == "action":
238         raise SaltCloudSystemExit(
239             "The list_subnets function must be called with -f or --function."
240         )
241     if conn is None:
242         conn = get_conn()
243     if kwargs is None or (isinstance(kwargs, dict) and "network" not in kwargs):
244         raise SaltCloudSystemExit("A `network` must be specified")
245     return conn.list_subnets(filters={"network": kwargs["network"]})
246 def _clean_create_kwargs(**kwargs):
247     VALID_OPTS = {
248         "name": (str,),
249         "image": (str,),
250         "flavor": (str,),
251         "auto_ip": bool,
252         "ips": list,
253         "ip_pool": (str,),
254         "root_volume": (str,),
255         "boot_volume": (str,),
256         "terminate_volume": bool,
257         "volumes": list,
258         "meta": dict,
259         "files": dict,
260         "reservation_id": (str,),
261         "security_groups": list,
262         "key_name": (str,),
263         "availability_zone": (str,),
264         "block_device_mapping": list,
265         "block_device_mapping_v2": list,
266         "nics": list,
267         "scheduler_hints": dict,
268         "config_drive": bool,
269         "disk_config": (str,),  # AUTO or MANUAL
270         "admin_pass": (str,),
271         "wait": bool,
272         "timeout": int,
273         "reuse_ips": bool,
274         "network": (dict, list),
275         "boot_from_volume": bool,
276         "volume_size": int,
277         "nat_destination": (str,),
278         "group": (str,),
279         "userdata": (str,),
280     }
281     extra = kwargs.pop("extra", {})
282     for key, value in kwargs.copy().items():
283         if key in VALID_OPTS:
284             if isinstance(value, VALID_OPTS[key]):
285                 continue
286             log.error("Error %s: %s is not of type %s", key, value, VALID_OPTS[key])
287         kwargs.pop(key)
288     return __utils__["dictupdate.update"](kwargs, extra)
289 def request_instance(vm_, conn=None, call=None):
290     if call == "function":
291         raise SaltCloudSystemExit(
292             "The request_instance action must be called with -a or --action."
293         )
294     kwargs = copy.deepcopy(vm_)
295     log.info("Creating Cloud VM %s", vm_["name"])
296     __utils__["cloud.check_name"](vm_["name"], "a-zA-Z0-9._-")
297     if conn is None:
298         conn = get_conn()
299     userdata = config.get_cloud_config_value(
300         "userdata", vm_, __opts__, search_global=False, default=None
301     )
302     if userdata is not None and os.path.isfile(userdata):
303         try:
304             with __utils__["files.fopen"](userdata, "r") as fp_:
305                 kwargs["userdata"] = __utils__["cloud.userdata_template"](
306                     __opts__, vm_, fp_.read()
307                 )
308         except Exception as exc:  # pylint: disable=broad-except
309             log.exception("Failed to read userdata from %s: %s", userdata, exc)
310     if "size" in kwargs:
311         kwargs["flavor"] = kwargs.pop("size")
312     kwargs["key_name"] = config.get_cloud_config_value(
313         "ssh_key_name", vm_, __opts__, search_global=False, default=None
314     )
315     kwargs["wait"] = True
316     try:
317         conn.create_server(**_clean_create_kwargs(**kwargs))
318     except shade.exc.OpenStackCloudException as exc:
319         log.error("Error creating server %s: %s", vm_["name"], exc)
320         destroy(vm_["name"], conn=conn, call="action")
321         raise SaltCloudSystemExit(str(exc))
322     return show_instance(vm_["name"], conn=conn, call="action")
323 def create(vm_):
324     deploy = config.get_cloud_config_value("deploy", vm_, __opts__)
325     key_filename = config.get_cloud_config_value(
326         "ssh_key_file", vm_, __opts__, search_global=False, default=None
327     )
328     if key_filename is not None and not os.path.isfile(key_filename):
329         raise SaltCloudConfigError(
330             "The defined ssh_key_file '{}' does not exist".format(key_filename)
331         )
332     vm_["key_filename"] = key_filename
333     __utils__["cloud.fire_event"](
334         "event",
335         "starting create",
336         "salt/cloud/{}/creating".format(vm_["name"]),
337         args=__utils__["cloud.filter_event"](
338             "creating", vm_, ["name", "profile", "provider", "driver"]
339         ),
340         sock_dir=__opts__["sock_dir"],
341         transport=__opts__["transport"],
342     )
343     conn = get_conn()
344     if "instance_id" in vm_:
345         if "pub_key" not in vm_ and "priv_key" not in vm_:
346             log.debug("Generating minion keys for '%s'", vm_["name"])
347             vm_["priv_key"], vm_["pub_key"] = __utils__["cloud.gen_keys"](
348                 config.get_cloud_config_value("keysize", vm_, __opts__)
349             )
350     else:
351         request_instance(conn=conn, call="action", vm_=vm_)
352     data = show_instance(vm_.get("instance_id", vm_["name"]), conn=conn, call="action")
353     log.debug("VM is now running")
354     def __query_node(vm_):
355         data = show_instance(vm_["name"], conn=conn, call="action")
356         if "wait_for_metadata" in vm_:
357             for key, value in vm_.get("wait_for_metadata", {}).items():
358                 log.debug("Waiting for metadata: %s=%s", key, value)
359                 if data["metadata"].get(key, None) != value:
360                     log.debug(
361                         "Metadata is not ready: %s=%s", key, data["metadata"].get(key)
362                     )
363                     return False
364         return preferred_ip(vm_, data[ssh_interface(vm_)])
365     try:
366         ip_address = __utils__["cloud.wait_for_fun"](__query_node, vm_=vm_)
367     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
368         try:
369             destroy(vm_["name"])
370         except SaltCloudSystemExit:
371             pass
372         finally:
373             raise SaltCloudSystemExit(str(exc))
374     log.debug("Using IP address %s", ip_address)
375     salt_interface = __utils__["cloud.get_salt_interface"](vm_, __opts__)
376     salt_ip_address = preferred_ip(vm_, data[salt_interface])
377     log.debug("Salt interface set to: %s", salt_ip_address)
378     if not ip_address:
379         raise SaltCloudSystemExit("A valid IP address was not found")
380     vm_["ssh_host"] = ip_address
381     vm_["salt_host"] = salt_ip_address
382     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
383     ret.update(data)
384     log.info("Created Cloud VM '%s'", vm_["name"])
385     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
386     event_data = {
387         "name": vm_["name"],
388         "profile": vm_["profile"],
389         "provider": vm_["driver"],
390         "instance_id": data["id"],
391         "floating_ips": data["floating_ips"],
392         "fixed_ips": data["fixed_ips"],
393         "private_ips": data["private_ips"],
394         "public_ips": data["public_ips"],
395     }
396     __utils__["cloud.fire_event"](
397         "event",
398         "created instance",
399         "salt/cloud/{}/created".format(vm_["name"]),
400         args=__utils__["cloud.filter_event"]("created", event_data, list(event_data)),
401         sock_dir=__opts__["sock_dir"],
402         transport=__opts__["transport"],
403     )
404     __utils__["cloud.cachedir_index_add"](
405         vm_["name"], vm_["profile"], "nova", vm_["driver"]
406     )
407     return ret
408 def destroy(name, conn=None, call=None):
409     if call == "function":
410         raise SaltCloudSystemExit(
411             "The destroy action must be called with -d, --destroy, -a or --action."
412         )
413     __utils__["cloud.fire_event"](
414         "event",
415         "destroying instance",
416         "salt/cloud/{}/destroying".format(name),
417         args={"name": name},
418         sock_dir=__opts__["sock_dir"],
419         transport=__opts__["transport"],
420     )
421     if not conn:
422         conn = get_conn()
423     node = show_instance(name, conn=conn, call="action")
424     log.info("Destroying VM: %s", name)
425     ret = conn.delete_server(name)
426     if ret:
427         log.info("Destroyed VM: %s", name)
428 <a name="0"></a>        __utils__["cloud.fire_event"](
429             "event",
430             "destroyed instance",
431             "salt/cloud/{}/destroyed"<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(name),
432             args={"name": name},
433             sock_dir=__opts__["sock_dir"],
434             transport=__opts__["transport"],
435         )
436         if __opts__.get("delete_sshkeys", False) is True:
437             __utils__[</b></font>"cloud.remove_sshkey"](
438                 getattr(node, __opts__.get("ssh_interface", "public_ips"))[0]
439             )
440         if __opts__.get("update_cachedir", False) is True:
441             __utils__["cloud.delete_minion_cachedir"](
442                 name, _get_active_provider_name().split(":")[0], __opts__
443             )
444         __utils__["cloud.cachedir_index_del"](name)
445         return True
446     log.error("Failed to Destroy VM: %s", name)
447     return False
448 def call(conn=None, call=None, kwargs=None):
449     if call == "action":
450         raise SaltCloudSystemExit(
451             "The call function must be called with -f or --function."
452         )
453     if "func" not in kwargs:
454         raise SaltCloudSystemExit("No `func` argument passed")
455     if conn is None:
456         conn = get_conn()
457     func = kwargs.pop("func")
458     for key, value in kwargs.items():
459         try:
460             kwargs[key] = __utils__["json.loads"](value)
461         except ValueError:
462             continue
463     try:
464         return getattr(conn, func)(**kwargs)
465     except shade.exc.OpenStackCloudException as exc:
466         log.error("Error running %s: %s", func, exc)
467         raise SaltCloudSystemExit(str(exc))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import hashlib
2 import logging
3 import os
4 import re
5 import salt.utils.files
6 import salt.utils.json
7 import salt.utils.yaml
8 log = logging.getLogger(__name__)
9 def __virtual__():
10     if "boto_apigateway.describe_apis" in __salt__:
11         return "boto_apigateway"
12     return (False, "boto_apigateway module could not be loaded")
13 def present(
14     name,
15     api_name,
16     swagger_file,
17     stage_name,
18     api_key_required,
19     lambda_integration_role,
20     lambda_region=None,
21     stage_variables=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     lambda_funcname_format="{stage}_{api}_{resource}_{method}",
27     authorization_type="NONE",
28     error_response_template=None,
29     response_template=None,
30 ):
31     ret = {"name": name, "result": True, "comment": "", "changes": {}}
32     try:
33         common_args = dict(
34             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
35         )
36         swagger = _Swagger(
37             api_name,
38             stage_name,
39             lambda_funcname_format,
40             swagger_file,
41             error_response_template,
42             response_template,
43             common_args,
44         )
45         stage_vars = _get_stage_variables(stage_variables)
46         ret = swagger.verify_api(ret)
47         if ret.get("publish"):
48             if __opts__["test"]:
49                 ret["comment"] = (
50                     "[stage: {}] will be reassociated to an already available "
51                     "deployment that matched the given [api_name: {}] "
52                     "and [swagger_file: {}].\n"
53                     "Stage variables will be set "
54                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
55                 )
56                 ret["result"] = None
57                 return ret
58             return swagger.publish_api(ret, stage_vars)
59         if ret.get("current"):
60             if __opts__["test"]:
61                 ret["comment"] = (
62                     "[stage: {}] is already at desired state with an associated "
63                     "deployment matching the given [api_name: {}] "
64                     "and [swagger_file: {}].\n"
65                     "Stage variables will be set "
66                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
67                 )
68                 ret["result"] = None
69             return swagger.overwrite_stage_variables(ret, stage_vars)
70         if __opts__["test"]:
71             ret["comment"] = (
72                 "There is no deployment matching the given [api_name: {}] "
73                 "and [swagger_file: {}].  A new deployment will be "
74                 "created and the [stage_name: {}] will then be associated "
75                 "to the newly created deployment.\n"
76                 "Stage variables will be set "
77                 "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
78             )
79             ret["result"] = None
80             return ret
81         ret = swagger.deploy_api(ret)
82         if ret.get("abort"):
83             return ret
84         ret = swagger.deploy_models(ret)
85         if ret.get("abort"):
86             return ret
87         ret = swagger.deploy_resources(
88             ret,
89             api_key_required=api_key_required,
90             lambda_integration_role=lambda_integration_role,
91             lambda_region=lambda_region,
92             authorization_type=authorization_type,
93         )
94         if ret.get("abort"):
95             return ret
96         ret = swagger.publish_api(ret, stage_vars)
97     except (ValueError, OSError) as e:
98         ret["result"] = False
99         ret["comment"] = "{}".format(e.args)
100     return ret
101 def _get_stage_variables(stage_variables):
102     ret = dict()
103     if stage_variables is None:
104         return ret
105     if isinstance(stage_variables, str):
106         if stage_variables in __opts__:
107             ret = __opts__[stage_variables]
108         master_opts = __pillar__.get("master", {})
109         if stage_variables in master_opts:
110             ret = master_opts[stage_variables]
111         if stage_variables in __pillar__:
112             ret = __pillar__[stage_variables]
113     elif isinstance(stage_variables, dict):
114         ret = stage_variables
115     if not isinstance(ret, dict):
116         ret = dict()
117     return ret
118 def absent(
119     name,
120     api_name,
121     stage_name,
122     nuke_api=False,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127 ):
128     ret = {"name": name, "result": True, "comment": "", "changes": {}}
129     try:
130         common_args = dict(
131             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
132         )
133         swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
134         if not swagger.restApiId:
135             ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
136             return ret
137         if __opts__["test"]:
138             if nuke_api:
139                 ret["comment"] = (
140                     "[stage: {}] will be deleted, if there are no other "
141                     "active stages, the [api: {} will also be "
142                     "deleted.".format(stage_name, api_name)
143                 )
144             else:
145                 ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
146             ret["result"] = None
147             return ret
148         ret = swagger.delete_stage(ret)
149         if ret.get("abort"):
150             return ret
151         if nuke_api and swagger.no_more_deployments_remain():
152             ret = swagger.delete_api(ret)
153     except (ValueError, OSError) as e:
154         ret["result"] = False
155         ret["comment"] = "{}".format(e.args)
156     return ret
157 def _gen_md5_filehash(fname, *args):
158     _hash = hashlib.md5()
159     with salt.utils.files.fopen(fname, "rb") as f:
160         for chunk in iter(lambda: f.read(4096), b""):
161             _hash.update(chunk)
162     for extra_arg in args:
163         _hash.update(str(extra_arg).encode())
164     return _hash.hexdigest()
165 def _dict_to_json_pretty(d, sort_keys=True):
166     return salt.utils.json.dumps(
167         d, indent=4, separators=(",", ": "), sort_keys=sort_keys
168     )
169 def _name_matches(name, matches):
170     for m in matches:
171         if name.endswith(m):
172             return True
173         if name.lower().endswith("_" + m.lower()):
174             return True
175         if name.lower() == m.lower():
176             return True
177     return False
178 def _object_reducer(
179     o,
180     names=(
181         "id",
182         "name",
183         "path",
184         "httpMethod",
185         "statusCode",
186         "Created",
187         "Deleted",
188         "Updated",
189         "Flushed",
190         "Associated",
191         "Disassociated",
192     ),
193 ):
194     result = {}
195     if isinstance(o, dict):
196         for k, v in o.items():
197             if isinstance(v, dict):
198                 reduced = v if k == "variables" else _object_reducer(v, names)
199                 if reduced or _name_matches(k, names):
200                     result[k] = reduced
201             elif isinstance(v, list):
202                 newlist = []
203                 for val in v:
204                     reduced = _object_reducer(val, names)
205                     if reduced or _name_matches(k, names):
206                         newlist.append(reduced)
207                 if newlist:
208                     result[k] = newlist
209             else:
210                 if _name_matches(k, names):
211                     result[k] = v
212     return result
213 def _log_changes(ret, changekey, changevalue):
214     cl = ret["changes"].get("new", [])
215     cl.append({changekey: _object_reducer(changevalue)})
216     ret["changes"]["new"] = cl
217     return ret
218 def _log_error_and_abort(ret, obj):
219     ret["result"] = False
220     ret["abort"] = True
221     if "error" in obj:
222         ret["comment"] = "{}".format(obj.get("error"))
223     return ret
224 class _Swagger:
225     SWAGGER_OBJ_V2_FIELDS = (
226         "swagger",
227         "info",
228         "host",
229         "basePath",
230         "schemes",
231         "consumes",
232         "produces",
233         "paths",
234         "definitions",
235         "parameters",
236         "responses",
237         "securityDefinitions",
238         "security",
239         "tags",
240         "externalDocs",
241     )
242     SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
243         "swagger",
244         "info",
245         "basePath",
246         "schemes",
247         "paths",
248         "definitions",
249     )
250     SWAGGER_OPERATION_NAMES = (
251         "get",
252         "put",
253         "post",
254         "delete",
255         "options",
256         "head",
257         "patch",
258     )
259     SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
260     VENDOR_EXT_PATTERN = re.compile("^x-")
261     JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
262     REQUEST_TEMPLATE = {
263         "application/json": (
264             "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
265             " = $input.params().header)\n#foreach( $param in $map.entrySet()"
266             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
267             ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
268             " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
269             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
270             ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
271             " $input.params().path)\n#foreach( $param in $map.entrySet()"
272             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
273             ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
274             ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
275             ' "$context.requestId",\n"resourceId":'
276             ' "$context.resourceId",\n"resourcePath":'
277             ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
278             ' "user":"$context.identity.user",\n '
279             ' "userArn":"$context.identity.userArn",\n '
280             ' "userAgent":"$context.identity.userAgent",\n '
281             ' "sourceIp":"$context.identity.sourceIp",\n '
282             ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
283             ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
284             ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
285             '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
286             '  "caller":"$context.identity.caller",\n '
287             ' "apiKey":"$context.identity.apiKey",\n '
288             ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
289             " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
290             ' $stageVariables.keySet())\n"$variable":'
291             ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
292             " #end\n#end\n}\n}"
293         )
294     }
295     REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
296     RESPONSE_TEMPLATE = {
297         "application/json": (
298             "#set($inputRoot = $input.path('$'))\n"
299             "{\n"
300             '  "errorMessage" : "$inputRoot.errorMessage",\n'
301             '  "errorType" : "$inputRoot.errorType",\n'
302             '  "stackTrace" : [\n'
303             "#foreach($stackTrace in $inputRoot.stackTrace)\n"
304             "    [\n"
305             "#foreach($elem in $stackTrace)\n"
306             '      "$elem"\n'
307             "#if($foreach.hasNext),#end\n"
308             "#end\n"
309             "    ]\n"
310             "#if($foreach.hasNext),#end\n"
311             "#end\n"
312             "  ]\n"
313             "}"
314         )
315     }
316     RESPONSE_OPTION_TEMPLATE = {}
317     AWS_API_DESCRIPTION = _dict_to_json_pretty(
318         {
319             "provisioned_by": "Salt boto_apigateway.present State",
320             "context": "See deployment or stage description",
321         }
322     )
323     class SwaggerParameter:
324         LOCATIONS = ("body", "query", "header", "path")
325         def __init__(self, paramdict):
326             self._paramdict = paramdict
327         @property
328         def location(self):
329             _location = self._paramdict.get("in")
330             if _location in _Swagger.SwaggerParameter.LOCATIONS:
331                 return _location
332             raise ValueError(
333                 "Unsupported parameter location: {} in Parameter Object".format(
334                     _location
335                 )
336             )
337         @property
338         def name(self):
339             _name = self._paramdict.get("name")
340             if _name:
341                 if self.location == "header":
342                     return "method.request.header.{}".format(_name)
343                 elif self.location == "query":
344                     return "method.request.querystring.{}".format(_name)
345                 elif self.location == "path":
346                     return "method.request.path.{}".format(_name)
347                 return None
348             raise ValueError(
349                 "Parameter must have a name: {}".format(
350                     _dict_to_json_pretty(self._paramdict)
351                 )
352             )
353         @property
354         def schema(self):
355             if self.location == "body":
356                 _schema = self._paramdict.get("schema")
357                 if _schema:
358                     if "$ref" in _schema:
359                         schema_name = _schema.get("$ref").split("/")[-1]
360                         return schema_name
361                     raise ValueError(
362                         "Body parameter must have a JSON reference "
363                         "to the schema definition due to Amazon API restrictions: {}".format(
364                             self.name
365                         )
366                     )
367                 raise ValueError(
368                     "Body parameter must have a schema: {}".format(self.name)
369                 )
370             return None
371     class SwaggerMethodResponse:
372         def __init__(self, r):
373             self._r = r
374         @property
375         def schema(self):
376             _schema = self._r.get("schema")
377             if _schema:
378                 if "$ref" in _schema:
379                     return _schema.get("$ref").split("/")[-1]
380                 raise ValueError(
381                     "Method response must have a JSON reference "
382                     "to the schema definition: {}".format(_schema)
383                 )
384             return None
385         @property
386         def headers(self):
387             _headers = self._r.get("headers", {})
388             return _headers
389     def __init__(
390         self,
391         api_name,
392         stage_name,
393         lambda_funcname_format,
394         swagger_file_path,
395         error_response_template,
396         response_template,
397         common_aws_args,
398     ):
399         self._api_name = api_name
400         self._stage_name = stage_name
401         self._lambda_funcname_format = lambda_funcname_format
402         self._common_aws_args = common_aws_args
403         self._restApiId = ""
404         self._deploymentId = ""
405         self._error_response_template = error_response_template
406         self._response_template = response_template
407         if swagger_file_path is not None:
408             if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
409                 self._swagger_file = swagger_file_path
410                 self._md5_filehash = _gen_md5_filehash(
411                     self._swagger_file, error_response_template, response_template
412                 )
413                 with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
414                     self._cfg = salt.utils.yaml.safe_load(sf)
415                 self._swagger_version = ""
416             else:
417                 raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
418             self._validate_swagger_file()
419         self._validate_lambda_funcname_format()
420         self._resolve_api_id()
421     def _is_http_error_rescode(self, code):
422         return bool(re.match(r"^\s*[45]\d\d\s*$", code))
423     def _validate_error_response_model(self, paths, mods):
424         for path, ops in paths:
425             for opname, opobj in ops.items():
426                 if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
427                     continue
428                 if "responses" not in opobj:
429                     raise ValueError(
430                         "missing mandatory responses field in path item object"
431                     )
432                 for rescode, resobj in opobj.get("responses").items():
433                     if not self._is_http_error_rescode(str(rescode)):
434                         continue
435                     if "schema" not in resobj:
436                         raise ValueError(
437                             "missing schema field in path {}, "
438                             "op {}, response {}".format(path, opname, rescode)
439                         )
440                     schemaobj = resobj.get("schema")
441                     if "$ref" not in schemaobj:
442                         raise ValueError(
443                             "missing $ref field under schema in "
444                             "path {}, op {}, response {}".format(path, opname, rescode)
445                         )
446                     schemaobjref = schemaobj.get("$ref", "/")
447                     modelname = schemaobjref.split("/")[-1]
448                     if modelname not in mods:
449                         raise ValueError(
450                             "model schema {} reference not found "
451                             "under /definitions".format(schemaobjref)
452                         )
453                     model = mods.get(modelname)
454                     if model.get("type") != "object":
455                         raise ValueError(
456                             "model schema {} must be type object".format(modelname)
457                         )
458                     if "properties" not in model:
459                         raise ValueError(
460                             "model schema {} must have properties fields".format(
461                                 modelname
462                             )
463                         )
464                     modelprops = model.get("properties")
465                     if "errorMessage" not in modelprops:
466                         raise ValueError(
467                             "model schema {} must have errorMessage as a property to "
468                             "match AWS convention. If pattern is not set, .+ will "
469                             "be used".format(modelname)
470                         )
471     def _validate_lambda_funcname_format(self):
472         try:
473             if self._lambda_funcname_format:
474                 known_kwargs = dict(stage="", api="", resource="", method="")
475                 self._lambda_funcname_format.format(**known_kwargs)
476             return True
477         except Exception:  # pylint: disable=broad-except
478             raise ValueError(
479                 "Invalid lambda_funcname_format {}.  Please review "
480                 "documentation for known substitutable keys".format(
481                     self._lambda_funcname_format
482                 )
483             )
484     def _validate_swagger_file(self):
485         for field in self._cfg:
486             if (
487                 field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
488                 and not _Swagger.VENDOR_EXT_PATTERN.match(field)
489             ):
490                 raise ValueError("Invalid Swagger Object Field: {}".format(field))
491         for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
492             if field not in self._cfg:
493                 raise ValueError("Missing Swagger Object Field: {}".format(field))
494         self._swagger_version = self._cfg.get("swagger")
495         if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
496             raise ValueError(
497                 "Unsupported Swagger version: {},Supported versions are {}".format(
498                     self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
499                 )
500             )
501         log.info(type(self._models))
502         self._validate_error_response_model(self.paths, self._models())
503     @property
504     def md5_filehash(self):
505         return self._md5_filehash
506     @property
507     def info(self):
508         info = self._cfg.get("info")
509         if not info:
510             raise ValueError("Info Object has no values")
511         return info
512     @property
513     def info_json(self):
514         return _dict_to_json_pretty(self.info)
515     @property
516     def rest_api_name(self):
517         return self._api_name
518     @property
519     def rest_api_version(self):
520         version = self.info.get("version")
521         if not version:
522             raise ValueError("Missing version value in Info Object")
523         return version
524     def _models(self):
525         models = self._cfg.get("definitions")
526         if not models:
527             raise ValueError(
528                 "Definitions Object has no values, You need to define them in your"
529                 " swagger file"
530             )
531         return models
532     def models(self):
533         model_dict = self._build_all_dependencies()
534         while True:
535             model = self._get_model_without_dependencies(model_dict)
536             if not model:
537                 break
538             yield (model, self._models().get(model))
539     @property
540     def paths(self):
541         paths = self._cfg.get("paths")
542         if not paths:
543             raise ValueError(
544                 "Paths Object has no values, You need to define them in your swagger"
545                 " file"
546             )
547         for path in paths:
548             if not path.startswith("/"):
549                 raise ValueError(
550                     "Path object {} should start with /. Please fix it".format(path)
551                 )
552         return paths.items()
553     @property
554     def basePath(self):
555         basePath = self._cfg.get("basePath", "")
556         return basePath
557     @property
558     def restApiId(self):
559         return self._restApiId
560     @restApiId.setter
561     def restApiId(self, restApiId):
562         self._restApiId = restApiId
563     @property
564     def deployment_label_json(self):
565         return _dict_to_json_pretty(self.deployment_label)
566     @property
567     def deployment_label(self):
568         label = dict()
569         label["swagger_info_object"] = self.info
570         label["api_name"] = self.rest_api_name
571         label["swagger_file"] = os.path.basename(self._swagger_file)
572         label["swagger_file_md5sum"] = self.md5_filehash
573         return label
574     def _one_or_more_stages_remain(self, deploymentId):
575         stages = __salt__["boto_apigateway.describe_api_stages"](
576             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
577         ).get("stages")
578         return bool(stages)
579     def no_more_deployments_remain(self):
580         no_more_deployments = True
581         deployments = __salt__["boto_apigateway.describe_api_deployments"](
582             restApiId=self.restApiId, **self._common_aws_args
583         ).get("deployments")
584         if deployments:
585             for deployment in deployments:
586                 deploymentId = deployment.get("id")
587                 stages = __salt__["boto_apigateway.describe_api_stages"](
588                     restApiId=self.restApiId,
589                     deploymentId=deploymentId,
590                     **self._common_aws_args
591                 ).get("stages")
592                 if stages:
593                     no_more_deployments = False
594                     break
595         return no_more_deployments
596     def _get_current_deployment_id(self):
597         deploymentId = ""
598         stage = __salt__["boto_apigateway.describe_api_stage"](
599             restApiId=self.restApiId,
600             stageName=self._stage_name,
601             **self._common_aws_args
602         ).get("stage")
603         if stage:
604             deploymentId = stage.get("deploymentId")
605         return deploymentId
606     def _get_current_deployment_label(self):
607         deploymentId = self._get_current_deployment_id()
608         deployment = __salt__["boto_apigateway.describe_api_deployment"](
609             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
610         ).get("deployment")
611         if deployment:
612             return deployment.get("description")
613         return None
614     def _get_desired_deployment_id(self):
615         deployments = __salt__["boto_apigateway.describe_api_deployments"](
616             restApiId=self.restApiId, **self._common_aws_args
617         ).get("deployments")
618         if deployments:
619             for deployment in deployments:
620                 if deployment.get("description") == self.deployment_label_json:
621                     return deployment.get("id")
622         return ""
623     def overwrite_stage_variables(self, ret, stage_variables):
624 <a name="0"></a>        """
625         overwrite the given stage_name's stage variables with the given stage_variables
626         res = __salt__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto_apigateway.overwrite_api_stage_variables"](
627             restApiId=self.restApiId,
628             stageName=self._stage_name,
629             variables=stage_variables,
630             **self._common_aws_args
631         )
632         if not res.get("overwrite"):
633             ret[</b></font>"result"] = False
634             ret["abort"] = True
635             ret["comment"] = res.get("error")
636         else:
637             ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
638         return ret
639     def _set_current_deployment(self, stage_desc_json, stage_variables):
640         stage = __salt__["boto_apigateway.describe_api_stage"](
641             restApiId=self.restApiId,
642             stageName=self._stage_name,
643             **self._common_aws_args
644         ).get("stage")
645         if not stage:
646             stage = __salt__["boto_apigateway.create_api_stage"](
647                 restApiId=self.restApiId,
648                 stageName=self._stage_name,
649                 deploymentId=self._deploymentId,
650                 description=stage_desc_json,
651                 variables=stage_variables,
652                 **self._common_aws_args
653             )
654             if not stage.get("stage"):
655                 return {"set": False, "error": stage.get("error")}
656         else:
657             overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
658                 restApiId=self.restApiId,
659                 stageName=self._stage_name,
660                 variables=stage_variables,
661                 **self._common_aws_args
662             )
663             if not overwrite.get("stage"):
664                 return {"set": False, "error": overwrite.get("error")}
665         return __salt__["boto_apigateway.activate_api_deployment"](
666             restApiId=self.restApiId,
667             stageName=self._stage_name,
668             deploymentId=self._deploymentId,
669             **self._common_aws_args
670         )
671     def _resolve_api_id(self):
672         apis = __salt__["boto_apigateway.describe_apis"](
673             name=self.rest_api_name,
674             description=_Swagger.AWS_API_DESCRIPTION,
675             **self._common_aws_args
676         ).get("restapi")
677         if apis:
678             if len(apis) == 1:
679                 self.restApiId = apis[0].get("id")
680             else:
681                 raise ValueError(
682                     "Multiple APIs matching given name {} and description {}".format(
683                         self.rest_api_name, self.info_json
684                     )
685                 )
686     def delete_stage(self, ret):
687         deploymentId = self._get_current_deployment_id()
688         if deploymentId:
689             result = __salt__["boto_apigateway.delete_api_stage"](
690                 restApiId=self.restApiId,
691                 stageName=self._stage_name,
692                 **self._common_aws_args
693             )
694             if not result.get("deleted"):
695                 ret["abort"] = True
696                 ret["result"] = False
697                 ret["comment"] = "delete_stage delete_api_stage, {}".format(
698                     result.get("error")
699                 )
700             else:
701                 if not self._one_or_more_stages_remain(deploymentId):
702                     result = __salt__["boto_apigateway.delete_api_deployment"](
703                         restApiId=self.restApiId,
704                         deploymentId=deploymentId,
705                         **self._common_aws_args
706                     )
707                     if not result.get("deleted"):
708                         ret["abort"] = True
709                         ret["result"] = False
710                         ret[
711                             "comment"
712                         ] = "delete_stage delete_api_deployment, {}".format(
713                             result.get("error")
714                         )
715                 else:
716                     ret["comment"] = "stage {} has been deleted.\n".format(
717                         self._stage_name
718                     )
719         else:
720             ret["comment"] = "stage {} does not exist".format(self._stage_name)
721         return ret
722     def verify_api(self, ret):
723         if self.restApiId:
724             deployed_label_json = self._get_current_deployment_label()
725             if deployed_label_json == self.deployment_label_json:
726                 ret["comment"] = (
727                     "Already at desired state, the stage {} is already at the desired "
728                     "deployment label:\n{}".format(
729                         self._stage_name, deployed_label_json
730                     )
731                 )
732                 ret["current"] = True
733                 return ret
734             else:
735                 self._deploymentId = self._get_desired_deployment_id()
736                 if self._deploymentId:
737                     ret["publish"] = True
738         return ret
739     def publish_api(self, ret, stage_variables):
740         stage_desc = dict()
741         stage_desc["current_deployment_label"] = self.deployment_label
742         stage_desc_json = _dict_to_json_pretty(stage_desc)
743         if self._deploymentId:
744             res = self._set_current_deployment(stage_desc_json, stage_variables)
745             if not res.get("set"):
746                 ret["abort"] = True
747                 ret["result"] = False
748                 ret["comment"] = res.get("error")
749             else:
750                 ret = _log_changes(
751                     ret,
752                     "publish_api (reassociate deployment, set stage_variables)",
753                     res.get("response"),
754                 )
755         else:
756             res = __salt__["boto_apigateway.create_api_deployment"](
757                 restApiId=self.restApiId,
758                 stageName=self._stage_name,
759                 stageDescription=stage_desc_json,
760                 description=self.deployment_label_json,
761                 variables=stage_variables,
762                 **self._common_aws_args
763             )
764             if not res.get("created"):
765                 ret["abort"] = True
766                 ret["result"] = False
767                 ret["comment"] = res.get("error")
768             else:
769                 ret = _log_changes(
770                     ret, "publish_api (new deployment)", res.get("deployment")
771                 )
772         return ret
773     def _cleanup_api(self):
774         resources = __salt__["boto_apigateway.describe_api_resources"](
775             restApiId=self.restApiId, **self._common_aws_args
776         )
777         if resources.get("resources"):
778             res = resources.get("resources")[1:]
779             res.reverse()
780             for resource in res:
781                 delres = __salt__["boto_apigateway.delete_api_resources"](
782                     restApiId=self.restApiId,
783                     path=resource.get("path"),
784                     **self._common_aws_args
785                 )
786                 if not delres.get("deleted"):
787                     return delres
788         models = __salt__["boto_apigateway.describe_api_models"](
789             restApiId=self.restApiId, **self._common_aws_args
790         )
791         if models.get("models"):
792             for model in models.get("models"):
793                 delres = __salt__["boto_apigateway.delete_api_model"](
794                     restApiId=self.restApiId,
795                     modelName=model.get("name"),
796                     **self._common_aws_args
797                 )
798                 if not delres.get("deleted"):
799                     return delres
800         return {"deleted": True}
801     def deploy_api(self, ret):
802         if self.restApiId:
803             res = self._cleanup_api()
804             if not res.get("deleted"):
805                 ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
806                 ret["abort"] = True
807                 ret["result"] = False
808                 return ret
809             return ret
810         response = __salt__["boto_apigateway.create_api"](
811             name=self.rest_api_name,
812             description=_Swagger.AWS_API_DESCRIPTION,
813             **self._common_aws_args
814         )
815         if not response.get("created"):
816             ret["result"] = False
817             ret["abort"] = True
818             if "error" in response:
819                 ret["comment"] = "Failed to create rest api: {}.".format(
820                     response["error"]["message"]
821                 )
822             return ret
823         self.restApiId = response.get("restapi", {}).get("id")
824         return _log_changes(ret, "deploy_api", response.get("restapi"))
825     def delete_api(self, ret):
826         exists_response = __salt__["boto_apigateway.api_exists"](
827             name=self.rest_api_name,
828             description=_Swagger.AWS_API_DESCRIPTION,
829             **self._common_aws_args
830         )
831         if exists_response.get("exists"):
832             if __opts__["test"]:
833                 ret["comment"] = "Rest API named {} is set to be deleted.".format(
834                     self.rest_api_name
835                 )
836                 ret["result"] = None
837                 ret["abort"] = True
838                 return ret
839             delete_api_response = __salt__["boto_apigateway.delete_api"](
840                 name=self.rest_api_name,
841                 description=_Swagger.AWS_API_DESCRIPTION,
842                 **self._common_aws_args
843             )
844             if not delete_api_response.get("deleted"):
845                 ret["result"] = False
846                 ret["abort"] = True
847                 if "error" in delete_api_response:
848                     ret["comment"] = "Failed to delete rest api: {}.".format(
849                         delete_api_response["error"]["message"]
850                     )
851                 return ret
852             ret = _log_changes(ret, "delete_api", delete_api_response)
853         else:
854             ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
855                 self.rest_api_name, self.info_json
856             )
857         return ret
858     def _aws_model_ref_from_swagger_ref(self, r):
859         model_name = r.split("/")[-1]
860         return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
861             self.restApiId, model_name
862         )
863     def _update_schema_to_aws_notation(self, schema):
864         result = {}
865         for k, v in schema.items():
866             if k == "$ref":
867                 v = self._aws_model_ref_from_swagger_ref(v)
868             if isinstance(v, dict):
869                 v = self._update_schema_to_aws_notation(v)
870             result[k] = v
871         return result
872     def _build_dependent_model_list(self, obj_schema):
873         dep_models_list = []
874         if obj_schema:
875             obj_schema["type"] = obj_schema.get("type", "object")
876         if obj_schema["type"] == "array":
877             dep_models_list.extend(
878                 self._build_dependent_model_list(obj_schema.get("items", {}))
879             )
880         else:
881             ref = obj_schema.get("$ref")
882             if ref:
883                 ref_obj_model = ref.split("/")[-1]
884                 ref_obj_schema = self._models().get(ref_obj_model)
885                 dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
886                 dep_models_list.extend([ref_obj_model])
887             else:
888                 properties = obj_schema.get("properties")
889                 if properties:
890                     for _, prop_obj_schema in properties.items():
891                         dep_models_list.extend(
892                             self._build_dependent_model_list(prop_obj_schema)
893                         )
894         return list(set(dep_models_list))
895     def _build_all_dependencies(self):
896         ret = {}
897         for model, schema in self._models().items():
898             dep_list = self._build_dependent_model_list(schema)
899             ret[model] = dep_list
900         return ret
901     def _get_model_without_dependencies(self, models_dict):
902         next_model = None
903         if not models_dict:
904             return next_model
905         for model, dependencies in models_dict.items():
906             if dependencies == []:
907                 next_model = model
908                 break
909         if next_model is None:
910             raise ValueError(
911                 "incomplete model definitions, models in dependency "
912                 "list not defined: {}".format(models_dict)
913             )
914         models_dict.pop(next_model)
915         for model, dep_list in models_dict.items():
916             if next_model in dep_list:
917                 dep_list.remove(next_model)
918         return next_model
919     def deploy_models(self, ret):
920         for model, schema in self.models():
921             _schema = self._update_schema_to_aws_notation(schema)
922             _schema.update(
923                 {
924                     "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
925                     "title": "{} Schema".format(model),
926                 }
927             )
928             model_exists_response = __salt__["boto_apigateway.api_model_exists"](
929                 restApiId=self.restApiId, modelName=model, **self._common_aws_args
930             )
931             if model_exists_response.get("exists"):
932                 update_model_schema_response = __salt__[
933                     "boto_apigateway.update_api_model_schema"
934                 ](
935                     restApiId=self.restApiId,
936                     modelName=model,
937                     schema=_dict_to_json_pretty(_schema),
938                     **self._common_aws_args
939                 )
940                 if not update_model_schema_response.get("updated"):
941                     ret["result"] = False
942                     ret["abort"] = True
943                     if "error" in update_model_schema_response:
944                         ret[
945                             "comment"
946                         ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
947                             model,
948                             _dict_to_json_pretty(schema),
949                             update_model_schema_response["error"]["message"],
950                         )
951                     return ret
952                 ret = _log_changes(ret, "deploy_models", update_model_schema_response)
953             else:
954                 create_model_response = __salt__["boto_apigateway.create_api_model"](
955                     restApiId=self.restApiId,
956                     modelName=model,
957                     modelDescription=model,
958                     schema=_dict_to_json_pretty(_schema),
959                     contentType="application/json",
960                     **self._common_aws_args
961                 )
962                 if not create_model_response.get("created"):
963                     ret["result"] = False
964                     ret["abort"] = True
965                     if "error" in create_model_response:
966                         ret[
967                             "comment"
968                         ] = "Failed to create model {}, schema {}, error: {}".format(
969                             model,
970                             _dict_to_json_pretty(schema),
971                             create_model_response["error"]["message"],
972                         )
973                     return ret
974                 ret = _log_changes(ret, "deploy_models", create_model_response)
975         return ret
976     def _lambda_name(self, resourcePath, httpMethod):
977         lambda_name = self._lambda_funcname_format.format(
978             stage=self._stage_name,
979             api=self.rest_api_name,
980             resource=resourcePath,
981             method=httpMethod,
982         )
983         lambda_name = lambda_name.strip()
984         lambda_name = re.sub(r"{|}", "", lambda_name)
985         lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
986         return re.sub(r"_+", "_", lambda_name)
987     def _lambda_uri(self, lambda_name, lambda_region):
988         profile = self._common_aws_args.get("profile")
989         region = self._common_aws_args.get("region")
990         lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
991         apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
992         lambda_desc = __salt__["boto_lambda.describe_function"](
993             lambda_name, **self._common_aws_args
994         )
995         if lambda_region != apigw_region:
996             if not lambda_desc.get("function"):
997                 lambda_desc = __salt__["boto_lambda.describe_function"](
998                     lambda_name, **self._common_aws_args
999                 )
1000         if not lambda_desc.get("function"):
1001             raise ValueError(
1002                 "Could not find lambda function {} in regions [{}, {}].".format(
1003                     lambda_name, lambda_region, apigw_region
1004                 )
1005             )
1006         lambda_arn = lambda_desc.get("function").get("FunctionArn")
1007         lambda_uri = (
1008             "arn:aws:apigateway:{}:lambda:path/2015-03-31"
1009             "/functions/{}/invocations".format(apigw_region, lambda_arn)
1010         )
1011         return lambda_uri
1012     def _parse_method_data(self, method_name, method_data):
1013         method_params = {}
1014         method_models = {}
1015         if "parameters" in method_data:
1016             for param in method_data["parameters"]:
1017                 p = _Swagger.SwaggerParameter(param)
1018                 if p.name:
1019                     method_params[p.name] = True
1020                 if p.schema:
1021                     method_models["application/json"] = p.schema
1022         request_templates = (
1023             _Swagger.REQUEST_OPTION_TEMPLATE
1024             if method_name == "options"
1025             else _Swagger.REQUEST_TEMPLATE
1026         )
1027         integration_type = "MOCK" if method_name == "options" else "AWS"
1028         return {
1029             "params": method_params,
1030             "models": method_models,
1031             "request_templates": request_templates,
1032             "integration_type": integration_type,
1033         }
1034     def _find_patterns(self, o):
1035         result = []
1036         if isinstance(o, dict):
1037             for k, v in o.items():
1038                 if isinstance(v, dict):
1039                     result.extend(self._find_patterns(v))
1040                 else:
1041                     if k == "pattern":
1042                         result.append(v)
1043         return result
1044     def _get_pattern_for_schema(self, schema_name, httpStatus):
1045         defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
1046         model = self._models().get(schema_name)
1047         patterns = self._find_patterns(model)
1048         return patterns[0] if patterns else defaultPattern
1049     def _get_response_template(self, method_name, http_status):
1050         if method_name == "options" or not self._is_http_error_rescode(http_status):
1051             response_templates = (
1052                 {"application/json": self._response_template}
1053                 if self._response_template
1054                 else self.RESPONSE_OPTION_TEMPLATE
1055             )
1056         else:
1057             response_templates = (
1058                 {"application/json": self._error_response_template}
1059                 if self._error_response_template
1060                 else self.RESPONSE_TEMPLATE
1061             )
1062         return response_templates
1063     def _parse_method_response(self, method_name, method_response, httpStatus):
1064         method_response_models = {}
1065         method_response_pattern = ".*"
1066         if method_response.schema:
1067             method_response_models["application/json"] = method_response.schema
1068             method_response_pattern = self._get_pattern_for_schema(
1069                 method_response.schema, httpStatus
1070             )
1071         method_response_params = {}
1072         method_integration_response_params = {}
1073         for header in method_response.headers:
1074             response_header = "method.response.header.{}".format(header)
1075             method_response_params[response_header] = False
1076             header_data = method_response.headers.get(header)
1077             method_integration_response_params[response_header] = (
1078                 "'{}'".format(header_data.get("default"))
1079                 if "default" in header_data
1080                 else "'*'"
1081             )
1082         response_templates = self._get_response_template(method_name, httpStatus)
1083         return {
1084             "params": method_response_params,
1085             "models": method_response_models,
1086             "integration_params": method_integration_response_params,
1087             "pattern": method_response_pattern,
1088             "response_templates": response_templates,
1089         }
1090     def _deploy_method(
1091         self,
1092         ret,
1093         resource_path,
1094         method_name,
1095         method_data,
1096         api_key_required,
1097         lambda_integration_role,
1098         lambda_region,
1099         authorization_type,
1100     ):
1101         method = self._parse_method_data(method_name.lower(), method_data)
1102         if method_name.lower() == "options":
1103             api_key_required = False
1104             authorization_type = "NONE"
1105         m = __salt__["boto_apigateway.create_api_method"](
1106             restApiId=self.restApiId,
1107             resourcePath=resource_path,
1108             httpMethod=method_name.upper(),
1109             authorizationType=authorization_type,
1110             apiKeyRequired=api_key_required,
1111             requestParameters=method.get("params"),
1112             requestModels=method.get("models"),
1113             **self._common_aws_args
1114         )
1115         if not m.get("created"):
1116             ret = _log_error_and_abort(ret, m)
1117             return ret
1118         ret = _log_changes(ret, "_deploy_method.create_api_method", m)
1119         lambda_uri = ""
1120         if method_name.lower() != "options":
1121             lambda_uri = self._lambda_uri(
1122                 self._lambda_name(resource_path, method_name),
1123                 lambda_region=lambda_region,
1124             )
1125         integration = __salt__["boto_apigateway.create_api_integration"](
1126             restApiId=self.restApiId,
1127             resourcePath=resource_path,
1128             httpMethod=method_name.upper(),
1129             integrationType=method.get("integration_type"),
1130             integrationHttpMethod="POST",
1131             uri=lambda_uri,
1132             credentials=lambda_integration_role,
1133             requestTemplates=method.get("request_templates"),
1134             **self._common_aws_args
1135         )
1136         if not integration.get("created"):
1137             ret = _log_error_and_abort(ret, integration)
1138             return ret
1139         ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
1140         if "responses" in method_data:
1141             for response, response_data in method_data["responses"].items():
1142                 httpStatus = str(response)
1143                 method_response = self._parse_method_response(
1144                     method_name.lower(),
1145                     _Swagger.SwaggerMethodResponse(response_data),
1146                     httpStatus,
1147                 )
1148                 mr = __salt__["boto_apigateway.create_api_method_response"](
1149                     restApiId=self.restApiId,
1150                     resourcePath=resource_path,
1151                     httpMethod=method_name.upper(),
1152                     statusCode=httpStatus,
1153                     responseParameters=method_response.get("params"),
1154                     responseModels=method_response.get("models"),
1155                     **self._common_aws_args
1156                 )
1157                 if not mr.get("created"):
1158                     ret = _log_error_and_abort(ret, mr)
1159                     return ret
1160                 ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
1161                 mir = __salt__["boto_apigateway.create_api_integration_response"](
1162                     restApiId=self.restApiId,
1163                     resourcePath=resource_path,
1164                     httpMethod=method_name.upper(),
1165                     statusCode=httpStatus,
1166                     selectionPattern=method_response.get("pattern"),
1167                     responseParameters=method_response.get("integration_params"),
1168                     responseTemplates=method_response.get("response_templates"),
1169                     **self._common_aws_args
1170                 )
1171                 if not mir.get("created"):
1172                     ret = _log_error_and_abort(ret, mir)
1173                     return ret
1174                 ret = _log_changes(
1175                     ret, "_deploy_method.create_api_integration_response", mir
1176                 )
1177         else:
1178             raise ValueError(
1179                 "No responses specified for {} {}".format(resource_path, method_name)
1180             )
1181         return ret
1182     def deploy_resources(
1183         self,
1184         ret,
1185         api_key_required,
1186         lambda_integration_role,
1187         lambda_region,
1188         authorization_type,
1189     ):
1190         for path, pathData in self.paths:
1191             resource = __salt__["boto_apigateway.create_api_resources"](
1192                 restApiId=self.restApiId, path=path, **self._common_aws_args
1193             )
1194             if not resource.get("created"):
1195                 ret = _log_error_and_abort(ret, resource)
1196                 return ret
1197             ret = _log_changes(ret, "deploy_resources", resource)
1198             for method, method_data in pathData.items():
1199                 if method in _Swagger.SWAGGER_OPERATION_NAMES:
1200                     ret = self._deploy_method(
1201                         ret,
1202                         path,
1203                         method,
1204                         method_data,
1205                         api_key_required,
1206                         lambda_integration_role,
1207                         lambda_region,
1208                         authorization_type,
1209                     )
1210         return ret
1211 def usage_plan_present(
1212     name,
1213     plan_name,
1214     description=None,
1215     throttle=None,
1216     quota=None,
1217     region=None,
1218     key=None,
1219     keyid=None,
1220     profile=None,
1221 ):
1222     func_params = locals()
1223     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1224     try:
1225         common_args = dict(
1226             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1227         )
1228         existing = __salt__["boto_apigateway.describe_usage_plans"](
1229             name=plan_name, **common_args
1230         )
1231         if "error" in existing:
1232             ret["result"] = False
1233             ret["comment"] = "Failed to describe existing usage plans"
1234             return ret
1235         if not existing["plans"]:
1236             if __opts__["test"]:
1237                 ret["comment"] = "a new usage plan {} would be created".format(
1238                     plan_name
1239                 )
1240                 ret["result"] = None
1241                 return ret
1242             result = __salt__["boto_apigateway.create_usage_plan"](
1243                 name=plan_name,
1244                 description=description,
1245                 throttle=throttle,
1246                 quota=quota,
1247                 **common_args
1248             )
1249             if "error" in result:
1250                 ret["result"] = False
1251                 ret["comment"] = "Failed to create a usage plan {}, {}".format(
1252                     plan_name, result["error"]
1253                 )
1254                 return ret
1255             ret["changes"]["old"] = {"plan": None}
1256             ret["comment"] = "A new usage plan {} has been created".format(plan_name)
1257         else:
1258             plan = existing["plans"][0]
1259             needs_updating = False
1260             modifiable_params = (
1261                 ("throttle", ("rateLimit", "burstLimit")),
1262                 ("quota", ("limit", "offset", "period")),
1263             )
1264             for p, fields in modifiable_params:
1265                 for f in fields:
1266                     actual_param = (
1267                         {} if func_params.get(p) is None else func_params.get(p)
1268                     )
1269                     if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
1270                         needs_updating = True
1271                         break
1272             if not needs_updating:
1273                 ret["comment"] = "usage plan {} is already in a correct state".format(
1274                     plan_name
1275                 )
1276                 ret["result"] = True
1277                 return ret
1278             if __opts__["test"]:
1279                 ret["comment"] = "a new usage plan {} would be updated".format(
1280                     plan_name
1281                 )
1282                 ret["result"] = None
1283                 return ret
1284             result = __salt__["boto_apigateway.update_usage_plan"](
1285                 plan["id"], throttle=throttle, quota=quota, **common_args
1286             )
1287             if "error" in result:
1288                 ret["result"] = False
1289                 ret["comment"] = "Failed to update a usage plan {}, {}".format(
1290                     plan_name, result["error"]
1291                 )
1292                 return ret
1293             ret["changes"]["old"] = {"plan": plan}
1294             ret["comment"] = "usage plan {} has been updated".format(plan_name)
1295         newstate = __salt__["boto_apigateway.describe_usage_plans"](
1296             name=plan_name, **common_args
1297         )
1298         if "error" in existing:
1299             ret["result"] = False
1300             ret["comment"] = "Failed to describe existing usage plans after updates"
1301             return ret
1302         ret["changes"]["new"] = {"plan": newstate["plans"][0]}
1303     except (ValueError, OSError) as e:
1304         ret["result"] = False
1305         ret["comment"] = "{}".format(e.args)
1306     return ret
1307 def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
1308     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1309     try:
1310         common_args = dict(
1311             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1312         )
1313         existing = __salt__["boto_apigateway.describe_usage_plans"](
1314             name=plan_name, **common_args
1315         )
1316         if "error" in existing:
1317             ret["result"] = False
1318             ret["comment"] = "Failed to describe existing usage plans"
1319             return ret
1320         if not existing["plans"]:
1321             ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
1322             return ret
1323         if __opts__["test"]:
1324             ret["comment"] = "Usage plan {} exists and would be deleted".format(
1325                 plan_name
1326             )
1327             ret["result"] = None
1328             return ret
1329         plan_id = existing["plans"][0]["id"]
1330         result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
1331         if "error" in result:
1332             ret["result"] = False
1333             ret["comment"] = "Failed to delete usage plan {}, {}".format(
1334                 plan_name, result
1335             )
1336             return ret
1337         ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
1338         ret["changes"]["old"] = {"plan": existing["plans"][0]}
1339         ret["changes"]["new"] = {"plan": None}
1340     except (ValueError, OSError) as e:
1341         ret["result"] = False
1342         ret["comment"] = "{}".format(e.args)
1343     return ret
1344 def usage_plan_association_present(
1345     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1346 ):
1347     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1348     try:
1349         common_args = dict(
1350             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1351         )
1352         existing = __salt__["boto_apigateway.describe_usage_plans"](
1353             name=plan_name, **common_args
1354         )
1355         if "error" in existing:
1356             ret["result"] = False
1357             ret["comment"] = "Failed to describe existing usage plans"
1358             return ret
1359         if not existing["plans"]:
1360             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1361             ret["result"] = False
1362             return ret
1363         if len(existing["plans"]) != 1:
1364             ret["comment"] = (
1365                 "There are multiple usage plans with the same name - it is not"
1366                 " supported"
1367             )
1368             ret["result"] = False
1369             return ret
1370         plan = existing["plans"][0]
1371         plan_id = plan["id"]
1372         plan_stages = plan.get("apiStages", [])
1373         stages_to_add = []
1374         for api in api_stages:
1375             if api not in plan_stages:
1376                 stages_to_add.append(api)
1377         if not stages_to_add:
1378             ret["comment"] = "Usage plan is already asssociated to all api stages"
1379             return ret
1380         result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
1381             plan_id, stages_to_add, **common_args
1382         )
1383         if "error" in result:
1384             ret[
1385                 "comment"
1386             ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
1387                 plan_name, stages_to_add, result["error"]
1388             )
1389             ret["result"] = False
1390             return ret
1391         ret["comment"] = "successfully associated usage plan to apis"
1392         ret["changes"]["old"] = plan_stages
1393         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1394     except (ValueError, OSError) as e:
1395         ret["result"] = False
1396         ret["comment"] = "{}".format(e.args)
1397     return ret
1398 def usage_plan_association_absent(
1399     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1400 ):
1401     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1402     try:
1403         common_args = dict(
1404             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1405         )
1406         existing = __salt__["boto_apigateway.describe_usage_plans"](
1407             name=plan_name, **common_args
1408         )
1409         if "error" in existing:
1410             ret["result"] = False
1411             ret["comment"] = "Failed to describe existing usage plans"
1412             return ret
1413         if not existing["plans"]:
1414             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1415             ret["result"] = False
1416             return ret
1417         if len(existing["plans"]) != 1:
1418             ret["comment"] = (
1419                 "There are multiple usage plans with the same name - it is not"
1420                 " supported"
1421             )
1422             ret["result"] = False
1423             return ret
1424         plan = existing["plans"][0]
1425         plan_id = plan["id"]
1426         plan_stages = plan.get("apiStages", [])
1427         if not plan_stages:
1428             ret["comment"] = "Usage plan {} has no associated stages already".format(
1429                 plan_name
1430             )
1431             return ret
1432         stages_to_remove = []
1433         for api in api_stages:
1434             if api in plan_stages:
1435                 stages_to_remove.append(api)
1436         if not stages_to_remove:
1437             ret["comment"] = "Usage plan is already not asssociated to any api stages"
1438             return ret
1439         result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
1440             plan_id, stages_to_remove, **common_args
1441         )
1442         if "error" in result:
1443             ret[
1444                 "comment"
1445             ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
1446                 plan_name, stages_to_remove, result["error"]
1447             )
1448             ret["result"] = False
1449             return ret
1450         ret["comment"] = "successfully disassociated usage plan from apis"
1451         ret["changes"]["old"] = plan_stages
1452         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1453     except (ValueError, OSError) as e:
1454         ret["result"] = False
1455         ret["comment"] = "{}".format(e.args)
1456     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
