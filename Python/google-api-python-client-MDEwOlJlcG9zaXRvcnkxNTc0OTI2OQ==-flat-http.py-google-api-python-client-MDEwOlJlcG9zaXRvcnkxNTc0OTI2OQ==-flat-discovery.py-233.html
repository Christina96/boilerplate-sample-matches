
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 27, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-http.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  __author__ = &quot;jcgregorio@google.com (Joe Gregorio)&quot;
3  import copy
4  import http.client as http_client
5  import io
6  import json
7  import logging
8  import mimetypes
9  import os
10  import random
11  import socket
12  import time
13  import urllib
14  import uuid
15  import httplib2
16  try:
17      import ssl
18  except ImportError:
19      _ssl_SSLError = object()
20  else:
21      _ssl_SSLError = ssl.SSLError
22  from email.generator import Generator
23  from email.mime.multipart import MIMEMultipart
24  from email.mime.nonmultipart import MIMENonMultipart
25  from email.parser import FeedParser
26  from googleapiclient import _auth
27  from googleapiclient import _helpers as util
28  from googleapiclient.errors import (
29      BatchError,
30      HttpError,
31      InvalidChunkSizeError,
32      ResumableUploadError,
33      UnexpectedBodyError,
34      UnexpectedMethodError,
35  )
36  from googleapiclient.model import JsonModel
37  LOGGER = logging.getLogger(__name__)
38  DEFAULT_CHUNK_SIZE = 100 * 1024 * 1024
39  MAX_URI_LENGTH = 2048
40  MAX_BATCH_LIMIT = 1000
41  _TOO_MANY_REQUESTS = 429
42  DEFAULT_HTTP_TIMEOUT_SEC = 60
43  _LEGACY_BATCH_URI = &quot;https://www.googleapis.com/batch&quot;
44  def _should_retry_response(resp_status, content):
45      reason = None
46      if resp_status &gt;= 500:
47          return True
48      if resp_status == _TOO_MANY_REQUESTS:
49          return True
50      if resp_status == http_client.FORBIDDEN:
51          if not content:
52              return False
53          try:
54              data = json.loads(content.decode(&quot;utf-8&quot;))
55              if isinstance(data, dict):
56                  error_detail_keyword = next(
57                      (
58                          kw
59                          for kw in [&quot;errors&quot;, &quot;status&quot;, &quot;message&quot;]
60                          if kw in data[&quot;error&quot;]
61                      ),
62                      &quot;&quot;,
63                  )
64                  if error_detail_keyword:
65                      reason = data[&quot;error&quot;][error_detail_keyword]
66                      if isinstance(reason, list) and len(reason) &gt; 0:
67                          reason = reason[0]
68                          if &quot;reason&quot; in reason:
69                              reason = reason[&quot;reason&quot;]
70              else:
71                  reason = data[0][&quot;error&quot;][&quot;errors&quot;][&quot;reason&quot;]
72          except (UnicodeDecodeError, ValueError, KeyError):
73              LOGGER.warning(&quot;Invalid JSON content from response: %s&quot;, content)
74              return False
75          LOGGER.warning(&#x27;Encountered 403 Forbidden with reason &quot;%s&quot;&#x27;, reason)
76          if reason in (&quot;userRateLimitExceeded&quot;, &quot;rateLimitExceeded&quot;):
77              return True
78      return False
79  def _retry_request(
80      http, num_retries, req_type, sleep, rand, uri, method, *args, **kwargs
81  ):
82      resp = None
83      content = None
84      exception = None
85      for retry_num in range(num_retries + 1):
86          if retry_num &gt; 0:
87              sleep_time = rand() * 2**retry_num
88              LOGGER.warning(
89                  &quot;Sleeping %.2f seconds before retry %d of %d for %s: %s %s, after %s&quot;,
90                  sleep_time,
91                  retry_num,
92                  num_retries,
93                  req_type,
94                  method,
95                  uri,
96                  resp.status if resp else exception,
97              )
98              sleep(sleep_time)
99          try:
100              exception = None
101              resp, content = http.request(uri, method, *args, **kwargs)
102          except _ssl_SSLError as ssl_error:
103              exception = ssl_error
104          except socket.timeout as socket_timeout:
105              exception = socket_timeout
106          except ConnectionError as connection_error:
107              exception = connection_error
108          except OSError as socket_error:
109              if socket.errno.errorcode.get(socket_error.errno) not in {
110                  &quot;WSAETIMEDOUT&quot;,
111                  &quot;ETIMEDOUT&quot;,
112                  &quot;EPIPE&quot;,
113                  &quot;ECONNABORTED&quot;,
114                  &quot;ECONNREFUSED&quot;,
115                  &quot;ECONNRESET&quot;,
116              }:
117                  raise
118              exception = socket_error
119          except httplib2.ServerNotFoundError as server_not_found_error:
120              exception = server_not_found_error
121          if exception:
122              if retry_num == num_retries:
123                  raise exception
124              else:
125                  continue
126          if not _should_retry_response(resp.status, content):
127              break
128      return resp, content
129  class MediaUploadProgress(object):
130      def __init__(self, resumable_progress, total_size):
131          self.resumable_progress = resumable_progress
132          self.total_size = total_size
133      def progress(self):
134          if self.total_size is not None and self.total_size != 0:
135              return float(self.resumable_progress) / float(self.total_size)
136          else:
137              return 0.0
138  class MediaDownloadProgress(object):
139      def __init__(self, resumable_progress, total_size):
140          self.resumable_progress = resumable_progress
141          self.total_size = total_size
142      def progress(self):
143          if self.total_size is not None and self.total_size != 0:
144              return float(self.resumable_progress) / float(self.total_size)
145          else:
146              return 0.0
147  class MediaUpload(object):
148      def chunksize(self):
149          raise NotImplementedError()
150      def mimetype(self):
151          return &quot;application/octet-stream&quot;
152      def size(self):
153          return None
154      def resumable(self):
155          return False
156      def getbytes(self, begin, end):
157          raise NotImplementedError()
158      def has_stream(self):
159          return False
160      def stream(self):
161          raise NotImplementedError()
162      @util.positional(1)
163      def _to_json(self, strip=None):
164          t = type(self)
165          d = copy.copy(self.__dict__)
166          if strip is not None:
167              for member in strip:
168                  del d[member]
169          d[&quot;_class&quot;] = t.__name__
170          d[&quot;_module&quot;] = t.__module__
171          return json.dumps(d)
172      def to_json(self):
173          return self._to_json()
174      @classmethod
175      def new_from_json(cls, s):
176          data = json.loads(s)
177          module = data[&quot;_module&quot;]
178          m = __import__(module, fromlist=module.split(&quot;.&quot;)[:-1])
179          kls = getattr(m, data[&quot;_class&quot;])
180          from_json = getattr(kls, &quot;from_json&quot;)
181          return from_json(s)
182  class MediaIoBaseUpload(MediaUpload):
183      @util.positional(3)
184      def __init__(self, fd, mimetype, chunksize=DEFAULT_CHUNK_SIZE, resumable=False):
185          super(MediaIoBaseUpload, self).__init__()
186          self._fd = fd
187          self._mimetype = mimetype
188          if not (chunksize == -1 or chunksize &gt; 0):
189              raise InvalidChunkSizeError()
190          self._chunksize = chunksize
191          self._resumable = resumable
192          self._fd.seek(0, os.SEEK_END)
193          self._size = self._fd.tell()
194      def chunksize(self):
195          return self._chunksize
196      def mimetype(self):
197          return self._mimetype
198      def size(self):
199          return self._size
200      def resumable(self):
201          return self._resumable
202      def getbytes(self, begin, length):
203          self._fd.seek(begin)
204          return self._fd.read(length)
205      def has_stream(self):
206          return True
207      def stream(self):
208          return self._fd
209      def to_json(self):
210          raise NotImplementedError(&quot;MediaIoBaseUpload is not serializable.&quot;)
211  class MediaFileUpload(MediaIoBaseUpload):
212      @util.positional(2)
213      def __init__(
214          self, filename, mimetype=None, chunksize=DEFAULT_CHUNK_SIZE, resumable=False
215      ):
216          self._fd = None
217          self._filename = filename
218          self._fd = open(self._filename, &quot;rb&quot;)
219          if mimetype is None:
220              mimetype, _ = mimetypes.guess_type(filename)
221              if mimetype is None:
222                  mimetype = &quot;application/octet-stream&quot;
223          super(MediaFileUpload, self).__init__(
224              self._fd, mimetype, chunksize=chunksize, resumable=resumable
225          )
226      def __del__(self):
227          if self._fd:
228              self._fd.close()
229      def to_json(self):
230          return self._to_json(strip=[&quot;_fd&quot;])
231      @staticmethod
232      def from_json(s):
233          d = json.loads(s)
234          return MediaFileUpload(
235              d[&quot;_filename&quot;],
236              mimetype=d[&quot;_mimetype&quot;],
237              chunksize=d[&quot;_chunksize&quot;],
238              resumable=d[&quot;_resumable&quot;],
239          )
240  class MediaInMemoryUpload(MediaIoBaseUpload):
241      @util.positional(2)
242      def __init__(
243          self,
244          body,
245          mimetype=&quot;application/octet-stream&quot;,
246          chunksize=DEFAULT_CHUNK_SIZE,
247          resumable=False,
248      ):
249          fd = io.BytesIO(body)
250          super(MediaInMemoryUpload, self).__init__(
251              fd, mimetype, chunksize=chunksize, resumable=resumable
252          )
253  class MediaIoBaseDownload(object):
254      @util.positional(3)
255      def __init__(self, fd, request, chunksize=DEFAULT_CHUNK_SIZE):
256          self._fd = fd
257          self._request = request
258          self._uri = request.uri
259          self._chunksize = chunksize
260          self._progress = 0
261          self._total_size = None
262          self._done = False
263          self._sleep = time.sleep
264          self._rand = random.random
265          self._headers = {}
266          for k, v in request.headers.items():
267              if not k.lower() in (&quot;accept&quot;, &quot;accept-encoding&quot;, &quot;user-agent&quot;):
268                  self._headers[k] = v
269      @util.positional(1)
270      def next_chunk(self, num_retries=0):
271          headers = self._headers.copy()
272          headers[&quot;range&quot;] = &quot;bytes=%d-%d&quot; % (
273              self._progress,
274              self._progress + self._chunksize - 1,
275          )
276          http = self._request.http
277          resp, content = _retry_request(
278              http,
279              num_retries,
280              &quot;media download&quot;,
281              self._sleep,
282              self._rand,
283              self._uri,
284              &quot;GET&quot;,
285              headers=headers,
286          )
287          if resp.status in [200, 206]:
288              if &quot;content-location&quot; in resp and resp[&quot;content-location&quot;] != self._uri:
289                  self._uri = resp[&quot;content-location&quot;]
290              self._progress += len(content)
291              self._fd.write(content)
292              if &quot;content-range&quot; in resp:
293                  content_range = resp[&quot;content-range&quot;]
294                  length = content_range.rsplit(&quot;/&quot;, 1)[1]
295                  self._total_size = int(length)
296              elif &quot;content-length&quot; in resp:
297                  self._total_size = int(resp[&quot;content-length&quot;])
298              if self._total_size is None or self._progress == self._total_size:
299                  self._done = True
300              return MediaDownloadProgress(self._progress, self._total_size), self._done
301          elif resp.status == 416:
302              content_range = resp[&quot;content-range&quot;]
303              length = content_range.rsplit(&quot;/&quot;, 1)[1]
304              self._total_size = int(length)
305              if self._total_size == 0:
306                  self._done = True
307                  return (
308                      MediaDownloadProgress(self._progress, self._total_size),
309                      self._done,
310                  )
311          raise HttpError(resp, content, uri=self._uri)
312  class _StreamSlice(object):
313      def __init__(self, stream, begin, chunksize):
314          self._stream = stream
315          self._begin = begin
316          self._chunksize = chunksize
317          self._stream.seek(begin)
318      def read(self, n=-1):
319          cur = self._stream.tell()
320          end = self._begin + self._chunksize
321          if n == -1 or cur + n &gt; end:
322              n = end - cur
323          return self._stream.read(n)
324  class HttpRequest(object):
325      @util.positional(4)
326      def __init__(
327          self,
328          http,
329          postproc,
330          uri,
331          method=&quot;GET&quot;,
332          body=None,
333          headers=None,
334          methodId=None,
335          resumable=None,
336      ):
337          self.uri = uri
338          self.method = method
339          self.body = body
340          self.headers = headers or {}
341          self.methodId = methodId
342          self.http = http
343          self.postproc = postproc
344          self.resumable = resumable
345          self.response_callbacks = []
346          self._in_error_state = False
347          self.body_size = len(self.body or &quot;&quot;)
348          self.resumable_uri = None
349          self.resumable_progress = 0
350          self._rand = random.random
351          self._sleep = time.sleep
352      @util.positional(1)
353      def execute(self, http=None, num_retries=0):
354          if http is None:
355              http = self.http
356          if self.resumable:
357              body = None
358              while body is None:
359                  _, body = self.next_chunk(http=http, num_retries=num_retries)
360              return body
361          if &quot;content-length&quot; not in self.headers:
362              self.headers[&quot;content-length&quot;] = str(self.body_size)
363          if len(self.uri) &gt; MAX_URI_LENGTH and self.method == &quot;GET&quot;:
364              self.method = &quot;POST&quot;
365              self.headers[&quot;x-http-method-override&quot;] = &quot;GET&quot;
366              self.headers[&quot;content-type&quot;] = &quot;application/x-www-form-urlencoded&quot;
367              parsed = urllib.parse.urlparse(self.uri)
368              self.uri = urllib.parse.urlunparse(
369                  (parsed.scheme, parsed.netloc, parsed.path, parsed.params, None, None)
370              )
371              self.body = parsed.query
372              self.headers[&quot;content-length&quot;] = str(len(self.body))
373          resp, content = _retry_request(
374              http,
375              num_retries,
376              &quot;request&quot;,
377              self._sleep,
378              self._rand,
379              str(self.uri),
380              method=str(self.method),
381              body=self.body,
382              headers=self.headers,
383          )
384          for callback in self.response_callbacks:
385              callback(resp)
386          if resp.status &gt;= 300:
387              raise HttpError(resp, content, uri=self.uri)
388          return self.postproc(resp, content)
389      @util.positional(2)
390      def add_response_callback(self, cb):
391          self.response_callbacks.append(cb)
392      @util.positional(1)
393      def next_chunk(self, http=None, num_retries=0):
394          if http is None:
395              http = self.http
396          if self.resumable.size() is None:
397              size = &quot;*&quot;
398          else:
399              size = str(self.resumable.size())
400          if self.resumable_uri is None:
401              start_headers = copy.copy(self.headers)
402              start_headers[&quot;X-Upload-Content-Type&quot;] = self.resumable.mimetype()
403              if size != &quot;*&quot;:
404                  start_headers[&quot;X-Upload-Content-Length&quot;] = size
405              start_headers[&quot;content-length&quot;] = str(self.body_size)
406              resp, content = _retry_request(
407                  http,
408                  num_retries,
409                  &quot;resumable URI request&quot;,
410                  self._sleep,
411                  self._rand,
412                  self.uri,
413                  method=self.method,
414                  body=self.body,
415                  headers=start_headers,
416              )
417              if resp.status == 200 and &quot;location&quot; in resp:
418                  self.resumable_uri = resp[&quot;location&quot;]
419              else:
420                  raise ResumableUploadError(resp, content)
421          elif self._in_error_state:
422              resp, content = http.request(self.resumable_uri, &quot;PUT&quot;, headers=headers)
423              status, body = self._process_response(resp, content)
424              if body:
425                  return (status, body)
426          if self.resumable.has_stream():
427              data = self.resumable.stream()
428              if self.resumable.chunksize() == -1:
429                  data.seek(self.resumable_progress)
430                  chunk_end = self.resumable.size() - self.resumable_progress - 1
431              else:
432                  data = _StreamSlice(
433                      data, self.resumable_progress, self.resumable.chunksize()
434                  )
435                  chunk_end = min(
436                      self.resumable_progress + self.resumable.chunksize() - 1,
437                      self.resumable.size() - 1,
438                  )
439          else:
440              data = self.resumable.getbytes(
441                  self.resumable_progress, self.resumable.chunksize()
442              )
443              if len(data) &lt; self.resumable.chunksize():
444                  size = str(self.resumable_progress + len(data))
445              chunk_end = self.resumable_progress + len(data) - 1
446          headers = {
447              &quot;Content-Length&quot;: str(chunk_end - self.resumable_progress + 1),
448          }
449          if chunk_end != -1:
450              headers[&quot;Content-Range&quot;] = &quot;bytes %d-%d/%s&quot; % (
451                  self.resumable_progress,
452                  chunk_end,
453                  size,
454              )
455          for retry_num in range(num_retries + 1):
456              if retry_num &gt; 0:
457                  self._sleep(self._rand() * 2**retry_num)
458                  LOGGER.warning(
459                      &quot;Retry #%d for media upload: %s %s, following status: %d&quot;
460                      % (retry_num, self.method, self.uri, resp.status)
461                  )
462              try:
463                  resp, content = http.request(
464                      self.resumable_uri, method=&quot;PUT&quot;, body=data, headers=headers
465                  )
466              except:
467                  self._in_error_state = True
468                  raise
469              if not _should_retry_response(resp.status, content):
470                  break
471          return self._process_response(resp, content)
472      def _process_response(self, resp, content):
473          if resp.status in [200, 201]:
474              self._in_error_state = False
475              return None, self.postproc(resp, content)
476          elif resp.status == 308:
477              self._in_error_state = False
478              try:
479                  self.resumable_progress = int(resp[&quot;range&quot;].split(&quot;-&quot;)[1]) + 1
480              except KeyError:
481                  self.resumable_progress = 0
482              if &quot;location&quot; in resp:
483                  self.resumable_uri = resp[&quot;location&quot;]
484          else:
485              self._in_error_state = True
486              raise HttpError(resp, content, uri=self.uri)
487          return (
488              MediaUploadProgress(self.resumable_progress, self.resumable.size()),
489              None,
490          )
491      def to_json(self):
492          d = copy.copy(self.__dict__)
493          if d[&quot;resumable&quot;] is not None:
494              d[&quot;resumable&quot;] = self.resumable.to_json()
495          del d[&quot;http&quot;]
496          del d[&quot;postproc&quot;]
497          del d[&quot;_sleep&quot;]
498          del d[&quot;_rand&quot;]
499          return json.dumps(d)
500      @staticmethod
501      def from_json(s, http, postproc):
502          d = json.loads(s)
503          if d[&quot;resumable&quot;] is not None:
504              d[&quot;resumable&quot;] = MediaUpload.new_from_json(d[&quot;resumable&quot;])
505          return HttpRequest(
506              http,
507              postproc,
508              uri=d[&quot;uri&quot;],
509              method=d[&quot;method&quot;],
510              body=d[&quot;body&quot;],
511              headers=d[&quot;headers&quot;],
512              methodId=d[&quot;methodId&quot;],
513              resumable=d[&quot;resumable&quot;],
514          )
515      @staticmethod
516      def null_postproc(resp, contents):
517          return resp, contents
518  class BatchHttpRequest(object):
519      @util.positional(1)
520      def __init__(self, callback=None, batch_uri=None):
521          if batch_uri is None:
522              batch_uri = _LEGACY_BATCH_URI
523          if batch_uri == _LEGACY_BATCH_URI:
524              LOGGER.warning(
525                  &quot;You have constructed a BatchHttpRequest using the legacy batch &quot;
526                  &quot;endpoint %s. This endpoint will be turned down on August 12, 2020. &quot;
527                  &quot;Please provide the API-specific endpoint or use &quot;
528                  &quot;service.new_batch_http_request(). For more details see &quot;
529                  &quot;https://developers.googleblog.com/2018/03/discontinuing-support-for-json-rpc-and.html&quot;
530                  &quot;and https://developers.google.com/api-client-library/python/guide/batch.&quot;,
531                  _LEGACY_BATCH_URI,
532              )
533          self._batch_uri = batch_uri
534          self._callback = callback
535          self._requests = {}
536          self._callbacks = {}
537          self._order = []
538          self._last_auto_id = 0
539          self._base_id = None
540          self._responses = {}
541          self._refreshed_credentials = {}
542      def _refresh_and_apply_credentials(self, request, http):
543          creds = None
544          request_credentials = False
545          if request.http is not None:
546              creds = _auth.get_credentials_from_http(request.http)
547              request_credentials = True
548          if creds is None and http is not None:
549              creds = _auth.get_credentials_from_http(http)
550          if creds is not None:
551              if id(creds) not in self._refreshed_credentials:
552                  _auth.refresh_credentials(creds)
553                  self._refreshed_credentials[id(creds)] = 1
554          if request.http is None or not request_credentials:
555              _auth.apply_credentials(creds, request.headers)
556      def _id_to_header(self, id_):
557          if self._base_id is None:
558              self._base_id = uuid.uuid4()
559          return &quot;&lt;%s + %s&gt;&quot; % (self._base_id, urllib.parse.quote(id_))
560      def _header_to_id(self, header):
561          if header[0] != &quot;&lt;&quot; or header[-1] != &quot;&gt;&quot;:
562              raise BatchError(&quot;Invalid value for Content-ID: %s&quot; % header)
563          if &quot;+&quot; not in header:
564              raise BatchError(&quot;Invalid value for Content-ID: %s&quot; % header)
565          base, id_ = header[1:-1].split(&quot; + &quot;, 1)
566          return urllib.parse.unquote(id_)
567      def _serialize_request(self, request):
568          parsed = urllib.parse.urlparse(request.uri)
569          request_line = urllib.parse.urlunparse(
570              (&quot;&quot;, &quot;&quot;, parsed.path, parsed.params, parsed.query, &quot;&quot;)
571          )
572          status_line = request.method + &quot; &quot; + request_line + &quot; HTTP/1.1\n&quot;
573          major, minor = request.headers.get(&quot;content-type&quot;, &quot;application/json&quot;).split(
574              &quot;/&quot;
575          )
576          msg = MIMENonMultipart(major, minor)
577          headers = request.headers.copy()
578          if request.http is not None:
579              credentials = _auth.get_credentials_from_http(request.http)
580              if credentials is not None:
581                  _auth.apply_credentials(credentials, headers)
582          if &quot;content-type&quot; in headers:
583              del headers[&quot;content-type&quot;]
584          for key, value in headers.items():
585              msg[key] = value
586          msg[&quot;Host&quot;] = parsed.netloc
587          msg.set_unixfrom(None)
588          if request.body is not None:
589              msg.set_payload(request.body)
590              msg[&quot;content-length&quot;] = str(len(request.body))
591          fp = io.StringIO()
592          g = Generator(fp, maxheaderlen=0)
593          g.flatten(msg, unixfrom=False)
594          body = fp.getvalue()
595          return status_line + body
596      def _deserialize_response(self, payload):
597          status_line, payload = payload.split(&quot;\n&quot;, 1)
598          protocol, status, reason = status_line.split(&quot; &quot;, 2)
599          parser = FeedParser()
600          parser.feed(payload)
601          msg = parser.close()
602          msg[&quot;status&quot;] = status
603          resp = httplib2.Response(msg)
604          resp.reason = reason
605          resp.version = int(protocol.split(&quot;/&quot;, 1)[1].replace(&quot;.&quot;, &quot;&quot;))
606          content = payload.split(&quot;\r\n\r\n&quot;, 1)[1]
607          return resp, content
608      def _new_id(self):
609          self._last_auto_id += 1
610          while str(self._last_auto_id) in self._requests:
611              self._last_auto_id += 1
612          return str(self._last_auto_id)
613      @util.positional(2)
614      def add(self, request, callback=None, request_id=None):
615          if len(self._order) &gt;= MAX_BATCH_LIMIT:
616              raise BatchError(
617                  &quot;Exceeded the maximum calls(%d) in a single batch request.&quot;
618                  % MAX_BATCH_LIMIT
619              )
620          if request_id is None:
621              request_id = self._new_id()
622          if request.resumable is not None:
623              raise BatchError(&quot;Media requests cannot be used in a batch request.&quot;)
624          if request_id in self._requests:
625              raise KeyError(&quot;A request with this ID already exists: %s&quot; % request_id)
626          self._requests[request_id] = request
627          self._callbacks[request_id] = callback
628          self._order.append(request_id)
629      def _execute(self, http, order, requests):
630          message = MIMEMultipart(&quot;mixed&quot;)
631          setattr(message, &quot;_write_headers&quot;, lambda self: None)
632          for request_id in order:
633              request = requests[request_id]
634              msg = MIMENonMultipart(&quot;application&quot;, &quot;http&quot;)
635              msg[&quot;Content-Transfer-Encoding&quot;] = &quot;binary&quot;
636              msg[&quot;Content-ID&quot;] = self._id_to_header(request_id)
637              body = self._serialize_request(request)
638              msg.set_payload(body)
639              message.attach(msg)
640          fp = io.StringIO()
<span onclick='openModal()' class='match'>641          g = Generator(fp, mangle_from_=False)
642          g.flatten(message, unixfrom=False)
643          body = fp.getvalue()
644          headers = {}
</span>645          headers[&quot;content-type&quot;] = (
646              &quot;multipart/mixed; &quot; &#x27;boundary=&quot;%s&quot;&#x27;
647          ) % message.get_boundary()
648          resp, content = http.request(
649              self._batch_uri, method=&quot;POST&quot;, body=body, headers=headers
650          )
651          if resp.status &gt;= 300:
652              raise HttpError(resp, content, uri=self._batch_uri)
653          header = &quot;content-type: %s\r\n\r\n&quot; % resp[&quot;content-type&quot;]
654          content = content.decode(&quot;utf-8&quot;)
655          for_parser = header + content
656          parser = FeedParser()
657          parser.feed(for_parser)
658          mime_response = parser.close()
659          if not mime_response.is_multipart():
660              raise BatchError(
661                  &quot;Response not in multipart/mixed format.&quot;, resp=resp, content=content
662              )
663          for part in mime_response.get_payload():
664              request_id = self._header_to_id(part[&quot;Content-ID&quot;])
665              response, content = self._deserialize_response(part.get_payload())
666              if isinstance(content, str):
667                  content = content.encode(&quot;utf-8&quot;)
668              self._responses[request_id] = (response, content)
669      @util.positional(1)
670      def execute(self, http=None):
671          if len(self._order) == 0:
672              return None
673          if http is None:
674              for request_id in self._order:
675                  request = self._requests[request_id]
676                  if request is not None:
677                      http = request.http
678                      break
679          if http is None:
680              raise ValueError(&quot;Missing a valid http object.&quot;)
681          creds = _auth.get_credentials_from_http(http)
682          if creds is not None:
683              if not _auth.is_valid(creds):
684                  LOGGER.info(&quot;Attempting refresh to obtain initial access_token&quot;)
685                  _auth.refresh_credentials(creds)
686          self._execute(http, self._order, self._requests)
687          redo_requests = {}
688          redo_order = []
689          for request_id in self._order:
690              resp, content = self._responses[request_id]
691              if resp[&quot;status&quot;] == &quot;401&quot;:
692                  redo_order.append(request_id)
693                  request = self._requests[request_id]
694                  self._refresh_and_apply_credentials(request, http)
695                  redo_requests[request_id] = request
696          if redo_requests:
697              self._execute(http, redo_order, redo_requests)
698          for request_id in self._order:
699              resp, content = self._responses[request_id]
700              request = self._requests[request_id]
701              callback = self._callbacks[request_id]
702              response = None
703              exception = None
704              try:
705                  if resp.status &gt;= 300:
706                      raise HttpError(resp, content, uri=request.uri)
707                  response = request.postproc(resp, content)
708              except HttpError as e:
709                  exception = e
710              if callback is not None:
711                  callback(request_id, response, exception)
712              if self._callback is not None:
713                  self._callback(request_id, response, exception)
714  class HttpRequestMock(object):
715      def __init__(self, resp, content, postproc):
716          self.resp = resp
717          self.content = content
718          self.postproc = postproc
719          if resp is None:
720              self.resp = httplib2.Response({&quot;status&quot;: 200, &quot;reason&quot;: &quot;OK&quot;})
721          if &quot;reason&quot; in self.resp:
722              self.resp.reason = self.resp[&quot;reason&quot;]
723      def execute(self, http=None):
724          return self.postproc(self.resp, self.content)
725  class RequestMockBuilder(object):
726      def __init__(self, responses, check_unexpected=False):
727          self.responses = responses
728          self.check_unexpected = check_unexpected
729      def __call__(
730          self,
731          http,
732          postproc,
733          uri,
734          method=&quot;GET&quot;,
735          body=None,
736          headers=None,
737          methodId=None,
738          resumable=None,
739      ):
740          if methodId in self.responses:
741              response = self.responses[methodId]
742              resp, content = response[:2]
743              if len(response) &gt; 2:
744                  expected_body = response[2]
745                  if bool(expected_body) != bool(body):
746                      raise UnexpectedBodyError(expected_body, body)
747                  if isinstance(expected_body, str):
748                      expected_body = json.loads(expected_body)
749                  body = json.loads(body)
750                  if body != expected_body:
751                      raise UnexpectedBodyError(expected_body, body)
752              return HttpRequestMock(resp, content, postproc)
753          elif self.check_unexpected:
754              raise UnexpectedMethodError(methodId=methodId)
755          else:
756              model = JsonModel(False)
757              return HttpRequestMock(None, &quot;{}&quot;, model.response)
758  class HttpMock(object):
759      def __init__(self, filename=None, headers=None):
760          if headers is None:
761              headers = {&quot;status&quot;: &quot;200&quot;}
762          if filename:
763              with open(filename, &quot;rb&quot;) as f:
764                  self.data = f.read()
765          else:
766              self.data = None
767          self.response_headers = headers
768          self.headers = None
769          self.uri = None
770          self.method = None
771          self.body = None
772          self.headers = None
773      def request(
774          self,
775          uri,
776          method=&quot;GET&quot;,
777          body=None,
778          headers=None,
779          redirections=1,
780          connection_type=None,
781      ):
782          self.uri = uri
783          self.method = method
784          self.body = body
785          self.headers = headers
786          return httplib2.Response(self.response_headers), self.data
787      def close(self):
788          return None
789  class HttpMockSequence(object):
790      def __init__(self, iterable):
791          self._iterable = iterable
792          self.follow_redirects = True
793          self.request_sequence = list()
794      def request(
795          self,
796          uri,
797          method=&quot;GET&quot;,
798          body=None,
799          headers=None,
800          redirections=1,
801          connection_type=None,
802      ):
803          self.request_sequence.append((uri, method, body, headers))
804          resp, content = self._iterable.pop(0)
805          if isinstance(content, str):
806              content = content.encode(&quot;utf-8&quot;)
807          if content == b&quot;echo_request_headers&quot;:
808              content = headers
809          elif content == b&quot;echo_request_headers_as_json&quot;:
810              content = json.dumps(headers)
811          elif content == b&quot;echo_request_body&quot;:
812              if hasattr(body, &quot;read&quot;):
813                  content = body.read()
814              else:
815                  content = body
816          elif content == b&quot;echo_request_uri&quot;:
817              content = uri
818          if isinstance(content, str):
819              content = content.encode(&quot;utf-8&quot;)
820          return httplib2.Response(resp), content
821  def set_user_agent(http, user_agent):
822      request_orig = http.request
823      def new_request(
824          uri,
825          method=&quot;GET&quot;,
826          body=None,
827          headers=None,
828          redirections=httplib2.DEFAULT_MAX_REDIRECTS,
829          connection_type=None,
830      ):
831          if headers is None:
832              headers = {}
833          if &quot;user-agent&quot; in headers:
834              headers[&quot;user-agent&quot;] = user_agent + &quot; &quot; + headers[&quot;user-agent&quot;]
835          else:
836              headers[&quot;user-agent&quot;] = user_agent
837          resp, content = request_orig(
838              uri,
839              method=method,
840              body=body,
841              headers=headers,
842              redirections=redirections,
843              connection_type=connection_type,
844          )
845          return resp, content
846      http.request = new_request
847      return http
848  def tunnel_patch(http):
849      request_orig = http.request
850      def new_request(
851          uri,
852          method=&quot;GET&quot;,
853          body=None,
854          headers=None,
855          redirections=httplib2.DEFAULT_MAX_REDIRECTS,
856          connection_type=None,
857      ):
858          if headers is None:
859              headers = {}
860          if method == &quot;PATCH&quot;:
861              if &quot;oauth_token&quot; in headers.get(&quot;authorization&quot;, &quot;&quot;):
862                  LOGGER.warning(
863                      &quot;OAuth 1.0 request made with Credentials after tunnel_patch.&quot;
864                  )
865              headers[&quot;x-http-method-override&quot;] = &quot;PATCH&quot;
866              method = &quot;POST&quot;
867          resp, content = request_orig(
868              uri,
869              method=method,
870              body=body,
871              headers=headers,
872              redirections=redirections,
873              connection_type=connection_type,
874          )
875          return resp, content
876      http.request = new_request
877      return http
878  def build_http():
879      if socket.getdefaulttimeout() is not None:
880          http_timeout = socket.getdefaulttimeout()
881      else:
882          http_timeout = DEFAULT_HTTP_TIMEOUT_SEC
883      http = httplib2.Http(timeout=http_timeout)
884      try:
885          http.redirect_codes = http.redirect_codes - {308}
886      except AttributeError:
887          pass
888      return http
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-discovery.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  __author__ = &quot;jcgregorio@google.com (Joe Gregorio)&quot;
3  __all__ = [&quot;build&quot;, &quot;build_from_document&quot;, &quot;fix_method_name&quot;, &quot;key2param&quot;]
4  from collections import OrderedDict
5  import collections.abc
6  import copy
7  from email.generator import BytesGenerator
8  from email.mime.multipart import MIMEMultipart
9  from email.mime.nonmultipart import MIMENonMultipart
10  import http.client as http_client
11  import io
12  import json
13  import keyword
14  import logging
15  import mimetypes
16  import os
17  import re
18  import urllib
19  import google.api_core.client_options
20  from google.auth.exceptions import MutualTLSChannelError
21  from google.auth.transport import mtls
22  from google.oauth2 import service_account
23  import httplib2
24  import uritemplate
25  try:
26      import google_auth_httplib2
27  except ImportError:  # pragma: NO COVER
28      google_auth_httplib2 = None
29  from googleapiclient import _auth, mimeparse
30  from googleapiclient._helpers import _add_query_parameter, positional
31  from googleapiclient.errors import (
32      HttpError,
33      InvalidJsonError,
34      MediaUploadSizeError,
35      UnacceptableMimeTypeError,
36      UnknownApiNameOrVersion,
37      UnknownFileType,
38  )
39  from googleapiclient.http import (
40      BatchHttpRequest,
41      HttpMock,
42      HttpMockSequence,
43      HttpRequest,
44      MediaFileUpload,
45      MediaUpload,
46      build_http,
47  )
48  from googleapiclient.model import JsonModel, MediaModel, RawModel
49  from googleapiclient.schema import Schemas
50  httplib2.RETRIES = 1
51  logger = logging.getLogger(__name__)
52  URITEMPLATE = re.compile(&quot;{[^}]*}&quot;)
53  VARNAME = re.compile(&quot;[a-zA-Z0-9_-]+&quot;)
54  DISCOVERY_URI = (
55      &quot;https://www.googleapis.com/discovery/v1/apis/&quot; &quot;{api}/{apiVersion}/rest&quot;
56  )
57  V1_DISCOVERY_URI = DISCOVERY_URI
58  V2_DISCOVERY_URI = (
59      &quot;https://{api}.googleapis.com/$discovery/rest?&quot; &quot;version={apiVersion}&quot;
60  )
61  DEFAULT_METHOD_DOC = &quot;A description of how to use this function&quot;
62  HTTP_PAYLOAD_METHODS = frozenset([&quot;PUT&quot;, &quot;POST&quot;, &quot;PATCH&quot;])
63  _MEDIA_SIZE_BIT_SHIFTS = {&quot;KB&quot;: 10, &quot;MB&quot;: 20, &quot;GB&quot;: 30, &quot;TB&quot;: 40}
64  BODY_PARAMETER_DEFAULT_VALUE = {&quot;description&quot;: &quot;The request body.&quot;, &quot;type&quot;: &quot;object&quot;}
65  MEDIA_BODY_PARAMETER_DEFAULT_VALUE = {
66      &quot;description&quot;: (
67          &quot;The filename of the media request body, or an instance &quot;
68          &quot;of a MediaUpload object.&quot;
69      ),
70      &quot;type&quot;: &quot;string&quot;,
71      &quot;required&quot;: False,
72  }
73  MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE = {
74      &quot;description&quot;: (
75          &quot;The MIME type of the media request body, or an instance &quot;
76          &quot;of a MediaUpload object.&quot;
77      ),
78      &quot;type&quot;: &quot;string&quot;,
79      &quot;required&quot;: False,
80  }
81  _PAGE_TOKEN_NAMES = (&quot;pageToken&quot;, &quot;nextPageToken&quot;)
82  GOOGLE_API_USE_CLIENT_CERTIFICATE = &quot;GOOGLE_API_USE_CLIENT_CERTIFICATE&quot;
83  GOOGLE_API_USE_MTLS_ENDPOINT = &quot;GOOGLE_API_USE_MTLS_ENDPOINT&quot;
84  STACK_QUERY_PARAMETERS = frozenset([&quot;trace&quot;, &quot;pp&quot;, &quot;userip&quot;, &quot;strict&quot;])
85  STACK_QUERY_PARAMETER_DEFAULT_VALUE = {&quot;type&quot;: &quot;string&quot;, &quot;location&quot;: &quot;query&quot;}
86  RESERVED_WORDS = frozenset([&quot;body&quot;])
87  class _BytesGenerator(BytesGenerator):
88      _write_lines = BytesGenerator.write
89  def fix_method_name(name):
90      name = name.replace(&quot;$&quot;, &quot;_&quot;).replace(&quot;-&quot;, &quot;_&quot;)
91      if keyword.iskeyword(name) or name in RESERVED_WORDS:
92          return name + &quot;_&quot;
93      else:
94          return name
95  def key2param(key):
96      result = []
97      key = list(key)
98      if not key[0].isalpha():
99          result.append(&quot;x&quot;)
100      for c in key:
101          if c.isalnum():
102              result.append(c)
103          else:
104              result.append(&quot;_&quot;)
105      return &quot;&quot;.join(result)
106  @positional(2)
107  def build(
108      serviceName,
109      version,
110      http=None,
111      discoveryServiceUrl=None,
112      developerKey=None,
113      model=None,
114      requestBuilder=HttpRequest,
115      credentials=None,
116      cache_discovery=True,
117      cache=None,
118      client_options=None,
119      adc_cert_path=None,
120      adc_key_path=None,
121      num_retries=1,
122      static_discovery=None,
123      always_use_jwt_access=False,
124  ):
125      params = {&quot;api&quot;: serviceName, &quot;apiVersion&quot;: version}
126      if static_discovery is None:
127          if discoveryServiceUrl is None:
128              static_discovery = True
129          else:
130              static_discovery = False
131      if http is None:
132          discovery_http = build_http()
133      else:
134          discovery_http = http
135      service = None
136      for discovery_url in _discovery_service_uri_options(discoveryServiceUrl, version):
137          requested_url = uritemplate.expand(discovery_url, params)
138          try:
139              content = _retrieve_discovery_doc(
140                  requested_url,
141                  discovery_http,
142                  cache_discovery,
143                  serviceName,
144                  version,
145                  cache,
146                  developerKey,
147                  num_retries=num_retries,
148                  static_discovery=static_discovery,
149              )
150              service = build_from_document(
151                  content,
152                  base=discovery_url,
153                  http=http,
154                  developerKey=developerKey,
155                  model=model,
156                  requestBuilder=requestBuilder,
157                  credentials=credentials,
158                  client_options=client_options,
159                  adc_cert_path=adc_cert_path,
160                  adc_key_path=adc_key_path,
161                  always_use_jwt_access=always_use_jwt_access,
162              )
163              break  # exit if a service was created
164          except HttpError as e:
165              if e.resp.status == http_client.NOT_FOUND:
166                  continue
167              else:
168                  raise e
169      if http is None:
170          discovery_http.close()
171      if service is None:
172          raise UnknownApiNameOrVersion(&quot;name: %s  version: %s&quot; % (serviceName, version))
173      else:
174          return service
175  def _discovery_service_uri_options(discoveryServiceUrl, version):
176      if discoveryServiceUrl is not None:
177          return [discoveryServiceUrl]
178      if version is None:
179          logger.warning(
180              &quot;Discovery V1 does not support empty versions. Defaulting to V2...&quot;
181          )
182          return [V2_DISCOVERY_URI]
183      else:
184          return [DISCOVERY_URI, V2_DISCOVERY_URI]
185  def _retrieve_discovery_doc(
186      url,
187      http,
188      cache_discovery,
189      serviceName,
190      version,
191      cache=None,
192      developerKey=None,
193      num_retries=1,
194      static_discovery=True,
195  ):
196      from . import discovery_cache
197      if cache_discovery:
198          if cache is None:
199              cache = discovery_cache.autodetect()
200          if cache:
201              content = cache.get(url)
202              if content:
203                  return content
204      if static_discovery:
205          content = discovery_cache.get_static_doc(serviceName, version)
206          if content:
207              return content
208          else:
209              raise UnknownApiNameOrVersion(
210                  &quot;name: %s  version: %s&quot; % (serviceName, version)
211              )
212      actual_url = url
213      if &quot;REMOTE_ADDR&quot; in os.environ:
214          actual_url = _add_query_parameter(url, &quot;userIp&quot;, os.environ[&quot;REMOTE_ADDR&quot;])
215      if developerKey:
216          actual_url = _add_query_parameter(url, &quot;key&quot;, developerKey)
217      logger.debug(&quot;URL being requested: GET %s&quot;, actual_url)
218      req = HttpRequest(http, HttpRequest.null_postproc, actual_url)
219      resp, content = req.execute(num_retries=num_retries)
220      try:
221          content = content.decode(&quot;utf-8&quot;)
222      except AttributeError:
223          pass
224      try:
225          service = json.loads(content)
226      except ValueError as e:
227          logger.error(&quot;Failed to parse as JSON: &quot; + content)
228          raise InvalidJsonError()
229      if cache_discovery and cache:
230          cache.set(url, content)
231      return content
232  @positional(1)
233  def build_from_document(
234      service,
235      base=None,
236      future=None,
237      http=None,
238      developerKey=None,
239      model=None,
240      requestBuilder=HttpRequest,
241      credentials=None,
242      client_options=None,
243      adc_cert_path=None,
244      adc_key_path=None,
245      always_use_jwt_access=False,
246  ):
247      if client_options is None:
248          client_options = google.api_core.client_options.ClientOptions()
249      if isinstance(client_options, collections.abc.Mapping):
250          client_options = google.api_core.client_options.from_dict(client_options)
251      if http is not None:
252          banned_options = [
253              (credentials, &quot;credentials&quot;),
254              (client_options.credentials_file, &quot;client_options.credentials_file&quot;),
255          ]
256          for option, name in banned_options:
257              if option is not None:
258                  raise ValueError(
259                      &quot;Arguments http and {} are mutually exclusive&quot;.format(name)
260                  )
261      if isinstance(service, str):
262          service = json.loads(service)
263      elif isinstance(service, bytes):
264          service = json.loads(service.decode(&quot;utf-8&quot;))
265      if &quot;rootUrl&quot; not in service and isinstance(http, (HttpMock, HttpMockSequence)):
266          logger.error(
267              &quot;You are using HttpMock or HttpMockSequence without&quot;
268              + &quot;having the service discovery doc in cache. Try calling &quot;
269              + &quot;build() without mocking once first to populate the &quot;
270              + &quot;cache.&quot;
271          )
272          raise InvalidJsonError()
273      base = urllib.parse.urljoin(service[&quot;rootUrl&quot;], service[&quot;servicePath&quot;])
274      audience_for_self_signed_jwt = base
275      if client_options.api_endpoint:
276          base = client_options.api_endpoint
277      schema = Schemas(service)
278      if http is None:
279          scopes = list(
280              service.get(&quot;auth&quot;, {}).get(&quot;oauth2&quot;, {}).get(&quot;scopes&quot;, {}).keys()
281          )
282          if scopes and not developerKey:
283              if client_options.credentials_file and credentials:
284                  raise google.api_core.exceptions.DuplicateCredentialArgs(
285                      &quot;client_options.credentials_file and credentials are mutually exclusive.&quot;
286                  )
287              if client_options.credentials_file:
288                  credentials = _auth.credentials_from_file(
289                      client_options.credentials_file,
290                      scopes=client_options.scopes,
291                      quota_project_id=client_options.quota_project_id,
292                  )
293              if credentials is None:
294                  credentials = _auth.default_credentials(
295                      scopes=client_options.scopes,
296                      quota_project_id=client_options.quota_project_id,
297                  )
298              if not client_options.scopes:
299                  credentials = _auth.with_scopes(credentials, scopes)
300          if (
301              credentials
302              and isinstance(credentials, service_account.Credentials)
303              and always_use_jwt_access
304              and hasattr(service_account.Credentials, &quot;with_always_use_jwt_access&quot;)
305          ):
306              credentials = credentials.with_always_use_jwt_access(always_use_jwt_access)
307              credentials._create_self_signed_jwt(audience_for_self_signed_jwt)
308          if credentials:
309              http = _auth.authorized_http(credentials)
310          else:
311              http = build_http()
312          client_cert_to_use = None
313          use_client_cert = os.getenv(GOOGLE_API_USE_CLIENT_CERTIFICATE, &quot;false&quot;)
314          if not use_client_cert in (&quot;true&quot;, &quot;false&quot;):
315              raise MutualTLSChannelError(
316                  &quot;Unsupported GOOGLE_API_USE_CLIENT_CERTIFICATE value. Accepted values: true, false&quot;
317              )
318          if client_options and client_options.client_cert_source:
319              raise MutualTLSChannelError(
320                  &quot;ClientOptions.client_cert_source is not supported, please use ClientOptions.client_encrypted_cert_source.&quot;
321              )
322          if use_client_cert == &quot;true&quot;:
323              if (
324                  client_options
325                  and hasattr(client_options, &quot;client_encrypted_cert_source&quot;)
326                  and client_options.client_encrypted_cert_source
327              ):
328                  client_cert_to_use = client_options.client_encrypted_cert_source
329              elif (
330                  adc_cert_path and adc_key_path and mtls.has_default_client_cert_source()
331              ):
332                  client_cert_to_use = mtls.default_client_encrypted_cert_source(
333                      adc_cert_path, adc_key_path
334                  )
335          if client_cert_to_use:
336              cert_path, key_path, passphrase = client_cert_to_use()
337              http_channel = (
338                  http.http
339                  if google_auth_httplib2
340                  and isinstance(http, google_auth_httplib2.AuthorizedHttp)
341                  else http
342              )
343              http_channel.add_certificate(key_path, cert_path, &quot;&quot;, passphrase)
344          if &quot;mtlsRootUrl&quot; in service and (
345              not client_options or not client_options.api_endpoint
346          ):
347              mtls_endpoint = urllib.parse.urljoin(
348                  service[&quot;mtlsRootUrl&quot;], service[&quot;servicePath&quot;]
349              )
350              use_mtls_endpoint = os.getenv(GOOGLE_API_USE_MTLS_ENDPOINT, &quot;auto&quot;)
351              if not use_mtls_endpoint in (&quot;never&quot;, &quot;auto&quot;, &quot;always&quot;):
352                  raise MutualTLSChannelError(
353                      &quot;Unsupported GOOGLE_API_USE_MTLS_ENDPOINT value. Accepted values: never, auto, always&quot;
354                  )
355              if use_mtls_endpoint == &quot;always&quot; or (
356                  use_mtls_endpoint == &quot;auto&quot; and client_cert_to_use
357              ):
358                  base = mtls_endpoint
359      if model is None:
360          features = service.get(&quot;features&quot;, [])
361          model = JsonModel(&quot;dataWrapper&quot; in features)
362      return Resource(
363          http=http,
364          baseUrl=base,
365          model=model,
366          developerKey=developerKey,
367          requestBuilder=requestBuilder,
368          resourceDesc=service,
369          rootDesc=service,
370          schema=schema,
371      )
372  def _cast(value, schema_type):
373      if schema_type == &quot;string&quot;:
374          if type(value) == type(&quot;&quot;) or type(value) == type(&quot;&quot;):
375              return value
376          else:
377              return str(value)
378      elif schema_type == &quot;integer&quot;:
379          return str(int(value))
380      elif schema_type == &quot;number&quot;:
381          return str(float(value))
382      elif schema_type == &quot;boolean&quot;:
383          return str(bool(value)).lower()
384      else:
385          if type(value) == type(&quot;&quot;) or type(value) == type(&quot;&quot;):
386              return value
387          else:
388              return str(value)
389  def _media_size_to_long(maxSize):
390      if len(maxSize) &lt; 2:
391          return 0
392      units = maxSize[-2:].upper()
393      bit_shift = _MEDIA_SIZE_BIT_SHIFTS.get(units)
394      if bit_shift is not None:
395          return int(maxSize[:-2]) &lt;&lt; bit_shift
396      else:
397          return int(maxSize)
398  def _media_path_url_from_info(root_desc, path_url):
399      return &quot;%(root)supload/%(service_path)s%(path)s&quot; % {
400          &quot;root&quot;: root_desc[&quot;rootUrl&quot;],
401          &quot;service_path&quot;: root_desc[&quot;servicePath&quot;],
402          &quot;path&quot;: path_url,
403      }
404  def _fix_up_parameters(method_desc, root_desc, http_method, schema):
405      parameters = method_desc.setdefault(&quot;parameters&quot;, {})
406      for name, description in root_desc.get(&quot;parameters&quot;, {}).items():
407          parameters[name] = description
408      for name in STACK_QUERY_PARAMETERS:
409          parameters[name] = STACK_QUERY_PARAMETER_DEFAULT_VALUE.copy()
410      if http_method in HTTP_PAYLOAD_METHODS and &quot;request&quot; in method_desc:
411          body = BODY_PARAMETER_DEFAULT_VALUE.copy()
412          body.update(method_desc[&quot;request&quot;])
413          parameters[&quot;body&quot;] = body
414      return parameters
415  def _fix_up_media_upload(method_desc, root_desc, path_url, parameters):
416      media_upload = method_desc.get(&quot;mediaUpload&quot;, {})
417      accept = media_upload.get(&quot;accept&quot;, [])
418      max_size = _media_size_to_long(media_upload.get(&quot;maxSize&quot;, &quot;&quot;))
419      media_path_url = None
420      if media_upload:
421          media_path_url = _media_path_url_from_info(root_desc, path_url)
422          parameters[&quot;media_body&quot;] = MEDIA_BODY_PARAMETER_DEFAULT_VALUE.copy()
423          parameters[&quot;media_mime_type&quot;] = MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE.copy()
424      return accept, max_size, media_path_url
425  def _fix_up_method_description(method_desc, root_desc, schema):
426      path_url = method_desc[&quot;path&quot;]
427      http_method = method_desc[&quot;httpMethod&quot;]
428      method_id = method_desc[&quot;id&quot;]
429      parameters = _fix_up_parameters(method_desc, root_desc, http_method, schema)
430      accept, max_size, media_path_url = _fix_up_media_upload(
431          method_desc, root_desc, path_url, parameters
432      )
433      return path_url, http_method, method_id, accept, max_size, media_path_url
434  def _fix_up_media_path_base_url(media_path_url, base_url):
435      parsed_media_url = urllib.parse.urlparse(media_path_url)
436      parsed_base_url = urllib.parse.urlparse(base_url)
437      if parsed_media_url.netloc == parsed_base_url.netloc:
438          return media_path_url
439      return urllib.parse.urlunparse(
440          parsed_media_url._replace(netloc=parsed_base_url.netloc)
441      )
442  def _urljoin(base, url):
443      if url.startswith(&quot;http://&quot;) or url.startswith(&quot;https://&quot;):
444          return urllib.parse.urljoin(base, url)
445      new_base = base if base.endswith(&quot;/&quot;) else base + &quot;/&quot;
446      new_url = url[1:] if url.startswith(&quot;/&quot;) else url
447      return new_base + new_url
448  class ResourceMethodParameters(object):
449      def __init__(self, method_desc):
450          self.argmap = {}
451          self.required_params = []
452          self.repeated_params = []
453          self.pattern_params = {}
454          self.query_params = []
455          self.path_params = set()
456          self.param_types = {}
457          self.enum_params = {}
458          self.set_parameters(method_desc)
459      def set_parameters(self, method_desc):
460          parameters = method_desc.get(&quot;parameters&quot;, {})
461          sorted_parameters = OrderedDict(sorted(parameters.items()))
462          for arg, desc in sorted_parameters.items():
463              param = key2param(arg)
464              self.argmap[param] = arg
465              if desc.get(&quot;pattern&quot;):
466                  self.pattern_params[param] = desc[&quot;pattern&quot;]
467              if desc.get(&quot;enum&quot;):
468                  self.enum_params[param] = desc[&quot;enum&quot;]
469              if desc.get(&quot;required&quot;):
470                  self.required_params.append(param)
471              if desc.get(&quot;repeated&quot;):
472                  self.repeated_params.append(param)
473              if desc.get(&quot;location&quot;) == &quot;query&quot;:
474                  self.query_params.append(param)
475              if desc.get(&quot;location&quot;) == &quot;path&quot;:
476                  self.path_params.add(param)
477              self.param_types[param] = desc.get(&quot;type&quot;, &quot;string&quot;)
478          for match in URITEMPLATE.finditer(method_desc[&quot;path&quot;]):
479              for namematch in VARNAME.finditer(match.group(0)):
480                  name = key2param(namematch.group(0))
481                  self.path_params.add(name)
482                  if name in self.query_params:
483                      self.query_params.remove(name)
484  def createMethod(methodName, methodDesc, rootDesc, schema):
485      methodName = fix_method_name(methodName)
486      (
487          pathUrl,
488          httpMethod,
489          methodId,
490          accept,
491          maxSize,
492          mediaPathUrl,
493      ) = _fix_up_method_description(methodDesc, rootDesc, schema)
494      parameters = ResourceMethodParameters(methodDesc)
495      def method(self, **kwargs):
496          for name in kwargs:
497              if name not in parameters.argmap:
498                  raise TypeError(&quot;Got an unexpected keyword argument {}&quot;.format(name))
499          keys = list(kwargs.keys())
500          for name in keys:
501              if kwargs[name] is None:
502                  del kwargs[name]
503          for name in parameters.required_params:
504              if name not in kwargs:
505                  if name not in _PAGE_TOKEN_NAMES or _findPageTokenName(
506                      _methodProperties(methodDesc, schema, &quot;response&quot;)
507                  ):
508                      raise TypeError(&#x27;Missing required parameter &quot;%s&quot;&#x27; % name)
509          for name, regex in parameters.pattern_params.items():
510              if name in kwargs:
511                  if isinstance(kwargs[name], str):
512                      pvalues = [kwargs[name]]
513                  else:
514                      pvalues = kwargs[name]
515                  for pvalue in pvalues:
516                      if re.match(regex, pvalue) is None:
517                          raise TypeError(
518                              &#x27;Parameter &quot;%s&quot; value &quot;%s&quot; does not match the pattern &quot;%s&quot;&#x27;
519                              % (name, pvalue, regex)
520                          )
521          for name, enums in parameters.enum_params.items():
522              if name in kwargs:
523                  if name in parameters.repeated_params and not isinstance(
524                      kwargs[name], str
525                  ):
526                      values = kwargs[name]
527                  else:
528                      values = [kwargs[name]]
529                  for value in values:
530                      if value not in enums:
531                          raise TypeError(
532                              &#x27;Parameter &quot;%s&quot; value &quot;%s&quot; is not an allowed value in &quot;%s&quot;&#x27;
533                              % (name, value, str(enums))
534                          )
535          actual_query_params = {}
536          actual_path_params = {}
537          for key, value in kwargs.items():
538              to_type = parameters.param_types.get(key, &quot;string&quot;)
539              if key in parameters.repeated_params and type(value) == type([]):
540                  cast_value = [_cast(x, to_type) for x in value]
541              else:
542                  cast_value = _cast(value, to_type)
543              if key in parameters.query_params:
544                  actual_query_params[parameters.argmap[key]] = cast_value
545              if key in parameters.path_params:
546                  actual_path_params[parameters.argmap[key]] = cast_value
547          body_value = kwargs.get(&quot;body&quot;, None)
548          media_filename = kwargs.get(&quot;media_body&quot;, None)
549          media_mime_type = kwargs.get(&quot;media_mime_type&quot;, None)
550          if self._developerKey:
551              actual_query_params[&quot;key&quot;] = self._developerKey
552          model = self._model
553          if methodName.endswith(&quot;_media&quot;):
554              model = MediaModel()
555          elif &quot;response&quot; not in methodDesc:
556              model = RawModel()
557          headers = {}
558          headers, params, query, body = model.request(
559              headers, actual_path_params, actual_query_params, body_value
560          )
561          expanded_url = uritemplate.expand(pathUrl, params)
562          url = _urljoin(self._baseUrl, expanded_url + query)
563          resumable = None
564          multipart_boundary = &quot;&quot;
565          if media_filename:
566              if isinstance(media_filename, str):
567                  if media_mime_type is None:
568                      logger.warning(
569                          &quot;media_mime_type argument not specified: trying to auto-detect for %s&quot;,
570                          media_filename,
571                      )
572                      media_mime_type, _ = mimetypes.guess_type(media_filename)
573                  if media_mime_type is None:
574                      raise UnknownFileType(media_filename)
575                  if not mimeparse.best_match([media_mime_type], &quot;,&quot;.join(accept)):
576                      raise UnacceptableMimeTypeError(media_mime_type)
577                  media_upload = MediaFileUpload(media_filename, mimetype=media_mime_type)
578              elif isinstance(media_filename, MediaUpload):
579                  media_upload = media_filename
580              else:
581                  raise TypeError(&quot;media_filename must be str or MediaUpload.&quot;)
582              if media_upload.size() is not None and media_upload.size() &gt; maxSize &gt; 0:
583                  raise MediaUploadSizeError(&quot;Media larger than: %s&quot; % maxSize)
584              expanded_url = uritemplate.expand(mediaPathUrl, params)
585              url = _urljoin(self._baseUrl, expanded_url + query)
586              url = _fix_up_media_path_base_url(url, self._baseUrl)
587              if media_upload.resumable():
588                  url = _add_query_parameter(url, &quot;uploadType&quot;, &quot;resumable&quot;)
589              if media_upload.resumable():
590                  resumable = media_upload
591              else:
592                  if body is None:
593                      headers[&quot;content-type&quot;] = media_upload.mimetype()
594                      body = media_upload.getbytes(0, media_upload.size())
595                      url = _add_query_parameter(url, &quot;uploadType&quot;, &quot;media&quot;)
596                  else:
597                      msgRoot = MIMEMultipart(&quot;related&quot;)
598                      setattr(msgRoot, &quot;_write_headers&quot;, lambda self: None)
599                      msg = MIMENonMultipart(*headers[&quot;content-type&quot;].split(&quot;/&quot;))
600                      msg.set_payload(body)
601                      msgRoot.attach(msg)
602                      msg = MIMENonMultipart(*media_upload.mimetype().split(&quot;/&quot;))
603                      msg[&quot;Content-Transfer-Encoding&quot;] = &quot;binary&quot;
604                      payload = media_upload.getbytes(0, media_upload.size())
605                      msg.set_payload(payload)
606                      msgRoot.attach(msg)
607                      fp = io.BytesIO()
<span onclick='openModal()' class='match'>608                      g = _BytesGenerator(fp, mangle_from_=False)
609                      g.flatten(msgRoot, unixfrom=False)
610                      body = fp.getvalue()
611                      multipart_boundary = msgRoot.get_boundary()
</span>612                      headers[&quot;content-type&quot;] = (
613                          &quot;multipart/related; &quot; &#x27;boundary=&quot;%s&quot;&#x27;
614                      ) % multipart_boundary
615                      url = _add_query_parameter(url, &quot;uploadType&quot;, &quot;multipart&quot;)
616          logger.debug(&quot;URL being requested: %s %s&quot; % (httpMethod, url))
617          return self._requestBuilder(
618              self._http,
619              model.response,
620              url,
621              method=httpMethod,
622              body=body,
623              headers=headers,
624              methodId=methodId,
625              resumable=resumable,
626          )
627      docs = [methodDesc.get(&quot;description&quot;, DEFAULT_METHOD_DOC), &quot;\n\n&quot;]
628      if len(parameters.argmap) &gt; 0:
629          docs.append(&quot;Args:\n&quot;)
630      skip_parameters = list(rootDesc.get(&quot;parameters&quot;, {}).keys())
631      skip_parameters.extend(STACK_QUERY_PARAMETERS)
632      all_args = list(parameters.argmap.keys())
633      args_ordered = [key2param(s) for s in methodDesc.get(&quot;parameterOrder&quot;, [])]
634      if &quot;body&quot; in all_args:
635          args_ordered.append(&quot;body&quot;)
636      for name in sorted(all_args):
637          if name not in args_ordered:
638              args_ordered.append(name)
639      for arg in args_ordered:
640          if arg in skip_parameters:
641              continue
642          repeated = &quot;&quot;
643          if arg in parameters.repeated_params:
644              repeated = &quot; (repeated)&quot;
645          required = &quot;&quot;
646          if arg in parameters.required_params:
647              required = &quot; (required)&quot;
648          paramdesc = methodDesc[&quot;parameters&quot;][parameters.argmap[arg]]
649          paramdoc = paramdesc.get(&quot;description&quot;, &quot;A parameter&quot;)
650          if &quot;$ref&quot; in paramdesc:
651              docs.append(
652                  (&quot;  %s: object, %s%s%s\n    The object takes the form of:\n\n%s\n\n&quot;)
653                  % (
654                      arg,
655                      paramdoc,
656                      required,
657                      repeated,
658                      schema.prettyPrintByName(paramdesc[&quot;$ref&quot;]),
659                  )
660              )
661          else:
662              paramtype = paramdesc.get(&quot;type&quot;, &quot;string&quot;)
663              docs.append(
664                  &quot;  %s: %s, %s%s%s\n&quot; % (arg, paramtype, paramdoc, required, repeated)
665              )
666          enum = paramdesc.get(&quot;enum&quot;, [])
667          enumDesc = paramdesc.get(&quot;enumDescriptions&quot;, [])
668          if enum and enumDesc:
669              docs.append(&quot;    Allowed values\n&quot;)
670              for (name, desc) in zip(enum, enumDesc):
671                  docs.append(&quot;      %s - %s\n&quot; % (name, desc))
672      if &quot;response&quot; in methodDesc:
673          if methodName.endswith(&quot;_media&quot;):
674              docs.append(&quot;\nReturns:\n  The media object as a string.\n\n    &quot;)
675          else:
676              docs.append(&quot;\nReturns:\n  An object of the form:\n\n    &quot;)
677              docs.append(schema.prettyPrintSchema(methodDesc[&quot;response&quot;]))
678      setattr(method, &quot;__doc__&quot;, &quot;&quot;.join(docs))
679      return (methodName, method)
680  def createNextMethod(
681      methodName,
682      pageTokenName=&quot;pageToken&quot;,
683      nextPageTokenName=&quot;nextPageToken&quot;,
684      isPageTokenParameter=True,
685  ):
686      methodName = fix_method_name(methodName)
687      def methodNext(self, previous_request, previous_response):
688          nextPageToken = previous_response.get(nextPageTokenName, None)
689          if not nextPageToken:
690              return None
691          request = copy.copy(previous_request)
692          if isPageTokenParameter:
693              request.uri = _add_query_parameter(
694                  request.uri, pageTokenName, nextPageToken
695              )
696              logger.debug(&quot;Next page request URL: %s %s&quot; % (methodName, request.uri))
697          else:
698              model = self._model
699              body = model.deserialize(request.body)
700              body[pageTokenName] = nextPageToken
701              request.body = model.serialize(body)
702              request.body_size = len(request.body)
703              if &quot;content-length&quot; in request.headers:
704                  del request.headers[&quot;content-length&quot;]
705              logger.debug(&quot;Next page request body: %s %s&quot; % (methodName, body))
706          return request
707      return (methodName, methodNext)
708  class Resource(object):
709      def __init__(
710          self,
711          http,
712          baseUrl,
713          model,
714          requestBuilder,
715          developerKey,
716          resourceDesc,
717          rootDesc,
718          schema,
719      ):
720          self._dynamic_attrs = []
721          self._http = http
722          self._baseUrl = baseUrl
723          self._model = model
724          self._developerKey = developerKey
725          self._requestBuilder = requestBuilder
726          self._resourceDesc = resourceDesc
727          self._rootDesc = rootDesc
728          self._schema = schema
729          self._set_service_methods()
730      def _set_dynamic_attr(self, attr_name, value):
731          self._dynamic_attrs.append(attr_name)
732          self.__dict__[attr_name] = value
733      def __getstate__(self):
734          state_dict = copy.copy(self.__dict__)
735          for dynamic_attr in self._dynamic_attrs:
736              del state_dict[dynamic_attr]
737          del state_dict[&quot;_dynamic_attrs&quot;]
738          return state_dict
739      def __setstate__(self, state):
740          self.__dict__.update(state)
741          self._dynamic_attrs = []
742          self._set_service_methods()
743      def __enter__(self):
744          return self
745      def __exit__(self, exc_type, exc, exc_tb):
746          self.close()
747      def close(self):
748          self._http.close()
749      def _set_service_methods(self):
750          self._add_basic_methods(self._resourceDesc, self._rootDesc, self._schema)
751          self._add_nested_resources(self._resourceDesc, self._rootDesc, self._schema)
752          self._add_next_methods(self._resourceDesc, self._schema)
753      def _add_basic_methods(self, resourceDesc, rootDesc, schema):
754          if resourceDesc == rootDesc:
755              batch_uri = &quot;%s%s&quot; % (
756                  rootDesc[&quot;rootUrl&quot;],
757                  rootDesc.get(&quot;batchPath&quot;, &quot;batch&quot;),
758              )
759              def new_batch_http_request(callback=None):
760                  return BatchHttpRequest(callback=callback, batch_uri=batch_uri)
761              self._set_dynamic_attr(&quot;new_batch_http_request&quot;, new_batch_http_request)
762          if &quot;methods&quot; in resourceDesc:
763              for methodName, methodDesc in resourceDesc[&quot;methods&quot;].items():
764                  fixedMethodName, method = createMethod(
765                      methodName, methodDesc, rootDesc, schema
766                  )
767                  self._set_dynamic_attr(
768                      fixedMethodName, method.__get__(self, self.__class__)
769                  )
770                  if methodDesc.get(&quot;supportsMediaDownload&quot;, False):
771                      fixedMethodName, method = createMethod(
772                          methodName + &quot;_media&quot;, methodDesc, rootDesc, schema
773                      )
774                      self._set_dynamic_attr(
775                          fixedMethodName, method.__get__(self, self.__class__)
776                      )
777      def _add_nested_resources(self, resourceDesc, rootDesc, schema):
778          if &quot;resources&quot; in resourceDesc:
779              def createResourceMethod(methodName, methodDesc):
780                  methodName = fix_method_name(methodName)
781                  def methodResource(self):
782                      return Resource(
783                          http=self._http,
784                          baseUrl=self._baseUrl,
785                          model=self._model,
786                          developerKey=self._developerKey,
787                          requestBuilder=self._requestBuilder,
788                          resourceDesc=methodDesc,
789                          rootDesc=rootDesc,
790                          schema=schema,
791                      )
792                  setattr(methodResource, &quot;__doc__&quot;, &quot;A collection resource.&quot;)
793                  setattr(methodResource, &quot;__is_resource__&quot;, True)
794                  return (methodName, methodResource)
795              for methodName, methodDesc in resourceDesc[&quot;resources&quot;].items():
796                  fixedMethodName, method = createResourceMethod(methodName, methodDesc)
797                  self._set_dynamic_attr(
798                      fixedMethodName, method.__get__(self, self.__class__)
799                  )
800      def _add_next_methods(self, resourceDesc, schema):
801          if &quot;methods&quot; not in resourceDesc:
802              return
803          for methodName, methodDesc in resourceDesc[&quot;methods&quot;].items():
804              nextPageTokenName = _findPageTokenName(
805                  _methodProperties(methodDesc, schema, &quot;response&quot;)
806              )
807              if not nextPageTokenName:
808                  continue
809              isPageTokenParameter = True
810              pageTokenName = _findPageTokenName(methodDesc.get(&quot;parameters&quot;, {}))
811              if not pageTokenName:
812                  isPageTokenParameter = False
813                  pageTokenName = _findPageTokenName(
814                      _methodProperties(methodDesc, schema, &quot;request&quot;)
815                  )
816              if not pageTokenName:
817                  continue
818              fixedMethodName, method = createNextMethod(
819                  methodName + &quot;_next&quot;,
820                  pageTokenName,
821                  nextPageTokenName,
822                  isPageTokenParameter,
823              )
824              self._set_dynamic_attr(
825                  fixedMethodName, method.__get__(self, self.__class__)
826              )
827  def _findPageTokenName(fields):
828      return next(
829          (tokenName for tokenName in _PAGE_TOKEN_NAMES if tokenName in fields), None
830      )
831  def _methodProperties(methodDesc, schema, name):
832      desc = methodDesc.get(name, {})
833      if &quot;$ref&quot; in desc:
834          desc = schema.get(desc[&quot;$ref&quot;], {})
835      return desc.get(&quot;properties&quot;, {})
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-http.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-discovery.py</div>
                </div>
                <div class="column column_space"><pre><code>641          g = Generator(fp, mangle_from_=False)
642          g.flatten(message, unixfrom=False)
643          body = fp.getvalue()
644          headers = {}
</pre></code></div>
                <div class="column column_space"><pre><code>608                      g = _BytesGenerator(fp, mangle_from_=False)
609                      g.flatten(msgRoot, unixfrom=False)
610                      body = fp.getvalue()
611                      multipart_boundary = msgRoot.get_boundary()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    