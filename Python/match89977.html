<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bsd_shadow.py &amp; test_saltmod_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bsd_shadow.py &amp; test_saltmod_1.py
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bsd_shadow.py (6.4864864%)<th>test_saltmod_1.py (2.6258206%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(39-41)<td><a href="#" name="0">(248-250)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bsd_shadow.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Alan Somers &lt;asomers@gmail.com&gt;
"""
import re
import salt.utils.platform
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf
try:
    import salt.modules.bsd_shadow as shadow
    HAS_SHADOW = True
except ImportError:
    HAS_SHADOW = False
@skipIf(not salt.utils.platform.is_freebsd(), "minion is not FreeBSD")
@skipIf(not HAS_SHADOW, "shadow module is not available")
class BSDShadowTest(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            shadow: {
                "__grains__": {"kernel": "FreeBSD", "os": "FreeBSD"},
                "__salt__": {"cmd.has_exec": MagicMock(return_value=True)},
            }
        }
    def test_del_password(self):
        """
        Test shadow.del_password
        info_mock = MagicMock(return_value="root::0:0::0:0:Charlie &amp;:/root:/bin/sh")
        usermod_mock = MagicMock(return_value=0)
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
            with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
                shadow.del_password(</b></font>"root")
        usermod_mock.assert_called_once_with(
            "pw user mod root -w none", output_loglevel="quiet", python_shell=False
        )
    def test_gen_password(self):
        """
        Test shadow.gen_password
        """
        self.assertEqual(
            "$6$salt$wZU8LXJfJJqoagopbB7RuK6JEotEMZ0CQDy0phpPAuLMYQFcmf6L6BdAbs/Q7w7o1qsZ9pFqFVY4yuUSWgaYt1",
            shadow.gen_password("x", crypt_salt="salt", algorithm="sha512"),
        )
        self.assertEqual(
            "$5$salt$eC8iHMk0B/acxRGi4idWiCK/.xXHLUsxovn4V591t3.",
            shadow.gen_password("x", crypt_salt="salt", algorithm="sha256"),
        )
    def test_info(self):
        """
        Test shadow.info
        """
        mock = MagicMock(return_value="root:*:0:0::42:69:Charlie &amp;:/root:/bin/sh")
        with patch.dict(shadow.__salt__, {"cmd.run_stdout": mock}):
            info = shadow.info("root")
        self.assertEqual("root", info["name"])
        self.assertEqual(42, info["change"])
        self.assertEqual(69, info["expire"])
        self.assertTrue(
            info["passwd"] == "*"  # if the test is not running as root
            or re.match(r"^\$[0-9]\$", info["passwd"])  # modular format
            or re.match(r"^_", info["passwd"])  # DES Extended format
            or info["passwd"] == ""  # No password
            or re.match(r"^\*LOCKED\*", info["passwd"])  # Locked account
        )
    def test_set_change(self):
        """
        Test shadow.set_change
        """
        info_mock = MagicMock(return_value="root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh")
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
            with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
                shadow.set_change("root", 42)
        usermod_mock.assert_called_once_with(
            ["pw", "user", "mod", "root", "-f", 42], python_shell=False
        )
    def test_set_expire(self):
        """
        Test shadow.set_expire
        """
        info_mock = MagicMock(return_value="root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh")
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
            with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
                shadow.set_expire("root", 42)
        usermod_mock.assert_called_once_with(
            ["pw", "user", "mod", "root", "-e", 42], python_shell=False
        )
    def test_set_password(self):
        """
        Test shadow.set_password
        """
        PASSWORD = "$6$1jReqE6eU.b.fl0X$lzsxgaP6kgPyW0kxeDhAn0ySH08gn5A3At0NDHRFUSkk/6s4hCgE9OTpSsNs1Vcvws3zN0lEXkxCYeZoTVY4A1"
        info_mock = MagicMock(return_value="root:%s:0:0::0:0:Charlie &amp;:/root:/bin/sh")
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
            with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
                shadow.set_password("root", PASSWORD)
        usermod_mock.assert_called_once_with(
            ["pw", "user", "mod", "root", "-H", "0"],
            stdin=PASSWORD,
            output_loglevel="quiet",
            python_shell=False,
        )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
"""
import os
import tempfile
import pytest
import salt.config
import salt.loader
import salt.states.saltmod as saltmod
import salt.utils.event
import salt.utils.jid
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase
class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.states.saltmod
    """
    def setup_loader_modules(self):
        utils = salt.loader.utils(
            salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=["state"]
        )
        return {
            saltmod: {
                "__env__": "base",
                "__opts__": {
                    "__role": "master",
                    "file_client": "remote",
                    "sock_dir": tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
                    "transport": "tcp",
                },
                "__salt__": {"saltutil.cmd": MagicMock()},
                "__orchestration_jid__": salt.utils.jid.gen_jid({}),
                "__utils__": utils,
            }
        }
    @pytest.mark.slow_test
    def test_state(self):
        """
        Test to invoke a state run on a given target
        """
        name = "state"
        tgt = "minion1"
        comt = "Passed invalid value for 'allow_fail', must be an int"
        ret = {"name": name, "changes": {}, "result": False, "comment": comt}
        test_ret = {
            "name": name,
            "changes": {},
            "result": True,
            "comment": "States ran successfully.",
        }
        test_batch_return = {
            "minion1": {
                "ret": {
                    "test_|-notify_me_|-this is a name_|-show_notification": {
                        "comment": "Notify me",
                        "name": "this is a name",
                        "start_time": "10:43:41.487565",
                        "result": True,
                        "duration": 0.35,
                        "__run_num__": 0,
                        "__sls__": "demo",
                        "changes": {},
                        "__id__": "notify_me",
                    },
                    "retcode": 0,
                },
                "out": "highstate",
            },
            "minion2": {
                "ret": {
                    "test_|-notify_me_|-this is a name_|-show_notification": {
                        "comment": "Notify me",
                        "name": "this is a name",
                        "start_time": "10:43:41.487565",
                        "result": True,
                        "duration": 0.35,
                        "__run_num__": 0,
                        "__sls__": "demo",
                        "changes": {},
                        "__id__": "notify_me",
                    },
                    "retcode": 0,
                },
                "out": "highstate",
            },
            "minion3": {
                "ret": {
                    "test_|-notify_me_|-this is a name_|-show_notification": {
                        "comment": "Notify me",
                        "name": "this is a name",
                        "start_time": "10:43:41.487565",
                        "result": True,
                        "duration": 0.35,
                        "__run_num__": 0,
                        "__sls__": "demo",
                        "changes": {},
                        "__id__": "notify_me",
                    },
                    "retcode": 0,
                },
                "out": "highstate",
            },
        }
        self.assertDictEqual(saltmod.state(name, tgt, allow_fail="a"), ret)
        comt = "No highstate or sls specified, no execution made"
        ret.update({"comment": comt})
        self.assertDictEqual(saltmod.state(name, tgt), ret)
        comt = "Must pass in boolean for value of 'concurrent'"
        ret.update({"comment": comt})
        self.assertDictEqual(
            saltmod.state(name, tgt, highstate=True, concurrent="a"), ret
        )
        ret.update({"comment": comt, "result": None})
        with patch.dict(saltmod.__opts__, {"test": True}):
            self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)
        ret.update(
            {
                "comment": "States ran successfully. No changes made to silver.",
                "result": True,
                "__jid__": "20170406104341210934",
            }
        )
        with patch.dict(saltmod.__opts__, {"test": False}):
            mock = MagicMock(
                return_value={
                    "silver": {
                        "jid": "20170406104341210934",
                        "retcode": 0,
                        "ret": {
                            "test_|-notify_me_|-this is a name_|-show_notification": {
                                "comment": "Notify me",
                                "name": "this is a name",
                                "start_time": "10:43:41.487565",
                                "result": True,
                                "duration": 0.35,
                                "__run_num__": 0,
                                "__sls__": "demo",
                                "changes": {},
                                "__id__": "notify_me",
                            }
                        },
                        "out": "highstate",
                    }
                }
            )
            with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock}):
                self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)
        ret.update(
            {
                "comment": (
                    "States ran successfully. No changes made to minion1, minion3,"
                    " minion2."
                )
            }
        )
        del ret["__jid__"]
        with patch.dict(saltmod.__opts__, {"test": False}):
            with patch.dict(
                saltmod.__salt__,
                {"saltutil.cmd": MagicMock(return_value=test_batch_return)},
            ):
                state_run = saltmod.state(name, tgt, highstate=True)
                comment = state_run.pop("comment")
                ret.pop("comment")
                self.assertDictEqual(state_run, ret)
                self.assertIn("States ran successfully. No changes made to", comment)
                for minion in ["minion1", "minion2", "minion3"]:
                    self.assertIn(minion, comment)
    @pytest.mark.slow_test
    def test_function(self):
        """
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        """
        name = "state"
        tgt = "larry"
        ret = {
            "name": name,
            "changes": {},
            "result": None,
            "comment": "Function state would be executed on target {}".format(tgt),
        }
        with patch.dict(saltmod.__opts__, {"test": True}):
            self.assertDictEqual(saltmod.function(name, tgt), ret)
        ret.update(
            {
                "result": True,
                "changes": {"ret": {tgt: ""}},
                "comment": (
                    "Function ran successfully. Function state ran on {}.".format(tgt)
                ),
            }
        )
        with patch.dict(saltmod.__opts__, {"test": False}):
            mock_ret = {"larry": {"ret": "", "retcode": 0, "failed": False}}
            mock_cmd = MagicMock(return_value=mock_ret)
            with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
                self.assertDictEqual(saltmod.function(name, tgt), ret)
    @pytest.mark.slow_test
    def test_function_when_no_minions_match(self):
        """
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        """
        name = "state"
        tgt = "larry"
        mock_ret = {}
        mock_cmd = MagicMock(return_value=mock_ret)
        ret = {
            "name": name,
            "changes": {},
            "result": False,
        }
        <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with patch.dict(saltmod.__opts__, {"test": False}):
            with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
                self.assertDictEqual(</b></font>saltmod.function(name, tgt), ret)
    def test_wait_for_event(self):
        """
        Test to watch Salt's event bus and block until a condition is met
        """
        name = "state"
        tgt = "minion1"
        comt = "Timeout value reached."
        ret = {"name": name, "changes": {}, "result": False, "comment": comt}
        class Mockevent:
            """
            Mock event class
            """
            flag = None
            def __init__(self):
                self.full = None
            def get_event(self, full):
                """
                Mock get_event method
                """
                self.full = full
                if self.flag:
                    return {"tag": name, "data": {}}
                return None
            def __enter__(self):
                return self
            def __exit__(self, *args):
                pass
        with patch.object(
            salt.utils.event, "get_event", MagicMock(return_value=Mockevent())
        ):
            with patch.dict(saltmod.__opts__, {"sock_dir": True, "transport": True}):
                with patch(
                    "salt.states.saltmod.time.time", MagicMock(return_value=1.0)
                ):
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, "salt", timeout=-1.0), ret
                    )
                    Mockevent.flag = True
                    ret.update(
                        {"comment": "All events seen in 0.0 seconds.", "result": True}
                    )
                    self.assertDictEqual(saltmod.wait_for_event(name, ""), ret)
                    ret.update({"comment": "Timeout value reached.", "result": False})
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
                    )
    def test_runner(self):
        """
        Test to execute a runner module on the master
        """
        name = "state"
        ret = {
            "changes": {"return": True},
            "name": "state",
            "result": True,
            "comment": "Runner function 'state' executed.",
            "__orchestration__": True,
        }
        runner_mock = MagicMock(return_value={"return": True})
        with patch.dict(saltmod.__salt__, {"saltutil.runner": runner_mock}):
            self.assertDictEqual(saltmod.runner(name), ret)
    def test_wheel(self):
        """
        Test to execute a wheel module on the master
        """
        name = "state"
        ret = {
            "changes": {"return": True},
            "name": "state",
            "result": True,
            "comment": "Wheel function 'state' executed.",
            "__orchestration__": True,
        }
        wheel_mock = MagicMock(return_value={"return": True})
        with patch.dict(saltmod.__salt__, {"saltutil.wheel": wheel_mock}):
            self.assertDictEqual(saltmod.wheel(name), ret)
    @pytest.mark.slow_test
    def test_state_ssh(self):
        """
        Test saltmod state passes roster to saltutil.cmd
        """
        origcmd = saltmod.__salt__["saltutil.cmd"]
        cmd_kwargs = {}
        cmd_args = []
        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)
        with patch.dict(saltmod.__salt__, {"saltutil.cmd": cmd_mock}):
            ret = saltmod.state(
                "state.sls", tgt="*", ssh=True, highstate=True, roster="my_roster"
            )
        assert "roster" in cmd_kwargs
        assert cmd_kwargs["roster"] == "my_roster"
    @pytest.mark.slow_test
    def test_function_ssh(self):
        """
        Test saltmod function passes roster to saltutil.cmd
        """
        origcmd = saltmod.__salt__["saltutil.cmd"]
        cmd_kwargs = {}
        cmd_args = []
        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)
        with patch.dict(saltmod.__opts__, {"test": False}), patch.dict(
            saltmod.__salt__, {"saltutil.cmd": cmd_mock}
        ):
            saltmod.function("state", tgt="*", ssh=True, roster="my_roster")
        assert "roster" in cmd_kwargs
        assert cmd_kwargs["roster"] == "my_roster"
class StatemodTests(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        return {
            saltmod: {
                "__env__": "base",
                "__opts__": {
                    "id": "webserver2",
                    "argv": [],
                    "__role": "master",
                    "cachedir": self.tmp_cachedir,
                    "extension_modules": os.path.join(self.tmp_cachedir, "extmods"),
                },
                "__salt__": {"saltutil.cmd": MagicMock()},
                "__orchestration_jid__": salt.utils.jid.gen_jid({}),
            }
        }
    def test_statemod_state(self):
        """Smoke test for for salt.states.statemod.state().  Ensures that we
        don't take an exception if optional parameters are not specified in
        __opts__ or __env__.
        """
        args = ("webserver_setup", "webserver2")
        kwargs = {
            "tgt_type": "glob",
            "fail_minions": None,
            "pillar": None,
            "top": None,
            "batch": None,
            "orchestration_jid": None,
            "sls": "vroom",
            "queue": False,
            "concurrent": False,
            "highstate": None,
            "expr_form": None,
            "ret": "",
            "ssh": False,
            "timeout": None,
            "test": False,
            "allow_fail": 0,
            "saltenv": None,
            "expect_minions": False,
        }
        ret = saltmod.state(*args, **kwargs)
        expected = {
            "comment": "States ran successfully.",
            "changes": {},
            "name": "webserver_setup",
            "result": True,
        }
        self.assertEqual(ret, expected)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
