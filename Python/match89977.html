<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_bsd_shadow.py & test_saltmod_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_bsd_shadow.py & test_saltmod_1.py
      </h3>
      <h1 align="center">
        3.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_bsd_shadow.py (6.4864864%)<TH>test_saltmod_1.py (2.6258206%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match89977-0.html#0',2,'match89977-1.html#0',3)" NAME="0">(39-41)<TD><A HREF="javascript:ZweiFrames('match89977-0.html#0',2,'match89977-1.html#0',3)" NAME="0">(248-250)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bsd_shadow.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Alan Somers &lt;asomers@gmail.com&gt;
&quot;&quot;&quot;


import re

import salt.utils.platform
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

try:
    import salt.modules.bsd_shadow as shadow

    HAS_SHADOW = True
except ImportError:
    HAS_SHADOW = False

# Although bsd_shadow runs on NetBSD and OpenBSD as well, the mocks are
# currently only designed for FreeBSD.
@skipIf(not salt.utils.platform.is_freebsd(), &quot;minion is not FreeBSD&quot;)
@skipIf(not HAS_SHADOW, &quot;shadow module is not available&quot;)
class BSDShadowTest(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            shadow: {
                &quot;__grains__&quot;: {&quot;kernel&quot;: &quot;FreeBSD&quot;, &quot;os&quot;: &quot;FreeBSD&quot;},
                &quot;__salt__&quot;: {&quot;cmd.has_exec&quot;: MagicMock(return_value=True)},
            }
        }

    def test_del_password(self):
        &quot;&quot;&quot;
        Test shadow.del_password
<A NAME="0"></A>        &quot;&quot;&quot;
        info_mock = MagicMock(return_value=&quot;root::0:0::0:0:Charlie &amp;:/root:/bin/sh&quot;)
        usermod_mock = MagicMock(return_value=0)
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match89977-1.html#0',3,'match89977-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>with patch.dict(shadow.__salt__, {&quot;cmd.run_stdout&quot;: info_mock}):
            with patch.dict(shadow.__salt__, {&quot;cmd.run&quot;: usermod_mock}):
                shadow.del_password(</B></FONT>&quot;root&quot;)
        usermod_mock.assert_called_once_with(
            &quot;pw user mod root -w none&quot;, output_loglevel=&quot;quiet&quot;, python_shell=False
        )

    def test_gen_password(self):
        &quot;&quot;&quot;
        Test shadow.gen_password
        &quot;&quot;&quot;
        self.assertEqual(
            &quot;$6$salt$wZU8LXJfJJqoagopbB7RuK6JEotEMZ0CQDy0phpPAuLMYQFcmf6L6BdAbs/Q7w7o1qsZ9pFqFVY4yuUSWgaYt1&quot;,
            shadow.gen_password(&quot;x&quot;, crypt_salt=&quot;salt&quot;, algorithm=&quot;sha512&quot;),
        )
        self.assertEqual(
            &quot;$5$salt$eC8iHMk0B/acxRGi4idWiCK/.xXHLUsxovn4V591t3.&quot;,
            shadow.gen_password(&quot;x&quot;, crypt_salt=&quot;salt&quot;, algorithm=&quot;sha256&quot;),
        )

    def test_info(self):
        &quot;&quot;&quot;
        Test shadow.info
        &quot;&quot;&quot;
        mock = MagicMock(return_value=&quot;root:*:0:0::42:69:Charlie &amp;:/root:/bin/sh&quot;)
        with patch.dict(shadow.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
            info = shadow.info(&quot;root&quot;)
        self.assertEqual(&quot;root&quot;, info[&quot;name&quot;])
        self.assertEqual(42, info[&quot;change&quot;])
        self.assertEqual(69, info[&quot;expire&quot;])
        self.assertTrue(
            info[&quot;passwd&quot;] == &quot;*&quot;  # if the test is not running as root
            or re.match(r&quot;^\$[0-9]\$&quot;, info[&quot;passwd&quot;])  # modular format
            or re.match(r&quot;^_&quot;, info[&quot;passwd&quot;])  # DES Extended format
            or info[&quot;passwd&quot;] == &quot;&quot;  # No password
            or re.match(r&quot;^\*LOCKED\*&quot;, info[&quot;passwd&quot;])  # Locked account
        )

    def test_set_change(self):
        &quot;&quot;&quot;
        Test shadow.set_change
        &quot;&quot;&quot;
        info_mock = MagicMock(return_value=&quot;root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh&quot;)
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {&quot;cmd.run_stdout&quot;: info_mock}):
            with patch.dict(shadow.__salt__, {&quot;cmd.run&quot;: usermod_mock}):
                shadow.set_change(&quot;root&quot;, 42)
        usermod_mock.assert_called_once_with(
            [&quot;pw&quot;, &quot;user&quot;, &quot;mod&quot;, &quot;root&quot;, &quot;-f&quot;, 42], python_shell=False
        )

    def test_set_expire(self):
        &quot;&quot;&quot;
        Test shadow.set_expire
        &quot;&quot;&quot;
        info_mock = MagicMock(return_value=&quot;root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh&quot;)
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {&quot;cmd.run_stdout&quot;: info_mock}):
            with patch.dict(shadow.__salt__, {&quot;cmd.run&quot;: usermod_mock}):
                shadow.set_expire(&quot;root&quot;, 42)
        usermod_mock.assert_called_once_with(
            [&quot;pw&quot;, &quot;user&quot;, &quot;mod&quot;, &quot;root&quot;, &quot;-e&quot;, 42], python_shell=False
        )

    def test_set_password(self):
        &quot;&quot;&quot;
        Test shadow.set_password
        &quot;&quot;&quot;
        PASSWORD = &quot;$6$1jReqE6eU.b.fl0X$lzsxgaP6kgPyW0kxeDhAn0ySH08gn5A3At0NDHRFUSkk/6s4hCgE9OTpSsNs1Vcvws3zN0lEXkxCYeZoTVY4A1&quot;
        info_mock = MagicMock(return_value=&quot;root:%s:0:0::0:0:Charlie &amp;:/root:/bin/sh&quot;)
        usermod_mock = MagicMock(return_value=0)
        with patch.dict(shadow.__salt__, {&quot;cmd.run_stdout&quot;: info_mock}):
            with patch.dict(shadow.__salt__, {&quot;cmd.run&quot;: usermod_mock}):
                shadow.set_password(&quot;root&quot;, PASSWORD)
        usermod_mock.assert_called_once_with(
            [&quot;pw&quot;, &quot;user&quot;, &quot;mod&quot;, &quot;root&quot;, &quot;-H&quot;, &quot;0&quot;],
            stdin=PASSWORD,
            output_loglevel=&quot;quiet&quot;,
            python_shell=False,
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import os
import tempfile

import pytest
import salt.config
import salt.loader
import salt.states.saltmod as saltmod
import salt.utils.event
import salt.utils.jid
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase


class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.states.saltmod
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        utils = salt.loader.utils(
            salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=[&quot;state&quot;]
        )
        return {
            saltmod: {
                &quot;__env__&quot;: &quot;base&quot;,
                &quot;__opts__&quot;: {
                    &quot;__role&quot;: &quot;master&quot;,
                    &quot;file_client&quot;: &quot;remote&quot;,
                    &quot;sock_dir&quot;: tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
                    &quot;transport&quot;: &quot;tcp&quot;,
                },
                &quot;__salt__&quot;: {&quot;saltutil.cmd&quot;: MagicMock()},
                &quot;__orchestration_jid__&quot;: salt.utils.jid.gen_jid({}),
                &quot;__utils__&quot;: utils,
            }
        }

    # 'state' function tests: 1

    @pytest.mark.slow_test
    def test_state(self):
        &quot;&quot;&quot;
        Test to invoke a state run on a given target
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;minion1&quot;

        comt = &quot;Passed invalid value for 'allow_fail', must be an int&quot;

        ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: comt}

        test_ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;States ran successfully.&quot;,
        }

        test_batch_return = {
            &quot;minion1&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
            &quot;minion2&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
            &quot;minion3&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
        }

        self.assertDictEqual(saltmod.state(name, tgt, allow_fail=&quot;a&quot;), ret)

        comt = &quot;No highstate or sls specified, no execution made&quot;
        ret.update({&quot;comment&quot;: comt})
        self.assertDictEqual(saltmod.state(name, tgt), ret)

        comt = &quot;Must pass in boolean for value of 'concurrent'&quot;
        ret.update({&quot;comment&quot;: comt})
        self.assertDictEqual(
            saltmod.state(name, tgt, highstate=True, concurrent=&quot;a&quot;), ret
        )

        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: True}):
            self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)

        ret.update(
            {
                &quot;comment&quot;: &quot;States ran successfully. No changes made to silver.&quot;,
                &quot;result&quot;: True,
                &quot;__jid__&quot;: &quot;20170406104341210934&quot;,
            }
        )
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            mock = MagicMock(
                return_value={
                    &quot;silver&quot;: {
                        &quot;jid&quot;: &quot;20170406104341210934&quot;,
                        &quot;retcode&quot;: 0,
                        &quot;ret&quot;: {
                            &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                                &quot;comment&quot;: &quot;Notify me&quot;,
                                &quot;name&quot;: &quot;this is a name&quot;,
                                &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                                &quot;result&quot;: True,
                                &quot;duration&quot;: 0.35,
                                &quot;__run_num__&quot;: 0,
                                &quot;__sls__&quot;: &quot;demo&quot;,
                                &quot;changes&quot;: {},
                                &quot;__id__&quot;: &quot;notify_me&quot;,
                            }
                        },
                        &quot;out&quot;: &quot;highstate&quot;,
                    }
                }
            )
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock}):
                self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)

        ret.update(
            {
                &quot;comment&quot;: (
                    &quot;States ran successfully. No changes made to minion1, minion3,&quot;
                    &quot; minion2.&quot;
                )
            }
        )
        del ret[&quot;__jid__&quot;]
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            with patch.dict(
                saltmod.__salt__,
                {&quot;saltutil.cmd&quot;: MagicMock(return_value=test_batch_return)},
            ):
                state_run = saltmod.state(name, tgt, highstate=True)

                # Test return without checking the comment contents. Comments are tested later.
                comment = state_run.pop(&quot;comment&quot;)
                ret.pop(&quot;comment&quot;)
                self.assertDictEqual(state_run, ret)

                # Check the comment contents in a non-order specific way (ordering fails sometimes on PY3)
                self.assertIn(&quot;States ran successfully. No changes made to&quot;, comment)
                for minion in [&quot;minion1&quot;, &quot;minion2&quot;, &quot;minion3&quot;]:
                    self.assertIn(minion, comment)

    # 'function' function tests: 1

    @pytest.mark.slow_test
    def test_function(self):
        &quot;&quot;&quot;
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;larry&quot;

        ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: None,
            &quot;comment&quot;: &quot;Function state would be executed on target {}&quot;.format(tgt),
        }

        with patch.dict(saltmod.__opts__, {&quot;test&quot;: True}):
            self.assertDictEqual(saltmod.function(name, tgt), ret)

        ret.update(
            {
                &quot;result&quot;: True,
                &quot;changes&quot;: {&quot;ret&quot;: {tgt: &quot;&quot;}},
                &quot;comment&quot;: (
                    &quot;Function ran successfully. Function state ran on {}.&quot;.format(tgt)
                ),
            }
        )
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            mock_ret = {&quot;larry&quot;: {&quot;ret&quot;: &quot;&quot;, &quot;retcode&quot;: 0, &quot;failed&quot;: False}}
            mock_cmd = MagicMock(return_value=mock_ret)
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock_cmd}):
                self.assertDictEqual(saltmod.function(name, tgt), ret)

    @pytest.mark.slow_test
    def test_function_when_no_minions_match(self):
        &quot;&quot;&quot;
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;larry&quot;
        mock_ret = {}
        mock_cmd = MagicMock(return_value=mock_ret)

        ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: False,
<A NAME="0"></A>            &quot;comment&quot;: &quot;No minions responded&quot;,
        }

        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match89977-0.html#0',2,'match89977-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock_cmd}):
                self.assertDictEqual(</B></FONT>saltmod.function(name, tgt), ret)

    # 'wait_for_event' function tests: 1

    def test_wait_for_event(self):
        &quot;&quot;&quot;
        Test to watch Salt's event bus and block until a condition is met
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;minion1&quot;

        comt = &quot;Timeout value reached.&quot;

        ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: comt}

        class Mockevent:
            &quot;&quot;&quot;
            Mock event class
            &quot;&quot;&quot;

            flag = None

            def __init__(self):
                self.full = None

            def get_event(self, full):
                &quot;&quot;&quot;
                Mock get_event method
                &quot;&quot;&quot;
                self.full = full
                if self.flag:
                    return {&quot;tag&quot;: name, &quot;data&quot;: {}}
                return None

            def __enter__(self):
                return self

            def __exit__(self, *args):
                pass

        with patch.object(
            salt.utils.event, &quot;get_event&quot;, MagicMock(return_value=Mockevent())
        ):
            with patch.dict(saltmod.__opts__, {&quot;sock_dir&quot;: True, &quot;transport&quot;: True}):
                with patch(
                    &quot;salt.states.saltmod.time.time&quot;, MagicMock(return_value=1.0)
                ):
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, &quot;salt&quot;, timeout=-1.0), ret
                    )

                    Mockevent.flag = True
                    ret.update(
                        {&quot;comment&quot;: &quot;All events seen in 0.0 seconds.&quot;, &quot;result&quot;: True}
                    )
                    self.assertDictEqual(saltmod.wait_for_event(name, &quot;&quot;), ret)

                    ret.update({&quot;comment&quot;: &quot;Timeout value reached.&quot;, &quot;result&quot;: False})
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
                    )

    # 'runner' function tests: 1

    def test_runner(self):
        &quot;&quot;&quot;
        Test to execute a runner module on the master
        &quot;&quot;&quot;
        name = &quot;state&quot;

        ret = {
            &quot;changes&quot;: {&quot;return&quot;: True},
            &quot;name&quot;: &quot;state&quot;,
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;Runner function 'state' executed.&quot;,
            &quot;__orchestration__&quot;: True,
        }
        runner_mock = MagicMock(return_value={&quot;return&quot;: True})

        with patch.dict(saltmod.__salt__, {&quot;saltutil.runner&quot;: runner_mock}):
            self.assertDictEqual(saltmod.runner(name), ret)

    # 'wheel' function tests: 1

    def test_wheel(self):
        &quot;&quot;&quot;
        Test to execute a wheel module on the master
        &quot;&quot;&quot;
        name = &quot;state&quot;

        ret = {
            &quot;changes&quot;: {&quot;return&quot;: True},
            &quot;name&quot;: &quot;state&quot;,
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;Wheel function 'state' executed.&quot;,
            &quot;__orchestration__&quot;: True,
        }
        wheel_mock = MagicMock(return_value={&quot;return&quot;: True})

        with patch.dict(saltmod.__salt__, {&quot;saltutil.wheel&quot;: wheel_mock}):
            self.assertDictEqual(saltmod.wheel(name), ret)

    @pytest.mark.slow_test
    def test_state_ssh(self):
        &quot;&quot;&quot;
        Test saltmod state passes roster to saltutil.cmd
        &quot;&quot;&quot;
        origcmd = saltmod.__salt__[&quot;saltutil.cmd&quot;]
        cmd_kwargs = {}
        cmd_args = []

        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)

        with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: cmd_mock}):
            ret = saltmod.state(
                &quot;state.sls&quot;, tgt=&quot;*&quot;, ssh=True, highstate=True, roster=&quot;my_roster&quot;
            )
        assert &quot;roster&quot; in cmd_kwargs
        assert cmd_kwargs[&quot;roster&quot;] == &quot;my_roster&quot;

    @pytest.mark.slow_test
    def test_function_ssh(self):
        &quot;&quot;&quot;
        Test saltmod function passes roster to saltutil.cmd
        &quot;&quot;&quot;
        origcmd = saltmod.__salt__[&quot;saltutil.cmd&quot;]
        cmd_kwargs = {}
        cmd_args = []

        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)

        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}), patch.dict(
            saltmod.__salt__, {&quot;saltutil.cmd&quot;: cmd_mock}
        ):
            saltmod.function(&quot;state&quot;, tgt=&quot;*&quot;, ssh=True, roster=&quot;my_roster&quot;)
        assert &quot;roster&quot; in cmd_kwargs
        assert cmd_kwargs[&quot;roster&quot;] == &quot;my_roster&quot;


class StatemodTests(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        return {
            saltmod: {
                &quot;__env__&quot;: &quot;base&quot;,
                &quot;__opts__&quot;: {
                    &quot;id&quot;: &quot;webserver2&quot;,
                    &quot;argv&quot;: [],
                    &quot;__role&quot;: &quot;master&quot;,
                    &quot;cachedir&quot;: self.tmp_cachedir,
                    &quot;extension_modules&quot;: os.path.join(self.tmp_cachedir, &quot;extmods&quot;),
                },
                &quot;__salt__&quot;: {&quot;saltutil.cmd&quot;: MagicMock()},
                &quot;__orchestration_jid__&quot;: salt.utils.jid.gen_jid({}),
            }
        }

    def test_statemod_state(self):
        &quot;&quot;&quot;Smoke test for for salt.states.statemod.state().  Ensures that we
        don't take an exception if optional parameters are not specified in
        __opts__ or __env__.
        &quot;&quot;&quot;
        args = (&quot;webserver_setup&quot;, &quot;webserver2&quot;)
        kwargs = {
            &quot;tgt_type&quot;: &quot;glob&quot;,
            &quot;fail_minions&quot;: None,
            &quot;pillar&quot;: None,
            &quot;top&quot;: None,
            &quot;batch&quot;: None,
            &quot;orchestration_jid&quot;: None,
            &quot;sls&quot;: &quot;vroom&quot;,
            &quot;queue&quot;: False,
            &quot;concurrent&quot;: False,
            &quot;highstate&quot;: None,
            &quot;expr_form&quot;: None,
            &quot;ret&quot;: &quot;&quot;,
            &quot;ssh&quot;: False,
            &quot;timeout&quot;: None,
            &quot;test&quot;: False,
            &quot;allow_fail&quot;: 0,
            &quot;saltenv&quot;: None,
            &quot;expect_minions&quot;: False,
        }
        ret = saltmod.state(*args, **kwargs)
        expected = {
            &quot;comment&quot;: &quot;States ran successfully.&quot;,
            &quot;changes&quot;: {},
            &quot;name&quot;: &quot;webserver_setup&quot;,
            &quot;result&quot;: True,
        }
        self.assertEqual(ret, expected)
</PRE>
</div>
  </div>
</body>
</html>
