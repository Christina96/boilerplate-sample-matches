<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bsd_shadow.py &amp; test_saltmod_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bsd_shadow.py &amp; test_saltmod_1.py
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bsd_shadow.py (6.4864864%)<th>test_saltmod_1.py (2.6258206%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(39-41)<td><a href="#" name="0">(248-250)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bsd_shadow.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import re
2 import salt.utils.platform
3 from tests.support.mixins import LoaderModuleMockMixin
4 from tests.support.mock import MagicMock, patch
5 from tests.support.unit import TestCase, skipIf
6 try:
7     import salt.modules.bsd_shadow as shadow
8     HAS_SHADOW = True
9 except ImportError:
10     HAS_SHADOW = False
11 @skipIf(not salt.utils.platform.is_freebsd(), "minion is not FreeBSD")
12 @skipIf(not HAS_SHADOW, "shadow module is not available")
13 class BSDShadowTest(TestCase, LoaderModuleMockMixin):
14     def setup_loader_modules(self):
15         return {
16             shadow: {
17                 "__grains__": {"kernel": "FreeBSD", "os": "FreeBSD"},
18                 "__salt__": {"cmd.has_exec": MagicMock(return_value=True)},
19             }
20         }
21     def test_del_password(self):
22         """
23         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
24             with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
25                 shadow.del_password(</b></font>"root")
26         usermod_mock.assert_called_once_with(
27             "pw user mod root -w none", output_loglevel="quiet", python_shell=False
28         )
29     def test_gen_password(self):
30         """
31         Test shadow.gen_password
32         """
33         self.assertEqual(
34             "$6$salt$wZU8LXJfJJqoagopbB7RuK6JEotEMZ0CQDy0phpPAuLMYQFcmf6L6BdAbs/Q7w7o1qsZ9pFqFVY4yuUSWgaYt1",
35             shadow.gen_password("x", crypt_salt="salt", algorithm="sha512"),
36         )
37         self.assertEqual(
38             "$5$salt$eC8iHMk0B/acxRGi4idWiCK/.xXHLUsxovn4V591t3.",
39             shadow.gen_password("x", crypt_salt="salt", algorithm="sha256"),
40         )
41     def test_info(self):
42         """
43         Test shadow.info
44         """
45         mock = MagicMock(return_value="root:*:0:0::42:69:Charlie &amp;:/root:/bin/sh")
46         with patch.dict(shadow.__salt__, {"cmd.run_stdout": mock}):
47             info = shadow.info("root")
48         self.assertEqual("root", info["name"])
49         self.assertEqual(42, info["change"])
50         self.assertEqual(69, info["expire"])
51         self.assertTrue(
52             info["passwd"] == "*"  # if the test is not running as root
53             or re.match(r"^\$[0-9]\$", info["passwd"])  # modular format
54             or re.match(r"^_", info["passwd"])  # DES Extended format
55             or info["passwd"] == ""  # No password
56             or re.match(r"^\*LOCKED\*", info["passwd"])  # Locked account
57         )
58     def test_set_change(self):
59         """
60         Test shadow.set_change
61         """
62         info_mock = MagicMock(return_value="root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh")
63         usermod_mock = MagicMock(return_value=0)
64         with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
65             with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
66                 shadow.set_change("root", 42)
67         usermod_mock.assert_called_once_with(
68             ["pw", "user", "mod", "root", "-f", 42], python_shell=False
69         )
70     def test_set_expire(self):
71         """
72         Test shadow.set_expire
73         """
74         info_mock = MagicMock(return_value="root:*:0:0::0:0:Charlie &amp;:/root:/bin/sh")
75         usermod_mock = MagicMock(return_value=0)
76         with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
77             with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
78                 shadow.set_expire("root", 42)
79         usermod_mock.assert_called_once_with(
80             ["pw", "user", "mod", "root", "-e", 42], python_shell=False
81         )
82     def test_set_password(self):
83         """
84         Test shadow.set_password
85         """
86         PASSWORD = "$6$1jReqE6eU.b.fl0X$lzsxgaP6kgPyW0kxeDhAn0ySH08gn5A3At0NDHRFUSkk/6s4hCgE9OTpSsNs1Vcvws3zN0lEXkxCYeZoTVY4A1"
87         info_mock = MagicMock(return_value="root:%s:0:0::0:0:Charlie &amp;:/root:/bin/sh")
88         usermod_mock = MagicMock(return_value=0)
89         with patch.dict(shadow.__salt__, {"cmd.run_stdout": info_mock}):
90             with patch.dict(shadow.__salt__, {"cmd.run": usermod_mock}):
91                 shadow.set_password("root", PASSWORD)
92         usermod_mock.assert_called_once_with(
93             ["pw", "user", "mod", "root", "-H", "0"],
94             stdin=PASSWORD,
95             output_loglevel="quiet",
96             python_shell=False,
97         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2     :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
3 """
4 import os
5 import tempfile
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.saltmod as saltmod
10 import salt.utils.event
11 import salt.utils.jid
12 from tests.support.mixins import LoaderModuleMockMixin
13 from tests.support.mock import MagicMock, patch
14 from tests.support.runtests import RUNTIME_VARS
15 from tests.support.unit import TestCase
16 class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
17     """
18     Test cases for salt.states.saltmod
19     """
20     def setup_loader_modules(self):
21         utils = salt.loader.utils(
22             salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=["state"]
23         )
24         return {
25             saltmod: {
26                 "__env__": "base",
27                 "__opts__": {
28                     "__role": "master",
29                     "file_client": "remote",
30                     "sock_dir": tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
31                     "transport": "tcp",
32                 },
33                 "__salt__": {"saltutil.cmd": MagicMock()},
34                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
35                 "__utils__": utils,
36             }
37         }
38     @pytest.mark.slow_test
39     def test_state(self):
40         """
41         Test to invoke a state run on a given target
42         """
43         name = "state"
44         tgt = "minion1"
45         comt = "Passed invalid value for 'allow_fail', must be an int"
46         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
47         test_ret = {
48             "name": name,
49             "changes": {},
50             "result": True,
51             "comment": "States ran successfully.",
52         }
53         test_batch_return = {
54             "minion1": {
55                 "ret": {
56                     "test_|-notify_me_|-this is a name_|-show_notification": {
57                         "comment": "Notify me",
58                         "name": "this is a name",
59                         "start_time": "10:43:41.487565",
60                         "result": True,
61                         "duration": 0.35,
62                         "__run_num__": 0,
63                         "__sls__": "demo",
64                         "changes": {},
65                         "__id__": "notify_me",
66                     },
67                     "retcode": 0,
68                 },
69                 "out": "highstate",
70             },
71             "minion2": {
72                 "ret": {
73                     "test_|-notify_me_|-this is a name_|-show_notification": {
74                         "comment": "Notify me",
75                         "name": "this is a name",
76                         "start_time": "10:43:41.487565",
77                         "result": True,
78                         "duration": 0.35,
79                         "__run_num__": 0,
80                         "__sls__": "demo",
81                         "changes": {},
82                         "__id__": "notify_me",
83                     },
84                     "retcode": 0,
85                 },
86                 "out": "highstate",
87             },
88             "minion3": {
89                 "ret": {
90                     "test_|-notify_me_|-this is a name_|-show_notification": {
91                         "comment": "Notify me",
92                         "name": "this is a name",
93                         "start_time": "10:43:41.487565",
94                         "result": True,
95                         "duration": 0.35,
96                         "__run_num__": 0,
97                         "__sls__": "demo",
98                         "changes": {},
99                         "__id__": "notify_me",
100                     },
101                     "retcode": 0,
102                 },
103                 "out": "highstate",
104             },
105         }
106         self.assertDictEqual(saltmod.state(name, tgt, allow_fail="a"), ret)
107         comt = "No highstate or sls specified, no execution made"
108         ret.update({"comment": comt})
109         self.assertDictEqual(saltmod.state(name, tgt), ret)
110         comt = "Must pass in boolean for value of 'concurrent'"
111         ret.update({"comment": comt})
112         self.assertDictEqual(
113             saltmod.state(name, tgt, highstate=True, concurrent="a"), ret
114         )
115         ret.update({"comment": comt, "result": None})
116         with patch.dict(saltmod.__opts__, {"test": True}):
117             self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)
118         ret.update(
119             {
120                 "comment": "States ran successfully. No changes made to silver.",
121                 "result": True,
122                 "__jid__": "20170406104341210934",
123             }
124         )
125         with patch.dict(saltmod.__opts__, {"test": False}):
126             mock = MagicMock(
127                 return_value={
128                     "silver": {
129                         "jid": "20170406104341210934",
130                         "retcode": 0,
131                         "ret": {
132                             "test_|-notify_me_|-this is a name_|-show_notification": {
133                                 "comment": "Notify me",
134                                 "name": "this is a name",
135                                 "start_time": "10:43:41.487565",
136                                 "result": True,
137                                 "duration": 0.35,
138                                 "__run_num__": 0,
139                                 "__sls__": "demo",
140                                 "changes": {},
141                                 "__id__": "notify_me",
142                             }
143                         },
144                         "out": "highstate",
145                     }
146                 }
147             )
148             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock}):
149                 self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)
150         ret.update(
151             {
152                 "comment": (
153                     "States ran successfully. No changes made to minion1, minion3,"
154                     " minion2."
155                 )
156             }
157         )
158         del ret["__jid__"]
159         with patch.dict(saltmod.__opts__, {"test": False}):
160             with patch.dict(
161                 saltmod.__salt__,
162                 {"saltutil.cmd": MagicMock(return_value=test_batch_return)},
163             ):
164                 state_run = saltmod.state(name, tgt, highstate=True)
165                 comment = state_run.pop("comment")
166                 ret.pop("comment")
167                 self.assertDictEqual(state_run, ret)
168                 self.assertIn("States ran successfully. No changes made to", comment)
169                 for minion in ["minion1", "minion2", "minion3"]:
170                     self.assertIn(minion, comment)
171     @pytest.mark.slow_test
172     def test_function(self):
173         """
174         Test to execute a single module function on a remote
175         minion via salt or salt-ssh
176         """
177         name = "state"
178         tgt = "larry"
179         ret = {
180             "name": name,
181             "changes": {},
182             "result": None,
183             "comment": "Function state would be executed on target {}".format(tgt),
184         }
185         with patch.dict(saltmod.__opts__, {"test": True}):
186             self.assertDictEqual(saltmod.function(name, tgt), ret)
187         ret.update(
188             {
189                 "result": True,
190                 "changes": {"ret": {tgt: ""}},
191                 "comment": (
192                     "Function ran successfully. Function state ran on {}.".format(tgt)
193                 ),
194             }
195         )
196         with patch.dict(saltmod.__opts__, {"test": False}):
197             mock_ret = {"larry": {"ret": "", "retcode": 0, "failed": False}}
198             mock_cmd = MagicMock(return_value=mock_ret)
199             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
200                 self.assertDictEqual(saltmod.function(name, tgt), ret)
201     @pytest.mark.slow_test
202     def test_function_when_no_minions_match(self):
203         """
204         Test to execute a single module function on a remote
205         minion via salt or salt-ssh
206         """
207         name = "state"
208         tgt = "larry"
209         mock_ret = {}
210         mock_cmd = MagicMock(return_value=mock_ret)
211         ret = {
212             "name": name,
213             "changes": {},
214             "result": False,
215         }
216         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with patch.dict(saltmod.__opts__, {"test": False}):
217             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
218                 self.assertDictEqual(</b></font>saltmod.function(name, tgt), ret)
219     def test_wait_for_event(self):
220         """
221         Test to watch Salt's event bus and block until a condition is met
222         """
223         name = "state"
224         tgt = "minion1"
225         comt = "Timeout value reached."
226         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
227         class Mockevent:
228             """
229             Mock event class
230             """
231             flag = None
232             def __init__(self):
233                 self.full = None
234             def get_event(self, full):
235                 """
236                 Mock get_event method
237                 """
238                 self.full = full
239                 if self.flag:
240                     return {"tag": name, "data": {}}
241                 return None
242             def __enter__(self):
243                 return self
244             def __exit__(self, *args):
245                 pass
246         with patch.object(
247             salt.utils.event, "get_event", MagicMock(return_value=Mockevent())
248         ):
249             with patch.dict(saltmod.__opts__, {"sock_dir": True, "transport": True}):
250                 with patch(
251                     "salt.states.saltmod.time.time", MagicMock(return_value=1.0)
252                 ):
253                     self.assertDictEqual(
254                         saltmod.wait_for_event(name, "salt", timeout=-1.0), ret
255                     )
256                     Mockevent.flag = True
257                     ret.update(
258                         {"comment": "All events seen in 0.0 seconds.", "result": True}
259                     )
260                     self.assertDictEqual(saltmod.wait_for_event(name, ""), ret)
261                     ret.update({"comment": "Timeout value reached.", "result": False})
262                     self.assertDictEqual(
263                         saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
264                     )
265     def test_runner(self):
266         """
267         Test to execute a runner module on the master
268         """
269         name = "state"
270         ret = {
271             "changes": {"return": True},
272             "name": "state",
273             "result": True,
274             "comment": "Runner function 'state' executed.",
275             "__orchestration__": True,
276         }
277         runner_mock = MagicMock(return_value={"return": True})
278         with patch.dict(saltmod.__salt__, {"saltutil.runner": runner_mock}):
279             self.assertDictEqual(saltmod.runner(name), ret)
280     def test_wheel(self):
281         """
282         Test to execute a wheel module on the master
283         """
284         name = "state"
285         ret = {
286             "changes": {"return": True},
287             "name": "state",
288             "result": True,
289             "comment": "Wheel function 'state' executed.",
290             "__orchestration__": True,
291         }
292         wheel_mock = MagicMock(return_value={"return": True})
293         with patch.dict(saltmod.__salt__, {"saltutil.wheel": wheel_mock}):
294             self.assertDictEqual(saltmod.wheel(name), ret)
295     @pytest.mark.slow_test
296     def test_state_ssh(self):
297         """
298         Test saltmod state passes roster to saltutil.cmd
299         """
300         origcmd = saltmod.__salt__["saltutil.cmd"]
301         cmd_kwargs = {}
302         cmd_args = []
303         def cmd_mock(*args, **kwargs):
304             cmd_args.extend(args)
305             cmd_kwargs.update(kwargs)
306             return origcmd(*args, **kwargs)
307         with patch.dict(saltmod.__salt__, {"saltutil.cmd": cmd_mock}):
308             ret = saltmod.state(
309                 "state.sls", tgt="*", ssh=True, highstate=True, roster="my_roster"
310             )
311         assert "roster" in cmd_kwargs
312         assert cmd_kwargs["roster"] == "my_roster"
313     @pytest.mark.slow_test
314     def test_function_ssh(self):
315         """
316         Test saltmod function passes roster to saltutil.cmd
317         """
318         origcmd = saltmod.__salt__["saltutil.cmd"]
319         cmd_kwargs = {}
320         cmd_args = []
321         def cmd_mock(*args, **kwargs):
322             cmd_args.extend(args)
323             cmd_kwargs.update(kwargs)
324             return origcmd(*args, **kwargs)
325         with patch.dict(saltmod.__opts__, {"test": False}), patch.dict(
326             saltmod.__salt__, {"saltutil.cmd": cmd_mock}
327         ):
328             saltmod.function("state", tgt="*", ssh=True, roster="my_roster")
329         assert "roster" in cmd_kwargs
330         assert cmd_kwargs["roster"] == "my_roster"
331 class StatemodTests(TestCase, LoaderModuleMockMixin):
332     def setup_loader_modules(self):
333         self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
334         return {
335             saltmod: {
336                 "__env__": "base",
337                 "__opts__": {
338                     "id": "webserver2",
339                     "argv": [],
340                     "__role": "master",
341                     "cachedir": self.tmp_cachedir,
342                     "extension_modules": os.path.join(self.tmp_cachedir, "extmods"),
343                 },
344                 "__salt__": {"saltutil.cmd": MagicMock()},
345                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
346             }
347         }
348     def test_statemod_state(self):
349         """Smoke test for for salt.states.statemod.state().  Ensures that we
350         don't take an exception if optional parameters are not specified in
351         __opts__ or __env__.
352         """
353         args = ("webserver_setup", "webserver2")
354         kwargs = {
355             "tgt_type": "glob",
356             "fail_minions": None,
357             "pillar": None,
358             "top": None,
359             "batch": None,
360             "orchestration_jid": None,
361             "sls": "vroom",
362             "queue": False,
363             "concurrent": False,
364             "highstate": None,
365             "expr_form": None,
366             "ret": "",
367             "ssh": False,
368             "timeout": None,
369             "test": False,
370             "allow_fail": 0,
371             "saltenv": None,
372             "expect_minions": False,
373         }
374         ret = saltmod.state(*args, **kwargs)
375         expected = {
376             "comment": "States ran successfully.",
377             "changes": {},
378             "name": "webserver_setup",
379             "result": True,
380         }
381         self.assertEqual(ret, expected)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
