<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_iam_role.py &amp; boto_rds_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_iam_role.py &amp; boto_rds_1.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_iam_role.py (3.716814%)<th>boto_rds_1.py (2.902557%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(363-376)<td><a href="#" name="0">(755-766)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(104-182)<td><a href="#" name="1">(225-247)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(432-440)<td><a href="#" name="2">(814-826)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam_role.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.dictdiffer
3 import salt.utils.dictupdate as dictupdate
4 from salt.utils.odict import OrderedDict
5 log = logging.getLogger(__name__)
6 def __virtual__():
7     """
8     return (F<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>alse, "boto_iam module could not be loaded")
9 def present(
10     name,
11     policy_document=None,
12     policy_document_from_pillars=None,
13     path=None,
14     policies=None,
15     policies_from_pillars=None,
16     managed_policies=None,
17     create_instance_profile=True,
18     region=None,
19     key=None,
20     keyid=None,
21     profile=None,
22     delete_policies=True,
23 ):
24     """
25     Ensure the IAM role exists.
26     name
27         Name of the IAM role.
28     policy_document
29         The policy that grants an entity permission to assume the role.
30         (See https://boto.readthedocs.io/en/latest/ref/iam.html#boto.iam.connection.IAMConnection.create_role)
31     policy_document_from_pillars
32         A pillar key that contains a role policy document. The statements
33         defined here will be appended with the policy document statements
34         defined in the policy_document argument.
35         .. versionadded:: 2017.7.0
36     path
37         The path to the role/instance profile.
38         (See https://boto.readthedocs.io/en/latest/ref/iam.html#boto.iam.connection.IAMConnection.create_role)
39     policies
40         A dict of IAM role policies.
41     policies_from_pillars
42         A list of pillars that contain role policy dicts. Policies in the
43         pillars will be merged in the order defined in the list and key
44         conflicts will be handled by later defined keys overriding earlier
45         defined keys. The policies defined here will be merged with the
46         policies defined in the policies argument. If keys conflict, the keys
47         in the policies argument will override the keys defined in
48         policies_from_pillars.
49     managed_policies
50         A list of (AWS or Customer) managed policies to be attached to the role.
51     create_instance_profile
52         A boolean of whether or not to create an instance profile and associate
53         it with this role.
54     region
55         Region to connect to.
56     key
57         Secret key to be used.
58     keyid
59         Access key to be used.
60     profile
61         A dict with region, key and keyid, or a pillar key (string)
62         that contains a dict with region, key and keyid.
63     delete_policies
64         Deletes existing policies that are not in the given list of policies. Default
65         value is ``True``. If ``False`` is specified, existing policies will not be deleted
66         allowing manual modifications on the IAM role to be persistent.
67         .. versionadded:: 2015.8.0
68     """
69     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
70     _policy_document = {}
71     if policy_document_from_pillars:
72         from_pillars = __salt__["pillar.get"](policy_document_from_pillars)
73         if from_pillars:
74             _policy_document["Version"] = from_pillars["Version"]
75             _policy_document.setdefault("Statement", [])
76             _policy_document["Statement"].extend(from_pillars["Statement"])
77     if policy_document:
78         _policy_document["Version"] = policy_document["Version"]
79         _policy_document.setdefault("Statement", [])
80         _policy_document["Statement"].extend(policy_document["Statement"])
81     _ret = _role_present(name, _policy_document, path, region, key, keyid, profile)
82     if not policies:
83         policies = {}
84     if not policies_from_pillars:
85         policies_from_pillars = []
86     if not managed_policies:
87         managed_policies = []
88     _policies = {}
89     for policy in policies_from_pillars:
90         _policy = __salt__["pillar.get"](policy)
91         _policies.update(_policy)
92     _policies.update(policies)
93     ret["changes"] = _ret["changes"]
94     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
95     if not _ret["result"]:
96         ret["result"] = _ret["result"]
97         if ret["result"] is False:
98             return ret
99     if create_instance_profile:
100         _ret = _instance_profile_present(name, region, key, keyid, profile)
101         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
102         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
103         if not _ret["result"]:
104             ret["result"] = _ret["result"]
105             if ret["result"] is False:
106                 return ret
107         _ret = _instance_profile_associated(name, region, key, keyid, profile)
108         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
109         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
110         if not _ret["result"]:
111             ret["result"] = _ret["result"]
112             if ret["result"] is False:
113                 return ret
114     _ret = _policies_present(
115         name, _policies, region, key, keyid, profile, delete_policies
116     )
117     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
118     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
119     if not _ret["result"]:
120         ret["result"] = _ret["result"]
121     _ret = _policies_attached(name, managed_policies, region, key, keyid, profile)
122     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
123     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
124     if not _ret["result"]:
125         ret["result"] = _ret["result"]
126     return ret
127 def _role_present(
128     name,
129     policy_document=None,
130     path=None,
131     region=None,
132     key=None,
133     keyid=None,
134     profile=None,
135 ):
136     ret = {"result": True, "comment": "", "changes": {}}
137     role = __salt__["boto_iam.describe_role"](name, region, key, keyid, profile)
138     if not role:
139         if __opts__["test"]:
140             ret["comment"] = "IAM role {} is set to be created.".format(name)
141             ret["result"] = None
142             return ret
143         created = __salt__["boto_iam.create_role"](
144             name, policy_document, path, region, key, keyid, profile
145         )
146         if created:
147             ret["changes"]["old"] = {"role": None}
148             ret["changes"]["new"] = {"role": name}
149             ret["comment"] = "IAM role {} created.".format(name)
150         else:
151             ret["result"] = False
152             ret["comment"] = "Failed to create {} IAM role.".format(name)
153     else:
154         ret["comment"] = "{} role present.".format(name)
155         if not policy_document:
156             _policy_document = __salt__["boto_iam.build_policy"](
157                 region, key, keyid, profile
158             )
159         else:
160             _policy_document = policy_document
161         if salt.utils.dictdiffer.deep_diff(
162             _sort_policy(role["assume_role_policy_document"]),
163             _sort_policy(_policy_document),
164         ):
165             if __opts__["test"]:
166                 msg = "Assume role policy document to be updated."
167                 ret["comment"] = "{} {}".format(ret["comment"], msg)
168                 ret["result"] = None
169                 return ret
170             updated = __salt__["boto_iam.update_assume_role_policy"](
171                 name, _policy_document, region, key, keyid, profile
172             )
173             if updated:
174                 msg = "Assume role policy document updated."
175                 ret["comment"] = "{} {}".format(ret["comment"], msg)
176                 ret["changes"]["old"] = {
177                     "policy_document": role["assume_role_policy_document"]
178                 }
179                 ret["changes"]["new"] = {"policy_document": _policy_document}
180             else:
181                 ret["result"] = False
182                 msg = "Failed to update assume role policy."
183                 ret["comment"] = "{} {}".format(ret["comment"], msg)
184     return ret
185 def _instance_profile_present(name, region=None, key=None, keyid=None, profile=None):
186     ret = {"result": True, "comment": "", "changes": {}}
187     exists = __salt__["boto_iam.instance_profile_exists"](
188         name, region, key, keyid, profile
189     )
190     if not exists:
191         if __opts__["test"]:
192             ret["comment"] = "Instance profile {} is set to be created.".format(name)
193             ret["result"] = None
194             return ret
195         created = __salt__["boto_iam.create_instance_profile"](
196             name, region, key, keyid, profile
197         )
198         if created:
199             ret["changes"]["old"] = {"instance_profile": None}
200             ret["changes"]["new"] = {"instance_profile": name}
201             ret["comment"] = "Instance profile {} created.".format(name)
202         else:
203             ret["result"] = False
204             ret["comment"] = "Failed to create {} instance profile.".format(name)
205     return ret
206 def _instance_profile_associated(name, region=None, key=None, keyid=None, profile=None):
207     ret = {"result": True, "comment": "", "changes": {}}
208     is_associated = __salt__["boto_iam.profile_associated"](
209         name, name, region, key, keyid, profile
210     )
211     if not is_associated:
212         if __opts__["test"]:
213             ret["comment"] = "Instance profile {} is set to be associated.".format(name)
214             ret["result"] = None
215             return ret
216         associated = __salt__["boto_iam.associate_profile_to_role"](
217             name, name, region, key, keyid, profile
218         )
219         if associated:
220             ret["changes"]["old"] = {"profile_associated": None}
221             ret["changes"]["new"] = {"profile_associated": True}
222             ret["comment"] = "Instance profile {} associated.".format(name)
223         else:
224             ret["result"] = False
225             ret[
226                 "comment"
227             ] = "Failed to associate {0} instance profile with {0} role.".format(name)
228     return ret
229 def _sort_policy(doc):
230     """
231     List-type sub-items in policies don't happen to be order-sensitive, but
232     compare operations will render them unequal, leading to non-idempotent
233     state runs.  We'll sort any list-type subitems before comparison to reduce
234     the likelihood of false negatives.
235     """
236         return sorted(_sort_policy(i) for i in doc)
237     elif isinstance(doc, (dict, OrderedDict)):
238         return {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>k: _sort_policy(v) for k, v in doc.items()}
239     return doc
240 def _policies_present(
241     name,
242     policies=None,
243     region=None,
244     key=None,
245     keyid=None,
246     profile=None,
247     delete_policies=True,
248 ):
249     ret =</b></font> {"result": True, "comment": "", "changes": {}}
250     policies_to_create = {}
251     policies_to_delete = []
252     for policy_name, policy in policies.items():
253         _policy = __salt__["boto_iam.get_role_policy"](
254             name, policy_name, region, key, keyid, profile
255         )
256         if _policy != policy:
257             policies_to_create[policy_name] = policy
258     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
259     for policy_name in _list:
260         if delete_policies and policy_name not in policies:
261             policies_to_delete.append(policy_name)
262     if policies_to_create or policies_to_delete:
263         _to_modify = list(policies_to_delete)
264         _to_modify.extend(policies_to_create)
265         if __opts__["test"]:
266             ret["comment"] = "{} policies to be modified on role {}.".format(
267                 ", ".join(_to_modify), name
268             )
269             ret["result"] = None
270             return ret
271         ret["changes"]["old"] = {"policies": _list}
272         for policy_name, policy in policies_to_create.items():
273             policy_set = __salt__["boto_iam.create_role_policy"](
274                 name, policy_name, policy, region, key, keyid, profile
275             )
276             if not policy_set:
277                 _list = __salt__["boto_iam.list_role_policies"](
278                     name, region, key, keyid, profile
279                 )
280                 ret["changes"]["new"] = {"policies": _list}
281                 ret["result"] = False
282                 ret["comment"] = "Failed to add policy {} to role {}".format(
283                     policy_name, name
284                 )
285                 return ret
286         for policy_name in policies_to_delete:
287             policy_unset = __salt__["boto_iam.delete_role_policy"](
288                 name, policy_name, region, key, keyid, profile
289             )
290             if not policy_unset:
291                 _list = __salt__["boto_iam.list_role_policies"](
292                     name, region, key, keyid, profile
293                 )
294                 ret["changes"]["new"] = {"policies": _list}
295                 ret["result"] = False
296                 ret["comment"] = "Failed to remove policy {} from role {}".format(
297                     policy_name, name
298                 )
299                 return ret
300         _list = __salt__["boto_iam.list_role_policies"](
301             name, region, key, keyid, profile
302         ret["changes"]["new"] = {"policies": _list}
303         ret["comment"] = "{} policies modified on role {}.".format(
304             ", "<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(_list), name
305         )
306     return ret
307 def _policies_attached(
308     name, managed_policies=None, region=None, key=None, keyid=None, profile=None
309 ):
310     ret =</b></font> {"result": True, "comment": "", "changes": {}}
311     policies_to_attach = []
312     policies_to_detach = []
313     for policy in managed_policies or []:
314         entities = __salt__["boto_iam.list_entities_for_policy"](
315             policy,
316             entity_filter="Role",
317             region=region,
318             key=key,
319             keyid=keyid,
320             profile=profile,
321         )
322         found = False
323         for roledict in entities.get("policy_roles", []):
324             if name == roledict.get("role_name"):
325                 found = True
326                 break
327         if not found:
328             policies_to_attach.append(policy)
329     _list = __salt__["boto_iam.list_attached_role_policies"](
330         name, region=region, key=key, keyid=keyid, profile=profile
331     )
332     oldpolicies = [x.get("policy_arn") for x in _list]
333     for policy_data in _list:
334         if (
335             policy_data.get("policy_name") not in managed_policies
336             and policy_data.get("policy_arn") not in managed_policies
337         ):
338             policies_to_detach.append(policy_data.get("policy_arn"))
339     if policies_to_attach or policies_to_detach:
340         _to_modify = list(policies_to_detach)
341         _to_modify.extend(policies_to_attach)
342         if __opts__["test"]:
343             ret["comment"] = "{} policies to be modified on role {}.".format(
344                 ", ".join(_to_modify), name
345             )
346             ret["result"] = None
347             return ret
348         ret["changes"]["old"] = {"managed_policies": oldpolicies}
349         for policy_name in policies_to_attach:
350             policy_set = __salt__["boto_iam.attach_role_policy"](
351                 policy_name,
352                 role_name=name,
353                 region=region,
354                 key=key,
355                 keyid=keyid,
356                 profile=profile,
357             )
358             if not policy_set:
359                 _list = __salt__["boto_iam.list_attached_role_policies"](
360                     name, region=region, key=key, keyid=keyid, profile=profile
361                 )
362                 newpolicies = [x.get("policy_arn") for x in _list]
363                 ret["changes"]["new"] = {"managed_policies": newpolicies}
364                 ret["result"] = False
365                 ret["comment"] = "Failed to add policy {} to role {}".format(
366                     policy_name, name
367                 )
368                 return ret
369         for policy_name in policies_to_detach:
370             policy_unset = __salt__["boto_iam.detach_role_policy"](
371                 policy_name,
372                 role_name=name,
373                 region=region,
374                 key=key,
375                 keyid=keyid,
376                 profile=profile,
377             )
378             if not policy_unset:
379                 _list = __salt__["boto_iam.list_attached_role_policies"](
380                     name, region=region, key=key, keyid=keyid, profile=profile
381                 )
382                 newpolicies = [x.get("policy_arn") for x in _list]
383                 ret["changes"]["new"] = {"managed_policies": newpolicies}
384                 ret["result"] = False
385                 ret["comment"] = "Failed to remove policy {} from role {}".format(
386                     policy_name, name
387                 )
388                 return ret
389         _list = __salt__["boto_iam.list_attached_role_policies"](
390             name, region=region, key=key, keyid=keyid, profile=profile
391         )
392         newpolicies = [x.get("policy_arn") for x in _list]
393         log.debug(newpolicies)
394         ret["changes"]["new"] = {"managed_policies": newpolicies}
395         ret["comment"] = "{} policies modified on role {}.".format(
396             ", ".join(newpolicies), name
397         )
398     return ret
399 def absent(name, region=None, key=None, keyid=None, profile=None):
400     """
401     Ensure the IAM role is deleted.
402     name
403         Name of the IAM role.
404     region
405         Region to connect to.
406     key
407         Secret key to be used.
408     keyid
409         Access key to be used.
410     profile
411         A dict with region, key and keyid, or a pillar key (string)
412         that contains a dict with region, key and keyid.
413     """
414     ret = {"name": name, "result": True, "comment": "", "changes": {}}
415     _ret = _policies_absent(name, region, key, keyid, profile)
416     ret["changes"] = _ret["changes"]
417     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
418     if not _ret["result"]:
419         ret["result"] = _ret["result"]
420         if ret["result"] is False:
421             return ret
422     _ret = _policies_detached(name, region, key, keyid, profile)
423     ret["changes"] = _ret["changes"]
424     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
425     if not _ret["result"]:
426         ret["result"] = _ret["result"]
427         if ret["result"] is False:
428             return ret
429     _ret = _instance_profile_disassociated(name, region, key, keyid, profile)
430     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
431     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
432     if not _ret["result"]:
433         ret["result"] = _ret["result"]
434         if ret["result"] is False:
435             return ret
436     _ret = _instance_profile_absent(name, region, key, keyid, profile)
437     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
438     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
439     if not _ret["result"]:
440         ret["result"] = _ret["result"]
441         if ret["result"] is False:
442             return ret
443     _ret = _role_absent(name, region, key, keyid, profile)
444     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
445     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
446     if not _ret["result"]:
447         ret["result"] = _ret["result"]
448     return ret
449 def _role_absent(name, region=None, key=None, keyid=None, profile=None):
450     ret = {"result": True, "comment": "", "changes": {}}
451     exists = __salt__["boto_iam.role_exists"](name, region, key, keyid, profile)
452     if exists:
453         if __opts__["test"]:
454             ret["comment"] = "IAM role {} is set to be removed.".format(name)
455             ret["result"] = None
456             return ret
457         deleted = __salt__["boto_iam.delete_role"](name, region, key, keyid, profile)
458         if deleted:
459             ret["changes"]["old"] = {"role": name}
460             ret["changes"]["new"] = {"role": None}
461             ret["comment"] = "IAM role {} removed.".format(name)
462         else:
463             ret["result"] = False
464             ret["comment"] = "Failed to delete {} iam role.".format(name)
465     else:
466         ret["comment"] = "{} role does not exist.".format(name)
467     return ret
468 def _instance_profile_absent(name, region=None, key=None, keyid=None, profile=None):
469     ret = {"result": True, "comment": "", "changes": {}}
470     exists = __salt__["boto_iam.instance_profile_exists"](
471         name, region, key, keyid, profile
472     )
473     if exists:
474         if __opts__["test"]:
475             ret["comment"] = "Instance profile {} is set to be removed.".format(name)
476             ret["result"] = None
477             return ret
478         deleted = __salt__["boto_iam.delete_instance_profile"](
479             name, region, key, keyid, profile
480         )
481         if deleted:
482             ret["changes"]["old"] = {"instance_profile": name}
483             ret["changes"]["new"] = {"instance_profile": None}
484             ret["comment"] = "Instance profile {} removed.".format(name)
485         else:
486             ret["result"] = False
487             ret["comment"] = "Failed to delete {} instance profile.".format(name)
488     else:
489         ret["comment"] = "{} instance profile does not exist.".format(name)
490     return ret
491 def _policies_absent(name, region=None, key=None, keyid=None, profile=None):
492     ret = {"result": True, "comment": "", "changes": {}}
493     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
494     if not _list:
495         ret["comment"] = "No policies in role {}.".format(name)
496         return ret
497     if __opts__["test"]:
498         ret["comment"] = "{} policies to be removed from role {}.".format(
499             ", ".join(_list), name
500         )
501         ret["result"] = None
502         return ret
503     ret["changes"]["old"] = {"policies": _list}
504     for policy_name in _list:
505         policy_unset = __salt__["boto_iam.delete_role_policy"](
506             name, policy_name, region, key, keyid, profile
507         )
508         if not policy_unset:
509             _list = __salt__["boto_iam.list_role_policies"](
510                 name, region, key, keyid, profile
511             )
512             ret["changes"]["new"] = {"policies": _list}
513             ret["result"] = False
514             ret["comment"] = "Failed to add policy {} to role {}".format(
515                 policy_name, name
516             )
517             return ret
518     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
519     ret["changes"]["new"] = {"policies": _list}
520     ret["comment"] = "{} policies removed from role {}.".format(", ".join(_list), name)
521     return ret
522 def _policies_detached(name, region=None, key=None, keyid=None, profile=None):
523     ret = {"result": True, "comment": "", "changes": {}}
524     _list = __salt__["boto_iam.list_attached_role_policies"](
525         role_name=name, region=region, key=key, keyid=keyid, profile=profile
526     )
527     oldpolicies = [x.get("policy_arn") for x in _list]
528     if not _list:
529         ret["comment"] = "No attached policies in role {}.".format(name)
530         return ret
531     if __opts__["test"]:
532         ret["comment"] = "{} policies to be detached from role {}.".format(
533             ", ".join(oldpolicies), name
534         )
535         ret["result"] = None
536         return ret
537     ret["changes"]["old"] = {"managed_policies": oldpolicies}
538     for policy_arn in oldpolicies:
539         policy_unset = __salt__["boto_iam.detach_role_policy"](
540             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
541         )
542         if not policy_unset:
543             _list = __salt__["boto_iam.list_attached_role_policies"](
544                 name, region=region, key=key, keyid=keyid, profile=profile
545             )
546             newpolicies = [x.get("policy_arn") for x in _list]
547             ret["changes"]["new"] = {"managed_policies": newpolicies}
548             ret["result"] = False
549             ret["comment"] = "Failed to detach {} from role {}".format(policy_arn, name)
550             return ret
551     _list = __salt__["boto_iam.list_attached_role_policies"](
552         name, region=region, key=key, keyid=keyid, profile=profile
553     )
554     newpolicies = [x.get("policy_arn") for x in _list]
555     ret["changes"]["new"] = {"managed_policies": newpolicies}
556     ret["comment"] = "{} policies detached from role {}.".format(
557         ", ".join(newpolicies), name
558     )
559     return ret
560 def _instance_profile_disassociated(
561     name, region=None, key=None, keyid=None, profile=None
562 ):
563     ret = {"result": True, "comment": "", "changes": {}}
564     is_associated = __salt__["boto_iam.profile_associated"](
565         name, name, region, key, keyid, profile
566     )
567     if is_associated:
568         if __opts__["test"]:
569             ret["comment"] = "Instance profile {} is set to be disassociated.".format(
570                 name
571             )
572             ret["result"] = None
573             return ret
574         associated = __salt__["boto_iam.disassociate_profile_from_role"](
575             name, name, region, key, keyid, profile
576         )
577         if associated:
578             ret["changes"]["old"] = {"profile_associated": True}
579             ret["changes"]["new"] = {"profile_associated": False}
580             ret["comment"] = "Instance profile {} disassociated.".format(name)
581         else:
582             ret["result"] = False
583             ret[
584                 "comment"
585             ] = "Failed to disassociate {0} instance profile from {0} role.".format(
586                 name
587             )
588     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_rds_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Connection module for Amazon RDS
3 .. versionadded:: 2015.8.0
4 :configuration: This module accepts explicit rds credentials but can also
5     utilize IAM roles assigned to the instance through Instance Profiles.
6     Dynamic credentials are then automatically obtained from AWS API and no
7     further configuration is necessary. More Information available at:
8     .. code-block:: text
9         http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html
10     If IAM roles are not used you need to specify them either in a pillar or
11     in the minion's config file:
12     .. code-block:: yaml
13         rds.keyid: GKTADJGHEIQSXMKKRBJ08H
14         rds.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
15     A region may also be specified in the configuration:
16     .. code-block:: yaml
17         rds.region: us-east-1
18     If a region is not specified, the default is us-east-1.
19     It's also possible to specify key, keyid and region via a profile, either
20     as a passed in dict, or as a string to pull from pillars or minion config:
21     .. code-block:: yaml
22         myprofile:
23             keyid: GKTADJGHEIQSXMKKRBJ08H
24             key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
25             region: us-east-1
26 :depends: boto3
27 """
28 import logging
29 import time
30 import salt.utils.compat
31 import salt.utils.odict as odict
32 import salt.utils.versions
33 from salt.exceptions import SaltInvocationError
34 log = logging.getLogger(__name__)
35 try:
36     import boto
37     import boto3
38     from botocore.exceptions import ClientError
39     logging.getLogger("boto").setLevel(logging.CRITICAL)
40     logging.getLogger("boto3").setLevel(logging.CRITICAL)
41     HAS_BOTO = True
42 except ImportError:
43     HAS_BOTO = False
44 boto3_param_map = {
45     "allocated_storage": ("AllocatedStorage", int),
46     "allow_major_version_upgrade": ("AllowMajorVersionUpgrade", bool),
47     "apply_immediately": ("ApplyImmediately", bool),
48     "auto_minor_version_upgrade": ("AutoMinorVersionUpgrade", bool),
49     "availability_zone": ("AvailabilityZone", str),
50     "backup_retention_period": ("BackupRetentionPeriod", int),
51     "ca_certificate_identifier": ("CACertificateIdentifier", str),
52     "character_set_name": ("CharacterSetName", str),
53     "copy_tags_to_snapshot": ("CopyTagsToSnapshot", bool),
54     "db_cluster_identifier": ("DBClusterIdentifier", str),
55     "db_instance_class": ("DBInstanceClass", str),
56     "db_name": ("DBName", str),
57     "db_parameter_group_name": ("DBParameterGroupName", str),
58     "db_port_number": ("DBPortNumber", int),
59     "db_security_groups": ("DBSecurityGroups", list),
60     "db_subnet_group_name": ("DBSubnetGroupName", str),
61     "domain": ("Domain", str),
62     "domain_iam_role_name": ("DomainIAMRoleName", str),
63     "engine": ("Engine", str),
64     "engine_version": ("EngineVersion", str),
65     "iops": ("Iops", int),
66     "kms_key_id": ("KmsKeyId", str),
67     "license_model": ("LicenseModel", str),
68     "master_user_password": ("MasterUserPassword", str),
69     "master_username": ("MasterUsername", str),
70     "monitoring_interval": ("MonitoringInterval", int),
71     "monitoring_role_arn": ("MonitoringRoleArn", str),
72     "multi_az": ("MultiAZ", bool),
73     "name": ("DBInstanceIdentifier", str),
74     "new_db_instance_identifier": ("NewDBInstanceIdentifier", str),
75     "option_group_name": ("OptionGroupName", str),
76     "port": ("Port", int),
77     "preferred_backup_window": ("PreferredBackupWindow", str),
78     "preferred_maintenance_window": ("PreferredMaintenanceWindow", str),
79     "promotion_tier": ("PromotionTier", int),
80     "publicly_accessible": ("PubliclyAccessible", bool),
81     "storage_encrypted": ("StorageEncrypted", bool),
82     "storage_type": ("StorageType", str),
83     "tags": ("Tags", list),
84     "tde_credential_arn": ("TdeCredentialArn", str),
85     "tde_credential_password": ("TdeCredentialPassword", str),
86     "vpc_security_group_ids": ("VpcSecurityGroupIds", list),
87 }
88 def __virtual__():
89     """
90     Only load if boto libraries exist and if boto libraries are greater than
91     a given version.
92     """
93     return salt.utils.versions.check_boto_reqs(boto3_ver="1.3.1")
94 def __init__(opts):
95     if HAS_BOTO:
96         __utils__["boto3.assign_funcs"](__name__, "rds")
97 def exists(name, tags=None, region=None, key=None, keyid=None, profile=None):
98     """
99     Check to see if an RDS exists.
100     CLI Example:
101     .. code-block:: bash
102         salt myminion boto_rds.exists myrds region=us-east-1
103     """
104     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
105     try:
106         rds = conn.describe_db_instances(DBInstanceIdentifier=name)
107         return {"exists": bool(rds)}
108     except ClientError as e:
109         return {"error": __utils__["boto3.get_error"](e)}
110 def option_group_exists(
111     name, tags=None, region=None, key=None, keyid=None, profile=None
112 ):
113     """
114     Check to see if an RDS option group exists.
115     CLI Example:
116     .. code-block:: bash
117         salt myminion boto_rds.option_group_exists myoptiongr region=us-east-1
118     """
119     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
120     try:
121         rds = conn.describe_option_groups(OptionGroupName=name)
122         return {"exists": bool(rds)}
123     except ClientError as e:
124         return {"error": __utils__["boto3.get_error"](e)}
125 def parameter_group_exists(
126     name, tags=None, region=None, key=None, keyid=None, profile=None
127 ):
128     """
129     Check to see if an RDS parameter group exists.
130     CLI Example:
131     .. code-block:: bash
132         salt myminion boto_rds.parameter_group_exists myparametergroup \
133                 region=us-east-1
134     """
135     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
136     try:
137         rds = conn.describe_db_parameter_groups(DBParameterGroupName=name)
138         return {"exists": bool(rds), "error": None}
139     except ClientError as e:
140         resp = {}
141         if e.response["Error"]["Code"] == "DBParameterGroupNotFound":
142             resp["exists"] = False
143         resp["error"] = __utils__["boto3.get_error"](e)
144         return resp
145 def subnet_group_exists(
146     name, tags=None, region=None, key=None, keyid=None, profile=None
147 ):
148     """
149     Check to see if an RDS subnet group exists.
150     CLI Example:
151     .. code-block:: bash
152         salt myminion boto_rds.subnet_group_exists my-param-group \
153                 region=us-east-1
154     """
155     try:
156         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
157         if not conn:
158             return {"exists": bool(conn)}
159         rds = conn.describe_db_subnet_groups(DBSubnetGroupName=name)
160         return {"exists": bool(rds)}
161     except ClientError as e:
162             return {"exists": False}
163         else:
164             return {"error": __utils__["boto3.get_error"](e<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>)}
165 def create(
166     name,
167     allocated_storage,
168     db_instance_class,
169     engine,
170     master_username,
171     master_user_password,
172     db_name=None,
173     db_security_groups=None,
174     vpc_security_group_ids=None,
175     vpc_security_groups=None,
176     availability_zone=None,
177     db_subnet_group_name=None,
178     preferred_maintenance_window=None,
179     db_parameter_group_name=None,
180     backup_retention_period=None,
181     preferred_backup_window=None,
182     port=None,
183     multi_az=None,
184     engine_version=</b></font>None,
185     auto_minor_version_upgrade=None,
186     license_model=None,
187     iops=None,
188     option_group_name=None,
189     character_set_name=None,
190     publicly_accessible=None,
191     wait_status=None,
192     tags=None,
193     db_cluster_identifier=None,
194     storage_type=None,
195     tde_credential_arn=None,
196     tde_credential_password=None,
197     storage_encrypted=None,
198     kms_key_id=None,
199     domain=None,
200     copy_tags_to_snapshot=None,
201     monitoring_interval=None,
202     monitoring_role_arn=None,
203     domain_iam_role_name=None,
204     region=None,
205     promotion_tier=None,
206     key=None,
207     keyid=None,
208     profile=None,
209 ):
210     """
211     Create an RDS Instance
212     CLI example to create an RDS Instance::
213         salt myminion boto_rds.create myrds 10 db.t2.micro MySQL sqlusr sqlpassw
214     """
215     if not allocated_storage:
216         raise SaltInvocationError("allocated_storage is required")
217     if not db_instance_class:
218         raise SaltInvocationError("db_instance_class is required")
219     if not engine:
220         raise SaltInvocationError("engine is required")
221     if not master_username:
222         raise SaltInvocationError("master_username is required")
223     if not master_user_password:
224         raise SaltInvocationError("master_user_password is required")
225     if availability_zone and multi_az:
226         raise SaltInvocationError(
227             "availability_zone and multi_az are mutually exclusive arguments."
228         )
229     if wait_status:
230         wait_stati = ["available", "modifying", "backing-up"]
231         if wait_status not in wait_stati:
232             raise SaltInvocationError(
233                 "wait_status can be one of: {}".format(wait_stati)
234             )
235     if vpc_security_groups:
236         v_tmp = __salt__["boto_secgroup.convert_to_group_ids"](
237             groups=vpc_security_groups,
238             region=region,
239             key=key,
240             keyid=keyid,
241             profile=profile,
242         )
243         vpc_security_group_ids = (
244             vpc_security_group_ids + v_tmp if vpc_security_group_ids else v_tmp
245         )
246     try:
247         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
248         if not conn:
249             return {"results": bool(conn)}
250         kwargs = {}
251         boto_params = set(boto3_param_map.keys())
252         keys = set(locals().keys())
253         tags = _tag_doc(tags)
254         for param_key in keys.intersection(boto_params):
255             val = locals()[param_key]
256             if val is not None:
257                 mapped = boto3_param_map[param_key]
258                 kwargs[mapped[0]] = mapped[1](val)
259         kwargs = {k: v for k, v in kwargs.items() if v is not None}
260         rds = conn.create_db_instance(**kwargs)
261         if not rds:
262             return {"created": False}
263         if not wait_status:
264             return {
265                 "created": True,
266                 "message": "RDS instance {} created.".format(name),
267             }
268         while True:
269             jmespath = "DBInstances[*].DBInstanceStatus"
270             status = describe_db_instances(
271                 name=name,
272                 jmespath=jmespath,
273                 region=region,
274                 key=key,
275                 keyid=keyid,
276                 profile=profile,
277             )
278             if status:
279                 stat = status[0]
280             else:
281                 return {
282                     "created": False,
283                     "error": (
284                         "RDS instance {} should have been created but"
285                         " now I can't find it.".format(name)
286                     ),
287                 }
288             if stat == wait_status:
289                 return {
290                     "created": True,
291                     "message": "RDS instance {} created (current status {})".format(
292                         name, stat
293                     ),
294                 }
295             time.sleep(10)
296             log.info("Instance status after 10 seconds is: %s", stat)
297     except ClientError as e:
298         return {"error": __utils__["boto3.get_error"](e)}
299 def create_read_replica(
300     name,
301     source_name,
302     db_instance_class=None,
303     availability_zone=None,
304     port=None,
305     auto_minor_version_upgrade=None,
306     iops=None,
307     option_group_name=None,
308     publicly_accessible=None,
309     tags=None,
310     db_subnet_group_name=None,
311     storage_type=None,
312     copy_tags_to_snapshot=None,
313     monitoring_interval=None,
314     monitoring_role_arn=None,
315     region=None,
316     key=None,
317     keyid=None,
318     profile=None,
319 ):
320     """
321     Create an RDS read replica
322     CLI example to create an RDS  read replica::
323         salt myminion boto_rds.create_read_replica replicaname source_name
324     """
325     if not backup_retention_period:
326         raise SaltInvocationError("backup_retention_period is required")
327     res = __salt__["boto_rds.exists"](source_name, tags, region, key, keyid, profile)
328     if not res.get("exists"):
329         return {
330             "exists": bool(res),
331             "message": "RDS instance source {} does not exists.".format(source_name),
332         }
333     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
334     if res.get("exists"):
335         return {
336             "exists": bool(res),
337             "message": "RDS replica instance {} already exists.".format(name),
338         }
339     try:
340         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
341         kwargs = {}
342         for key in ("OptionGroupName", "MonitoringRoleArn"):
343             if locals()[key] is not None:
344                 kwargs[key] = str(locals()[key])
345         for key in ("MonitoringInterval", "Iops", "Port"):
346             if locals()[key] is not None:
347                 kwargs[key] = int(locals()[key])
348         for key in ("CopyTagsToSnapshot", "AutoMinorVersionUpgrade"):
349             if locals()[key] is not None:
350                 kwargs[key] = bool(locals()[key])
351         taglist = _tag_doc(tags)
352         rds_replica = conn.create_db_instance_read_replica(
353             DBInstanceIdentifier=name,
354             SourceDBInstanceIdentifier=source_name,
355             DBInstanceClass=db_instance_class,
356             AvailabilityZone=availability_zone,
357             PubliclyAccessible=publicly_accessible,
358             Tags=taglist,
359             DBSubnetGroupName=db_subnet_group_name,
360             StorageType=storage_type,
361             **kwargs
362         )
363         return {"exists": bool(rds_replica)}
364     except ClientError as e:
365         return {"error": __utils__["boto3.get_error"](e)}
366 def create_option_group(
367     name,
368     engine_name,
369     major_engine_version,
370     option_group_description,
371     tags=None,
372     region=None,
373     key=None,
374     keyid=None,
375     profile=None,
376 ):
377     """
378     Create an RDS option group
379     CLI example to create an RDS option group::
380         salt myminion boto_rds.create_option_group my-opt-group mysql 5.6 \
381                 "group description"
382     """
383     res = __salt__["boto_rds.option_group_exists"](
384         name, tags, region, key, keyid, profile
385     )
386     if res.get("exists"):
387         return {"exists": bool(res)}
388     try:
389         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
390         if not conn:
391             return {"results": bool(conn)}
392         taglist = _tag_doc(tags)
393         rds = conn.create_option_group(
394             OptionGroupName=name,
395             EngineName=engine_name,
396             MajorEngineVersion=major_engine_version,
397             OptionGroupDescription=option_group_description,
398             Tags=taglist,
399         )
400         return {"exists": bool(rds)}
401     except ClientError as e:
402         return {"error": __utils__["boto3.get_error"](e)}
403 def create_parameter_group(
404     name,
405     db_parameter_group_family,
406     description,
407     tags=None,
408     region=None,
409     key=None,
410     keyid=None,
411     profile=None,
412 ):
413     """
414     Create an RDS parameter group
415     CLI example to create an RDS parameter group::
416         salt myminion boto_rds.create_parameter_group my-param-group mysql5.6 \
417                 "group description"
418     """
419     res = __salt__["boto_rds.parameter_group_exists"](
420         name, tags, region, key, keyid, profile
421     )
422     if res.get("exists"):
423         return {"exists": bool(res)}
424     try:
425         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
426         if not conn:
427             return {"results": bool(conn)}
428         taglist = _tag_doc(tags)
429         rds = conn.create_db_parameter_group(
430             DBParameterGroupName=name,
431             DBParameterGroupFamily=db_parameter_group_family,
432             Description=description,
433             Tags=taglist,
434         )
435         if not rds:
436             return {
437                 "created": False,
438                 "message": "Failed to create RDS parameter group {}".format(name),
439             }
440         return {
441             "exists": bool(rds),
442             "message": "Created RDS parameter group {}".format(name),
443         }
444     except ClientError as e:
445         return {"error": __utils__["boto3.get_error"](e)}
446 def create_subnet_group(
447     name,
448     description,
449     subnet_ids,
450     tags=None,
451     region=None,
452     key=None,
453     keyid=None,
454     profile=None,
455 ):
456     """
457     Create an RDS subnet group
458     CLI example to create an RDS subnet group::
459         salt myminion boto_rds.create_subnet_group my-subnet-group \
460             "group description" '[subnet-12345678, subnet-87654321]' \
461             region=us-east-1
462     """
463     res = __salt__["boto_rds.subnet_group_exists"](
464         name, tags, region, key, keyid, profile
465     )
466     if res.get("exists"):
467         return {"exists": bool(res)}
468     try:
469         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
470         if not conn:
471             return {"results": bool(conn)}
472         taglist = _tag_doc(tags)
473         rds = conn.create_db_subnet_group(
474             DBSubnetGroupName=name,
475             DBSubnetGroupDescription=description,
476             SubnetIds=subnet_ids,
477             Tags=taglist,
478         )
479         return {"created": bool(rds)}
480     except ClientError as e:
481         return {"error": __utils__["boto3.get_error"](e)}
482 def update_parameter_group(
483     name,
484     parameters,
485     apply_method="pending-reboot",
486     tags=None,
487     region=None,
488     key=None,
489     keyid=None,
490     profile=None,
491 ):
492     """
493     Update an RDS parameter group.
494     CLI Example:
495     .. code-block:: bash
496         salt myminion boto_rds.update_parameter_group my-param-group \
497                 parameters='{"back_log":1, "binlog_cache_size":4096}' \
498                 region=us-east-1
499     """
500     res = __salt__["boto_rds.parameter_group_exists"](
501         name, tags, region, key, keyid, profile
502     )
503     if not res.get("exists"):
504         return {
505             "exists": bool(res),
506             "message": "RDS parameter group {} does not exist.".format(name),
507         }
508     param_list = []
509     for key, value in parameters.items():
510         item = odict.OrderedDict()
511         item.update({"ParameterName": key})
512         item.update({"ApplyMethod": apply_method})
513         if type(value) is bool:
514             item.update({"ParameterValue": "on" if value else "off"})
515         else:
516             item.update({"ParameterValue": str(value)})
517         param_list.append(item)
518     if not param_list:
519         return {"results": False}
520     try:
521         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
522         if not conn:
523             return {"results": bool(conn)}
524         res = conn.modify_db_parameter_group(
525             DBParameterGroupName=name, Parameters=param_list
526         )
527         return {"results": bool(res)}
528     except ClientError as e:
529         return {"error": __utils__["boto3.get_error"](e)}
530 def describe(name, tags=None, region=None, key=None, keyid=None, profile=None):
531     """
532     Return RDS instance details.
533     CLI Example:
534     .. code-block:: bash
535         salt myminion boto_rds.describe myrds
536     """
537     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
538     if not res.get("exists"):
539         return {
540             "exists": bool(res),
541             "message": "RDS instance {} does not exist.".format(name),
542         }
543     try:
544         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
545         if not conn:
546             return {"results": bool(conn)}
547         rds = conn.describe_db_instances(DBInstanceIdentifier=name)
548         rds = [
549             i
550             for i in rds.get("DBInstances", [])
551             if i.get("DBInstanceIdentifier") == name
552         ].pop(0)
553         if rds:
554             keys = (
555                 "DBInstanceIdentifier",
556                 "DBInstanceClass",
557                 "Engine",
558                 "DBInstanceStatus",
559                 "DBName",
560                 "AllocatedStorage",
561                 "PreferredBackupWindow",
562                 "BackupRetentionPeriod",
563                 "AvailabilityZone",
564                 "PreferredMaintenanceWindow",
565                 "LatestRestorableTime",
566                 "EngineVersion",
567                 "AutoMinorVersionUpgrade",
568                 "LicenseModel",
569                 "Iops",
570                 "CharacterSetName",
571                 "PubliclyAccessible",
572                 "StorageType",
573                 "TdeCredentialArn",
574                 "DBInstancePort",
575                 "DBClusterIdentifier",
576                 "StorageEncrypted",
577                 "KmsKeyId",
578                 "DbiResourceId",
579                 "CACertificateIdentifier",
580                 "CopyTagsToSnapshot",
581                 "MonitoringInterval",
582                 "MonitoringRoleArn",
583                 "PromotionTier",
584                 "DomainMemberships",
585             )
586             return {"rds": {k: rds.get(k) for k in keys}}
587         else:
588             return {"rds": None}
589     except ClientError as e:
590         return {"error": __utils__["boto3.get_error"](e)}
591     except IndexError:
592         return {"rds": None}
593 def describe_db_instances(
594     name=None,
595     filters=None,
596     jmespath="DBInstances",
597     region=None,
598     key=None,
599     keyid=None,
600     profile=None,
601 ):
602     """
603     Return a detailed listing of some, or all, DB Instances visible in the
604     current scope.  Arbitrary subelements or subsections of the returned dataset
605     can be selected by passing in a valid JMSEPath filter as well.
606     CLI Example:
607     .. code-block:: bash
608         salt myminion boto_rds.describe_db_instances jmespath='DBInstances[*].DBInstanceIdentifier'
609     """
610     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
611     pag = conn.get_paginator("describe_db_instances")
612     args = {}
613     args.update({"DBInstanceIdentifier": name}) if name else None
614     args.update({"Filters": filters}) if filters else None
615     pit = pag.paginate(**args)
616     pit = pit.search(jmespath) if jmespath else pit
617     try:
618         return [p for p in pit]
619         code = getattr(e, "response", {}).get("Error", {}).get("Code")
620         if code != "DBInstanceNotFound":
621             log<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.error(__utils__["boto3.get_error"](e))
622     return []
623 def describe_db_subnet_groups(
624     name=None,
625     filters=None,
626     jmespath="DBSubnetGroups",
627     region=None,
628     key=None,
629     keyid=None,
630     profile=</b></font>None,
631 ):
632     """
633     Return a detailed listing of some, or all, DB Subnet Groups visible in the
634     current scope.  Arbitrary subelements or subsections of the returned dataset
635     can be selected by passing in a valid JMSEPath filter as well.
636     CLI Example:
637     .. code-block:: bash
638         salt myminion boto_rds.describe_db_subnet_groups
639     """
640     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
641     pag = conn.get_paginator("describe_db_subnet_groups")
642     args = {}
643     args.update({"DBSubnetGroupName": name}) if name else None
644     args.update({"Filters": filters}) if filters else None
645     pit = pag.paginate(**args)
646     pit = pit.search(jmespath) if jmespath else pit
647     return [p for p in pit]
648 def get_endpoint(name, tags=None, region=None, key=None, keyid=None, profile=None):
649     """
650     Return the endpoint of an RDS instance.
651     CLI Example:
652     .. code-block:: bash
653         salt myminion boto_rds.get_endpoint myrds
654     """
655     endpoint = False
656     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
657     if res.get("exists"):
658         try:
659             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
660             if conn:
661                 rds = conn.describe_db_instances(DBInstanceIdentifier=name)
662                 if rds and "Endpoint" in rds["DBInstances"][0]:
663                     endpoint = rds["DBInstances"][0]["Endpoint"]["Address"]
664         except ClientError as e:
665             return {"error": __utils__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto3.get_error"](e)}
666     return endpoint
667 def delete(
668     name,
669     skip_final_snapshot=None,
670     final_db_snapshot_identifier=None,
671     region=None,
672     key=None,
673     keyid=None,
674     profile=</b></font>None,
675     tags=None,
676     wait_for_deletion=True,
677     timeout=180,
678 ):
679     """
680     Delete an RDS instance.
681     CLI Example:
682     .. code-block:: bash
683         salt myminion boto_rds.delete myrds skip_final_snapshot=True \
684                 region=us-east-1
685     """
686     if timeout == 180 and not skip_final_snapshot:
687         timeout = 420
688     if not skip_final_snapshot and not final_db_snapshot_identifier:
689         raise SaltInvocationError(
690             "At least one of the following must"
691             " be specified: skip_final_snapshot"
692             " final_db_snapshot_identifier"
693         )
694     try:
695         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
696         if not conn:
697             return {"deleted": bool(conn)}
698         kwargs = {}
699         if locals()["skip_final_snapshot"] is not None:
700             kwargs["SkipFinalSnapshot"] = bool(locals()["skip_final_snapshot"])
701         if locals()["final_db_snapshot_identifier"] is not None:
702             kwargs["FinalDBSnapshotIdentifier"] = str(
703                 locals()["final_db_snapshot_identifier"]
704             )
705         res = conn.delete_db_instance(DBInstanceIdentifier=name, **kwargs)
706         if not wait_for_deletion:
707             return {
708                 "deleted": bool(res),
709                 "message": "Deleted RDS instance {}.".format(name),
710             }
711         start_time = time.time()
712         while True:
713             res = __salt__["boto_rds.exists"](
714                 name=name,
715                 tags=tags,
716                 region=region,
717                 key=key,
718                 keyid=keyid,
719                 profile=profile,
720             )
721             if not res.get("exists"):
722                 return {
723                     "deleted": bool(res),
724                     "message": "Deleted RDS instance {} completely.".format(name),
725                 }
726             if time.time() - start_time &gt; timeout:
727                 raise SaltInvocationError(
728                     "RDS instance {} has not been "
729                     "deleted completely after {} "
730                     "seconds".format(name, timeout)
731                 )
732             log.info(
733                 "Waiting up to %s seconds for RDS instance %s to be deleted.",
734                 timeout,
735                 name,
736             )
737             time.sleep(10)
738     except ClientError as e:
739         return {"error": __utils__["boto3.get_error"](e)}
740 def delete_option_group(name, region=None, key=None, keyid=None, profile=None):
741     """
742     Delete an RDS option group.
743     CLI Example:
744     .. code-block:: bash
745         salt myminion boto_rds.delete_option_group my-opt-group \
746                 region=us-east-1
747     """
748     try:
749         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
750         if not conn:
751             return {"deleted": bool(conn)}
752         res = conn.delete_option_group(OptionGroupName=name)
753         if not res:
754             return {
755                 "deleted": bool(res),
756                 "message": "Failed to delete RDS option group {}.".format(name),
757             }
758         return {
759             "deleted": bool(res),
760             "message": "Deleted RDS option group {}.".format(name),
761         }
762     except ClientError as e:
763         return {"error": __utils__["boto3.get_error"](e)}
764 def delete_parameter_group(name, region=None, key=None, keyid=None, profile=None):
765     """
766     Delete an RDS parameter group.
767     CLI Example:
768     .. code-block:: bash
769         salt myminion boto_rds.delete_parameter_group my-param-group \
770                 region=us-east-1
771     """
772     try:
773         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
774         if not conn:
775             return {"results": bool(conn)}
776         r = conn.delete_db_parameter_group(DBParameterGroupName=name)
777         return {
778             "deleted": bool(r),
779             "message": "Deleted RDS parameter group {}.".format(name),
780         }
781     except ClientError as e:
782         return {"error": __utils__["boto3.get_error"](e)}
783 def delete_subnet_group(name, region=None, key=None, keyid=None, profile=None):
784     """
785     Delete an RDS subnet group.
786     CLI Example:
787     .. code-block:: bash
788         salt myminion boto_rds.delete_subnet_group my-subnet-group \
789                 region=us-east-1
790     """
791     try:
792         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
793         if not conn:
794             return {"results": bool(conn)}
795         r = conn.delete_db_subnet_group(DBSubnetGroupName=name)
796         return {
797             "deleted": bool(r),
798             "message": "Deleted RDS subnet group {}.".format(name),
799         }
800     except ClientError as e:
801         return {"error": __utils__["boto3.get_error"](e)}
802 def describe_parameter_group(
803     name,
804     Filters=None,
805     MaxRecords=None,
806     Marker=None,
807     region=None,
808     key=None,
809     keyid=None,
810     profile=None,
811 ):
812     """
813     Returns a list of `DBParameterGroup` descriptions.
814     CLI example to description of parameter group::
815         salt myminion boto_rds.describe_parameter_group parametergroupname\
816             region=us-east-1
817     """
818     res = __salt__["boto_rds.parameter_group_exists"](
819         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
820     )
821     if not res.get("exists"):
822         return {"exists": bool(res)}
823     try:
824         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
825         if not conn:
826             return {"results": bool(conn)}
827         kwargs = {}
828         for key in ("Marker", "Filters"):
829             if locals()[key] is not None:
830                 kwargs[key] = str(locals()[key])
831         if locals()["MaxRecords"] is not None:
832             kwargs["MaxRecords"] = int(locals()["MaxRecords"])
833         info = conn.describe_db_parameter_groups(DBParameterGroupName=name, **kwargs)
834         if not info:
835             return {
836                 "results": bool(info),
837                 "message": "Failed to get RDS description for group {}.".format(name),
838             }
839         return {
840             "results": bool(info),
841             "message": "Got RDS descrition for group {}.".format(name),
842         }
843     except ClientError as e:
844         return {"error": __utils__["boto3.get_error"](e)}
845 def describe_parameters(
846     name,
847     Source=None,
848     MaxRecords=None,
849     Marker=None,
850     region=None,
851     key=None,
852     keyid=None,
853     profile=None,
854 ):
855     """
856     Returns a list of `DBParameterGroup` parameters.
857     CLI example to description of parameters ::
858         salt myminion boto_rds.describe_parameters parametergroupname\
859             region=us-east-1
860     """
861     res = __salt__["boto_rds.parameter_group_exists"](
862         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
863     )
864     if not res.get("exists"):
865         return {
866             "result": False,
867             "message": "Parameter group {} does not exist".format(name),
868         }
869     try:
870         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
871         if not conn:
872             return {
873                 "result": False,
874                 "message": "Could not establish a connection to RDS",
875             }
876         kwargs = {}
877         kwargs.update({"DBParameterGroupName": name})
878         for key in ("Marker", "Source"):
879             if locals()[key] is not None:
880                 kwargs[key] = str(locals()[key])
881         if locals()["MaxRecords"] is not None:
882             kwargs["MaxRecords"] = int(locals()["MaxRecords"])
883         pag = conn.get_paginator("describe_db_parameters")
884         pit = pag.paginate(**kwargs)
885         keys = [
886             "ParameterName",
887             "ParameterValue",
888             "Description",
889             "Source",
890             "ApplyType",
891             "DataType",
892             "AllowedValues",
893             "IsModifieable",
894             "MinimumEngineVersion",
895             "ApplyMethod",
896         ]
897         parameters = odict.OrderedDict()
898         ret = {"result": True}
899         for p in pit:
900             for result in p["Parameters"]:
901                 data = odict.OrderedDict()
902                 for k in keys:
903                     data[k] = result.get(k)
904                 parameters[result.get("ParameterName")] = data
905         ret["parameters"] = parameters
906         return ret
907     except ClientError as e:
908         return {"error": __utils__["boto3.get_error"](e)}
909 def modify_db_instance(
910     name,
911     allocated_storage=None,
912     allow_major_version_upgrade=None,
913     apply_immediately=None,
914     auto_minor_version_upgrade=None,
915     backup_retention_period=None,
916     ca_certificate_identifier=None,
917     character_set_name=None,
918     copy_tags_to_snapshot=None,
919     db_cluster_identifier=None,
920     db_instance_class=None,
921     db_name=None,
922     db_parameter_group_name=None,
923     db_port_number=None,
924     db_security_groups=None,
925     db_subnet_group_name=None,
926     domain=None,
927     domain_iam_role_name=None,
928     engine_version=None,
929     iops=None,
930     kms_key_id=None,
931     license_model=None,
932     master_user_password=None,
933     monitoring_interval=None,
934     monitoring_role_arn=None,
935     multi_az=None,
936     new_db_instance_identifier=None,
937     option_group_name=None,
938     preferred_backup_window=None,
939     preferred_maintenance_window=None,
940     promotion_tier=None,
941     publicly_accessible=None,
942     storage_encrypted=None,
943     storage_type=None,
944     tde_credential_arn=None,
945     tde_credential_password=None,
946     vpc_security_group_ids=None,
947     region=None,
948     key=None,
949     keyid=None,
950     profile=None,
951 ):
952     """
953     Modify settings for a DB instance.
954     CLI example to description of parameters ::
955         salt myminion boto_rds.modify_db_instance db_instance_identifier region=us-east-1
956     """
957     res = __salt__["boto_rds.exists"](
958         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
959     )
960     if not res.get("exists"):
961         return {
962             "modified": False,
963             "message": "RDS db instance {} does not exist.".format(name),
964         }
965     try:
966         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
967         if not conn:
968             return {"modified": False}
969         kwargs = {}
970         excluded = {"name"}
971         boto_params = set(boto3_param_map.keys())
972         keys = set(locals().keys())
973         for key in keys.intersection(boto_params).difference(excluded):
974             val = locals()[key]
975             if val is not None:
976                 mapped = boto3_param_map[key]
977                 kwargs[mapped[0]] = mapped[1](val)
978         info = conn.modify_db_instance(DBInstanceIdentifier=name, **kwargs)
979         if not info:
980             return {
981                 "modified": bool(info),
982                 "message": "Failed to modify RDS db instance {}.".format(name),
983             }
984         return {
985             "modified": bool(info),
986             "message": "Modified RDS db instance {}.".format(name),
987             "results": dict(info),
988         }
989     except ClientError as e:
990         return {"error": __utils__["boto3.get_error"](e)}
991 def _tag_doc(tags):
992     taglist = []
993     if tags is not None:
994         for k, v in tags.items():
995             if str(k).startswith("__"):
996                 continue
997             taglist.append({"Key": str(k), "Value": str(v)})
998     return taglist
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
