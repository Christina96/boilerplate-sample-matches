<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_iam_role.py &amp; boto_rds_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_iam_role.py &amp; boto_rds_1.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_iam_role.py (3.716814%)<th>boto_rds_1.py (2.902557%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(363-376)<td><a href="#" name="0">(755-766)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(104-182)<td><a href="#" name="1">(225-247)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(432-440)<td><a href="#" name="2">(814-826)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam_role.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.dictdiffer
3 import salt.utils.dictupdate as dictupdate
4 from salt.utils.odict import OrderedDict
5 log = logging.getLogger(__name__)
6 def __virtual__():
7     return (F<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>alse, "boto_iam module could not be loaded")
8 def present(
9     name,
10     policy_document=None,
11     policy_document_from_pillars=None,
12     path=None,
13     policies=None,
14     policies_from_pillars=None,
15     managed_policies=None,
16     create_instance_profile=True,
17     region=None,
18     key=None,
19     keyid=None,
20     profile=None,
21     delete_policies=True,
22 ):
23     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
24     _policy_document = {}
25     if policy_document_from_pillars:
26         from_pillars = __salt__["pillar.get"](policy_document_from_pillars)
27         if from_pillars:
28             _policy_document["Version"] = from_pillars["Version"]
29             _policy_document.setdefault("Statement", [])
30             _policy_document["Statement"].extend(from_pillars["Statement"])
31     if policy_document:
32         _policy_document["Version"] = policy_document["Version"]
33         _policy_document.setdefault("Statement", [])
34         _policy_document["Statement"].extend(policy_document["Statement"])
35     _ret = _role_present(name, _policy_document, path, region, key, keyid, profile)
36     if not policies:
37         policies = {}
38     if not policies_from_pillars:
39         policies_from_pillars = []
40     if not managed_policies:
41         managed_policies = []
42     _policies = {}
43     for policy in policies_from_pillars:
44         _policy = __salt__["pillar.get"](policy)
45         _policies.update(_policy)
46     _policies.update(policies)
47     ret["changes"] = _ret["changes"]
48     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
49     if not _ret["result"]:
50         ret["result"] = _ret["result"]
51         if ret["result"] is False:
52             return ret
53     if create_instance_profile:
54         _ret = _instance_profile_present(name, region, key, keyid, profile)
55         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
56         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
57         if not _ret["result"]:
58             ret["result"] = _ret["result"]
59             if ret["result"] is False:
60                 return ret
61         _ret = _instance_profile_associated(name, region, key, keyid, profile)
62         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
63         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
64         if not _ret["result"]:
65             ret["result"] = _ret["result"]
66             if ret["result"] is False:
67                 return ret
68     _ret = _policies_present(
69         name, _policies, region, key, keyid, profile, delete_policies
70     )
71     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
72     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
73     if not _ret["result"]:
74         ret["result"] = _ret["result"]
75     _ret = _policies_attached(name, managed_policies, region, key, keyid, profile)
76     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
77     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
78     if not _ret["result"]:
79         ret["result"] = _ret["result"]
80     return ret
81 def _role_present(
82     name,
83     policy_document=None,
84     path=None,
85     region=None,
86     key=None,
87     keyid=None,
88     profile=None,
89 ):
90     ret = {"result": True, "comment": "", "changes": {}}
91     role = __salt__["boto_iam.describe_role"](name, region, key, keyid, profile)
92     if not role:
93         if __opts__["test"]:
94             ret["comment"] = "IAM role {} is set to be created.".format(name)
95             ret["result"] = None
96             return ret
97         created = __salt__["boto_iam.create_role"](
98             name, policy_document, path, region, key, keyid, profile
99         )
100         if created:
101             ret["changes"]["old"] = {"role": None}
102             ret["changes"]["new"] = {"role": name}
103             ret["comment"] = "IAM role {} created.".format(name)
104         else:
105             ret["result"] = False
106             ret["comment"] = "Failed to create {} IAM role.".format(name)
107     else:
108         ret["comment"] = "{} role present.".format(name)
109         if not policy_document:
110             _policy_document = __salt__["boto_iam.build_policy"](
111                 region, key, keyid, profile
112             )
113         else:
114             _policy_document = policy_document
115         if salt.utils.dictdiffer.deep_diff(
116             _sort_policy(role["assume_role_policy_document"]),
117             _sort_policy(_policy_document),
118         ):
119             if __opts__["test"]:
120                 msg = "Assume role policy document to be updated."
121                 ret["comment"] = "{} {}".format(ret["comment"], msg)
122                 ret["result"] = None
123                 return ret
124             updated = __salt__["boto_iam.update_assume_role_policy"](
125                 name, _policy_document, region, key, keyid, profile
126             )
127             if updated:
128                 msg = "Assume role policy document updated."
129                 ret["comment"] = "{} {}".format(ret["comment"], msg)
130                 ret["changes"]["old"] = {
131                     "policy_document": role["assume_role_policy_document"]
132                 }
133                 ret["changes"]["new"] = {"policy_document": _policy_document}
134             else:
135                 ret["result"] = False
136                 msg = "Failed to update assume role policy."
137                 ret["comment"] = "{} {}".format(ret["comment"], msg)
138     return ret
139 def _instance_profile_present(name, region=None, key=None, keyid=None, profile=None):
140     ret = {"result": True, "comment": "", "changes": {}}
141     exists = __salt__["boto_iam.instance_profile_exists"](
142         name, region, key, keyid, profile
143     )
144     if not exists:
145         if __opts__["test"]:
146             ret["comment"] = "Instance profile {} is set to be created.".format(name)
147             ret["result"] = None
148             return ret
149         created = __salt__["boto_iam.create_instance_profile"](
150             name, region, key, keyid, profile
151         )
152         if created:
153             ret["changes"]["old"] = {"instance_profile": None}
154             ret["changes"]["new"] = {"instance_profile": name}
155             ret["comment"] = "Instance profile {} created.".format(name)
156         else:
157             ret["result"] = False
158             ret["comment"] = "Failed to create {} instance profile.".format(name)
159     return ret
160 def _instance_profile_associated(name, region=None, key=None, keyid=None, profile=None):
161     ret = {"result": True, "comment": "", "changes": {}}
162     is_associated = __salt__["boto_iam.profile_associated"](
163         name, name, region, key, keyid, profile
164     )
165     if not is_associated:
166         if __opts__["test"]:
167             ret["comment"] = "Instance profile {} is set to be associated.".format(name)
168             ret["result"] = None
169             return ret
170         associated = __salt__["boto_iam.associate_profile_to_role"](
171             name, name, region, key, keyid, profile
172         )
173         if associated:
174             ret["changes"]["old"] = {"profile_associated": None}
175             ret["changes"]["new"] = {"profile_associated": True}
176             ret["comment"] = "Instance profile {} associated.".format(name)
177         else:
178             ret["result"] = False
179             ret[
180                 "comment"
181             ] = "Failed to associate {0} instance profile with {0} role.".format(name)
182     return ret
183 def _sort_policy(doc):
184 <a name="0"></a>    if isinstance(doc, list):
185         return sorted(_sort_policy(i) for i in doc)
186     elif isinstance(doc, (dict, OrderedDict)):
187         return {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>k: _sort_policy(v) for k, v in doc.items()}
188     return doc
189 def _policies_present(
190     name,
191     policies=None,
192     region=None,
193     key=None,
194     keyid=None,
195     profile=None,
196     delete_policies=True,
197 ):
198     ret =</b></font> {"result": True, "comment": "", "changes": {}}
199     policies_to_create = {}
200     policies_to_delete = []
201     for policy_name, policy in policies.items():
202         _policy = __salt__["boto_iam.get_role_policy"](
203             name, policy_name, region, key, keyid, profile
204         )
205         if _policy != policy:
206             policies_to_create[policy_name] = policy
207     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
208     for policy_name in _list:
209         if delete_policies and policy_name not in policies:
210             policies_to_delete.append(policy_name)
211     if policies_to_create or policies_to_delete:
212         _to_modify = list(policies_to_delete)
213         _to_modify.extend(policies_to_create)
214         if __opts__["test"]:
215             ret["comment"] = "{} policies to be modified on role {}.".format(
216                 ", ".join(_to_modify), name
217             )
218             ret["result"] = None
219             return ret
220         ret["changes"]["old"] = {"policies": _list}
221         for policy_name, policy in policies_to_create.items():
222             policy_set = __salt__["boto_iam.create_role_policy"](
223                 name, policy_name, policy, region, key, keyid, profile
224             )
225             if not policy_set:
226                 _list = __salt__["boto_iam.list_role_policies"](
227                     name, region, key, keyid, profile
228                 )
229                 ret["changes"]["new"] = {"policies": _list}
230                 ret["result"] = False
231                 ret["comment"] = "Failed to add policy {} to role {}".format(
232                     policy_name, name
233                 )
234                 return ret
235         for policy_name in policies_to_delete:
236             policy_unset = __salt__["boto_iam.delete_role_policy"](
237                 name, policy_name, region, key, keyid, profile
238             )
239             if not policy_unset:
240                 _list = __salt__["boto_iam.list_role_policies"](
241                     name, region, key, keyid, profile
242                 )
243                 ret["changes"]["new"] = {"policies": _list}
244                 ret["result"] = False
245                 ret["comment"] = "Failed to remove policy {} from role {}".format(
246                     policy_name, name
247                 )
248                 return ret
249         _list = __salt__["boto_iam.list_role_policies"](
250             name, region, key, keyid, profile
251 <a name="2"></a>        )
252         ret["changes"]["new"] = {"policies": _list}
253         ret["comment"] = "{} policies modified on role {}.".format(
254             ", "<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(_list), name
255         )
256     return ret
257 def _policies_attached(
258     name, managed_policies=None, region=None, key=None, keyid=None, profile=None
259 ):
260     ret =</b></font> {"result": True, "comment": "", "changes": {}}
261     policies_to_attach = []
262     policies_to_detach = []
263     for policy in managed_policies or []:
264         entities = __salt__["boto_iam.list_entities_for_policy"](
265             policy,
266             entity_filter="Role",
267             region=region,
268             key=key,
269             keyid=keyid,
270             profile=profile,
271         )
272         found = False
273         for roledict in entities.get("policy_roles", []):
274             if name == roledict.get("role_name"):
275                 found = True
276                 break
277         if not found:
278             policies_to_attach.append(policy)
279     _list = __salt__["boto_iam.list_attached_role_policies"](
280         name, region=region, key=key, keyid=keyid, profile=profile
281     )
282     oldpolicies = [x.get("policy_arn") for x in _list]
283     for policy_data in _list:
284         if (
285             policy_data.get("policy_name") not in managed_policies
286             and policy_data.get("policy_arn") not in managed_policies
287         ):
288             policies_to_detach.append(policy_data.get("policy_arn"))
289     if policies_to_attach or policies_to_detach:
290         _to_modify = list(policies_to_detach)
291         _to_modify.extend(policies_to_attach)
292         if __opts__["test"]:
293             ret["comment"] = "{} policies to be modified on role {}.".format(
294                 ", ".join(_to_modify), name
295             )
296             ret["result"] = None
297             return ret
298         ret["changes"]["old"] = {"managed_policies": oldpolicies}
299         for policy_name in policies_to_attach:
300             policy_set = __salt__["boto_iam.attach_role_policy"](
301                 policy_name,
302                 role_name=name,
303                 region=region,
304                 key=key,
305                 keyid=keyid,
306                 profile=profile,
307             )
308             if not policy_set:
309                 _list = __salt__["boto_iam.list_attached_role_policies"](
310                     name, region=region, key=key, keyid=keyid, profile=profile
311                 )
312                 newpolicies = [x.get("policy_arn") for x in _list]
313                 ret["changes"]["new"] = {"managed_policies": newpolicies}
314                 ret["result"] = False
315                 ret["comment"] = "Failed to add policy {} to role {}".format(
316                     policy_name, name
317                 )
318                 return ret
319         for policy_name in policies_to_detach:
320             policy_unset = __salt__["boto_iam.detach_role_policy"](
321                 policy_name,
322                 role_name=name,
323                 region=region,
324                 key=key,
325                 keyid=keyid,
326                 profile=profile,
327             )
328             if not policy_unset:
329                 _list = __salt__["boto_iam.list_attached_role_policies"](
330                     name, region=region, key=key, keyid=keyid, profile=profile
331                 )
332                 newpolicies = [x.get("policy_arn") for x in _list]
333                 ret["changes"]["new"] = {"managed_policies": newpolicies}
334                 ret["result"] = False
335                 ret["comment"] = "Failed to remove policy {} from role {}".format(
336                     policy_name, name
337                 )
338                 return ret
339         _list = __salt__["boto_iam.list_attached_role_policies"](
340             name, region=region, key=key, keyid=keyid, profile=profile
341         )
342         newpolicies = [x.get("policy_arn") for x in _list]
343         log.debug(newpolicies)
344         ret["changes"]["new"] = {"managed_policies": newpolicies}
345         ret["comment"] = "{} policies modified on role {}.".format(
346             ", ".join(newpolicies), name
347         )
348     return ret
349 def absent(name, region=None, key=None, keyid=None, profile=None):
350     ret = {"name": name, "result": True, "comment": "", "changes": {}}
351     _ret = _policies_absent(name, region, key, keyid, profile)
352     ret["changes"] = _ret["changes"]
353     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
354     if not _ret["result"]:
355         ret["result"] = _ret["result"]
356         if ret["result"] is False:
357             return ret
358     _ret = _policies_detached(name, region, key, keyid, profile)
359     ret["changes"] = _ret["changes"]
360     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
361     if not _ret["result"]:
362         ret["result"] = _ret["result"]
363         if ret["result"] is False:
364             return ret
365     _ret = _instance_profile_disassociated(name, region, key, keyid, profile)
366     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
367     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
368     if not _ret["result"]:
369         ret["result"] = _ret["result"]
370         if ret["result"] is False:
371             return ret
372     _ret = _instance_profile_absent(name, region, key, keyid, profile)
373     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
374     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
375     if not _ret["result"]:
376         ret["result"] = _ret["result"]
377         if ret["result"] is False:
378             return ret
379     _ret = _role_absent(name, region, key, keyid, profile)
380     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
381     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
382     if not _ret["result"]:
383         ret["result"] = _ret["result"]
384     return ret
385 def _role_absent(name, region=None, key=None, keyid=None, profile=None):
386     ret = {"result": True, "comment": "", "changes": {}}
387     exists = __salt__["boto_iam.role_exists"](name, region, key, keyid, profile)
388     if exists:
389         if __opts__["test"]:
390             ret["comment"] = "IAM role {} is set to be removed.".format(name)
391             ret["result"] = None
392             return ret
393         deleted = __salt__["boto_iam.delete_role"](name, region, key, keyid, profile)
394         if deleted:
395             ret["changes"]["old"] = {"role": name}
396             ret["changes"]["new"] = {"role": None}
397             ret["comment"] = "IAM role {} removed.".format(name)
398         else:
399             ret["result"] = False
400             ret["comment"] = "Failed to delete {} iam role.".format(name)
401     else:
402         ret["comment"] = "{} role does not exist.".format(name)
403     return ret
404 def _instance_profile_absent(name, region=None, key=None, keyid=None, profile=None):
405     ret = {"result": True, "comment": "", "changes": {}}
406     exists = __salt__["boto_iam.instance_profile_exists"](
407         name, region, key, keyid, profile
408     )
409     if exists:
410         if __opts__["test"]:
411             ret["comment"] = "Instance profile {} is set to be removed.".format(name)
412             ret["result"] = None
413             return ret
414         deleted = __salt__["boto_iam.delete_instance_profile"](
415             name, region, key, keyid, profile
416         )
417         if deleted:
418             ret["changes"]["old"] = {"instance_profile": name}
419             ret["changes"]["new"] = {"instance_profile": None}
420             ret["comment"] = "Instance profile {} removed.".format(name)
421         else:
422             ret["result"] = False
423             ret["comment"] = "Failed to delete {} instance profile.".format(name)
424     else:
425         ret["comment"] = "{} instance profile does not exist.".format(name)
426     return ret
427 def _policies_absent(name, region=None, key=None, keyid=None, profile=None):
428     ret = {"result": True, "comment": "", "changes": {}}
429     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
430     if not _list:
431         ret["comment"] = "No policies in role {}.".format(name)
432         return ret
433     if __opts__["test"]:
434         ret["comment"] = "{} policies to be removed from role {}.".format(
435             ", ".join(_list), name
436         )
437         ret["result"] = None
438         return ret
439     ret["changes"]["old"] = {"policies": _list}
440     for policy_name in _list:
441         policy_unset = __salt__["boto_iam.delete_role_policy"](
442             name, policy_name, region, key, keyid, profile
443         )
444         if not policy_unset:
445             _list = __salt__["boto_iam.list_role_policies"](
446                 name, region, key, keyid, profile
447             )
448             ret["changes"]["new"] = {"policies": _list}
449             ret["result"] = False
450             ret["comment"] = "Failed to add policy {} to role {}".format(
451                 policy_name, name
452             )
453             return ret
454     _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
455     ret["changes"]["new"] = {"policies": _list}
456     ret["comment"] = "{} policies removed from role {}.".format(", ".join(_list), name)
457     return ret
458 def _policies_detached(name, region=None, key=None, keyid=None, profile=None):
459     ret = {"result": True, "comment": "", "changes": {}}
460     _list = __salt__["boto_iam.list_attached_role_policies"](
461         role_name=name, region=region, key=key, keyid=keyid, profile=profile
462     )
463     oldpolicies = [x.get("policy_arn") for x in _list]
464     if not _list:
465         ret["comment"] = "No attached policies in role {}.".format(name)
466         return ret
467     if __opts__["test"]:
468         ret["comment"] = "{} policies to be detached from role {}.".format(
469             ", ".join(oldpolicies), name
470         )
471         ret["result"] = None
472         return ret
473     ret["changes"]["old"] = {"managed_policies": oldpolicies}
474     for policy_arn in oldpolicies:
475         policy_unset = __salt__["boto_iam.detach_role_policy"](
476             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
477         )
478         if not policy_unset:
479             _list = __salt__["boto_iam.list_attached_role_policies"](
480                 name, region=region, key=key, keyid=keyid, profile=profile
481             )
482             newpolicies = [x.get("policy_arn") for x in _list]
483             ret["changes"]["new"] = {"managed_policies": newpolicies}
484             ret["result"] = False
485             ret["comment"] = "Failed to detach {} from role {}".format(policy_arn, name)
486             return ret
487     _list = __salt__["boto_iam.list_attached_role_policies"](
488         name, region=region, key=key, keyid=keyid, profile=profile
489     )
490     newpolicies = [x.get("policy_arn") for x in _list]
491     ret["changes"]["new"] = {"managed_policies": newpolicies}
492     ret["comment"] = "{} policies detached from role {}.".format(
493         ", ".join(newpolicies), name
494     )
495     return ret
496 def _instance_profile_disassociated(
497     name, region=None, key=None, keyid=None, profile=None
498 ):
499     ret = {"result": True, "comment": "", "changes": {}}
500     is_associated = __salt__["boto_iam.profile_associated"](
501         name, name, region, key, keyid, profile
502     )
503     if is_associated:
504         if __opts__["test"]:
505             ret["comment"] = "Instance profile {} is set to be disassociated.".format(
506                 name
507             )
508             ret["result"] = None
509             return ret
510         associated = __salt__["boto_iam.disassociate_profile_from_role"](
511             name, name, region, key, keyid, profile
512         )
513         if associated:
514             ret["changes"]["old"] = {"profile_associated": True}
515             ret["changes"]["new"] = {"profile_associated": False}
516             ret["comment"] = "Instance profile {} disassociated.".format(name)
517         else:
518             ret["result"] = False
519             ret[
520                 "comment"
521             ] = "Failed to disassociate {0} instance profile from {0} role.".format(
522                 name
523             )
524     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_rds_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import time
3 import salt.utils.compat
4 import salt.utils.odict as odict
5 import salt.utils.versions
6 from salt.exceptions import SaltInvocationError
7 log = logging.getLogger(__name__)
8 try:
9     import boto
10     import boto3
11     from botocore.exceptions import ClientError
12     logging.getLogger("boto").setLevel(logging.CRITICAL)
13     logging.getLogger("boto3").setLevel(logging.CRITICAL)
14     HAS_BOTO = True
15 except ImportError:
16     HAS_BOTO = False
17 boto3_param_map = {
18     "allocated_storage": ("AllocatedStorage", int),
19     "allow_major_version_upgrade": ("AllowMajorVersionUpgrade", bool),
20     "apply_immediately": ("ApplyImmediately", bool),
21     "auto_minor_version_upgrade": ("AutoMinorVersionUpgrade", bool),
22     "availability_zone": ("AvailabilityZone", str),
23     "backup_retention_period": ("BackupRetentionPeriod", int),
24     "ca_certificate_identifier": ("CACertificateIdentifier", str),
25     "character_set_name": ("CharacterSetName", str),
26     "copy_tags_to_snapshot": ("CopyTagsToSnapshot", bool),
27     "db_cluster_identifier": ("DBClusterIdentifier", str),
28     "db_instance_class": ("DBInstanceClass", str),
29     "db_name": ("DBName", str),
30     "db_parameter_group_name": ("DBParameterGroupName", str),
31     "db_port_number": ("DBPortNumber", int),
32     "db_security_groups": ("DBSecurityGroups", list),
33     "db_subnet_group_name": ("DBSubnetGroupName", str),
34     "domain": ("Domain", str),
35     "domain_iam_role_name": ("DomainIAMRoleName", str),
36     "engine": ("Engine", str),
37     "engine_version": ("EngineVersion", str),
38     "iops": ("Iops", int),
39     "kms_key_id": ("KmsKeyId", str),
40     "license_model": ("LicenseModel", str),
41     "master_user_password": ("MasterUserPassword", str),
42     "master_username": ("MasterUsername", str),
43     "monitoring_interval": ("MonitoringInterval", int),
44     "monitoring_role_arn": ("MonitoringRoleArn", str),
45     "multi_az": ("MultiAZ", bool),
46     "name": ("DBInstanceIdentifier", str),
47     "new_db_instance_identifier": ("NewDBInstanceIdentifier", str),
48     "option_group_name": ("OptionGroupName", str),
49     "port": ("Port", int),
50     "preferred_backup_window": ("PreferredBackupWindow", str),
51     "preferred_maintenance_window": ("PreferredMaintenanceWindow", str),
52     "promotion_tier": ("PromotionTier", int),
53     "publicly_accessible": ("PubliclyAccessible", bool),
54     "storage_encrypted": ("StorageEncrypted", bool),
55     "storage_type": ("StorageType", str),
56     "tags": ("Tags", list),
57     "tde_credential_arn": ("TdeCredentialArn", str),
58     "tde_credential_password": ("TdeCredentialPassword", str),
59     "vpc_security_group_ids": ("VpcSecurityGroupIds", list),
60 }
61 def __virtual__():
62     return salt.utils.versions.check_boto_reqs(boto3_ver="1.3.1")
63 def __init__(opts):
64     if HAS_BOTO:
65         __utils__["boto3.assign_funcs"](__name__, "rds")
66 def exists(name, tags=None, region=None, key=None, keyid=None, profile=None):
67     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
68     try:
69         rds = conn.describe_db_instances(DBInstanceIdentifier=name)
70         return {"exists": bool(rds)}
71     except ClientError as e:
72         return {"error": __utils__["boto3.get_error"](e)}
73 def option_group_exists(
74     name, tags=None, region=None, key=None, keyid=None, profile=None
75 ):
76     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
77     try:
78         rds = conn.describe_option_groups(OptionGroupName=name)
79         return {"exists": bool(rds)}
80     except ClientError as e:
81         return {"error": __utils__["boto3.get_error"](e)}
82 def parameter_group_exists(
83     name, tags=None, region=None, key=None, keyid=None, profile=None
84 ):
85     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
86     try:
87         rds = conn.describe_db_parameter_groups(DBParameterGroupName=name)
88         return {"exists": bool(rds), "error": None}
89     except ClientError as e:
90         resp = {}
91         if e.response["Error"]["Code"] == "DBParameterGroupNotFound":
92             resp["exists"] = False
93         resp["error"] = __utils__["boto3.get_error"](e)
94         return resp
95 def subnet_group_exists(
96     name, tags=None, region=None, key=None, keyid=None, profile=None
97 ):
98     try:
99         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
100         if not conn:
101             return {"exists": bool(conn)}
102         rds = conn.describe_db_subnet_groups(DBSubnetGroupName=name)
103         return {"exists": bool(rds)}
104     except ClientError as e:
105 <a name="1"></a>        if "DBSubnetGroupNotFoundFault" in e.message:
106             return {"exists": False}
107         else:
108             return {"error": __utils__["boto3.get_error"](e<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>)}
109 def create(
110     name,
111     allocated_storage,
112     db_instance_class,
113     engine,
114     master_username,
115     master_user_password,
116     db_name=None,
117     db_security_groups=None,
118     vpc_security_group_ids=None,
119     vpc_security_groups=None,
120     availability_zone=None,
121     db_subnet_group_name=None,
122     preferred_maintenance_window=None,
123     db_parameter_group_name=None,
124     backup_retention_period=None,
125     preferred_backup_window=None,
126     port=None,
127     multi_az=None,
128     engine_version=</b></font>None,
129     auto_minor_version_upgrade=None,
130     license_model=None,
131     iops=None,
132     option_group_name=None,
133     character_set_name=None,
134     publicly_accessible=None,
135     wait_status=None,
136     tags=None,
137     db_cluster_identifier=None,
138     storage_type=None,
139     tde_credential_arn=None,
140     tde_credential_password=None,
141     storage_encrypted=None,
142     kms_key_id=None,
143     domain=None,
144     copy_tags_to_snapshot=None,
145     monitoring_interval=None,
146     monitoring_role_arn=None,
147     domain_iam_role_name=None,
148     region=None,
149     promotion_tier=None,
150     key=None,
151     keyid=None,
152     profile=None,
153 ):
154     if not allocated_storage:
155         raise SaltInvocationError("allocated_storage is required")
156     if not db_instance_class:
157         raise SaltInvocationError("db_instance_class is required")
158     if not engine:
159         raise SaltInvocationError("engine is required")
160     if not master_username:
161         raise SaltInvocationError("master_username is required")
162     if not master_user_password:
163         raise SaltInvocationError("master_user_password is required")
164     if availability_zone and multi_az:
165         raise SaltInvocationError(
166             "availability_zone and multi_az are mutually exclusive arguments."
167         )
168     if wait_status:
169         wait_stati = ["available", "modifying", "backing-up"]
170         if wait_status not in wait_stati:
171             raise SaltInvocationError(
172                 "wait_status can be one of: {}".format(wait_stati)
173             )
174     if vpc_security_groups:
175         v_tmp = __salt__["boto_secgroup.convert_to_group_ids"](
176             groups=vpc_security_groups,
177             region=region,
178             key=key,
179             keyid=keyid,
180             profile=profile,
181         )
182         vpc_security_group_ids = (
183             vpc_security_group_ids + v_tmp if vpc_security_group_ids else v_tmp
184         )
185     try:
186         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
187         if not conn:
188             return {"results": bool(conn)}
189         kwargs = {}
190         boto_params = set(boto3_param_map.keys())
191         keys = set(locals().keys())
192         tags = _tag_doc(tags)
193         for param_key in keys.intersection(boto_params):
194             val = locals()[param_key]
195             if val is not None:
196                 mapped = boto3_param_map[param_key]
197                 kwargs[mapped[0]] = mapped[1](val)
198         kwargs = {k: v for k, v in kwargs.items() if v is not None}
199         rds = conn.create_db_instance(**kwargs)
200         if not rds:
201             return {"created": False}
202         if not wait_status:
203             return {
204                 "created": True,
205                 "message": "RDS instance {} created.".format(name),
206             }
207         while True:
208             jmespath = "DBInstances[*].DBInstanceStatus"
209             status = describe_db_instances(
210                 name=name,
211                 jmespath=jmespath,
212                 region=region,
213                 key=key,
214                 keyid=keyid,
215                 profile=profile,
216             )
217             if status:
218                 stat = status[0]
219             else:
220                 return {
221                     "created": False,
222                     "error": (
223                         "RDS instance {} should have been created but"
224                         " now I can't find it.".format(name)
225                     ),
226                 }
227             if stat == wait_status:
228                 return {
229                     "created": True,
230                     "message": "RDS instance {} created (current status {})".format(
231                         name, stat
232                     ),
233                 }
234             time.sleep(10)
235             log.info("Instance status after 10 seconds is: %s", stat)
236     except ClientError as e:
237         return {"error": __utils__["boto3.get_error"](e)}
238 def create_read_replica(
239     name,
240     source_name,
241     db_instance_class=None,
242     availability_zone=None,
243     port=None,
244     auto_minor_version_upgrade=None,
245     iops=None,
246     option_group_name=None,
247     publicly_accessible=None,
248     tags=None,
249     db_subnet_group_name=None,
250     storage_type=None,
251     copy_tags_to_snapshot=None,
252     monitoring_interval=None,
253     monitoring_role_arn=None,
254     region=None,
255     key=None,
256     keyid=None,
257     profile=None,
258 ):
259     if not backup_retention_period:
260         raise SaltInvocationError("backup_retention_period is required")
261     res = __salt__["boto_rds.exists"](source_name, tags, region, key, keyid, profile)
262     if not res.get("exists"):
263         return {
264             "exists": bool(res),
265             "message": "RDS instance source {} does not exists.".format(source_name),
266         }
267     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
268     if res.get("exists"):
269         return {
270             "exists": bool(res),
271             "message": "RDS replica instance {} already exists.".format(name),
272         }
273     try:
274         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
275         kwargs = {}
276         for key in ("OptionGroupName", "MonitoringRoleArn"):
277             if locals()[key] is not None:
278                 kwargs[key] = str(locals()[key])
279         for key in ("MonitoringInterval", "Iops", "Port"):
280             if locals()[key] is not None:
281                 kwargs[key] = int(locals()[key])
282         for key in ("CopyTagsToSnapshot", "AutoMinorVersionUpgrade"):
283             if locals()[key] is not None:
284                 kwargs[key] = bool(locals()[key])
285         taglist = _tag_doc(tags)
286         rds_replica = conn.create_db_instance_read_replica(
287             DBInstanceIdentifier=name,
288             SourceDBInstanceIdentifier=source_name,
289             DBInstanceClass=db_instance_class,
290             AvailabilityZone=availability_zone,
291             PubliclyAccessible=publicly_accessible,
292             Tags=taglist,
293             DBSubnetGroupName=db_subnet_group_name,
294             StorageType=storage_type,
295             **kwargs
296         )
297         return {"exists": bool(rds_replica)}
298     except ClientError as e:
299         return {"error": __utils__["boto3.get_error"](e)}
300 def create_option_group(
301     name,
302     engine_name,
303     major_engine_version,
304     option_group_description,
305     tags=None,
306     region=None,
307     key=None,
308     keyid=None,
309     profile=None,
310 ):
311     res = __salt__["boto_rds.option_group_exists"](
312         name, tags, region, key, keyid, profile
313     )
314     if res.get("exists"):
315         return {"exists": bool(res)}
316     try:
317         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
318         if not conn:
319             return {"results": bool(conn)}
320         taglist = _tag_doc(tags)
321         rds = conn.create_option_group(
322             OptionGroupName=name,
323             EngineName=engine_name,
324             MajorEngineVersion=major_engine_version,
325             OptionGroupDescription=option_group_description,
326             Tags=taglist,
327         )
328         return {"exists": bool(rds)}
329     except ClientError as e:
330         return {"error": __utils__["boto3.get_error"](e)}
331 def create_parameter_group(
332     name,
333     db_parameter_group_family,
334     description,
335     tags=None,
336     region=None,
337     key=None,
338     keyid=None,
339     profile=None,
340 ):
341     res = __salt__["boto_rds.parameter_group_exists"](
342         name, tags, region, key, keyid, profile
343     )
344     if res.get("exists"):
345         return {"exists": bool(res)}
346     try:
347         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
348         if not conn:
349             return {"results": bool(conn)}
350         taglist = _tag_doc(tags)
351         rds = conn.create_db_parameter_group(
352             DBParameterGroupName=name,
353             DBParameterGroupFamily=db_parameter_group_family,
354             Description=description,
355             Tags=taglist,
356         )
357         if not rds:
358             return {
359                 "created": False,
360                 "message": "Failed to create RDS parameter group {}".format(name),
361             }
362         return {
363             "exists": bool(rds),
364             "message": "Created RDS parameter group {}".format(name),
365         }
366     except ClientError as e:
367         return {"error": __utils__["boto3.get_error"](e)}
368 def create_subnet_group(
369     name,
370     description,
371     subnet_ids,
372     tags=None,
373     region=None,
374     key=None,
375     keyid=None,
376     profile=None,
377 ):
378     res = __salt__["boto_rds.subnet_group_exists"](
379         name, tags, region, key, keyid, profile
380     )
381     if res.get("exists"):
382         return {"exists": bool(res)}
383     try:
384         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
385         if not conn:
386             return {"results": bool(conn)}
387         taglist = _tag_doc(tags)
388         rds = conn.create_db_subnet_group(
389             DBSubnetGroupName=name,
390             DBSubnetGroupDescription=description,
391             SubnetIds=subnet_ids,
392             Tags=taglist,
393         )
394         return {"created": bool(rds)}
395     except ClientError as e:
396         return {"error": __utils__["boto3.get_error"](e)}
397 def update_parameter_group(
398     name,
399     parameters,
400     apply_method="pending-reboot",
401     tags=None,
402     region=None,
403     key=None,
404     keyid=None,
405     profile=None,
406 ):
407     res = __salt__["boto_rds.parameter_group_exists"](
408         name, tags, region, key, keyid, profile
409     )
410     if not res.get("exists"):
411         return {
412             "exists": bool(res),
413             "message": "RDS parameter group {} does not exist.".format(name),
414         }
415     param_list = []
416     for key, value in parameters.items():
417         item = odict.OrderedDict()
418         item.update({"ParameterName": key})
419         item.update({"ApplyMethod": apply_method})
420         if type(value) is bool:
421             item.update({"ParameterValue": "on" if value else "off"})
422         else:
423             item.update({"ParameterValue": str(value)})
424         param_list.append(item)
425     if not param_list:
426         return {"results": False}
427     try:
428         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
429         if not conn:
430             return {"results": bool(conn)}
431         res = conn.modify_db_parameter_group(
432             DBParameterGroupName=name, Parameters=param_list
433         )
434         return {"results": bool(res)}
435     except ClientError as e:
436         return {"error": __utils__["boto3.get_error"](e)}
437 def describe(name, tags=None, region=None, key=None, keyid=None, profile=None):
438     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
439     if not res.get("exists"):
440         return {
441             "exists": bool(res),
442             "message": "RDS instance {} does not exist.".format(name),
443         }
444     try:
445         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
446         if not conn:
447             return {"results": bool(conn)}
448         rds = conn.describe_db_instances(DBInstanceIdentifier=name)
449         rds = [
450             i
451             for i in rds.get("DBInstances", [])
452             if i.get("DBInstanceIdentifier") == name
453         ].pop(0)
454         if rds:
455             keys = (
456                 "DBInstanceIdentifier",
457                 "DBInstanceClass",
458                 "Engine",
459                 "DBInstanceStatus",
460                 "DBName",
461                 "AllocatedStorage",
462                 "PreferredBackupWindow",
463                 "BackupRetentionPeriod",
464                 "AvailabilityZone",
465                 "PreferredMaintenanceWindow",
466                 "LatestRestorableTime",
467                 "EngineVersion",
468                 "AutoMinorVersionUpgrade",
469                 "LicenseModel",
470                 "Iops",
471                 "CharacterSetName",
472                 "PubliclyAccessible",
473                 "StorageType",
474                 "TdeCredentialArn",
475                 "DBInstancePort",
476                 "DBClusterIdentifier",
477                 "StorageEncrypted",
478                 "KmsKeyId",
479                 "DbiResourceId",
480                 "CACertificateIdentifier",
481                 "CopyTagsToSnapshot",
482                 "MonitoringInterval",
483                 "MonitoringRoleArn",
484                 "PromotionTier",
485                 "DomainMemberships",
486             )
487             return {"rds": {k: rds.get(k) for k in keys}}
488         else:
489             return {"rds": None}
490     except ClientError as e:
491         return {"error": __utils__["boto3.get_error"](e)}
492     except IndexError:
493         return {"rds": None}
494 def describe_db_instances(
495     name=None,
496     filters=None,
497     jmespath="DBInstances",
498     region=None,
499     key=None,
500     keyid=None,
501     profile=None,
502 ):
503     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
504     pag = conn.get_paginator("describe_db_instances")
505     args = {}
506     args.update({"DBInstanceIdentifier": name}) if name else None
507     args.update({"Filters": filters}) if filters else None
508     pit = pag.paginate(**args)
509     pit = pit.search(jmespath) if jmespath else pit
510     try:
511         return [p for p in pit]
512 <a name="0"></a>    except ClientError as e:
513         code = getattr(e, "response", {}).get("Error", {}).get("Code")
514         if code != "DBInstanceNotFound":
515             log<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.error(__utils__["boto3.get_error"](e))
516     return []
517 def describe_db_subnet_groups(
518     name=None,
519     filters=None,
520     jmespath="DBSubnetGroups",
521     region=None,
522     key=None,
523     keyid=None,
524     profile=</b></font>None,
525 ):
526     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
527     pag = conn.get_paginator("describe_db_subnet_groups")
528     args = {}
529     args.update({"DBSubnetGroupName": name}) if name else None
530     args.update({"Filters": filters}) if filters else None
531     pit = pag.paginate(**args)
532     pit = pit.search(jmespath) if jmespath else pit
533     return [p for p in pit]
534 def get_endpoint(name, tags=None, region=None, key=None, keyid=None, profile=None):
535     endpoint = False
536     res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
537     if res.get("exists"):
538         try:
539             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
540             if conn:
541                 rds = conn.describe_db_instances(DBInstanceIdentifier=name)
542                 if rds and "Endpoint" in rds["DBInstances"][0]:
543                     endpoint = rds["DBInstances"][0]["Endpoint"]["Address"]
544 <a name="2"></a>                    return endpoint
545         except ClientError as e:
546             return {"error": __utils__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto3.get_error"](e)}
547     return endpoint
548 def delete(
549     name,
550     skip_final_snapshot=None,
551     final_db_snapshot_identifier=None,
552     region=None,
553     key=None,
554     keyid=None,
555     profile=</b></font>None,
556     tags=None,
557     wait_for_deletion=True,
558     timeout=180,
559 ):
560     if timeout == 180 and not skip_final_snapshot:
561         timeout = 420
562     if not skip_final_snapshot and not final_db_snapshot_identifier:
563         raise SaltInvocationError(
564             "At least one of the following must"
565             " be specified: skip_final_snapshot"
566             " final_db_snapshot_identifier"
567         )
568     try:
569         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
570         if not conn:
571             return {"deleted": bool(conn)}
572         kwargs = {}
573         if locals()["skip_final_snapshot"] is not None:
574             kwargs["SkipFinalSnapshot"] = bool(locals()["skip_final_snapshot"])
575         if locals()["final_db_snapshot_identifier"] is not None:
576             kwargs["FinalDBSnapshotIdentifier"] = str(
577                 locals()["final_db_snapshot_identifier"]
578             )
579         res = conn.delete_db_instance(DBInstanceIdentifier=name, **kwargs)
580         if not wait_for_deletion:
581             return {
582                 "deleted": bool(res),
583                 "message": "Deleted RDS instance {}.".format(name),
584             }
585         start_time = time.time()
586         while True:
587             res = __salt__["boto_rds.exists"](
588                 name=name,
589                 tags=tags,
590                 region=region,
591                 key=key,
592                 keyid=keyid,
593                 profile=profile,
594             )
595             if not res.get("exists"):
596                 return {
597                     "deleted": bool(res),
598                     "message": "Deleted RDS instance {} completely.".format(name),
599                 }
600             if time.time() - start_time &gt; timeout:
601                 raise SaltInvocationError(
602                     "RDS instance {} has not been "
603                     "deleted completely after {} "
604                     "seconds".format(name, timeout)
605                 )
606             log.info(
607                 "Waiting up to %s seconds for RDS instance %s to be deleted.",
608                 timeout,
609                 name,
610             )
611             time.sleep(10)
612     except ClientError as e:
613         return {"error": __utils__["boto3.get_error"](e)}
614 def delete_option_group(name, region=None, key=None, keyid=None, profile=None):
615     try:
616         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
617         if not conn:
618             return {"deleted": bool(conn)}
619         res = conn.delete_option_group(OptionGroupName=name)
620         if not res:
621             return {
622                 "deleted": bool(res),
623                 "message": "Failed to delete RDS option group {}.".format(name),
624             }
625         return {
626             "deleted": bool(res),
627             "message": "Deleted RDS option group {}.".format(name),
628         }
629     except ClientError as e:
630         return {"error": __utils__["boto3.get_error"](e)}
631 def delete_parameter_group(name, region=None, key=None, keyid=None, profile=None):
632     try:
633         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
634         if not conn:
635             return {"results": bool(conn)}
636         r = conn.delete_db_parameter_group(DBParameterGroupName=name)
637         return {
638             "deleted": bool(r),
639             "message": "Deleted RDS parameter group {}.".format(name),
640         }
641     except ClientError as e:
642         return {"error": __utils__["boto3.get_error"](e)}
643 def delete_subnet_group(name, region=None, key=None, keyid=None, profile=None):
644     try:
645         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
646         if not conn:
647             return {"results": bool(conn)}
648         r = conn.delete_db_subnet_group(DBSubnetGroupName=name)
649         return {
650             "deleted": bool(r),
651             "message": "Deleted RDS subnet group {}.".format(name),
652         }
653     except ClientError as e:
654         return {"error": __utils__["boto3.get_error"](e)}
655 def describe_parameter_group(
656     name,
657     Filters=None,
658     MaxRecords=None,
659     Marker=None,
660     region=None,
661     key=None,
662     keyid=None,
663     profile=None,
664 ):
665     res = __salt__["boto_rds.parameter_group_exists"](
666         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
667     )
668     if not res.get("exists"):
669         return {"exists": bool(res)}
670     try:
671         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
672         if not conn:
673             return {"results": bool(conn)}
674         kwargs = {}
675         for key in ("Marker", "Filters"):
676             if locals()[key] is not None:
677                 kwargs[key] = str(locals()[key])
678         if locals()["MaxRecords"] is not None:
679             kwargs["MaxRecords"] = int(locals()["MaxRecords"])
680         info = conn.describe_db_parameter_groups(DBParameterGroupName=name, **kwargs)
681         if not info:
682             return {
683                 "results": bool(info),
684                 "message": "Failed to get RDS description for group {}.".format(name),
685             }
686         return {
687             "results": bool(info),
688             "message": "Got RDS descrition for group {}.".format(name),
689         }
690     except ClientError as e:
691         return {"error": __utils__["boto3.get_error"](e)}
692 def describe_parameters(
693     name,
694     Source=None,
695     MaxRecords=None,
696     Marker=None,
697     region=None,
698     key=None,
699     keyid=None,
700     profile=None,
701 ):
702     res = __salt__["boto_rds.parameter_group_exists"](
703         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
704     )
705     if not res.get("exists"):
706         return {
707             "result": False,
708             "message": "Parameter group {} does not exist".format(name),
709         }
710     try:
711         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
712         if not conn:
713             return {
714                 "result": False,
715                 "message": "Could not establish a connection to RDS",
716             }
717         kwargs = {}
718         kwargs.update({"DBParameterGroupName": name})
719         for key in ("Marker", "Source"):
720             if locals()[key] is not None:
721                 kwargs[key] = str(locals()[key])
722         if locals()["MaxRecords"] is not None:
723             kwargs["MaxRecords"] = int(locals()["MaxRecords"])
724         pag = conn.get_paginator("describe_db_parameters")
725         pit = pag.paginate(**kwargs)
726         keys = [
727             "ParameterName",
728             "ParameterValue",
729             "Description",
730             "Source",
731             "ApplyType",
732             "DataType",
733             "AllowedValues",
734             "IsModifieable",
735             "MinimumEngineVersion",
736             "ApplyMethod",
737         ]
738         parameters = odict.OrderedDict()
739         ret = {"result": True}
740         for p in pit:
741             for result in p["Parameters"]:
742                 data = odict.OrderedDict()
743                 for k in keys:
744                     data[k] = result.get(k)
745                 parameters[result.get("ParameterName")] = data
746         ret["parameters"] = parameters
747         return ret
748     except ClientError as e:
749         return {"error": __utils__["boto3.get_error"](e)}
750 def modify_db_instance(
751     name,
752     allocated_storage=None,
753     allow_major_version_upgrade=None,
754     apply_immediately=None,
755     auto_minor_version_upgrade=None,
756     backup_retention_period=None,
757     ca_certificate_identifier=None,
758     character_set_name=None,
759     copy_tags_to_snapshot=None,
760     db_cluster_identifier=None,
761     db_instance_class=None,
762     db_name=None,
763     db_parameter_group_name=None,
764     db_port_number=None,
765     db_security_groups=None,
766     db_subnet_group_name=None,
767     domain=None,
768     domain_iam_role_name=None,
769     engine_version=None,
770     iops=None,
771     kms_key_id=None,
772     license_model=None,
773     master_user_password=None,
774     monitoring_interval=None,
775     monitoring_role_arn=None,
776     multi_az=None,
777     new_db_instance_identifier=None,
778     option_group_name=None,
779     preferred_backup_window=None,
780     preferred_maintenance_window=None,
781     promotion_tier=None,
782     publicly_accessible=None,
783     storage_encrypted=None,
784     storage_type=None,
785     tde_credential_arn=None,
786     tde_credential_password=None,
787     vpc_security_group_ids=None,
788     region=None,
789     key=None,
790     keyid=None,
791     profile=None,
792 ):
793     res = __salt__["boto_rds.exists"](
794         name, tags=None, region=region, key=key, keyid=keyid, profile=profile
795     )
796     if not res.get("exists"):
797         return {
798             "modified": False,
799             "message": "RDS db instance {} does not exist.".format(name),
800         }
801     try:
802         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
803         if not conn:
804             return {"modified": False}
805         kwargs = {}
806         excluded = {"name"}
807         boto_params = set(boto3_param_map.keys())
808         keys = set(locals().keys())
809         for key in keys.intersection(boto_params).difference(excluded):
810             val = locals()[key]
811             if val is not None:
812                 mapped = boto3_param_map[key]
813                 kwargs[mapped[0]] = mapped[1](val)
814         info = conn.modify_db_instance(DBInstanceIdentifier=name, **kwargs)
815         if not info:
816             return {
817                 "modified": bool(info),
818                 "message": "Failed to modify RDS db instance {}.".format(name),
819             }
820         return {
821             "modified": bool(info),
822             "message": "Modified RDS db instance {}.".format(name),
823             "results": dict(info),
824         }
825     except ClientError as e:
826         return {"error": __utils__["boto3.get_error"](e)}
827 def _tag_doc(tags):
828     taglist = []
829     if tags is not None:
830         for k, v in tags.items():
831             if str(k).startswith("__"):
832                 continue
833             taglist.append({"Key": str(k), "Value": str(v)})
834     return taglist
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
