<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for boto_iam_role.py &amp; boto_rds_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_iam_role.py &amp; boto_rds_1.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_iam_role.py (3.716814%)<th>boto_rds_1.py (2.902557%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(363-376)<td><a href="#" name="0">(755-766)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(104-182)<td><a href="#" name="1">(225-247)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(432-440)<td><a href="#" name="2">(814-826)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam_role.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage IAM roles
================

.. versionadded:: 2014.7.0

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit IAM credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    iam.keyid: GKTADJGHEIQSXMKKRBJ08H
    iam.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    myprofile:
        keyid: GKTADJGHEIQSXMKKRBJ08H
        key: askjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
        region: us-east-1

Creating a role will automatically create an instance profile and associate it
with the role. This is the default behavior of the AWS console.

.. code-block:: yaml

    myrole:
        boto_iam_role.present:
            - region: us-east-1
            - key: GKTADJGHEIQSXMKKRBJ08H
            - keyid: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            - policies_from_pillars:
                - shared_iam_bootstrap_policy
            - policies:
                MySQSPolicy:
                    Statement:
                      - Action:
                            - sqs:*
                        Effect: Allow
                        Resource:
                            - arn:aws:sqs:*:*:*
                        Sid: MyPolicySQS1
                MyS3Policy:
                    Statement:
                      - Action:
                            - s3:GetObject
                        Effect: Allow
                        Resource:
                            - arn:aws:s3:*:*:mybucket/*

    # Using a credentials profile from pillars
    myrole:
        boto_iam_role.present:
            - profile: myiamprofile

    # Passing in a credentials profile
    myrole:
        boto_iam_role.present:
            - profile:
                key: GKTADJGHEIQSXMKKRBJ08H
                keyid: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
                region: us-east-1

If ``delete_policies: False`` is specified, existing policies that are not in
the given list of policies will not be deleted. This allows manual modifications
on the IAM role to be persistent. This functionality was added in 2015.8.0.

.. note::

    When using the ``profile`` parameter and ``region`` is set outside of
    the profile group, region is ignored and a default region will be used.

    If ``region`` is missing from the ``profile`` data set, ``us-east-1``
    will be used as the default region.

"""

import logging

import salt.utils.dictdiffer
import salt.utils.dictupdate as dictupdate
from salt.utils.odict import OrderedDict

log = logging.getLogger(__name__)


def __virtual__():
    """
    Only load if boto is available.
<a name="1"></a>    """
    if "boto_iam.role_exists" in __salt__:
        return "boto_iam_role"
    return (F<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>alse, "boto_iam module could not be loaded")


def present(
    name,
    policy_document=None,
    policy_document_from_pillars=None,
    path=None,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    create_instance_profile=True,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    """
    Ensure the IAM role exists.

    name
        Name of the IAM role.

    policy_document
        The policy that grants an entity permission to assume the role.
        (See https://boto.readthedocs.io/en/latest/ref/iam.html#boto.iam.connection.IAMConnection.create_role)

    policy_document_from_pillars
        A pillar key that contains a role policy document. The statements
        defined here will be appended with the policy document statements
        defined in the policy_document argument.

        .. versionadded:: 2017.7.0

    path
        The path to the role/instance profile.
        (See https://boto.readthedocs.io/en/latest/ref/iam.html#boto.iam.connection.IAMConnection.create_role)

    policies
        A dict of IAM role policies.

    policies_from_pillars
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies
        A list of (AWS or Customer) managed policies to be attached to the role.

    create_instance_profile
        A boolean of whether or not to create an instance profile and associate
        it with this role.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.

    delete_policies
        Deletes existing policies that are not in the given list of policies. Default
        value is ``True``. If ``False`` is specified, existing policies will not be deleted
        allowing manual modifications on the IAM role to be persistent.

        .. versionadded:: 2015.8.0
    """
    ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
    # Build up _policy_document
    _policy_document = {}
    if policy_document_from_pillars:
        from_pillars = __salt__["pillar.get"](policy_document_from_pillars)
        if from_pillars:
            _policy_document["Version"] = from_pillars["Version"]
            _policy_document.setdefault("Statement", [])
            _policy_document["Statement"].extend(from_pillars["Statement"])
    if policy_document:
        _policy_document["Version"] = policy_document["Version"]
        _policy_document.setdefault("Statement", [])
        _policy_document["Statement"].extend(policy_document["Statement"])
    _ret = _role_present(name, _policy_document, path, region, key, keyid, profile)

    # Build up _policies
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__["pillar.get"](policy)
        _policies.update(_policy)
    _policies.update(policies)
    ret["changes"] = _ret["changes"]
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            return ret
    if create_instance_profile:
        _ret = _instance_profile_present(name, region, key, keyid, profile)
        ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
        _ret = _instance_profile_associated(name, region, key, keyid, profile)
        ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    _ret = _policies_present(
        name, _policies, region, key, keyid, profile, delete_policies
    )
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
    _ret = _policies_attached(name, managed_policies, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
    return ret


def _role_present(
    name,
    policy_document=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"result": True, "comment": "", "changes": {}}
    role = __salt__["boto_iam.describe_role"](name, region, key, keyid, profile)
    if not role:
        if __opts__["test"]:
            ret["comment"] = "IAM role {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_role"](
            name, policy_document, path, region, key, keyid, profile
        )
        if created:
            ret["changes"]["old"] = {"role": None}
            ret["changes"]["new"] = {"role": name}
            ret["comment"] = "IAM role {} created.".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "Failed to create {} IAM role.".format(name)
    else:
        ret["comment"] = "{} role present.".format(name)
        if not policy_document:
            _policy_document = __salt__["boto_iam.build_policy"](
                region, key, keyid, profile
            )
        else:
            _policy_document = policy_document
        if salt.utils.dictdiffer.deep_diff(
            _sort_policy(role["assume_role_policy_document"]),
            _sort_policy(_policy_document),
        ):
            if __opts__["test"]:
                msg = "Assume role policy document to be updated."
                ret["comment"] = "{} {}".format(ret["comment"], msg)
                ret["result"] = None
                return ret
            updated = __salt__["boto_iam.update_assume_role_policy"](
                name, _policy_document, region, key, keyid, profile
            )
            if updated:
                msg = "Assume role policy document updated."
                ret["comment"] = "{} {}".format(ret["comment"], msg)
                ret["changes"]["old"] = {
                    "policy_document": role["assume_role_policy_document"]
                }
                ret["changes"]["new"] = {"policy_document": _policy_document}
            else:
                ret["result"] = False
                msg = "Failed to update assume role policy."
                ret["comment"] = "{} {}".format(ret["comment"], msg)
    return ret


def _instance_profile_present(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_iam.instance_profile_exists"](
        name, region, key, keyid, profile
    )
    if not exists:
        if __opts__["test"]:
            ret["comment"] = "Instance profile {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_instance_profile"](
            name, region, key, keyid, profile
        )
        if created:
            ret["changes"]["old"] = {"instance_profile": None}
            ret["changes"]["new"] = {"instance_profile": name}
            ret["comment"] = "Instance profile {} created.".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "Failed to create {} instance profile.".format(name)
    return ret


def _instance_profile_associated(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    is_associated = __salt__["boto_iam.profile_associated"](
        name, name, region, key, keyid, profile
    )
    if not is_associated:
        if __opts__["test"]:
            ret["comment"] = "Instance profile {} is set to be associated.".format(name)
            ret["result"] = None
            return ret
        associated = __salt__["boto_iam.associate_profile_to_role"](
            name, name, region, key, keyid, profile
        )
        if associated:
            ret["changes"]["old"] = {"profile_associated": None}
            ret["changes"]["new"] = {"profile_associated": True}
            ret["comment"] = "Instance profile {} associated.".format(name)
        else:
            ret["result"] = False
            ret[
                "comment"
            ] = "Failed to associate {0} instance profile with {0} role.".format(name)
    return ret


def _sort_policy(doc):
    """
    List-type sub-items in policies don't happen to be order-sensitive, but
    compare operations will render them unequal, leading to non-idempotent
    state runs.  We'll sort any list-type subitems before comparison to reduce
    the likelihood of false negatives.
    """
<a name="0"></a>    if isinstance(doc, list):
        return sorted(_sort_policy(i) for i in doc)
    elif isinstance(doc, (dict, OrderedDict)):
        return {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>k: _sort_policy(v) for k, v in doc.items()}
    return doc


def _policies_present(
    name,
    policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret =</b></font> {"result": True, "comment": "", "changes": {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        _policy = __salt__["boto_iam.get_role_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != policy:
            policies_to_create[policy_name] = policy
    _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
    for policy_name in _list:
        if delete_policies and policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on role {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"policies": _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__["boto_iam.create_role_policy"](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_role_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to role {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__["boto_iam.delete_role_policy"](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_role_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from role {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_role_policies"](
            name, region, key, keyid, profile
<a name="2"></a>        )
        ret["changes"]["new"] = {"policies": _list}
        ret["comment"] = "{} policies modified on role {}.".format(
            ", "<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(_list), name
        )
    return ret


def _policies_attached(
    name, managed_policies=None, region=None, key=None, keyid=None, profile=None
):
    ret =</b></font> {"result": True, "comment": "", "changes": {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__["boto_iam.list_entities_for_policy"](
            policy,
            entity_filter="Role",
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for roledict in entities.get("policy_roles", []):
            if name == roledict.get("role_name"):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__["boto_iam.list_attached_role_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    for policy_data in _list:
        if (
            policy_data.get("policy_name") not in managed_policies
            and policy_data.get("policy_arn") not in managed_policies
        ):
            policies_to_detach.append(policy_data.get("policy_arn"))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on role {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"managed_policies": oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__["boto_iam.attach_role_policy"](
                policy_name,
                role_name=name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_attached_role_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to role {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__["boto_iam.detach_role_policy"](
                policy_name,
                role_name=name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_attached_role_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from role {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_attached_role_policies"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get("policy_arn") for x in _list]
        log.debug(newpolicies)
        ret["changes"]["new"] = {"managed_policies": newpolicies}
        ret["comment"] = "{} policies modified on role {}.".format(
            ", ".join(newpolicies), name
        )
    return ret


def absent(name, region=None, key=None, keyid=None, profile=None):
    """
    Ensure the IAM role is deleted.

    name
        Name of the IAM role.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    _ret = _policies_absent(name, region, key, keyid, profile)
    ret["changes"] = _ret["changes"]
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            return ret
    _ret = _policies_detached(name, region, key, keyid, profile)
    ret["changes"] = _ret["changes"]
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            return ret
    _ret = _instance_profile_disassociated(name, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            return ret
    _ret = _instance_profile_absent(name, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            return ret
    _ret = _role_absent(name, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
    return ret


def _role_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}

    exists = __salt__["boto_iam.role_exists"](name, region, key, keyid, profile)
    if exists:
        if __opts__["test"]:
            ret["comment"] = "IAM role {} is set to be removed.".format(name)
            ret["result"] = None
            return ret
        deleted = __salt__["boto_iam.delete_role"](name, region, key, keyid, profile)
        if deleted:
            ret["changes"]["old"] = {"role": name}
            ret["changes"]["new"] = {"role": None}
            ret["comment"] = "IAM role {} removed.".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "Failed to delete {} iam role.".format(name)
    else:
        ret["comment"] = "{} role does not exist.".format(name)
    return ret


def _instance_profile_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}

    exists = __salt__["boto_iam.instance_profile_exists"](
        name, region, key, keyid, profile
    )
    if exists:
        if __opts__["test"]:
            ret["comment"] = "Instance profile {} is set to be removed.".format(name)
            ret["result"] = None
            return ret
        deleted = __salt__["boto_iam.delete_instance_profile"](
            name, region, key, keyid, profile
        )
        if deleted:
            ret["changes"]["old"] = {"instance_profile": name}
            ret["changes"]["new"] = {"instance_profile": None}
            ret["comment"] = "Instance profile {} removed.".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "Failed to delete {} instance profile.".format(name)
    else:
        ret["comment"] = "{} instance profile does not exist.".format(name)
    return ret


def _policies_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
    if not _list:
        ret["comment"] = "No policies in role {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be removed from role {}.".format(
            ", ".join(_list), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"policies": _list}
    for policy_name in _list:
        policy_unset = __salt__["boto_iam.delete_role_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_role_policies"](
                name, region, key, keyid, profile
            )
            ret["changes"]["new"] = {"policies": _list}
            ret["result"] = False
            ret["comment"] = "Failed to add policy {} to role {}".format(
                policy_name, name
            )
            return ret
    _list = __salt__["boto_iam.list_role_policies"](name, region, key, keyid, profile)
    ret["changes"]["new"] = {"policies": _list}
    ret["comment"] = "{} policies removed from role {}.".format(", ".join(_list), name)
    return ret


def _policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    _list = __salt__["boto_iam.list_attached_role_policies"](
        role_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    if not _list:
        ret["comment"] = "No attached policies in role {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be detached from role {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"managed_policies": oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__["boto_iam.detach_role_policy"](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_attached_role_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get("policy_arn") for x in _list]
            ret["changes"]["new"] = {"managed_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from role {}".format(policy_arn, name)
            return ret
    _list = __salt__["boto_iam.list_attached_role_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get("policy_arn") for x in _list]
    ret["changes"]["new"] = {"managed_policies": newpolicies}
    ret["comment"] = "{} policies detached from role {}.".format(
        ", ".join(newpolicies), name
    )
    return ret


def _instance_profile_disassociated(
    name, region=None, key=None, keyid=None, profile=None
):
    ret = {"result": True, "comment": "", "changes": {}}
    is_associated = __salt__["boto_iam.profile_associated"](
        name, name, region, key, keyid, profile
    )
    if is_associated:
        if __opts__["test"]:
            ret["comment"] = "Instance profile {} is set to be disassociated.".format(
                name
            )
            ret["result"] = None
            return ret
        associated = __salt__["boto_iam.disassociate_profile_from_role"](
            name, name, region, key, keyid, profile
        )
        if associated:
            ret["changes"]["old"] = {"profile_associated": True}
            ret["changes"]["new"] = {"profile_associated": False}
            ret["comment"] = "Instance profile {} disassociated.".format(name)
        else:
            ret["result"] = False
            ret[
                "comment"
            ] = "Failed to disassociate {0} instance profile from {0} role.".format(
                name
            )
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_rds_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Connection module for Amazon RDS

.. versionadded:: 2015.8.0

:configuration: This module accepts explicit rds credentials but can also
    utilize IAM roles assigned to the instance through Instance Profiles.
    Dynamic credentials are then automatically obtained from AWS API and no
    further configuration is necessary. More Information available at:

    .. code-block:: text

        http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

    If IAM roles are not used you need to specify them either in a pillar or
    in the minion's config file:

    .. code-block:: yaml

        rds.keyid: GKTADJGHEIQSXMKKRBJ08H
        rds.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    A region may also be specified in the configuration:

    .. code-block:: yaml

        rds.region: us-east-1

    If a region is not specified, the default is us-east-1.

    It's also possible to specify key, keyid and region via a profile, either
    as a passed in dict, or as a string to pull from pillars or minion config:

    .. code-block:: yaml

        myprofile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

:depends: boto3
"""
# keep lint from choking on _get_conn and _cache_id
# pylint: disable=E0602
# pylint whinging perfectly valid code
# pylint: disable=W0106


import logging
import time

import salt.utils.compat
import salt.utils.odict as odict
import salt.utils.versions
from salt.exceptions import SaltInvocationError

log = logging.getLogger(__name__)


# pylint: disable=import-error
try:
    # pylint: disable=unused-import
    import boto
    import boto3

    # pylint: enable=unused-import
    from botocore.exceptions import ClientError

    logging.getLogger("boto").setLevel(logging.CRITICAL)
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
# pylint: enable=import-error

boto3_param_map = {
    "allocated_storage": ("AllocatedStorage", int),
    "allow_major_version_upgrade": ("AllowMajorVersionUpgrade", bool),
    "apply_immediately": ("ApplyImmediately", bool),
    "auto_minor_version_upgrade": ("AutoMinorVersionUpgrade", bool),
    "availability_zone": ("AvailabilityZone", str),
    "backup_retention_period": ("BackupRetentionPeriod", int),
    "ca_certificate_identifier": ("CACertificateIdentifier", str),
    "character_set_name": ("CharacterSetName", str),
    "copy_tags_to_snapshot": ("CopyTagsToSnapshot", bool),
    "db_cluster_identifier": ("DBClusterIdentifier", str),
    "db_instance_class": ("DBInstanceClass", str),
    "db_name": ("DBName", str),
    "db_parameter_group_name": ("DBParameterGroupName", str),
    "db_port_number": ("DBPortNumber", int),
    "db_security_groups": ("DBSecurityGroups", list),
    "db_subnet_group_name": ("DBSubnetGroupName", str),
    "domain": ("Domain", str),
    "domain_iam_role_name": ("DomainIAMRoleName", str),
    "engine": ("Engine", str),
    "engine_version": ("EngineVersion", str),
    "iops": ("Iops", int),
    "kms_key_id": ("KmsKeyId", str),
    "license_model": ("LicenseModel", str),
    "master_user_password": ("MasterUserPassword", str),
    "master_username": ("MasterUsername", str),
    "monitoring_interval": ("MonitoringInterval", int),
    "monitoring_role_arn": ("MonitoringRoleArn", str),
    "multi_az": ("MultiAZ", bool),
    "name": ("DBInstanceIdentifier", str),
    "new_db_instance_identifier": ("NewDBInstanceIdentifier", str),
    "option_group_name": ("OptionGroupName", str),
    "port": ("Port", int),
    "preferred_backup_window": ("PreferredBackupWindow", str),
    "preferred_maintenance_window": ("PreferredMaintenanceWindow", str),
    "promotion_tier": ("PromotionTier", int),
    "publicly_accessible": ("PubliclyAccessible", bool),
    "storage_encrypted": ("StorageEncrypted", bool),
    "storage_type": ("StorageType", str),
    "tags": ("Tags", list),
    "tde_credential_arn": ("TdeCredentialArn", str),
    "tde_credential_password": ("TdeCredentialPassword", str),
    "vpc_security_group_ids": ("VpcSecurityGroupIds", list),
}


def __virtual__():
    """
    Only load if boto libraries exist and if boto libraries are greater than
    a given version.
    """
    return salt.utils.versions.check_boto_reqs(boto3_ver="1.3.1")


def __init__(opts):
    if HAS_BOTO:
        __utils__["boto3.assign_funcs"](__name__, "rds")


def exists(name, tags=None, region=None, key=None, keyid=None, profile=None):
    """
    Check to see if an RDS exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.exists myrds region=us-east-1
    """
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    try:
        rds = conn.describe_db_instances(DBInstanceIdentifier=name)
        return {"exists": bool(rds)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def option_group_exists(
    name, tags=None, region=None, key=None, keyid=None, profile=None
):
    """
    Check to see if an RDS option group exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.option_group_exists myoptiongr region=us-east-1
    """
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    try:
        rds = conn.describe_option_groups(OptionGroupName=name)
        return {"exists": bool(rds)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def parameter_group_exists(
    name, tags=None, region=None, key=None, keyid=None, profile=None
):
    """
    Check to see if an RDS parameter group exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.parameter_group_exists myparametergroup \
                region=us-east-1
    """
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    try:
        rds = conn.describe_db_parameter_groups(DBParameterGroupName=name)
        return {"exists": bool(rds), "error": None}
    except ClientError as e:
        resp = {}
        if e.response["Error"]["Code"] == "DBParameterGroupNotFound":
            resp["exists"] = False
        resp["error"] = __utils__["boto3.get_error"](e)
        return resp


def subnet_group_exists(
    name, tags=None, region=None, key=None, keyid=None, profile=None
):
    """
    Check to see if an RDS subnet group exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.subnet_group_exists my-param-group \
                region=us-east-1
    """
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"exists": bool(conn)}

        rds = conn.describe_db_subnet_groups(DBSubnetGroupName=name)
        return {"exists": bool(rds)}
    except ClientError as e:
<a name="1"></a>        if "DBSubnetGroupNotFoundFault" in e.message:
            return {"exists": False}
        else:
            return {"error": __utils__["boto3.get_error"](e<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>)}


def create(
    name,
    allocated_storage,
    db_instance_class,
    engine,
    master_username,
    master_user_password,
    db_name=None,
    db_security_groups=None,
    vpc_security_group_ids=None,
    vpc_security_groups=None,
    availability_zone=None,
    db_subnet_group_name=None,
    preferred_maintenance_window=None,
    db_parameter_group_name=None,
    backup_retention_period=None,
    preferred_backup_window=None,
    port=None,
    multi_az=None,
    engine_version=</b></font>None,
    auto_minor_version_upgrade=None,
    license_model=None,
    iops=None,
    option_group_name=None,
    character_set_name=None,
    publicly_accessible=None,
    wait_status=None,
    tags=None,
    db_cluster_identifier=None,
    storage_type=None,
    tde_credential_arn=None,
    tde_credential_password=None,
    storage_encrypted=None,
    kms_key_id=None,
    domain=None,
    copy_tags_to_snapshot=None,
    monitoring_interval=None,
    monitoring_role_arn=None,
    domain_iam_role_name=None,
    region=None,
    promotion_tier=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Create an RDS Instance

    CLI example to create an RDS Instance::

        salt myminion boto_rds.create myrds 10 db.t2.micro MySQL sqlusr sqlpassw
    """
    if not allocated_storage:
        raise SaltInvocationError("allocated_storage is required")
    if not db_instance_class:
        raise SaltInvocationError("db_instance_class is required")
    if not engine:
        raise SaltInvocationError("engine is required")
    if not master_username:
        raise SaltInvocationError("master_username is required")
    if not master_user_password:
        raise SaltInvocationError("master_user_password is required")
    if availability_zone and multi_az:
        raise SaltInvocationError(
            "availability_zone and multi_az are mutually exclusive arguments."
        )
    if wait_status:
        wait_stati = ["available", "modifying", "backing-up"]
        if wait_status not in wait_stati:
            raise SaltInvocationError(
                "wait_status can be one of: {}".format(wait_stati)
            )
    if vpc_security_groups:
        v_tmp = __salt__["boto_secgroup.convert_to_group_ids"](
            groups=vpc_security_groups,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        vpc_security_group_ids = (
            vpc_security_group_ids + v_tmp if vpc_security_group_ids else v_tmp
        )

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        kwargs = {}
        boto_params = set(boto3_param_map.keys())
        keys = set(locals().keys())
        tags = _tag_doc(tags)

        for param_key in keys.intersection(boto_params):
            val = locals()[param_key]
            if val is not None:
                mapped = boto3_param_map[param_key]
                kwargs[mapped[0]] = mapped[1](val)

        # Validation doesn't want parameters that are None
        # https://github.com/boto/boto3/issues/400
        kwargs = {k: v for k, v in kwargs.items() if v is not None}

        rds = conn.create_db_instance(**kwargs)

        if not rds:
            return {"created": False}
        if not wait_status:
            return {
                "created": True,
                "message": "RDS instance {} created.".format(name),
            }

        while True:
            jmespath = "DBInstances[*].DBInstanceStatus"
            status = describe_db_instances(
                name=name,
                jmespath=jmespath,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if status:
                stat = status[0]
            else:
                # Whoops, something is horribly wrong...
                return {
                    "created": False,
                    "error": (
                        "RDS instance {} should have been created but"
                        " now I can't find it.".format(name)
                    ),
                }
            if stat == wait_status:
                return {
                    "created": True,
                    "message": "RDS instance {} created (current status {})".format(
                        name, stat
                    ),
                }
            time.sleep(10)
            log.info("Instance status after 10 seconds is: %s", stat)

    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def create_read_replica(
    name,
    source_name,
    db_instance_class=None,
    availability_zone=None,
    port=None,
    auto_minor_version_upgrade=None,
    iops=None,
    option_group_name=None,
    publicly_accessible=None,
    tags=None,
    db_subnet_group_name=None,
    storage_type=None,
    copy_tags_to_snapshot=None,
    monitoring_interval=None,
    monitoring_role_arn=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Create an RDS read replica

    CLI example to create an RDS  read replica::

        salt myminion boto_rds.create_read_replica replicaname source_name
    """
    if not backup_retention_period:
        raise SaltInvocationError("backup_retention_period is required")
    res = __salt__["boto_rds.exists"](source_name, tags, region, key, keyid, profile)
    if not res.get("exists"):
        return {
            "exists": bool(res),
            "message": "RDS instance source {} does not exists.".format(source_name),
        }

    res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
    if res.get("exists"):
        return {
            "exists": bool(res),
            "message": "RDS replica instance {} already exists.".format(name),
        }

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        kwargs = {}
        for key in ("OptionGroupName", "MonitoringRoleArn"):
            if locals()[key] is not None:
                kwargs[key] = str(locals()[key])

        for key in ("MonitoringInterval", "Iops", "Port"):
            if locals()[key] is not None:
                kwargs[key] = int(locals()[key])

        for key in ("CopyTagsToSnapshot", "AutoMinorVersionUpgrade"):
            if locals()[key] is not None:
                kwargs[key] = bool(locals()[key])

        taglist = _tag_doc(tags)

        rds_replica = conn.create_db_instance_read_replica(
            DBInstanceIdentifier=name,
            SourceDBInstanceIdentifier=source_name,
            DBInstanceClass=db_instance_class,
            AvailabilityZone=availability_zone,
            PubliclyAccessible=publicly_accessible,
            Tags=taglist,
            DBSubnetGroupName=db_subnet_group_name,
            StorageType=storage_type,
            **kwargs
        )

        return {"exists": bool(rds_replica)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def create_option_group(
    name,
    engine_name,
    major_engine_version,
    option_group_description,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Create an RDS option group

    CLI example to create an RDS option group::

        salt myminion boto_rds.create_option_group my-opt-group mysql 5.6 \
                "group description"
    """
    res = __salt__["boto_rds.option_group_exists"](
        name, tags, region, key, keyid, profile
    )
    if res.get("exists"):
        return {"exists": bool(res)}

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        taglist = _tag_doc(tags)
        rds = conn.create_option_group(
            OptionGroupName=name,
            EngineName=engine_name,
            MajorEngineVersion=major_engine_version,
            OptionGroupDescription=option_group_description,
            Tags=taglist,
        )

        return {"exists": bool(rds)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def create_parameter_group(
    name,
    db_parameter_group_family,
    description,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Create an RDS parameter group

    CLI example to create an RDS parameter group::

        salt myminion boto_rds.create_parameter_group my-param-group mysql5.6 \
                "group description"
    """
    res = __salt__["boto_rds.parameter_group_exists"](
        name, tags, region, key, keyid, profile
    )
    if res.get("exists"):
        return {"exists": bool(res)}

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        taglist = _tag_doc(tags)
        rds = conn.create_db_parameter_group(
            DBParameterGroupName=name,
            DBParameterGroupFamily=db_parameter_group_family,
            Description=description,
            Tags=taglist,
        )
        if not rds:
            return {
                "created": False,
                "message": "Failed to create RDS parameter group {}".format(name),
            }

        return {
            "exists": bool(rds),
            "message": "Created RDS parameter group {}".format(name),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def create_subnet_group(
    name,
    description,
    subnet_ids,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Create an RDS subnet group

    CLI example to create an RDS subnet group::

        salt myminion boto_rds.create_subnet_group my-subnet-group \
            "group description" '[subnet-12345678, subnet-87654321]' \
            region=us-east-1
    """
    res = __salt__["boto_rds.subnet_group_exists"](
        name, tags, region, key, keyid, profile
    )
    if res.get("exists"):
        return {"exists": bool(res)}

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        taglist = _tag_doc(tags)
        rds = conn.create_db_subnet_group(
            DBSubnetGroupName=name,
            DBSubnetGroupDescription=description,
            SubnetIds=subnet_ids,
            Tags=taglist,
        )

        return {"created": bool(rds)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def update_parameter_group(
    name,
    parameters,
    apply_method="pending-reboot",
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Update an RDS parameter group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.update_parameter_group my-param-group \
                parameters='{"back_log":1, "binlog_cache_size":4096}' \
                region=us-east-1
    """

    res = __salt__["boto_rds.parameter_group_exists"](
        name, tags, region, key, keyid, profile
    )
    if not res.get("exists"):
        return {
            "exists": bool(res),
            "message": "RDS parameter group {} does not exist.".format(name),
        }

    param_list = []
    for key, value in parameters.items():
        item = odict.OrderedDict()
        item.update({"ParameterName": key})
        item.update({"ApplyMethod": apply_method})
        if type(value) is bool:
            item.update({"ParameterValue": "on" if value else "off"})
        else:
            item.update({"ParameterValue": str(value)})
        param_list.append(item)

    if not param_list:
        return {"results": False}

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        res = conn.modify_db_parameter_group(
            DBParameterGroupName=name, Parameters=param_list
        )
        return {"results": bool(res)}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def describe(name, tags=None, region=None, key=None, keyid=None, profile=None):
    """
    Return RDS instance details.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.describe myrds

    """
    res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
    if not res.get("exists"):
        return {
            "exists": bool(res),
            "message": "RDS instance {} does not exist.".format(name),
        }

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        rds = conn.describe_db_instances(DBInstanceIdentifier=name)
        rds = [
            i
            for i in rds.get("DBInstances", [])
            if i.get("DBInstanceIdentifier") == name
        ].pop(0)

        if rds:
            keys = (
                "DBInstanceIdentifier",
                "DBInstanceClass",
                "Engine",
                "DBInstanceStatus",
                "DBName",
                "AllocatedStorage",
                "PreferredBackupWindow",
                "BackupRetentionPeriod",
                "AvailabilityZone",
                "PreferredMaintenanceWindow",
                "LatestRestorableTime",
                "EngineVersion",
                "AutoMinorVersionUpgrade",
                "LicenseModel",
                "Iops",
                "CharacterSetName",
                "PubliclyAccessible",
                "StorageType",
                "TdeCredentialArn",
                "DBInstancePort",
                "DBClusterIdentifier",
                "StorageEncrypted",
                "KmsKeyId",
                "DbiResourceId",
                "CACertificateIdentifier",
                "CopyTagsToSnapshot",
                "MonitoringInterval",
                "MonitoringRoleArn",
                "PromotionTier",
                "DomainMemberships",
            )
            return {"rds": {k: rds.get(k) for k in keys}}
        else:
            return {"rds": None}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
    except IndexError:
        return {"rds": None}


def describe_db_instances(
    name=None,
    filters=None,
    jmespath="DBInstances",
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Return a detailed listing of some, or all, DB Instances visible in the
    current scope.  Arbitrary subelements or subsections of the returned dataset
    can be selected by passing in a valid JMSEPath filter as well.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.describe_db_instances jmespath='DBInstances[*].DBInstanceIdentifier'

    """
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    pag = conn.get_paginator("describe_db_instances")
    args = {}
    args.update({"DBInstanceIdentifier": name}) if name else None
    args.update({"Filters": filters}) if filters else None
    pit = pag.paginate(**args)
    pit = pit.search(jmespath) if jmespath else pit
    try:
        return [p for p in pit]
<a name="0"></a>    except ClientError as e:
        code = getattr(e, "response", {}).get("Error", {}).get("Code")
        if code != "DBInstanceNotFound":
            log<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.error(__utils__["boto3.get_error"](e))
    return []


def describe_db_subnet_groups(
    name=None,
    filters=None,
    jmespath="DBSubnetGroups",
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    """
    Return a detailed listing of some, or all, DB Subnet Groups visible in the
    current scope.  Arbitrary subelements or subsections of the returned dataset
    can be selected by passing in a valid JMSEPath filter as well.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.describe_db_subnet_groups

    """
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    pag = conn.get_paginator("describe_db_subnet_groups")
    args = {}
    args.update({"DBSubnetGroupName": name}) if name else None
    args.update({"Filters": filters}) if filters else None
    pit = pag.paginate(**args)
    pit = pit.search(jmespath) if jmespath else pit
    return [p for p in pit]


def get_endpoint(name, tags=None, region=None, key=None, keyid=None, profile=None):
    """
    Return the endpoint of an RDS instance.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.get_endpoint myrds

    """
    endpoint = False
    res = __salt__["boto_rds.exists"](name, tags, region, key, keyid, profile)
    if res.get("exists"):
        try:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            if conn:
                rds = conn.describe_db_instances(DBInstanceIdentifier=name)

                if rds and "Endpoint" in rds["DBInstances"][0]:
                    endpoint = rds["DBInstances"][0]["Endpoint"]["Address"]
<a name="2"></a>                    return endpoint

        except ClientError as e:
            return {"error": __utils__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto3.get_error"](e)}

    return endpoint


def delete(
    name,
    skip_final_snapshot=None,
    final_db_snapshot_identifier=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
    tags=None,
    wait_for_deletion=True,
    timeout=180,
):
    """
    Delete an RDS instance.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.delete myrds skip_final_snapshot=True \
                region=us-east-1
    """
    if timeout == 180 and not skip_final_snapshot:
        timeout = 420

    if not skip_final_snapshot and not final_db_snapshot_identifier:
        raise SaltInvocationError(
            "At least one of the following must"
            " be specified: skip_final_snapshot"
            " final_db_snapshot_identifier"
        )

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"deleted": bool(conn)}

        kwargs = {}
        if locals()["skip_final_snapshot"] is not None:
            kwargs["SkipFinalSnapshot"] = bool(locals()["skip_final_snapshot"])

        if locals()["final_db_snapshot_identifier"] is not None:
            kwargs["FinalDBSnapshotIdentifier"] = str(
                locals()["final_db_snapshot_identifier"]
            )

        res = conn.delete_db_instance(DBInstanceIdentifier=name, **kwargs)

        if not wait_for_deletion:
            return {
                "deleted": bool(res),
                "message": "Deleted RDS instance {}.".format(name),
            }

        start_time = time.time()
        while True:
            res = __salt__["boto_rds.exists"](
                name=name,
                tags=tags,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not res.get("exists"):
                return {
                    "deleted": bool(res),
                    "message": "Deleted RDS instance {} completely.".format(name),
                }

            if time.time() - start_time &gt; timeout:
                raise SaltInvocationError(
                    "RDS instance {} has not been "
                    "deleted completely after {} "
                    "seconds".format(name, timeout)
                )
            log.info(
                "Waiting up to %s seconds for RDS instance %s to be deleted.",
                timeout,
                name,
            )
            time.sleep(10)
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def delete_option_group(name, region=None, key=None, keyid=None, profile=None):
    """
    Delete an RDS option group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.delete_option_group my-opt-group \
                region=us-east-1
    """
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"deleted": bool(conn)}

        res = conn.delete_option_group(OptionGroupName=name)
        if not res:
            return {
                "deleted": bool(res),
                "message": "Failed to delete RDS option group {}.".format(name),
            }

        return {
            "deleted": bool(res),
            "message": "Deleted RDS option group {}.".format(name),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def delete_parameter_group(name, region=None, key=None, keyid=None, profile=None):
    """
    Delete an RDS parameter group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.delete_parameter_group my-param-group \
                region=us-east-1
    """
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        r = conn.delete_db_parameter_group(DBParameterGroupName=name)
        return {
            "deleted": bool(r),
            "message": "Deleted RDS parameter group {}.".format(name),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def delete_subnet_group(name, region=None, key=None, keyid=None, profile=None):
    """
    Delete an RDS subnet group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_rds.delete_subnet_group my-subnet-group \
                region=us-east-1
    """
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        r = conn.delete_db_subnet_group(DBSubnetGroupName=name)
        return {
            "deleted": bool(r),
            "message": "Deleted RDS subnet group {}.".format(name),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def describe_parameter_group(
    name,
    Filters=None,
    MaxRecords=None,
    Marker=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Returns a list of `DBParameterGroup` descriptions.
    CLI example to description of parameter group::

        salt myminion boto_rds.describe_parameter_group parametergroupname\
            region=us-east-1
    """
    res = __salt__["boto_rds.parameter_group_exists"](
        name, tags=None, region=region, key=key, keyid=keyid, profile=profile
    )
    if not res.get("exists"):
        return {"exists": bool(res)}

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"results": bool(conn)}

        kwargs = {}
        for key in ("Marker", "Filters"):
            if locals()[key] is not None:
                kwargs[key] = str(locals()[key])

        if locals()["MaxRecords"] is not None:
            kwargs["MaxRecords"] = int(locals()["MaxRecords"])

        info = conn.describe_db_parameter_groups(DBParameterGroupName=name, **kwargs)

        if not info:
            return {
                "results": bool(info),
                "message": "Failed to get RDS description for group {}.".format(name),
            }

        return {
            "results": bool(info),
            "message": "Got RDS descrition for group {}.".format(name),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def describe_parameters(
    name,
    Source=None,
    MaxRecords=None,
    Marker=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Returns a list of `DBParameterGroup` parameters.
    CLI example to description of parameters ::

        salt myminion boto_rds.describe_parameters parametergroupname\
            region=us-east-1
    """
    res = __salt__["boto_rds.parameter_group_exists"](
        name, tags=None, region=region, key=key, keyid=keyid, profile=profile
    )
    if not res.get("exists"):
        return {
            "result": False,
            "message": "Parameter group {} does not exist".format(name),
        }

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {
                "result": False,
                "message": "Could not establish a connection to RDS",
            }

        kwargs = {}
        kwargs.update({"DBParameterGroupName": name})
        for key in ("Marker", "Source"):
            if locals()[key] is not None:
                kwargs[key] = str(locals()[key])

        if locals()["MaxRecords"] is not None:
            kwargs["MaxRecords"] = int(locals()["MaxRecords"])

        pag = conn.get_paginator("describe_db_parameters")
        pit = pag.paginate(**kwargs)

        keys = [
            "ParameterName",
            "ParameterValue",
            "Description",
            "Source",
            "ApplyType",
            "DataType",
            "AllowedValues",
            "IsModifieable",
            "MinimumEngineVersion",
            "ApplyMethod",
        ]

        parameters = odict.OrderedDict()
        ret = {"result": True}

        for p in pit:
            for result in p["Parameters"]:
                data = odict.OrderedDict()
                for k in keys:
                    data[k] = result.get(k)

                parameters[result.get("ParameterName")] = data

        ret["parameters"] = parameters
        return ret
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def modify_db_instance(
    name,
    allocated_storage=None,
    allow_major_version_upgrade=None,
    apply_immediately=None,
    auto_minor_version_upgrade=None,
    backup_retention_period=None,
    ca_certificate_identifier=None,
    character_set_name=None,
    copy_tags_to_snapshot=None,
    db_cluster_identifier=None,
    db_instance_class=None,
    db_name=None,
    db_parameter_group_name=None,
    db_port_number=None,
    db_security_groups=None,
    db_subnet_group_name=None,
    domain=None,
    domain_iam_role_name=None,
    engine_version=None,
    iops=None,
    kms_key_id=None,
    license_model=None,
    master_user_password=None,
    monitoring_interval=None,
    monitoring_role_arn=None,
    multi_az=None,
    new_db_instance_identifier=None,
    option_group_name=None,
    preferred_backup_window=None,
    preferred_maintenance_window=None,
    promotion_tier=None,
    publicly_accessible=None,
    storage_encrypted=None,
    storage_type=None,
    tde_credential_arn=None,
    tde_credential_password=None,
    vpc_security_group_ids=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Modify settings for a DB instance.
    CLI example to description of parameters ::

        salt myminion boto_rds.modify_db_instance db_instance_identifier region=us-east-1
    """
    res = __salt__["boto_rds.exists"](
        name, tags=None, region=region, key=key, keyid=keyid, profile=profile
    )
    if not res.get("exists"):
        return {
            "modified": False,
            "message": "RDS db instance {} does not exist.".format(name),
        }

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not conn:
            return {"modified": False}

        kwargs = {}
        excluded = {"name"}
        boto_params = set(boto3_param_map.keys())
        keys = set(locals().keys())
        for key in keys.intersection(boto_params).difference(excluded):
            val = locals()[key]
            if val is not None:
                mapped = boto3_param_map[key]
                kwargs[mapped[0]] = mapped[1](val)

        info = conn.modify_db_instance(DBInstanceIdentifier=name, **kwargs)

        if not info:
            return {
                "modified": bool(info),
                "message": "Failed to modify RDS db instance {}.".format(name),
            }

        return {
            "modified": bool(info),
            "message": "Modified RDS db instance {}.".format(name),
            "results": dict(info),
        }
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}


def _tag_doc(tags):
    taglist = []
    if tags is not None:
        for k, v in tags.items():
            if str(k).startswith("__"):
                continue
            taglist.append({"Key": str(k), "Value": str(v)})
    return taglist
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
