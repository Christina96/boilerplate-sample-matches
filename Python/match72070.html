<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cbc.py &amp; vimeo.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cbc.py &amp; vimeo.py
      </h3>
<h1 align="center">
        9.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cbc.py (15.582191%)<th>vimeo.py (6.899166%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(32-106)<td><a href="#" name="0">(259-372)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(321-329)<td><a href="#" name="1">(132-140)</a><td align="center"><font color="#f10000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(199-217)<td><a href="#" name="2">(897-906)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(153-189)<td><a href="#" name="3">(785-825)</a><td align="center"><font color="#bb0000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(136-140)<td><a href="#" name="4">(126-131)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(115-119)<td><a href="#" name="5">(1160-1164)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cbc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import hashlib
3 import json
4 import re
5 from xml.sax.saxutils import escape
6 from .common import InfoExtractor
7 from ..compat import (
8     compat_str,
9     compat_HTTPError,
10 )
11 from ..utils import (
12     js_to_json,
13     smuggle_url,
14     try_get,
15     xpath_text,
16     xpath_element,
17     xpath_with_ns,
18     find_xpath_attr,
19     orderedSet,
20     parse_duration,
21     parse_iso8601,
22     parse_age_limit,
23     strip_or_none,
24     int_or_none,
25     ExtractorError,
26 <a name="0"></a>)
27 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>class CBCIE(InfoExtractor):
28     IE_NAME = 'cbc.ca'
29     _VALID_URL = r'https?://(?:www\.)?cbc\.ca/(?!player/)(?:[^/]+/)+(?P&lt;id&gt;[^/?#]+)'
30     _TESTS = [{
31         'url': 'http://www.cbc.ca/22minutes/videos/clips-season-23/don-cherry-play-offs',
32         'md5': '97e24d09672fc4cf56256d6faa6c25bc',
33         'info_dict': {
34             'id': '2682904050',
35             'ext': 'mp4',
36             'title': 'Don Cherry – All-Stars',
37             'description': 'Don Cherry has a bee in his bonnet about AHL player John Scott because that guy’s got heart.',
38             'timestamp': 1454463000,
39             'upload_date': '20160203',
40             'uploader': 'CBCC-NEW',
41         },
42         'skip': 'Geo-restricted to Canada',
43     }, {
44         'url': 'http://www.cbc.ca/22minutes/videos/22-minutes-update/22-minutes-update-episode-4',
45         'md5': '162adfa070274b144f4fdc3c3b8207db',
46         'info_dict': {
47             'id': '2414435309',
48             'ext': 'mp4',
49             'title': '22 Minutes Update: What Not To Wear Quebec',
50             'description': "This week's latest Canadian top political story is What Not To Wear Quebec.",
51             'upload_date': '20131025',
52             'uploader': 'CBCC-NEW',
53             'timestamp': 1382717907,
54         },
55     }, {
56         'url': 'http://www.cbc.ca/archives/entry/1978-robin-williams-freestyles-on-90-minutes-live',
57         'md5': '0274a90b51a9b4971fe005c63f592f12',
58         'info_dict': {
59             'id': '2487345465',
60             'ext': 'mp4',
61             'title': 'Robin Williams freestyles on 90 Minutes Live',
62             'description': 'Wacky American comedian Robin Williams shows off his infamous "freestyle" comedic talents while being interviewed on CBC\'s 90 Minutes Live.',
63             'upload_date': '19780210',
64             'uploader': 'CBCC-NEW',
65             'timestamp': 255977160,
66         },
67     }, {
68         'url': 'http://www.cbc.ca/natureofthings/blog/birds-eye-view-from-vancouvers-burrard-street-bridge-how-we-got-the-shot',
69         'playlist': [{
70             'md5': '377572d0b49c4ce0c9ad77470e0b96b4',
71             'info_dict': {
72                 'id': '2680832926',
73                 'ext': 'mp4',
74                 'title': 'An Eagle\'s-Eye View Off Burrard Bridge',
75                 'description': 'Hercules the eagle flies from Vancouver\'s Burrard Bridge down to a nearby park with a mini-camera strapped to his back.',
76                 'upload_date': '20160201',
77                 'timestamp': 1454342820,
78                 'uploader': 'CBCC-NEW',
79             },
80         }, {
81             'md5': '415a0e3f586113894174dfb31aa5bb1a',
82             'info_dict': {
83                 'id': '2658915080',
84                 'ext': 'mp4',
85                 'title': 'Fly like an eagle!',
86                 'description': 'Eagle equipped with a mini camera flies from the world\'s tallest tower',
87                 'upload_date': '20150315',
88                 'timestamp': 1426443984,
89                 'uploader': 'CBCC-NEW',
90             },
91         }],
92         'skip': 'Geo-restricted to Canada',
93     }, {
94         'url': 'http://www.cbc.ca/news/canada/calgary/dog-indoor-exercise-winter-1.3928238',
95         'info_dict': {
96             'title'</b></font>: 'Keep Rover active during the deep freeze with doggie pushups and other fun indoor tasks',
97             'id': 'dog-indoor-exercise-winter-1.3928238',
98             'description': 'md5:c18552e41726ee95bd75210d1ca9194c',
99         },
100         'playlist_mincount': 6,
101     }]
102 <a name="5"></a>
103     @classmethod
104     def suitable(cls, url):
105         return False if CBCPlayerIE.suitable(url) else super<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(CBCIE, cls).suitable(url)
106     def _extract_player_init(self, player_init, display_id):
107         player_info = self._parse_json(player_init, display_id, js_to_json)
108         media_id = player_info.get(</b></font>'mediaId')
109         if not media_id:
110             clip_id = player_info['clipId']
111             feed = self._download_json(
112                 'http://tpfeed.cbc.ca/f/ExhSPC/vms_5akSXx4Ng_Zn?byCustomValue={:mpsReleases}{%s}' % clip_id,
113                 clip_id, fatal=False)
114             if feed:
115                 media_id = try_get(feed, lambda x: x['entries'][0]['guid'], compat_str)
116             if not media_id:
117                 media_id = self._download_json(
118                     'http://feed.theplatform.com/f/h9dtGB/punlNGjMlc1F?fields=id&amp;byContent=byReleases%3DbyId%253D' + clip_id,
119                     clip_id)['entries'][0]['id'].split('/')[-1]
120         return self.url_result('cbcplayer:%s' % media_id, 'CBCPlayer', media_id)
121 <a name="4"></a>    def _real_extract(self, url):
122         display_id = self._match_id(url)
123         webpage = self._download_webpage(url, display_id)
124         title <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._og_search_title(webpage, default=None) or self._html_search_meta(
125             'twitter:title', webpage, 'title', default=None) or self._html_search_regex(
126                 r'&lt;title&gt;([^&lt;]+)&lt;/title&gt;', webpage, 'title', fatal=False)
127         entries = [
128             self</b></font>._extract_player_init(player_init, display_id)
129             for player_init in re.findall(r'CBC\.APP\.Caffeine\.initInstance\(({.+?})\);', webpage)]
130         media_ids = []
131         for media_id_re in (
132                 r'&lt;iframe[^&gt;]+src="[^"]+?mediaId=(\d+)"',
133                 r'&lt;div[^&gt;]+\bid=["\']player-(\d+)',
134                 r'guid["\']\s*:\s*["\'](\d+)'):
135             media_ids.extend(re.findall(media_id_re, webpage))
136         entries.extend([
137             self.url_result('cbcplayer:%s' % media_id, 'CBCPlayer', media_id)
138 <a name="3"></a>            for media_id in orderedSet(media_ids)])
139         return self.playlist_result(
140             entries, display_id, strip_or_none(title),
141             self._og_search_description<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(webpage))
142 class CBCPlayerIE(InfoExtractor):
143     IE_NAME = 'cbc.ca:player'
144     _VALID_URL = r'(?:cbcplayer:|https?://(?:www\.)?cbc\.ca/(?:player/play/|i/caffeine/syndicate/\?mediaId=))(?P&lt;id&gt;\d+)'
145     _TESTS = [{
146         'url': 'http://www.cbc.ca/player/play/2683190193',
147         'md5': '64d25f841ddf4ddb28a235338af32e2c',
148         'info_dict': {
149             'id': '2683190193',
150             'ext': 'mp4',
151             'title': 'Gerry Runs a Sweat Shop',
152             'description': 'md5:b457e1c01e8ff408d9d801c1c2cd29b0',
153             'timestamp': 1455071400,
154             'upload_date': '20160210',
155             'uploader': 'CBCC-NEW',
156         },
157         'skip': 'Geo-restricted to Canada',
158     }, {
159         'url': 'http://www.cbc.ca/player/play/2657631896',
160         'md5': 'e5e708c34ae6fca156aafe17c43e8b75',
161         'info_dict': {
162             'id': '2657631896',
163             'ext': 'mp3',
164             'title': 'CBC Montreal is organizing its first ever community hackathon!',
165             'description': 'The modern technology we tend to depend on so heavily, is never without it\'s share of hiccups and headaches. Next weekend - CBC Montreal will be getting members of the public for its first Hackathon.',
166             'timestamp': 1425704400,
167             'upload_date': '20150307',
168             'uploader': 'CBCC-NEW',
169         },
170     }, {
171         'url': 'http://www.cbc.ca/player/play/2164402062',
172         'md5': '33fcd8f6719b9dd60a5e73adcb83b9f6',
173         'info_dict': {
174             'id'</b></font>: '2164402062',
175             'ext': 'mp4',
176             'title': 'Cancer survivor four times over',
177             'description': 'Tim Mayer has beaten three different forms of cancer four times in five years.',
178             'timestamp': 1320410746,
179             'upload_date': '20111104',
180             'uploader': 'CBCC-NEW',
181 <a name="2"></a>        },
182     }]
183     <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def _real_extract(self, url):
184         video_id = self._match_id(url)
185         return {
186             '_type': 'url_transparent',
187             'ie_key': 'ThePlatform',
188             'url': smuggle_url(
189                 'http://link.theplatform.com/s/ExhSPC/media/guid/2655402169/%s?mbr=true&amp;formats=MPEG4,FLV,MP3' % video_id, {
190                     'force_smil_url': True
191                 }),
192             'id': video_id,
193         }
194 class CBCWatchBaseIE(InfoExtractor):
195     _device_id = None
196     _device_token = None
197     _API_BASE_URL = 'https://api-cbc.cloud.clearleap.com/cloffice/client/'
198     _NS_MAP = {
199         'media'</b></font>: 'http://search.yahoo.com/mrss/',
200         'clearleap': 'http://www.clearleap.com/namespace/clearleap/1.0/',
201     }
202     _GEO_COUNTRIES = ['CA']
203     _LOGIN_URL = 'https://api.loginradius.com/identity/v2/auth/login'
204     _TOKEN_URL = 'https://cloud-api.loginradius.com/sso/jwt/api/token'
205     _API_KEY = '3f4beddd-2061-49b0-ae80-6f1f2ed65b37'
206     _NETRC_MACHINE = 'cbcwatch'
207     def _signature(self, email, password):
208         data = json.dumps({
209             'email': email,
210             'password': password,
211         }).encode()
212         headers = {'content-type': 'application/json'}
213         query = {'apikey': self._API_KEY}
214         resp = self._download_json(self._LOGIN_URL, None, data=data, headers=headers, query=query)
215         access_token = resp['access_token']
216         query = {
217             'access_token': access_token,
218             'apikey': self._API_KEY,
219             'jwtapp': 'jwt',
220         }
221         resp = self._download_json(self._TOKEN_URL, None, headers=headers, query=query)
222         return resp['signature']
223     def _call_api(self, path, video_id):
224         url = path if path.startswith('http') else self._API_BASE_URL + path
225         for _ in range(2):
226             try:
227                 result = self._download_xml(url, video_id, headers={
228                     'X-Clearleap-DeviceId': self._device_id,
229                     'X-Clearleap-DeviceToken': self._device_token,
230                 })
231             except ExtractorError as e:
232                 if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:
233                     self._register_device()
234                     continue
235                 raise
236         error_message = xpath_text(result, 'userMessage') or xpath_text(result, 'systemMessage')
237         if error_message:
238             raise ExtractorError('%s said: %s' % (self.IE_NAME, error_message))
239         return result
240     def _real_initialize(self):
241         if self._valid_device_token():
242             return
243         device = self._downloader.cache.load(
244             'cbcwatch', self._cache_device_key()) or {}
245         self._device_id, self._device_token = device.get('id'), device.get('token')
246         if self._valid_device_token():
247             return
248         self._register_device()
249     def _valid_device_token(self):
250         return self._device_id and self._device_token
251     def _cache_device_key(self):
252         email, _ = self._get_login_info()
253         return '%s_device' % hashlib.sha256(email.encode()).hexdigest() if email else 'device'
254     def _register_device(self):
255         result = self._download_xml(
256             self._API_BASE_URL + 'device/register',
257             None, 'Acquiring device token',
258             data=b'&lt;device&gt;&lt;type&gt;web&lt;/type&gt;&lt;/device&gt;')
259         self._device_id = xpath_text(result, 'deviceId', fatal=True)
260         email, password = self._get_login_info()
261         if email and password:
262             signature = self._signature(email, password)
263             data = '&lt;login&gt;&lt;token&gt;{0}&lt;/token&gt;&lt;device&gt;&lt;deviceId&gt;{1}&lt;/deviceId&gt;&lt;type&gt;web&lt;/type&gt;&lt;/device&gt;&lt;/login&gt;'.format(
264                 escape(signature), escape(self._device_id)).encode()
265             url = self._API_BASE_URL + 'device/login'
266             result = self._download_xml(
267                 url, None, data=data,
268                 headers={'content-type': 'application/xml'})
269             self._device_token = xpath_text(result, 'token', fatal=True)
270         else:
271             self._device_token = xpath_text(result, 'deviceToken', fatal=True)
272         self._downloader.cache.store(
273             'cbcwatch', self._cache_device_key(), {
274                 'id': self._device_id,
275                 'token': self._device_token,
276             })
277     def _parse_rss_feed(self, rss):
278         channel = xpath_element(rss, 'channel', fatal=True)
279         def _add_ns(path):
280             return xpath_with_ns(path, self._NS_MAP)
281         entries = []
282         for item in channel.findall('item'):
283             guid = xpath_text(item, 'guid', fatal=True)
284             title = xpath_text(item, 'title', fatal=True)
285             media_group = xpath_element(item, _add_ns('media:group'), fatal=True)
286             content = xpath_element(media_group, _add_ns('media:content'), fatal=True)
287 <a name="1"></a>            content_url = content.attrib['url']
288             thumbnails = []
289             for thumbnail in media_group.findall(_add_ns<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>('media:thumbnail')):
290                 thumbnail_url = thumbnail.get('url')
291                 if not thumbnail_url:
292                     continue
293                 thumbnails.append({
294                     'id': thumbnail.get('profile'),
295                     'url': thumbnail_url,
296                     'width': int_or_none(thumbnail.get('width')),
297                     'height': int_or_none(thumbnail.get(</b></font>'height')),
298                 })
299             timestamp = None
300             release_date = find_xpath_attr(
301                 item, _add_ns('media:credit'), 'role', 'releaseDate')
302             if release_date is not None:
303                 timestamp = parse_iso8601(release_date.text)
304             entries.append({
305                 '_type': 'url_transparent',
306                 'url': content_url,
307                 'id': guid,
308                 'title': title,
309                 'description': xpath_text(item, 'description'),
310                 'timestamp': timestamp,
311                 'duration': int_or_none(content.get('duration')),
312                 'age_limit': parse_age_limit(xpath_text(item, _add_ns('media:rating'))),
313                 'episode': xpath_text(item, _add_ns('clearleap:episode')),
314                 'episode_number': int_or_none(xpath_text(item, _add_ns('clearleap:episodeInSeason'))),
315                 'series': xpath_text(item, _add_ns('clearleap:series')),
316                 'season_number': int_or_none(xpath_text(item, _add_ns('clearleap:season'))),
317                 'thumbnails': thumbnails,
318                 'ie_key': 'CBCWatchVideo',
319             })
320         return self.playlist_result(
321             entries, xpath_text(channel, 'guid'),
322             xpath_text(channel, 'title'),
323             xpath_text(channel, 'description'))
324 class CBCWatchVideoIE(CBCWatchBaseIE):
325     IE_NAME = 'cbc.ca:watch:video'
326     _VALID_URL = r'https?://api-cbc\.cloud\.clearleap\.com/cloffice/client/web/play/?\?.*?\bcontentId=(?P&lt;id&gt;[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12})'
327     _TEST = {
328         'url': 'https://api-cbc.cloud.clearleap.com/cloffice/client/web/play/?contentId=3c84472a-1eea-4dee-9267-2655d5055dcf&amp;categoryId=ebc258f5-ee40-4cca-b66b-ba6bd55b7235',
329         'only_matching': True,
330     }
331     def _real_extract(self, url):
332         video_id = self._match_id(url)
333         result = self._call_api(url, video_id)
334         m3u8_url = xpath_text(result, 'url', fatal=True)
335         formats = self._extract_m3u8_formats(re.sub(r'/([^/]+)/[^/?]+\.m3u8', r'/\1/\1.m3u8', m3u8_url), video_id, 'mp4', fatal=False)
336         if len(formats) &lt; 2:
337             formats = self._extract_m3u8_formats(m3u8_url, video_id, 'mp4')
338         for f in formats:
339             format_id = f.get('format_id')
340             if format_id.startswith('AAC'):
341                 f['acodec'] = 'aac'
342             elif format_id.startswith('AC3'):
343                 f['acodec'] = 'ac-3'
344         self._sort_formats(formats)
345         info = {
346             'id': video_id,
347             'title': video_id,
348             'formats': formats,
349         }
350         rss = xpath_element(result, 'rss')
351         if rss:
352             info.update(self._parse_rss_feed(rss)['entries'][0])
353             del info['url']
354             del info['_type']
355             del info['ie_key']
356         return info
357 class CBCWatchIE(CBCWatchBaseIE):
358     IE_NAME = 'cbc.ca:watch'
359     _VALID_URL = r'https?://(?:gem|watch)\.cbc\.ca/(?:[^/]+/)+(?P&lt;id&gt;[0-9a-f-]+)'
360     _TESTS = [{
361         'url': 'http://watch.cbc.ca/doc-zone/season-6/customer-disservice/38e815a-009e3ab12e4',
362         'info_dict': {
363             'id': '9673749a-5e77-484c-8b62-a1092a6b5168',
364             'ext': 'mp4',
365             'title': 'Customer (Dis)Service',
366             'description': 'md5:8bdd6913a0fe03d4b2a17ebe169c7c87',
367             'upload_date': '20160219',
368             'timestamp': 1455840000,
369         },
370         'params': {
371             'skip_download': True,
372             'format': 'bestvideo',
373         },
374     }, {
375         'url': 'http://watch.cbc.ca/arthur/all/1ed4b385-cd84-49cf-95f0-80f004680057',
376         'info_dict': {
377             'id': '1ed4b385-cd84-49cf-95f0-80f004680057',
378             'title': 'Arthur',
379             'description': 'Arthur, the sweetest 8-year-old aardvark, and his pals solve all kinds of problems with humour, kindness and teamwork.',
380         },
381         'playlist_mincount': 30,
382     }, {
383         'url': 'https://gem.cbc.ca/media/this-hour-has-22-minutes/season-26/episode-20/38e815a-0108c6c6a42',
384         'only_matching': True,
385     }]
386     def _real_extract(self, url):
387         video_id = self._match_id(url)
388         rss = self._call_api('web/browse/' + video_id, video_id)
389         return self._parse_rss_feed(rss)
390 class CBCOlympicsIE(InfoExtractor):
391     IE_NAME = 'cbc.ca:olympics'
392     _VALID_URL = r'https?://olympics\.cbc\.ca/video/[^/]+/(?P&lt;id&gt;[^/?#]+)'
393     _TESTS = [{
394         'url': 'https://olympics.cbc.ca/video/whats-on-tv/olympic-morning-featuring-the-opening-ceremony/',
395         'only_matching': True,
396     }]
397     def _real_extract(self, url):
398         display_id = self._match_id(url)
399         webpage = self._download_webpage(url, display_id)
400         video_id = self._hidden_inputs(webpage)['videoId']
401         video_doc = self._download_xml(
402             'https://olympics.cbc.ca/videodata/%s.xml' % video_id, video_id)
403         title = xpath_text(video_doc, 'title', fatal=True)
404         is_live = xpath_text(video_doc, 'kind') == 'Live'
405         if is_live:
406             title = self._live_title(title)
407         formats = []
408         for video_source in video_doc.findall('videoSources/videoSource'):
409             uri = xpath_text(video_source, 'uri')
410             if not uri:
411                 continue
412             tokenize = self._download_json(
413                 'https://olympics.cbc.ca/api/api-akamai/tokenize',
414                 video_id, data=json.dumps({
415                     'VideoSource': uri,
416                 }).encode(), headers={
417                     'Content-Type': 'application/json',
418                     'Referer': url,
419                     'Cookie': '_dvp=TK:C0ObxjerU',  # AKAMAI CDN cookie
420                 }, fatal=False)
421             if not tokenize:
422                 continue
423             content_url = tokenize['ContentUrl']
424             video_source_format = video_source.get('format')
425             if video_source_format == 'IIS':
426                 formats.extend(self._extract_ism_formats(
427                     content_url, video_id, ism_id=video_source_format, fatal=False))
428             else:
429                 formats.extend(self._extract_m3u8_formats(
430                     content_url, video_id, 'mp4',
431                     'm3u8' if is_live else 'm3u8_native',
432                     m3u8_id=video_source_format, fatal=False))
433         self._sort_formats(formats)
434         return {
435             'id': video_id,
436             'display_id': display_id,
437             'title': title,
438             'description': xpath_text(video_doc, 'description'),
439             'thumbnail': xpath_text(video_doc, 'thumbnailUrl'),
440             'duration': parse_duration(xpath_text(video_doc, 'duration')),
441             'formats': formats,
442             'is_live': is_live,
443         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vimeo.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import base64
3 import functools
4 import re
5 import itertools
6 from .common import InfoExtractor
7 from ..compat import (
8     compat_kwargs,
9     compat_HTTPError,
10     compat_str,
11     compat_urlparse,
12 )
13 from ..utils import (
14     clean_html,
15     determine_ext,
16     ExtractorError,
17     get_element_by_class,
18     js_to_json,
19     int_or_none,
20     merge_dicts,
21     OnDemandPagedList,
22     parse_filesize,
23     parse_iso8601,
24     sanitized_Request,
25     smuggle_url,
26     std_headers,
27     str_or_none,
28     try_get,
29     unified_timestamp,
30     unsmuggle_url,
31     urlencode_postdata,
32     urljoin,
33     unescapeHTML,
34 )
35 class VimeoBaseInfoExtractor(InfoExtractor):
36     _NETRC_MACHINE = 'vimeo'
37     _LOGIN_REQUIRED = False
38     _LOGIN_URL = 'https://vimeo.com/log_in'
39     def _login(self):
40         username, password = self._get_login_info()
41         if username is None:
42             if self._LOGIN_REQUIRED:
43                 raise ExtractorError('No login info available, needed for using %s.' % self.IE_NAME, expected=True)
44             return
45         webpage = self._download_webpage(
46             self._LOGIN_URL, None, 'Downloading login page')
47         token, vuid = self._extract_xsrft_and_vuid(webpage)
48         data = {
49             'action': 'login',
50             'email': username,
51             'password': password,
52             'service': 'vimeo',
53             'token': token,
54         }
55         self._set_vimeo_cookie('vuid', vuid)
56         try:
57             self._download_webpage(
58                 self._LOGIN_URL, None, 'Logging in',
59                 data=urlencode_postdata(data), headers={
60                     'Content-Type': 'application/x-www-form-urlencoded',
61                     'Referer': self._LOGIN_URL,
62                 })
63         except ExtractorError as e:
64             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 418:
65                 raise ExtractorError(
66                     'Unable to log in: bad username or password',
67                     expected=True)
68             raise ExtractorError('Unable to log in')
69     def _get_video_password(self):
70         password = self._downloader.params.get('videopassword')
71         if password is None:
72             raise ExtractorError(
73                 'This video is protected by a password, use the --video-password option',
74                 expected=True)
75         return password
76     def _verify_video_password(self, url, video_id, password, token, vuid):
77         if url.startswith('http://'):
78             url = url.replace('http://', 'https://')
79         self._set_vimeo_cookie('vuid', vuid)
80         return self._download_webpage(
81             url + '/password', video_id, 'Verifying the password',
82             'Wrong password', data=urlencode_postdata({
83                 'password': password,
84                 'token': token,
85             }), headers={
86                 'Content-Type': 'application/x-www-form-urlencoded',
87                 'Referer': url,
88             })
89     def _extract_xsrft_and_vuid(self, webpage):
90         xsrft = self._search_regex(
91             r'(?:(?P&lt;q1&gt;["\'])xsrft(?P=q1)\s*:|xsrft\s*[=:])\s*(?P&lt;q&gt;["\'])(?P&lt;xsrft&gt;.+?)(?P=q)',
92             webpage, 'login token', group='xsrft')
93         vuid = self._search_regex(
94             r'["\']vuid["\']\s*:\s*(["\'])(?P&lt;vuid&gt;.+?)\1',
95             webpage, 'vuid', group='vuid')
96         return xsrft, vuid
97     def _extract_vimeo_config(self, webpage, video_id, *args, **kwargs):
98         vimeo_config = self._search_regex(
99             r'vimeo\.config\s*=\s*(?:({.+?})|_extend\([^,]+,\s+({.+?})\));',
100             webpage, 'vimeo config', *args, **compat_kwargs(kwargs))
101         if vimeo_config:
102             return self._parse_json(vimeo_config, video_id)
103     def _set_vimeo_cookie(self, name, value):
104         self._set_cookie('vimeo.com', name, value)
105     def _vimeo_sort_formats(self, formats):
106         self._sort_formats(formats, field_preference=('preference', 'height', 'width', 'fps', 'tbr', 'format_id'))
107 <a name="4"></a>    def _parse_config(self, config, video_id):
108         video_data = config['video']
109         video_title = video_data['title']
110         live_event <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= video_data.get('live_event') or {}
111         is_live = live_event.get('status') == 'started'
112         request = config.get('request') or {}
113 <a name="1"></a>
114         formats = []
115         config_files = video_data.</b></font>get('files') or request.get('files') or {}
116         for f in (config_files.get<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>('progressive') or []):
117             video_url = f.get('url')
118             if not video_url:
119                 continue
120             formats.append({
121                 'url': video_url,
122                 'format_id': 'http-%s' % f.get('quality'),
123                 'width': int_or_none(f.get('width')),
124                 'height': int_or_none(f.get(</b></font>'height')),
125                 'fps': int_or_none(f.get('fps')),
126                 'tbr': int_or_none(f.get('bitrate')),
127             })
128         sep_pattern = r'/sep/video/'
129         for files_type in ('hls', 'dash'):
130             for cdn_name, cdn_data in (try_get(config_files, lambda x: x[files_type]['cdns']) or {}).items():
131                 manifest_url = cdn_data.get('url')
132                 if not manifest_url:
133                     continue
134                 format_id = '%s-%s' % (files_type, cdn_name)
135                 sep_manifest_urls = []
136                 if re.search(sep_pattern, manifest_url):
137                     for suffix, repl in (('', 'video'), ('_sep', 'sep/video')):
138                         sep_manifest_urls.append((format_id + suffix, re.sub(
139                             sep_pattern, '/%s/' % repl, manifest_url)))
140                 else:
141                     sep_manifest_urls = [(format_id, manifest_url)]
142                 for f_id, m_url in sep_manifest_urls:
143                     if files_type == 'hls':
144                         formats.extend(self._extract_m3u8_formats(
145                             m_url, video_id, 'mp4',
146                             'm3u8' if is_live else 'm3u8_native', m3u8_id=f_id,
147                             note='Downloading %s m3u8 information' % cdn_name,
148                             fatal=False))
149                     elif files_type == 'dash':
150                         if 'json=1' in m_url:
151                             real_m_url = (self._download_json(m_url, video_id, fatal=False) or {}).get('url')
152                             if real_m_url:
153                                 m_url = real_m_url
154                         mpd_formats = self._extract_mpd_formats(
155                             m_url.replace('/master.json', '/master.mpd'), video_id, f_id,
156                             'Downloading %s MPD information' % cdn_name,
157                             fatal=False)
158                         formats.extend(mpd_formats)
159         live_archive = live_event.get('archive') or {}
160         live_archive_source_url = live_archive.get('source_url')
161         if live_archive_source_url and live_archive.get('status') == 'done':
162             formats.append({
163                 'format_id': 'live-archive-source',
164                 'url': live_archive_source_url,
165                 'preference': 1,
166             })
167         for f in formats:
168             if f.get('vcodec') == 'none':
169                 f['preference'] = -50
170             elif f.get('acodec') == 'none':
171                 f['preference'] = -40
172         subtitles = {}
173         for tt in (request.get('text_tracks') or []):
174             subtitles[tt['lang']] = [{
175                 'ext': 'vtt',
176                 'url': urljoin('https://vimeo.com', tt['url']),
177             }]
178         thumbnails = []
179         if not is_live:
180             for key, thumb in (video_data.get('thumbs') or {}).items():
181                 thumbnails.append({
182                     'id': key,
183                     'width': int_or_none(key),
184                     'url': thumb,
185                 })
186             thumbnail = video_data.get('thumbnail')
187             if thumbnail:
188                 thumbnails.append({
189                     'url': thumbnail,
190                 })
191         owner = video_data.get('owner') or {}
192         video_uploader_url = owner.get('url')
193         return {
194             'id': str_or_none(video_data.get('id')) or video_id,
195             'title': self._live_title(video_title) if is_live else video_title,
196             'uploader': owner.get('name'),
197             'uploader_id': video_uploader_url.split('/')[-1] if video_uploader_url else None,
198             'uploader_url': video_uploader_url,
199             'thumbnails': thumbnails,
200             'duration': int_or_none(video_data.get('duration')),
201             'formats': formats,
202             'subtitles': subtitles,
203             'is_live': is_live,
204         }
205     def _extract_original_format(self, url, video_id, unlisted_hash=None):
206         query = {'action': 'load_download_config'}
207         if unlisted_hash:
208             query['unlisted_hash'] = unlisted_hash
209         download_data = self._download_json(
210             url, video_id, fatal=False, query=query,
211             headers={'X-Requested-With': 'XMLHttpRequest'})
212         if download_data:
213             source_file = download_data.get('source_file')
214             if isinstance(source_file, dict):
215                 download_url = source_file.get('download_url')
216                 if download_url and not source_file.get('is_cold') and not source_file.get('is_defrosting'):
217                     source_name = source_file.get('public_name', 'Original')
218                     if self._is_valid_url(download_url, video_id, '%s video' % source_name):
219                         ext = (try_get(
220                             source_file, lambda x: x['extension'],
221                             compat_str) or determine_ext(
222                             download_url, None) or 'mp4').lower()
223                         return {
224                             'url': download_url,
225                             'ext': ext,
226                             'width': int_or_none(source_file.get('width')),
227                             'height': int_or_none(source_file.get('height')),
228                             'filesize': parse_filesize(source_file.get('size')),
229                             'format_id': source_name,
230                             'preference': 1,
231 <a name="0"></a>                        }
232 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>class VimeoIE(VimeoBaseInfoExtractor):
233     _VALID_URL = r'''(?x)
234                     https?://
235                         (?:
236                             (?:
237                                 www|
238                                 player
239                             )
240                             \.
241                         )?
242                         vimeo(?:pro)?\.com/
243                         (?!(?:channels|album|showcase)/[^/?#]+/?(?:$|[?#])|[^/]+/review/|ondemand/)
244                         (?:.*?/)??
245                         (?:
246                             (?:
247                                 play_redirect_hls|
248                                 moogaloop\.swf)\?clip_id=
249                             )?
250                         (?:videos?/)?
251                         (?P&lt;id&gt;[0-9]+)
252                         (?:/(?P&lt;unlisted_hash&gt;[\da-f]{10}))?
253                         /?(?:[?&amp;].*)?(?:[#].*)?$
254                 'id'</b></font>: '75629013',
255                 'ext': 'mp4',
256                 'title': 'Key &amp; Peele: Terrorist Interrogation',
257                 'description': 'md5:8678b246399b070816b12313e8b4eb5c',
258                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/atencio',
259                 'uploader_id': 'atencio',
260                 'uploader': 'Peter Atencio',
261                 'channel_id': 'keypeele',
262                 'channel_url': r're:https?://(?:www\.)?vimeo\.com/channels/keypeele',
263                 'timestamp': 1380339469,
264                 'upload_date': '20130928',
265                 'duration': 187,
266             },
267             'expected_warnings': ['Unable to download JSON metadata'],
268         },
269         {
270             'url': 'http://vimeo.com/76979871',
271             'note': 'Video with subtitles',
272             'info_dict': {
273                 'id': '76979871',
274                 'ext': 'mp4',
275                 'title': 'The New Vimeo Player (You Know, For Videos)',
276                 'description': 'md5:2ec900bf97c3f389378a96aee11260ea',
277                 'timestamp': 1381846109,
278                 'upload_date': '20131015',
279                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/staff',
280                 'uploader_id': 'staff',
281                 'uploader': 'Vimeo Staff',
282                 'duration': 62,
283                 'subtitles': {
284                     'de': [{'ext': 'vtt'}],
285                     'en': [{'ext': 'vtt'}],
286                     'es': [{'ext': 'vtt'}],
287                     'fr': [{'ext': 'vtt'}],
288                 },
289             }
290         },
291         {
292             'url': 'https://player.vimeo.com/video/98044508',
293             'note': 'The js code contains assignments to the same variable as the config',
294             'info_dict': {
295                 'id': '98044508',
296                 'ext': 'mp4',
297                 'title': 'Pier Solar OUYA Official Trailer',
298                 'uploader': 'Tulio Gonçalves',
299                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/user28849593',
300                 'uploader_id': 'user28849593',
301             },
302         },
303         {
304             'url': 'https://vimeo.com/33951933',
305             'md5': '53c688fa95a55bf4b7293d37a89c5c53',
306             'info_dict': {
307                 'id': '33951933',
308                 'ext': 'mp4',
309                 'title': 'FOX CLASSICS - Forever Classic ID - A Full Minute',
310                 'uploader': 'The DMCI',
311                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/dmci',
312                 'uploader_id': 'dmci',
313                 'timestamp': 1324343742,
314                 'upload_date': '20111220',
315                 'description': 'md5:ae23671e82d05415868f7ad1aec21147',
316             },
317         },
318         {
319             'url': 'https://vimeo.com/channels/tributes/6213729',
320             'info_dict': {
321                 'id': '6213729',
322                 'ext': 'mp4',
323                 'title': 'Vimeo Tribute: The Shining',
324                 'uploader': 'Casey Donahue',
325                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/caseydonahue',
326                 'uploader_id': 'caseydonahue',
327                 'channel_url': r're:https?://(?:www\.)?vimeo\.com/channels/tributes',
328                 'channel_id': 'tributes',
329                 'timestamp': 1250886430,
330                 'upload_date': '20090821',
331                 'description': 'md5:bdbf314014e58713e6e5b66eb252f4a6',
332             },
333             'params': {
334                 'skip_download': True,
335             },
336             'expected_warnings': ['Unable to download JSON metadata'],
337         },
338         {
339             'url': 'https://vimeo.com/73445910',
340             'info_dict': {
341                 'id': '73445910',
342                 'ext': 'mp4',
343                 'title': 'The Reluctant Revolutionary',
344                 'uploader': '10Ft Films',
345                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/tenfootfilms',
346                 'uploader_id': 'tenfootfilms',
347                 'description': 'md5:0fa704e05b04f91f40b7f3ca2e801384',
348                 'upload_date': '20130830',
349                 'timestamp': 1377853339,
350             },
351             'params': {
352                 'skip_download': True,
353             },
354             'expected_warnings': ['Unable to download JSON metadata'],
355             'skip': 'this page is no longer available.',
356         },
357         {
358             'url': 'http://player.vimeo.com/video/68375962',
359             'md5': 'aaf896bdb7ddd6476df50007a0ac0ae7',
360             'info_dict': {
361                 'id': '68375962',
362                 'ext': 'mp4',
363                 'title': 'youtube-dl password protected test video',
364                 'uploader_url': r're:https?://(?:www\.)?vimeo\.com/user18948128',
365                 'uploader_id': 'user18948128',
366                 'uploader': 'Jaime Marquínez Ferrándiz',
367                 'duration': 10,
368             },
369             'params': {
370                 'format': 'best[protocol=https]',
371                 'videopassword': 'youtube-dl',
372             },
373         },
374         {
375             'url': 'http://vimeo.com/moogaloop.swf?clip_id=2539741',
376             'only_matching': True,
377         },
378         {
379             'url': 'https://vimeo.com/109815029',
380             'note': 'Video not completely processed, "failed" seed status',
381             'only_matching': True,
382         },
383         {
384             'url': 'https://vimeo.com/groups/travelhd/videos/22439234',
385             'only_matching': True,
386         },
387         {
388             'url': 'https://vimeo.com/album/2632481/video/79010983',
389             'only_matching': True,
390         },
391         {
392             'url': 'https://vimeo.com/7809605',
393             'only_matching': True,
394         },
395         {
396             'url': 'https://vimeo.com/392479337/a52724358e',
397             'only_matching': True,
398         },
399         {
400             'url': 'https://vimeo.com/581039021/9603038895',
401             'info_dict': {
402                 'id': '581039021',
403                 'ext': 'mp4',
404                 'timestamp': 1627621014,
405                 'title': 're:.+',
406                 'uploader_id': 're:.+',
407                 'uploader': 're:.+',
408                 'upload_date': r're:\d+',
409             },
410             'params': {
411                 'skip_download': True,
412             },
413         }
414     ]
415     @staticmethod
416     def _smuggle_referrer(url, referrer_url):
417         return smuggle_url(url, {'http_headers': {'Referer': referrer_url}})
418     @staticmethod
419     def _extract_urls(url, webpage):
420         urls = []
421         for mobj in re.finditer(
422                 r'&lt;iframe[^&gt;]+?src=(["\'])(?P&lt;url&gt;(?:https?:)?//player\.vimeo\.com/video/\d+.*?)\1',
423                 webpage):
424             urls.append(VimeoIE._smuggle_referrer(unescapeHTML(mobj.group('url')), url))
425         PLAIN_EMBED_RE = (
426             r'&lt;embed[^&gt;]+?src=(["\'])(?P&lt;url&gt;(?:https?:)?//(?:www\.)?vimeo\.com/moogaloop\.swf.+?)\1',
427             r'&lt;video[^&gt;]+src=(["\'])(?P&lt;url&gt;(?:https?:)?//(?:www\.)?vimeo\.com/[0-9]+)\1',
428         )
429         for embed_re in PLAIN_EMBED_RE:
430             for mobj in re.finditer(embed_re, webpage):
431                 urls.append(mobj.group('url'))
432         return urls
433     @staticmethod
434     def _extract_url(url, webpage):
435         urls = VimeoIE._extract_urls(url, webpage)
436         return urls[0] if urls else None
437     def _verify_player_video_password(self, url, video_id, headers):
438         password = self._get_video_password()
439         data = urlencode_postdata({
440             'password': base64.b64encode(password.encode()),
441         })
442         headers = merge_dicts(headers, {
443             'Content-Type': 'application/x-www-form-urlencoded',
444         })
445         checked = self._download_json(
446             url + '/check-password', video_id,
447             'Verifying the password', data=data, headers=headers)
448         if checked is False:
449             raise ExtractorError('Wrong video password', expected=True)
450         return checked
451     def _real_initialize(self):
452         self._login()
453     def _extract_from_api(self, video_id, unlisted_hash=None):
454         token = self._download_json(
455             'https://vimeo.com/_rv/jwt', video_id, headers={
456                 'X-Requested-With': 'XMLHttpRequest'
457             })['token']
458         api_url = 'https://api.vimeo.com/videos/' + video_id
459         if unlisted_hash:
460             api_url += ':' + unlisted_hash
461         video = self._download_json(
462             api_url, video_id, headers={
463                 'Authorization': 'jwt ' + token,
464             }, query={
465                 'fields': 'config_url,created_time,description,license,metadata.connections.comments.total,metadata.connections.likes.total,release_time,stats.plays',
466             })
467         info = self._parse_config(self._download_json(
468             video['config_url'], video_id), video_id)
469         self._vimeo_sort_formats(info['formats'])
470         get_timestamp = lambda x: parse_iso8601(video.get(x + '_time'))
471         info.update({
472             'description': video.get('description'),
473             'license': video.get('license'),
474             'release_timestamp': get_timestamp('release'),
475             'timestamp': get_timestamp('created'),
476             'view_count': int_or_none(try_get(video, lambda x: x['stats']['plays'])),
477         })
478         connections = try_get(
479             video, lambda x: x['metadata']['connections'], dict) or {}
480         for k in ('comment', 'like'):
481             info[k + '_count'] = int_or_none(try_get(connections, lambda x: x[k + 's']['total']))
482         return info
483     def _real_extract(self, url):
484         url, data = unsmuggle_url(url, {})
485         headers = std_headers.copy()
486         if 'http_headers' in data:
487             headers.update(data['http_headers'])
488         if 'Referer' not in headers:
489             headers['Referer'] = url
490         mobj = re.match(self._VALID_URL, url).groupdict()
491         video_id, unlisted_hash = mobj['id'], mobj.get('unlisted_hash')
492         if unlisted_hash:
493             return self._extract_from_api(video_id, unlisted_hash)
494         orig_url = url
495         is_pro = 'vimeopro.com/' in url
496         if is_pro:
497             url = self._extract_url(url, self._download_webpage(url, video_id))
498             if not url:
499                 url = 'https://vimeo.com/' + video_id
500         elif any(p in url for p in ('play_redirect_hls', 'moogaloop.swf')):
501             url = 'https://vimeo.com/' + video_id
502         try:
503             webpage, urlh = self._download_webpage_handle(
504                 url, video_id, headers=headers)
505             redirect_url = urlh.geturl()
506         except ExtractorError as ee:
507             if isinstance(ee.cause, compat_HTTPError) and ee.cause.code == 403:
508                 errmsg = ee.cause.read()
509                 if b'Because of its privacy settings, this video cannot be played here' in errmsg:
510                     raise ExtractorError(
511                         'Cannot download embed-only video without embedding '
512                         'URL. Please call youtube-dl with the URL of the page '
513                         'that embeds this video.',
514                         expected=True)
515             raise
516         if '//player.vimeo.com/video/' in url:
517             config = self._parse_json(self._search_regex(
518                 r'\bconfig\s*=\s*({.+?})\s*;', webpage, 'info section'), video_id)
519             if config.get('view') == 4:
520                 config = self._verify_player_video_password(
521                     redirect_url, video_id, headers)
522             info = self._parse_config(config, video_id)
523             self._vimeo_sort_formats(info['formats'])
524             return info
525         if re.search(r'&lt;form[^&gt;]+?id="pw_form"', webpage):
526             video_password = self._get_video_password()
527             token, vuid = self._extract_xsrft_and_vuid(webpage)
528             webpage = self._verify_video_password(
529                 redirect_url, video_id, video_password, token, vuid)
530         vimeo_config = self._extract_vimeo_config(webpage, video_id, default=None)
531         if vimeo_config:
532             seed_status = vimeo_config.get('seed_status') or {}
533             if seed_status.get('state') == 'failed':
534                 raise ExtractorError(
535                     '%s said: %s' % (self.IE_NAME, seed_status['title']),
536                     expected=True)
537         cc_license = None
538         timestamp = None
539         video_description = None
540         info_dict = {}
541         channel_id = self._search_regex(
542             r'vimeo\.com/channels/([^/]+)', url, 'channel id', default=None)
543         if channel_id:
544             config_url = self._html_search_regex(
545                 r'\bdata-config-url="([^"]+)"', webpage, 'config URL')
546             video_description = clean_html(get_element_by_class('description', webpage))
547             info_dict.update({
548                 'channel_id': channel_id,
549                 'channel_url': 'https://vimeo.com/channels/' + channel_id,
550             })
551         else:
552             page_config = self._parse_json(self._search_regex(
553                 r'vimeo\.(?:clip|vod_title)_page_config\s*=\s*({.+?});',
554                 webpage, 'page config', default='{}'), video_id, fatal=False)
555             if not page_config:
556                 return self._extract_from_api(video_id)
557             config_url = page_config['player']['config_url']
558             cc_license = page_config.get('cc_license')
559             clip = page_config.get('clip') or {}
560             timestamp = clip.get('uploaded_on')
561             video_description = clean_html(
562                 clip.get('description') or page_config.get('description_html_escaped'))
563         config = self._download_json(config_url, video_id)
564         video = config.get('video') or {}
565         vod = video.get('vod') or {}
566         def is_rented():
567             if '&gt;You rented this title.&lt;' in webpage:
568                 return True
569             if try_get(config, lambda x: x['user']['purchased']):
570                 return True
571             for purchase_option in (vod.get('purchase_options') or []):
572                 if purchase_option.get('purchased'):
573                     return True
574                 label = purchase_option.get('label_string')
575                 if label and (label.startswith('You rented this') or label.endswith(' remaining')):
576                     return True
577             return False
578         if is_rented() and vod.get('is_trailer'):
579             feature_id = vod.get('feature_id')
580             if feature_id and not data.get('force_feature_id', False):
581                 return self.url_result(smuggle_url(
582                     'https://player.vimeo.com/player/%s' % feature_id,
583                     {'force_feature_id': True}), 'Vimeo')
584         if not video_description:
585             video_description = self._html_search_meta(
586                 ['description', 'og:description', 'twitter:description'],
587                 webpage, default=None)
588         if not video_description and is_pro:
589             orig_webpage = self._download_webpage(
590                 orig_url, video_id,
591                 note='Downloading webpage for description',
592                 fatal=False)
593             if orig_webpage:
594                 video_description = self._html_search_meta(
595                     'description', orig_webpage, default=None)
596         if not video_description:
597             self._downloader.report_warning('Cannot find video description')
598         if not timestamp:
599             timestamp = self._search_regex(
600                 r'&lt;time[^&gt;]+datetime="([^"]+)"', webpage,
601                 'timestamp', default=None)
602         formats = []
603         source_format = self._extract_original_format(
604             'https://vimeo.com/' + video_id, video_id, video.get('unlisted_hash'))
605         if source_format:
606             formats.append(source_format)
607         info_dict_config = self._parse_config(config, video_id)
608         formats.extend(info_dict_config['formats'])
609         self._vimeo_sort_formats(formats)
610         json_ld = self._search_json_ld(webpage, video_id, default={})
611         if not cc_license:
612             cc_license = self._search_regex(
613                 r'&lt;link[^&gt;]+rel=["\']license["\'][^&gt;]+href=(["\'])(?P&lt;license&gt;(?:(?!\1).)+)\1',
614                 webpage, 'license', default=None, group='license')
615         info_dict.update({
616             'formats': formats,
617             'timestamp': unified_timestamp(timestamp),
618             'description': video_description,
619             'webpage_url': url,
620 <a name="3"></a>            'license': cc_license,
621         })
622         return merge_dicts<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(info_dict, info_dict_config, json_ld)
623 class VimeoOndemandIE(VimeoIE):
624     IE_NAME = 'vimeo:ondemand'
625     _VALID_URL = r'https?://(?:www\.)?vimeo\.com/ondemand/(?:[^/]+/)?(?P&lt;id&gt;[^/?#&amp;]+)'
626     _TESTS = [{
627         'url': 'https://vimeo.com/ondemand/20704',
628         'md5': 'c424deda8c7f73c1dfb3edd7630e2f35',
629         'info_dict': {
630             'id': '105442900',
631             'ext': 'mp4',
632             'title': 'המעבדה - במאי יותם פלדמן',
633             'uploader': 'גם סרטים',
634             'uploader_url': r're:https?://(?:www\.)?vimeo\.com/gumfilms',
635             'uploader_id': 'gumfilms',
636             'description': 'md5:4c027c965e439de4baab621e48b60791',
637             'upload_date': '20140906',
638             'timestamp': 1410032453,
639         },
640         'params': {
641             'format': 'best[protocol=https]',
642         },
643         'expected_warnings': ['Unable to download JSON metadata'],
644     }, {
645         'url': 'https://vimeo.com/ondemand/36938/126682985',
646         'info_dict': {
647             'id': '126584684',
648             'ext': 'mp4',
649             'title': 'Rävlock, rätt läte på rätt plats',
650             'uploader': 'Lindroth &amp; Norin',
651             'uploader_url': r're:https?://(?:www\.)?vimeo\.com/lindrothnorin',
652             'uploader_id': 'lindrothnorin',
653             'description': 'md5:c3c46a90529612c8279fb6af803fc0df',
654             'upload_date': '20150502',
655             'timestamp': 1430586422,
656         },
657         'params': {
658             'skip_download'</b></font>: True,
659         },
660         'expected_warnings': ['Unable to download JSON metadata'],
661     }, {
662         'url': 'https://vimeo.com/ondemand/nazmaalik',
663         'only_matching': True,
664     }, {
665         'url': 'https://vimeo.com/ondemand/141692381',
666         'only_matching': True,
667     }, {
668         'url': 'https://vimeo.com/ondemand/thelastcolony/150274832',
669         'only_matching': True,
670     }]
671 class VimeoChannelIE(VimeoBaseInfoExtractor):
672     IE_NAME = 'vimeo:channel'
673     _VALID_URL = r'https://vimeo\.com/channels/(?P&lt;id&gt;[^/?#]+)/?(?:$|[?#])'
674     _MORE_PAGES_INDICATOR = r'&lt;a.+?rel="next"'
675     _TITLE = None
676     _TITLE_RE = r'&lt;link rel="alternate"[^&gt;]+?title="(.*?)"'
677     _TESTS = [{
678         'url': 'https://vimeo.com/channels/tributes',
679         'info_dict': {
680             'id': 'tributes',
681             'title': 'Vimeo Tributes',
682         },
683         'playlist_mincount': 25,
684     }]
685     _BASE_URL_TEMPL = 'https://vimeo.com/channels/%s'
686     def _page_url(self, base_url, pagenum):
687         return '%s/videos/page:%d/' % (base_url, pagenum)
688     def _extract_list_title(self, webpage):
689         return self._TITLE or self._html_search_regex(
690             self._TITLE_RE, webpage, 'list title', fatal=False)
691     def _title_and_entries(self, list_id, base_url):
692         for pagenum in itertools.count(1):
693             page_url = self._page_url(base_url, pagenum)
694             webpage = self._download_webpage(
695                 page_url, list_id,
696                 'Downloading page %s' % pagenum)
697             if pagenum == 1:
698                 yield self._extract_list_title(webpage)
699             clips = re.findall(
700                 r'id="clip_(\d+)"[^&gt;]*&gt;\s*&lt;a[^&gt;]+href="(/(?:[^/]+/)*\1)(?:[^&gt;]+\btitle="([^"]+)")?', webpage)
701             if clips:
702                 for video_id, video_url, video_title in clips:
703                     yield self.url_result(
704                         compat_urlparse.urljoin(base_url, video_url),
705                         VimeoIE.ie_key(), video_id=video_id, video_title=video_title)
706             else:
707                 for video_id in re.findall(r'id=["\']clip_(\d+)', webpage):
708                     yield self.url_result(
709                         'https://vimeo.com/%s' % video_id,
710                         VimeoIE.ie_key(), video_id=video_id)
711             if re.search(self._MORE_PAGES_INDICATOR, webpage, re.DOTALL) is None:
712                 break
713     def _extract_videos(self, list_id, base_url):
714         title_and_entries = self._title_and_entries(list_id, base_url)
715 <a name="2"></a>        list_title = next(title_and_entries)
716         return self.playlist_result(title_and_entries, list_id, list_title)
717     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def _real_extract(self, url):
718         channel_id = self._match_id(url)
719         return self._extract_videos(channel_id, self._BASE_URL_TEMPL % channel_id)
720 class VimeoUserIE(VimeoChannelIE):
721     IE_NAME = 'vimeo:user'
722     _VALID_URL = r'https://vimeo\.com/(?!(?:[0-9]+|watchlater)(?:$|[?#/]))(?P&lt;id&gt;[^/]+)(?:/videos|[#?]|$)'
723     _TITLE_RE = r'&lt;a[^&gt;]+?class="user"&gt;([^&lt;&gt;]+?)&lt;/a&gt;'
724     _TESTS = [{</b></font>
725         'url': 'https://vimeo.com/nkistudio/videos',
726         'info_dict': {
727             'title': 'Nki',
728             'id': 'nkistudio',
729         },
730         'playlist_mincount': 66,
731     }]
732     _BASE_URL_TEMPL = 'https://vimeo.com/%s'
733 class VimeoAlbumIE(VimeoBaseInfoExtractor):
734     IE_NAME = 'vimeo:album'
735     _VALID_URL = r'https://vimeo\.com/(?:album|showcase)/(?P&lt;id&gt;\d+)(?:$|[?#]|/(?!video))'
736     _TITLE_RE = r'&lt;header id="page_header"&gt;\n\s*&lt;h1&gt;(.*?)&lt;/h1&gt;'
737     _TESTS = [{
738         'url': 'https://vimeo.com/album/2632481',
739         'info_dict': {
740             'id': '2632481',
741             'title': 'Staff Favorites: November 2013',
742         },
743         'playlist_mincount': 13,
744     }, {
745         'note': 'Password-protected album',
746         'url': 'https://vimeo.com/album/3253534',
747         'info_dict': {
748             'title': 'test',
749             'id': '3253534',
750         },
751         'playlist_count': 1,
752         'params': {
753             'videopassword': 'youtube-dl',
754         }
755     }]
756     _PAGE_SIZE = 100
757     def _fetch_page(self, album_id, authorization, hashed_pass, page):
758         api_page = page + 1
759         query = {
760             'fields': 'link,uri',
761             'page': api_page,
762             'per_page': self._PAGE_SIZE,
763         }
764         if hashed_pass:
765             query['_hashed_pass'] = hashed_pass
766         try:
767             videos = self._download_json(
768                 'https://api.vimeo.com/albums/%s/videos' % album_id,
769                 album_id, 'Downloading page %d' % api_page, query=query, headers={
770                     'Authorization': 'jwt ' + authorization,
771                 })['data']
772         except ExtractorError as e:
773             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 400:
774                 return
775         for video in videos:
776             link = video.get('link')
777             if not link:
778                 continue
779             uri = video.get('uri')
780             video_id = self._search_regex(r'/videos/(\d+)', uri, 'video_id', default=None) if uri else None
781             yield self.url_result(link, VimeoIE.ie_key(), video_id)
782     def _real_extract(self, url):
783         album_id = self._match_id(url)
784         viewer = self._download_json(
785             'https://vimeo.com/_rv/viewer', album_id, fatal=False)
786         if not viewer:
787             webpage = self._download_webpage(url, album_id)
788             viewer = self._parse_json(self._search_regex(
789                 r'bootstrap_data\s*=\s*({.+?})&lt;/script&gt;',
790                 webpage, 'bootstrap data'), album_id)['viewer']
791         jwt = viewer['jwt']
792         album = self._download_json(
793             'https://api.vimeo.com/albums/' + album_id,
794             album_id, headers={'Authorization': 'jwt ' + jwt},
795             query={'fields': 'description,name,privacy'})
796         hashed_pass = None
797         if try_get(album, lambda x: x['privacy']['view']) == 'password':
798             password = self._downloader.params.get('videopassword')
799             if not password:
800                 raise ExtractorError(
801                     'This album is protected by a password, use the --video-password option',
802                     expected=True)
803             self._set_vimeo_cookie('vuid', viewer['vuid'])
804             try:
805                 hashed_pass = self._download_json(
806                     'https://vimeo.com/showcase/%s/auth' % album_id,
807                     album_id, 'Verifying the password', data=urlencode_postdata({
808                         'password': password,
809                         'token': viewer['xsrft'],
810                     }), headers={
811                         'X-Requested-With': 'XMLHttpRequest',
812                     })['hashed_pass']
813             except ExtractorError as e:
814                 if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:
815                     raise ExtractorError('Wrong password', expected=True)
816                 raise
817         entries = OnDemandPagedList(functools.partial(
818             self._fetch_page, album_id, jwt, hashed_pass), self._PAGE_SIZE)
819         return self.playlist_result(
820             entries, album_id, album.get('name'), album.get('description'))
821 class VimeoGroupsIE(VimeoChannelIE):
822     IE_NAME = 'vimeo:group'
823     _VALID_URL = r'https://vimeo\.com/groups/(?P&lt;id&gt;[^/]+)(?:/(?!videos?/\d+)|$)'
824     _TESTS = [{
825         'url': 'https://vimeo.com/groups/kattykay',
826         'info_dict': {
827             'id': 'kattykay',
828             'title': 'Katty Kay',
829         },
830         'playlist_mincount': 27,
831     }]
832     _BASE_URL_TEMPL = 'https://vimeo.com/groups/%s'
833 class VimeoReviewIE(VimeoBaseInfoExtractor):
834     IE_NAME = 'vimeo:review'
835     IE_DESC = 'Review pages on vimeo'
836     _VALID_URL = r'(?P&lt;url&gt;https://vimeo\.com/[^/]+/review/(?P&lt;id&gt;[^/]+)/[0-9a-f]{10})'
837     _TESTS = [{
838         'url': 'https://vimeo.com/user21297594/review/75524534/3c257a1b5d',
839         'md5': 'c507a72f780cacc12b2248bb4006d253',
840         'info_dict': {
841             'id': '75524534',
842             'ext': 'mp4',
843             'title': "DICK HARDWICK 'Comedian'",
844             'uploader': 'Richard Hardwick',
845             'uploader_id': 'user21297594',
846             'description': "Comedian Dick Hardwick's five minute demo filmed in front of a live theater audience.\nEdit by Doug Mattocks",
847         },
848         'expected_warnings': ['Unable to download JSON metadata'],
849     }, {
850         'note': 'video player needs Referer',
851         'url': 'https://vimeo.com/user22258446/review/91613211/13f927e053',
852         'md5': '6295fdab8f4bf6a002d058b2c6dce276',
853         'info_dict': {
854             'id': '91613211',
855             'ext': 'mp4',
856             'title': 're:(?i)^Death by dogma versus assembling agile . Sander Hoogendoorn',
857             'uploader': 'DevWeek Events',
858             'duration': 2773,
859             'thumbnail': r're:^https?://.*\.jpg$',
860             'uploader_id': 'user22258446',
861         },
862         'skip': 'video gone',
863     }, {
864         'note': 'Password protected',
865         'url': 'https://vimeo.com/user37284429/review/138823582/c4d865efde',
866         'info_dict': {
867             'id': '138823582',
868             'ext': 'mp4',
869             'title': 'EFFICIENT PICKUP MASTERCLASS MODULE 1',
870             'uploader': 'TMB',
871             'uploader_id': 'user37284429',
872         },
873         'params': {
874             'videopassword': 'holygrail',
875         },
876         'skip': 'video gone',
877     }]
878     def _real_initialize(self):
879         self._login()
880     def _real_extract(self, url):
881         page_url, video_id = re.match(self._VALID_URL, url).groups()
882         data = self._download_json(
883             page_url.replace('/review/', '/review/data/'), video_id)
884         if data.get('isLocked') is True:
885             video_password = self._get_video_password()
886             viewer = self._download_json(
887                 'https://vimeo.com/_rv/viewer', video_id)
888             webpage = self._verify_video_password(
889                 'https://vimeo.com/' + video_id, video_id,
890                 video_password, viewer['xsrft'], viewer['vuid'])
891             clip_page_config = self._parse_json(self._search_regex(
892                 r'window\.vimeo\.clip_page_config\s*=\s*({.+?});',
893                 webpage, 'clip page config'), video_id)
894             config_url = clip_page_config['player']['config_url']
895             clip_data = clip_page_config.get('clip') or {}
896         else:
897             clip_data = data['clipData']
898             config_url = clip_data['configUrl']
899         config = self._download_json(config_url, video_id)
900         info_dict = self._parse_config(config, video_id)
901         source_format = self._extract_original_format(
902             page_url + '/action', video_id)
903         if source_format:
904             info_dict['formats'].append(source_format)
905         self._vimeo_sort_formats(info_dict['formats'])
906         info_dict['description'] = clean_html(clip_data.get('description'))
907         return info_dict
908 class VimeoWatchLaterIE(VimeoChannelIE):
909     IE_NAME = 'vimeo:watchlater'
910     IE_DESC = 'Vimeo watch later list, "vimeowatchlater" keyword (requires authentication)'
911     _VALID_URL = r'https://vimeo\.com/(?:home/)?watchlater|:vimeowatchlater'
912     _TITLE = 'Watch Later'
913     _LOGIN_REQUIRED = True
914     _TESTS = [{
915         'url': 'https://vimeo.com/watchlater',
916         'only_matching': True,
917     }]
918     def _real_initialize(self):
919         self._login()
920     def _page_url(self, base_url, pagenum):
921         url = '%s/page:%d/' % (base_url, pagenum)
922         request = sanitized_Request(url)
923         request.add_header('X-Requested-With', 'XMLHttpRequest')
924         return request
925     def _real_extract(self, url):
926         return self._extract_videos('watchlater', 'https://vimeo.com/watchlater')
927 class VimeoLikesIE(VimeoChannelIE):
928     _VALID_URL = r'https://(?:www\.)?vimeo\.com/(?P&lt;id&gt;[^/]+)/likes/?(?:$|[?#]|sort:)'
929     IE_NAME = 'vimeo:likes'
930     IE_DESC = 'Vimeo user likes'
931     _TESTS = [{
932         'url': 'https://vimeo.com/user755559/likes/',
933         'playlist_mincount': 293,
934         'info_dict': {
935             'id': 'user755559',
936             'title': 'urza’s Likes',
937         },
938     }, {
939         'url': 'https://vimeo.com/stormlapse/likes',
940         'only_matching': True,
941     }]
942     def _page_url(self, base_url, pagenum):
943         return '%s/page:%d/' % (base_url, pagenum)
944     def _real_extract(self, url):
945         user_id = self._match_id(url)
946         return self._extract_videos(user_id, 'https://vimeo.com/%s/likes' % user_id)
947 class VHXEmbedIE(VimeoBaseInfoExtractor):
948     IE_NAME = 'vhx:embed'
949     _VALID_URL = r'https?://embed\.vhx\.tv/videos/(?P&lt;id&gt;\d+)'
950     @staticmethod
951 <a name="5"></a>    def _extract_url(webpage):
952         mobj = re.search(
953             r'&lt;iframe[^&gt;]+src="(https?://embed\.vhx\.tv/videos/\d+[^"]*)"', webpage)
954         return unescapeHTML<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(mobj.group(1)) if mobj else None
955     def _real_extract(self, url):
956         video_id = self._match_id(url)
957         webpage = self._download_webpage(</b></font>url, video_id)
958         config_url = self._parse_json(self._search_regex(
959             r'window\.OTTData\s*=\s*({.+})', webpage,
960             'ott data'), video_id, js_to_json)['config_url']
961         config = self._download_json(config_url, video_id)
962         info = self._parse_config(config, video_id)
963         info['id'] = video_id
964         self._vimeo_sort_formats(info['formats'])
965         return info
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
