
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</h3>
            <pre><code>1  import binascii
2  import copy
3  import hashlib
4  import io
5  import os
6  import re
7  import struct
<span onclick='openModal()' class='match'>8  from .loader import ESPLoader
9  from .targets import (
10      ESP32C2ROM,
11      ESP32C3ROM,
12      ESP32C6BETAROM,
13      ESP32C6ROM,
14      ESP32H2BETA1ROM,
15      ESP32H2BETA2ROM,
16      ESP32H2ROM,
</span>17      ESP32ROM,
18      ESP32S2ROM,
19      ESP32S3BETA2ROM,
20      ESP32S3ROM,
21      ESP8266ROM,
22  )
23  from .util import FatalError, byte, pad_to
24  def align_file_position(f, size):
25      align = (size - 1) - (f.tell() % size)
26      f.seek(align, 1)
27  def LoadFirmwareImage(chip, image_file):
28      def select_image_class(f, chip):
29          chip = re.sub(r&quot;[-()]&quot;, &quot;&quot;, chip.lower())
30          if chip != &quot;esp8266&quot;:
31              return {
32                  &quot;esp32&quot;: ESP32FirmwareImage,
33                  &quot;esp32s2&quot;: ESP32S2FirmwareImage,
34                  &quot;esp32s3beta2&quot;: ESP32S3BETA2FirmwareImage,
35                  &quot;esp32s3&quot;: ESP32S3FirmwareImage,
36                  &quot;esp32c3&quot;: ESP32C3FirmwareImage,
37                  &quot;esp32c6beta&quot;: ESP32C6BETAFirmwareImage,
38                  &quot;esp32h2beta1&quot;: ESP32H2BETA1FirmwareImage,
39                  &quot;esp32h2beta2&quot;: ESP32H2BETA2FirmwareImage,
40                  &quot;esp32c2&quot;: ESP32C2FirmwareImage,
41                  &quot;esp32c6&quot;: ESP32C6FirmwareImage,
42                  &quot;esp32h2&quot;: ESP32H2FirmwareImage,
43              }[chip](f)
44          else:  # Otherwise, ESP8266 so look at magic to determine the image type
45              magic = ord(f.read(1))
46              f.seek(0)
47              if magic == ESPLoader.ESP_IMAGE_MAGIC:
48                  return ESP8266ROMFirmwareImage(f)
49              elif magic == ESP8266V2FirmwareImage.IMAGE_V2_MAGIC:
50                  return ESP8266V2FirmwareImage(f)
51              else:
52                  raise FatalError(&quot;Invalid image magic number: %d&quot; % magic)
53      if isinstance(image_file, str):
54          with open(image_file, &quot;rb&quot;) as f:
55              return select_image_class(f, chip)
56      return select_image_class(image_file, chip)
57  class ImageSegment(object):
58      def __init__(self, addr, data, file_offs=None):
59          self.addr = addr
60          self.data = data
61          self.file_offs = file_offs
62          self.include_in_checksum = True
63          if self.addr != 0:
64              self.pad_to_alignment(
65                  4
66              )  # pad all &quot;real&quot; ImageSegments 4 byte aligned length
67      def copy_with_new_addr(self, new_addr):
68          return ImageSegment(new_addr, self.data, 0)
69      def split_image(self, split_len):
70          result = copy.copy(self)
71          result.data = self.data[:split_len]
72          self.data = self.data[split_len:]
73          self.addr += split_len
74          self.file_offs = None
75          result.file_offs = None
76          return result
77      def __repr__(self):
78          r = &quot;len 0x%05x load 0x%08x&quot; % (len(self.data), self.addr)
79          if self.file_offs is not None:
80              r += &quot; file_offs 0x%08x&quot; % (self.file_offs)
81          return r
82      def get_memory_type(self, image):
83          return [
84              map_range[2]
85              for map_range in image.ROM_LOADER.MEMORY_MAP
86              if map_range[0] &lt;= self.addr &lt; map_range[1]
87          ]
88      def pad_to_alignment(self, alignment):
89          self.data = pad_to(self.data, alignment, b&quot;\x00&quot;)
90  class ELFSection(ImageSegment):
91      def __init__(self, name, addr, data):
92          super(ELFSection, self).__init__(addr, data)
93          self.name = name.decode(&quot;utf-8&quot;)
94      def __repr__(self):
95          return &quot;%s %s&quot; % (self.name, super(ELFSection, self).__repr__())
96  class BaseFirmwareImage(object):
97      SEG_HEADER_LEN = 8
98      SHA256_DIGEST_LEN = 32
99      def __init__(self):
100          self.segments = []
101          self.entrypoint = 0
102          self.elf_sha256 = None
103          self.elf_sha256_offset = 0
104          self.pad_to_size = 0
105      def load_common_header(self, load_file, expected_magic):
106          (
107              magic,
108              segments,
109              self.flash_mode,
110              self.flash_size_freq,
111              self.entrypoint,
112          ) = struct.unpack(&quot;&lt;BBBBI&quot;, load_file.read(8))
113          if magic != expected_magic:
114              raise FatalError(&quot;Invalid firmware image magic=0x%x&quot; % (magic))
115          return segments
116      def verify(self):
117          if len(self.segments) &gt; 16:
118              raise FatalError(
119                  &quot;Invalid segment count %d (max 16). &quot;
120                  &quot;Usually this indicates a linker script problem.&quot; % len(self.segments)
121              )
122      def load_segment(self, f, is_irom_segment=False):
123          file_offs = f.tell()
124          (offset, size) = struct.unpack(&quot;&lt;II&quot;, f.read(8))
125          self.warn_if_unusual_segment(offset, size, is_irom_segment)
126          segment_data = f.read(size)
127          if len(segment_data) &lt; size:
128              raise FatalError(
129                  &quot;End of file reading segment 0x%x, length %d (actual length %d)&quot;
130                  % (offset, size, len(segment_data))
131              )
132          segment = ImageSegment(offset, segment_data, file_offs)
133          self.segments.append(segment)
134          return segment
135      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
136          if not is_irom_segment:
137              if offset &gt; 0x40200000 or offset &lt; 0x3FFE0000 or size &gt; 65536:
138                  print(&quot;WARNING: Suspicious segment 0x%x, length %d&quot; % (offset, size))
139      def maybe_patch_segment_data(self, f, segment_data):
140          segment_len = len(segment_data)
141          file_pos = f.tell()  # file_pos is position in the .bin file
142          if (
143              self.elf_sha256_offset &gt;= file_pos
144              and self.elf_sha256_offset &lt; file_pos + segment_len
145          ):
146              patch_offset = self.elf_sha256_offset - file_pos
147              if (
148                  patch_offset &lt; self.SEG_HEADER_LEN
149                  or patch_offset + self.SHA256_DIGEST_LEN &gt; segment_len
150              ):
151                  raise FatalError(
152                      &quot;Cannot place SHA256 digest on segment boundary&quot;
153                      &quot;(elf_sha256_offset=%d, file_pos=%d, segment_size=%d)&quot;
154                      % (self.elf_sha256_offset, file_pos, segment_len)
155                  )
156              patch_offset -= self.SEG_HEADER_LEN
157              if (
158                  segment_data[patch_offset : patch_offset + self.SHA256_DIGEST_LEN]
159                  != b&quot;\x00&quot; * self.SHA256_DIGEST_LEN
160              ):
161                  raise FatalError(
162                      &quot;Contents of segment at SHA256 digest offset 0x%x are not all zero.&quot;
163                      &quot; Refusing to overwrite.&quot; % self.elf_sha256_offset
164                  )
165              assert len(self.elf_sha256) == self.SHA256_DIGEST_LEN
166              segment_data = (
167                  segment_data[0:patch_offset]
168                  + self.elf_sha256
169                  + segment_data[patch_offset + self.SHA256_DIGEST_LEN :]
170              )
171          return segment_data
172      def save_segment(self, f, segment, checksum=None):
173          segment_data = self.maybe_patch_segment_data(f, segment.data)
174          f.write(struct.pack(&quot;&lt;II&quot;, segment.addr, len(segment_data)))
175          f.write(segment_data)
176          if checksum is not None:
177              return ESPLoader.checksum(segment_data, checksum)
178      def read_checksum(self, f):
179          align_file_position(f, 16)
180          return ord(f.read(1))
181      def calculate_checksum(self):
182          checksum = ESPLoader.ESP_CHECKSUM_MAGIC
183          for seg in self.segments:
184              if seg.include_in_checksum:
185                  checksum = ESPLoader.checksum(seg.data, checksum)
186          return checksum
187      def append_checksum(self, f, checksum):
188          align_file_position(f, 16)
189          f.write(struct.pack(b&quot;B&quot;, checksum))
190      def write_common_header(self, f, segments):
191          f.write(
192              struct.pack(
193                  &quot;&lt;BBBBI&quot;,
194                  ESPLoader.ESP_IMAGE_MAGIC,
195                  len(segments),
196                  self.flash_mode,
197                  self.flash_size_freq,
198                  self.entrypoint,
199              )
200          )
201      def is_irom_addr(self, addr):
202          return ESP8266ROM.IROM_MAP_START &lt;= addr &lt; ESP8266ROM.IROM_MAP_END
203      def get_irom_segment(self):
204          irom_segments = [s for s in self.segments if self.is_irom_addr(s.addr)]
205          if len(irom_segments) &gt; 0:
206              if len(irom_segments) != 1:
207                  raise FatalError(
208                      &quot;Found %d segments that could be irom0. Bad ELF file?&quot;
209                      % len(irom_segments)
210                  )
211              return irom_segments[0]
212          return None
213      def get_non_irom_segments(self):
214          irom_segment = self.get_irom_segment()
215          return [s for s in self.segments if s != irom_segment]
216      def merge_adjacent_segments(self):
217          if not self.segments:
218              return  # nothing to merge
219          segments = []
220          for i in range(len(self.segments) - 1, 0, -1):
221              elem = self.segments[i - 1]
222              next_elem = self.segments[i]
223              if all(
224                  (
225                      elem.get_memory_type(self) == next_elem.get_memory_type(self),
226                      elem.include_in_checksum == next_elem.include_in_checksum,
227                      next_elem.addr == elem.addr + len(elem.data),
228                  )
229              ):
230                  elem.data += next_elem.data
231              else:
232                  segments.insert(0, next_elem)
233          segments.insert(0, self.segments[0])
234          self.segments = segments
235      def set_mmu_page_size(self, size):
236          print(
237              &quot;WARNING: Changing MMU page size is not supported on {}! &quot;
238              &quot;Defaulting to 64KB.&quot;.format(self.ROM_LOADER.CHIP_NAME)
239          )
240  class ESP8266ROMFirmwareImage(BaseFirmwareImage):
241      ROM_LOADER = ESP8266ROM
242      def __init__(self, load_file=None):
243          super(ESP8266ROMFirmwareImage, self).__init__()
244          self.flash_mode = 0
245          self.flash_size_freq = 0
246          self.version = 1
247          if load_file is not None:
248              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
249              for _ in range(segments):
250                  self.load_segment(load_file)
251              self.checksum = self.read_checksum(load_file)
252              self.verify()
253      def default_output_name(self, input_file):
254          return input_file + &quot;-&quot;
255      def save(self, basename):
256          irom_segment = self.get_irom_segment()
257          if irom_segment is not None:
258              with open(
259                  &quot;%s0x%05x.bin&quot;
260                  % (basename, irom_segment.addr - ESP8266ROM.IROM_MAP_START),
261                  &quot;wb&quot;,
262              ) as f:
263                  f.write(irom_segment.data)
264          normal_segments = self.get_non_irom_segments()
265          with open(&quot;%s0x00000.bin&quot; % basename, &quot;wb&quot;) as f:
266              self.write_common_header(f, normal_segments)
267              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
268              for segment in normal_segments:
269                  checksum = self.save_segment(f, segment, checksum)
270              self.append_checksum(f, checksum)
271  ESP8266ROM.BOOTLOADER_IMAGE = ESP8266ROMFirmwareImage
272  class ESP8266V2FirmwareImage(BaseFirmwareImage):
273      ROM_LOADER = ESP8266ROM
274      IMAGE_V2_MAGIC = 0xEA
275      IMAGE_V2_SEGMENT = 4
276      def __init__(self, load_file=None):
277          super(ESP8266V2FirmwareImage, self).__init__()
278          self.version = 2
279          if load_file is not None:
280              segments = self.load_common_header(load_file, self.IMAGE_V2_MAGIC)
281              if segments != self.IMAGE_V2_SEGMENT:
282                  print(
283                      &#x27;Warning: V2 header has unexpected &quot;segment&quot; count %d (usually 4)&#x27;
284                      % segments
285                  )
286              irom_segment = self.load_segment(load_file, True)
287              irom_segment.addr = 0
288              irom_segment.include_in_checksum = False
289              first_flash_mode = self.flash_mode
290              first_flash_size_freq = self.flash_size_freq
291              first_entrypoint = self.entrypoint
292              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
293              if first_flash_mode != self.flash_mode:
294                  print(
295                      &quot;WARNING: Flash mode value in first header (0x%02x) disagrees &quot;
296                      &quot;with second (0x%02x). Using second value.&quot;
297                      % (first_flash_mode, self.flash_mode)
298                  )
299              if first_flash_size_freq != self.flash_size_freq:
300                  print(
301                      &quot;WARNING: Flash size/freq value in first header (0x%02x) disagrees &quot;
302                      &quot;with second (0x%02x). Using second value.&quot;
303                      % (first_flash_size_freq, self.flash_size_freq)
304                  )
305              if first_entrypoint != self.entrypoint:
306                  print(
307                      &quot;WARNING: Entrypoint address in first header (0x%08x) disagrees &quot;
308                      &quot;with second header (0x%08x). Using second value.&quot;
309                      % (first_entrypoint, self.entrypoint)
310                  )
311              for _ in range(segments):
312                  self.load_segment(load_file)
313              self.checksum = self.read_checksum(load_file)
314              self.verify()
315      def default_output_name(self, input_file):
316          irom_segment = self.get_irom_segment()
317          if irom_segment is not None:
318              irom_offs = irom_segment.addr - ESP8266ROM.IROM_MAP_START
319          else:
320              irom_offs = 0
321          return &quot;%s-0x%05x.bin&quot; % (
322              os.path.splitext(input_file)[0],
323              irom_offs &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1),
324          )
325      def save(self, filename):
326          with open(filename, &quot;wb&quot;) as f:
327              f.write(
328                  struct.pack(
329                      b&quot;&lt;BBBBI&quot;,
330                      self.IMAGE_V2_MAGIC,
331                      self.IMAGE_V2_SEGMENT,
332                      self.flash_mode,
333                      self.flash_size_freq,
334                      self.entrypoint,
335                  )
336              )
337              irom_segment = self.get_irom_segment()
338              if irom_segment is not None:
339                  irom_segment = irom_segment.copy_with_new_addr(0)
340                  irom_segment.pad_to_alignment(
341                      16
342                  )  # irom_segment must end on a 16 byte boundary
343                  self.save_segment(f, irom_segment)
344              normal_segments = self.get_non_irom_segments()
345              self.write_common_header(f, normal_segments)
346              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
347              for segment in normal_segments:
348                  checksum = self.save_segment(f, segment, checksum)
349              self.append_checksum(f, checksum)
350          with open(filename, &quot;rb&quot;) as f:
351              crc = esp8266_crc32(f.read())
352          with open(filename, &quot;ab&quot;) as f:
353              f.write(struct.pack(b&quot;&lt;I&quot;, crc))
354  def esp8266_crc32(data):
355      crc = binascii.crc32(data, 0) &amp; 0xFFFFFFFF
356      if crc &amp; 0x80000000:
357          return crc ^ 0xFFFFFFFF
358      else:
359          return crc + 1
360  class ESP32FirmwareImage(BaseFirmwareImage):
361      ROM_LOADER = ESP32ROM
362      WP_PIN_DISABLED = 0xEE
363      EXTENDED_HEADER_STRUCT_FMT = &quot;&lt;BBBBHBHH&quot; + (&quot;B&quot; * 4) + &quot;B&quot;
364      IROM_ALIGN = 65536
365      def __init__(self, load_file=None, append_digest=True):
366          super(ESP32FirmwareImage, self).__init__()
367          self.secure_pad = None
368          self.flash_mode = 0
369          self.flash_size_freq = 0
370          self.version = 1
371          self.wp_pin = self.WP_PIN_DISABLED
372          self.clk_drv = 0
373          self.q_drv = 0
374          self.d_drv = 0
375          self.cs_drv = 0
376          self.hd_drv = 0
377          self.wp_drv = 0
378          self.chip_id = 0
379          self.min_rev = 0
380          self.min_rev_full = 0
381          self.max_rev_full = 0
382          self.append_digest = append_digest
383          if load_file is not None:
384              start = load_file.tell()
385              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
386              self.load_extended_header(load_file)
387              for _ in range(segments):
388                  self.load_segment(load_file)
389              self.checksum = self.read_checksum(load_file)
390              if self.append_digest:
391                  end = load_file.tell()
392                  self.stored_digest = load_file.read(32)
393                  load_file.seek(start)
394                  calc_digest = hashlib.sha256()
395                  calc_digest.update(load_file.read(end - start))
396                  self.calc_digest = calc_digest.digest()  # TODO: decide what to do here?
397              self.verify()
398      def is_flash_addr(self, addr):
399          return (
400              self.ROM_LOADER.IROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.IROM_MAP_END
401          ) or (self.ROM_LOADER.DROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.DROM_MAP_END)
402      def default_output_name(self, input_file):
403          return &quot;%s.bin&quot; % (os.path.splitext(input_file)[0])
404      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
405          pass  # TODO: add warnings for wrong ESP32 segment offset/size combinations
406      def save(self, filename):
407          total_segments = 0
408          with io.BytesIO() as f:  # write file to memory first
409              self.write_common_header(f, self.segments)
410              self.save_extended_header(f)
411              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
412              flash_segments = [
413                  copy.deepcopy(s)
414                  for s in sorted(self.segments, key=lambda s: s.addr)
415                  if self.is_flash_addr(s.addr)
416              ]
417              ram_segments = [
418                  copy.deepcopy(s)
419                  for s in sorted(self.segments, key=lambda s: s.addr)
420                  if not self.is_flash_addr(s.addr)
421              ]
422              for segment in flash_segments:
423                  if segment.name == &quot;.flash.appdesc&quot;:
424                      flash_segments.remove(segment)
425                      flash_segments.insert(0, segment)
426                      break
427              for segment in ram_segments:
428                  if segment.name == &quot;.dram0.bootdesc&quot;:
429                      ram_segments.remove(segment)
430                      ram_segments.insert(0, segment)
431                      break
432              if len(flash_segments) &gt; 0:
433                  last_addr = flash_segments[0].addr
434                  for segment in flash_segments[1:]:
435                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
436                          raise FatalError(
437                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
438                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
439                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
440                              % (segment.addr, last_addr)
441                          )
442                      last_addr = segment.addr
443              def get_alignment_data_needed(segment):
444                  align_past = (segment.addr % self.IROM_ALIGN) - self.SEG_HEADER_LEN
445                  pad_len = (self.IROM_ALIGN - (f.tell() % self.IROM_ALIGN)) + align_past
446                  if pad_len == 0 or pad_len == self.IROM_ALIGN:
447                      return 0  # already aligned
448                  pad_len -= self.SEG_HEADER_LEN
449                  if pad_len &lt; 0:
450                      pad_len += self.IROM_ALIGN
451                  return pad_len
452              while len(flash_segments) &gt; 0:
453                  segment = flash_segments[0]
454                  pad_len = get_alignment_data_needed(segment)
455                  if pad_len &gt; 0:  # need to pad
456                      if len(ram_segments) &gt; 0 and pad_len &gt; self.SEG_HEADER_LEN:
457                          pad_segment = ram_segments[0].split_image(pad_len)
458                          if len(ram_segments[0].data) == 0:
459                              ram_segments.pop(0)
460                      else:
461                          pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
462                      checksum = self.save_segment(f, pad_segment, checksum)
463                      total_segments += 1
464                  else:
465                      assert (
466                          f.tell() + 8
467                      ) % self.IROM_ALIGN == segment.addr % self.IROM_ALIGN
468                      checksum = self.save_flash_segment(f, segment, checksum)
469                      flash_segments.pop(0)
470                      total_segments += 1
471              for segment in ram_segments:
472                  checksum = self.save_segment(f, segment, checksum)
473                  total_segments += 1
474              if self.secure_pad:
475                  if not self.append_digest:
476                      raise FatalError(
477                          &quot;secure_pad only applies if a SHA-256 digest &quot;
478                          &quot;is also appended to the image&quot;
479                      )
480                  align_past = (f.tell() + self.SEG_HEADER_LEN) % self.IROM_ALIGN
481                  checksum_space = 16
482                  if self.secure_pad == &quot;1&quot;:
483                      space_after_checksum = 32 + 4 + 64 + 12
484                  elif self.secure_pad == &quot;2&quot;:  # Secure Boot V2
485                      space_after_checksum = 32
486                  pad_len = (
487                      self.IROM_ALIGN - align_past - checksum_space - space_after_checksum
488                  ) % self.IROM_ALIGN
489                  pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
490                  checksum = self.save_segment(f, pad_segment, checksum)
491                  total_segments += 1
492              self.append_checksum(f, checksum)
493              image_length = f.tell()
494              if self.secure_pad:
495                  assert ((image_length + space_after_checksum) % self.IROM_ALIGN) == 0
496              f.seek(1)
497              f.write(bytes([total_segments]))
498              if self.append_digest:
499                  f.seek(0)
500                  digest = hashlib.sha256()
501                  digest.update(f.read(image_length))
502                  f.write(digest.digest())
503              if self.pad_to_size:
504                  image_length = f.tell()
505                  if image_length % self.pad_to_size != 0:
506                      pad_by = self.pad_to_size - (image_length % self.pad_to_size)
507                      f.write(b&quot;\xff&quot; * pad_by)
508              with open(filename, &quot;wb&quot;) as real_file:
509                  real_file.write(f.getvalue())
510      def save_flash_segment(self, f, segment, checksum=None):
511          segment_end_pos = f.tell() + len(segment.data) + self.SEG_HEADER_LEN
512          segment_len_remainder = segment_end_pos % self.IROM_ALIGN
513          if segment_len_remainder &lt; 0x24:
514              segment.data += b&quot;\x00&quot; * (0x24 - segment_len_remainder)
515          return self.save_segment(f, segment, checksum)
516      def load_extended_header(self, load_file):
517          def split_byte(n):
518              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
519          fields = list(
520              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
521          )
522          self.wp_pin = fields[0]
523          self.clk_drv, self.q_drv = split_byte(fields[1])
524          self.d_drv, self.cs_drv = split_byte(fields[2])
525          self.hd_drv, self.wp_drv = split_byte(fields[3])
526          self.chip_id = fields[4]
527          if self.chip_id != self.ROM_LOADER.IMAGE_CHIP_ID:
528              print(
529                  (
530                      &quot;Unexpected chip id in image. Expected %d but value was %d. &quot;
531                      &quot;Is this image for a different chip model?&quot;
532                  )
533                  % (self.ROM_LOADER.IMAGE_CHIP_ID, self.chip_id)
534              )
535          self.min_rev = fields[5]
536          self.min_rev_full = fields[6]
537          self.max_rev_full = fields[7]
538          append_digest = fields[-1]  # last byte is append_digest
539          if append_digest in [0, 1]:
540              self.append_digest = append_digest == 1
541          else:
542              raise RuntimeError(
543                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
544                  append_digest,
545              )
546      def save_extended_header(self, save_file):
547          def join_byte(ln, hn):
548              return (ln &amp; 0x0F) + ((hn &amp; 0x0F) &lt;&lt; 4)
549          append_digest = 1 if self.append_digest else 0
550          fields = [
551              self.wp_pin,
552              join_byte(self.clk_drv, self.q_drv),
553              join_byte(self.d_drv, self.cs_drv),
554              join_byte(self.hd_drv, self.wp_drv),
555              self.ROM_LOADER.IMAGE_CHIP_ID,
556              self.min_rev,
557              self.min_rev_full,
558              self.max_rev_full,
559          ]
560          fields += [0] * 4  # padding
561          fields += [append_digest]
562          packed = struct.pack(self.EXTENDED_HEADER_STRUCT_FMT, *fields)
563          save_file.write(packed)
564  class ESP8266V3FirmwareImage(ESP32FirmwareImage):
565      EXTENDED_HEADER_STRUCT_FMT = &quot;B&quot; * 16
566      def is_flash_addr(self, addr):
567          return addr &gt; ESP8266ROM.IROM_MAP_START
568      def save(self, filename):
569          total_segments = 0
570          with io.BytesIO() as f:  # write file to memory first
571              self.write_common_header(f, self.segments)
572              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
573              flash_segments = [
574                  copy.deepcopy(s)
575                  for s in sorted(self.segments, key=lambda s: s.addr)
576                  if self.is_flash_addr(s.addr) and len(s.data)
577              ]
578              ram_segments = [
579                  copy.deepcopy(s)
580                  for s in sorted(self.segments, key=lambda s: s.addr)
581                  if not self.is_flash_addr(s.addr) and len(s.data)
582              ]
583              if len(flash_segments) &gt; 0:
584                  last_addr = flash_segments[0].addr
585                  for segment in flash_segments[1:]:
586                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
587                          raise FatalError(
588                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
589                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
590                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
591                              % (segment.addr, last_addr)
592                          )
593                      last_addr = segment.addr
594              while len(flash_segments) &gt; 0:
595                  segment = flash_segments[0]
596                  if segment.name == &quot;.flash.rodata&quot;:
597                      segment.data = segment.data[8:]
598                  checksum = self.save_segment(f, segment, checksum)
599                  flash_segments.pop(0)
600                  total_segments += 1
601              for segment in ram_segments:
602                  checksum = self.save_segment(f, segment, checksum)
603                  total_segments += 1
604              self.append_checksum(f, checksum)
605              image_length = f.tell()
606              f.seek(1)
607              f.write(bytes([total_segments]))
608              if self.append_digest:
609                  f.seek(0)
610                  digest = hashlib.sha256()
611                  digest.update(f.read(image_length))
612                  f.write(digest.digest())
613              with open(filename, &quot;wb&quot;) as real_file:
614                  real_file.write(f.getvalue())
615      def load_extended_header(self, load_file):
616          def split_byte(n):
617              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
618          fields = list(
619              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
620          )
621          self.wp_pin = fields[0]
622          self.clk_drv, self.q_drv = split_byte(fields[1])
623          self.d_drv, self.cs_drv = split_byte(fields[2])
624          self.hd_drv, self.wp_drv = split_byte(fields[3])
625          if fields[15] in [0, 1]:
626              self.append_digest = fields[15] == 1
627          else:
628              raise RuntimeError(
629                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
630                  fields[15],
631              )
632          if any(f for f in fields[4:15] if f != 0):
633              print(
634                  &quot;Warning: some reserved header fields have non-zero values. &quot;
635                  &quot;This image may be from a newer esptool.py?&quot;
636              )
637  ESP32ROM.BOOTLOADER_IMAGE = ESP32FirmwareImage
638  class ESP32S2FirmwareImage(ESP32FirmwareImage):
639      ROM_LOADER = ESP32S2ROM
640  ESP32S2ROM.BOOTLOADER_IMAGE = ESP32S2FirmwareImage
641  class ESP32S3BETA2FirmwareImage(ESP32FirmwareImage):
642      ROM_LOADER = ESP32S3BETA2ROM
643  ESP32S3BETA2ROM.BOOTLOADER_IMAGE = ESP32S3BETA2FirmwareImage
644  class ESP32S3FirmwareImage(ESP32FirmwareImage):
645      ROM_LOADER = ESP32S3ROM
646  ESP32S3ROM.BOOTLOADER_IMAGE = ESP32S3FirmwareImage
647  class ESP32C3FirmwareImage(ESP32FirmwareImage):
648      ROM_LOADER = ESP32C3ROM
649  ESP32C3ROM.BOOTLOADER_IMAGE = ESP32C3FirmwareImage
650  class ESP32C6BETAFirmwareImage(ESP32FirmwareImage):
651      ROM_LOADER = ESP32C6BETAROM
652  ESP32C6BETAROM.BOOTLOADER_IMAGE = ESP32C6BETAFirmwareImage
653  class ESP32H2BETA1FirmwareImage(ESP32FirmwareImage):
654      ROM_LOADER = ESP32H2BETA1ROM
655  ESP32H2BETA1ROM.BOOTLOADER_IMAGE = ESP32H2BETA1FirmwareImage
656  class ESP32H2BETA2FirmwareImage(ESP32FirmwareImage):
657      ROM_LOADER = ESP32H2BETA2ROM
658  ESP32H2BETA2ROM.BOOTLOADER_IMAGE = ESP32H2BETA2FirmwareImage
659  class ESP32C2FirmwareImage(ESP32FirmwareImage):
660      ROM_LOADER = ESP32C2ROM
661      def set_mmu_page_size(self, size):
662          if size not in [16384, 32768, 65536]:
663              raise FatalError(
664                  &quot;{} bytes is not a valid ESP32-C2 page size, &quot;
665                  &quot;select from 64KB, 32KB, 16KB.&quot;.format(size)
666              )
667          self.IROM_ALIGN = size
668  ESP32C2ROM.BOOTLOADER_IMAGE = ESP32C2FirmwareImage
669  class ESP32C6FirmwareImage(ESP32FirmwareImage):
670      ROM_LOADER = ESP32C6ROM
671      def set_mmu_page_size(self, size):
672          if size not in [8192, 16384, 32768, 65536]:
673              raise FatalError(
674                  &quot;{} bytes is not a valid ESP32-C6 page size, &quot;
675                  &quot;select from 64KB, 32KB, 16KB, 8KB.&quot;.format(size)
676              )
677          self.IROM_ALIGN = size
678  ESP32C6ROM.BOOTLOADER_IMAGE = ESP32C6FirmwareImage
679  class ESP32H2FirmwareImage(ESP32C6FirmwareImage):
680      ROM_LOADER = ESP32H2ROM
681  ESP32H2ROM.BOOTLOADER_IMAGE = ESP32H2FirmwareImage
682  class ELFFile(object):
683      SEC_TYPE_PROGBITS = 0x01
684      SEC_TYPE_STRTAB = 0x03
685      SEC_TYPE_INITARRAY = 0x0E
686      SEC_TYPE_FINIARRAY = 0x0F
687      PROG_SEC_TYPES = (SEC_TYPE_PROGBITS, SEC_TYPE_INITARRAY, SEC_TYPE_FINIARRAY)
688      LEN_SEC_HEADER = 0x28
689      SEG_TYPE_LOAD = 0x01
690      LEN_SEG_HEADER = 0x20
691      def __init__(self, name):
692          self.name = name
693          with open(self.name, &quot;rb&quot;) as f:
694              self._read_elf_file(f)
695      def get_section(self, section_name):
696          for s in self.sections:
697              if s.name == section_name:
698                  return s
699          raise ValueError(&quot;No section %s in ELF file&quot; % section_name)
700      def _read_elf_file(self, f):
701          LEN_FILE_HEADER = 0x34
702          try:
703              (
704                  ident,
705                  _type,
706                  machine,
707                  _version,
708                  self.entrypoint,
709                  _phoff,
710                  shoff,
711                  _flags,
712                  _ehsize,
713                  _phentsize,
714                  _phnum,
715                  shentsize,
716                  shnum,
717                  shstrndx,
718              ) = struct.unpack(&quot;&lt;16sHHLLLLLHHHHHH&quot;, f.read(LEN_FILE_HEADER))
719          except struct.error as e:
720              raise FatalError(
721                  &quot;Failed to read a valid ELF header from %s: %s&quot; % (self.name, e)
722              )
723          if byte(ident, 0) != 0x7F or ident[1:4] != b&quot;ELF&quot;:
724              raise FatalError(&quot;%s has invalid ELF magic header&quot; % self.name)
725          if machine not in [0x5E, 0xF3]:
726              raise FatalError(
727                  &quot;%s does not appear to be an Xtensa or an RISCV ELF file. &quot;
728                  &quot;e_machine=%04x&quot; % (self.name, machine)
729              )
730          if shentsize != self.LEN_SEC_HEADER:
731              raise FatalError(
732                  &quot;%s has unexpected section header entry size 0x%x (not 0x%x)&quot;
733                  % (self.name, shentsize, self.LEN_SEC_HEADER)
734              )
735          if shnum == 0:
736              raise FatalError(&quot;%s has 0 section headers&quot; % (self.name))
737          self._read_sections(f, shoff, shnum, shstrndx)
738          self._read_segments(f, _phoff, _phnum, shstrndx)
739      def _read_sections(self, f, section_header_offs, section_header_count, shstrndx):
740          f.seek(section_header_offs)
741          len_bytes = section_header_count * self.LEN_SEC_HEADER
742          section_header = f.read(len_bytes)
743          if len(section_header) == 0:
744              raise FatalError(
745                  &quot;No section header found at offset %04x in ELF file.&quot;
746                  % section_header_offs
747              )
748          if len(section_header) != (len_bytes):
749              raise FatalError(
750                  &quot;Only read 0x%x bytes from section header (expected 0x%x.) &quot;
751                  &quot;Truncated ELF file?&quot; % (len(section_header), len_bytes)
752              )
753          section_header_offsets = range(0, len(section_header), self.LEN_SEC_HEADER)
754          def read_section_header(offs):
755              name_offs, sec_type, _flags, lma, sec_offs, size = struct.unpack_from(
756                  &quot;&lt;LLLLLL&quot;, section_header[offs:]
757              )
758              return (name_offs, sec_type, lma, size, sec_offs)
759          all_sections = [read_section_header(offs) for offs in section_header_offsets]
760          prog_sections = [s for s in all_sections if s[1] in ELFFile.PROG_SEC_TYPES]
761          if not (shstrndx * self.LEN_SEC_HEADER) in section_header_offsets:
762              raise FatalError(&quot;ELF file has no STRTAB section at shstrndx %d&quot; % shstrndx)
763          _, sec_type, _, sec_size, sec_offs = read_section_header(
764              shstrndx * self.LEN_SEC_HEADER
765          )
766          if sec_type != ELFFile.SEC_TYPE_STRTAB:
767              print(
768                  &quot;WARNING: ELF file has incorrect STRTAB section type 0x%02x&quot; % sec_type
769              )
770          f.seek(sec_offs)
771          string_table = f.read(sec_size)
772          def lookup_string(offs):
773              raw = string_table[offs:]
774              return raw[: raw.index(b&quot;\x00&quot;)]
775          def read_data(offs, size):
776              f.seek(offs)
777              return f.read(size)
778          prog_sections = [
779              ELFSection(lookup_string(n_offs), lma, read_data(offs, size))
780              for (n_offs, _type, lma, size, offs) in prog_sections
781              if lma != 0 and size &gt; 0
782          ]
783          self.sections = prog_sections
784      def _read_segments(self, f, segment_header_offs, segment_header_count, shstrndx):
785          f.seek(segment_header_offs)
786          len_bytes = segment_header_count * self.LEN_SEG_HEADER
787          segment_header = f.read(len_bytes)
788          if len(segment_header) == 0:
789              raise FatalError(
790                  &quot;No segment header found at offset %04x in ELF file.&quot;
791                  % segment_header_offs
792              )
793          if len(segment_header) != (len_bytes):
794              raise FatalError(
795                  &quot;Only read 0x%x bytes from segment header (expected 0x%x.) &quot;
796                  &quot;Truncated ELF file?&quot; % (len(segment_header), len_bytes)
797              )
798          segment_header_offsets = range(0, len(segment_header), self.LEN_SEG_HEADER)
799          def read_segment_header(offs):
800              (
801                  seg_type,
802                  seg_offs,
803                  _vaddr,
804                  lma,
805                  size,
806                  _memsize,
807                  _flags,
808                  _align,
809              ) = struct.unpack_from(&quot;&lt;LLLLLLLL&quot;, segment_header[offs:])
810              return (seg_type, lma, size, seg_offs)
811          all_segments = [read_segment_header(offs) for offs in segment_header_offsets]
812          prog_segments = [s for s in all_segments if s[0] == ELFFile.SEG_TYPE_LOAD]
813          def read_data(offs, size):
814              f.seek(offs)
815              return f.read(size)
816          prog_segments = [
817              ELFSection(b&quot;PHDR&quot;, lma, read_data(offs, size))
818              for (_type, lma, size, offs) in prog_segments
819              if lma != 0 and size &gt; 0
820          ]
821          self.segments = prog_segments
822      def sha256(self):
823          sha256 = hashlib.sha256()
824          with open(self.name, &quot;rb&quot;) as f:
825              sha256.update(f.read())
826          return sha256.digest()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
10  import time
<span onclick='openModal()' class='match'>11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
</span>20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
25      print(
26          &quot;Pyserial is not installed for %s. &quot;
27          &quot;Check the README for installation instructions.&quot; % (sys.executable)
28      )
29      raise
30  try:
31      if &quot;serialization&quot; in serial.__doc__ and &quot;deserialization&quot; in serial.__doc__:
32          raise ImportError(
33              &quot;esptool.py depends on pyserial, but there is a conflict with a currently &quot;
34              &quot;installed package named &#x27;serial&#x27;.\n&quot;
35              &quot;You may work around this by &#x27;pip uninstall serial; pip install pyserial&#x27; &quot;
36              &quot;but this may break other installed Python software &quot;
37              &quot;that depends on &#x27;serial&#x27;.\n&quot;
38              &quot;There is no good fix for this right now, &quot;
39              &quot;apart from configuring virtualenvs. &quot;
40              &quot;See https://github.com/espressif/esptool/issues/269#issuecomment-385298196&quot;
41              &quot; for discussion of the underlying issue(s).&quot;
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          &quot;The installed version (%s) of pyserial appears to be too old for esptool.py &quot;
50          &quot;(Python interpreter %s). Check the README for installation instructions.&quot;
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == &quot;darwin&quot;:
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg[&quot;esptool&quot;]
61  DEFAULT_TIMEOUT = cfg.getfloat(&quot;timeout&quot;, 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat(&quot;chip_erase_timeout&quot;, 120)
63  MAX_TIMEOUT = cfg.getfloat(&quot;max_timeout&quot;, CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat(&quot;sync_timeout&quot;, 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat(&quot;md5_timeout_per_mb&quot;, 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat(&quot;erase_region_timeout_per_mb&quot;, 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat(&quot;erase_write_timeout_per_mb&quot;, 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat(&quot;mem_end_rom_timeout&quot;, 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat(&quot;serial_write_timeout&quot;, 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint(&quot;connect_attempts&quot;, 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint(&quot;write_block_attempts&quot;, 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), &quot;targets&quot;, &quot;stub_flasher&quot;)
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace(&quot;esp&quot;, &quot;&quot;)
76      return os.path.join(STUBS_DIR, f&quot;stub_flasher_{chip_name}.json&quot;)
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result &lt; DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in [&quot;ESP8266&quot;]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in [&quot;ESP8266&quot;, &quot;ESP32&quot;, &quot;ESP32-S2&quot;]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub[&quot;text&quot;])
105          self.text_start = stub[&quot;text_start&quot;]
106          self.entry = stub[&quot;entry&quot;]
107          try:
108              self.data = base64.b64decode(stub[&quot;data&quot;])
109              self.data_start = stub[&quot;data_start&quot;]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = &quot;Espressif device&quot;
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = &quot;/dev/ttyUSB0&quot;
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: &quot;ESP32-S3(beta 3)&quot;}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              &quot;flash_id&quot;: None,
165              &quot;chip_id&quot;: None,
166              &quot;uart_no&quot;: None,
167              &quot;usb_pid&quot;: None,
168          }
169          if isinstance(port, str):
170              try:
171                  self._port = serial.serial_for_url(port)
172              except serial.serialutil.SerialException:
173                  raise FatalError(f&quot;Could not open {port}, the port doesn&#x27;t exist&quot;)
174          else:
175              self._port = port
176          self._slip_reader = slip_reader(self._port, self.trace)
177          self._set_port_baudrate(baud)
178          self._trace_enabled = trace_enabled
179          try:
180              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
181          except NotImplementedError:
182              self._port.write_timeout = None
183      @property
184      def serial_port(self):
185          return self._port.port
186      def _set_port_baudrate(self, baud):
187          try:
188              self._port.baudrate = baud
189          except IOError:
190              raise FatalError(
191                  &quot;Failed to set baud rate %d. The driver may not support this rate.&quot;
192                  % baud
193              )
194      def read(self):
195          return next(self._slip_reader)
196      def write(self, packet):
197          buf = (
198              b&quot;\xc0&quot;
199              + (packet.replace(b&quot;\xdb&quot;, b&quot;\xdb\xdd&quot;).replace(b&quot;\xc0&quot;, b&quot;\xdb\xdc&quot;))
200              + b&quot;\xc0&quot;
201          )
202          self.trace(&quot;Write %d bytes: %s&quot;, len(buf), HexFormatter(buf))
203          self._port.write(buf)
204      def trace(self, message, *format_args):
205          if self._trace_enabled:
206              now = time.time()
207              try:
208                  delta = now - self._last_trace
209              except AttributeError:
210                  delta = 0.0
211              self._last_trace = now
212              prefix = &quot;TRACE +%.3f &quot; % delta
213              print(prefix + (message % format_args))
214      @staticmethod
215      def checksum(data, state=ESP_CHECKSUM_MAGIC):
216          for b in data:
217              state ^= b
218          return state
219      def command(
220          self,
221          op=None,
222          data=b&quot;&quot;,
223          chk=0,
224          wait_response=True,
225          timeout=DEFAULT_TIMEOUT,
226      ):
227          saved_timeout = self._port.timeout
228          new_timeout = min(timeout, MAX_TIMEOUT)
229          if new_timeout != saved_timeout:
230              self._port.timeout = new_timeout
231          try:
232              if op is not None:
233                  self.trace(
234                      &quot;command op=0x%02x data len=%s wait_response=%d &quot;
235                      &quot;timeout=%.3f data=%s&quot;,
236                      op,
237                      len(data),
238                      1 if wait_response else 0,
239                      timeout,
240                      HexFormatter(data),
241                  )
242                  pkt = struct.pack(b&quot;&lt;BBHI&quot;, 0x00, op, len(data), chk) + data
243                  self.write(pkt)
244              if not wait_response:
245                  return
246              for retry in range(100):
247                  p = self.read()
248                  if len(p) &lt; 8:
249                      continue
250                  (resp, op_ret, len_ret, val) = struct.unpack(&quot;&lt;BBHI&quot;, p[:8])
251                  if resp != 1:
252                      continue
253                  data = p[8:]
254                  if op is None or op_ret == op:
255                      return val, data
256                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
257                      self.flush_input()
258                      raise UnsupportedCommandError(self, op)
259          finally:
260              if new_timeout != saved_timeout:
261                  self._port.timeout = saved_timeout
262          raise FatalError(&quot;Response doesn&#x27;t match request&quot;)
263      def check_command(
264          self, op_description, op=None, data=b&quot;&quot;, chk=0, timeout=DEFAULT_TIMEOUT
265      ):
266          val, data = self.command(op, data, chk, timeout=timeout)
267          if len(data) &lt; self.STATUS_BYTES_LENGTH:
268              raise FatalError(
269                  &quot;Failed to %s. Only got %d byte status response.&quot;
270                  % (op_description, len(data))
271              )
272          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
273          if byte(status_bytes, 0) != 0:
274              raise FatalError.WithResult(&quot;Failed to %s&quot; % op_description, status_bytes)
275          if len(data) &gt; self.STATUS_BYTES_LENGTH:
276              return data[: -self.STATUS_BYTES_LENGTH]
277          else:
278              return val
279      def flush_input(self):
280          self._port.flushInput()
281          self._slip_reader = slip_reader(self._port, self.trace)
282      def sync(self):
283          val, _ = self.command(
284              self.ESP_SYNC, b&quot;\x07\x07\x12\x20&quot; + 32 * b&quot;\x55&quot;, timeout=SYNC_TIMEOUT
285          )
286          self.sync_stub_detected = val == 0
287          for _ in range(7):
288              val, _ = self.command()
289              self.sync_stub_detected &amp;= val == 0
290      def _get_pid(self):
291          if self.cache[&quot;usb_pid&quot;] is not None:
292              return self.cache[&quot;usb_pid&quot;]
293          if list_ports is None:
294              print(
295                  &quot;\nListing all serial ports is currently not available. &quot;
296                  &quot;Can&#x27;t get device PID.&quot;
297              )
298              return
299          active_port = self._port.port
300          if not active_port.lower().startswith((&quot;com&quot;, &quot;/dev/&quot;)):
301              print(
302                  &quot;\nDevice PID identification is only supported on &quot;
303                  &quot;COM and /dev/ serial ports.&quot;
304              )
305              return
306          if active_port.startswith(&quot;/dev/&quot;) and os.path.islink(active_port):
307              active_port = os.path.realpath(active_port)
308          active_ports = [active_port]
309          if sys.platform == &quot;darwin&quot; and &quot;tty&quot; in active_port:
310              active_ports.append(active_port.replace(&quot;tty&quot;, &quot;cu&quot;))
311          ports = list_ports.comports()
312          for p in ports:
313              if p.device in active_ports:
314                  self.cache[&quot;usb_pid&quot;] = p.pid
315                  return p.pid
316          print(
317              f&quot;\nFailed to get PID of a device on {active_port}, &quot;
318              &quot;using standard reset sequence.&quot;
319          )
320      def _connect_attempt(self, reset_strategy, mode=&quot;default_reset&quot;):
321          last_error = None
322          boot_log_detected = False
323          download_mode = False
324          if mode == &quot;no_reset_no_sync&quot;:
325              return last_error
326          if mode != &quot;no_reset&quot;:
327              if not self.USES_RFC2217:  # Might block on rfc2217 ports
328                  self._port.reset_input_buffer()
329              reset_strategy()  # Reset the chip to bootloader (download mode)
330              waiting = self._port.inWaiting()
331              read_bytes = self._port.read(waiting)
332              data = re.search(
333                  b&quot;boot:(0x[0-9a-fA-F]+)(.*waiting for download)?&quot;, read_bytes, re.DOTALL
334              )
335              if data is not None:
336                  boot_log_detected = True
337                  boot_mode = data.group(1)
338                  download_mode = data.group(2) is not None
339          for _ in range(5):
340              try:
341                  self.flush_input()
342                  self._port.flushOutput()
343                  self.sync()
344                  return None
345              except FatalError as e:
346                  print(&quot;.&quot;, end=&quot;&quot;)
347                  sys.stdout.flush()
348                  time.sleep(0.05)
349                  last_error = e
350          if boot_log_detected:
351              last_error = FatalError(
352                  &quot;Wrong boot mode detected ({})! &quot;
353                  &quot;The chip needs to be in download mode.&quot;.format(
354                      boot_mode.decode(&quot;utf-8&quot;)
355                  )
356              )
357              if download_mode:
358                  last_error = FatalError(
359                      &quot;Download mode successfully detected, but getting no sync reply: &quot;
360                      &quot;The serial TX path seems to be down.&quot;
361                  )
362          return last_error
363      def get_memory_region(self, name):
364          try:
365              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
366          except IndexError:
367              return None
368      def _construct_reset_strategy_sequence(self, mode):
369          cfg_custom_reset_sequence = cfg.get(&quot;custom_reset_sequence&quot;)
370          if cfg_custom_reset_sequence is not None:
371              return (CustomReset(self._port, cfg_custom_reset_sequence),)
372          cfg_reset_delay = cfg.getfloat(&quot;reset_delay&quot;)
373          if cfg_reset_delay is not None:
374              delay = extra_delay = cfg_reset_delay
375          else:
376              delay = DEFAULT_RESET_DELAY
377              extra_delay = DEFAULT_RESET_DELAY + 0.5
378          if (
379              self.FPGA_SLOW_BOOT
380              and os.environ.get(&quot;ESPTOOL_ENV_FPGA&quot;, &quot;&quot;).strip() == &quot;1&quot;
381          ):
382              delay = extra_delay = 7
383          if mode == &quot;usb_reset&quot; or self._get_pid() == self.USB_JTAG_SERIAL_PID:
384              return (USBJTAGSerialReset(self._port),)
385          if os.name != &quot;nt&quot; and not self._port.name.startswith(&quot;rfc2217:&quot;):
386              return (
387                  UnixTightReset(self._port, delay),
388                  UnixTightReset(self._port, extra_delay),
389                  ClassicReset(self._port, delay),
390                  ClassicReset(self._port, extra_delay),
391              )
392          return (
393              ClassicReset(self._port, delay),
394              ClassicReset(self._port, extra_delay),
395          )
396      def connect(
397          self,
398          mode=&quot;default_reset&quot;,
399          attempts=DEFAULT_CONNECT_ATTEMPTS,
400          detecting=False,
401          warnings=True,
402      ):
403          if warnings and mode in [&quot;no_reset&quot;, &quot;no_reset_no_sync&quot;]:
404              print(
405                  &#x27;WARNING: Pre-connection option &quot;{}&quot; was selected.&#x27;.format(mode),
406                  &quot;Connection may fail if the chip is not in bootloader &quot;
407                  &quot;or flasher stub mode.&quot;,
408              )
409          print(&quot;Connecting...&quot;, end=&quot;&quot;)
410          sys.stdout.flush()
411          last_error = None
412          reset_sequence = self._construct_reset_strategy_sequence(mode)
413          try:
414              for _, reset_strategy in zip(
415                  range(attempts) if attempts &gt; 0 else itertools.count(),
416                  itertools.cycle(reset_sequence),
417              ):
418                  last_error = self._connect_attempt(reset_strategy, mode)
419                  if last_error is None:
420                      break
421          finally:
422              print(&quot;&quot;)  # end &#x27;Connecting...&#x27; line
423          if last_error is not None:
424              raise FatalError(
425                  &quot;Failed to connect to {}: {}&quot;
426                  &quot;\nFor troubleshooting steps visit: &quot;
427                  &quot;https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html&quot;.format(  # noqa E501
428                      self.CHIP_NAME, last_error
429                  )
430              )
431          if not detecting:
432              try:
433                  from .targets import ROM_LIST
434                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
435                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
436                      actually = None
437                      for cls in ROM_LIST:
438                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
439                              actually = cls
440                              break
441                      if warnings and actually is None:
442                          print(
443                              &quot;WARNING: This chip doesn&#x27;t appear to be a %s &quot;
444                              &quot;(chip magic value 0x%08x). &quot;
445                              &quot;Probably it is unsupported by this version of esptool.&quot;
446                              % (self.CHIP_NAME, chip_magic_value)
447                          )
448                      else:
449                          raise FatalError(
450                              &quot;This chip is %s not %s. Wrong --chip argument?&quot;
451                              % (actually.CHIP_NAME, self.CHIP_NAME)
452                          )
453              except UnsupportedCommandError:
454                  self.secure_download_mode = True
455              try:
456                  self.check_chip_id()
457              except UnsupportedCommandError:
458                  if self.secure_download_mode:
459                      self._connect_attempt(mode, reset_sequence[0])
460                      self.check_chip_id()
461                  else:
462                      raise
463              self._post_connect()
464      def _post_connect(self):
465          pass
466      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
467          val, data = self.command(
468              self.ESP_READ_REG, struct.pack(&quot;&lt;I&quot;, addr), timeout=timeout
469          )
470          if byte(data, 0) != 0:
471              raise FatalError.WithResult(
472                  &quot;Failed to read register address %08x&quot; % addr, data
473              )
474          return val
475      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
476          command = struct.pack(&quot;&lt;IIII&quot;, addr, value, mask, delay_us)
477          if delay_after_us &gt; 0:
478              command += struct.pack(
479                  &quot;&lt;IIII&quot;, self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
480              )
481          return self.check_command(&quot;write target memory&quot;, self.ESP_WRITE_REG, command)
482      def update_reg(self, addr, mask, new_val):
483          shift = mask_to_shift(mask)
484          val = self.read_reg(addr)
485          val &amp;= ~mask
486          val |= (new_val &lt;&lt; shift) &amp; mask
487          self.write_reg(addr, val)
488          return val
489      def mem_begin(self, size, blocks, blocksize, offset):
490          if self.IS_STUB:
491              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
492              load_start = offset
493              load_end = offset + size
494              for start, end in [
495                  (stub.data_start, stub.data_start + len(stub.data)),
496                  (stub.text_start, stub.text_start + len(stub.text)),
497              ]:
498                  if load_start &lt; end and load_end &gt; start:
499                      raise FatalError(
500                          &quot;Software loader is resident at 0x%08x-0x%08x. &quot;
501                          &quot;Can&#x27;t load binary at overlapping address range 0x%08x-0x%08x. &quot;
502                          &quot;Either change binary loading address, or use the --no-stub &quot;
503                          &quot;option to disable the software loader.&quot;
504                          % (start, end, load_start, load_end)
505                      )
506          return self.check_command(
507              &quot;enter RAM download mode&quot;,
508              self.ESP_MEM_BEGIN,
509              struct.pack(&quot;&lt;IIII&quot;, size, blocks, blocksize, offset),
510          )
511      def mem_block(self, data, seq):
512          return self.check_command(
513              &quot;write to target RAM&quot;,
514              self.ESP_MEM_DATA,
515              struct.pack(&quot;&lt;IIII&quot;, len(data), seq, 0, 0) + data,
516              self.checksum(data),
517          )
518      def mem_finish(self, entrypoint=0):
519          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
520          data = struct.pack(&quot;&lt;II&quot;, int(entrypoint == 0), entrypoint)
521          try:
522              return self.check_command(
523                  &quot;leave RAM download mode&quot;, self.ESP_MEM_END, data=data, timeout=timeout
524              )
525          except FatalError:
526              if self.IS_STUB:
527                  raise
528              pass
529      def flash_begin(self, size, offset, begin_rom_encrypted=False):
530          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
531          erase_size = self.get_erase_size(offset, size)
532          t = time.time()
533          if self.IS_STUB:
534              timeout = DEFAULT_TIMEOUT
535          else:
536              timeout = timeout_per_mb(
537                  ERASE_REGION_TIMEOUT_PER_MB, size
538              )  # ROM performs the erase up front
539          params = struct.pack(
540              &quot;&lt;IIII&quot;, erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
541          )
542          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
543              params += struct.pack(&quot;&lt;I&quot;, 1 if begin_rom_encrypted else 0)
544          self.check_command(
545              &quot;enter Flash download mode&quot;, self.ESP_FLASH_BEGIN, params, timeout=timeout
546          )
547          if size != 0 and not self.IS_STUB:
548              print(&quot;Took %.2fs to erase flash block&quot; % (time.time() - t))
549          return num_blocks
550      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
551          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
552              try:
553                  self.check_command(
554                      &quot;write to target Flash after seq %d&quot; % seq,
555                      self.ESP_FLASH_DATA,
556                      struct.pack(&quot;&lt;IIII&quot;, len(data), seq, 0, 0) + data,
557                      self.checksum(data),
558                      timeout=timeout,
559                  )
560                  break
561              except FatalError:
562                  if attempts_left:
563                      self.trace(
564                          &quot;Block write failed, &quot;
565                          f&quot;retrying with {attempts_left} attempts left&quot;
566                      )
567                  else:
568                      raise
569      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
570          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
571              return self.flash_block(data, seq, timeout)
572          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
573              try:
574                  self.check_command(
575                      &quot;Write encrypted to target Flash after seq %d&quot; % seq,
576                      self.ESP_FLASH_ENCRYPT_DATA,
577                      struct.pack(&quot;&lt;IIII&quot;, len(data), seq, 0, 0) + data,
578                      self.checksum(data),
579                      timeout=timeout,
580                  )
581                  break
582              except FatalError:
583                  if attempts_left:
584                      self.trace(
585                          &quot;Encrypted block write failed, &quot;
586                          f&quot;retrying with {attempts_left} attempts left&quot;
587                      )
588                  else:
589                      raise
590      def flash_finish(self, reboot=False):
591          pkt = struct.pack(&quot;&lt;I&quot;, int(not reboot))
592          self.check_command(&quot;leave Flash mode&quot;, self.ESP_FLASH_END, pkt)
593      def run(self, reboot=False):
594          self.flash_begin(0, 0)
595          self.flash_finish(reboot)
596      def flash_id(self):
597          if self.cache[&quot;flash_id&quot;] is None:
598              SPIFLASH_RDID = 0x9F
599              self.cache[&quot;flash_id&quot;] = self.run_spiflash_command(SPIFLASH_RDID, b&quot;&quot;, 24)
600          return self.cache[&quot;flash_id&quot;]
601      def flash_type(self):
602          return None  # not implemented for all chip targets
603      def get_security_info(self):
604          res = self.check_command(&quot;get security info&quot;, self.ESP_GET_SECURITY_INFO, b&quot;&quot;)
605          esp32s2 = True if len(res) == 12 else False
606          res = struct.unpack(&quot;&lt;IBBBBBBBB&quot; if esp32s2 else &quot;&lt;IBBBBBBBBII&quot;, res)
607          return {
608              &quot;flags&quot;: res[0],
609              &quot;flash_crypt_cnt&quot;: res[1],
610              &quot;key_purposes&quot;: res[2:9],
611              &quot;chip_id&quot;: None if esp32s2 else res[9],
612              &quot;api_version&quot;: None if esp32s2 else res[10],
613          }
614      @esp32s3_or_newer_function_only
615      def get_chip_id(self):
616          if self.cache[&quot;chip_id&quot;] is None:
617              res = self.check_command(
618                  &quot;get security info&quot;, self.ESP_GET_SECURITY_INFO, b&quot;&quot;
619              )
620              res = struct.unpack(
621                  &quot;&lt;IBBBBBBBBI&quot;, res[:16]
622              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
623              self.cache[&quot;chip_id&quot;] = res[9]  # 2/4 status bytes invariant
624          return self.cache[&quot;chip_id&quot;]
625      def get_uart_no(self):
626          if self.cache[&quot;uart_no&quot;] is None:
627              self.cache[&quot;uart_no&quot;] = self.read_reg(self.UARTDEV_BUF_NO) &amp; 0xFF
628          return self.cache[&quot;uart_no&quot;]
629      @classmethod
630      def parse_flash_size_arg(cls, arg):
631          try:
632              return cls.FLASH_SIZES[arg]
633          except KeyError:
634              raise FatalError(
635                  &quot;Flash size &#x27;%s&#x27; is not supported by this chip type. &quot;
636                  &quot;Supported sizes: %s&quot; % (arg, &quot;, &quot;.join(cls.FLASH_SIZES.keys()))
637              )
638      @classmethod
639      def parse_flash_freq_arg(cls, arg):
640          if arg is None:
641              return 0
642          try:
643              return cls.FLASH_FREQUENCY[arg]
644          except KeyError:
645              raise FatalError(
646                  &quot;Flash frequency &#x27;%s&#x27; is not supported by this chip type. &quot;
647                  &quot;Supported frequencies: %s&quot;
648                  % (arg, &quot;, &quot;.join(cls.FLASH_FREQUENCY.keys()))
649              )
650      def run_stub(self, stub=None):
651          if stub is None:
652              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
653          if self.sync_stub_detected:
654              print(&quot;Stub is already running. No upload is necessary.&quot;)
655              return self.STUB_CLASS(self)
656          print(&quot;Uploading stub...&quot;)
657          for field in [stub.text, stub.data]:
658              if field is not None:
659                  offs = stub.text_start if field == stub.text else stub.data_start
660                  length = len(field)
661                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
662                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
663                  for seq in range(blocks):
664                      from_offs = seq * self.ESP_RAM_BLOCK
665                      to_offs = from_offs + self.ESP_RAM_BLOCK
666                      self.mem_block(field[from_offs:to_offs], seq)
667          print(&quot;Running stub...&quot;)
668          self.mem_finish(stub.entry)
669          try:
670              p = self.read()
671          except StopIteration:
672              raise FatalError(
673                  &quot;Failed to start stub. There was no response.&quot;
674                  &quot;\nTry increasing timeouts, for more information see: &quot;
675                  &quot;https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html&quot;  # noqa E501
676              )
677          if p != b&quot;OHAI&quot;:
678              raise FatalError(f&quot;Failed to start stub. Unexpected response: {p}&quot;)
679          print(&quot;Stub running...&quot;)
680          return self.STUB_CLASS(self)
681      @stub_and_esp32_function_only
682      def flash_defl_begin(self, size, compsize, offset):
683          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
684          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
685          t = time.time()
686          if self.IS_STUB:
687              write_size = (
688                  size  # stub expects number of bytes here, manages erasing internally
689              )
690              timeout = DEFAULT_TIMEOUT
691          else:
692              write_size = (
693                  erase_blocks * self.FLASH_WRITE_SIZE
694              )  # ROM expects rounded up to erase block size
695              timeout = timeout_per_mb(
696                  ERASE_REGION_TIMEOUT_PER_MB, write_size
697              )  # ROM performs the erase up front
698          print(&quot;Compressed %d bytes to %d...&quot; % (size, compsize))
699          params = struct.pack(
700              &quot;&lt;IIII&quot;, write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
701          )
702          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
703              params += struct.pack(&quot;&lt;I&quot;, 0)
704          self.check_command(
705              &quot;enter compressed flash mode&quot;,
706              self.ESP_FLASH_DEFL_BEGIN,
707              params,
708              timeout=timeout,
709          )
710          if size != 0 and not self.IS_STUB:
711              print(&quot;Took %.2fs to erase flash block&quot; % (time.time() - t))
712          return num_blocks
713      @stub_and_esp32_function_only
714      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
715          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
716              try:
717                  self.check_command(
718                      &quot;write compressed data to flash after seq %d&quot; % seq,
719                      self.ESP_FLASH_DEFL_DATA,
720                      struct.pack(&quot;&lt;IIII&quot;, len(data), seq, 0, 0) + data,
721                      self.checksum(data),
722                      timeout=timeout,
723                  )
724                  break
725              except FatalError:
726                  if attempts_left:
727                      self.trace(
728                          &quot;Compressed block write failed, &quot;
729                          f&quot;retrying with {attempts_left} attempts left&quot;
730                      )
731                  else:
732                      raise
733      @stub_and_esp32_function_only
734      def flash_defl_finish(self, reboot=False):
735          if not reboot and not self.IS_STUB:
736              return
737          pkt = struct.pack(&quot;&lt;I&quot;, int(not reboot))
738          self.check_command(&quot;leave compressed flash mode&quot;, self.ESP_FLASH_DEFL_END, pkt)
739          self.in_bootloader = False
740      @stub_and_esp32_function_only
741      def flash_md5sum(self, addr, size):
742          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
743          res = self.check_command(
744              &quot;calculate md5sum&quot;,
745              self.ESP_SPI_FLASH_MD5,
746              struct.pack(&quot;&lt;IIII&quot;, addr, size, 0, 0),
747              timeout=timeout,
748          )
749          if len(res) == 32:
750              return res.decode(&quot;utf-8&quot;)  # already hex formatted
751          elif len(res) == 16:
752              return hexify(res).lower()
753          else:
754              raise FatalError(&quot;MD5Sum command returned unexpected result: %r&quot; % res)
755      @stub_and_esp32_function_only
756      def change_baud(self, baud):
757          print(&quot;Changing baud rate to %d&quot; % baud)
758          second_arg = self._port.baudrate if self.IS_STUB else 0
759          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack(&quot;&lt;II&quot;, baud, second_arg))
760          print(&quot;Changed.&quot;)
761          self._set_port_baudrate(baud)
762          time.sleep(0.05)  # get rid of crap sent during baud rate change
763          self.flush_input()
764      @stub_function_only
765      def erase_flash(self):
766          self.check_command(
767              &quot;erase flash&quot;, self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
768          )
769      @stub_function_only
770      def erase_region(self, offset, size):
771          if offset % self.FLASH_SECTOR_SIZE != 0:
772              raise FatalError(&quot;Offset to erase from must be a multiple of 4096&quot;)
773          if size % self.FLASH_SECTOR_SIZE != 0:
774              raise FatalError(&quot;Size of data to erase must be a multiple of 4096&quot;)
775          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
776          self.check_command(
777              &quot;erase region&quot;,
778              self.ESP_ERASE_REGION,
779              struct.pack(&quot;&lt;II&quot;, offset, size),
780              timeout=timeout,
781          )
782      def read_flash_slow(self, offset, length, progress_fn):
783          raise NotImplementedInROMError(self, self.read_flash_slow)
784      def read_flash(self, offset, length, progress_fn=None):
785          if not self.IS_STUB:
786              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
787          self.check_command(
788              &quot;read flash&quot;,
789              self.ESP_READ_FLASH,
790              struct.pack(&quot;&lt;IIII&quot;, offset, length, self.FLASH_SECTOR_SIZE, 64),
791          )
792          data = b&quot;&quot;
793          while len(data) &lt; length:
794              p = self.read()
795              data += p
796              if len(data) &lt; length and len(p) &lt; self.FLASH_SECTOR_SIZE:
797                  raise FatalError(
798                      &quot;Corrupt data, expected 0x%x bytes but received 0x%x bytes&quot;
799                      % (self.FLASH_SECTOR_SIZE, len(p))
800                  )
801              self.write(struct.pack(&quot;&lt;I&quot;, len(data)))
802              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
803                  progress_fn(len(data), length)
804          if progress_fn:
805              progress_fn(len(data), length)
806          if len(data) &gt; length:
807              raise FatalError(&quot;Read more than expected&quot;)
808          digest_frame = self.read()
809          if len(digest_frame) != 16:
810              raise FatalError(&quot;Expected digest, got: %s&quot; % hexify(digest_frame))
811          expected_digest = hexify(digest_frame).upper()
812          digest = hashlib.md5(data).hexdigest().upper()
813          if digest != expected_digest:
814              raise FatalError(
815                  &quot;Digest mismatch: expected %s, got %s&quot; % (expected_digest, digest)
816              )
817          return data
818      def flash_spi_attach(self, hspi_arg):
819          arg = struct.pack(&quot;&lt;I&quot;, hspi_arg)
820          if not self.IS_STUB:
821              is_legacy = 0
822              arg += struct.pack(&quot;BBBB&quot;, is_legacy, 0, 0, 0)
823          self.check_command(&quot;configure SPI flash pins&quot;, self.ESP_SPI_ATTACH, arg)
824      def flash_set_parameters(self, size):
825          fl_id = 0
826          total_size = size
827          block_size = 64 * 1024
828          sector_size = 4 * 1024
829          page_size = 256
830          status_mask = 0xFFFF
831          self.check_command(
832              &quot;set SPI params&quot;,
833              self.ESP_SPI_SET_PARAMS,
834              struct.pack(
835                  &quot;&lt;IIIIII&quot;,
836                  fl_id,
837                  total_size,
838                  block_size,
839                  sector_size,
840                  page_size,
841                  status_mask,
842              ),
843          )
844      def run_spiflash_command(
845          self,
846          spiflash_command,
847          data=b&quot;&quot;,
848          read_bits=0,
849          addr=None,
850          addr_len=0,
851          dummy_len=0,
852      ):
853          SPI_USR_COMMAND = 1 &lt;&lt; 31
854          SPI_USR_ADDR = 1 &lt;&lt; 30
855          SPI_USR_DUMMY = 1 &lt;&lt; 29
856          SPI_USR_MISO = 1 &lt;&lt; 28
857          SPI_USR_MOSI = 1 &lt;&lt; 27
858          base = self.SPI_REG_BASE
859          SPI_CMD_REG = base + 0x00
860          SPI_ADDR_REG = base + 0x04
861          SPI_USR_REG = base + self.SPI_USR_OFFS
862          SPI_USR1_REG = base + self.SPI_USR1_OFFS
863          SPI_USR2_REG = base + self.SPI_USR2_OFFS
864          SPI_W0_REG = base + self.SPI_W0_OFFS
865          if self.SPI_MOSI_DLEN_OFFS is not None:
866              def set_data_lengths(mosi_bits, miso_bits):
867                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
868                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
869                  if mosi_bits &gt; 0:
870                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
871                  if miso_bits &gt; 0:
872                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
873                  flags = 0
874                  if dummy_len &gt; 0:
875                      flags |= dummy_len - 1
876                  if addr_len &gt; 0:
877                      flags |= (addr_len - 1) &lt;&lt; SPI_USR_ADDR_LEN_SHIFT
878                  if flags:
879                      self.write_reg(SPI_USR1_REG, flags)
880          else:
881              def set_data_lengths(mosi_bits, miso_bits):
882                  SPI_DATA_LEN_REG = SPI_USR1_REG
883                  SPI_MOSI_BITLEN_S = 17
884                  SPI_MISO_BITLEN_S = 8
885                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
886                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
887                  flags = (miso_mask &lt;&lt; SPI_MISO_BITLEN_S) | (
888                      mosi_mask &lt;&lt; SPI_MOSI_BITLEN_S
889                  )
890                  if dummy_len &gt; 0:
891                      flags |= dummy_len - 1
892                  if addr_len &gt; 0:
893                      flags |= (addr_len - 1) &lt;&lt; SPI_USR_ADDR_LEN_SHIFT
894                  self.write_reg(SPI_DATA_LEN_REG, flags)
895          SPI_CMD_USR = 1 &lt;&lt; 18
896          SPI_USR2_COMMAND_LEN_SHIFT = 28
897          SPI_USR_ADDR_LEN_SHIFT = 26
898          if read_bits &gt; 32:
899              raise FatalError(
900                  &quot;Reading more than 32 bits back from a SPI flash &quot;
901                  &quot;operation is unsupported&quot;
902              )
903          if len(data) &gt; 64:
904              raise FatalError(
905                  &quot;Writing more than 64 bytes of data with one SPI &quot;
906                  &quot;command is unsupported&quot;
907              )
908          data_bits = len(data) * 8
909          old_spi_usr = self.read_reg(SPI_USR_REG)
910          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
911          flags = SPI_USR_COMMAND
912          if read_bits &gt; 0:
913              flags |= SPI_USR_MISO
914          if data_bits &gt; 0:
915              flags |= SPI_USR_MOSI
916          if addr_len &gt; 0:
917              flags |= SPI_USR_ADDR
918          if dummy_len &gt; 0:
919              flags |= SPI_USR_DUMMY
920          set_data_lengths(data_bits, read_bits)
921          self.write_reg(SPI_USR_REG, flags)
922          self.write_reg(
923              SPI_USR2_REG, (7 &lt;&lt; SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
924          )
925          if addr and addr_len &gt; 0:
926              self.write_reg(SPI_ADDR_REG, addr)
927          if data_bits == 0:
928              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
929          else:
930              data = pad_to(data, 4, b&quot;\00&quot;)  # pad to 32-bit multiple
931              words = struct.unpack(&quot;I&quot; * (len(data) // 4), data)
932              next_reg = SPI_W0_REG
933              for word in words:
934                  self.write_reg(next_reg, word)
935                  next_reg += 4
936          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
937          def wait_done():
938              for _ in range(10):
939                  if (self.read_reg(SPI_CMD_REG) &amp; SPI_CMD_USR) == 0:
940                      return
941              raise FatalError(&quot;SPI command did not complete in time&quot;)
942          wait_done()
943          status = self.read_reg(SPI_W0_REG)
944          self.write_reg(SPI_USR_REG, old_spi_usr)
945          self.write_reg(SPI_USR2_REG, old_spi_usr2)
946          return status
947      def read_spiflash_sfdp(self, addr, read_bits):
948          CMD_RDSFDP = 0x5A
949          return self.run_spiflash_command(
950              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
951          )
952      def read_status(self, num_bytes=2):
953          SPIFLASH_RDSR = 0x05
954          SPIFLASH_RDSR2 = 0x35
955          SPIFLASH_RDSR3 = 0x15
956          status = 0
957          shift = 0
958          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
959              status += self.run_spiflash_command(cmd, read_bits=8) &lt;&lt; shift
960              shift += 8
961          return status
962      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
963          SPIFLASH_WRSR = 0x01
964          SPIFLASH_WRSR2 = 0x31
965          SPIFLASH_WRSR3 = 0x11
966          SPIFLASH_WEVSR = 0x50
967          SPIFLASH_WREN = 0x06
968          SPIFLASH_WRDI = 0x04
969          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
970          if num_bytes == 2:
971              self.run_spiflash_command(enable_cmd)
972              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack(&quot;&lt;H&quot;, new_status))
973          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
974              self.run_spiflash_command(enable_cmd)
975              self.run_spiflash_command(cmd, struct.pack(&quot;B&quot;, new_status &amp; 0xFF))
976              new_status &gt;&gt;= 8
977          self.run_spiflash_command(SPIFLASH_WRDI)
978      def get_crystal_freq(self):
979          uart_div = self.read_reg(self.UART_CLKDIV_REG) &amp; self.UART_CLKDIV_MASK
980          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
981          norm_xtal = 40 if est_xtal &gt; 33 else 26
982          if abs(norm_xtal - est_xtal) &gt; 1:
983              print(
984                  &quot;WARNING: Detected crystal freq %.2fMHz is quite different to &quot;
985                  &quot;normalized freq %dMHz. Unsupported crystal in use?&quot;
986                  % (est_xtal, norm_xtal)
987              )
988          return norm_xtal
989      def hard_reset(self):
990          print(&quot;Hard resetting via RTS pin...&quot;)
991          HardReset(self._port)()
992      def soft_reset(self, stay_in_bootloader):
993          if not self.IS_STUB:
994              if stay_in_bootloader:
995                  return  # ROM bootloader is already in bootloader!
996              else:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(False)
999          else:
1000              if stay_in_bootloader:
1001                  self.flash_begin(0, 0)
1002                  self.flash_finish(True)
1003              elif self.CHIP_NAME != &quot;ESP8266&quot;:
1004                  raise FatalError(
1005                      &quot;Soft resetting is currently only supported on ESP8266&quot;
1006                  )
1007              else:
1008                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1009      def check_chip_id(self):
1010          try:
1011              chip_id = self.get_chip_id()
1012              if chip_id != self.IMAGE_CHIP_ID:
1013                  print(
1014                      &quot;WARNING: Chip ID {} ({}) doesn&#x27;t match expected Chip ID {}. &quot;
1015                      &quot;esptool may not work correctly.&quot;.format(
1016                          chip_id,
1017                          self.UNSUPPORTED_CHIPS.get(chip_id, &quot;Unknown&quot;),
1018                          self.IMAGE_CHIP_ID,
1019                      )
1020                  )
1021                  self.stub_is_disabled = True
1022          except NotImplementedInROMError:
1023              pass
1024  def slip_reader(port, trace_function):
1025      def detect_panic_handler(input):
1026          guru_meditation = (
1027              rb&quot;G?uru Meditation Error: (?:Core \d panic&#x27;ed \(([a-zA-Z ]*)\))?&quot;
1028          )
1029          fatal_exception = rb&quot;F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?&quot;
1030          data = re.search(
1031              rb&quot;&quot;.join([rb&quot;(?:&quot;, guru_meditation, rb&quot;|&quot;, fatal_exception, rb&quot;)&quot;]),
1032              input,
1033              re.DOTALL,
1034          )
1035          if data is not None:
1036              cause = [
1037                  &quot;({})&quot;.format(i.decode(&quot;utf-8&quot;))
1038                  for i in [data.group(1), data.group(2)]
1039                  if i is not None
1040              ]
1041              cause = f&quot; {cause[0]}&quot; if len(cause) else &quot;&quot;
1042              msg = f&quot;Guru Meditation Error detected{cause}&quot;
1043              raise FatalError(msg)
1044      partial_packet = None
1045      in_escape = False
1046      successful_slip = False
1047      while True:
1048          waiting = port.inWaiting()
1049          read_bytes = port.read(1 if waiting == 0 else waiting)
1050          if read_bytes == b&quot;&quot;:
1051              if partial_packet is None:  # fail due to no data
1052                  msg = (
1053                      &quot;Serial data stream stopped: Possible serial noise or corruption.&quot;
1054                      if successful_slip
1055                      else &quot;No serial data received.&quot;
1056                  )
1057              else:  # fail during packet transfer
1058                  msg = &quot;Packet content transfer stopped (received {} bytes)&quot;.format(
1059                      len(partial_packet)
1060                  )
1061              trace_function(msg)
1062              raise FatalError(msg)
1063          trace_function(&quot;Read %d bytes: %s&quot;, len(read_bytes), HexFormatter(read_bytes))
1064          for b in read_bytes:
1065              b = bytes([b])
1066              if partial_packet is None:  # waiting for packet header
1067                  if b == b&quot;\xc0&quot;:
1068                      partial_packet = b&quot;&quot;
1069                  else:
1070                      trace_function(&quot;Read invalid data: %s&quot;, HexFormatter(read_bytes))
1071                      remaining_data = port.read(port.inWaiting())
1072                      trace_function(
1073                          &quot;Remaining data in serial buffer: %s&quot;,
1074                          HexFormatter(remaining_data),
1075                      )
1076                      detect_panic_handler(read_bytes + remaining_data)
1077                      raise FatalError(
1078                          &quot;Invalid head of packet (0x%s): &quot;
1079                          &quot;Possible serial noise or corruption.&quot; % hexify(b)
1080                      )
1081              elif in_escape:  # part-way through escape sequence
1082                  in_escape = False
1083                  if b == b&quot;\xdc&quot;:
1084                      partial_packet += b&quot;\xc0&quot;
1085                  elif b == b&quot;\xdd&quot;:
1086                      partial_packet += b&quot;\xdb&quot;
1087                  else:
1088                      trace_function(&quot;Read invalid data: %s&quot;, HexFormatter(read_bytes))
1089                      remaining_data = port.read(port.inWaiting())
1090                      trace_function(
1091                          &quot;Remaining data in serial buffer: %s&quot;,
1092                          HexFormatter(remaining_data),
1093                      )
1094                      detect_panic_handler(read_bytes + remaining_data)
1095                      raise FatalError(&quot;Invalid SLIP escape (0xdb, 0x%s)&quot; % (hexify(b)))
1096              elif b == b&quot;\xdb&quot;:  # start of escape sequence
1097                  in_escape = True
1098              elif b == b&quot;\xc0&quot;:  # end of packet
1099                  trace_function(&quot;Received full packet: %s&quot;, HexFormatter(partial_packet))
1100                  yield partial_packet
1101                  partial_packet = None
1102                  successful_slip = True
1103              else:  # normal byte in packet
1104                  partial_packet += b
1105  class HexFormatter(object):
1106      def __init__(self, binary_string, auto_split=True):
1107          self._s = binary_string
1108          self._auto_split = auto_split
1109      def __str__(self):
1110          if self._auto_split and len(self._s) &gt; 16:
1111              result = &quot;&quot;
1112              s = self._s
1113              while len(s) &gt; 0:
1114                  line = s[:16]
1115                  ascii_line = &quot;&quot;.join(
1116                      c
1117                      if (
1118                          c == &quot; &quot;
1119                          or (c in string.printable and c not in string.whitespace)
1120                      )
1121                      else &quot;.&quot;
1122                      for c in line.decode(&quot;ascii&quot;, &quot;replace&quot;)
1123                  )
1124                  s = s[16:]
1125                  result += &quot;\n    %-16s %-16s | %s&quot; % (
1126                      hexify(line[:8], False),
1127                      hexify(line[8:], False),
1128                      ascii_line,
1129                  )
1130              return result
1131          else:
1132              return hexify(self._s, False)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                </div>
                <div class="column column_space"><pre><code>8  from .loader import ESPLoader
9  from .targets import (
10      ESP32C2ROM,
11      ESP32C3ROM,
12      ESP32C6BETAROM,
13      ESP32C6ROM,
14      ESP32H2BETA1ROM,
15      ESP32H2BETA2ROM,
16      ESP32H2ROM,
</pre></code></div>
                <div class="column column_space"><pre><code>11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    