<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for saltmod.py &amp; boto_iam.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for saltmod.py &amp; boto_iam.py
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>saltmod.py (6.0851927%)<th>boto_iam.py (2.144389%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-117)<td><a href="#" name="0">(1484-1557)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(445-519)<td><a href="#" name="1">(1045-1108)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(25-42)<td><a href="#" name="2">(133-149)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(376-382)<td><a href="#" name="3">(1560-1565)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
3 import sys
4 import threading
5 import time
6 import salt.exceptions
7 import salt.output
8 import salt.syspaths
9 import salt.utils.data
10 import salt.utils.event
11 log = logging.getLogger(__name__)
12 __virtualname__ = "salt"
13 def</b></font> __virtual__():
14     """
15     Named salt
16     """
17     return __virtualname__
18 def _fire_args(tag_data):
19     try:
20         salt.utils.event.fire_args(__opts__, __orchestration_jid__, tag_data, "run")
21     except NameError:
22         log.debug("Unable to fire args event due to missing __orchestration_jid__")
23 def _parallel_map(func, inputs):
24     """
25     Applies a function to each element of a list, returning the resulting list.
26     A separate thread is created for each element in the input list and the
27     passed function is called for each of the elements. When all threads have
28     finished execution a list with the results corresponding to the inputs is
29     returned.
30     If one of the threads fails (because the function throws an exception),
31     that exception is reraised. If more than one thread fails, the exception
32     from the first thread (according to the index of the input element) is
33     reraised.
34     func:
35         function that is applied on each input element.
36     inputs:
37         list of elements that shall be processed. The length of this list also
38         defines the number of threads created.
39     """
40     outputs = len(inputs) * [None]
41     errors = len(inputs) * [None]
42     def create_thread(index):
43         def run_thread():
44             try:
45                 outputs[index] = func(inputs[index])
46             except:  # pylint: disable=bare-except
47                 errors[index] = sys.exc_info()
48         thread = threading.Thread(target=run_thread)
49         thread.start()
50         return thread
51     threads = list(map(create_thread, range(len(inputs))))
52     for thread in threads:
53         thread.join()
54     for error in errors:
55             exc_type, exc_value, exc_traceback = error
56             raise exc_value.with_traceback(exc_traceback)
57     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return outputs
58 def state(
59     name,
60     tgt,
61     ssh=False,
62     tgt_type="glob",
63     ret="",
64     ret_config=None,
65     ret_kwargs=None,
66     highstate=None,
67     sls=None,
68     top=None,
69     saltenv=None,
70     test=None,
71     pillar=None,
72     pillarenv=None,
73     expect_minions=True,
74     exclude=None,
75     fail_minions=</b></font>None,
76     allow_fail=0,
77     concurrent=False,
78     timeout=None,
79     batch=None,
80     queue=False,
81     subset=None,
82     orchestration_jid=None,
83     failhard=None,
84     **kwargs
85 ):
86     """
87     Invoke a state run on a given target
88     name
89         An arbitrary name used to track the state execution
90     tgt
91         The target specification for the state run.
92         .. versionadded:: 2016.11.0
93         Masterless support: When running on a masterless minion, the ``tgt``
94         is ignored and will always be the local minion.
95     tgt_type
96         The target type to resolve, defaults to ``glob``
97     ret
98         Optionally set a single or a list of returners to use
99     ret_config
100         Use an alternative returner configuration
101     ret_kwargs
102         Override individual returner configuration items
103     highstate
104         Defaults to None, if set to True the target systems will ignore any
105         sls references specified in the sls option and call state.highstate
106         on the targeted minions
107     top
108         Should be the name of a top file. If set state.top is called with this
109         top file instead of state.sls.
110     sls
111         A group of sls files to execute. This can be defined as a single string
112         containing a single sls file, or a list of sls files
113     test
114         Pass ``test=true`` or ``test=false`` through to the state function. This
115         can be used to override a test mode set in the minion's config file. If
116         left as the default of None and the 'test' mode is supplied on the
117         command line, that value is passed instead.
118     pillar
119         Pass the ``pillar`` kwarg through to the state function
120     pillarenv
121         The pillar environment to grab pillars from
122         .. versionadded:: 2017.7.0
123     saltenv
124         The default salt environment to pull sls files from
125     ssh
126         Set to `True` to use the ssh client instead of the standard salt client
127     roster
128         In the event of using salt-ssh, a roster system can be set
129     expect_minions
130         An optional boolean for failing if some minions do not respond
131     fail_minions
132         An optional list of targeted minions where failure is an option
133     allow_fail
134         Pass in the number of minions to allow for failure before setting
135         the result of the execution to False
136     exclude
137         Pass exclude kwarg to state
138     concurrent
139         Allow multiple state runs to occur at once.
140         WARNING: This flag is potentially dangerous. It is designed
141         for use when multiple state runs can safely be run at the same
142         Do not use this flag for performance optimization.
143     queue
144         Pass ``queue=true`` through to the state function
145     batch
146         Execute the command :ref:`in batches &lt;targeting-batch&gt;`. E.g.: ``10%``.
147         .. versionadded:: 2016.3.0
148     subset
149         Number of minions from the targeted set to randomly use
150         .. versionadded:: 2017.7.0
151     failhard
152         pass failhard down to the executing state
153         .. versionadded:: 2019.2.2
154     Examples:
155     Run a list of sls files via :py:func:`state.sls &lt;salt.state.sls&gt;` on target
156     minions:
157     .. code-block:: yaml
158         webservers:
159           salt.state:
160             - tgt: 'web*'
161             - sls:
162               - apache
163               - django
164               - core
165             - saltenv: prod
166     Run sls file via :py:func:`state.sls &lt;salt.state.sls&gt;` on target
167     minions with exclude:
168     .. code-block:: yaml
169         docker:
170           salt.state:
171             - tgt: 'docker*'
172             - sls: docker
173             - exclude: docker.swarm
174             - saltenv: prod
175     Run a full :py:func:`state.highstate &lt;salt.state.highstate&gt;` on target
176     mininons.
177     .. code-block:: yaml
178         databases:
179           salt.state:
180             - tgt: role:database
181             - tgt_type: grain
182             - highstate: True
183     """
184     cmd_kw = {"arg": [], "kwarg": {}, "ret": ret, "timeout": timeout}
185     if ret_config:
186         cmd_kw["ret_config"] = ret_config
187     if ret_kwargs:
188         cmd_kw["ret_kwargs"] = ret_kwargs
189     state_ret = {"name": name, "changes": {}, "comment": "", "result": True}
190     try:
191         allow_fail = int(allow_fail)
192     except ValueError:
193         state_ret["result"] = False
194         state_ret["comment"] = "Passed invalid value for 'allow_fail', must be an int"
195         return state_ret
196     cmd_kw["tgt_type"] = tgt_type
197     cmd_kw["ssh"] = ssh
198     if "roster" in kwargs:
199         cmd_kw["roster"] = kwargs["roster"]
200     cmd_kw["expect_minions"] = expect_minions
201     if highstate:
202         fun = "state.highstate"
203     elif top:
204         fun = "state.top"
205         cmd_kw["arg"].append(top)
206     elif sls:
207         fun = "state.sls"
208         if isinstance(sls, list):
209             sls = ",".join(sls)
210         cmd_kw["arg"].append(sls)
211     else:
212         state_ret["comment"] = "No highstate or sls specified, no execution made"
213         state_ret["result"] = False
214         return state_ret
215     if test is not None or __opts__.get("test"):
216         cmd_kw["kwarg"]["test"] = test if test is not None else __opts__.get("test")
217     if pillar:
218         cmd_kw["kwarg"]["pillar"] = pillar
219     if pillarenv is not None:
220         cmd_kw["kwarg"]["pillarenv"] = pillarenv
221     if saltenv is not None:
222         cmd_kw["kwarg"]["saltenv"] = saltenv
223     if exclude is not None:
224         cmd_kw["kwarg"]["exclude"] = exclude
225     cmd_kw["kwarg"]["queue"] = queue
226     if isinstance(concurrent, bool):
227         cmd_kw["kwarg"]["concurrent"] = concurrent
228     else:
229         state_ret["comment"] = "Must pass in boolean for value of 'concurrent'"
230         state_ret["result"] = False
231         return state_ret
232     if batch is not None:
233         cmd_kw["batch"] = str(batch)
234     if subset is not None:
235         cmd_kw["subset"] = subset
236     if failhard is True or __opts__.get("failhard"):
237         cmd_kw["failhard"] = True
238     masterless = __opts__["__role"] == "minion" and __opts__["file_client"] == "local"
239     if not masterless:
240         _fire_args({"type": "state", "tgt": tgt, "name": name, "args": cmd_kw})
241         cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
242     else:
243         if top:
244             cmd_kw["topfn"] = "".join(cmd_kw.pop("arg"))
245         elif sls:
246             cmd_kw["mods"] = "".join(cmd_kw.pop("arg"))
247         cmd_kw.update(cmd_kw.pop("kwarg"))
248         tmp_ret = __salt__[fun](**cmd_kw)
249         cmd_ret = {
250             __opts__["id"]: {
251                 "ret": tmp_ret,
252                 "out": tmp_ret.get("out", "highstate")
253                 if isinstance(tmp_ret, dict)
254                 else "highstate",
255             }
256         }
257     try:
258         state_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
259     except (StopIteration, KeyError):
260         pass
261     changes = {}
262     fail = set()
263     no_change = set()
264     if fail_minions is None:
265         fail_minions = ()
266     elif isinstance(fail_minions, str):
267         fail_minions = [minion.strip() for minion in fail_minions.split(",")]
268     elif not isinstance(fail_minions, list):
269         state_ret.setdefault("warnings", []).append(
270             "'fail_minions' needs to be a list or a comma separated string. Ignored."
271         fail_minions = ()
272     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not cmd_ret and expect_minions:
273         state_ret["result"] = False
274         state_ret["comment"] = "No minions returned"
275         return state_ret
276     for minion, mdata in cmd_ret.items():
277         if mdata.</b></font>get("out", "") != "highstate":
278             log.warning("Output from salt state not highstate")
279         m_ret = False
280         if "return" in mdata and "ret" not in mdata:
281             mdata["ret"] = mdata.pop("return")
282         m_state = True
283         if mdata.get("failed", False):
284             m_state = False
285         else:
286             try:
287                 m_ret = mdata["ret"]
288             except KeyError:
289                 m_state = False
290             if m_state:
291                 m_state = __utils__["state.check_result"](m_ret, recurse=True)
292         if not m_state:
293             if minion not in fail_minions:
294                 fail.add(minion)
295             changes[minion] = m_ret
296             continue
297         try:
298             for state_item in m_ret.values():
299                 if isinstance(state_item, dict):
300                     if "changes" in state_item and state_item["changes"]:
301                         changes[minion] = m_ret
302                         break
303             else:
304                 no_change.add(minion)
305         except AttributeError:
306             log.error("m_ret did not have changes %s %s", type(m_ret), m_ret)
307             no_change.add(minion)
308     if changes:
309         state_ret["changes"] = {"out": "highstate", "ret": changes}
310     if len(fail) &gt; allow_fail:
311         state_ret["result"] = False
312         state_ret["comment"] = "Run failed on minions: {}".format(", ".join(fail))
313     else:
314         state_ret["comment"] = "States ran successfully."
315         if changes:
316             state_ret["comment"] += " Updating {}.".format(", ".join(changes))
317         if no_change:
318             state_ret["comment"] += " No changes made to {}.".format(
319                 ", ".join(no_change)
320             )
321     if test or __opts__.get("test"):
322         if state_ret["changes"] and state_ret["result"] is True:
323             state_ret["result"] = None
324     return state_ret
325 def function(
326     name,
327     tgt,
328     ssh=False,
329     ret="",
330     ret_config=None,
331     ret_kwargs<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
332     expect_minions=False,
333     fail_minions=None,
334     fail_function=None,
335     arg=None,
336     kwarg=None,
337     timeout=None,
338     batch=None,
339     subset=None,
340     failhard=None,
341     **kwargs
342 ):  # pylint: disable=unused-argument
343     """
344     Execute a single module function on a remote minion via salt or salt-ssh
345     name
346         The name of the function to run, aka cmd.run or pkg.install
347     tgt
348         The target specification, aka '*' for all minions
349     tgt_type
350         The target type, defaults to ``glob``
351     arg
352         The list of arguments to pass into the function
353     kwarg
354         The dict (not a list) of keyword arguments to pass into the function
355     ret
356         Optionally set a single or a list of returners to use
357     ret_config
358         Use an alternative returner configuration
359     ret_kwargs
360         Override individual returner configuration items
361     expect_minions
362         An optional boolean for failing if some minions do not respond
363     fail_minions
364         An optional list of targeted minions where failure is an option
365     fail_function
366         An optional string that points to a salt module that returns True or False
367         based on the returned data dict for individual minions
368     ssh
369         Set to `True` to use the ssh client instead of the standard salt client
370     roster
371         In the event of using salt-ssh, a roster system can be set
372         .. versionadded:: 3005
373     batch
374         Execute the command :ref:`in batches &lt;targeting-batch&gt;`. E.g.: ``10%``.
375     subset
376         Number of minions from the targeted set to randomly use
377         .. versionadded:: 2017.7.0
378     failhard
379         pass failhard down to the executing state
380         .. versionadded:: 2019.2.2
381     """
382     func_ret = {"name": name, "changes": {}, "comment": "", "result": True}
383     if kwarg is None:
384         kwarg = {}
385     if</b></font> isinstance(arg, str):
386         func_ret["warnings"] = ["Please specify 'arg' as a list of arguments."]
387         arg = arg.split()
388     cmd_kw = {"arg": arg or [], "kwarg": kwarg, "ret": ret, "timeout": timeout}
389     if batch is not None:
390         cmd_kw["batch"] = str(batch)
391     if subset is not None:
392         cmd_kw["subset"] = subset
393     cmd_kw["tgt_type"] = tgt_type
394     cmd_kw["ssh"] = ssh
395     if "roster" in kwargs:
396         cmd_kw["roster"] = kwargs["roster"]
397     cmd_kw["expect_minions"] = expect_minions
398     cmd_kw["_cmd_meta"] = True
399     if failhard is True or __opts__.get("failhard"):
400         cmd_kw["failhard"] = True
401     if ret_config:
402         cmd_kw["ret_config"] = ret_config
403     if ret_kwargs:
404         cmd_kw["ret_kwargs"] = ret_kwargs
405     fun = name
406     if __opts__["test"] is True:
407         func_ret["comment"] = "Function {} would be executed on target {}".format(
408             fun, tgt
409         )
410         func_ret["result"] = None
411         return func_ret
412     try:
413         _fire_args({"type": "function", "tgt": tgt, "name": name, "args": cmd_kw})
414         cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
415     except Exception as exc:  # pylint: disable=broad-except
416         func_ret["result"] = False
417         func_ret["comment"] = str(exc)
418         return func_ret
419     try:
420         func_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
421     except (StopIteration, KeyError):
422         pass
423     changes = {}
424     fail = set()
425     if fail_minions is None:
426         fail_minions = ()
427     elif isinstance(fail_minions, str):
428         fail_minions = [minion.strip() for minion in fail_minions.split(",")]
429     elif not isinstance(fail_minions, list):
430         func_ret.setdefault("warnings", []).append(
431             "'fail_minions' needs to be a list or a comma separated string. Ignored."
432         )
433         fail_minions = ()
434     for minion, mdata in cmd_ret.items():
435         m_ret = False
436         if mdata.get("retcode"):
437             func_ret["result"] = False
438             fail.add(minion)
439         if mdata.get("failed", False):
440             m_func = False
441         else:
442             if "return" in mdata and "ret" not in mdata:
443                 mdata["ret"] = mdata.pop("return")
444             m_ret = mdata["ret"]
445             m_func = (not fail_function and True) or __salt__[fail_function](m_ret)
446             if m_ret is False:
447                 m_func = False
448         if not m_func:
449             if minion not in fail_minions:
450                 fail.add(minion)
451         changes[minion] = m_ret
452     if not cmd_ret:
453         func_ret["result"] = False
454         func_ret["comment"] = "No minions responded"
455     else:
456         if changes:
457             func_ret["changes"] = {"ret": changes}
458         if fail:
459             func_ret["result"] = False
460             func_ret["comment"] = "Running function {} failed on minions: {}".format(
461                 name, ", ".join(fail)
462             )
463         else:
464             func_ret["comment"] = "Function ran successfully."
465         if changes:
466             func_ret["comment"] += " Function {} ran on {}.".format(
467                 name, ", ".join(changes)
468             )
469     return func_ret
470 def wait_for_event(name, id_list, event_id="id", timeout=300, node="master"):
471     """
472     Watch Salt's event bus and block until a condition is met
473     .. versionadded:: 2014.7.0
474     name
475         An event tag to watch for; supports Reactor-style globbing.
476     id_list
477         A list of event identifiers to watch for -- usually the minion ID. Each
478         time an event tag is matched the event data is inspected for
479         ``event_id``, if found it is removed from ``id_list``. When ``id_list``
480         is empty this function returns success.
481     event_id : id
482         The name of a key in the event data. Default is ``id`` for the minion
483         ID, another common value is ``name`` for use with orchestrating
484         salt-cloud events.
485     timeout : 300
486         The maximum time in seconds to wait before failing.
487     The following example blocks until all the listed minions complete a
488     restart and reconnect to the Salt master:
489     .. code-block:: yaml
490         reboot_all_minions:
491           salt.function:
492             - name: system.reboot
493             - tgt: '*'
494         wait_for_reboots:
495           salt.wait_for_event:
496             - name: salt/minion/*/start
497             - id_list:
498               - jerry
499               - stuart
500               - dave
501               - phil
502               - kevin
503               - mike
504             - require:
505               - salt: reboot_all_minions
506     """
507     ret = {"name": name, "changes": {}, "comment": "", "result": False}
508     if __opts__.get("test"):
509         ret["comment"] = "Orchestration would wait for event '{}'".format(name)
510         ret["result"] = None
511         return ret
512     with salt.utils.event.get_event(
513         node, __opts__["sock_dir"], opts=__opts__, listen=True
514     ) as sevent:
515         del_counter = 0
516         starttime = time.time()
517         timelimit = starttime + timeout
518         while True:
519             event = sevent.get_event(full=True)
520             is_timedout = time.time() &gt; timelimit
521             if event is None and not is_timedout:
522                 log.trace("wait_for_event: No event data; waiting.")
523                 continue
524             elif event is None and is_timedout:
525                 ret["comment"] = "Timeout value reached."
526                 return ret
527             if fnmatch.fnmatch(event["tag"], name):
528                 val = event["data"].get(event_id)
529                 if val is None and "data" in event["data"]:
530                     val = event["data"]["data"].get(event_id)
531                 if val is not None:
532                     try:
533                         val_idx = id_list.index(val)
534                     except ValueError:
535                         log.trace(
536                             "wait_for_event: Event identifier '%s' not in "
537                             "id_list; skipping.",
538                             event_id,
539                         )
540                     else:
541                         del id_list[val_idx]
542                         del_counter += 1
543                         minions_seen = ret["changes"].setdefault("minions_seen", [])
544                         minions_seen.append(val)
545                         log.debug(
546                             "wait_for_event: Event identifier '%s' removed "
547                             "from id_list; %s items remaining.",
548                             val,
549                             len(id_list),
550                         )
551                 else:
552                     log.trace(
553                         "wait_for_event: Event identifier '%s' not in event "
554                         "'%s'; skipping.",
555                         event_id,
556                         event["tag"],
557                     )
558             else:
559                 log.debug("wait_for_event: Skipping unmatched event '%s'", event["tag"])
560             if len(id_list) == 0:
561                 ret["result"] = True
562                 ret["comment"] = "All events seen in {} seconds.".format(
563                     time.time() - starttime
564                 )
565                 return ret
566             if is_timedout:
567                 ret["comment"] = "Timeout value reached."
568                 return ret
569 def runner(name, **kwargs):
570     """
571     Execute a runner module on the master
572     .. versionadded:: 2014.7.0
573     name
574         The name of the function to run
575     kwargs
576         Any keyword arguments to pass to the runner function
577     .. code-block:: yaml
578          run-manage-up:
579           salt.runner:
580             - name: manage.up
581     """
582     try:
583         jid = __orchestration_jid__
584     except NameError:
585         log.debug("Unable to fire args event due to missing __orchestration_jid__")
586         jid = None
587     if __opts__.get("test", False):
588         ret = {
589             "name": name,
590             "result": None,
591             "changes": {},
592             "comment": "Runner function '{}' would be executed.".format(name),
593         }
594         return ret
595     out = __salt__["saltutil.runner"](
596         name, __orchestration_jid__=jid, __env__=__env__, full_return=True, **kwargs
597     )
598     runner_return = out.get("return")
599     if isinstance(runner_return, dict) and "Error" in runner_return:
600         out["success"] = False
601     success = out.get("success", True)
602     ret = {"name": name, "changes": {"return": runner_return}, "result": success}
603     ret["comment"] = "Runner function '{}' {}.".format(
604         name,
605         "executed" if success else "failed",
606     )
607     ret["__orchestration__"] = True
608     if "jid" in out:
609         ret["__jid__"] = out["jid"]
610     return ret
611 def parallel_runners(name, runners, **kwargs):  # pylint: disable=unused-argument
612     """
613     Executes multiple runner modules on the master in parallel.
614     .. versionadded:: 2018.3.0
615     A separate thread is spawned for each runner. This state is intended to be
616     used with the orchestrate runner in place of the ``saltmod.runner`` state
617     when different tasks should be run in parallel. In general, Salt states are
618     not safe when used concurrently, so ensure that they are used in a safe way
619     (e.g. by only targeting separate minions in parallel tasks).
620     name:
621         name identifying this state. The name is provided as part of the
622         output, but not used for anything else.
623     runners:
624         list of runners that should be run in parallel. Each element of the
625         list has to be a dictionary. This dictionary's name entry stores the
626         name of the runner function that shall be invoked. The optional kwarg
627         entry stores a dictionary of named arguments that are passed to the
628         runner function.
629     .. code-block:: yaml
630         parallel-state:
631            salt.parallel_runners:
632              - runners:
633                  my_runner_1:
634                    - name: state.orchestrate
635                    - kwarg:
636                        mods: orchestrate_state_1
637                  my_runner_2:
638                    - name: state.orchestrate
639                    - kwarg:
640                        mods: orchestrate_state_2
641     """
642     if isinstance(runners, str):
643         runners = {runners: [{name: runners}]}
644     if not isinstance(runners, dict):
645         return {
646             "name": name,
647             "result": False,
648             "changes": {},
649             "comment": "The runners parameter must be a string or dict.",
650         }
651     for runner_id, runner_config in runners.items():
652         if runner_config is None:
653             runner_config = {}
654         else:
655             runner_config = salt.utils.data.repack_dictlist(runner_config)
656         if "name" not in runner_config:
657             runner_config["name"] = runner_id
658         runners[runner_id] = runner_config
659     try:
660         jid = __orchestration_jid__
661     except NameError:
662         log.debug("Unable to fire args event due to missing __orchestration_jid__")
663         jid = None
664     def call_runner(runner_config):
665         return __salt__["saltutil.runner"](
666             runner_config["name"],
667             __orchestration_jid__=jid,
668             __env__=__env__,
669             full_return=True,
670             **(runner_config.get("kwarg", {}))
671         )
672     try:
673         outputs = _parallel_map(call_runner, list(runners.values()))
674     except salt.exceptions.SaltException as exc:
675         return {
676             "name": name,
677             "result": False,
678             "success": False,
679             "changes": {},
680             "comment": "One of the runners raised an exception: {}".format(exc),
681         }
682     outputs = {
683         runner_id: out["return"] for runner_id, out in zip(runners.keys(), outputs)
684     }
685     highstate_output = all(
686         [
687             out.get("outputter", "") == "highstate" and "data" in out
688             for out in outputs.values()
689         ]
690     )
691     def extract_changes(obj):
692         if not isinstance(obj, dict):
693             return {}
694         elif "changes" in obj:
695             if (
696                 isinstance(obj["changes"], dict)
697                 and obj["changes"].get("out", "") == "highstate"
698                 and "ret" in obj["changes"]
699             ):
700                 return obj["changes"]["ret"]
701             else:
702                 return obj["changes"]
703         else:
704             found_changes = {}
705             for key, value in obj.items():
706                 change = extract_changes(value)
707                 if change:
708                     found_changes[key] = change
709             return found_changes
710     if highstate_output:
711         failed_runners = [
712             runner_id
713             for runner_id, out in outputs.items()
714             if out["data"].get("retcode", 0) != 0
715         ]
716         all_successful = not failed_runners
717         if all_successful:
718             comment = "All runner functions executed successfully."
719         else:
720             runner_comments = [
721                 "Runner {} failed with return value:\n{}".format(
722                     runner_id,
723                     salt.output.out_format(
724                         outputs[runner_id], "nested", __opts__, nested_indent=2
725                     ),
726                 )
727                 for runner_id in failed_runners
728             ]
729             comment = "\n".join(runner_comments)
730         changes = {}
731         for runner_id, out in outputs.items():
732             runner_changes = extract_changes(out["data"])
733             if runner_changes:
734                 changes[runner_id] = runner_changes
735     else:
736         failed_runners = [
737             runner_id
738             for runner_id, out in outputs.items()
739             if out.get("exit_code", 0) != 0
740         ]
741         all_successful = not failed_runners
742         if all_successful:
743             comment = "All runner functions executed successfully."
744         else:
745             if len(failed_runners) == 1:
746                 comment = "Runner {} failed.".format(failed_runners[0])
747             else:
748                 comment = "Runners {} failed.".format(", ".join(failed_runners))
749         changes = {"ret": {runner_id: out for runner_id, out in outputs.items()}}
750     ret = {
751         "name": name,
752         "result": all_successful,
753         "changes": changes,
754         "comment": comment,
755     }
756     return ret
757 def wheel(name, **kwargs):
758     """
759     Execute a wheel module on the master
760     .. versionadded:: 2014.7.0
761     name
762         The name of the function to run
763     kwargs
764         Any keyword arguments to pass to the wheel function
765     .. code-block:: yaml
766         accept_minion_key:
767           salt.wheel:
768             - name: key.accept
769             - match: frank
770     """
771     ret = {"name": name, "result": False, "changes": {}, "comment": ""}
772     try:
773         jid = __orchestration_jid__
774     except NameError:
775         log.debug("Unable to fire args event due to missing __orchestration_jid__")
776         jid = None
777     if __opts__.get("test", False):
778         ret["result"] = (None,)
779         ret["changes"] = {}
780         ret["comment"] = "Wheel function '{}' would be executed.".format(name)
781         return ret
782     out = __salt__["saltutil.wheel"](
783         name, __orchestration_jid__=jid, __env__=__env__, **kwargs
784     )
785     wheel_return = out.get("return")
786     if isinstance(wheel_return, dict) and "Error" in wheel_return:
787         out["success"] = False
788     success = out.get("success", True)
789     ret = {"name": name, "changes": {"return": wheel_return}, "result": success}
790     ret["comment"] = "Wheel function '{}' {}.".format(
791         name,
792         "executed" if success else "failed",
793     )
794     ret["__orchestration__"] = True
795     if "jid" in out:
796         ret["__jid__"] = out["jid"]
797     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage IAM objects
3 ==================
4 .. versionadded:: 2015.8.0
5 This module uses ``boto``, which can be installed via package, or pip.
6 This module accepts explicit IAM credentials but can also utilize
7 IAM roles assigned to the instance through Instance Profiles. Dynamic
8 credentials are then automatically obtained from AWS API and no further
9 configuration is necessary. More information available `here
10 &lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.
11 It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
12 passed in as a dict, or as a string to pull from pillars or minion config:
13 .. code-block:: yaml
14     delete-user:
15       boto_iam.user_absent:
16         - name: myuser
17         - delete_keys: true
18 .. code-block:: yaml
19     delete-keys:
20       boto_iam.keys_absent:
21         - access_keys:
22           - 'AKIAJHTMIQ2ASDFLASDF'
23           - 'PQIAJHTMIQ2ASRTLASFR'
24         - user_name: myuser
25 .. code-block:: yaml
26     create-user:
27       boto_iam.user_present:
28         - name: myuser
29         - policies:
30             mypolicy: |
31                 {
32                     "Version": "2012-10-17",
33                     "Statement": [{
34                     "Effect": "Allow",
35                     "Action": "*",
36                     "Resource": "*"}]
37                 }
38         - password: NewPassword$$1
39         - region: eu-west-1
40         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
41         - key: 'fdkjsafkljsASSADFalkfjasdf'
42 .. code-block:: yaml
43     create-group:
44       boto_iam.group_present:
45         - name: mygroup
46         - users:
47           - myuser
48           - myuser1
49         - policies:
50             mypolicy: |
51                 {
52                     "Version": "2012-10-17",
53                     "Statement": [{
54                     "Effect": "Allow",
55                     "Action": "*",
56                     "Resource": "*"}]
57                 }
58         - region: eu-west-1
59         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
60         - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
61 .. code-block:: yaml
62     change-policy:
63       boto_iam.account_policy:
64         - change_password: True
65         - region: eu-west-1
66         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
67         - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
68 .. code-block:: yaml
69     create server certificate:
70       boto_iam.server_cert_present:
71         - name: mycert
72         - public_key: salt://base/mycert.crt
73         - private_key: salt://base/mycert.key
74         - cert_chain: salt://base/mycert_chain.crt
75         - region: eu-west-1
76         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
77         - key: 'fdkjsafkljsASSADFalkfjasdf'
78 .. code-block:: yaml
79     delete server certificate:
80       boto_iam.server_cert_absent:
81         - name: mycert
82 .. code-block:: yaml
83     create keys for user:
84       boto_iam.keys_present:
85         - name: myusername
86         - number: 2
87         - save_dir: /root
88         - region: eu-west-1
89         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
90         - key: 'fdkjsafkljsASSADFalkfjasdf'
91 .. code-block:: yaml
92     create policy:
93       boto_iam.policy_present:
94         - name: myname
95         - policy_document: '{"MyPolicy": "Statement": [{"Action": ["sqs:*"], "Effect": "Allow", "Resource": ["arn:aws:sqs:*:*:*"], "Sid": "MyPolicySqs1"}]}'
96         - region: eu-west-1
97         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
98         - key: 'fdkjsafkljsASSADFalkfjasdf'
99 .. code-block:: yaml
100     add-saml-provider:
101       boto_iam.saml_provider_present:
102         - name: my_saml_provider
103         - saml_metadata_document: salt://base/files/provider.xml
104         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
105 """
106 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
107 import os
108 import xml.etree.ElementTree as ET
109 import salt.utils.data
110 import salt.utils.dictupdate as dictupdate
111 import salt.utils.files
112 import salt.utils.json
113 import salt.utils.odict as odict
114 import salt.utils.stringutils
115 log = logging.getLogger(__name__)
116 __virtualname__ = "boto_iam"
117 def</b></font> __virtual__():
118     """
119     Only load if elementtree xml library and boto are available.
120     """
121     if "boto_iam.get_user" in __salt__:
122         return True
123     else:
124         return (
125             False,
126             "Cannot load {} state: boto_iam module unavailable".format(__virtualname__),
127         )
128 def user_absent(
129     name,
130     delete_keys=True,
131     delete_mfa_devices=True,
132     delete_profile=True,
133     region=None,
134     key=None,
135     keyid=None,
136     profile=None,
137 ):
138     """
139     .. versionadded:: 2015.8.0
140     Ensure the IAM user is absent. User cannot be deleted if it has keys.
141     name (string)
142         The name of the new user.
143     delete_keys (bool)
144         Delete all keys from user.
145     delete_mfa_devices (bool)
146         Delete all mfa devices from user.
147         .. versionadded:: 2016.3.0
148     delete_profile (bool)
149         Delete profile from user.
150         .. versionadded:: 2016.3.0
151     region (string)
152         Region to connect to.
153     key (string)
154         Secret key to be used.
155     keyid (string)
156         Access key to be used.
157     profile (dict)
158         A dict with region, key and keyid, or a pillar key (string)
159         that contains a dict with region, key and keyid.
160     """
161     ret = {"name": name, "result": True, "comment": "", "changes": {}}
162     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
163         ret["result"] = True
164         ret["comment"] = "IAM User {} does not exist.".format(name)
165         return ret
166     if delete_keys:
167         keys = __salt__["boto_iam.get_all_access_keys"](
168             user_name=name, region=region, key=key, keyid=keyid, profile=profile
169         )
170         log.debug("Keys for user %s are %s.", name, keys)
171         if isinstance(keys, dict):
172             keys = keys["list_access_keys_response"]["list_access_keys_result"][
173                 "access_key_metadata"
174             ]
175             for k in keys:
176                 if __opts__["test"]:
177                     ret["comment"] = " ".join(
178                         [
179                             ret["comment"],
180                             "Key {} is set to be deleted.".format(k["access_key_id"]),
181                         ]
182                     )
183                     ret["result"] = None
184                 else:
185                     if _delete_key(
186                         ret, k["access_key_id"], name, region, key, keyid, profile
187                     ):
188                         ret["comment"] = " ".join(
189                             [
190                                 ret["comment"],
191                                 "Key {} has been deleted.".format(k["access_key_id"]),
192                             ]
193                         )
194                         ret["changes"][k["access_key_id"]] = "deleted"
195     if delete_mfa_devices:
196         devices = __salt__["boto_iam.get_all_mfa_devices"](
197             user_name=name, region=region, key=key, keyid=keyid, profile=profile
198         )
199         if devices:
200             for d in devices:
201                 serial = d["serial_number"]
202                 if __opts__["test"]:
203                     ret["comment"] = " ".join(
204                         [
205                             ret["comment"],
206                             "IAM user {} MFA device {} is set to be deactivated.".format(
207                                 name, serial
208                             ),
209                         ]
210                     )
211                     ret["result"] = None
212                 else:
213                     mfa_deactivated = __salt__["boto_iam.deactivate_mfa_device"](
214                         user_name=name,
215                         serial=serial,
216                         region=region,
217                         key=key,
218                         keyid=keyid,
219                         profile=profile,
220                     )
221                     if mfa_deactivated:
222                         ret["comment"] = " ".join(
223                             [
224                                 ret["comment"],
225                                 "IAM user {} MFA device {} is deactivated.".format(
226                                     name, serial
227                                 ),
228                             ]
229                         )
230                 if __opts__["test"]:
231                     ret["comment"] = " ".join(
232                         [
233                             ret["comment"],
234                             "Virtual MFA device {} is set to be deleted.".format(
235                                 serial
236                             ),
237                         ]
238                     )
239                     ret["result"] = None
240                 else:
241                     mfa_deleted = __salt__["boto_iam.delete_virtual_mfa_device"](
242                         serial=serial,
243                         region=region,
244                         key=key,
245                         keyid=keyid,
246                         profile=profile,
247                     )
248                     if mfa_deleted:
249                         ret["comment"] = " ".join(
250                             [
251                                 ret["comment"],
252                                 "Virtual MFA device {} is deleted.".format(serial),
253                             ]
254                         )
255     if delete_profile:
256         if __opts__["test"]:
257             ret["comment"] = " ".join(
258                 [
259                     ret["comment"],
260                     "IAM user {} login profile is set to be deleted.".format(name),
261                 ]
262             )
263             ret["result"] = None
264         else:
265             profile_deleted = __salt__["boto_iam.delete_login_profile"](
266                 name, region, key, keyid, profile
267             )
268             if profile_deleted:
269                 ret["comment"] = " ".join(
270                     [
271                         ret["comment"],
272                         "IAM user {} login profile is deleted.".format(name),
273                     ]
274                 )
275     if __opts__["test"]:
276         ret["comment"] = " ".join(
277             [
278                 ret["comment"],
279                 "IAM user {} managed policies are set to be detached.".format(name),
280             ]
281         )
282         ret["result"] = None
283     else:
284         _ret = _user_policies_detached(name, region, key, keyid, profile)
285         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
286         if not _ret["result"]:
287             ret["result"] = _ret["result"]
288             if ret["result"] is False:
289                 return ret
290     if __opts__["test"]:
291         ret["comment"] = " ".join(
292             [
293                 ret["comment"],
294                 "IAM user {} inline policies are set to be deleted.".format(name),
295             ]
296         )
297         ret["result"] = None
298     else:
299         _ret = _user_policies_deleted(name, region, key, keyid, profile)
300         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
301         if not _ret["result"]:
302             ret["result"] = _ret["result"]
303             if ret["result"] is False:
304                 return ret
305     if __opts__["test"]:
306         ret["comment"] = " ".join(
307             [ret["comment"], "IAM user {} is set to be deleted.".format(name)]
308         )
309         ret["result"] = None
310         return ret
311     deleted = __salt__["boto_iam.delete_user"](name, region, key, keyid, profile)
312     if deleted is True:
313         ret["comment"] = " ".join(
314             [ret["comment"], "IAM user {} is deleted.".format(name)]
315         )
316         ret["result"] = True
317         ret["changes"]["deleted"] = name
318         return ret
319     ret["comment"] = "IAM user {} could not be deleted.\n {}".format(name, deleted)
320     ret["result"] = False
321     return ret
322 def keys_present(
323     name,
324     number,
325     save_dir,
326     region=None,
327     key=None,
328     keyid=None,
329     profile=None,
330     save_format="{2}\n{0}\n{3}\n{1}\n",
331 ):
332     """
333     .. versionadded:: 2015.8.0
334     Ensure the IAM access keys are present.
335     name (string)
336         The name of the new user.
337     number (int)
338         Number of keys that user should have.
339     save_dir (string)
340         The directory that the key/keys will be saved. Keys are saved to a file named according
341         to the username privided.
342     region (string)
343         Region to connect to.
344     key (string)
345         Secret key to be used.
346     keyid (string)
347         Access key to be used.
348     profile (dict)
349         A dict with region, key and keyid, or a pillar key (string)
350         that contains a dict with region, key and keyid.
351     save_format (dict)
352         Save format is repeated for each key. Default format is
353         "{2}\\n{0}\\n{3}\\n{1}\\n", where {0} and {1} are placeholders for new
354         key_id and key respectively, whereas {2} and {3} are "key_id-{number}"
355         and 'key-{number}' strings kept for compatibility.
356     """
357     ret = {"name": name, "result": True, "comment": "", "changes": {}}
358     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
359         ret["result"] = False
360         ret["comment"] = "IAM User {} does not exist.".format(name)
361         return ret
362     if not isinstance(number, int):
363         ret["comment"] = "The number of keys must be an integer."
364         ret["result"] = False
365         return ret
366     if not os.path.isdir(save_dir):
367         ret["comment"] = "The directory {} does not exist.".format(save_dir)
368         ret["result"] = False
369         return ret
370     keys = __salt__["boto_iam.get_all_access_keys"](
371         user_name=name, region=region, key=key, keyid=keyid, profile=profile
372     )
373     if isinstance(keys, str):
374         log.debug("keys are : false %s", keys)
375         error, message = _get_error(keys)
376         ret["comment"] = "Could not get keys.\n{}\n{}".format(error, message)
377         ret["result"] = False
378         return ret
379     keys = keys["list_access_keys_response"]["list_access_keys_result"][
380         "access_key_metadata"
381     ]
382     log.debug("Keys are : %s.", keys)
383     if len(keys) &gt;= number:
384         ret["comment"] = "The number of keys exist for user {}".format(name)
385         ret["result"] = True
386         return ret
387     if __opts__["test"]:
388         ret["comment"] = "Access key is set to be created for {}.".format(name)
389         ret["result"] = None
390         return ret
391     new_keys = {}
392     for i in range(number - len(keys)):
393         created = __salt__["boto_iam.create_access_key"](
394             name, region, key, keyid, profile
395         )
396         if isinstance(created, str):
397             error, message = _get_error(created)
398             ret["comment"] = "Could not create keys.\n{}\n{}".format(error, message)
399             ret["result"] = False
400             return ret
401         log.debug("Created is : %s", created)
402         response = "create_access_key_response"
403         result = "create_access_key_result"
404         new_keys[str(i)] = {}
405         new_keys[str(i)]["key_id"] = created[response][result]["access_key"][
406             "access_key_id"
407         ]
408         new_keys[str(i)]["secret_key"] = created[response][result]["access_key"][
409             "secret_access_key"
410         ]
411     try:
412         with salt.utils.files.fopen("{}/{}".format(save_dir, name), "a") as _wrf:
413             for key_num, key in new_keys.items():
414                 key_id = key["key_id"]
415                 secret_key = key["secret_key"]
416                 _wrf.write(
417                     salt.utils.stringutils.to_str(
418                         save_format.format(
419                             key_id,
420                             secret_key,
421                             "key_id-{}".format(key_num),
422                             "key-{}".format(key_num),
423                         )
424                     )
425                 )
426         ret["comment"] = "Keys have been written to file {}/{}.".format(save_dir, name)
427         ret["result"] = True
428         ret["changes"] = new_keys
429         return ret
430     except OSError:
431         ret["comment"] = "Could not write to file {}/{}.".format(save_dir, name)
432         ret["result"] = False
433         return ret
434 def keys_absent(
435     access_keys, user_name, region=None, key=None, keyid=None, profile=None
436 ):
437     """
438     .. versionadded:: 2015.8.0
439     Ensure the IAM user access_key_id is absent.
440     access_key_id (list)
441         A list of access key ids
442     user_name (string)
443         The username of the user
444     region (string)
445         Region to connect to.
446     key (string)
447         Secret key to be used.
448     keyid (string)
449         Access key to be used.
450     profile (dict)
451         A dict with region, key and keyid, or a pillar key (string)
452         that contains a dict with region, key and keyid.
453     """
454     ret = {"name": access_keys, "result": True, "comment": "", "changes": {}}
455     if not __salt__["boto_iam.get_user"](user_name, region, key, keyid, profile):
456         ret["result"] = False
457         ret["comment"] = "IAM User {} does not exist.".format(user_name)
458         return ret
459     for k in access_keys:
460         ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
461     return ret
462 def _delete_key(
463     ret, access_key_id, user_name, region=None, key=None, keyid=None, profile=None
464 ):
465     keys = __salt__["boto_iam.get_all_access_keys"](
466         user_name=user_name, region=region, key=key, keyid=keyid, profile=profile
467     )
468     log.debug("Keys for user %s are : %s.", keys, user_name)
469     if isinstance(keys, str):
470         log.debug("Keys %s are a string. Something went wrong.", keys)
471         ret["comment"] = " ".join(
472             [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
473         )
474         return ret
475     keys = keys["list_access_keys_response"]["list_access_keys_result"][
476         "access_key_metadata"
477     ]
478     for k in keys:
479         log.debug(
480             "Key is: %s and is compared with: %s", k["access_key_id"], access_key_id
481         )
482         if str(k["access_key_id"]) == str(access_key_id):
483             if __opts__["test"]:
484                 ret["comment"] = "Access key {} is set to be deleted.".format(
485                     access_key_id
486                 )
487                 ret["result"] = None
488                 return ret
489             deleted = __salt__["boto_iam.delete_access_key"](
490                 access_key_id, user_name, region, key, keyid, profile
491             )
492             if deleted:
493                 ret["comment"] = " ".join(
494                     [ret["comment"], "Key {} has been deleted.".format(access_key_id)]
495                 )
496                 ret["changes"][access_key_id] = "deleted"
497                 return ret
498             ret["comment"] = " ".join(
499                 [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
500             )
501             return ret
502         ret["comment"] = " ".join([ret["comment"], "Key {} does not exist.".format(k)])
503         return ret
504 def user_present(
505     name,
506     policies=None,
507     policies_from_pillars=None,
508     managed_policies=None,
509     password=None,
510     path=None,
511     region=None,
512     key=None,
513     keyid=None,
514     profile=None,
515 ):
516     """
517     .. versionadded:: 2015.8.0
518     Ensure the IAM user is present
519     name (string)
520         The name of the new user.
521     policies (dict)
522         A dict of IAM group policy documents.
523     policies_from_pillars (list)
524         A list of pillars that contain role policy dicts. Policies in the
525         pillars will be merged in the order defined in the list and key
526         conflicts will be handled by later defined keys overriding earlier
527         defined keys. The policies defined here will be merged with the
528         policies defined in the policies argument. If keys conflict, the keys
529         in the policies argument will override the keys defined in
530         policies_from_pillars.
531     managed_policies (list)
532         A list of managed policy names or ARNs that should be attached to this
533         user.
534     password (string)
535         The password for the new user. Must comply with account policy.
536     path (string)
537         The path of the user. Default is '/'.
538         .. versionadded:: 2015.8.2
539     region (string)
540         Region to connect to.
541     key (string)
542         Secret key to be used.
543     keyid (string)
544         Access key to be used.
545     profile (dict)
546         A dict with region, key and keyid, or a pillar key (string)
547         that contains a dict with region, key and keyid.
548     """
549     ret = {"name": name, "result": True, "comment": "", "changes": {}}
550     if not policies:
551         policies = {}
552     if not policies_from_pillars:
553         policies_from_pillars = []
554     if not managed_policies:
555         managed_policies = []
556     _policies = {}
557     for policy in policies_from_pillars:
558         _policy = __salt__["pillar.get"](policy)
559         _policies.update(_policy)
560     _policies.update(policies)
561     exists = __salt__["boto_iam.get_user"](name, region, key, keyid, profile)
562     if not exists:
563         if __opts__["test"]:
564             ret["comment"] = "IAM user {} is set to be created.".format(name)
565             ret["result"] = None
566             return ret
567         created = __salt__["boto_iam.create_user"](
568             name, path, region, key, keyid, profile
569         )
570         if created:
571             ret["changes"]["user"] = created
572             ret["comment"] = " ".join(
573                 [ret["comment"], "User {} has been created.".format(name)]
574             )
575             if password:
576                 ret = _case_password(ret, name, password, region, key, keyid, profile)
577             _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
578             ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
579             ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
580     else:
581         ret["comment"] = " ".join([ret["comment"], "User {} is present.".format(name)])
582         if password:
583             ret = _case_password(ret, name, password, region, key, keyid, profile)
584         _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
585         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
586         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
587     _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
588     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
589     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
590     if not _ret["result"]:
591         ret["result"] = _ret["result"]
592         return ret
593     return ret
594 def _user_policies_present(
595     name, policies=None, region=None, key=None, keyid=None, profile=None
596 ):
597     ret = {"result": True, "comment": "", "changes": {}}
598     policies_to_create = {}
599     policies_to_delete = []
600     for policy_name, policy in policies.items():
601         if isinstance(policy, str):
602             dict_policy = salt.utils.json.loads(
603                 policy, object_pairs_hook=odict.OrderedDict
604             )
605         else:
606             dict_policy = policy
607         _policy = __salt__["boto_iam.get_user_policy"](
608             name, policy_name, region, key, keyid, profile
609         )
610         if _policy != dict_policy:
611             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
612             policies_to_create[policy_name] = policy
613     _list = __salt__["boto_iam.get_all_user_policies"](
614         user_name=name, region=region, key=key, keyid=keyid, profile=profile
615     )
616     for policy_name in _list:
617         if policy_name not in policies:
618             policies_to_delete.append(policy_name)
619     if policies_to_create or policies_to_delete:
620         _to_modify = list(policies_to_delete)
621         _to_modify.extend(policies_to_create)
622         if __opts__["test"]:
623             ret["comment"] = "{} policies to be modified on user {}.".format(
624                 ", ".join(_to_modify), name
625             )
626             ret["result"] = None
627             return ret
628         ret["changes"]["old"] = {"policies": _list}
629         for policy_name, policy in policies_to_create.items():
630             policy_set = __salt__["boto_iam.put_user_policy"](
631                 name, policy_name, policy, region, key, keyid, profile
632             )
633             if not policy_set:
634                 _list = __salt__["boto_iam.get_all_user_policies"](
635                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
636                 )
637                 ret["changes"]["new"] = {"policies": _list}
638                 ret["result"] = False
639                 ret["comment"] = "Failed to add policy {} for user {}".format(
640                     policy_name, name
641                 )
642                 return ret
643         for policy_name in policies_to_delete:
644             policy_unset = __salt__["boto_iam.delete_user_policy"](
645                 name, policy_name, region, key, keyid, profile
646             )
647             if not policy_unset:
648                 _list = __salt__["boto_iam.get_all_user_policies"](
649                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
650                 )
651                 ret["changes"]["new"] = {"policies": _list}
652                 ret["result"] = False
653                 ret["comment"] = "Failed to add policy {} to user {}".format(
654                     policy_name, name
655                 )
656                 return ret
657         _list = __salt__["boto_iam.get_all_user_policies"](
658             user_name=name, region=region, key=key, keyid=keyid, profile=profile
659         )
660         ret["changes"]["new"] = {"policies": _list}
661         ret["comment"] = "{} policies modified on user {}.".format(
662             ", ".join(_list), name
663         )
664     return ret
665 def _user_policies_attached(
666     name, managed_policies=None, region=None, key=None, keyid=None, profile=None
667 ):
668     ret = {"result": True, "comment": "", "changes": {}}
669     policies_to_attach = []
670     policies_to_detach = []
671     for policy in managed_policies or []:
672         entities = __salt__["boto_iam.list_entities_for_policy"](
673             policy,
674             entity_filter="User",
675             region=region,
676             key=key,
677             keyid=keyid,
678             profile=profile,
679         )
680         found = False
681         for userdict in entities.get("policy_users", []):
682             if name == userdict.get("user_name"):
683                 found = True
684                 break
685         if not found:
686             policies_to_attach.append(policy)
687     _list = __salt__["boto_iam.list_attached_user_policies"](
688         name, region=region, key=key, keyid=keyid, profile=profile
689     )
690     oldpolicies = [x.get("policy_arn") for x in _list]
691     for policy_data in _list:
692         if (
693             policy_data.get("policy_name") not in managed_policies
694             and policy_data.get("policy_arn") not in managed_policies
695         ):
696             policies_to_detach.append(policy_data.get("policy_arn"))
697     if policies_to_attach or policies_to_detach:
698         _to_modify = list(policies_to_detach)
699         _to_modify.extend(policies_to_attach)
700         if __opts__["test"]:
701             ret["comment"] = "{} policies to be modified on user {}.".format(
702                 ", ".join(_to_modify), name
703             )
704             ret["result"] = None
705             return ret
706         ret["changes"]["old"] = {"managed_policies": oldpolicies}
707         for policy_name in policies_to_attach:
708             policy_set = __salt__["boto_iam.attach_user_policy"](
709                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
710             )
711             if not policy_set:
712                 _list = __salt__["boto_iam.list_attached_user_policies"](
713                     name, region=region, key=key, keyid=keyid, profile=profile
714                 )
715                 newpolicies = [x.get("policy_arn") for x in _list]
716                 ret["changes"]["new"] = {"managed_policies": newpolicies}
717                 ret["result"] = False
718                 ret["comment"] = "Failed to add policy {} to user {}".format(
719                     policy_name, name
720                 )
721                 return ret
722         for policy_name in policies_to_detach:
723             policy_unset = __salt__["boto_iam.detach_user_policy"](
724                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
725             )
726             if not policy_unset:
727                 _list = __salt__["boto_iam.list_attached_user_policies"](
728                     name, region=region, key=key, keyid=keyid, profile=profile
729                 )
730                 newpolicies = [x.get("policy_arn") for x in _list]
731                 ret["changes"]["new"] = {"managed_policies": newpolicies}
732                 ret["result"] = False
733                 ret["comment"] = "Failed to remove policy {} from user {}".format(
734                     policy_name, name
735                 )
736                 return ret
737         _list = __salt__["boto_iam.list_attached_user_policies"](
738             name, region=region, key=key, keyid=keyid, profile=profile
739         )
740         newpolicies = [x.get("policy_arn") for x in _list]
741         log.debug(newpolicies)
742         ret["changes"]["new"] = {"managed_policies": newpolicies}
743         ret["comment"] = "{} policies modified on user {}.".format(
744             ", ".join(newpolicies), name
745         )
746     return ret
747 def _user_policies_detached(name, region=None, key=None, keyid=None, profile=None):
748     ret = {"result": True, "comment": "", "changes": {}}
749     _list = __salt__["boto_iam.list_attached_user_policies"](
750         user_name=name, region=region, key=key, keyid=keyid, profile=profile
751     )
752     oldpolicies = [x.get("policy_arn") for x in _list]
753     if not _list:
754         ret["comment"] = "No attached policies in user {}.".format(name)
755         return ret
756     if __opts__["test"]:
757         ret["comment"] = "{} policies to be detached from user {}.".format(
758             ", ".join(oldpolicies), name
759         )
760         ret["result"] = None
761         return ret
762     ret["changes"]["old"] = {"managed_policies": oldpolicies}
763     for policy_arn in oldpolicies:
764         policy_unset = __salt__["boto_iam.detach_user_policy"](
765             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
766         )
767         if not policy_unset:
768             _list = __salt__["boto_iam.list_attached_user_policies"](
769                 name, region=region, key=key, keyid=keyid, profile=profile
770             )
771             newpolicies = [x.get("policy_arn") for x in _list]
772             ret["changes"]["new"] = {"managed_policies": newpolicies}
773             ret["result"] = False
774             ret["comment"] = "Failed to detach {} from user {}".format(policy_arn, name)
775             return ret
776     _list = __salt__["boto_iam.list_attached_user_policies"](
777         name, region=region, key=key, keyid=keyid, profile=profile
778     )
779     newpolicies = [x.get("policy_arn") for x in _list]
780     ret["changes"]["new"] = {"managed_policies": newpolicies}
781     ret["comment"] = "{} policies detached from user {}.".format(
782         ", ".join(oldpolicies), name
783     )
784     return ret
785 def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
786     ret = {"result": True, "comment": "", "changes": {}}
787     oldpolicies = __salt__["boto_iam.get_all_user_policies"](
788         user_name=name, region=region, key=key, keyid=keyid, profile=profile
789     )
790     if not oldpolicies:
791         ret["comment"] = "No inline policies in user {}.".format(name)
792         return ret
793     if __opts__["test"]:
794         ret["comment"] = "{} policies to be deleted from user {}.".format(
795             ", ".join(oldpolicies), name
796         )
797         ret["result"] = None
798         return ret
799     ret["changes"]["old"] = {"inline_policies": oldpolicies}
800     for policy_name in oldpolicies:
801         policy_deleted = __salt__["boto_iam.delete_user_policy"](
802             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
803         )
804         if not policy_deleted:
805             newpolicies = __salt__["boto_iam.get_all_user_policies"](
806                 name, region=region, key=key, keyid=keyid, profile=profile
807             )
808             ret["changes"]["new"] = {"inline_policies": newpolicies}
809             ret["result"] = False
810             ret["comment"] = "Failed to detach {} from user {}".format(
811                 policy_name, name
812             )
813             return ret
814     newpolicies = __salt__["boto_iam.get_all_user_policies"](
815         name, region=region, key=key, keyid=keyid, profile=profile
816     )
817     ret["changes"]["new"] = {"inline_policies": newpolicies}
818     ret["comment"] = "{} policies deleted from user {}.".format(
819         ", ".join(oldpolicies), name
820     )
821     return ret
822 def _case_password(
823     ret, name, password, region=None, key=None, keyid=None, profile=None
824 ):
825     if __opts__["test"]:
826         ret["comment"] = "Login policy for {} is set to be changed.".format(name)
827         ret["result"] = None
828         return ret
829     login = __salt__["boto_iam.create_login_profile"](
830         name, password, region, key, keyid, profile
831     )
832     log.debug("Login is : %s.", login)
833     if login:
834         if "Conflict" in login:
835             ret["comment"] = " ".join(
836                 [ret["comment"], "Login profile for user {} exists.".format(name)]
837             )
838         else:
839             ret["comment"] = " ".join(
840                 [ret["comment"], "Password has been added to User {}.".format(name)]
841             )
842             ret["changes"]["password"] = "REDACTED"
843     else:
844         ret["result"] = False
845         ret["comment"] = " ".join(
846             [
847                 ret["comment"],
848                 "Password for user {} could not be set.\nPlease check your password"
849                 " policy.".format(name),
850             ]
851         )
852     return ret
853 def group_absent(name, region=None, key=None, keyid=None, profile=None):
854     """
855     .. versionadded:: 2015.8.0
856     Ensure the IAM group is absent.
857     name (string)
858         The name of the group.
859     region (string)
860         Region to connect to.
861     key (string)
862         Secret key to be used.
863     keyid (string)
864         Access key to be used.
865     profile (dict)
866         A dict with region, key and keyid, or a pillar key (string)
867         that contains a dict with region, key and keyid.
868     """
869     ret = {"name": name, "result": True, "comment": "", "changes": {}}
870     if not __salt__["boto_iam.get_group"](name, region, key, keyid, profile):
871         ret["result"] = True
872         ret["comment"] = "IAM Group {} does not exist.".format(name)
873         return ret
874     if __opts__["test"]:
875         ret["comment"] = " ".join(
876             [
877                 ret["comment"],
878                 "IAM group {} managed policies are set to be detached.".format(name),
879             ]
880         )
881         ret["result"] = None
882     else:
883         _ret = _group_policies_detached(name, region, key, keyid, profile)
884         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
885         if not _ret["result"]:
886             ret["result"] = _ret["result"]
887             if ret["result"] is False:
888                 return ret
889     if __opts__["test"]:
890         ret["comment"] = " ".join(
891             [
892                 ret["comment"],
893                 "IAM group {} inline policies are set to be deleted.".format(name),
894             ]
895         )
896         ret["result"] = None
897     else:
898         _ret = _group_policies_deleted(name, region, key, keyid, profile)
899         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
900         if not _ret["result"]:
901             ret["result"] = _ret["result"]
902             if ret["result"] is False:
903                 return ret
904     ret["comment"] = " ".join(
905         [ret["comment"], "IAM group {} users are set to be removed.".format(name)]
906     )
907     existing_users = __salt__["boto_iam.get_group_members"](
908         group_name=name, region=region, key=key, keyid=keyid, profile=profile
909     )
910     _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
911     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
912     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
913     if not _ret["result"]:
914         ret["result"] = _ret["result"]
915         return ret
916     if __opts__["test"]:
917         ret["comment"] = " ".join(
918             [ret["comment"], "IAM group {} is set to be deleted.".format(name)]
919         )
920         ret["result"] = None
921         return ret
922     deleted = __salt__["boto_iam.delete_group"](name, region, key, keyid, profile)
923     if deleted is True:
924         ret["comment"] = " ".join(
925             [ret["comment"], "IAM group {} is deleted.".format(name)]
926         )
927         ret["result"] = True
928         ret["changes"]["deleted"] = name
929         return ret
930     ret["comment"] = "IAM group {} could not be deleted.\n {}".format(name, deleted)
931     ret["result"] = False
932     return ret
933 def group_present(
934     name,
935     policies<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
936     policies_from_pillars=None,
937     managed_policies=None,
938     users=None,
939     path="/",
940     region=None,
941     key=None,
942     keyid=None,
943     profile=None,
944     delete_policies=True,
945 ):
946     """
947     .. versionadded:: 2015.8.0
948     Ensure the IAM group is present
949     name (string)
950         The name of the new group.
951     path (string)
952         The path for the group, defaults to '/'
953     policies (dict)
954         A dict of IAM group policy documents.
955     policies_from_pillars (list)
956         A list of pillars that contain role policy dicts. Policies in the
957         pillars will be merged in the order defined in the list and key
958         conflicts will be handled by later defined keys overriding earlier
959         defined keys. The policies defined here will be merged with the
960         policies defined in the policies argument. If keys conflict, the keys
961         in the policies argument will override the keys defined in
962         policies_from_pillars.
963     managed_policies (list)
964         A list of policy names or ARNs that should be attached to this group.
965     users (list)
966         A list of users to be added to the group.
967     region (string)
968         Region to connect to.
969     key (string)
970         Secret key to be used.
971     keyid (string)
972         Access key to be used.
973     profile (dict)
974         A dict with region, key and keyid, or a pillar key (string) that
975         contains a dict with region, key and keyid.
976     delete_policies (boolean)
977         Delete or detach existing policies that are not in the given list of policies.
978         Default value is ``True``. If ``False`` is specified, existing policies
979         will not be deleted or detached allowing manual modifications on the IAM group
980         to be persistent.
981     """
982     ret = {"name": name, "result": True, "comment": "", "changes": {}}
983     if not policies:
984         policies = {}
985     if</b></font> not policies_from_pillars:
986         policies_from_pillars = []
987     if not managed_policies:
988         managed_policies = []
989     _policies = {}
990     for policy in policies_from_pillars:
991         _policy = __salt__["pillar.get"](policy)
992         _policies.update(_policy)
993     _policies.update(policies)
994     exists = __salt__["boto_iam.get_group"](
995         group_name=name, region=region, key=key, keyid=keyid, profile=profile
996     )
997     if not exists:
998         if __opts__["test"]:
999             ret["comment"] = "IAM group {} is set to be created.".format(name)
1000             ret["result"] = None
1001             return ret
1002         created = __salt__["boto_iam.create_group"](
1003             group_name=name,
1004             path=path,
1005             region=region,
1006             key=key,
1007             keyid=keyid,
1008             profile=profile,
1009         )
1010         if not created:
1011             ret["comment"] = "Failed to create IAM group {}.".format(name)
1012             ret["result"] = False
1013             return ret
1014         ret["changes"]["group"] = created
1015         ret["comment"] = " ".join(
1016             [ret["comment"], "Group {} has been created.".format(name)]
1017         )
1018     else:
1019         ret["comment"] = " ".join([ret["comment"], "Group {} is present.".format(name)])
1020     _ret = _group_policies_present(
1021         name, _policies, region, key, keyid, profile, delete_policies
1022     )
1023     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
1024     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
1025     if not _ret["result"]:
1026         ret["result"] = _ret["result"]
1027         return ret
1028     _ret = _group_policies_attached(
1029         name, managed_policies, region, key, keyid, profile, delete_policies
1030     )
1031     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
1032     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
1033     if not _ret["result"]:
1034         ret["result"] = _ret["result"]
1035         return ret
1036     if users is not None:
1037         log.debug("Users are : %s.", users)
1038         existing_users = __salt__["boto_iam.get_group_members"](
1039             group_name=name, region=region, key=key, keyid=keyid, profile=profile
1040         )
1041         ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
1042     return ret
1043 def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
1044     _users = []
1045     for user in existing_users:
1046         _users.append(user["user_name"])
1047     log.debug("upstream users are %s", _users)
1048     for user in users:
1049         log.debug("users are %s", user)
1050         if user in _users:
1051             log.debug("user exists")
1052             ret["comment"] = " ".join(
1053                 [
1054                     ret["comment"],
1055                     "User {} is already a member of group {}.".format(user, group_name),
1056                 ]
1057             )
1058             continue
1059         else:
1060             log.debug("user is set to be added %s", user)
1061             if __opts__["test"]:
1062                 ret["comment"] = "User {} is set to be added to group {}.".format(
1063                     user, group_name
1064                 )
1065                 ret["result"] = None
1066             else:
1067                 __salt__["boto_iam.add_user_to_group"](
1068                     user, group_name, region, key, keyid, profile
1069                 )
1070                 ret["comment"] = " ".join(
1071                     [
1072                         ret["comment"],
1073                         "User {} has been added to group {}.".format(user, group_name),
1074                     ]
1075                 )
1076                 ret["changes"][user] = group_name
1077     for user in _users:
1078         if user not in users:
1079             if __opts__["test"]:
1080                 ret["comment"] = " ".join(
1081                     [
1082                         ret["comment"],
1083                         "User {} is set to be removed from group {}.".format(
1084                             user, group_name
1085                         ),
1086                     ]
1087                 )
1088                 ret["result"] = None
1089             else:
1090                 __salt__["boto_iam.remove_user_from_group"](
1091                     group_name=group_name,
1092                     user_name=user,
1093                     region=region,
1094                     key=key,
1095                     keyid=keyid,
1096                     profile=profile,
1097                 )
1098                 ret["comment"] = " ".join(
1099                     [
1100                         ret["comment"],
1101                         "User {} has been removed from group {}.".format(
1102                             user, group_name
1103                         ),
1104                     ]
1105                 )
1106                 ret["changes"][user] = "Removed from group {}.".format(group_name)
1107     return ret
1108 def _group_policies_present(
1109     name,
1110     policies=None,
1111     region=None,
1112     key=None,
1113     keyid=None,
1114     profile=None,
1115     delete_policies=True,
1116 ):
1117     ret = {"result": True, "comment": "", "changes": {}}
1118     policies_to_create = {}
1119     policies_to_delete = []
1120     for policy_name, policy in policies.items():
1121         if isinstance(policy, str):
1122             dict_policy = salt.utils.json.loads(
1123                 policy, object_pairs_hook=odict.OrderedDict
1124             )
1125         else:
1126             dict_policy = policy
1127         _policy = __salt__["boto_iam.get_group_policy"](
1128             name, policy_name, region, key, keyid, profile
1129         )
1130         if _policy != dict_policy:
1131             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
1132             policies_to_create[policy_name] = policy
1133     _list = __salt__["boto_iam.get_all_group_policies"](
1134         name, region, key, keyid, profile
1135     )
1136     for policy_name in _list:
1137         if delete_policies and policy_name not in policies:
1138             policies_to_delete.append(policy_name)
1139     if policies_to_create or policies_to_delete:
1140         _to_modify = list(policies_to_delete)
1141         _to_modify.extend(policies_to_create)
1142         if __opts__["test"]:
1143             ret["comment"] = "{} policies to be modified on group {}.".format(
1144                 ", ".join(_to_modify), name
1145             )
1146             ret["result"] = None
1147             return ret
1148         ret["changes"]["old"] = {"policies": _list}
1149         for policy_name, policy in policies_to_create.items():
1150             policy_set = __salt__["boto_iam.put_group_policy"](
1151                 name, policy_name, policy, region, key, keyid, profile
1152             )
1153             if not policy_set:
1154                 _list = __salt__["boto_iam.get_all_group_policies"](
1155                     name, region, key, keyid, profile
1156                 )
1157                 ret["changes"]["new"] = {"policies": _list}
1158                 ret["result"] = False
1159                 ret["comment"] = "Failed to add policy {} to group {}".format(
1160                     policy_name, name
1161                 )
1162                 return ret
1163         for policy_name in policies_to_delete:
1164             policy_unset = __salt__["boto_iam.delete_group_policy"](
1165                 name, policy_name, region, key, keyid, profile
1166             )
1167             if not policy_unset:
1168                 _list = __salt__["boto_iam.get_all_group_policies"](
1169                     name, region, key, keyid, profile
1170                 )
1171                 ret["changes"]["new"] = {"policies": _list}
1172                 ret["result"] = False
1173                 ret["comment"] = "Failed to add policy {} to group {}".format(
1174                     policy_name, name
1175                 )
1176                 return ret
1177         _list = __salt__["boto_iam.get_all_group_policies"](
1178             name, region, key, keyid, profile
1179         )
1180         ret["changes"]["new"] = {"policies": _list}
1181         ret["comment"] = "{} policies modified on group {}.".format(
1182             ", ".join(_list), name
1183         )
1184     return ret
1185 def _group_policies_attached(
1186     name,
1187     managed_policies=None,
1188     region=None,
1189     key=None,
1190     keyid=None,
1191     profile=None,
1192     detach_policies=True,
1193 ):
1194     ret = {"result": True, "comment": "", "changes": {}}
1195     policies_to_attach = []
1196     policies_to_detach = []
1197     for policy in managed_policies or []:
1198         entities = __salt__["boto_iam.list_entities_for_policy"](
1199             policy,
1200             entity_filter="Group",
1201             region=region,
1202             key=key,
1203             keyid=keyid,
1204             profile=profile,
1205         )
1206         found = False
1207         for groupdict in entities.get("policy_groups", []):
1208             if name == groupdict.get("group_name"):
1209                 found = True
1210                 break
1211         if not found:
1212             policies_to_attach.append(policy)
1213     _list = __salt__["boto_iam.list_attached_group_policies"](
1214         name, region=region, key=key, keyid=keyid, profile=profile
1215     )
1216     oldpolicies = [x.get("policy_arn") for x in _list]
1217     for policy_data in _list:
1218         if (
1219             detach_policies
1220             and policy_data.get("policy_name") not in managed_policies
1221             and policy_data.get("policy_arn") not in managed_policies
1222         ):
1223             policies_to_detach.append(policy_data.get("policy_arn"))
1224     if policies_to_attach or policies_to_detach:
1225         _to_modify = list(policies_to_detach)
1226         _to_modify.extend(policies_to_attach)
1227         if __opts__["test"]:
1228             ret["comment"] = "{} policies to be modified on group {}.".format(
1229                 ", ".join(_to_modify), name
1230             )
1231             ret["result"] = None
1232             return ret
1233         ret["changes"]["old"] = {"managed_policies": oldpolicies}
1234         for policy_name in policies_to_attach:
1235             policy_set = __salt__["boto_iam.attach_group_policy"](
1236                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
1237             )
1238             if not policy_set:
1239                 _list = __salt__["boto_iam.list_attached_group_policies"](
1240                     name, region=region, key=key, keyid=keyid, profile=profile
1241                 )
1242                 newpolicies = [x.get("policy_arn") for x in _list]
1243                 ret["changes"]["new"] = {"managed_policies": newpolicies}
1244                 ret["result"] = False
1245                 ret["comment"] = "Failed to add policy {} to group {}".format(
1246                     policy_name, name
1247                 )
1248                 return ret
1249         for policy_name in policies_to_detach:
1250             policy_unset = __salt__["boto_iam.detach_group_policy"](
1251                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
1252             )
1253             if not policy_unset:
1254                 _list = __salt__["boto_iam.list_attached_group_policies"](
1255                     name, region=region, key=key, keyid=keyid, profile=profile
1256                 )
1257                 newpolicies = [x.get("policy_arn") for x in _list]
1258                 ret["changes"]["new"] = {"managed_policies": newpolicies}
1259                 ret["result"] = False
1260                 ret["comment"] = "Failed to remove policy {} from group {}".format(
1261                     policy_name, name
1262                 )
1263                 return ret
1264         _list = __salt__["boto_iam.list_attached_group_policies"](
1265             name, region=region, key=key, keyid=keyid, profile=profile
1266         )
1267         newpolicies = [x.get("policy_arn") for x in _list]
1268         log.debug(newpolicies)
1269         ret["changes"]["new"] = {"managed_policies": newpolicies}
1270         ret["comment"] = "{} policies modified on group {}.".format(
1271             ", ".join(newpolicies), name
1272         )
1273     return ret
1274 def _group_policies_detached(name, region=None, key=None, keyid=None, profile=None):
1275     ret = {"result": True, "comment": "", "changes": {}}
1276     _list = __salt__["boto_iam.list_attached_group_policies"](
1277         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1278     )
1279     oldpolicies = [x.get("policy_arn") for x in _list]
1280     if not _list:
1281         ret["comment"] = "No attached policies in group {}.".format(name)
1282         return ret
1283     if __opts__["test"]:
1284         ret["comment"] = "{} policies to be detached from group {}.".format(
1285             ", ".join(oldpolicies), name
1286         )
1287         ret["result"] = None
1288         return ret
1289     ret["changes"]["old"] = {"managed_policies": oldpolicies}
1290     for policy_arn in oldpolicies:
1291         policy_unset = __salt__["boto_iam.detach_group_policy"](
1292             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
1293         )
1294         if not policy_unset:
1295             _list = __salt__["boto_iam.list_attached_group_policies"](
1296                 name, region=region, key=key, keyid=keyid, profile=profile
1297             )
1298             newpolicies = [x.get("policy_arn") for x in _list]
1299             ret["changes"]["new"] = {"managed_policies": newpolicies}
1300             ret["result"] = False
1301             ret["comment"] = "Failed to detach {} from group {}".format(
1302                 policy_arn, name
1303             )
1304             return ret
1305     _list = __salt__["boto_iam.list_attached_group_policies"](
1306         name, region=region, key=key, keyid=keyid, profile=profile
1307     )
1308     newpolicies = [x.get("policy_arn") for x in _list]
1309     ret["changes"]["new"] = {"managed_policies": newpolicies}
1310     ret["comment"] = "{} policies detached from group {}.".format(
1311         ", ".join(newpolicies), name
1312     )
1313     return ret
1314 def _group_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
1315     ret = {"result": True, "comment": "", "changes": {}}
1316     oldpolicies = __salt__["boto_iam.get_all_group_policies"](
1317         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1318     )
1319     if not oldpolicies:
1320         ret["comment"] = "No inline policies in group {}.".format(name)
1321         return ret
1322     if __opts__["test"]:
1323         ret["comment"] = "{} policies to be deleted from group {}.".format(
1324             ", ".join(oldpolicies), name
1325         )
1326         ret["result"] = None
1327         return ret
1328     ret["changes"]["old"] = {"inline_policies": oldpolicies}
1329     for policy_name in oldpolicies:
1330         policy_deleted = __salt__["boto_iam.delete_group_policy"](
1331             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
1332         )
1333         if not policy_deleted:
1334             newpolicies = __salt__["boto_iam.get_all_group_policies"](
1335                 name, region=region, key=key, keyid=keyid, profile=profile
1336             )
1337             ret["changes"]["new"] = {"inline_policies": newpolicies}
1338             ret["result"] = False
1339             ret["comment"] = "Failed to detach {} from group {}".format(
1340                 policy_name, name
1341             )
1342             return ret
1343     newpolicies = __salt__["boto_iam.get_all_group_policies"](
1344         name, region=region, key=key, keyid=keyid, profile=profile
1345     )
1346     ret["changes"]["new"] = {"inline_policies": newpolicies}
1347         ", ".join(oldpolicies), name
1348     )
1349     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
1350 def account_policy(
1351     name=None,
1352     allow_users_to_change_password=None,
1353     hard_expiry=None,
1354     max_password_age=None,
1355     minimum_password_length=None,
1356     password_reuse_prevention=None,
1357     require_lowercase_characters=None,
1358     require_numbers=None,
1359     require_symbols=None,
1360     require_uppercase_characters=None,
1361     region=None,
1362     key=None,
1363     keyid=None,
1364     profile=None,
1365 ):
1366     """
1367     Change account policy.
1368     .. versionadded:: 2015.8.0
1369     name (string)
1370         The name of the account policy
1371     allow_users_to_change_password (bool)
1372         Allows all IAM users in your account to
1373         use the AWS Management Console to change their own passwords.
1374     hard_expiry (bool)
1375         Prevents IAM users from setting a new password after their
1376         password has expired.
1377     max_password_age (int)
1378         The number of days that an IAM user password is valid.
1379     minimum_password_length (int)
1380         The minimum number of characters allowed in an IAM user password.
1381     password_reuse_prevention (int)
1382         Specifies the number of previous passwords
1383         that IAM users are prevented from reusing.
1384     require_lowercase_characters (bool)
1385         Specifies whether IAM user passwords
1386         must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).
1387     require_numbers (bool)
1388         Specifies whether IAM user passwords must contain at
1389         least one numeric character (0 to 9).
1390     require_symbols (bool)
1391         Specifies whether IAM user passwords must contain at
1392         least one of the following non-alphanumeric characters: ! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '
1393     require_uppercase_characters (bool)
1394         Specifies whether IAM user passwords must
1395         contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).
1396     region (string)
1397         Region to connect to.
1398     key (string)
1399         Secret key to be used.
1400     keyid (string)
1401         Access key to be used.
1402     profile (dict)
1403         A dict with region, key and keyid, or a pillar key (string)
1404     """
1405     ret = {"name": "Account Policy", "result": True, "comment": "", "changes": {}}
1406     info = __salt__["boto_iam.get_account_policy"](region, key, keyid, profile)
1407     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not info:
1408         ret["comment"] = "Account policy is not Enabled."
1409         ret["result"] = False
1410         return ret
1411     for key, value in config.items():
1412         if key in ("region"</b></font>, "key", "keyid", "profile", "name"):
1413             continue
1414         if value is not None and str(info[key]) != str(value).lower():
1415             ret["comment"] = " ".join(
1416                 [
1417                     ret["comment"],
1418                     "Policy value {} has been set to {}.".format(value, info[key]),
1419                 ]
1420             )
1421             ret["changes"][key] = str(value).lower()
1422     if not ret["changes"]:
1423         ret["comment"] = "Account policy is not changed."
1424         return ret
1425     if __opts__["test"]:
1426         ret["comment"] = "Account policy is set to be changed."
1427         ret["result"] = None
1428         return ret
1429     if __salt__["boto_iam.update_account_password_policy"](
1430         allow_users_to_change_password,
1431         hard_expiry,
1432         max_password_age,
1433         minimum_password_length,
1434         password_reuse_prevention,
1435         require_lowercase_characters,
1436         require_numbers,
1437         require_symbols,
1438         require_uppercase_characters,
1439         region,
1440         key,
1441         keyid,
1442         profile,
1443     ):
1444         return ret
1445     ret["comment"] = "Account policy is not changed."
1446     ret["changes"] = {}
1447     ret["result"] = False
1448     return ret
1449 def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
1450     """
1451     Deletes a server certificate.
1452     .. versionadded:: 2015.8.0
1453     name (string)
1454         The name for the server certificate. Do not include the path in this value.
1455     region (string)
1456         The name of the region to connect to.
1457     key (string)
1458         The key to be used in order to connect
1459     keyid (string)
1460         The keyid to be used in order to connect
1461     profile (string)
1462         The profile that contains a dict of region, key, keyid
1463     """
1464     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1465     exists = __salt__["boto_iam.get_server_certificate"](
1466         name, region, key, keyid, profile
1467     )
1468     if not exists:
1469         ret["comment"] = "Certificate {} does not exist.".format(name)
1470         return ret
1471     if __opts__["test"]:
1472         ret["comment"] = "Server certificate {} is set to be deleted.".format(name)
1473         ret["result"] = None
1474         return ret
1475     deleted = __salt__["boto_iam.delete_server_cert"](name, region, key, keyid, profile)
1476     if not deleted:
1477         ret["result"] = False
1478         ret["comment"] = "Certificate {} failed to be deleted.".format(name)
1479         return ret
1480     ret["comment"] = "Certificate {} was deleted.".format(name)
1481     ret["changes"] = deleted
1482     return ret
1483 def server_cert_present(
1484     name,
1485     public_key,
1486     private_key,
1487     cert_chain=None,
1488     path=None,
1489     region=None,
1490     key=None,
1491     keyid=None,
1492     profile=None,
1493 ):
1494     """
1495     Crete server certificate.
1496     .. versionadded:: 2015.8.0
1497     name (string)
1498         The name for the server certificate. Do not include the path in this value.
1499     public_key (string)
1500         The contents of the public key certificate in PEM-encoded format.
1501     private_key (string)
1502         The contents of the private key in PEM-encoded format.
1503     cert_chain (string)
1504         The contents of the certificate chain. This is typically a
1505         concatenation of the PEM-encoded public key certificates of the chain.
1506     path (string)
1507         The path for the server certificate.
1508     region (string)
1509         The name of the region to connect to.
1510     key (string)
1511         The key to be used in order to connect
1512     keyid (string)
1513         The keyid to be used in order to connect
1514     profile (string)
1515         The profile that contains a dict of region, key, keyid
1516     """
1517     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1518     exists = __salt__["boto_iam.get_server_certificate"](
1519         name, region, key, keyid, profile
1520     )
1521     log.debug("Variables are : %s.", locals())
1522     if exists:
1523         ret["comment"] = "Certificate {} exists.".format(name)
1524         return ret
1525     if "salt://" in public_key:
1526         try:
1527             public_key = __salt__["cp.get_file_str"](public_key)
1528         except OSError as e:
1529             log.debug(e)
1530             ret["comment"] = "File {} not found.".format(public_key)
1531             ret["result"] = False
1532             return ret
1533     if "salt://" in private_key:
1534         try:
1535             private_key = __salt__["cp.get_file_str"](private_key)
1536         except OSError as e:
1537             log.debug(e)
1538             ret["comment"] = "File {} not found.".format(private_key)
1539             ret["result"] = False
1540             return ret
1541     if cert_chain is not None and "salt://" in cert_chain:
1542         try:
1543             cert_chain = __salt__["cp.get_file_str"](cert_chain)
1544         except OSError as e:
1545             log.debug(e)
1546             ret["comment"] = "File {} not found.".format(cert_chain)
1547             ret["result"] = False
1548             return ret
1549     if __opts__["test"]:
1550         ret["comment"] = "Server certificate {} is set to be created.".format(name)
1551         ret["result"] = None
1552         return ret
1553     created = __salt__["boto_iam.upload_server_cert"](
1554         name, public_key, private_key, cert_chain, path, region, key, keyid, profile
1555     )
1556     if created is not False:
1557         ret["comment"] = "Certificate {} was created.".format(name)
1558         ret["changes"] = created
1559         return ret
1560     ret["result"] = False
1561     ret["comment"] = "Certificate {} failed to be created.".format(name)
1562     return ret
1563 def policy_present(
1564     name,
1565     policy_document,
1566     path=None,
1567     description=None,
1568     region=None,
1569     key=None,
1570     keyid=None,
1571     profile=None,
1572 ):
1573     """
1574     .. versionadded:: 2015.8.0
1575     Ensure the IAM managed policy is present
1576     name (string)
1577         The name of the new policy.
1578     policy_document (dict)
1579         The document of the new policy
1580     path (string)
1581         The path in which the policy will be created. Default is '/'.
1582     description (string)
1583         Description
1584     region (string)
1585         Region to connect to.
1586     key (string)
1587         Secret key to be used.
1588     keyid (string)
1589         Access key to be used.
1590     profile (dict)
1591         A dict with region, key and keyid, or a pillar key (string)
1592         that contains a dict with region, key and keyid.
1593     """
1594     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1595     policy = __salt__["boto_iam.get_policy"](name, region, key, keyid, profile)
1596     if not policy:
1597         if __opts__["test"]:
1598             ret["comment"] = "IAM policy {} is set to be created.".format(name)
1599             ret["result"] = None
1600             return ret
1601         created = __salt__["boto_iam.create_policy"](
1602             name, policy_document, path, description, region, key, keyid, profile
1603         )
1604         if created:
1605             ret["changes"]["policy"] = created
1606             ret["comment"] = " ".join(
1607                 [ret["comment"], "Policy {} has been created.".format(name)]
1608             )
1609         else:
1610             ret["result"] = False
1611             ret["comment"] = "Failed to update policy."
1612             ret["changes"] = {}
1613             return ret
1614     else:
1615         policy = policy.get("policy", {})
1616         ret["comment"] = " ".join(
1617             [ret["comment"], "Policy {} is present.".format(name)]
1618         )
1619         _describe = __salt__["boto_iam.get_policy_version"](
1620             name, policy.get("default_version_id"), region, key, keyid, profile
1621         ).get("policy_version", {})
1622         if isinstance(_describe["document"], str):
1623             describeDict = salt.utils.json.loads(_describe["document"])
1624         else:
1625             describeDict = _describe["document"]
1626         if isinstance(policy_document, str):
1627             policy_document = salt.utils.json.loads(policy_document)
1628         r = salt.utils.data.compare_dicts(describeDict, policy_document)
1629         if bool(r):
1630             if __opts__["test"]:
1631                 ret["comment"] = "Policy {} set to be modified.".format(name)
1632                 ret["result"] = None
1633                 return ret
1634             ret["comment"] = " ".join([ret["comment"], "Policy to be modified"])
1635             policy_document = salt.utils.json.dumps(policy_document)
1636             r = __salt__["boto_iam.create_policy_version"](
1637                 policy_name=name,
1638                 policy_document=policy_document,
1639                 set_as_default=True,
1640                 region=region,
1641                 key=key,
1642                 keyid=keyid,
1643                 profile=profile,
1644             )
1645             if not r.get("created"):
1646                 ret["result"] = False
1647                 ret["comment"] = "Failed to update policy: {}.".format(
1648                     r["error"]["message"]
1649                 )
1650                 ret["changes"] = {}
1651                 return ret
1652             __salt__["boto_iam.delete_policy_version"](
1653                 policy_name=name,
1654                 version_id=policy["default_version_id"],
1655                 region=region,
1656                 key=key,
1657                 keyid=keyid,
1658                 profile=profile,
1659             )
1660             ret["changes"].setdefault("new", {})["document"] = policy_document
1661             ret["changes"].setdefault("old", {})["document"] = _describe["document"]
1662     return ret
1663 def policy_absent(name, region=None, key=None, keyid=None, profile=None):
1664     """
1665     .. versionadded:: 2015.8.0
1666     Ensure the IAM managed policy with the specified name is absent
1667     name (string)
1668         The name of the new policy.
1669     region (string)
1670         Region to connect to.
1671     key (string)
1672         Secret key to be used.
1673     keyid (string)
1674         Access key to be used.
1675     profile (dict)
1676         A dict with region, key and keyid, or a pillar key (string)
1677         that contains a dict with region, key and keyid.
1678     """
1679     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1680     r = __salt__["boto_iam.policy_exists"](
1681         name, region=region, key=key, keyid=keyid, profile=profile
1682     )
1683     if not r:
1684         ret["comment"] = "Policy {} does not exist.".format(name)
1685         return ret
1686     if __opts__["test"]:
1687         ret["comment"] = "Policy {} is set to be removed.".format(name)
1688         ret["result"] = None
1689         return ret
1690     versions = __salt__["boto_iam.list_policy_versions"](
1691         name, region=region, key=key, keyid=keyid, profile=profile
1692     )
1693     if versions:
1694         for version in versions:
1695             if version.get("is_default_version", False) in ("true", True):
1696                 continue
1697             r = __salt__["boto_iam.delete_policy_version"](
1698                 name,
1699                 version_id=version.get("version_id"),
1700                 region=region,
1701                 key=key,
1702                 keyid=keyid,
1703                 profile=profile,
1704             )
1705             if not r:
1706                 ret["result"] = False
1707                 ret["comment"] = "Failed to delete policy {}.".format(name)
1708                 return ret
1709     r = __salt__["boto_iam.delete_policy"](
1710         name, region=region, key=key, keyid=keyid, profile=profile
1711     )
1712     if not r:
1713         ret["result"] = False
1714         ret["comment"] = "Failed to delete policy {}.".format(name)
1715         return ret
1716     ret["changes"]["old"] = {"policy": name}
1717     ret["changes"]["new"] = {"policy": None}
1718     ret["comment"] = "Policy {} deleted.".format(name)
1719     return ret
1720 def saml_provider_present(
1721     name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
1722 ):
1723     """
1724     .. versionadded:: 2016.11.0
1725     Ensure the SAML provider with the specified name is present.
1726     name (string)
1727         The name of the SAML provider.
1728     saml_metadata_document (string)
1729         The xml document of the SAML provider.
1730     region (string)
1731         Region to connect to.
1732     key (string)
1733         Secret key to be used.
1734     keyid (string)
1735         Access key to be used.
1736     profile (dict)
1737         A dict with region, key and keyid, or a pillar key (string)
1738         that contains a dict with region, key and keyid.
1739     """
1740     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1741     if "salt://" in saml_metadata_document:
1742         try:
1743             saml_metadata_document = __salt__["cp.get_file_str"](saml_metadata_document)
1744             ET.fromstring(saml_metadata_document)
1745         except OSError as e:
1746             log.debug(e)
1747             ret[
1748                 "comment"
1749             ] = "SAML document file {} not found or could not be loaded".format(name)
1750             ret["result"] = False
1751             return ret
1752     for provider in __salt__["boto_iam.list_saml_providers"](
1753         region=region, key=key, keyid=keyid, profile=profile
1754     ):
1755         if provider == name:
1756             ret["comment"] = "SAML provider {} is present.".format(name)
1757             return ret
1758     if __opts__["test"]:
1759         ret["comment"] = "SAML provider {} is set to be create.".format(name)
1760         ret["result"] = None
1761         return ret
1762     created = __salt__["boto_iam.create_saml_provider"](
1763         name,
1764         saml_metadata_document,
1765         region=region,
1766         key=key,
1767         keyid=keyid,
1768         profile=profile,
1769     )
1770     if created:
1771         ret["comment"] = "SAML provider {} was created.".format(name)
1772         ret["changes"]["new"] = name
1773         return ret
1774     ret["result"] = False
1775     ret["comment"] = "SAML provider {} failed to be created.".format(name)
1776     return ret
1777 def saml_provider_absent(name, region=None, key=None, keyid=None, profile=None):
1778     """
1779     .. versionadded:: 2016.11.0
1780     Ensure the SAML provider with the specified name is absent.
1781     name (string)
1782         The name of the SAML provider.
1783     saml_metadata_document (string)
1784         The xml document of the SAML provider.
1785     region (string)
1786         Region to connect to.
1787     key (string)
1788         Secret key to be used.
1789     keyid (string)
1790         Access key to be used.
1791     profile (dict)
1792         A dict with region, key and keyid, or a pillar key (string)
1793         that contains a dict with region, key and keyid.
1794     """
1795     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1796     provider = __salt__["boto_iam.list_saml_providers"](
1797         region=region, key=key, keyid=keyid, profile=profile
1798     )
1799     if len(provider) == 0:
1800         ret["comment"] = "SAML provider {} is absent.".format(name)
1801         return ret
1802     if __opts__["test"]:
1803         ret["comment"] = "SAML provider {} is set to be removed.".format(name)
1804         ret["result"] = None
1805         return ret
1806     deleted = __salt__["boto_iam.delete_saml_provider"](
1807         name, region=region, key=key, keyid=keyid, profile=profile
1808     )
1809     if deleted is not False:
1810         ret["comment"] = "SAML provider {} was deleted.".format(name)
1811         ret["changes"]["old"] = name
1812         return ret
1813     ret["result"] = False
1814     ret["comment"] = "SAML provider {} failed to be deleted.".format(name)
1815     return ret
1816 def _get_error(error):
1817     error = "\n".join(error.split("\n")[1:])
1818     error = ET.fromstring(error)
1819     code = error[0][1].text
1820     message = error[0][2].text
1821     return code, message
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
