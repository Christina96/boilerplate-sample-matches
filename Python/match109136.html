<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for saltmod.py &amp; boto_iam.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for saltmod.py &amp; boto_iam.py
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>saltmod.py (6.0851927%)<th>boto_iam.py (2.144389%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-117)<td><a href="#" name="0">(1484-1557)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(445-519)<td><a href="#" name="1">(1045-1108)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(25-42)<td><a href="#" name="2">(133-149)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(376-382)<td><a href="#" name="3">(1560-1565)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import sys
3 import threading
4 import time
5 import salt.exceptions
6 import salt.output
7 import salt.syspaths
8 import salt.utils.data
9 import salt.utils.event
10 log = logging.getLogger(__name__)
11 __virtualname__ = "salt"
12 def</b></font> __virtual__():
13     return __virtualname__
14 def _fire_args(tag_data):
15     try:
16         salt.utils.event.fire_args(__opts__, __orchestration_jid__, tag_data, "run")
17     except NameError:
18         log.debug("Unable to fire args event due to missing __orchestration_jid__")
19 def _parallel_map(func, inputs):
20     outputs = len(inputs) * [None]
21     errors = len(inputs) * [None]
22     def create_thread(index):
23         def run_thread():
24             try:
25                 outputs[index] = func(inputs[index])
26             except:  # pylint: disable=bare-except
27                 errors[index] = sys.exc_info()
28         thread = threading.Thread(target=run_thread)
29         thread.start()
30         return thread
31     threads = list(map(create_thread, range(len(inputs))))
32     for thread in threads:
33         thread.join()
34     for error in errors:
35 <a name="0"></a>        if error is not None:
36             exc_type, exc_value, exc_traceback = error
37             raise exc_value.with_traceback(exc_traceback)
38     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return outputs
39 def state(
40     name,
41     tgt,
42     ssh=False,
43     tgt_type="glob",
44     ret="",
45     ret_config=None,
46     ret_kwargs=None,
47     highstate=None,
48     sls=None,
49     top=None,
50     saltenv=None,
51     test=None,
52     pillar=None,
53     pillarenv=None,
54     expect_minions=True,
55     exclude=None,
56     fail_minions=</b></font>None,
57     allow_fail=0,
58     concurrent=False,
59     timeout=None,
60     batch=None,
61     queue=False,
62     subset=None,
63     orchestration_jid=None,
64     failhard=None,
65     **kwargs
66 ):
67     cmd_kw = {"arg": [], "kwarg": {}, "ret": ret, "timeout": timeout}
68     if ret_config:
69         cmd_kw["ret_config"] = ret_config
70     if ret_kwargs:
71         cmd_kw["ret_kwargs"] = ret_kwargs
72     state_ret = {"name": name, "changes": {}, "comment": "", "result": True}
73     try:
74         allow_fail = int(allow_fail)
75     except ValueError:
76         state_ret["result"] = False
77         state_ret["comment"] = "Passed invalid value for 'allow_fail', must be an int"
78         return state_ret
79     cmd_kw["tgt_type"] = tgt_type
80     cmd_kw["ssh"] = ssh
81     if "roster" in kwargs:
82         cmd_kw["roster"] = kwargs["roster"]
83     cmd_kw["expect_minions"] = expect_minions
84     if highstate:
85         fun = "state.highstate"
86     elif top:
87         fun = "state.top"
88         cmd_kw["arg"].append(top)
89     elif sls:
90         fun = "state.sls"
91         if isinstance(sls, list):
92             sls = ",".join(sls)
93         cmd_kw["arg"].append(sls)
94     else:
95         state_ret["comment"] = "No highstate or sls specified, no execution made"
96         state_ret["result"] = False
97         return state_ret
98     if test is not None or __opts__.get("test"):
99         cmd_kw["kwarg"]["test"] = test if test is not None else __opts__.get("test")
100     if pillar:
101         cmd_kw["kwarg"]["pillar"] = pillar
102     if pillarenv is not None:
103         cmd_kw["kwarg"]["pillarenv"] = pillarenv
104     if saltenv is not None:
105         cmd_kw["kwarg"]["saltenv"] = saltenv
106     if exclude is not None:
107         cmd_kw["kwarg"]["exclude"] = exclude
108     cmd_kw["kwarg"]["queue"] = queue
109     if isinstance(concurrent, bool):
110         cmd_kw["kwarg"]["concurrent"] = concurrent
111     else:
112         state_ret["comment"] = "Must pass in boolean for value of 'concurrent'"
113         state_ret["result"] = False
114         return state_ret
115     if batch is not None:
116         cmd_kw["batch"] = str(batch)
117     if subset is not None:
118         cmd_kw["subset"] = subset
119     if failhard is True or __opts__.get("failhard"):
120         cmd_kw["failhard"] = True
121     masterless = __opts__["__role"] == "minion" and __opts__["file_client"] == "local"
122     if not masterless:
123         _fire_args({"type": "state", "tgt": tgt, "name": name, "args": cmd_kw})
124         cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
125     else:
126         if top:
127             cmd_kw["topfn"] = "".join(cmd_kw.pop("arg"))
128         elif sls:
129             cmd_kw["mods"] = "".join(cmd_kw.pop("arg"))
130         cmd_kw.update(cmd_kw.pop("kwarg"))
131         tmp_ret = __salt__[fun](**cmd_kw)
132         cmd_ret = {
133             __opts__["id"]: {
134                 "ret": tmp_ret,
135                 "out": tmp_ret.get("out", "highstate")
136                 if isinstance(tmp_ret, dict)
137                 else "highstate",
138             }
139         }
140     try:
141         state_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
142     except (StopIteration, KeyError):
143         pass
144     changes = {}
145     fail = set()
146     no_change = set()
147     if fail_minions is None:
148         fail_minions = ()
149     elif isinstance(fail_minions, str):
150         fail_minions = [minion.strip() for minion in fail_minions.split(",")]
151     elif not isinstance(fail_minions, list):
152         state_ret.setdefault("warnings", []).append(
153             "'fail_minions' needs to be a list or a comma separated string. Ignored."
154 <a name="3"></a>        )
155         fail_minions = ()
156     <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not cmd_ret and expect_minions:
157         state_ret["result"] = False
158         state_ret["comment"] = "No minions returned"
159         return state_ret
160     for minion, mdata in cmd_ret.items():
161         if mdata.</b></font>get("out", "") != "highstate":
162             log.warning("Output from salt state not highstate")
163         m_ret = False
164         if "return" in mdata and "ret" not in mdata:
165             mdata["ret"] = mdata.pop("return")
166         m_state = True
167         if mdata.get("failed", False):
168             m_state = False
169         else:
170             try:
171                 m_ret = mdata["ret"]
172             except KeyError:
173                 m_state = False
174             if m_state:
175                 m_state = __utils__["state.check_result"](m_ret, recurse=True)
176         if not m_state:
177             if minion not in fail_minions:
178                 fail.add(minion)
179             changes[minion] = m_ret
180             continue
181         try:
182             for state_item in m_ret.values():
183                 if isinstance(state_item, dict):
184                     if "changes" in state_item and state_item["changes"]:
185                         changes[minion] = m_ret
186                         break
187             else:
188                 no_change.add(minion)
189         except AttributeError:
190             log.error("m_ret did not have changes %s %s", type(m_ret), m_ret)
191             no_change.add(minion)
192     if changes:
193         state_ret["changes"] = {"out": "highstate", "ret": changes}
194     if len(fail) &gt; allow_fail:
195         state_ret["result"] = False
196         state_ret["comment"] = "Run failed on minions: {}".format(", ".join(fail))
197     else:
198         state_ret["comment"] = "States ran successfully."
199         if changes:
200             state_ret["comment"] += " Updating {}.".format(", ".join(changes))
201         if no_change:
202             state_ret["comment"] += " No changes made to {}.".format(
203                 ", ".join(no_change)
204             )
205     if test or __opts__.get("test"):
206         if state_ret["changes"] and state_ret["result"] is True:
207             state_ret["result"] = None
208     return state_ret
209 def function(
210     name,
211     tgt,
212     ssh=False,
213 <a name="1"></a>    tgt_type="glob",
214     ret="",
215     ret_config=None,
216     ret_kwargs<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
217     expect_minions=False,
218     fail_minions=None,
219     fail_function=None,
220     arg=None,
221     kwarg=None,
222     timeout=None,
223     batch=None,
224     subset=None,
225     failhard=None,
226     **kwargs
227 ):  # pylint: disable=unused-argument
228     func_ret = {"name": name, "changes": {}, "comment": "", "result": True}
229     if kwarg is None:
230         kwarg = {}
231     if</b></font> isinstance(arg, str):
232         func_ret["warnings"] = ["Please specify 'arg' as a list of arguments."]
233         arg = arg.split()
234     cmd_kw = {"arg": arg or [], "kwarg": kwarg, "ret": ret, "timeout": timeout}
235     if batch is not None:
236         cmd_kw["batch"] = str(batch)
237     if subset is not None:
238         cmd_kw["subset"] = subset
239     cmd_kw["tgt_type"] = tgt_type
240     cmd_kw["ssh"] = ssh
241     if "roster" in kwargs:
242         cmd_kw["roster"] = kwargs["roster"]
243     cmd_kw["expect_minions"] = expect_minions
244     cmd_kw["_cmd_meta"] = True
245     if failhard is True or __opts__.get("failhard"):
246         cmd_kw["failhard"] = True
247     if ret_config:
248         cmd_kw["ret_config"] = ret_config
249     if ret_kwargs:
250         cmd_kw["ret_kwargs"] = ret_kwargs
251     fun = name
252     if __opts__["test"] is True:
253         func_ret["comment"] = "Function {} would be executed on target {}".format(
254             fun, tgt
255         )
256         func_ret["result"] = None
257         return func_ret
258     try:
259         _fire_args({"type": "function", "tgt": tgt, "name": name, "args": cmd_kw})
260         cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
261     except Exception as exc:  # pylint: disable=broad-except
262         func_ret["result"] = False
263         func_ret["comment"] = str(exc)
264         return func_ret
265     try:
266         func_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
267     except (StopIteration, KeyError):
268         pass
269     changes = {}
270     fail = set()
271     if fail_minions is None:
272         fail_minions = ()
273     elif isinstance(fail_minions, str):
274         fail_minions = [minion.strip() for minion in fail_minions.split(",")]
275     elif not isinstance(fail_minions, list):
276         func_ret.setdefault("warnings", []).append(
277             "'fail_minions' needs to be a list or a comma separated string. Ignored."
278         )
279         fail_minions = ()
280     for minion, mdata in cmd_ret.items():
281         m_ret = False
282         if mdata.get("retcode"):
283             func_ret["result"] = False
284             fail.add(minion)
285         if mdata.get("failed", False):
286             m_func = False
287         else:
288             if "return" in mdata and "ret" not in mdata:
289                 mdata["ret"] = mdata.pop("return")
290             m_ret = mdata["ret"]
291             m_func = (not fail_function and True) or __salt__[fail_function](m_ret)
292             if m_ret is False:
293                 m_func = False
294         if not m_func:
295             if minion not in fail_minions:
296                 fail.add(minion)
297         changes[minion] = m_ret
298     if not cmd_ret:
299         func_ret["result"] = False
300         func_ret["comment"] = "No minions responded"
301     else:
302         if changes:
303             func_ret["changes"] = {"ret": changes}
304         if fail:
305             func_ret["result"] = False
306             func_ret["comment"] = "Running function {} failed on minions: {}".format(
307                 name, ", ".join(fail)
308             )
309         else:
310             func_ret["comment"] = "Function ran successfully."
311         if changes:
312             func_ret["comment"] += " Function {} ran on {}.".format(
313                 name, ", ".join(changes)
314             )
315     return func_ret
316 def wait_for_event(name, id_list, event_id="id", timeout=300, node="master"):
317     ret = {"name": name, "changes": {}, "comment": "", "result": False}
318     if __opts__.get("test"):
319         ret["comment"] = "Orchestration would wait for event '{}'".format(name)
320         ret["result"] = None
321         return ret
322     with salt.utils.event.get_event(
323         node, __opts__["sock_dir"], opts=__opts__, listen=True
324     ) as sevent:
325         del_counter = 0
326         starttime = time.time()
327         timelimit = starttime + timeout
328         while True:
329             event = sevent.get_event(full=True)
330             is_timedout = time.time() &gt; timelimit
331             if event is None and not is_timedout:
332                 log.trace("wait_for_event: No event data; waiting.")
333                 continue
334             elif event is None and is_timedout:
335                 ret["comment"] = "Timeout value reached."
336                 return ret
337             if fnmatch.fnmatch(event["tag"], name):
338                 val = event["data"].get(event_id)
339                 if val is None and "data" in event["data"]:
340                     val = event["data"]["data"].get(event_id)
341                 if val is not None:
342                     try:
343                         val_idx = id_list.index(val)
344                     except ValueError:
345                         log.trace(
346                             "wait_for_event: Event identifier '%s' not in "
347                             "id_list; skipping.",
348                             event_id,
349                         )
350                     else:
351                         del id_list[val_idx]
352                         del_counter += 1
353                         minions_seen = ret["changes"].setdefault("minions_seen", [])
354                         minions_seen.append(val)
355                         log.debug(
356                             "wait_for_event: Event identifier '%s' removed "
357                             "from id_list; %s items remaining.",
358                             val,
359                             len(id_list),
360                         )
361                 else:
362                     log.trace(
363                         "wait_for_event: Event identifier '%s' not in event "
364                         "'%s'; skipping.",
365                         event_id,
366                         event["tag"],
367                     )
368             else:
369                 log.debug("wait_for_event: Skipping unmatched event '%s'", event["tag"])
370             if len(id_list) == 0:
371                 ret["result"] = True
372                 ret["comment"] = "All events seen in {} seconds.".format(
373                     time.time() - starttime
374                 )
375                 return ret
376             if is_timedout:
377                 ret["comment"] = "Timeout value reached."
378                 return ret
379 def runner(name, **kwargs):
380     try:
381         jid = __orchestration_jid__
382     except NameError:
383         log.debug("Unable to fire args event due to missing __orchestration_jid__")
384         jid = None
385     if __opts__.get("test", False):
386         ret = {
387             "name": name,
388             "result": None,
389             "changes": {},
390             "comment": "Runner function '{}' would be executed.".format(name),
391         }
392         return ret
393     out = __salt__["saltutil.runner"](
394         name, __orchestration_jid__=jid, __env__=__env__, full_return=True, **kwargs
395     )
396     runner_return = out.get("return")
397     if isinstance(runner_return, dict) and "Error" in runner_return:
398         out["success"] = False
399     success = out.get("success", True)
400     ret = {"name": name, "changes": {"return": runner_return}, "result": success}
401     ret["comment"] = "Runner function '{}' {}.".format(
402         name,
403         "executed" if success else "failed",
404     )
405     ret["__orchestration__"] = True
406     if "jid" in out:
407         ret["__jid__"] = out["jid"]
408     return ret
409 def parallel_runners(name, runners, **kwargs):  # pylint: disable=unused-argument
410     if isinstance(runners, str):
411         runners = {runners: [{name: runners}]}
412     if not isinstance(runners, dict):
413         return {
414             "name": name,
415             "result": False,
416             "changes": {},
417             "comment": "The runners parameter must be a string or dict.",
418         }
419     for runner_id, runner_config in runners.items():
420         if runner_config is None:
421             runner_config = {}
422         else:
423             runner_config = salt.utils.data.repack_dictlist(runner_config)
424         if "name" not in runner_config:
425             runner_config["name"] = runner_id
426         runners[runner_id] = runner_config
427     try:
428         jid = __orchestration_jid__
429     except NameError:
430         log.debug("Unable to fire args event due to missing __orchestration_jid__")
431         jid = None
432     def call_runner(runner_config):
433         return __salt__["saltutil.runner"](
434             runner_config["name"],
435             __orchestration_jid__=jid,
436             __env__=__env__,
437             full_return=True,
438             **(runner_config.get("kwarg", {}))
439         )
440     try:
441         outputs = _parallel_map(call_runner, list(runners.values()))
442     except salt.exceptions.SaltException as exc:
443         return {
444             "name": name,
445             "result": False,
446             "success": False,
447             "changes": {},
448             "comment": "One of the runners raised an exception: {}".format(exc),
449         }
450     outputs = {
451         runner_id: out["return"] for runner_id, out in zip(runners.keys(), outputs)
452     }
453     highstate_output = all(
454         [
455             out.get("outputter", "") == "highstate" and "data" in out
456             for out in outputs.values()
457         ]
458     )
459     def extract_changes(obj):
460         if not isinstance(obj, dict):
461             return {}
462         elif "changes" in obj:
463             if (
464                 isinstance(obj["changes"], dict)
465                 and obj["changes"].get("out", "") == "highstate"
466                 and "ret" in obj["changes"]
467             ):
468                 return obj["changes"]["ret"]
469             else:
470                 return obj["changes"]
471         else:
472             found_changes = {}
473             for key, value in obj.items():
474                 change = extract_changes(value)
475                 if change:
476                     found_changes[key] = change
477             return found_changes
478     if highstate_output:
479         failed_runners = [
480             runner_id
481             for runner_id, out in outputs.items()
482             if out["data"].get("retcode", 0) != 0
483         ]
484         all_successful = not failed_runners
485         if all_successful:
486             comment = "All runner functions executed successfully."
487         else:
488             runner_comments = [
489                 "Runner {} failed with return value:\n{}".format(
490                     runner_id,
491                     salt.output.out_format(
492                         outputs[runner_id], "nested", __opts__, nested_indent=2
493                     ),
494                 )
495                 for runner_id in failed_runners
496             ]
497             comment = "\n".join(runner_comments)
498         changes = {}
499         for runner_id, out in outputs.items():
500             runner_changes = extract_changes(out["data"])
501             if runner_changes:
502                 changes[runner_id] = runner_changes
503     else:
504         failed_runners = [
505             runner_id
506             for runner_id, out in outputs.items()
507             if out.get("exit_code", 0) != 0
508         ]
509         all_successful = not failed_runners
510         if all_successful:
511             comment = "All runner functions executed successfully."
512         else:
513             if len(failed_runners) == 1:
514                 comment = "Runner {} failed.".format(failed_runners[0])
515             else:
516                 comment = "Runners {} failed.".format(", ".join(failed_runners))
517         changes = {"ret": {runner_id: out for runner_id, out in outputs.items()}}
518     ret = {
519         "name": name,
520         "result": all_successful,
521         "changes": changes,
522         "comment": comment,
523     }
524     return ret
525 def wheel(name, **kwargs):
526     ret = {"name": name, "result": False, "changes": {}, "comment": ""}
527     try:
528         jid = __orchestration_jid__
529     except NameError:
530         log.debug("Unable to fire args event due to missing __orchestration_jid__")
531         jid = None
532     if __opts__.get("test", False):
533         ret["result"] = (None,)
534         ret["changes"] = {}
535         ret["comment"] = "Wheel function '{}' would be executed.".format(name)
536         return ret
537     out = __salt__["saltutil.wheel"](
538         name, __orchestration_jid__=jid, __env__=__env__, **kwargs
539     )
540     wheel_return = out.get("return")
541     if isinstance(wheel_return, dict) and "Error" in wheel_return:
542         out["success"] = False
543     success = out.get("success", True)
544     ret = {"name": name, "changes": {"return": wheel_return}, "result": success}
545     ret["comment"] = "Wheel function '{}' {}.".format(
546         name,
547         "executed" if success else "failed",
548     )
549     ret["__orchestration__"] = True
550     if "jid" in out:
551         ret["__jid__"] = out["jid"]
552     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import os
3 import xml.etree.ElementTree as ET
4 import salt.utils.data
5 import salt.utils.dictupdate as dictupdate
6 import salt.utils.files
7 import salt.utils.json
8 import salt.utils.odict as odict
9 import salt.utils.stringutils
10 log = logging.getLogger(__name__)
11 __virtualname__ = "boto_iam"
12 def</b></font> __virtual__():
13     if "boto_iam.get_user" in __salt__:
14         return True
15     else:
16         return (
17             False,
18             "Cannot load {} state: boto_iam module unavailable".format(__virtualname__),
19         )
20 def user_absent(
21     name,
22     delete_keys=True,
23     delete_mfa_devices=True,
24     delete_profile=True,
25     region=None,
26     key=None,
27     keyid=None,
28     profile=None,
29 ):
30     ret = {"name": name, "result": True, "comment": "", "changes": {}}
31     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
32         ret["result"] = True
33         ret["comment"] = "IAM User {} does not exist.".format(name)
34         return ret
35     if delete_keys:
36         keys = __salt__["boto_iam.get_all_access_keys"](
37             user_name=name, region=region, key=key, keyid=keyid, profile=profile
38         )
39         log.debug("Keys for user %s are %s.", name, keys)
40         if isinstance(keys, dict):
41             keys = keys["list_access_keys_response"]["list_access_keys_result"][
42                 "access_key_metadata"
43             ]
44             for k in keys:
45                 if __opts__["test"]:
46                     ret["comment"] = " ".join(
47                         [
48                             ret["comment"],
49                             "Key {} is set to be deleted.".format(k["access_key_id"]),
50                         ]
51                     )
52                     ret["result"] = None
53                 else:
54                     if _delete_key(
55                         ret, k["access_key_id"], name, region, key, keyid, profile
56                     ):
57                         ret["comment"] = " ".join(
58                             [
59                                 ret["comment"],
60                                 "Key {} has been deleted.".format(k["access_key_id"]),
61                             ]
62                         )
63                         ret["changes"][k["access_key_id"]] = "deleted"
64     if delete_mfa_devices:
65         devices = __salt__["boto_iam.get_all_mfa_devices"](
66             user_name=name, region=region, key=key, keyid=keyid, profile=profile
67         )
68         if devices:
69             for d in devices:
70                 serial = d["serial_number"]
71                 if __opts__["test"]:
72                     ret["comment"] = " ".join(
73                         [
74                             ret["comment"],
75                             "IAM user {} MFA device {} is set to be deactivated.".format(
76                                 name, serial
77                             ),
78                         ]
79                     )
80                     ret["result"] = None
81                 else:
82                     mfa_deactivated = __salt__["boto_iam.deactivate_mfa_device"](
83                         user_name=name,
84                         serial=serial,
85                         region=region,
86                         key=key,
87                         keyid=keyid,
88                         profile=profile,
89                     )
90                     if mfa_deactivated:
91                         ret["comment"] = " ".join(
92                             [
93                                 ret["comment"],
94                                 "IAM user {} MFA device {} is deactivated.".format(
95                                     name, serial
96                                 ),
97                             ]
98                         )
99                 if __opts__["test"]:
100                     ret["comment"] = " ".join(
101                         [
102                             ret["comment"],
103                             "Virtual MFA device {} is set to be deleted.".format(
104                                 serial
105                             ),
106                         ]
107                     )
108                     ret["result"] = None
109                 else:
110                     mfa_deleted = __salt__["boto_iam.delete_virtual_mfa_device"](
111                         serial=serial,
112                         region=region,
113                         key=key,
114                         keyid=keyid,
115                         profile=profile,
116                     )
117                     if mfa_deleted:
118                         ret["comment"] = " ".join(
119                             [
120                                 ret["comment"],
121                                 "Virtual MFA device {} is deleted.".format(serial),
122                             ]
123                         )
124     if delete_profile:
125         if __opts__["test"]:
126             ret["comment"] = " ".join(
127                 [
128                     ret["comment"],
129                     "IAM user {} login profile is set to be deleted.".format(name),
130                 ]
131             )
132             ret["result"] = None
133         else:
134             profile_deleted = __salt__["boto_iam.delete_login_profile"](
135                 name, region, key, keyid, profile
136             )
137             if profile_deleted:
138                 ret["comment"] = " ".join(
139                     [
140                         ret["comment"],
141                         "IAM user {} login profile is deleted.".format(name),
142                     ]
143                 )
144     if __opts__["test"]:
145         ret["comment"] = " ".join(
146             [
147                 ret["comment"],
148                 "IAM user {} managed policies are set to be detached.".format(name),
149             ]
150         )
151         ret["result"] = None
152     else:
153         _ret = _user_policies_detached(name, region, key, keyid, profile)
154         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
155         if not _ret["result"]:
156             ret["result"] = _ret["result"]
157             if ret["result"] is False:
158                 return ret
159     if __opts__["test"]:
160         ret["comment"] = " ".join(
161             [
162                 ret["comment"],
163                 "IAM user {} inline policies are set to be deleted.".format(name),
164             ]
165         )
166         ret["result"] = None
167     else:
168         _ret = _user_policies_deleted(name, region, key, keyid, profile)
169         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
170         if not _ret["result"]:
171             ret["result"] = _ret["result"]
172             if ret["result"] is False:
173                 return ret
174     if __opts__["test"]:
175         ret["comment"] = " ".join(
176             [ret["comment"], "IAM user {} is set to be deleted.".format(name)]
177         )
178         ret["result"] = None
179         return ret
180     deleted = __salt__["boto_iam.delete_user"](name, region, key, keyid, profile)
181     if deleted is True:
182         ret["comment"] = " ".join(
183             [ret["comment"], "IAM user {} is deleted.".format(name)]
184         )
185         ret["result"] = True
186         ret["changes"]["deleted"] = name
187         return ret
188     ret["comment"] = "IAM user {} could not be deleted.\n {}".format(name, deleted)
189     ret["result"] = False
190     return ret
191 def keys_present(
192     name,
193     number,
194     save_dir,
195     region=None,
196     key=None,
197     keyid=None,
198     profile=None,
199     save_format="{2}\n{0}\n{3}\n{1}\n",
200 ):
201     ret = {"name": name, "result": True, "comment": "", "changes": {}}
202     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
203         ret["result"] = False
204         ret["comment"] = "IAM User {} does not exist.".format(name)
205         return ret
206     if not isinstance(number, int):
207         ret["comment"] = "The number of keys must be an integer."
208         ret["result"] = False
209         return ret
210     if not os.path.isdir(save_dir):
211         ret["comment"] = "The directory {} does not exist.".format(save_dir)
212         ret["result"] = False
213         return ret
214     keys = __salt__["boto_iam.get_all_access_keys"](
215         user_name=name, region=region, key=key, keyid=keyid, profile=profile
216     )
217     if isinstance(keys, str):
218         log.debug("keys are : false %s", keys)
219         error, message = _get_error(keys)
220         ret["comment"] = "Could not get keys.\n{}\n{}".format(error, message)
221         ret["result"] = False
222         return ret
223     keys = keys["list_access_keys_response"]["list_access_keys_result"][
224         "access_key_metadata"
225     ]
226     log.debug("Keys are : %s.", keys)
227     if len(keys) &gt;= number:
228         ret["comment"] = "The number of keys exist for user {}".format(name)
229         ret["result"] = True
230         return ret
231     if __opts__["test"]:
232         ret["comment"] = "Access key is set to be created for {}.".format(name)
233         ret["result"] = None
234         return ret
235     new_keys = {}
236     for i in range(number - len(keys)):
237         created = __salt__["boto_iam.create_access_key"](
238             name, region, key, keyid, profile
239         )
240         if isinstance(created, str):
241             error, message = _get_error(created)
242             ret["comment"] = "Could not create keys.\n{}\n{}".format(error, message)
243             ret["result"] = False
244             return ret
245         log.debug("Created is : %s", created)
246         response = "create_access_key_response"
247         result = "create_access_key_result"
248         new_keys[str(i)] = {}
249         new_keys[str(i)]["key_id"] = created[response][result]["access_key"][
250             "access_key_id"
251         ]
252         new_keys[str(i)]["secret_key"] = created[response][result]["access_key"][
253             "secret_access_key"
254         ]
255     try:
256         with salt.utils.files.fopen("{}/{}".format(save_dir, name), "a") as _wrf:
257             for key_num, key in new_keys.items():
258                 key_id = key["key_id"]
259                 secret_key = key["secret_key"]
260                 _wrf.write(
261                     salt.utils.stringutils.to_str(
262                         save_format.format(
263                             key_id,
264                             secret_key,
265                             "key_id-{}".format(key_num),
266                             "key-{}".format(key_num),
267                         )
268                     )
269                 )
270         ret["comment"] = "Keys have been written to file {}/{}.".format(save_dir, name)
271         ret["result"] = True
272         ret["changes"] = new_keys
273         return ret
274     except OSError:
275         ret["comment"] = "Could not write to file {}/{}.".format(save_dir, name)
276         ret["result"] = False
277         return ret
278 def keys_absent(
279     access_keys, user_name, region=None, key=None, keyid=None, profile=None
280 ):
281     ret = {"name": access_keys, "result": True, "comment": "", "changes": {}}
282     if not __salt__["boto_iam.get_user"](user_name, region, key, keyid, profile):
283         ret["result"] = False
284         ret["comment"] = "IAM User {} does not exist.".format(user_name)
285         return ret
286     for k in access_keys:
287         ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
288     return ret
289 def _delete_key(
290     ret, access_key_id, user_name, region=None, key=None, keyid=None, profile=None
291 ):
292     keys = __salt__["boto_iam.get_all_access_keys"](
293         user_name=user_name, region=region, key=key, keyid=keyid, profile=profile
294     )
295     log.debug("Keys for user %s are : %s.", keys, user_name)
296     if isinstance(keys, str):
297         log.debug("Keys %s are a string. Something went wrong.", keys)
298         ret["comment"] = " ".join(
299             [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
300         )
301         return ret
302     keys = keys["list_access_keys_response"]["list_access_keys_result"][
303         "access_key_metadata"
304     ]
305     for k in keys:
306         log.debug(
307             "Key is: %s and is compared with: %s", k["access_key_id"], access_key_id
308         )
309         if str(k["access_key_id"]) == str(access_key_id):
310             if __opts__["test"]:
311                 ret["comment"] = "Access key {} is set to be deleted.".format(
312                     access_key_id
313                 )
314                 ret["result"] = None
315                 return ret
316             deleted = __salt__["boto_iam.delete_access_key"](
317                 access_key_id, user_name, region, key, keyid, profile
318             )
319             if deleted:
320                 ret["comment"] = " ".join(
321                     [ret["comment"], "Key {} has been deleted.".format(access_key_id)]
322                 )
323                 ret["changes"][access_key_id] = "deleted"
324                 return ret
325             ret["comment"] = " ".join(
326                 [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
327             )
328             return ret
329         ret["comment"] = " ".join([ret["comment"], "Key {} does not exist.".format(k)])
330         return ret
331 def user_present(
332     name,
333     policies=None,
334     policies_from_pillars=None,
335     managed_policies=None,
336     password=None,
337     path=None,
338     region=None,
339     key=None,
340     keyid=None,
341     profile=None,
342 ):
343     ret = {"name": name, "result": True, "comment": "", "changes": {}}
344     if not policies:
345         policies = {}
346     if not policies_from_pillars:
347         policies_from_pillars = []
348     if not managed_policies:
349         managed_policies = []
350     _policies = {}
351     for policy in policies_from_pillars:
352         _policy = __salt__["pillar.get"](policy)
353         _policies.update(_policy)
354     _policies.update(policies)
355     exists = __salt__["boto_iam.get_user"](name, region, key, keyid, profile)
356     if not exists:
357         if __opts__["test"]:
358             ret["comment"] = "IAM user {} is set to be created.".format(name)
359             ret["result"] = None
360             return ret
361         created = __salt__["boto_iam.create_user"](
362             name, path, region, key, keyid, profile
363         )
364         if created:
365             ret["changes"]["user"] = created
366             ret["comment"] = " ".join(
367                 [ret["comment"], "User {} has been created.".format(name)]
368             )
369             if password:
370                 ret = _case_password(ret, name, password, region, key, keyid, profile)
371             _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
372             ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
373             ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
374     else:
375         ret["comment"] = " ".join([ret["comment"], "User {} is present.".format(name)])
376         if password:
377             ret = _case_password(ret, name, password, region, key, keyid, profile)
378         _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
379         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
380         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
381     _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
382     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
383     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
384     if not _ret["result"]:
385         ret["result"] = _ret["result"]
386         return ret
387     return ret
388 def _user_policies_present(
389     name, policies=None, region=None, key=None, keyid=None, profile=None
390 ):
391     ret = {"result": True, "comment": "", "changes": {}}
392     policies_to_create = {}
393     policies_to_delete = []
394     for policy_name, policy in policies.items():
395         if isinstance(policy, str):
396             dict_policy = salt.utils.json.loads(
397                 policy, object_pairs_hook=odict.OrderedDict
398             )
399         else:
400             dict_policy = policy
401         _policy = __salt__["boto_iam.get_user_policy"](
402             name, policy_name, region, key, keyid, profile
403         )
404         if _policy != dict_policy:
405             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
406             policies_to_create[policy_name] = policy
407     _list = __salt__["boto_iam.get_all_user_policies"](
408         user_name=name, region=region, key=key, keyid=keyid, profile=profile
409     )
410     for policy_name in _list:
411         if policy_name not in policies:
412             policies_to_delete.append(policy_name)
413     if policies_to_create or policies_to_delete:
414         _to_modify = list(policies_to_delete)
415         _to_modify.extend(policies_to_create)
416         if __opts__["test"]:
417             ret["comment"] = "{} policies to be modified on user {}.".format(
418                 ", ".join(_to_modify), name
419             )
420             ret["result"] = None
421             return ret
422         ret["changes"]["old"] = {"policies": _list}
423         for policy_name, policy in policies_to_create.items():
424             policy_set = __salt__["boto_iam.put_user_policy"](
425                 name, policy_name, policy, region, key, keyid, profile
426             )
427             if not policy_set:
428                 _list = __salt__["boto_iam.get_all_user_policies"](
429                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
430                 )
431                 ret["changes"]["new"] = {"policies": _list}
432                 ret["result"] = False
433                 ret["comment"] = "Failed to add policy {} for user {}".format(
434                     policy_name, name
435                 )
436                 return ret
437         for policy_name in policies_to_delete:
438             policy_unset = __salt__["boto_iam.delete_user_policy"](
439                 name, policy_name, region, key, keyid, profile
440             )
441             if not policy_unset:
442                 _list = __salt__["boto_iam.get_all_user_policies"](
443                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
444                 )
445                 ret["changes"]["new"] = {"policies": _list}
446                 ret["result"] = False
447                 ret["comment"] = "Failed to add policy {} to user {}".format(
448                     policy_name, name
449                 )
450                 return ret
451         _list = __salt__["boto_iam.get_all_user_policies"](
452             user_name=name, region=region, key=key, keyid=keyid, profile=profile
453         )
454         ret["changes"]["new"] = {"policies": _list}
455         ret["comment"] = "{} policies modified on user {}.".format(
456             ", ".join(_list), name
457         )
458     return ret
459 def _user_policies_attached(
460     name, managed_policies=None, region=None, key=None, keyid=None, profile=None
461 ):
462     ret = {"result": True, "comment": "", "changes": {}}
463     policies_to_attach = []
464     policies_to_detach = []
465     for policy in managed_policies or []:
466         entities = __salt__["boto_iam.list_entities_for_policy"](
467             policy,
468             entity_filter="User",
469             region=region,
470             key=key,
471             keyid=keyid,
472             profile=profile,
473         )
474         found = False
475         for userdict in entities.get("policy_users", []):
476             if name == userdict.get("user_name"):
477                 found = True
478                 break
479         if not found:
480             policies_to_attach.append(policy)
481     _list = __salt__["boto_iam.list_attached_user_policies"](
482         name, region=region, key=key, keyid=keyid, profile=profile
483     )
484     oldpolicies = [x.get("policy_arn") for x in _list]
485     for policy_data in _list:
486         if (
487             policy_data.get("policy_name") not in managed_policies
488             and policy_data.get("policy_arn") not in managed_policies
489         ):
490             policies_to_detach.append(policy_data.get("policy_arn"))
491     if policies_to_attach or policies_to_detach:
492         _to_modify = list(policies_to_detach)
493         _to_modify.extend(policies_to_attach)
494         if __opts__["test"]:
495             ret["comment"] = "{} policies to be modified on user {}.".format(
496                 ", ".join(_to_modify), name
497             )
498             ret["result"] = None
499             return ret
500         ret["changes"]["old"] = {"managed_policies": oldpolicies}
501         for policy_name in policies_to_attach:
502             policy_set = __salt__["boto_iam.attach_user_policy"](
503                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
504             )
505             if not policy_set:
506                 _list = __salt__["boto_iam.list_attached_user_policies"](
507                     name, region=region, key=key, keyid=keyid, profile=profile
508                 )
509                 newpolicies = [x.get("policy_arn") for x in _list]
510                 ret["changes"]["new"] = {"managed_policies": newpolicies}
511                 ret["result"] = False
512                 ret["comment"] = "Failed to add policy {} to user {}".format(
513                     policy_name, name
514                 )
515                 return ret
516         for policy_name in policies_to_detach:
517             policy_unset = __salt__["boto_iam.detach_user_policy"](
518                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
519             )
520             if not policy_unset:
521                 _list = __salt__["boto_iam.list_attached_user_policies"](
522                     name, region=region, key=key, keyid=keyid, profile=profile
523                 )
524                 newpolicies = [x.get("policy_arn") for x in _list]
525                 ret["changes"]["new"] = {"managed_policies": newpolicies}
526                 ret["result"] = False
527                 ret["comment"] = "Failed to remove policy {} from user {}".format(
528                     policy_name, name
529                 )
530                 return ret
531         _list = __salt__["boto_iam.list_attached_user_policies"](
532             name, region=region, key=key, keyid=keyid, profile=profile
533         )
534         newpolicies = [x.get("policy_arn") for x in _list]
535         log.debug(newpolicies)
536         ret["changes"]["new"] = {"managed_policies": newpolicies}
537         ret["comment"] = "{} policies modified on user {}.".format(
538             ", ".join(newpolicies), name
539         )
540     return ret
541 def _user_policies_detached(name, region=None, key=None, keyid=None, profile=None):
542     ret = {"result": True, "comment": "", "changes": {}}
543     _list = __salt__["boto_iam.list_attached_user_policies"](
544         user_name=name, region=region, key=key, keyid=keyid, profile=profile
545     )
546     oldpolicies = [x.get("policy_arn") for x in _list]
547     if not _list:
548         ret["comment"] = "No attached policies in user {}.".format(name)
549         return ret
550     if __opts__["test"]:
551         ret["comment"] = "{} policies to be detached from user {}.".format(
552             ", ".join(oldpolicies), name
553         )
554         ret["result"] = None
555         return ret
556     ret["changes"]["old"] = {"managed_policies": oldpolicies}
557     for policy_arn in oldpolicies:
558         policy_unset = __salt__["boto_iam.detach_user_policy"](
559             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
560         )
561         if not policy_unset:
562             _list = __salt__["boto_iam.list_attached_user_policies"](
563                 name, region=region, key=key, keyid=keyid, profile=profile
564             )
565             newpolicies = [x.get("policy_arn") for x in _list]
566             ret["changes"]["new"] = {"managed_policies": newpolicies}
567             ret["result"] = False
568             ret["comment"] = "Failed to detach {} from user {}".format(policy_arn, name)
569             return ret
570     _list = __salt__["boto_iam.list_attached_user_policies"](
571         name, region=region, key=key, keyid=keyid, profile=profile
572     )
573     newpolicies = [x.get("policy_arn") for x in _list]
574     ret["changes"]["new"] = {"managed_policies": newpolicies}
575     ret["comment"] = "{} policies detached from user {}.".format(
576         ", ".join(oldpolicies), name
577     )
578     return ret
579 def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
580     ret = {"result": True, "comment": "", "changes": {}}
581     oldpolicies = __salt__["boto_iam.get_all_user_policies"](
582         user_name=name, region=region, key=key, keyid=keyid, profile=profile
583     )
584     if not oldpolicies:
585         ret["comment"] = "No inline policies in user {}.".format(name)
586         return ret
587     if __opts__["test"]:
588         ret["comment"] = "{} policies to be deleted from user {}.".format(
589             ", ".join(oldpolicies), name
590         )
591         ret["result"] = None
592         return ret
593     ret["changes"]["old"] = {"inline_policies": oldpolicies}
594     for policy_name in oldpolicies:
595         policy_deleted = __salt__["boto_iam.delete_user_policy"](
596             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
597         )
598         if not policy_deleted:
599             newpolicies = __salt__["boto_iam.get_all_user_policies"](
600                 name, region=region, key=key, keyid=keyid, profile=profile
601             )
602             ret["changes"]["new"] = {"inline_policies": newpolicies}
603             ret["result"] = False
604             ret["comment"] = "Failed to detach {} from user {}".format(
605                 policy_name, name
606             )
607             return ret
608     newpolicies = __salt__["boto_iam.get_all_user_policies"](
609         name, region=region, key=key, keyid=keyid, profile=profile
610     )
611     ret["changes"]["new"] = {"inline_policies": newpolicies}
612     ret["comment"] = "{} policies deleted from user {}.".format(
613         ", ".join(oldpolicies), name
614     )
615     return ret
616 def _case_password(
617     ret, name, password, region=None, key=None, keyid=None, profile=None
618 ):
619     if __opts__["test"]:
620         ret["comment"] = "Login policy for {} is set to be changed.".format(name)
621         ret["result"] = None
622         return ret
623     login = __salt__["boto_iam.create_login_profile"](
624         name, password, region, key, keyid, profile
625     )
626     log.debug("Login is : %s.", login)
627     if login:
628         if "Conflict" in login:
629             ret["comment"] = " ".join(
630                 [ret["comment"], "Login profile for user {} exists.".format(name)]
631             )
632         else:
633             ret["comment"] = " ".join(
634                 [ret["comment"], "Password has been added to User {}.".format(name)]
635             )
636             ret["changes"]["password"] = "REDACTED"
637     else:
638         ret["result"] = False
639         ret["comment"] = " ".join(
640             [
641                 ret["comment"],
642                 "Password for user {} could not be set.\nPlease check your password"
643                 " policy.".format(name),
644             ]
645         )
646     return ret
647 def group_absent(name, region=None, key=None, keyid=None, profile=None):
648     ret = {"name": name, "result": True, "comment": "", "changes": {}}
649     if not __salt__["boto_iam.get_group"](name, region, key, keyid, profile):
650         ret["result"] = True
651         ret["comment"] = "IAM Group {} does not exist.".format(name)
652         return ret
653     if __opts__["test"]:
654         ret["comment"] = " ".join(
655             [
656                 ret["comment"],
657                 "IAM group {} managed policies are set to be detached.".format(name),
658             ]
659         )
660         ret["result"] = None
661     else:
662         _ret = _group_policies_detached(name, region, key, keyid, profile)
663         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
664         if not _ret["result"]:
665             ret["result"] = _ret["result"]
666             if ret["result"] is False:
667                 return ret
668     if __opts__["test"]:
669         ret["comment"] = " ".join(
670             [
671                 ret["comment"],
672                 "IAM group {} inline policies are set to be deleted.".format(name),
673             ]
674         )
675         ret["result"] = None
676     else:
677         _ret = _group_policies_deleted(name, region, key, keyid, profile)
678         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
679         if not _ret["result"]:
680             ret["result"] = _ret["result"]
681             if ret["result"] is False:
682                 return ret
683     ret["comment"] = " ".join(
684         [ret["comment"], "IAM group {} users are set to be removed.".format(name)]
685     )
686     existing_users = __salt__["boto_iam.get_group_members"](
687         group_name=name, region=region, key=key, keyid=keyid, profile=profile
688     )
689     _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
690     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
691     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
692     if not _ret["result"]:
693         ret["result"] = _ret["result"]
694         return ret
695     if __opts__["test"]:
696         ret["comment"] = " ".join(
697             [ret["comment"], "IAM group {} is set to be deleted.".format(name)]
698         )
699         ret["result"] = None
700         return ret
701     deleted = __salt__["boto_iam.delete_group"](name, region, key, keyid, profile)
702     if deleted is True:
703         ret["comment"] = " ".join(
704             [ret["comment"], "IAM group {} is deleted.".format(name)]
705         )
706         ret["result"] = True
707         ret["changes"]["deleted"] = name
708         return ret
709     ret["comment"] = "IAM group {} could not be deleted.\n {}".format(name, deleted)
710     ret["result"] = False
711     return ret
712 <a name="1"></a>
713 def group_present(
714     name,
715     policies<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
716     policies_from_pillars=None,
717     managed_policies=None,
718     users=None,
719     path="/",
720     region=None,
721     key=None,
722     keyid=None,
723     profile=None,
724     delete_policies=True,
725 ):
726     ret = {"name": name, "result": True, "comment": "", "changes": {}}
727     if not policies:
728         policies = {}
729     if</b></font> not policies_from_pillars:
730         policies_from_pillars = []
731     if not managed_policies:
732         managed_policies = []
733     _policies = {}
734     for policy in policies_from_pillars:
735         _policy = __salt__["pillar.get"](policy)
736         _policies.update(_policy)
737     _policies.update(policies)
738     exists = __salt__["boto_iam.get_group"](
739         group_name=name, region=region, key=key, keyid=keyid, profile=profile
740     )
741     if not exists:
742         if __opts__["test"]:
743             ret["comment"] = "IAM group {} is set to be created.".format(name)
744             ret["result"] = None
745             return ret
746         created = __salt__["boto_iam.create_group"](
747             group_name=name,
748             path=path,
749             region=region,
750             key=key,
751             keyid=keyid,
752             profile=profile,
753         )
754         if not created:
755             ret["comment"] = "Failed to create IAM group {}.".format(name)
756             ret["result"] = False
757             return ret
758         ret["changes"]["group"] = created
759         ret["comment"] = " ".join(
760             [ret["comment"], "Group {} has been created.".format(name)]
761         )
762     else:
763         ret["comment"] = " ".join([ret["comment"], "Group {} is present.".format(name)])
764     _ret = _group_policies_present(
765         name, _policies, region, key, keyid, profile, delete_policies
766     )
767     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
768     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
769     if not _ret["result"]:
770         ret["result"] = _ret["result"]
771         return ret
772     _ret = _group_policies_attached(
773         name, managed_policies, region, key, keyid, profile, delete_policies
774     )
775     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
776     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
777     if not _ret["result"]:
778         ret["result"] = _ret["result"]
779         return ret
780     if users is not None:
781         log.debug("Users are : %s.", users)
782         existing_users = __salt__["boto_iam.get_group_members"](
783             group_name=name, region=region, key=key, keyid=keyid, profile=profile
784         )
785         ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
786     return ret
787 def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
788     _users = []
789     for user in existing_users:
790         _users.append(user["user_name"])
791     log.debug("upstream users are %s", _users)
792     for user in users:
793         log.debug("users are %s", user)
794         if user in _users:
795             log.debug("user exists")
796             ret["comment"] = " ".join(
797                 [
798                     ret["comment"],
799                     "User {} is already a member of group {}.".format(user, group_name),
800                 ]
801             )
802             continue
803         else:
804             log.debug("user is set to be added %s", user)
805             if __opts__["test"]:
806                 ret["comment"] = "User {} is set to be added to group {}.".format(
807                     user, group_name
808                 )
809                 ret["result"] = None
810             else:
811                 __salt__["boto_iam.add_user_to_group"](
812                     user, group_name, region, key, keyid, profile
813                 )
814                 ret["comment"] = " ".join(
815                     [
816                         ret["comment"],
817                         "User {} has been added to group {}.".format(user, group_name),
818                     ]
819                 )
820                 ret["changes"][user] = group_name
821     for user in _users:
822         if user not in users:
823             if __opts__["test"]:
824                 ret["comment"] = " ".join(
825                     [
826                         ret["comment"],
827                         "User {} is set to be removed from group {}.".format(
828                             user, group_name
829                         ),
830                     ]
831                 )
832                 ret["result"] = None
833             else:
834                 __salt__["boto_iam.remove_user_from_group"](
835                     group_name=group_name,
836                     user_name=user,
837                     region=region,
838                     key=key,
839                     keyid=keyid,
840                     profile=profile,
841                 )
842                 ret["comment"] = " ".join(
843                     [
844                         ret["comment"],
845                         "User {} has been removed from group {}.".format(
846                             user, group_name
847                         ),
848                     ]
849                 )
850                 ret["changes"][user] = "Removed from group {}.".format(group_name)
851     return ret
852 def _group_policies_present(
853     name,
854     policies=None,
855     region=None,
856     key=None,
857     keyid=None,
858     profile=None,
859     delete_policies=True,
860 ):
861     ret = {"result": True, "comment": "", "changes": {}}
862     policies_to_create = {}
863     policies_to_delete = []
864     for policy_name, policy in policies.items():
865         if isinstance(policy, str):
866             dict_policy = salt.utils.json.loads(
867                 policy, object_pairs_hook=odict.OrderedDict
868             )
869         else:
870             dict_policy = policy
871         _policy = __salt__["boto_iam.get_group_policy"](
872             name, policy_name, region, key, keyid, profile
873         )
874         if _policy != dict_policy:
875             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
876             policies_to_create[policy_name] = policy
877     _list = __salt__["boto_iam.get_all_group_policies"](
878         name, region, key, keyid, profile
879     )
880     for policy_name in _list:
881         if delete_policies and policy_name not in policies:
882             policies_to_delete.append(policy_name)
883     if policies_to_create or policies_to_delete:
884         _to_modify = list(policies_to_delete)
885         _to_modify.extend(policies_to_create)
886         if __opts__["test"]:
887             ret["comment"] = "{} policies to be modified on group {}.".format(
888                 ", ".join(_to_modify), name
889             )
890             ret["result"] = None
891             return ret
892         ret["changes"]["old"] = {"policies": _list}
893         for policy_name, policy in policies_to_create.items():
894             policy_set = __salt__["boto_iam.put_group_policy"](
895                 name, policy_name, policy, region, key, keyid, profile
896             )
897             if not policy_set:
898                 _list = __salt__["boto_iam.get_all_group_policies"](
899                     name, region, key, keyid, profile
900                 )
901                 ret["changes"]["new"] = {"policies": _list}
902                 ret["result"] = False
903                 ret["comment"] = "Failed to add policy {} to group {}".format(
904                     policy_name, name
905                 )
906                 return ret
907         for policy_name in policies_to_delete:
908             policy_unset = __salt__["boto_iam.delete_group_policy"](
909                 name, policy_name, region, key, keyid, profile
910             )
911             if not policy_unset:
912                 _list = __salt__["boto_iam.get_all_group_policies"](
913                     name, region, key, keyid, profile
914                 )
915                 ret["changes"]["new"] = {"policies": _list}
916                 ret["result"] = False
917                 ret["comment"] = "Failed to add policy {} to group {}".format(
918                     policy_name, name
919                 )
920                 return ret
921         _list = __salt__["boto_iam.get_all_group_policies"](
922             name, region, key, keyid, profile
923         )
924         ret["changes"]["new"] = {"policies": _list}
925         ret["comment"] = "{} policies modified on group {}.".format(
926             ", ".join(_list), name
927         )
928     return ret
929 def _group_policies_attached(
930     name,
931     managed_policies=None,
932     region=None,
933     key=None,
934     keyid=None,
935     profile=None,
936     detach_policies=True,
937 ):
938     ret = {"result": True, "comment": "", "changes": {}}
939     policies_to_attach = []
940     policies_to_detach = []
941     for policy in managed_policies or []:
942         entities = __salt__["boto_iam.list_entities_for_policy"](
943             policy,
944             entity_filter="Group",
945             region=region,
946             key=key,
947             keyid=keyid,
948             profile=profile,
949         )
950         found = False
951         for groupdict in entities.get("policy_groups", []):
952             if name == groupdict.get("group_name"):
953                 found = True
954                 break
955         if not found:
956             policies_to_attach.append(policy)
957     _list = __salt__["boto_iam.list_attached_group_policies"](
958         name, region=region, key=key, keyid=keyid, profile=profile
959     )
960     oldpolicies = [x.get("policy_arn") for x in _list]
961     for policy_data in _list:
962         if (
963             detach_policies
964             and policy_data.get("policy_name") not in managed_policies
965             and policy_data.get("policy_arn") not in managed_policies
966         ):
967             policies_to_detach.append(policy_data.get("policy_arn"))
968     if policies_to_attach or policies_to_detach:
969         _to_modify = list(policies_to_detach)
970         _to_modify.extend(policies_to_attach)
971         if __opts__["test"]:
972             ret["comment"] = "{} policies to be modified on group {}.".format(
973                 ", ".join(_to_modify), name
974             )
975             ret["result"] = None
976             return ret
977         ret["changes"]["old"] = {"managed_policies": oldpolicies}
978         for policy_name in policies_to_attach:
979             policy_set = __salt__["boto_iam.attach_group_policy"](
980                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
981             )
982             if not policy_set:
983                 _list = __salt__["boto_iam.list_attached_group_policies"](
984                     name, region=region, key=key, keyid=keyid, profile=profile
985                 )
986                 newpolicies = [x.get("policy_arn") for x in _list]
987                 ret["changes"]["new"] = {"managed_policies": newpolicies}
988                 ret["result"] = False
989                 ret["comment"] = "Failed to add policy {} to group {}".format(
990                     policy_name, name
991                 )
992                 return ret
993         for policy_name in policies_to_detach:
994             policy_unset = __salt__["boto_iam.detach_group_policy"](
995                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
996             )
997             if not policy_unset:
998                 _list = __salt__["boto_iam.list_attached_group_policies"](
999                     name, region=region, key=key, keyid=keyid, profile=profile
1000                 )
1001                 newpolicies = [x.get("policy_arn") for x in _list]
1002                 ret["changes"]["new"] = {"managed_policies": newpolicies}
1003                 ret["result"] = False
1004                 ret["comment"] = "Failed to remove policy {} from group {}".format(
1005                     policy_name, name
1006                 )
1007                 return ret
1008         _list = __salt__["boto_iam.list_attached_group_policies"](
1009             name, region=region, key=key, keyid=keyid, profile=profile
1010         )
1011         newpolicies = [x.get("policy_arn") for x in _list]
1012         log.debug(newpolicies)
1013         ret["changes"]["new"] = {"managed_policies": newpolicies}
1014         ret["comment"] = "{} policies modified on group {}.".format(
1015             ", ".join(newpolicies), name
1016         )
1017     return ret
1018 def _group_policies_detached(name, region=None, key=None, keyid=None, profile=None):
1019     ret = {"result": True, "comment": "", "changes": {}}
1020     _list = __salt__["boto_iam.list_attached_group_policies"](
1021         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1022     )
1023     oldpolicies = [x.get("policy_arn") for x in _list]
1024     if not _list:
1025         ret["comment"] = "No attached policies in group {}.".format(name)
1026         return ret
1027     if __opts__["test"]:
1028         ret["comment"] = "{} policies to be detached from group {}.".format(
1029             ", ".join(oldpolicies), name
1030         )
1031         ret["result"] = None
1032         return ret
1033     ret["changes"]["old"] = {"managed_policies": oldpolicies}
1034     for policy_arn in oldpolicies:
1035         policy_unset = __salt__["boto_iam.detach_group_policy"](
1036             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
1037         )
1038         if not policy_unset:
1039             _list = __salt__["boto_iam.list_attached_group_policies"](
1040                 name, region=region, key=key, keyid=keyid, profile=profile
1041             )
1042             newpolicies = [x.get("policy_arn") for x in _list]
1043             ret["changes"]["new"] = {"managed_policies": newpolicies}
1044             ret["result"] = False
1045             ret["comment"] = "Failed to detach {} from group {}".format(
1046                 policy_arn, name
1047             )
1048             return ret
1049     _list = __salt__["boto_iam.list_attached_group_policies"](
1050         name, region=region, key=key, keyid=keyid, profile=profile
1051     )
1052     newpolicies = [x.get("policy_arn") for x in _list]
1053     ret["changes"]["new"] = {"managed_policies": newpolicies}
1054     ret["comment"] = "{} policies detached from group {}.".format(
1055         ", ".join(newpolicies), name
1056     )
1057     return ret
1058 def _group_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
1059     ret = {"result": True, "comment": "", "changes": {}}
1060     oldpolicies = __salt__["boto_iam.get_all_group_policies"](
1061         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1062     )
1063     if not oldpolicies:
1064         ret["comment"] = "No inline policies in group {}.".format(name)
1065         return ret
1066     if __opts__["test"]:
1067         ret["comment"] = "{} policies to be deleted from group {}.".format(
1068             ", ".join(oldpolicies), name
1069         )
1070         ret["result"] = None
1071         return ret
1072     ret["changes"]["old"] = {"inline_policies": oldpolicies}
1073     for policy_name in oldpolicies:
1074         policy_deleted = __salt__["boto_iam.delete_group_policy"](
1075             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
1076         )
1077         if not policy_deleted:
1078             newpolicies = __salt__["boto_iam.get_all_group_policies"](
1079                 name, region=region, key=key, keyid=keyid, profile=profile
1080             )
1081             ret["changes"]["new"] = {"inline_policies": newpolicies}
1082             ret["result"] = False
1083             ret["comment"] = "Failed to detach {} from group {}".format(
1084                 policy_name, name
1085             )
1086             return ret
1087     newpolicies = __salt__["boto_iam.get_all_group_policies"](
1088         name, region=region, key=key, keyid=keyid, profile=profile
1089     )
1090     ret["changes"]["new"] = {"inline_policies": newpolicies}
1091 <a name="0"></a>    ret["comment"] = "{} policies deleted from group {}.".format(
1092         ", ".join(oldpolicies), name
1093     )
1094     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
1095 def account_policy(
1096     name=None,
1097     allow_users_to_change_password=None,
1098     hard_expiry=None,
1099     max_password_age=None,
1100     minimum_password_length=None,
1101     password_reuse_prevention=None,
1102     require_lowercase_characters=None,
1103     require_numbers=None,
1104     require_symbols=None,
1105     require_uppercase_characters=None,
1106     region=None,
1107     key=None,
1108     keyid=None,
1109     profile=None,
1110 ):
1111 <a name="3"></a>    config =</b></font> locals()
1112     ret = {"name": "Account Policy", "result": True, "comment": "", "changes": {}}
1113     info = __salt__["boto_iam.get_account_policy"](region, key, keyid, profile)
1114     <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not info:
1115         ret["comment"] = "Account policy is not Enabled."
1116         ret["result"] = False
1117         return ret
1118     for key, value in config.items():
1119         if key in ("region"</b></font>, "key", "keyid", "profile", "name"):
1120             continue
1121         if value is not None and str(info[key]) != str(value).lower():
1122             ret["comment"] = " ".join(
1123                 [
1124                     ret["comment"],
1125                     "Policy value {} has been set to {}.".format(value, info[key]),
1126                 ]
1127             )
1128             ret["changes"][key] = str(value).lower()
1129     if not ret["changes"]:
1130         ret["comment"] = "Account policy is not changed."
1131         return ret
1132     if __opts__["test"]:
1133         ret["comment"] = "Account policy is set to be changed."
1134         ret["result"] = None
1135         return ret
1136     if __salt__["boto_iam.update_account_password_policy"](
1137         allow_users_to_change_password,
1138         hard_expiry,
1139         max_password_age,
1140         minimum_password_length,
1141         password_reuse_prevention,
1142         require_lowercase_characters,
1143         require_numbers,
1144         require_symbols,
1145         require_uppercase_characters,
1146         region,
1147         key,
1148         keyid,
1149         profile,
1150     ):
1151         return ret
1152     ret["comment"] = "Account policy is not changed."
1153     ret["changes"] = {}
1154     ret["result"] = False
1155     return ret
1156 def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
1157     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1158     exists = __salt__["boto_iam.get_server_certificate"](
1159         name, region, key, keyid, profile
1160     )
1161     if not exists:
1162         ret["comment"] = "Certificate {} does not exist.".format(name)
1163         return ret
1164     if __opts__["test"]:
1165         ret["comment"] = "Server certificate {} is set to be deleted.".format(name)
1166         ret["result"] = None
1167         return ret
1168     deleted = __salt__["boto_iam.delete_server_cert"](name, region, key, keyid, profile)
1169     if not deleted:
1170         ret["result"] = False
1171         ret["comment"] = "Certificate {} failed to be deleted.".format(name)
1172         return ret
1173     ret["comment"] = "Certificate {} was deleted.".format(name)
1174     ret["changes"] = deleted
1175     return ret
1176 def server_cert_present(
1177     name,
1178     public_key,
1179     private_key,
1180     cert_chain=None,
1181     path=None,
1182     region=None,
1183     key=None,
1184     keyid=None,
1185     profile=None,
1186 ):
1187     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1188     exists = __salt__["boto_iam.get_server_certificate"](
1189         name, region, key, keyid, profile
1190     )
1191     log.debug("Variables are : %s.", locals())
1192     if exists:
1193         ret["comment"] = "Certificate {} exists.".format(name)
1194         return ret
1195     if "salt://" in public_key:
1196         try:
1197             public_key = __salt__["cp.get_file_str"](public_key)
1198         except OSError as e:
1199             log.debug(e)
1200             ret["comment"] = "File {} not found.".format(public_key)
1201             ret["result"] = False
1202             return ret
1203     if "salt://" in private_key:
1204         try:
1205             private_key = __salt__["cp.get_file_str"](private_key)
1206         except OSError as e:
1207             log.debug(e)
1208             ret["comment"] = "File {} not found.".format(private_key)
1209             ret["result"] = False
1210             return ret
1211     if cert_chain is not None and "salt://" in cert_chain:
1212         try:
1213             cert_chain = __salt__["cp.get_file_str"](cert_chain)
1214         except OSError as e:
1215             log.debug(e)
1216             ret["comment"] = "File {} not found.".format(cert_chain)
1217             ret["result"] = False
1218             return ret
1219     if __opts__["test"]:
1220         ret["comment"] = "Server certificate {} is set to be created.".format(name)
1221         ret["result"] = None
1222         return ret
1223     created = __salt__["boto_iam.upload_server_cert"](
1224         name, public_key, private_key, cert_chain, path, region, key, keyid, profile
1225     )
1226     if created is not False:
1227         ret["comment"] = "Certificate {} was created.".format(name)
1228         ret["changes"] = created
1229         return ret
1230     ret["result"] = False
1231     ret["comment"] = "Certificate {} failed to be created.".format(name)
1232     return ret
1233 def policy_present(
1234     name,
1235     policy_document,
1236     path=None,
1237     description=None,
1238     region=None,
1239     key=None,
1240     keyid=None,
1241     profile=None,
1242 ):
1243     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1244     policy = __salt__["boto_iam.get_policy"](name, region, key, keyid, profile)
1245     if not policy:
1246         if __opts__["test"]:
1247             ret["comment"] = "IAM policy {} is set to be created.".format(name)
1248             ret["result"] = None
1249             return ret
1250         created = __salt__["boto_iam.create_policy"](
1251             name, policy_document, path, description, region, key, keyid, profile
1252         )
1253         if created:
1254             ret["changes"]["policy"] = created
1255             ret["comment"] = " ".join(
1256                 [ret["comment"], "Policy {} has been created.".format(name)]
1257             )
1258         else:
1259             ret["result"] = False
1260             ret["comment"] = "Failed to update policy."
1261             ret["changes"] = {}
1262             return ret
1263     else:
1264         policy = policy.get("policy", {})
1265         ret["comment"] = " ".join(
1266             [ret["comment"], "Policy {} is present.".format(name)]
1267         )
1268         _describe = __salt__["boto_iam.get_policy_version"](
1269             name, policy.get("default_version_id"), region, key, keyid, profile
1270         ).get("policy_version", {})
1271         if isinstance(_describe["document"], str):
1272             describeDict = salt.utils.json.loads(_describe["document"])
1273         else:
1274             describeDict = _describe["document"]
1275         if isinstance(policy_document, str):
1276             policy_document = salt.utils.json.loads(policy_document)
1277         r = salt.utils.data.compare_dicts(describeDict, policy_document)
1278         if bool(r):
1279             if __opts__["test"]:
1280                 ret["comment"] = "Policy {} set to be modified.".format(name)
1281                 ret["result"] = None
1282                 return ret
1283             ret["comment"] = " ".join([ret["comment"], "Policy to be modified"])
1284             policy_document = salt.utils.json.dumps(policy_document)
1285             r = __salt__["boto_iam.create_policy_version"](
1286                 policy_name=name,
1287                 policy_document=policy_document,
1288                 set_as_default=True,
1289                 region=region,
1290                 key=key,
1291                 keyid=keyid,
1292                 profile=profile,
1293             )
1294             if not r.get("created"):
1295                 ret["result"] = False
1296                 ret["comment"] = "Failed to update policy: {}.".format(
1297                     r["error"]["message"]
1298                 )
1299                 ret["changes"] = {}
1300                 return ret
1301             __salt__["boto_iam.delete_policy_version"](
1302                 policy_name=name,
1303                 version_id=policy["default_version_id"],
1304                 region=region,
1305                 key=key,
1306                 keyid=keyid,
1307                 profile=profile,
1308             )
1309             ret["changes"].setdefault("new", {})["document"] = policy_document
1310             ret["changes"].setdefault("old", {})["document"] = _describe["document"]
1311     return ret
1312 def policy_absent(name, region=None, key=None, keyid=None, profile=None):
1313     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1314     r = __salt__["boto_iam.policy_exists"](
1315         name, region=region, key=key, keyid=keyid, profile=profile
1316     )
1317     if not r:
1318         ret["comment"] = "Policy {} does not exist.".format(name)
1319         return ret
1320     if __opts__["test"]:
1321         ret["comment"] = "Policy {} is set to be removed.".format(name)
1322         ret["result"] = None
1323         return ret
1324     versions = __salt__["boto_iam.list_policy_versions"](
1325         name, region=region, key=key, keyid=keyid, profile=profile
1326     )
1327     if versions:
1328         for version in versions:
1329             if version.get("is_default_version", False) in ("true", True):
1330                 continue
1331             r = __salt__["boto_iam.delete_policy_version"](
1332                 name,
1333                 version_id=version.get("version_id"),
1334                 region=region,
1335                 key=key,
1336                 keyid=keyid,
1337                 profile=profile,
1338             )
1339             if not r:
1340                 ret["result"] = False
1341                 ret["comment"] = "Failed to delete policy {}.".format(name)
1342                 return ret
1343     r = __salt__["boto_iam.delete_policy"](
1344         name, region=region, key=key, keyid=keyid, profile=profile
1345     )
1346     if not r:
1347         ret["result"] = False
1348         ret["comment"] = "Failed to delete policy {}.".format(name)
1349         return ret
1350     ret["changes"]["old"] = {"policy": name}
1351     ret["changes"]["new"] = {"policy": None}
1352     ret["comment"] = "Policy {} deleted.".format(name)
1353     return ret
1354 def saml_provider_present(
1355     name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
1356 ):
1357     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1358     if "salt://" in saml_metadata_document:
1359         try:
1360             saml_metadata_document = __salt__["cp.get_file_str"](saml_metadata_document)
1361             ET.fromstring(saml_metadata_document)
1362         except OSError as e:
1363             log.debug(e)
1364             ret[
1365                 "comment"
1366             ] = "SAML document file {} not found or could not be loaded".format(name)
1367             ret["result"] = False
1368             return ret
1369     for provider in __salt__["boto_iam.list_saml_providers"](
1370         region=region, key=key, keyid=keyid, profile=profile
1371     ):
1372         if provider == name:
1373             ret["comment"] = "SAML provider {} is present.".format(name)
1374             return ret
1375     if __opts__["test"]:
1376         ret["comment"] = "SAML provider {} is set to be create.".format(name)
1377         ret["result"] = None
1378         return ret
1379     created = __salt__["boto_iam.create_saml_provider"](
1380         name,
1381         saml_metadata_document,
1382         region=region,
1383         key=key,
1384         keyid=keyid,
1385         profile=profile,
1386     )
1387     if created:
1388         ret["comment"] = "SAML provider {} was created.".format(name)
1389         ret["changes"]["new"] = name
1390         return ret
1391     ret["result"] = False
1392     ret["comment"] = "SAML provider {} failed to be created.".format(name)
1393     return ret
1394 def saml_provider_absent(name, region=None, key=None, keyid=None, profile=None):
1395     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1396     provider = __salt__["boto_iam.list_saml_providers"](
1397         region=region, key=key, keyid=keyid, profile=profile
1398     )
1399     if len(provider) == 0:
1400         ret["comment"] = "SAML provider {} is absent.".format(name)
1401         return ret
1402     if __opts__["test"]:
1403         ret["comment"] = "SAML provider {} is set to be removed.".format(name)
1404         ret["result"] = None
1405         return ret
1406     deleted = __salt__["boto_iam.delete_saml_provider"](
1407         name, region=region, key=key, keyid=keyid, profile=profile
1408     )
1409     if deleted is not False:
1410         ret["comment"] = "SAML provider {} was deleted.".format(name)
1411         ret["changes"]["old"] = name
1412         return ret
1413     ret["result"] = False
1414     ret["comment"] = "SAML provider {} failed to be deleted.".format(name)
1415     return ret
1416 def _get_error(error):
1417     error = "\n".join(error.split("\n")[1:])
1418     error = ET.fromstring(error)
1419     code = error[0][1].text
1420     message = error[0][2].text
1421     return code, message
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
