<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for saltmod.py &amp; boto_iam.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for saltmod.py &amp; boto_iam.py
      </h3>
<h1 align="center">
        3.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>saltmod.py (6.0851927%)<th>boto_iam.py (2.144389%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-117)<td><a href="#" name="0">(1484-1557)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(445-519)<td><a href="#" name="1">(1045-1108)</a><td align="center"><font color="#e20000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(25-42)<td><a href="#" name="2">(133-149)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(376-382)<td><a href="#" name="3">(1560-1565)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import sys
import threading
import time
import salt.exceptions
import salt.output
import salt.syspaths
import salt.utils.data
import salt.utils.event
log = logging.getLogger(__name__)
__virtualname__ = "salt"
def</b></font> __virtual__():
    return __virtualname__
def _fire_args(tag_data):
    try:
        salt.utils.event.fire_args(__opts__, __orchestration_jid__, tag_data, "run")
    except NameError:
        log.debug("Unable to fire args event due to missing __orchestration_jid__")
def _parallel_map(func, inputs):
    outputs = len(inputs) * [None]
    errors = len(inputs) * [None]
    def create_thread(index):
        def run_thread():
            try:
                outputs[index] = func(inputs[index])
            except:  # pylint: disable=bare-except
                errors[index] = sys.exc_info()
        thread = threading.Thread(target=run_thread)
        thread.start()
        return thread
    threads = list(map(create_thread, range(len(inputs))))
    for thread in threads:
        thread.join()
    for error in errors:
<a name="0"></a>        if error is not None:
            exc_type, exc_value, exc_traceback = error
            raise exc_value.with_traceback(exc_traceback)
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return outputs
def state(
    name,
    tgt,
    ssh=False,
    tgt_type="glob",
    ret="",
    ret_config=None,
    ret_kwargs=None,
    highstate=None,
    sls=None,
    top=None,
    saltenv=None,
    test=None,
    pillar=None,
    pillarenv=None,
    expect_minions=True,
    exclude=None,
    fail_minions=</b></font>None,
    allow_fail=0,
    concurrent=False,
    timeout=None,
    batch=None,
    queue=False,
    subset=None,
    orchestration_jid=None,
    failhard=None,
    **kwargs
):
    cmd_kw = {"arg": [], "kwarg": {}, "ret": ret, "timeout": timeout}
    if ret_config:
        cmd_kw["ret_config"] = ret_config
    if ret_kwargs:
        cmd_kw["ret_kwargs"] = ret_kwargs
    state_ret = {"name": name, "changes": {}, "comment": "", "result": True}
    try:
        allow_fail = int(allow_fail)
    except ValueError:
        state_ret["result"] = False
        state_ret["comment"] = "Passed invalid value for 'allow_fail', must be an int"
        return state_ret
    cmd_kw["tgt_type"] = tgt_type
    cmd_kw["ssh"] = ssh
    if "roster" in kwargs:
        cmd_kw["roster"] = kwargs["roster"]
    cmd_kw["expect_minions"] = expect_minions
    if highstate:
        fun = "state.highstate"
    elif top:
        fun = "state.top"
        cmd_kw["arg"].append(top)
    elif sls:
        fun = "state.sls"
        if isinstance(sls, list):
            sls = ",".join(sls)
        cmd_kw["arg"].append(sls)
    else:
        state_ret["comment"] = "No highstate or sls specified, no execution made"
        state_ret["result"] = False
        return state_ret
    if test is not None or __opts__.get("test"):
        cmd_kw["kwarg"]["test"] = test if test is not None else __opts__.get("test")
    if pillar:
        cmd_kw["kwarg"]["pillar"] = pillar
    if pillarenv is not None:
        cmd_kw["kwarg"]["pillarenv"] = pillarenv
    if saltenv is not None:
        cmd_kw["kwarg"]["saltenv"] = saltenv
    if exclude is not None:
        cmd_kw["kwarg"]["exclude"] = exclude
    cmd_kw["kwarg"]["queue"] = queue
    if isinstance(concurrent, bool):
        cmd_kw["kwarg"]["concurrent"] = concurrent
    else:
        state_ret["comment"] = "Must pass in boolean for value of 'concurrent'"
        state_ret["result"] = False
        return state_ret
    if batch is not None:
        cmd_kw["batch"] = str(batch)
    if subset is not None:
        cmd_kw["subset"] = subset
    if failhard is True or __opts__.get("failhard"):
        cmd_kw["failhard"] = True
    masterless = __opts__["__role"] == "minion" and __opts__["file_client"] == "local"
    if not masterless:
        _fire_args({"type": "state", "tgt": tgt, "name": name, "args": cmd_kw})
        cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
    else:
        if top:
            cmd_kw["topfn"] = "".join(cmd_kw.pop("arg"))
        elif sls:
            cmd_kw["mods"] = "".join(cmd_kw.pop("arg"))
        cmd_kw.update(cmd_kw.pop("kwarg"))
        tmp_ret = __salt__[fun](**cmd_kw)
        cmd_ret = {
            __opts__["id"]: {
                "ret": tmp_ret,
                "out": tmp_ret.get("out", "highstate")
                if isinstance(tmp_ret, dict)
                else "highstate",
            }
        }
    try:
        state_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
    except (StopIteration, KeyError):
        pass
    changes = {}
    fail = set()
    no_change = set()
    if fail_minions is None:
        fail_minions = ()
    elif isinstance(fail_minions, str):
        fail_minions = [minion.strip() for minion in fail_minions.split(",")]
    elif not isinstance(fail_minions, list):
        state_ret.setdefault("warnings", []).append(
            "'fail_minions' needs to be a list or a comma separated string. Ignored."
<a name="3"></a>        )
        fail_minions = ()
    <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not cmd_ret and expect_minions:
        state_ret["result"] = False
        state_ret["comment"] = "No minions returned"
        return state_ret
    for minion, mdata in cmd_ret.items():
        if mdata.</b></font>get("out", "") != "highstate":
            log.warning("Output from salt state not highstate")
        m_ret = False
        if "return" in mdata and "ret" not in mdata:
            mdata["ret"] = mdata.pop("return")
        m_state = True
        if mdata.get("failed", False):
            m_state = False
        else:
            try:
                m_ret = mdata["ret"]
            except KeyError:
                m_state = False
            if m_state:
                m_state = __utils__["state.check_result"](m_ret, recurse=True)
        if not m_state:
            if minion not in fail_minions:
                fail.add(minion)
            changes[minion] = m_ret
            continue
        try:
            for state_item in m_ret.values():
                if isinstance(state_item, dict):
                    if "changes" in state_item and state_item["changes"]:
                        changes[minion] = m_ret
                        break
            else:
                no_change.add(minion)
        except AttributeError:
            log.error("m_ret did not have changes %s %s", type(m_ret), m_ret)
            no_change.add(minion)
    if changes:
        state_ret["changes"] = {"out": "highstate", "ret": changes}
    if len(fail) &gt; allow_fail:
        state_ret["result"] = False
        state_ret["comment"] = "Run failed on minions: {}".format(", ".join(fail))
    else:
        state_ret["comment"] = "States ran successfully."
        if changes:
            state_ret["comment"] += " Updating {}.".format(", ".join(changes))
        if no_change:
            state_ret["comment"] += " No changes made to {}.".format(
                ", ".join(no_change)
            )
    if test or __opts__.get("test"):
        if state_ret["changes"] and state_ret["result"] is True:
            state_ret["result"] = None
    return state_ret
def function(
    name,
    tgt,
    ssh=False,
<a name="1"></a>    tgt_type="glob",
    ret="",
    ret_config=None,
    ret_kwargs<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
    expect_minions=False,
    fail_minions=None,
    fail_function=None,
    arg=None,
    kwarg=None,
    timeout=None,
    batch=None,
    subset=None,
    failhard=None,
    **kwargs
):  # pylint: disable=unused-argument
    func_ret = {"name": name, "changes": {}, "comment": "", "result": True}
    if kwarg is None:
        kwarg = {}
    if</b></font> isinstance(arg, str):
        func_ret["warnings"] = ["Please specify 'arg' as a list of arguments."]
        arg = arg.split()
    cmd_kw = {"arg": arg or [], "kwarg": kwarg, "ret": ret, "timeout": timeout}
    if batch is not None:
        cmd_kw["batch"] = str(batch)
    if subset is not None:
        cmd_kw["subset"] = subset
    cmd_kw["tgt_type"] = tgt_type
    cmd_kw["ssh"] = ssh
    if "roster" in kwargs:
        cmd_kw["roster"] = kwargs["roster"]
    cmd_kw["expect_minions"] = expect_minions
    cmd_kw["_cmd_meta"] = True
    if failhard is True or __opts__.get("failhard"):
        cmd_kw["failhard"] = True
    if ret_config:
        cmd_kw["ret_config"] = ret_config
    if ret_kwargs:
        cmd_kw["ret_kwargs"] = ret_kwargs
    fun = name
    if __opts__["test"] is True:
        func_ret["comment"] = "Function {} would be executed on target {}".format(
            fun, tgt
        )
        func_ret["result"] = None
        return func_ret
    try:
        _fire_args({"type": "function", "tgt": tgt, "name": name, "args": cmd_kw})
        cmd_ret = __salt__["saltutil.cmd"](tgt, fun, **cmd_kw)
    except Exception as exc:  # pylint: disable=broad-except
        func_ret["result"] = False
        func_ret["comment"] = str(exc)
        return func_ret
    try:
        func_ret["__jid__"] = cmd_ret[next(iter(cmd_ret))]["jid"]
    except (StopIteration, KeyError):
        pass
    changes = {}
    fail = set()
    if fail_minions is None:
        fail_minions = ()
    elif isinstance(fail_minions, str):
        fail_minions = [minion.strip() for minion in fail_minions.split(",")]
    elif not isinstance(fail_minions, list):
        func_ret.setdefault("warnings", []).append(
            "'fail_minions' needs to be a list or a comma separated string. Ignored."
        )
        fail_minions = ()
    for minion, mdata in cmd_ret.items():
        m_ret = False
        if mdata.get("retcode"):
            func_ret["result"] = False
            fail.add(minion)
        if mdata.get("failed", False):
            m_func = False
        else:
            if "return" in mdata and "ret" not in mdata:
                mdata["ret"] = mdata.pop("return")
            m_ret = mdata["ret"]
            m_func = (not fail_function and True) or __salt__[fail_function](m_ret)
            if m_ret is False:
                m_func = False
        if not m_func:
            if minion not in fail_minions:
                fail.add(minion)
        changes[minion] = m_ret
    if not cmd_ret:
        func_ret["result"] = False
        func_ret["comment"] = "No minions responded"
    else:
        if changes:
            func_ret["changes"] = {"ret": changes}
        if fail:
            func_ret["result"] = False
            func_ret["comment"] = "Running function {} failed on minions: {}".format(
                name, ", ".join(fail)
            )
        else:
            func_ret["comment"] = "Function ran successfully."
        if changes:
            func_ret["comment"] += " Function {} ran on {}.".format(
                name, ", ".join(changes)
            )
    return func_ret
def wait_for_event(name, id_list, event_id="id", timeout=300, node="master"):
    ret = {"name": name, "changes": {}, "comment": "", "result": False}
    if __opts__.get("test"):
        ret["comment"] = "Orchestration would wait for event '{}'".format(name)
        ret["result"] = None
        return ret
    with salt.utils.event.get_event(
        node, __opts__["sock_dir"], opts=__opts__, listen=True
    ) as sevent:
        del_counter = 0
        starttime = time.time()
        timelimit = starttime + timeout
        while True:
            event = sevent.get_event(full=True)
            is_timedout = time.time() &gt; timelimit
            if event is None and not is_timedout:
                log.trace("wait_for_event: No event data; waiting.")
                continue
            elif event is None and is_timedout:
                ret["comment"] = "Timeout value reached."
                return ret
            if fnmatch.fnmatch(event["tag"], name):
                val = event["data"].get(event_id)
                if val is None and "data" in event["data"]:
                    val = event["data"]["data"].get(event_id)
                if val is not None:
                    try:
                        val_idx = id_list.index(val)
                    except ValueError:
                        log.trace(
                            "wait_for_event: Event identifier '%s' not in "
                            "id_list; skipping.",
                            event_id,
                        )
                    else:
                        del id_list[val_idx]
                        del_counter += 1
                        minions_seen = ret["changes"].setdefault("minions_seen", [])
                        minions_seen.append(val)
                        log.debug(
                            "wait_for_event: Event identifier '%s' removed "
                            "from id_list; %s items remaining.",
                            val,
                            len(id_list),
                        )
                else:
                    log.trace(
                        "wait_for_event: Event identifier '%s' not in event "
                        "'%s'; skipping.",
                        event_id,
                        event["tag"],
                    )
            else:
                log.debug("wait_for_event: Skipping unmatched event '%s'", event["tag"])
            if len(id_list) == 0:
                ret["result"] = True
                ret["comment"] = "All events seen in {} seconds.".format(
                    time.time() - starttime
                )
                return ret
            if is_timedout:
                ret["comment"] = "Timeout value reached."
                return ret
def runner(name, **kwargs):
    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug("Unable to fire args event due to missing __orchestration_jid__")
        jid = None
    if __opts__.get("test", False):
        ret = {
            "name": name,
            "result": None,
            "changes": {},
            "comment": "Runner function '{}' would be executed.".format(name),
        }
        return ret
    out = __salt__["saltutil.runner"](
        name, __orchestration_jid__=jid, __env__=__env__, full_return=True, **kwargs
    )
    runner_return = out.get("return")
    if isinstance(runner_return, dict) and "Error" in runner_return:
        out["success"] = False
    success = out.get("success", True)
    ret = {"name": name, "changes": {"return": runner_return}, "result": success}
    ret["comment"] = "Runner function '{}' {}.".format(
        name,
        "executed" if success else "failed",
    )
    ret["__orchestration__"] = True
    if "jid" in out:
        ret["__jid__"] = out["jid"]
    return ret
def parallel_runners(name, runners, **kwargs):  # pylint: disable=unused-argument
    if isinstance(runners, str):
        runners = {runners: [{name: runners}]}
    if not isinstance(runners, dict):
        return {
            "name": name,
            "result": False,
            "changes": {},
            "comment": "The runners parameter must be a string or dict.",
        }
    for runner_id, runner_config in runners.items():
        if runner_config is None:
            runner_config = {}
        else:
            runner_config = salt.utils.data.repack_dictlist(runner_config)
        if "name" not in runner_config:
            runner_config["name"] = runner_id
        runners[runner_id] = runner_config
    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug("Unable to fire args event due to missing __orchestration_jid__")
        jid = None
    def call_runner(runner_config):
        return __salt__["saltutil.runner"](
            runner_config["name"],
            __orchestration_jid__=jid,
            __env__=__env__,
            full_return=True,
            **(runner_config.get("kwarg", {}))
        )
    try:
        outputs = _parallel_map(call_runner, list(runners.values()))
    except salt.exceptions.SaltException as exc:
        return {
            "name": name,
            "result": False,
            "success": False,
            "changes": {},
            "comment": "One of the runners raised an exception: {}".format(exc),
        }
    outputs = {
        runner_id: out["return"] for runner_id, out in zip(runners.keys(), outputs)
    }
    highstate_output = all(
        [
            out.get("outputter", "") == "highstate" and "data" in out
            for out in outputs.values()
        ]
    )
    def extract_changes(obj):
        if not isinstance(obj, dict):
            return {}
        elif "changes" in obj:
            if (
                isinstance(obj["changes"], dict)
                and obj["changes"].get("out", "") == "highstate"
                and "ret" in obj["changes"]
            ):
                return obj["changes"]["ret"]
            else:
                return obj["changes"]
        else:
            found_changes = {}
            for key, value in obj.items():
                change = extract_changes(value)
                if change:
                    found_changes[key] = change
            return found_changes
    if highstate_output:
        failed_runners = [
            runner_id
            for runner_id, out in outputs.items()
            if out["data"].get("retcode", 0) != 0
        ]
        all_successful = not failed_runners
        if all_successful:
            comment = "All runner functions executed successfully."
        else:
            runner_comments = [
                "Runner {} failed with return value:\n{}".format(
                    runner_id,
                    salt.output.out_format(
                        outputs[runner_id], "nested", __opts__, nested_indent=2
                    ),
                )
                for runner_id in failed_runners
            ]
            comment = "\n".join(runner_comments)
        changes = {}
        for runner_id, out in outputs.items():
            runner_changes = extract_changes(out["data"])
            if runner_changes:
                changes[runner_id] = runner_changes
    else:
        failed_runners = [
            runner_id
            for runner_id, out in outputs.items()
            if out.get("exit_code", 0) != 0
        ]
        all_successful = not failed_runners
        if all_successful:
            comment = "All runner functions executed successfully."
        else:
            if len(failed_runners) == 1:
                comment = "Runner {} failed.".format(failed_runners[0])
            else:
                comment = "Runners {} failed.".format(", ".join(failed_runners))
        changes = {"ret": {runner_id: out for runner_id, out in outputs.items()}}
    ret = {
        "name": name,
        "result": all_successful,
        "changes": changes,
        "comment": comment,
    }
    return ret
def wheel(name, **kwargs):
    ret = {"name": name, "result": False, "changes": {}, "comment": ""}
    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug("Unable to fire args event due to missing __orchestration_jid__")
        jid = None
    if __opts__.get("test", False):
        ret["result"] = (None,)
        ret["changes"] = {}
        ret["comment"] = "Wheel function '{}' would be executed.".format(name)
        return ret
    out = __salt__["saltutil.wheel"](
        name, __orchestration_jid__=jid, __env__=__env__, **kwargs
    )
    wheel_return = out.get("return")
    if isinstance(wheel_return, dict) and "Error" in wheel_return:
        out["success"] = False
    success = out.get("success", True)
    ret = {"name": name, "changes": {"return": wheel_return}, "result": success}
    ret["comment"] = "Wheel function '{}' {}.".format(
        name,
        "executed" if success else "failed",
    )
    ret["__orchestration__"] = True
    if "jid" in out:
        ret["__jid__"] = out["jid"]
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
import os
import xml.etree.ElementTree as ET
import salt.utils.data
import salt.utils.dictupdate as dictupdate
import salt.utils.files
import salt.utils.json
import salt.utils.odict as odict
import salt.utils.stringutils
log = logging.getLogger(__name__)
__virtualname__ = "boto_iam"
def</b></font> __virtual__():
    if "boto_iam.get_user" in __salt__:
        return True
    else:
        return (
            False,
            "Cannot load {} state: boto_iam module unavailable".format(__virtualname__),
        )
def user_absent(
    name,
    delete_keys=True,
    delete_mfa_devices=True,
    delete_profile=True,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
        ret["result"] = True
        ret["comment"] = "IAM User {} does not exist.".format(name)
        return ret
    if delete_keys:
        keys = __salt__["boto_iam.get_all_access_keys"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        log.debug("Keys for user %s are %s.", name, keys)
        if isinstance(keys, dict):
            keys = keys["list_access_keys_response"]["list_access_keys_result"][
                "access_key_metadata"
            ]
            for k in keys:
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "Key {} is set to be deleted.".format(k["access_key_id"]),
                        ]
                    )
                    ret["result"] = None
                else:
                    if _delete_key(
                        ret, k["access_key_id"], name, region, key, keyid, profile
                    ):
                        ret["comment"] = " ".join(
                            [
                                ret["comment"],
                                "Key {} has been deleted.".format(k["access_key_id"]),
                            ]
                        )
                        ret["changes"][k["access_key_id"]] = "deleted"
    if delete_mfa_devices:
        devices = __salt__["boto_iam.get_all_mfa_devices"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        if devices:
            for d in devices:
                serial = d["serial_number"]
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "IAM user {} MFA device {} is set to be deactivated.".format(
                                name, serial
                            ),
                        ]
                    )
                    ret["result"] = None
                else:
                    mfa_deactivated = __salt__["boto_iam.deactivate_mfa_device"](
                        user_name=name,
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deactivated:
                        ret["comment"] = " ".join(
                            [
                                ret["comment"],
                                "IAM user {} MFA device {} is deactivated.".format(
                                    name, serial
                                ),
                            ]
                        )
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "Virtual MFA device {} is set to be deleted.".format(
                                serial
                            ),
                        ]
                    )
                    ret["result"] = None
                else:
                    mfa_deleted = __salt__["boto_iam.delete_virtual_mfa_device"](
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deleted:
                        ret["comment"] = " ".join(
                            [
                                ret["comment"],
                                "Virtual MFA device {} is deleted.".format(serial),
                            ]
                        )
    if delete_profile:
        if __opts__["test"]:
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "IAM user {} login profile is set to be deleted.".format(name),
                ]
            )
            ret["result"] = None
        else:
            profile_deleted = __salt__["boto_iam.delete_login_profile"](
                name, region, key, keyid, profile
            )
            if profile_deleted:
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "IAM user {} login profile is deleted.".format(name),
                    ]
                )
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM user {} managed policies are set to be detached.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _user_policies_detached(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM user {} inline policies are set to be deleted.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _user_policies_deleted(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM user {} is set to be deleted.".format(name)]
        )
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_user"](name, region, key, keyid, profile)
    if deleted is True:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM user {} is deleted.".format(name)]
        )
        ret["result"] = True
        ret["changes"]["deleted"] = name
        return ret
    ret["comment"] = "IAM user {} could not be deleted.\n {}".format(name, deleted)
    ret["result"] = False
    return ret
def keys_present(
    name,
    number,
    save_dir,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    save_format="{2}\n{0}\n{3}\n{1}\n",
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
        ret["result"] = False
        ret["comment"] = "IAM User {} does not exist.".format(name)
        return ret
    if not isinstance(number, int):
        ret["comment"] = "The number of keys must be an integer."
        ret["result"] = False
        return ret
    if not os.path.isdir(save_dir):
        ret["comment"] = "The directory {} does not exist.".format(save_dir)
        ret["result"] = False
        return ret
    keys = __salt__["boto_iam.get_all_access_keys"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if isinstance(keys, str):
        log.debug("keys are : false %s", keys)
        error, message = _get_error(keys)
        ret["comment"] = "Could not get keys.\n{}\n{}".format(error, message)
        ret["result"] = False
        return ret
    keys = keys["list_access_keys_response"]["list_access_keys_result"][
        "access_key_metadata"
    ]
    log.debug("Keys are : %s.", keys)
    if len(keys) &gt;= number:
        ret["comment"] = "The number of keys exist for user {}".format(name)
        ret["result"] = True
        return ret
    if __opts__["test"]:
        ret["comment"] = "Access key is set to be created for {}.".format(name)
        ret["result"] = None
        return ret
    new_keys = {}
    for i in range(number - len(keys)):
        created = __salt__["boto_iam.create_access_key"](
            name, region, key, keyid, profile
        )
        if isinstance(created, str):
            error, message = _get_error(created)
            ret["comment"] = "Could not create keys.\n{}\n{}".format(error, message)
            ret["result"] = False
            return ret
        log.debug("Created is : %s", created)
        response = "create_access_key_response"
        result = "create_access_key_result"
        new_keys[str(i)] = {}
        new_keys[str(i)]["key_id"] = created[response][result]["access_key"][
            "access_key_id"
        ]
        new_keys[str(i)]["secret_key"] = created[response][result]["access_key"][
            "secret_access_key"
        ]
    try:
        with salt.utils.files.fopen("{}/{}".format(save_dir, name), "a") as _wrf:
            for key_num, key in new_keys.items():
                key_id = key["key_id"]
                secret_key = key["secret_key"]
                _wrf.write(
                    salt.utils.stringutils.to_str(
                        save_format.format(
                            key_id,
                            secret_key,
                            "key_id-{}".format(key_num),
                            "key-{}".format(key_num),
                        )
                    )
                )
        ret["comment"] = "Keys have been written to file {}/{}.".format(save_dir, name)
        ret["result"] = True
        ret["changes"] = new_keys
        return ret
    except OSError:
        ret["comment"] = "Could not write to file {}/{}.".format(save_dir, name)
        ret["result"] = False
        return ret
def keys_absent(
    access_keys, user_name, region=None, key=None, keyid=None, profile=None
):
    ret = {"name": access_keys, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](user_name, region, key, keyid, profile):
        ret["result"] = False
        ret["comment"] = "IAM User {} does not exist.".format(user_name)
        return ret
    for k in access_keys:
        ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
    return ret
def _delete_key(
    ret, access_key_id, user_name, region=None, key=None, keyid=None, profile=None
):
    keys = __salt__["boto_iam.get_all_access_keys"](
        user_name=user_name, region=region, key=key, keyid=keyid, profile=profile
    )
    log.debug("Keys for user %s are : %s.", keys, user_name)
    if isinstance(keys, str):
        log.debug("Keys %s are a string. Something went wrong.", keys)
        ret["comment"] = " ".join(
            [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
        )
        return ret
    keys = keys["list_access_keys_response"]["list_access_keys_result"][
        "access_key_metadata"
    ]
    for k in keys:
        log.debug(
            "Key is: %s and is compared with: %s", k["access_key_id"], access_key_id
        )
        if str(k["access_key_id"]) == str(access_key_id):
            if __opts__["test"]:
                ret["comment"] = "Access key {} is set to be deleted.".format(
                    access_key_id
                )
                ret["result"] = None
                return ret
            deleted = __salt__["boto_iam.delete_access_key"](
                access_key_id, user_name, region, key, keyid, profile
            )
            if deleted:
                ret["comment"] = " ".join(
                    [ret["comment"], "Key {} has been deleted.".format(access_key_id)]
                )
                ret["changes"][access_key_id] = "deleted"
                return ret
            ret["comment"] = " ".join(
                [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
            )
            return ret
        ret["comment"] = " ".join([ret["comment"], "Key {} does not exist.".format(k)])
        return ret
def user_present(
    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    password=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__["pillar.get"](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__["boto_iam.get_user"](name, region, key, keyid, profile)
    if not exists:
        if __opts__["test"]:
            ret["comment"] = "IAM user {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_user"](
            name, path, region, key, keyid, profile
        )
        if created:
            ret["changes"]["user"] = created
            ret["comment"] = " ".join(
                [ret["comment"], "User {} has been created.".format(name)]
            )
            if password:
                ret = _case_password(ret, name, password, region, key, keyid, profile)
            _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
            ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
            ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    else:
        ret["comment"] = " ".join([ret["comment"], "User {} is present.".format(name)])
        if password:
            ret = _case_password(ret, name, password, region, key, keyid, profile)
        _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
        ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    return ret
def _user_policies_present(
    name, policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__["boto_iam.get_user_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__["boto_iam.get_all_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    for policy_name in _list:
        if policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on user {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"policies": _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__["boto_iam.put_user_policy"](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.get_all_user_policies"](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} for user {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__["boto_iam.delete_user_policy"](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.get_all_user_policies"](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to user {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.get_all_user_policies"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret["changes"]["new"] = {"policies": _list}
        ret["comment"] = "{} policies modified on user {}.".format(
            ", ".join(_list), name
        )
    return ret
def _user_policies_attached(
    name, managed_policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__["boto_iam.list_entities_for_policy"](
            policy,
            entity_filter="User",
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for userdict in entities.get("policy_users", []):
            if name == userdict.get("user_name"):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__["boto_iam.list_attached_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    for policy_data in _list:
        if (
            policy_data.get("policy_name") not in managed_policies
            and policy_data.get("policy_arn") not in managed_policies
        ):
            policies_to_detach.append(policy_data.get("policy_arn"))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on user {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"managed_policies": oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__["boto_iam.attach_user_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_attached_user_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to user {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__["boto_iam.detach_user_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_attached_user_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from user {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_attached_user_policies"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get("policy_arn") for x in _list]
        log.debug(newpolicies)
        ret["changes"]["new"] = {"managed_policies": newpolicies}
        ret["comment"] = "{} policies modified on user {}.".format(
            ", ".join(newpolicies), name
        )
    return ret
def _user_policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    _list = __salt__["boto_iam.list_attached_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    if not _list:
        ret["comment"] = "No attached policies in user {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be detached from user {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"managed_policies": oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__["boto_iam.detach_user_policy"](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_attached_user_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get("policy_arn") for x in _list]
            ret["changes"]["new"] = {"managed_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from user {}".format(policy_arn, name)
            return ret
    _list = __salt__["boto_iam.list_attached_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get("policy_arn") for x in _list]
    ret["changes"]["new"] = {"managed_policies": newpolicies}
    ret["comment"] = "{} policies detached from user {}.".format(
        ", ".join(oldpolicies), name
    )
    return ret
def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    oldpolicies = __salt__["boto_iam.get_all_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret["comment"] = "No inline policies in user {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be deleted from user {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"inline_policies": oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__["boto_iam.delete_user_policy"](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__["boto_iam.get_all_user_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret["changes"]["new"] = {"inline_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from user {}".format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__["boto_iam.get_all_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret["changes"]["new"] = {"inline_policies": newpolicies}
    ret["comment"] = "{} policies deleted from user {}.".format(
        ", ".join(oldpolicies), name
    )
    return ret
def _case_password(
    ret, name, password, region=None, key=None, keyid=None, profile=None
):
    if __opts__["test"]:
        ret["comment"] = "Login policy for {} is set to be changed.".format(name)
        ret["result"] = None
        return ret
    login = __salt__["boto_iam.create_login_profile"](
        name, password, region, key, keyid, profile
    )
    log.debug("Login is : %s.", login)
    if login:
        if "Conflict" in login:
            ret["comment"] = " ".join(
                [ret["comment"], "Login profile for user {} exists.".format(name)]
            )
        else:
            ret["comment"] = " ".join(
                [ret["comment"], "Password has been added to User {}.".format(name)]
            )
            ret["changes"]["password"] = "REDACTED"
    else:
        ret["result"] = False
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "Password for user {} could not be set.\nPlease check your password"
                " policy.".format(name),
            ]
        )
    return ret
def group_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_group"](name, region, key, keyid, profile):
        ret["result"] = True
        ret["comment"] = "IAM Group {} does not exist.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM group {} managed policies are set to be detached.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _group_policies_detached(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM group {} inline policies are set to be deleted.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _group_policies_deleted(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    ret["comment"] = " ".join(
        [ret["comment"], "IAM group {} users are set to be removed.".format(name)]
    )
    existing_users = __salt__["boto_iam.get_group_members"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM group {} is set to be deleted.".format(name)]
        )
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_group"](name, region, key, keyid, profile)
    if deleted is True:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM group {} is deleted.".format(name)]
        )
        ret["result"] = True
        ret["changes"]["deleted"] = name
        return ret
    ret["comment"] = "IAM group {} could not be deleted.\n {}".format(name, deleted)
    ret["result"] = False
    return ret
<a name="1"></a>
def group_present(
    name,
    policies<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
    policies_from_pillars=None,
    managed_policies=None,
    users=None,
    path="/",
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not policies:
        policies = {}
    if</b></font> not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__["pillar.get"](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__["boto_iam.get_group"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__["test"]:
            ret["comment"] = "IAM group {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_group"](
            group_name=name,
            path=path,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not created:
            ret["comment"] = "Failed to create IAM group {}.".format(name)
            ret["result"] = False
            return ret
        ret["changes"]["group"] = created
        ret["comment"] = " ".join(
            [ret["comment"], "Group {} has been created.".format(name)]
        )
    else:
        ret["comment"] = " ".join([ret["comment"], "Group {} is present.".format(name)])
    _ret = _group_policies_present(
        name, _policies, region, key, keyid, profile, delete_policies
    )
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    _ret = _group_policies_attached(
        name, managed_policies, region, key, keyid, profile, delete_policies
    )
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    if users is not None:
        log.debug("Users are : %s.", users)
        existing_users = __salt__["boto_iam.get_group_members"](
            group_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
    return ret
def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
    _users = []
    for user in existing_users:
        _users.append(user["user_name"])
    log.debug("upstream users are %s", _users)
    for user in users:
        log.debug("users are %s", user)
        if user in _users:
            log.debug("user exists")
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "User {} is already a member of group {}.".format(user, group_name),
                ]
            )
            continue
        else:
            log.debug("user is set to be added %s", user)
            if __opts__["test"]:
                ret["comment"] = "User {} is set to be added to group {}.".format(
                    user, group_name
                )
                ret["result"] = None
            else:
                __salt__["boto_iam.add_user_to_group"](
                    user, group_name, region, key, keyid, profile
                )
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} has been added to group {}.".format(user, group_name),
                    ]
                )
                ret["changes"][user] = group_name
    for user in _users:
        if user not in users:
            if __opts__["test"]:
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} is set to be removed from group {}.".format(
                            user, group_name
                        ),
                    ]
                )
                ret["result"] = None
            else:
                __salt__["boto_iam.remove_user_from_group"](
                    group_name=group_name,
                    user_name=user,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} has been removed from group {}.".format(
                            user, group_name
                        ),
                    ]
                )
                ret["changes"][user] = "Removed from group {}.".format(group_name)
    return ret
def _group_policies_present(
    name,
    policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__["boto_iam.get_group_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__["boto_iam.get_all_group_policies"](
        name, region, key, keyid, profile
    )
    for policy_name in _list:
        if delete_policies and policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on group {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"policies": _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__["boto_iam.put_group_policy"](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.get_all_group_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__["boto_iam.delete_group_policy"](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.get_all_group_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.get_all_group_policies"](
            name, region, key, keyid, profile
        )
        ret["changes"]["new"] = {"policies": _list}
        ret["comment"] = "{} policies modified on group {}.".format(
            ", ".join(_list), name
        )
    return ret
def _group_policies_attached(
    name,
    managed_policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    detach_policies=True,
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__["boto_iam.list_entities_for_policy"](
            policy,
            entity_filter="Group",
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for groupdict in entities.get("policy_groups", []):
            if name == groupdict.get("group_name"):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__["boto_iam.list_attached_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    for policy_data in _list:
        if (
            detach_policies
            and policy_data.get("policy_name") not in managed_policies
            and policy_data.get("policy_arn") not in managed_policies
        ):
            policies_to_detach.append(policy_data.get("policy_arn"))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on group {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"managed_policies": oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__["boto_iam.attach_group_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_attached_group_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__["boto_iam.detach_group_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_attached_group_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from group {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_attached_group_policies"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get("policy_arn") for x in _list]
        log.debug(newpolicies)
        ret["changes"]["new"] = {"managed_policies": newpolicies}
        ret["comment"] = "{} policies modified on group {}.".format(
            ", ".join(newpolicies), name
        )
    return ret
def _group_policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    _list = __salt__["boto_iam.list_attached_group_policies"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    if not _list:
        ret["comment"] = "No attached policies in group {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be detached from group {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"managed_policies": oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__["boto_iam.detach_group_policy"](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_attached_group_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get("policy_arn") for x in _list]
            ret["changes"]["new"] = {"managed_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from group {}".format(
                policy_arn, name
            )
            return ret
    _list = __salt__["boto_iam.list_attached_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get("policy_arn") for x in _list]
    ret["changes"]["new"] = {"managed_policies": newpolicies}
    ret["comment"] = "{} policies detached from group {}.".format(
        ", ".join(newpolicies), name
    )
    return ret
def _group_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    oldpolicies = __salt__["boto_iam.get_all_group_policies"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret["comment"] = "No inline policies in group {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be deleted from group {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"inline_policies": oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__["boto_iam.delete_group_policy"](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__["boto_iam.get_all_group_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret["changes"]["new"] = {"inline_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from group {}".format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__["boto_iam.get_all_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret["changes"]["new"] = {"inline_policies": newpolicies}
<a name="0"></a>    ret["comment"] = "{} policies deleted from group {}.".format(
        ", ".join(oldpolicies), name
    )
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
def account_policy(
    name=None,
    allow_users_to_change_password=None,
    hard_expiry=None,
    max_password_age=None,
    minimum_password_length=None,
    password_reuse_prevention=None,
    require_lowercase_characters=None,
    require_numbers=None,
    require_symbols=None,
    require_uppercase_characters=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
<a name="3"></a>    config =</b></font> locals()
    ret = {"name": "Account Policy", "result": True, "comment": "", "changes": {}}
    info = __salt__["boto_iam.get_account_policy"](region, key, keyid, profile)
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not info:
        ret["comment"] = "Account policy is not Enabled."
        ret["result"] = False
        return ret
    for key, value in config.items():
        if key in ("region"</b></font>, "key", "keyid", "profile", "name"):
            continue
        if value is not None and str(info[key]) != str(value).lower():
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "Policy value {} has been set to {}.".format(value, info[key]),
                ]
            )
            ret["changes"][key] = str(value).lower()
    if not ret["changes"]:
        ret["comment"] = "Account policy is not changed."
        return ret
    if __opts__["test"]:
        ret["comment"] = "Account policy is set to be changed."
        ret["result"] = None
        return ret
    if __salt__["boto_iam.update_account_password_policy"](
        allow_users_to_change_password,
        hard_expiry,
        max_password_age,
        minimum_password_length,
        password_reuse_prevention,
        require_lowercase_characters,
        require_numbers,
        require_symbols,
        require_uppercase_characters,
        region,
        key,
        keyid,
        profile,
    ):
        return ret
    ret["comment"] = "Account policy is not changed."
    ret["changes"] = {}
    ret["result"] = False
    return ret
def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_iam.get_server_certificate"](
        name, region, key, keyid, profile
    )
    if not exists:
        ret["comment"] = "Certificate {} does not exist.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "Server certificate {} is set to be deleted.".format(name)
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_server_cert"](name, region, key, keyid, profile)
    if not deleted:
        ret["result"] = False
        ret["comment"] = "Certificate {} failed to be deleted.".format(name)
        return ret
    ret["comment"] = "Certificate {} was deleted.".format(name)
    ret["changes"] = deleted
    return ret
def server_cert_present(
    name,
    public_key,
    private_key,
    cert_chain=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_iam.get_server_certificate"](
        name, region, key, keyid, profile
    )
    log.debug("Variables are : %s.", locals())
    if exists:
        ret["comment"] = "Certificate {} exists.".format(name)
        return ret
    if "salt://" in public_key:
        try:
            public_key = __salt__["cp.get_file_str"](public_key)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(public_key)
            ret["result"] = False
            return ret
    if "salt://" in private_key:
        try:
            private_key = __salt__["cp.get_file_str"](private_key)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(private_key)
            ret["result"] = False
            return ret
    if cert_chain is not None and "salt://" in cert_chain:
        try:
            cert_chain = __salt__["cp.get_file_str"](cert_chain)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(cert_chain)
            ret["result"] = False
            return ret
    if __opts__["test"]:
        ret["comment"] = "Server certificate {} is set to be created.".format(name)
        ret["result"] = None
        return ret
    created = __salt__["boto_iam.upload_server_cert"](
        name, public_key, private_key, cert_chain, path, region, key, keyid, profile
    )
    if created is not False:
        ret["comment"] = "Certificate {} was created.".format(name)
        ret["changes"] = created
        return ret
    ret["result"] = False
    ret["comment"] = "Certificate {} failed to be created.".format(name)
    return ret
def policy_present(
    name,
    policy_document,
    path=None,
    description=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    policy = __salt__["boto_iam.get_policy"](name, region, key, keyid, profile)
    if not policy:
        if __opts__["test"]:
            ret["comment"] = "IAM policy {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_policy"](
            name, policy_document, path, description, region, key, keyid, profile
        )
        if created:
            ret["changes"]["policy"] = created
            ret["comment"] = " ".join(
                [ret["comment"], "Policy {} has been created.".format(name)]
            )
        else:
            ret["result"] = False
            ret["comment"] = "Failed to update policy."
            ret["changes"] = {}
            return ret
    else:
        policy = policy.get("policy", {})
        ret["comment"] = " ".join(
            [ret["comment"], "Policy {} is present.".format(name)]
        )
        _describe = __salt__["boto_iam.get_policy_version"](
            name, policy.get("default_version_id"), region, key, keyid, profile
        ).get("policy_version", {})
        if isinstance(_describe["document"], str):
            describeDict = salt.utils.json.loads(_describe["document"])
        else:
            describeDict = _describe["document"]
        if isinstance(policy_document, str):
            policy_document = salt.utils.json.loads(policy_document)
        r = salt.utils.data.compare_dicts(describeDict, policy_document)
        if bool(r):
            if __opts__["test"]:
                ret["comment"] = "Policy {} set to be modified.".format(name)
                ret["result"] = None
                return ret
            ret["comment"] = " ".join([ret["comment"], "Policy to be modified"])
            policy_document = salt.utils.json.dumps(policy_document)
            r = __salt__["boto_iam.create_policy_version"](
                policy_name=name,
                policy_document=policy_document,
                set_as_default=True,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r.get("created"):
                ret["result"] = False
                ret["comment"] = "Failed to update policy: {}.".format(
                    r["error"]["message"]
                )
                ret["changes"] = {}
                return ret
            __salt__["boto_iam.delete_policy_version"](
                policy_name=name,
                version_id=policy["default_version_id"],
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            ret["changes"].setdefault("new", {})["document"] = policy_document
            ret["changes"].setdefault("old", {})["document"] = _describe["document"]
    return ret
def policy_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    r = __salt__["boto_iam.policy_exists"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r:
        ret["comment"] = "Policy {} does not exist.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "Policy {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    versions = __salt__["boto_iam.list_policy_versions"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if versions:
        for version in versions:
            if version.get("is_default_version", False) in ("true", True):
                continue
            r = __salt__["boto_iam.delete_policy_version"](
                name,
                version_id=version.get("version_id"),
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r:
                ret["result"] = False
                ret["comment"] = "Failed to delete policy {}.".format(name)
                return ret
    r = __salt__["boto_iam.delete_policy"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r:
        ret["result"] = False
        ret["comment"] = "Failed to delete policy {}.".format(name)
        return ret
    ret["changes"]["old"] = {"policy": name}
    ret["changes"]["new"] = {"policy": None}
    ret["comment"] = "Policy {} deleted.".format(name)
    return ret
def saml_provider_present(
    name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if "salt://" in saml_metadata_document:
        try:
            saml_metadata_document = __salt__["cp.get_file_str"](saml_metadata_document)
            ET.fromstring(saml_metadata_document)
        except OSError as e:
            log.debug(e)
            ret[
                "comment"
            ] = "SAML document file {} not found or could not be loaded".format(name)
            ret["result"] = False
            return ret
    for provider in __salt__["boto_iam.list_saml_providers"](
        region=region, key=key, keyid=keyid, profile=profile
    ):
        if provider == name:
            ret["comment"] = "SAML provider {} is present.".format(name)
            return ret
    if __opts__["test"]:
        ret["comment"] = "SAML provider {} is set to be create.".format(name)
        ret["result"] = None
        return ret
    created = __salt__["boto_iam.create_saml_provider"](
        name,
        saml_metadata_document,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if created:
        ret["comment"] = "SAML provider {} was created.".format(name)
        ret["changes"]["new"] = name
        return ret
    ret["result"] = False
    ret["comment"] = "SAML provider {} failed to be created.".format(name)
    return ret
def saml_provider_absent(name, region=None, key=None, keyid=None, profile=None):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    provider = __salt__["boto_iam.list_saml_providers"](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if len(provider) == 0:
        ret["comment"] = "SAML provider {} is absent.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "SAML provider {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_saml_provider"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if deleted is not False:
        ret["comment"] = "SAML provider {} was deleted.".format(name)
        ret["changes"]["old"] = name
        return ret
    ret["result"] = False
    ret["comment"] = "SAML provider {} failed to be deleted.".format(name)
    return ret
def _get_error(error):
    error = "\n".join(error.split("\n")[1:])
    error = ET.fromstring(error)
    code = error[0][1].text
    message = error[0][2].text
    return code, message
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
