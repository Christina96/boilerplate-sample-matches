<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for saltmod.py & boto_iam.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for saltmod.py & boto_iam.py
      </h3>
      <h1 align="center">
        3.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>saltmod.py (6.0851927%)<TH>boto_iam.py (2.144389%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match109136-0.html#0',2,'match109136-1.html#0',3)" NAME="0">(97-117)<TD><A HREF="javascript:ZweiFrames('match109136-0.html#0',2,'match109136-1.html#0',3)" NAME="0">(1484-1557)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match109136-0.html#1',2,'match109136-1.html#1',3)" NAME="1">(445-519)<TD><A HREF="javascript:ZweiFrames('match109136-0.html#1',2,'match109136-1.html#1',3)" NAME="1">(1045-1108)</A><TD ALIGN=center><FONT COLOR="#e20000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match109136-0.html#2',2,'match109136-1.html#2',3)" NAME="2">(25-42)<TD><A HREF="javascript:ZweiFrames('match109136-0.html#2',2,'match109136-1.html#2',3)" NAME="2">(133-149)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match109136-0.html#3',2,'match109136-1.html#3',3)" NAME="3">(376-382)<TD><A HREF="javascript:ZweiFrames('match109136-0.html#3',2,'match109136-1.html#3',3)" NAME="3">(1560-1565)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>saltmod.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Control the Salt command interface
==================================

This state is intended for use from the Salt Master. It provides access to
sending commands down to minions as well as access to executing master-side
modules. These state functions wrap Salt's :ref:`Python API &lt;python-api&gt;`.

    .. versionadded:: 2016.11.0

    Support for masterless minions was added to the ``salt.state`` function,
    so they can run orchestration sls files. This is particularly useful when
    the rendering of a state is dependent on the execution of another state.
    Orchestration will render and execute each orchestration block
    independently, while honoring requisites to ensure the states are applied
    in the correct order.

.. seealso:: More Orchestrate documentation

    * :ref:`Full Orchestrate Tutorial &lt;orchestrate-runner&gt;`
    * :py:func:`The Orchestrate runner &lt;salt.runners.state.orchestrate&gt;`
<A NAME="2"></A>&quot;&quot;&quot;

import fnmatch
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match109136-1.html#2',3,'match109136-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import logging
import sys
import threading
import time

import salt.exceptions
import salt.output
import salt.syspaths
import salt.utils.data
import salt.utils.event

log = logging.getLogger(__name__)

# Define the module's virtual name
__virtualname__ = &quot;salt&quot;


def</B></FONT> __virtual__():
    &quot;&quot;&quot;
    Named salt
    &quot;&quot;&quot;
    return __virtualname__


def _fire_args(tag_data):
    try:
        salt.utils.event.fire_args(__opts__, __orchestration_jid__, tag_data, &quot;run&quot;)
    except NameError:
        log.debug(&quot;Unable to fire args event due to missing __orchestration_jid__&quot;)


def _parallel_map(func, inputs):
    &quot;&quot;&quot;
    Applies a function to each element of a list, returning the resulting list.

    A separate thread is created for each element in the input list and the
    passed function is called for each of the elements. When all threads have
    finished execution a list with the results corresponding to the inputs is
    returned.

    If one of the threads fails (because the function throws an exception),
    that exception is reraised. If more than one thread fails, the exception
    from the first thread (according to the index of the input element) is
    reraised.

    func:
        function that is applied on each input element.
    inputs:
        list of elements that shall be processed. The length of this list also
        defines the number of threads created.
    &quot;&quot;&quot;
    outputs = len(inputs) * [None]
    errors = len(inputs) * [None]

    def create_thread(index):
        def run_thread():
            try:
                outputs[index] = func(inputs[index])
            except:  # pylint: disable=bare-except
                errors[index] = sys.exc_info()

        thread = threading.Thread(target=run_thread)
        thread.start()
        return thread

    threads = list(map(create_thread, range(len(inputs))))
    for thread in threads:
        thread.join()
    for error in errors:
<A NAME="0"></A>        if error is not None:
            exc_type, exc_value, exc_traceback = error
            raise exc_value.with_traceback(exc_traceback)
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match109136-1.html#0',3,'match109136-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return outputs


def state(
    name,
    tgt,
    ssh=False,
    tgt_type=&quot;glob&quot;,
    ret=&quot;&quot;,
    ret_config=None,
    ret_kwargs=None,
    highstate=None,
    sls=None,
    top=None,
    saltenv=None,
    test=None,
    pillar=None,
    pillarenv=None,
    expect_minions=True,
    exclude=None,
    fail_minions=</B></FONT>None,
    allow_fail=0,
    concurrent=False,
    timeout=None,
    batch=None,
    queue=False,
    subset=None,
    orchestration_jid=None,
    failhard=None,
    **kwargs
):
    &quot;&quot;&quot;
    Invoke a state run on a given target

    name
        An arbitrary name used to track the state execution

    tgt
        The target specification for the state run.

        .. versionadded:: 2016.11.0

        Masterless support: When running on a masterless minion, the ``tgt``
        is ignored and will always be the local minion.

    tgt_type
        The target type to resolve, defaults to ``glob``

    ret
        Optionally set a single or a list of returners to use

    ret_config
        Use an alternative returner configuration

    ret_kwargs
        Override individual returner configuration items

    highstate
        Defaults to None, if set to True the target systems will ignore any
        sls references specified in the sls option and call state.highstate
        on the targeted minions

    top
        Should be the name of a top file. If set state.top is called with this
        top file instead of state.sls.

    sls
        A group of sls files to execute. This can be defined as a single string
        containing a single sls file, or a list of sls files

    test
        Pass ``test=true`` or ``test=false`` through to the state function. This
        can be used to override a test mode set in the minion's config file. If
        left as the default of None and the 'test' mode is supplied on the
        command line, that value is passed instead.

    pillar
        Pass the ``pillar`` kwarg through to the state function

    pillarenv
        The pillar environment to grab pillars from

        .. versionadded:: 2017.7.0

    saltenv
        The default salt environment to pull sls files from

    ssh
        Set to `True` to use the ssh client instead of the standard salt client

    roster
        In the event of using salt-ssh, a roster system can be set

    expect_minions
        An optional boolean for failing if some minions do not respond

    fail_minions
        An optional list of targeted minions where failure is an option

    allow_fail
        Pass in the number of minions to allow for failure before setting
        the result of the execution to False

    exclude
        Pass exclude kwarg to state

    concurrent
        Allow multiple state runs to occur at once.

        WARNING: This flag is potentially dangerous. It is designed
        for use when multiple state runs can safely be run at the same
        Do not use this flag for performance optimization.

    queue
        Pass ``queue=true`` through to the state function

    batch
        Execute the command :ref:`in batches &lt;targeting-batch&gt;`. E.g.: ``10%``.

        .. versionadded:: 2016.3.0

    subset
        Number of minions from the targeted set to randomly use

        .. versionadded:: 2017.7.0

    failhard
        pass failhard down to the executing state

        .. versionadded:: 2019.2.2

    Examples:

    Run a list of sls files via :py:func:`state.sls &lt;salt.state.sls&gt;` on target
    minions:

    .. code-block:: yaml

        webservers:
          salt.state:
            - tgt: 'web*'
            - sls:
              - apache
              - django
              - core
            - saltenv: prod

    Run sls file via :py:func:`state.sls &lt;salt.state.sls&gt;` on target
    minions with exclude:

    .. code-block:: yaml

        docker:
          salt.state:
            - tgt: 'docker*'
            - sls: docker
            - exclude: docker.swarm
            - saltenv: prod

    Run a full :py:func:`state.highstate &lt;salt.state.highstate&gt;` on target
    mininons.

    .. code-block:: yaml

        databases:
          salt.state:
            - tgt: role:database
            - tgt_type: grain
            - highstate: True
    &quot;&quot;&quot;
    cmd_kw = {&quot;arg&quot;: [], &quot;kwarg&quot;: {}, &quot;ret&quot;: ret, &quot;timeout&quot;: timeout}

    if ret_config:
        cmd_kw[&quot;ret_config&quot;] = ret_config

    if ret_kwargs:
        cmd_kw[&quot;ret_kwargs&quot;] = ret_kwargs

    state_ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: True}

    try:
        allow_fail = int(allow_fail)
    except ValueError:
        state_ret[&quot;result&quot;] = False
        state_ret[&quot;comment&quot;] = &quot;Passed invalid value for 'allow_fail', must be an int&quot;
        return state_ret

    cmd_kw[&quot;tgt_type&quot;] = tgt_type
    cmd_kw[&quot;ssh&quot;] = ssh
    if &quot;roster&quot; in kwargs:
        cmd_kw[&quot;roster&quot;] = kwargs[&quot;roster&quot;]
    cmd_kw[&quot;expect_minions&quot;] = expect_minions
    if highstate:
        fun = &quot;state.highstate&quot;
    elif top:
        fun = &quot;state.top&quot;
        cmd_kw[&quot;arg&quot;].append(top)
    elif sls:
        fun = &quot;state.sls&quot;
        if isinstance(sls, list):
            sls = &quot;,&quot;.join(sls)
        cmd_kw[&quot;arg&quot;].append(sls)
    else:
        state_ret[&quot;comment&quot;] = &quot;No highstate or sls specified, no execution made&quot;
        state_ret[&quot;result&quot;] = False
        return state_ret

    if test is not None or __opts__.get(&quot;test&quot;):
        cmd_kw[&quot;kwarg&quot;][&quot;test&quot;] = test if test is not None else __opts__.get(&quot;test&quot;)

    if pillar:
        cmd_kw[&quot;kwarg&quot;][&quot;pillar&quot;] = pillar

    if pillarenv is not None:
        cmd_kw[&quot;kwarg&quot;][&quot;pillarenv&quot;] = pillarenv

    if saltenv is not None:
        cmd_kw[&quot;kwarg&quot;][&quot;saltenv&quot;] = saltenv

    if exclude is not None:
        cmd_kw[&quot;kwarg&quot;][&quot;exclude&quot;] = exclude

    cmd_kw[&quot;kwarg&quot;][&quot;queue&quot;] = queue

    if isinstance(concurrent, bool):
        cmd_kw[&quot;kwarg&quot;][&quot;concurrent&quot;] = concurrent
    else:
        state_ret[&quot;comment&quot;] = &quot;Must pass in boolean for value of 'concurrent'&quot;
        state_ret[&quot;result&quot;] = False
        return state_ret

    if batch is not None:
        cmd_kw[&quot;batch&quot;] = str(batch)

    if subset is not None:
        cmd_kw[&quot;subset&quot;] = subset

    if failhard is True or __opts__.get(&quot;failhard&quot;):
        cmd_kw[&quot;failhard&quot;] = True

    masterless = __opts__[&quot;__role&quot;] == &quot;minion&quot; and __opts__[&quot;file_client&quot;] == &quot;local&quot;
    if not masterless:
        _fire_args({&quot;type&quot;: &quot;state&quot;, &quot;tgt&quot;: tgt, &quot;name&quot;: name, &quot;args&quot;: cmd_kw})
        cmd_ret = __salt__[&quot;saltutil.cmd&quot;](tgt, fun, **cmd_kw)
    else:
        if top:
            cmd_kw[&quot;topfn&quot;] = &quot;&quot;.join(cmd_kw.pop(&quot;arg&quot;))
        elif sls:
            cmd_kw[&quot;mods&quot;] = &quot;&quot;.join(cmd_kw.pop(&quot;arg&quot;))
        cmd_kw.update(cmd_kw.pop(&quot;kwarg&quot;))
        tmp_ret = __salt__[fun](**cmd_kw)
        cmd_ret = {
            __opts__[&quot;id&quot;]: {
                &quot;ret&quot;: tmp_ret,
                &quot;out&quot;: tmp_ret.get(&quot;out&quot;, &quot;highstate&quot;)
                if isinstance(tmp_ret, dict)
                else &quot;highstate&quot;,
            }
        }

    try:
        state_ret[&quot;__jid__&quot;] = cmd_ret[next(iter(cmd_ret))][&quot;jid&quot;]
    except (StopIteration, KeyError):
        pass

    changes = {}
    fail = set()
    no_change = set()

    if fail_minions is None:
        fail_minions = ()
    elif isinstance(fail_minions, str):
        fail_minions = [minion.strip() for minion in fail_minions.split(&quot;,&quot;)]
    elif not isinstance(fail_minions, list):
        state_ret.setdefault(&quot;warnings&quot;, []).append(
            &quot;'fail_minions' needs to be a list or a comma separated string. Ignored.&quot;
<A NAME="3"></A>        )
        fail_minions = ()

    <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match109136-1.html#3',3,'match109136-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>if not cmd_ret and expect_minions:
        state_ret[&quot;result&quot;] = False
        state_ret[&quot;comment&quot;] = &quot;No minions returned&quot;
        return state_ret

    for minion, mdata in cmd_ret.items():
        if mdata.</B></FONT>get(&quot;out&quot;, &quot;&quot;) != &quot;highstate&quot;:
            log.warning(&quot;Output from salt state not highstate&quot;)

        m_ret = False

        if &quot;return&quot; in mdata and &quot;ret&quot; not in mdata:
            mdata[&quot;ret&quot;] = mdata.pop(&quot;return&quot;)

        m_state = True
        if mdata.get(&quot;failed&quot;, False):
            m_state = False
        else:
            try:
                m_ret = mdata[&quot;ret&quot;]
            except KeyError:
                m_state = False
            if m_state:
                m_state = __utils__[&quot;state.check_result&quot;](m_ret, recurse=True)

        if not m_state:
            if minion not in fail_minions:
                fail.add(minion)
            changes[minion] = m_ret
            continue
        try:
            for state_item in m_ret.values():
                if isinstance(state_item, dict):
                    if &quot;changes&quot; in state_item and state_item[&quot;changes&quot;]:
                        changes[minion] = m_ret
                        break
            else:
                no_change.add(minion)
        except AttributeError:
            log.error(&quot;m_ret did not have changes %s %s&quot;, type(m_ret), m_ret)
            no_change.add(minion)

    if changes:
        state_ret[&quot;changes&quot;] = {&quot;out&quot;: &quot;highstate&quot;, &quot;ret&quot;: changes}
    if len(fail) &gt; allow_fail:
        state_ret[&quot;result&quot;] = False
        state_ret[&quot;comment&quot;] = &quot;Run failed on minions: {}&quot;.format(&quot;, &quot;.join(fail))
    else:
        state_ret[&quot;comment&quot;] = &quot;States ran successfully.&quot;
        if changes:
            state_ret[&quot;comment&quot;] += &quot; Updating {}.&quot;.format(&quot;, &quot;.join(changes))
        if no_change:
            state_ret[&quot;comment&quot;] += &quot; No changes made to {}.&quot;.format(
                &quot;, &quot;.join(no_change)
            )
    if test or __opts__.get(&quot;test&quot;):
        if state_ret[&quot;changes&quot;] and state_ret[&quot;result&quot;] is True:
            # Test mode with changes is the only case where result should ever be none
            state_ret[&quot;result&quot;] = None
    return state_ret


def function(
    name,
    tgt,
    ssh=False,
<A NAME="1"></A>    tgt_type=&quot;glob&quot;,
    ret=&quot;&quot;,
    ret_config=None,
    ret_kwargs<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match109136-1.html#1',3,'match109136-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=None,
    expect_minions=False,
    fail_minions=None,
    fail_function=None,
    arg=None,
    kwarg=None,
    timeout=None,
    batch=None,
    subset=None,
    failhard=None,
    **kwargs
):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    Execute a single module function on a remote minion via salt or salt-ssh

    name
        The name of the function to run, aka cmd.run or pkg.install

    tgt
        The target specification, aka '*' for all minions

    tgt_type
        The target type, defaults to ``glob``

    arg
        The list of arguments to pass into the function

    kwarg
        The dict (not a list) of keyword arguments to pass into the function

    ret
        Optionally set a single or a list of returners to use

    ret_config
        Use an alternative returner configuration

    ret_kwargs
        Override individual returner configuration items

    expect_minions
        An optional boolean for failing if some minions do not respond

    fail_minions
        An optional list of targeted minions where failure is an option

    fail_function
        An optional string that points to a salt module that returns True or False
        based on the returned data dict for individual minions

    ssh
        Set to `True` to use the ssh client instead of the standard salt client

    roster
        In the event of using salt-ssh, a roster system can be set

        .. versionadded:: 3005

    batch
        Execute the command :ref:`in batches &lt;targeting-batch&gt;`. E.g.: ``10%``.

    subset
        Number of minions from the targeted set to randomly use

        .. versionadded:: 2017.7.0

    failhard
        pass failhard down to the executing state

        .. versionadded:: 2019.2.2

    &quot;&quot;&quot;
    func_ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: True}
    if kwarg is None:
        kwarg = {}
    if</B></FONT> isinstance(arg, str):
        func_ret[&quot;warnings&quot;] = [&quot;Please specify 'arg' as a list of arguments.&quot;]
        arg = arg.split()

    cmd_kw = {&quot;arg&quot;: arg or [], &quot;kwarg&quot;: kwarg, &quot;ret&quot;: ret, &quot;timeout&quot;: timeout}

    if batch is not None:
        cmd_kw[&quot;batch&quot;] = str(batch)
    if subset is not None:
        cmd_kw[&quot;subset&quot;] = subset

    cmd_kw[&quot;tgt_type&quot;] = tgt_type
    cmd_kw[&quot;ssh&quot;] = ssh
    if &quot;roster&quot; in kwargs:
        cmd_kw[&quot;roster&quot;] = kwargs[&quot;roster&quot;]
    cmd_kw[&quot;expect_minions&quot;] = expect_minions
    cmd_kw[&quot;_cmd_meta&quot;] = True

    if failhard is True or __opts__.get(&quot;failhard&quot;):
        cmd_kw[&quot;failhard&quot;] = True

    if ret_config:
        cmd_kw[&quot;ret_config&quot;] = ret_config

    if ret_kwargs:
        cmd_kw[&quot;ret_kwargs&quot;] = ret_kwargs

    fun = name
    if __opts__[&quot;test&quot;] is True:
        func_ret[&quot;comment&quot;] = &quot;Function {} would be executed on target {}&quot;.format(
            fun, tgt
        )
        func_ret[&quot;result&quot;] = None
        return func_ret
    try:
        _fire_args({&quot;type&quot;: &quot;function&quot;, &quot;tgt&quot;: tgt, &quot;name&quot;: name, &quot;args&quot;: cmd_kw})
        cmd_ret = __salt__[&quot;saltutil.cmd&quot;](tgt, fun, **cmd_kw)
    except Exception as exc:  # pylint: disable=broad-except
        func_ret[&quot;result&quot;] = False
        func_ret[&quot;comment&quot;] = str(exc)
        return func_ret

    try:
        func_ret[&quot;__jid__&quot;] = cmd_ret[next(iter(cmd_ret))][&quot;jid&quot;]
    except (StopIteration, KeyError):
        pass

    changes = {}
    fail = set()

    if fail_minions is None:
        fail_minions = ()
    elif isinstance(fail_minions, str):
        fail_minions = [minion.strip() for minion in fail_minions.split(&quot;,&quot;)]
    elif not isinstance(fail_minions, list):
        func_ret.setdefault(&quot;warnings&quot;, []).append(
            &quot;'fail_minions' needs to be a list or a comma separated string. Ignored.&quot;
        )
        fail_minions = ()
    for minion, mdata in cmd_ret.items():
        m_ret = False
        if mdata.get(&quot;retcode&quot;):
            func_ret[&quot;result&quot;] = False
            fail.add(minion)
        if mdata.get(&quot;failed&quot;, False):
            m_func = False
        else:
            if &quot;return&quot; in mdata and &quot;ret&quot; not in mdata:
                mdata[&quot;ret&quot;] = mdata.pop(&quot;return&quot;)
            m_ret = mdata[&quot;ret&quot;]
            m_func = (not fail_function and True) or __salt__[fail_function](m_ret)

            if m_ret is False:
                m_func = False

        if not m_func:
            if minion not in fail_minions:
                fail.add(minion)
        changes[minion] = m_ret
    if not cmd_ret:
        func_ret[&quot;result&quot;] = False
        func_ret[&quot;comment&quot;] = &quot;No minions responded&quot;
    else:
        if changes:
            func_ret[&quot;changes&quot;] = {&quot;ret&quot;: changes}
        if fail:
            func_ret[&quot;result&quot;] = False
            func_ret[&quot;comment&quot;] = &quot;Running function {} failed on minions: {}&quot;.format(
                name, &quot;, &quot;.join(fail)
            )
        else:
            func_ret[&quot;comment&quot;] = &quot;Function ran successfully.&quot;
        if changes:
            func_ret[&quot;comment&quot;] += &quot; Function {} ran on {}.&quot;.format(
                name, &quot;, &quot;.join(changes)
            )
    return func_ret


def wait_for_event(name, id_list, event_id=&quot;id&quot;, timeout=300, node=&quot;master&quot;):
    &quot;&quot;&quot;
    Watch Salt's event bus and block until a condition is met

    .. versionadded:: 2014.7.0

    name
        An event tag to watch for; supports Reactor-style globbing.
    id_list
        A list of event identifiers to watch for -- usually the minion ID. Each
        time an event tag is matched the event data is inspected for
        ``event_id``, if found it is removed from ``id_list``. When ``id_list``
        is empty this function returns success.
    event_id : id
        The name of a key in the event data. Default is ``id`` for the minion
        ID, another common value is ``name`` for use with orchestrating
        salt-cloud events.
    timeout : 300
        The maximum time in seconds to wait before failing.

    The following example blocks until all the listed minions complete a
    restart and reconnect to the Salt master:

    .. code-block:: yaml

        reboot_all_minions:
          salt.function:
            - name: system.reboot
            - tgt: '*'

        wait_for_reboots:
          salt.wait_for_event:
            - name: salt/minion/*/start
            - id_list:
              - jerry
              - stuart
              - dave
              - phil
              - kevin
              - mike
            - require:
              - salt: reboot_all_minions
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: False}

    if __opts__.get(&quot;test&quot;):
        ret[&quot;comment&quot;] = &quot;Orchestration would wait for event '{}'&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret

    with salt.utils.event.get_event(
        node, __opts__[&quot;sock_dir&quot;], opts=__opts__, listen=True
    ) as sevent:

        del_counter = 0
        starttime = time.time()
        timelimit = starttime + timeout
        while True:
            event = sevent.get_event(full=True)
            is_timedout = time.time() &gt; timelimit

            if event is None and not is_timedout:
                log.trace(&quot;wait_for_event: No event data; waiting.&quot;)
                continue
            elif event is None and is_timedout:
                ret[&quot;comment&quot;] = &quot;Timeout value reached.&quot;
                return ret

            if fnmatch.fnmatch(event[&quot;tag&quot;], name):
                val = event[&quot;data&quot;].get(event_id)
                if val is None and &quot;data&quot; in event[&quot;data&quot;]:
                    val = event[&quot;data&quot;][&quot;data&quot;].get(event_id)

                if val is not None:
                    try:
                        val_idx = id_list.index(val)
                    except ValueError:
                        log.trace(
                            &quot;wait_for_event: Event identifier '%s' not in &quot;
                            &quot;id_list; skipping.&quot;,
                            event_id,
                        )
                    else:
                        del id_list[val_idx]
                        del_counter += 1
                        minions_seen = ret[&quot;changes&quot;].setdefault(&quot;minions_seen&quot;, [])
                        minions_seen.append(val)

                        log.debug(
                            &quot;wait_for_event: Event identifier '%s' removed &quot;
                            &quot;from id_list; %s items remaining.&quot;,
                            val,
                            len(id_list),
                        )
                else:
                    log.trace(
                        &quot;wait_for_event: Event identifier '%s' not in event &quot;
                        &quot;'%s'; skipping.&quot;,
                        event_id,
                        event[&quot;tag&quot;],
                    )
            else:
                log.debug(&quot;wait_for_event: Skipping unmatched event '%s'&quot;, event[&quot;tag&quot;])

            if len(id_list) == 0:
                ret[&quot;result&quot;] = True
                ret[&quot;comment&quot;] = &quot;All events seen in {} seconds.&quot;.format(
                    time.time() - starttime
                )
                return ret

            if is_timedout:
                ret[&quot;comment&quot;] = &quot;Timeout value reached.&quot;
                return ret


def runner(name, **kwargs):
    &quot;&quot;&quot;
    Execute a runner module on the master

    .. versionadded:: 2014.7.0

    name
        The name of the function to run
    kwargs
        Any keyword arguments to pass to the runner function

    .. code-block:: yaml

         run-manage-up:
          salt.runner:
            - name: manage.up
    &quot;&quot;&quot;
    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug(&quot;Unable to fire args event due to missing __orchestration_jid__&quot;)
        jid = None

    if __opts__.get(&quot;test&quot;, False):
        ret = {
            &quot;name&quot;: name,
            &quot;result&quot;: None,
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;Runner function '{}' would be executed.&quot;.format(name),
        }
        return ret

    out = __salt__[&quot;saltutil.runner&quot;](
        name, __orchestration_jid__=jid, __env__=__env__, full_return=True, **kwargs
    )

    runner_return = out.get(&quot;return&quot;)
    if isinstance(runner_return, dict) and &quot;Error&quot; in runner_return:
        out[&quot;success&quot;] = False

    success = out.get(&quot;success&quot;, True)
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {&quot;return&quot;: runner_return}, &quot;result&quot;: success}
    ret[&quot;comment&quot;] = &quot;Runner function '{}' {}.&quot;.format(
        name,
        &quot;executed&quot; if success else &quot;failed&quot;,
    )

    ret[&quot;__orchestration__&quot;] = True
    if &quot;jid&quot; in out:
        ret[&quot;__jid__&quot;] = out[&quot;jid&quot;]

    return ret


def parallel_runners(name, runners, **kwargs):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    Executes multiple runner modules on the master in parallel.

    .. versionadded:: 2018.3.0

    A separate thread is spawned for each runner. This state is intended to be
    used with the orchestrate runner in place of the ``saltmod.runner`` state
    when different tasks should be run in parallel. In general, Salt states are
    not safe when used concurrently, so ensure that they are used in a safe way
    (e.g. by only targeting separate minions in parallel tasks).

    name:
        name identifying this state. The name is provided as part of the
        output, but not used for anything else.

    runners:
        list of runners that should be run in parallel. Each element of the
        list has to be a dictionary. This dictionary's name entry stores the
        name of the runner function that shall be invoked. The optional kwarg
        entry stores a dictionary of named arguments that are passed to the
        runner function.

    .. code-block:: yaml

        parallel-state:
           salt.parallel_runners:
             - runners:
                 my_runner_1:
                   - name: state.orchestrate
                   - kwarg:
                       mods: orchestrate_state_1
                 my_runner_2:
                   - name: state.orchestrate
                   - kwarg:
                       mods: orchestrate_state_2
    &quot;&quot;&quot;
    # For the sake of consistency, we treat a single string in the same way as
    # a key without a value. This allows something like
    #     salt.parallel_runners:
    #       - runners:
    #           state.orchestrate
    # Obviously, this will only work if the specified runner does not need any
    # arguments.
    if isinstance(runners, str):
        runners = {runners: [{name: runners}]}
    # If the runners argument is not a string, it must be a dict. Everything
    # else is considered an error.
    if not isinstance(runners, dict):
        return {
            &quot;name&quot;: name,
            &quot;result&quot;: False,
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;The runners parameter must be a string or dict.&quot;,
        }
    # The configuration for each runner is given as a list of key-value pairs.
    # This is not very useful for what we want to do, but it is the typical
    # style used in Salt. For further processing, we convert each of these
    # lists to a dict. This also makes it easier to check whether a name has
    # been specified explicitly.
    for runner_id, runner_config in runners.items():
        if runner_config is None:
            runner_config = {}
        else:
            runner_config = salt.utils.data.repack_dictlist(runner_config)
        if &quot;name&quot; not in runner_config:
            runner_config[&quot;name&quot;] = runner_id
        runners[runner_id] = runner_config

    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug(&quot;Unable to fire args event due to missing __orchestration_jid__&quot;)
        jid = None

    def call_runner(runner_config):
        return __salt__[&quot;saltutil.runner&quot;](
            runner_config[&quot;name&quot;],
            __orchestration_jid__=jid,
            __env__=__env__,
            full_return=True,
            **(runner_config.get(&quot;kwarg&quot;, {}))
        )

    try:
        outputs = _parallel_map(call_runner, list(runners.values()))
    except salt.exceptions.SaltException as exc:
        return {
            &quot;name&quot;: name,
            &quot;result&quot;: False,
            &quot;success&quot;: False,
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;One of the runners raised an exception: {}&quot;.format(exc),
        }
    # We bundle the results of the runners with the IDs of the runners so that
    # we can easily identify which output belongs to which runner. At the same
    # time we exctract the actual return value of the runner (saltutil.runner
    # adds some extra information that is not interesting to us).
    outputs = {
        runner_id: out[&quot;return&quot;] for runner_id, out in zip(runners.keys(), outputs)
    }

    # If each of the runners returned its output in the format compatible with
    # the 'highstate' outputter, we can leverage this fact when merging the
    # outputs.
    highstate_output = all(
        [
            out.get(&quot;outputter&quot;, &quot;&quot;) == &quot;highstate&quot; and &quot;data&quot; in out
            for out in outputs.values()
        ]
    )

    # The following helper function is used to extract changes from highstate
    # output.

    def extract_changes(obj):
        if not isinstance(obj, dict):
            return {}
        elif &quot;changes&quot; in obj:
            if (
                isinstance(obj[&quot;changes&quot;], dict)
                and obj[&quot;changes&quot;].get(&quot;out&quot;, &quot;&quot;) == &quot;highstate&quot;
                and &quot;ret&quot; in obj[&quot;changes&quot;]
            ):
                return obj[&quot;changes&quot;][&quot;ret&quot;]
            else:
                return obj[&quot;changes&quot;]
        else:
            found_changes = {}
            for key, value in obj.items():
                change = extract_changes(value)
                if change:
                    found_changes[key] = change
            return found_changes

    if highstate_output:
        failed_runners = [
            runner_id
            for runner_id, out in outputs.items()
            if out[&quot;data&quot;].get(&quot;retcode&quot;, 0) != 0
        ]
        all_successful = not failed_runners
        if all_successful:
            comment = &quot;All runner functions executed successfully.&quot;
        else:
            runner_comments = [
                &quot;Runner {} failed with return value:\n{}&quot;.format(
                    runner_id,
                    salt.output.out_format(
                        outputs[runner_id], &quot;nested&quot;, __opts__, nested_indent=2
                    ),
                )
                for runner_id in failed_runners
            ]
            comment = &quot;\n&quot;.join(runner_comments)
        changes = {}
        for runner_id, out in outputs.items():
            runner_changes = extract_changes(out[&quot;data&quot;])
            if runner_changes:
                changes[runner_id] = runner_changes
    else:
        failed_runners = [
            runner_id
            for runner_id, out in outputs.items()
            if out.get(&quot;exit_code&quot;, 0) != 0
        ]
        all_successful = not failed_runners
        if all_successful:
            comment = &quot;All runner functions executed successfully.&quot;
        else:
            if len(failed_runners) == 1:
                comment = &quot;Runner {} failed.&quot;.format(failed_runners[0])
            else:
                comment = &quot;Runners {} failed.&quot;.format(&quot;, &quot;.join(failed_runners))
        changes = {&quot;ret&quot;: {runner_id: out for runner_id, out in outputs.items()}}
    ret = {
        &quot;name&quot;: name,
        &quot;result&quot;: all_successful,
        &quot;changes&quot;: changes,
        &quot;comment&quot;: comment,
    }

    # The 'runner' function includes out['jid'] as '__jid__' in the returned
    # dict, but we cannot do this here because we have more than one JID if
    # we have more than one runner.

    return ret


def wheel(name, **kwargs):
    &quot;&quot;&quot;
    Execute a wheel module on the master

    .. versionadded:: 2014.7.0

    name
        The name of the function to run
    kwargs
        Any keyword arguments to pass to the wheel function

    .. code-block:: yaml

        accept_minion_key:
          salt.wheel:
            - name: key.accept
            - match: frank
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;}
    try:
        jid = __orchestration_jid__
    except NameError:
        log.debug(&quot;Unable to fire args event due to missing __orchestration_jid__&quot;)
        jid = None

    if __opts__.get(&quot;test&quot;, False):
        ret[&quot;result&quot;] = (None,)
        ret[&quot;changes&quot;] = {}
        ret[&quot;comment&quot;] = &quot;Wheel function '{}' would be executed.&quot;.format(name)
        return ret

    out = __salt__[&quot;saltutil.wheel&quot;](
        name, __orchestration_jid__=jid, __env__=__env__, **kwargs
    )

    wheel_return = out.get(&quot;return&quot;)
    if isinstance(wheel_return, dict) and &quot;Error&quot; in wheel_return:
        out[&quot;success&quot;] = False

    success = out.get(&quot;success&quot;, True)
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {&quot;return&quot;: wheel_return}, &quot;result&quot;: success}
    ret[&quot;comment&quot;] = &quot;Wheel function '{}' {}.&quot;.format(
        name,
        &quot;executed&quot; if success else &quot;failed&quot;,
    )

    ret[&quot;__orchestration__&quot;] = True
    if &quot;jid&quot; in out:
        ret[&quot;__jid__&quot;] = out[&quot;jid&quot;]

    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage IAM objects
==================

.. versionadded:: 2015.8.0

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit IAM credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    delete-user:
      boto_iam.user_absent:
        - name: myuser
        - delete_keys: true


.. code-block:: yaml

    delete-keys:
      boto_iam.keys_absent:
        - access_keys:
          - 'AKIAJHTMIQ2ASDFLASDF'
          - 'PQIAJHTMIQ2ASRTLASFR'
        - user_name: myuser

.. code-block:: yaml

    create-user:
      boto_iam.user_present:
        - name: myuser
        - policies:
            mypolicy: |
                {
                    &quot;Version&quot;: &quot;2012-10-17&quot;,
                    &quot;Statement&quot;: [{
                    &quot;Effect&quot;: &quot;Allow&quot;,
                    &quot;Action&quot;: &quot;*&quot;,
                    &quot;Resource&quot;: &quot;*&quot;}]
                }
        - password: NewPassword$$1
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create-group:
      boto_iam.group_present:
        - name: mygroup
        - users:
          - myuser
          - myuser1
        - policies:
            mypolicy: |
                {
                    &quot;Version&quot;: &quot;2012-10-17&quot;,
                    &quot;Statement&quot;: [{
                    &quot;Effect&quot;: &quot;Allow&quot;,
                    &quot;Action&quot;: &quot;*&quot;,
                    &quot;Resource&quot;: &quot;*&quot;}]
                }
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    change-policy:
      boto_iam.account_policy:
        - change_password: True
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    create server certificate:
      boto_iam.server_cert_present:
        - name: mycert
        - public_key: salt://base/mycert.crt
        - private_key: salt://base/mycert.key
        - cert_chain: salt://base/mycert_chain.crt
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    delete server certificate:
      boto_iam.server_cert_absent:
        - name: mycert

.. code-block:: yaml

    create keys for user:
      boto_iam.keys_present:
        - name: myusername
        - number: 2
        - save_dir: /root
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create policy:
      boto_iam.policy_present:
        - name: myname
        - policy_document: '{&quot;MyPolicy&quot;: &quot;Statement&quot;: [{&quot;Action&quot;: [&quot;sqs:*&quot;], &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: [&quot;arn:aws:sqs:*:*:*&quot;], &quot;Sid&quot;: &quot;MyPolicySqs1&quot;}]}'
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    add-saml-provider:
      boto_iam.saml_provider_present:
        - name: my_saml_provider
        - saml_metadata_document: salt://base/files/provider.xml
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
<A NAME="2"></A>        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
&quot;&quot;&quot;

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match109136-0.html#2',2,'match109136-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import os
import xml.etree.ElementTree as ET

import salt.utils.data
import salt.utils.dictupdate as dictupdate
import salt.utils.files
import salt.utils.json
import salt.utils.odict as odict
import salt.utils.stringutils

log = logging.getLogger(__name__)

__virtualname__ = &quot;boto_iam&quot;


def</B></FONT> __virtual__():
    &quot;&quot;&quot;
    Only load if elementtree xml library and boto are available.
    &quot;&quot;&quot;
    if &quot;boto_iam.get_user&quot; in __salt__:
        return True
    else:
        return (
            False,
            &quot;Cannot load {} state: boto_iam module unavailable&quot;.format(__virtualname__),
        )


def user_absent(
    name,
    delete_keys=True,
    delete_mfa_devices=True,
    delete_profile=True,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user is absent. User cannot be deleted if it has keys.

    name (string)
        The name of the new user.

    delete_keys (bool)
        Delete all keys from user.

    delete_mfa_devices (bool)
        Delete all mfa devices from user.

        .. versionadded:: 2016.3.0

    delete_profile (bool)
        Delete profile from user.

        .. versionadded:: 2016.3.0

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(name)
        return ret
    # delete the user's access keys
    if delete_keys:
        keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        log.debug(&quot;Keys for user %s are %s.&quot;, name, keys)
        if isinstance(keys, dict):
            keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
                &quot;access_key_metadata&quot;
            ]
            for k in keys:
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;Key {} is set to be deleted.&quot;.format(k[&quot;access_key_id&quot;]),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    if _delete_key(
                        ret, k[&quot;access_key_id&quot;], name, region, key, keyid, profile
                    ):
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;Key {} has been deleted.&quot;.format(k[&quot;access_key_id&quot;]),
                            ]
                        )
                        ret[&quot;changes&quot;][k[&quot;access_key_id&quot;]] = &quot;deleted&quot;
    # delete the user's MFA tokens
    if delete_mfa_devices:
        devices = __salt__[&quot;boto_iam.get_all_mfa_devices&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        if devices:
            for d in devices:
                serial = d[&quot;serial_number&quot;]
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;IAM user {} MFA device {} is set to be deactivated.&quot;.format(
                                name, serial
                            ),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    mfa_deactivated = __salt__[&quot;boto_iam.deactivate_mfa_device&quot;](
                        user_name=name,
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deactivated:
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;IAM user {} MFA device {} is deactivated.&quot;.format(
                                    name, serial
                                ),
                            ]
                        )
                if __opts__[&quot;test&quot;]:
                    ret[&quot;comment&quot;] = &quot; &quot;.join(
                        [
                            ret[&quot;comment&quot;],
                            &quot;Virtual MFA device {} is set to be deleted.&quot;.format(
                                serial
                            ),
                        ]
                    )
                    ret[&quot;result&quot;] = None
                else:
                    mfa_deleted = __salt__[&quot;boto_iam.delete_virtual_mfa_device&quot;](
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deleted:
                        ret[&quot;comment&quot;] = &quot; &quot;.join(
                            [
                                ret[&quot;comment&quot;],
                                &quot;Virtual MFA device {} is deleted.&quot;.format(serial),
                            ]
                        )
    # delete the user's login profile
    if delete_profile:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;IAM user {} login profile is set to be deleted.&quot;.format(name),
                ]
            )
            ret[&quot;result&quot;] = None
        else:
            profile_deleted = __salt__[&quot;boto_iam.delete_login_profile&quot;](
                name, region, key, keyid, profile
            )
            if profile_deleted:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;IAM user {} login profile is deleted.&quot;.format(name),
                    ]
                )
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM user {} managed policies are set to be detached.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _user_policies_detached(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM user {} inline policies are set to be deleted.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _user_policies_deleted(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    # finally, actually delete the user
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM user {} is set to be deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_user&quot;](name, region, key, keyid, profile)
    if deleted is True:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM user {} is deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;deleted&quot;] = name
        return ret
    ret[&quot;comment&quot;] = &quot;IAM user {} could not be deleted.\n {}&quot;.format(name, deleted)
    ret[&quot;result&quot;] = False
    return ret


def keys_present(
    name,
    number,
    save_dir,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    save_format=&quot;{2}\n{0}\n{3}\n{1}\n&quot;,
):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Ensure the IAM access keys are present.

    name (string)
        The name of the new user.

    number (int)
        Number of keys that user should have.

    save_dir (string)
        The directory that the key/keys will be saved. Keys are saved to a file named according
        to the username privided.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.

    save_format (dict)
        Save format is repeated for each key. Default format is
        &quot;{2}\\n{0}\\n{3}\\n{1}\\n&quot;, where {0} and {1} are placeholders for new
        key_id and key respectively, whereas {2} and {3} are &quot;key_id-{number}&quot;
        and 'key-{number}' strings kept for compatibility.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(name)
        return ret
    if not isinstance(number, int):
        ret[&quot;comment&quot;] = &quot;The number of keys must be an integer.&quot;
        ret[&quot;result&quot;] = False
        return ret
    if not os.path.isdir(save_dir):
        ret[&quot;comment&quot;] = &quot;The directory {} does not exist.&quot;.format(save_dir)
        ret[&quot;result&quot;] = False
        return ret
    keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if isinstance(keys, str):
        log.debug(&quot;keys are : false %s&quot;, keys)
        error, message = _get_error(keys)
        ret[&quot;comment&quot;] = &quot;Could not get keys.\n{}\n{}&quot;.format(error, message)
        ret[&quot;result&quot;] = False
        return ret
    keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
        &quot;access_key_metadata&quot;
    ]
    log.debug(&quot;Keys are : %s.&quot;, keys)
    if len(keys) &gt;= number:
        ret[&quot;comment&quot;] = &quot;The number of keys exist for user {}&quot;.format(name)
        ret[&quot;result&quot;] = True
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Access key is set to be created for {}.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    new_keys = {}
    for i in range(number - len(keys)):
        created = __salt__[&quot;boto_iam.create_access_key&quot;](
            name, region, key, keyid, profile
        )
        if isinstance(created, str):
            error, message = _get_error(created)
            ret[&quot;comment&quot;] = &quot;Could not create keys.\n{}\n{}&quot;.format(error, message)
            ret[&quot;result&quot;] = False
            return ret
        log.debug(&quot;Created is : %s&quot;, created)
        response = &quot;create_access_key_response&quot;
        result = &quot;create_access_key_result&quot;
        new_keys[str(i)] = {}
        new_keys[str(i)][&quot;key_id&quot;] = created[response][result][&quot;access_key&quot;][
            &quot;access_key_id&quot;
        ]
        new_keys[str(i)][&quot;secret_key&quot;] = created[response][result][&quot;access_key&quot;][
            &quot;secret_access_key&quot;
        ]
    try:
        with salt.utils.files.fopen(&quot;{}/{}&quot;.format(save_dir, name), &quot;a&quot;) as _wrf:
            for key_num, key in new_keys.items():
                key_id = key[&quot;key_id&quot;]
                secret_key = key[&quot;secret_key&quot;]
                _wrf.write(
                    salt.utils.stringutils.to_str(
                        save_format.format(
                            key_id,
                            secret_key,
                            &quot;key_id-{}&quot;.format(key_num),
                            &quot;key-{}&quot;.format(key_num),
                        )
                    )
                )
        ret[&quot;comment&quot;] = &quot;Keys have been written to file {}/{}.&quot;.format(save_dir, name)
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;] = new_keys
        return ret
    except OSError:
        ret[&quot;comment&quot;] = &quot;Could not write to file {}/{}.&quot;.format(save_dir, name)
        ret[&quot;result&quot;] = False
        return ret


def keys_absent(
    access_keys, user_name, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user access_key_id is absent.

    access_key_id (list)
        A list of access key ids

    user_name (string)
        The username of the user

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: access_keys, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_user&quot;](user_name, region, key, keyid, profile):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;IAM User {} does not exist.&quot;.format(user_name)
        return ret
    for k in access_keys:
        ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
    return ret


def _delete_key(
    ret, access_key_id, user_name, region=None, key=None, keyid=None, profile=None
):
    keys = __salt__[&quot;boto_iam.get_all_access_keys&quot;](
        user_name=user_name, region=region, key=key, keyid=keyid, profile=profile
    )
    log.debug(&quot;Keys for user %s are : %s.&quot;, keys, user_name)
    if isinstance(keys, str):
        log.debug(&quot;Keys %s are a string. Something went wrong.&quot;, keys)
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Key {} could not be deleted.&quot;.format(access_key_id)]
        )
        return ret
    keys = keys[&quot;list_access_keys_response&quot;][&quot;list_access_keys_result&quot;][
        &quot;access_key_metadata&quot;
    ]
    for k in keys:
        log.debug(
            &quot;Key is: %s and is compared with: %s&quot;, k[&quot;access_key_id&quot;], access_key_id
        )
        if str(k[&quot;access_key_id&quot;]) == str(access_key_id):
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;Access key {} is set to be deleted.&quot;.format(
                    access_key_id
                )
                ret[&quot;result&quot;] = None
                return ret
            deleted = __salt__[&quot;boto_iam.delete_access_key&quot;](
                access_key_id, user_name, region, key, keyid, profile
            )
            if deleted:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [ret[&quot;comment&quot;], &quot;Key {} has been deleted.&quot;.format(access_key_id)]
                )
                ret[&quot;changes&quot;][access_key_id] = &quot;deleted&quot;
                return ret
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Key {} could not be deleted.&quot;.format(access_key_id)]
            )
            return ret
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Key {} does not exist.&quot;.format(k)])
        return ret


def user_present(
    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    password=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM user is present

    name (string)
        The name of the new user.

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of managed policy names or ARNs that should be attached to this
        user.

    password (string)
        The password for the new user. Must comply with account policy.

    path (string)
        The path of the user. Default is '/'.

        .. versionadded:: 2015.8.2

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__[&quot;pillar.get&quot;](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__[&quot;boto_iam.get_user&quot;](name, region, key, keyid, profile)
    if not exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM user {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_iam.create_user&quot;](
            name, path, region, key, keyid, profile
        )
        if created:
            ret[&quot;changes&quot;][&quot;user&quot;] = created
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;User {} has been created.&quot;.format(name)]
            )
            if password:
                ret = _case_password(ret, name, password, region, key, keyid, profile)
            _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
            ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
            ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    else:
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;User {} is present.&quot;.format(name)])
        if password:
            ret = _case_password(ret, name, password, region, key, keyid, profile)
        _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
        ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    return ret


def _user_policies_present(
    name, policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__[&quot;boto_iam.get_user_policy&quot;](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug(&quot;Policy mismatch:\n%s\n%s&quot;, _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    for policy_name in _list:
        if policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on user {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policies&quot;: _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__[&quot;boto_iam.put_user_policy&quot;](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} for user {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__[&quot;boto_iam.delete_user_policy&quot;](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to user {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
        ret[&quot;comment&quot;] = &quot;{} policies modified on user {}.&quot;.format(
            &quot;, &quot;.join(_list), name
        )
    return ret


def _user_policies_attached(
    name, managed_policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__[&quot;boto_iam.list_entities_for_policy&quot;](
            policy,
            entity_filter=&quot;User&quot;,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for userdict in entities.get(&quot;policy_users&quot;, []):
            if name == userdict.get(&quot;user_name&quot;):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    for policy_data in _list:
        if (
            policy_data.get(&quot;policy_name&quot;) not in managed_policies
            and policy_data.get(&quot;policy_arn&quot;) not in managed_policies
        ):
            policies_to_detach.append(policy_data.get(&quot;policy_arn&quot;))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on user {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__[&quot;boto_iam.attach_user_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to user {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__[&quot;boto_iam.detach_user_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to remove policy {} from user {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
        log.debug(newpolicies)
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
        ret[&quot;comment&quot;] = &quot;{} policies modified on user {}.&quot;.format(
            &quot;, &quot;.join(newpolicies), name
        )
    return ret


def _user_policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    if not _list:
        ret[&quot;comment&quot;] = &quot;No attached policies in user {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be detached from user {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__[&quot;boto_iam.detach_user_policy&quot;](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from user {}&quot;.format(policy_arn, name)
            return ret
    _list = __salt__[&quot;boto_iam.list_attached_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies detached from user {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
    return ret


def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    oldpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret[&quot;comment&quot;] = &quot;No inline policies in user {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be deleted from user {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;inline_policies&quot;: oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__[&quot;boto_iam.delete_user_policy&quot;](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from user {}&quot;.format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__[&quot;boto_iam.get_all_user_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies deleted from user {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
    return ret


def _case_password(
    ret, name, password, region=None, key=None, keyid=None, profile=None
):
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Login policy for {} is set to be changed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    login = __salt__[&quot;boto_iam.create_login_profile&quot;](
        name, password, region, key, keyid, profile
    )
    log.debug(&quot;Login is : %s.&quot;, login)
    if login:
        if &quot;Conflict&quot; in login:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Login profile for user {} exists.&quot;.format(name)]
            )
        else:
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Password has been added to User {}.&quot;.format(name)]
            )
            ret[&quot;changes&quot;][&quot;password&quot;] = &quot;REDACTED&quot;
    else:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;Password for user {} could not be set.\nPlease check your password&quot;
                &quot; policy.&quot;.format(name),
            ]
        )
    return ret


def group_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM group is absent.

    name (string)
        The name of the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not __salt__[&quot;boto_iam.get_group&quot;](name, region, key, keyid, profile):
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;IAM Group {} does not exist.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM group {} managed policies are set to be detached.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _group_policies_detached(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [
                ret[&quot;comment&quot;],
                &quot;IAM group {} inline policies are set to be deleted.&quot;.format(name),
            ]
        )
        ret[&quot;result&quot;] = None
    else:
        _ret = _group_policies_deleted(name, region, key, keyid, profile)
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    ret[&quot;comment&quot;] = &quot; &quot;.join(
        [ret[&quot;comment&quot;], &quot;IAM group {} users are set to be removed.&quot;.format(name)]
    )
    existing_users = __salt__[&quot;boto_iam.get_group_members&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    # finally, actually delete the group
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM group {} is set to be deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_group&quot;](name, region, key, keyid, profile)
    if deleted is True:
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;IAM group {} is deleted.&quot;.format(name)]
        )
        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;deleted&quot;] = name
        return ret
    ret[&quot;comment&quot;] = &quot;IAM group {} could not be deleted.\n {}&quot;.format(name, deleted)
    ret[&quot;result&quot;] = False
    return ret

<A NAME="1"></A>
def group_present(
    name,
    policies<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match109136-0.html#1',2,'match109136-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=None,
    policies_from_pillars=None,
    managed_policies=None,
    users=None,
    path=&quot;/&quot;,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM group is present

    name (string)
        The name of the new group.

    path (string)
        The path for the group, defaults to '/'

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of policy names or ARNs that should be attached to this group.

    users (list)
        A list of users to be added to the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    delete_policies (boolean)
        Delete or detach existing policies that are not in the given list of policies.
        Default value is ``True``. If ``False`` is specified, existing policies
        will not be deleted or detached allowing manual modifications on the IAM group
        to be persistent.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if not policies:
        policies = {}
    if</B></FONT> not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__[&quot;pillar.get&quot;](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__[&quot;boto_iam.get_group&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM group {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_iam.create_group&quot;](
            group_name=name,
            path=path,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not created:
            ret[&quot;comment&quot;] = &quot;Failed to create IAM group {}.&quot;.format(name)
            ret[&quot;result&quot;] = False
            return ret
        ret[&quot;changes&quot;][&quot;group&quot;] = created
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Group {} has been created.&quot;.format(name)]
        )
    else:
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Group {} is present.&quot;.format(name)])
    # Group exists, ensure group policies and users are set.
    _ret = _group_policies_present(
        name, _policies, region, key, keyid, profile, delete_policies
    )
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    _ret = _group_policies_attached(
        name, managed_policies, region, key, keyid, profile, delete_policies
    )
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        return ret
    if users is not None:
        log.debug(&quot;Users are : %s.&quot;, users)
        existing_users = __salt__[&quot;boto_iam.get_group_members&quot;](
            group_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
    return ret


def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
    _users = []
    for user in existing_users:
        _users.append(user[&quot;user_name&quot;])
    log.debug(&quot;upstream users are %s&quot;, _users)
    for user in users:
        log.debug(&quot;users are %s&quot;, user)
        if user in _users:
            log.debug(&quot;user exists&quot;)
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;User {} is already a member of group {}.&quot;.format(user, group_name),
                ]
            )
            continue
        else:
            log.debug(&quot;user is set to be added %s&quot;, user)
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;User {} is set to be added to group {}.&quot;.format(
                    user, group_name
                )
                ret[&quot;result&quot;] = None
            else:
                __salt__[&quot;boto_iam.add_user_to_group&quot;](
                    user, group_name, region, key, keyid, profile
                )
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} has been added to group {}.&quot;.format(user, group_name),
                    ]
                )
                ret[&quot;changes&quot;][user] = group_name
    for user in _users:
        if user not in users:
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} is set to be removed from group {}.&quot;.format(
                            user, group_name
                        ),
                    ]
                )
                ret[&quot;result&quot;] = None
            else:
                __salt__[&quot;boto_iam.remove_user_from_group&quot;](
                    group_name=group_name,
                    user_name=user,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                ret[&quot;comment&quot;] = &quot; &quot;.join(
                    [
                        ret[&quot;comment&quot;],
                        &quot;User {} has been removed from group {}.&quot;.format(
                            user, group_name
                        ),
                    ]
                )
                ret[&quot;changes&quot;][user] = &quot;Removed from group {}.&quot;.format(group_name)
    return ret


def _group_policies_present(
    name,
    policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__[&quot;boto_iam.get_group_policy&quot;](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug(&quot;Policy mismatch:\n%s\n%s&quot;, _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        name, region, key, keyid, profile
    )
    for policy_name in _list:
        if delete_policies and policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on group {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policies&quot;: _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__[&quot;boto_iam.put_group_policy&quot;](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                    name, region, key, keyid, profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__[&quot;boto_iam.delete_group_policy&quot;](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                    name, region, key, keyid, profile
                )
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
            name, region, key, keyid, profile
        )
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policies&quot;: _list}
        ret[&quot;comment&quot;] = &quot;{} policies modified on group {}.&quot;.format(
            &quot;, &quot;.join(_list), name
        )
    return ret


def _group_policies_attached(
    name,
    managed_policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    detach_policies=True,
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__[&quot;boto_iam.list_entities_for_policy&quot;](
            policy,
            entity_filter=&quot;Group&quot;,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for groupdict in entities.get(&quot;policy_groups&quot;, []):
            if name == groupdict.get(&quot;group_name&quot;):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    for policy_data in _list:
        if (
            detach_policies
            and policy_data.get(&quot;policy_name&quot;) not in managed_policies
            and policy_data.get(&quot;policy_arn&quot;) not in managed_policies
        ):
            policies_to_detach.append(policy_data.get(&quot;policy_arn&quot;))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;{} policies to be modified on group {}.&quot;.format(
                &quot;, &quot;.join(_to_modify), name
            )
            ret[&quot;result&quot;] = None
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__[&quot;boto_iam.attach_group_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to add policy {} to group {}&quot;.format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__[&quot;boto_iam.detach_group_policy&quot;](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
                ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to remove policy {} from group {}&quot;.format(
                    policy_name, name
                )
                return ret
        _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
        log.debug(newpolicies)
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
        ret[&quot;comment&quot;] = &quot;{} policies modified on group {}.&quot;.format(
            &quot;, &quot;.join(newpolicies), name
        )
    return ret


def _group_policies_detached(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    if not _list:
        ret[&quot;comment&quot;] = &quot;No attached policies in group {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be detached from group {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;managed_policies&quot;: oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__[&quot;boto_iam.detach_group_policy&quot;](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from group {}&quot;.format(
                policy_arn, name
            )
            return ret
    _list = __salt__[&quot;boto_iam.list_attached_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get(&quot;policy_arn&quot;) for x in _list]
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;managed_policies&quot;: newpolicies}
    ret[&quot;comment&quot;] = &quot;{} policies detached from group {}.&quot;.format(
        &quot;, &quot;.join(newpolicies), name
    )
    return ret


def _group_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    oldpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret[&quot;comment&quot;] = &quot;No inline policies in group {}.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} policies to be deleted from group {}.&quot;.format(
            &quot;, &quot;.join(oldpolicies), name
        )
        ret[&quot;result&quot;] = None
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;inline_policies&quot;: oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__[&quot;boto_iam.delete_group_policy&quot;](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to detach {} from group {}&quot;.format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__[&quot;boto_iam.get_all_group_policies&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;inline_policies&quot;: newpolicies}
<A NAME="0"></A>    ret[&quot;comment&quot;] = &quot;{} policies deleted from group {}.&quot;.format(
        &quot;, &quot;.join(oldpolicies), name
    )
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match109136-0.html#0',2,'match109136-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return ret


def account_policy(
    name=None,
    allow_users_to_change_password=None,
    hard_expiry=None,
    max_password_age=None,
    minimum_password_length=None,
    password_reuse_prevention=None,
    require_lowercase_characters=None,
    require_numbers=None,
    require_symbols=None,
    require_uppercase_characters=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Change account policy.

    .. versionadded:: 2015.8.0

    name (string)
        The name of the account policy

    allow_users_to_change_password (bool)
        Allows all IAM users in your account to
        use the AWS Management Console to change their own passwords.

    hard_expiry (bool)
        Prevents IAM users from setting a new password after their
        password has expired.

    max_password_age (int)
        The number of days that an IAM user password is valid.

    minimum_password_length (int)
        The minimum number of characters allowed in an IAM user password.

    password_reuse_prevention (int)
        Specifies the number of previous passwords
        that IAM users are prevented from reusing.

    require_lowercase_characters (bool)
        Specifies whether IAM user passwords
        must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).

    require_numbers (bool)
        Specifies whether IAM user passwords must contain at
        least one numeric character (0 to 9).

    require_symbols (bool)
        Specifies whether IAM user passwords must contain at
        least one of the following non-alphanumeric characters: ! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '

    require_uppercase_characters (bool)
        Specifies whether IAM user passwords must
        contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
    &quot;&quot;&quot;
<A NAME="3"></A>    config =</B></FONT> locals()
    ret = {&quot;name&quot;: &quot;Account Policy&quot;, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    info = __salt__[&quot;boto_iam.get_account_policy&quot;](region, key, keyid, profile)
    <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match109136-0.html#3',2,'match109136-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if not info:
        ret[&quot;comment&quot;] = &quot;Account policy is not Enabled.&quot;
        ret[&quot;result&quot;] = False
        return ret
    for key, value in config.items():
        if key in (&quot;region&quot;</B></FONT>, &quot;key&quot;, &quot;keyid&quot;, &quot;profile&quot;, &quot;name&quot;):
            continue
        if value is not None and str(info[key]) != str(value).lower():
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [
                    ret[&quot;comment&quot;],
                    &quot;Policy value {} has been set to {}.&quot;.format(value, info[key]),
                ]
            )
            ret[&quot;changes&quot;][key] = str(value).lower()
    if not ret[&quot;changes&quot;]:
        ret[&quot;comment&quot;] = &quot;Account policy is not changed.&quot;
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Account policy is set to be changed.&quot;
        ret[&quot;result&quot;] = None
        return ret
    if __salt__[&quot;boto_iam.update_account_password_policy&quot;](
        allow_users_to_change_password,
        hard_expiry,
        max_password_age,
        minimum_password_length,
        password_reuse_prevention,
        require_lowercase_characters,
        require_numbers,
        require_symbols,
        require_uppercase_characters,
        region,
        key,
        keyid,
        profile,
    ):
        return ret
    ret[&quot;comment&quot;] = &quot;Account policy is not changed.&quot;
    ret[&quot;changes&quot;] = {}
    ret[&quot;result&quot;] = False
    return ret


def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Deletes a server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
        The profile that contains a dict of region, key, keyid
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_iam.get_server_certificate&quot;](
        name, region, key, keyid, profile
    )
    if not exists:
        ret[&quot;comment&quot;] = &quot;Certificate {} does not exist.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Server certificate {} is set to be deleted.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_server_cert&quot;](name, region, key, keyid, profile)
    if not deleted:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Certificate {} failed to be deleted.&quot;.format(name)
        return ret
    ret[&quot;comment&quot;] = &quot;Certificate {} was deleted.&quot;.format(name)
    ret[&quot;changes&quot;] = deleted
    return ret


def server_cert_present(
    name,
    public_key,
    private_key,
    cert_chain=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Crete server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    public_key (string)
        The contents of the public key certificate in PEM-encoded format.

    private_key (string)
        The contents of the private key in PEM-encoded format.

    cert_chain (string)
        The contents of the certificate chain. This is typically a
        concatenation of the PEM-encoded public key certificates of the chain.

    path (string)
        The path for the server certificate.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
        The profile that contains a dict of region, key, keyid
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_iam.get_server_certificate&quot;](
        name, region, key, keyid, profile
    )
    log.debug(&quot;Variables are : %s.&quot;, locals())
    if exists:
        ret[&quot;comment&quot;] = &quot;Certificate {} exists.&quot;.format(name)
        return ret
    if &quot;salt://&quot; in public_key:
        try:
            public_key = __salt__[&quot;cp.get_file_str&quot;](public_key)
        except OSError as e:
            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(public_key)
            ret[&quot;result&quot;] = False
            return ret
    if &quot;salt://&quot; in private_key:
        try:
            private_key = __salt__[&quot;cp.get_file_str&quot;](private_key)
        except OSError as e:
            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(private_key)
            ret[&quot;result&quot;] = False
            return ret
    if cert_chain is not None and &quot;salt://&quot; in cert_chain:
        try:
            cert_chain = __salt__[&quot;cp.get_file_str&quot;](cert_chain)
        except OSError as e:
            log.debug(e)
            ret[&quot;comment&quot;] = &quot;File {} not found.&quot;.format(cert_chain)
            ret[&quot;result&quot;] = False
            return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Server certificate {} is set to be created.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    created = __salt__[&quot;boto_iam.upload_server_cert&quot;](
        name, public_key, private_key, cert_chain, path, region, key, keyid, profile
    )
    if created is not False:
        ret[&quot;comment&quot;] = &quot;Certificate {} was created.&quot;.format(name)
        ret[&quot;changes&quot;] = created
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;Certificate {} failed to be created.&quot;.format(name)
    return ret


def policy_present(
    name,
    policy_document,
    path=None,
    description=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy is present

    name (string)
        The name of the new policy.

    policy_document (dict)
        The document of the new policy

    path (string)
        The path in which the policy will be created. Default is '/'.

    description (string)
        Description

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    policy = __salt__[&quot;boto_iam.get_policy&quot;](name, region, key, keyid, profile)
    if not policy:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;IAM policy {} is set to be created.&quot;.format(name)
            ret[&quot;result&quot;] = None
            return ret
        created = __salt__[&quot;boto_iam.create_policy&quot;](
            name, policy_document, path, description, region, key, keyid, profile
        )
        if created:
            ret[&quot;changes&quot;][&quot;policy&quot;] = created
            ret[&quot;comment&quot;] = &quot; &quot;.join(
                [ret[&quot;comment&quot;], &quot;Policy {} has been created.&quot;.format(name)]
            )
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to update policy.&quot;
            ret[&quot;changes&quot;] = {}
            return ret
    else:
        policy = policy.get(&quot;policy&quot;, {})
        ret[&quot;comment&quot;] = &quot; &quot;.join(
            [ret[&quot;comment&quot;], &quot;Policy {} is present.&quot;.format(name)]
        )
        _describe = __salt__[&quot;boto_iam.get_policy_version&quot;](
            name, policy.get(&quot;default_version_id&quot;), region, key, keyid, profile
        ).get(&quot;policy_version&quot;, {})
        if isinstance(_describe[&quot;document&quot;], str):
            describeDict = salt.utils.json.loads(_describe[&quot;document&quot;])
        else:
            describeDict = _describe[&quot;document&quot;]

        if isinstance(policy_document, str):
            policy_document = salt.utils.json.loads(policy_document)

        r = salt.utils.data.compare_dicts(describeDict, policy_document)

        if bool(r):
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;Policy {} set to be modified.&quot;.format(name)
                ret[&quot;result&quot;] = None
                return ret

            ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], &quot;Policy to be modified&quot;])
            policy_document = salt.utils.json.dumps(policy_document)

            r = __salt__[&quot;boto_iam.create_policy_version&quot;](
                policy_name=name,
                policy_document=policy_document,
                set_as_default=True,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r.get(&quot;created&quot;):
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to update policy: {}.&quot;.format(
                    r[&quot;error&quot;][&quot;message&quot;]
                )
                ret[&quot;changes&quot;] = {}
                return ret

            __salt__[&quot;boto_iam.delete_policy_version&quot;](
                policy_name=name,
                version_id=policy[&quot;default_version_id&quot;],
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )

            ret[&quot;changes&quot;].setdefault(&quot;new&quot;, {})[&quot;document&quot;] = policy_document
            ret[&quot;changes&quot;].setdefault(&quot;old&quot;, {})[&quot;document&quot;] = _describe[&quot;document&quot;]
    return ret


def policy_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy with the specified name is absent

    name (string)
        The name of the new policy.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    r = __salt__[&quot;boto_iam.policy_exists&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r:
        ret[&quot;comment&quot;] = &quot;Policy {} does not exist.&quot;.format(name)
        return ret

    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Policy {} is set to be removed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    # delete non-default versions
    versions = __salt__[&quot;boto_iam.list_policy_versions&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if versions:
        for version in versions:
            if version.get(&quot;is_default_version&quot;, False) in (&quot;true&quot;, True):
                continue
            r = __salt__[&quot;boto_iam.delete_policy_version&quot;](
                name,
                version_id=version.get(&quot;version_id&quot;),
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r:
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to delete policy {}.&quot;.format(name)
                return ret
    r = __salt__[&quot;boto_iam.delete_policy&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to delete policy {}.&quot;.format(name)
        return ret
    ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;policy&quot;: name}
    ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;policy&quot;: None}
    ret[&quot;comment&quot;] = &quot;Policy {} deleted.&quot;.format(name)
    return ret


def saml_provider_present(
    name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is present.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if &quot;salt://&quot; in saml_metadata_document:
        try:
            saml_metadata_document = __salt__[&quot;cp.get_file_str&quot;](saml_metadata_document)
            ET.fromstring(saml_metadata_document)
        except OSError as e:
            log.debug(e)
            ret[
                &quot;comment&quot;
            ] = &quot;SAML document file {} not found or could not be loaded&quot;.format(name)
            ret[&quot;result&quot;] = False
            return ret
    for provider in __salt__[&quot;boto_iam.list_saml_providers&quot;](
        region=region, key=key, keyid=keyid, profile=profile
    ):
        if provider == name:
            ret[&quot;comment&quot;] = &quot;SAML provider {} is present.&quot;.format(name)
            return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is set to be create.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    created = __salt__[&quot;boto_iam.create_saml_provider&quot;](
        name,
        saml_metadata_document,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if created:
        ret[&quot;comment&quot;] = &quot;SAML provider {} was created.&quot;.format(name)
        ret[&quot;changes&quot;][&quot;new&quot;] = name
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;SAML provider {} failed to be created.&quot;.format(name)
    return ret


def saml_provider_absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is absent.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    provider = __salt__[&quot;boto_iam.list_saml_providers&quot;](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if len(provider) == 0:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is absent.&quot;.format(name)
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;SAML provider {} is set to be removed.&quot;.format(name)
        ret[&quot;result&quot;] = None
        return ret
    deleted = __salt__[&quot;boto_iam.delete_saml_provider&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if deleted is not False:
        ret[&quot;comment&quot;] = &quot;SAML provider {} was deleted.&quot;.format(name)
        ret[&quot;changes&quot;][&quot;old&quot;] = name
        return ret
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = &quot;SAML provider {} failed to be deleted.&quot;.format(name)
    return ret


def _get_error(error):
    # Converts boto exception to string that can be used to output error.
    error = &quot;\n&quot;.join(error.split(&quot;\n&quot;)[1:])
    error = ET.fromstring(error)
    code = error[0][1].text
    message = error[0][2].text
    return code, message
</PRE>
</div>
  </div>
</body>
</html>
