<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for generate-names-file-from-failed-test-reports.py &amp; __init___57.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for generate-names-file-from-failed-test-reports.py &amp; __init___57.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>generate-names-file-from-failed-test-reports.py (11.650485%)<th>__init___57.py (0.32206118%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-24)<td><a href="#" name="0">(1244-1246)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>generate-names-file-from-failed-test-reports.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import argparse
2 import glob
3 import os
4 import sys
5 try:
6     import xunitparser
7 except ImportError:
8     sys.stderr.write(
9         "Please install the xunitparser python package to run this script\n"
10     )
11     sys.exit(1)
12 REPO_ROOT = os<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(</b></font>__file__))))
13 def main():
14     parser = argparse.ArgumentParser()
15     parser.add_argument(
16         "--reports-dir",
17         default=os.path.join(REPO_ROOT, "artifacts", "xml-unittests-output"),
18         help="Path to the directory where the JUnit XML reports can be found",
19     )
20     parser.add_argument(
21         "output_file",
22         help=(
23             "Path to the file containing the failed tests listing to be fed to"
24             " --names-files"
25         ),
26     )
27     options = parser.parse_args()
28     total_xml_reports = 0
29     failures = set()
30     for fname in sorted(glob.glob(os.path.join(options.reports_dir, "*.xml"))):
31         total_xml_reports += 1
32         with open(fname) as rfh:
33             test_suite, test_result = xunitparser.parse(rfh)
34             if not test_result.errors and not test_result.failures:
35                 continue
36             for test in test_suite:
37                 if test.bad:
38                     failures.add("{classname}.{methodname}".format(**test.__dict__))
39     if not total_xml_reports:
40         parser.exit(status=1, message="No JUnit XML files were parsed")
41     with open(options.output_file, "w") as wfh:
42         wfh.write(os.linesep.join(sorted(failures)))
43     parser.exit(status=0)
44 if __name__ == "__main__":
45     main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___57.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import glob
3 import logging
4 import multiprocessing
5 import os
6 import signal
7 import time
8 import traceback
9 from itertools import groupby
10 import salt.client
11 import salt.config
12 import salt.loader
13 import salt.syspaths
14 import salt.utils.args
15 import salt.utils.cloud
16 import salt.utils.context
17 import salt.utils.crypt
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.user
22 import salt.utils.verify
23 import salt.utils.yaml
24 from salt.exceptions import (
25     SaltCloudConfigError,
26     SaltCloudException,
27     SaltCloudNotFound,
28     SaltCloudSystemExit,
29 )
30 from salt.template import compile_template
31 try:
32     import Cryptodome.Random
33 except ImportError:
34     try:
35         import Crypto.Random  # nosec
36     except ImportError:
37         pass  # pycrypto &lt; 2.1
38 log = logging.getLogger(__name__)
39 def communicator(func):
40     def _call(queue, args, kwargs):
41         kwargs["queue"] = queue
42         ret = None
43         try:
44             ret = func(*args, **kwargs)
45             queue.put("END")
46         except KeyboardInterrupt as ex:
47             trace = traceback.format_exc()
48             queue.put("KEYBOARDINT")
49             queue.put("Keyboard interrupt")
50             queue.put("{}\n{}\n".format(ex, trace))
51         except Exception as ex:  # pylint: disable=broad-except
52             trace = traceback.format_exc()
53             queue.put("ERROR")
54             queue.put("Exception")
55             queue.put("{}\n{}\n".format(ex, trace))
56         except SystemExit as ex:
57             trace = traceback.format_exc()
58             queue.put("ERROR")
59             queue.put("System exit")
60             queue.put("{}\n{}\n".format(ex, trace))
61         return ret
62     return _call
63 def enter_mainloop(
64     target,
65     mapped_args=None,
66     args=None,
67     kwargs=None,
68     pool=None,
69     pool_size=None,
70     callback=None,
71     queue=None,
72 ):
73     if not kwargs:
74         kwargs = {}
75     if not pool_size:
76         pool_size = 1
77     if not pool:
78         pool = multiprocessing.Pool(pool_size)
79     if not queue:
80         manager = multiprocessing.Manager()
81         queue = manager.Queue()
82     if mapped_args is not None and not mapped_args:
83         msg = (
84             "We are called to asynchronously execute {}"
85             " but we do no have anything to execute, weird,"
86             " we bail out".format(target)
87         )
88         log.error(msg)
89         raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
90     elif mapped_args is not None:
91         iterable = [[queue, [arg], kwargs] for arg in mapped_args]
92         ret = pool.map(func=target, iterable=iterable)
93     else:
94         ret = pool.apply(target, [queue, args, kwargs])
95     while True:
96         test = queue.get()
97         if test in ["ERROR", "KEYBOARDINT"]:
98             type_ = queue.get()
99             trace = queue.get()
100             msg = "Caught {}, terminating workers\n".format(type_)
101             msg += "TRACE: {}\n".format(trace)
102             log.error(msg)
103             pool.terminate()
104             pool.join()
105             raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
106         elif test in ["END"] or (callback and callback(test)):
107             pool.close()
108             pool.join()
109             break
110         else:
111             time.sleep(0.125)
112     return ret
113 class CloudClient:
114     def __init__(self, path=None, opts=None, config_dir=None, pillars=None):
115         if opts:
116             self.opts = opts
117         else:
118             self.opts = salt.config.cloud_config(path)
119         v_dirs = [self.opts["cachedir"]]
120         salt.utils.verify.verify_env(v_dirs, salt.utils.user.get_user())
121         if pillars:
122             for name, provider in pillars.pop("providers", {}).items():
123                 driver = provider["driver"]
124                 provider["profiles"] = {}
125                 self.opts["providers"].update({name: {driver: provider}})
126             for name, profile in pillars.pop("profiles", {}).items():
127                 provider = profile["provider"].split(":")[0]
128                 driver = next(iter(self.opts["providers"][provider].keys()))
129                 profile["provider"] = "{}:{}".format(provider, driver)
130                 profile["profile"] = name
131                 self.opts["profiles"].update({name: profile})
132                 self.opts["providers"][provider][driver]["profiles"].update(
133                     {name: profile}
134                 )
135             for name, map_dct in pillars.pop("maps", {}).items():
136                 if "maps" not in self.opts:
137                     self.opts["maps"] = {}
138                 self.opts["maps"][name] = map_dct
139             self.opts.update(pillars)
140     def _opts_defaults(self, **kwargs):
141         opts = salt.config.DEFAULT_CLOUD_OPTS.copy()
142         opts.update(self.opts.copy())
143         opts["parallel"] = False
144         opts["keep_tmp"] = False
145         opts["deploy"] = True
146         opts["update_bootstrap"] = False
147         opts["show_deploy_args"] = False
148         opts["script_args"] = ""
149         if "kwargs" in kwargs:
150             opts.update(kwargs["kwargs"])
151         opts.update(kwargs)
152         profile = opts.get("profile", None)
153         if profile:
154             tmp_profiles = opts.get("profiles", {}).copy()
155             for _profile in [a for a in tmp_profiles]:
156                 if not _profile == profile:
157                     tmp_profiles.pop(_profile)
158             providers = [
159                 a.get("provider", "").split(":")[0]
160                 for a in tmp_profiles.values()
161                 if a.get("provider", "")
162             ]
163             if providers:
164                 _providers = opts.get("providers", {})
165                 for provider in _providers.copy():
166                     if provider not in providers:
167                         _providers.pop(provider)
168         return opts
169     def low(self, fun, low):
170         l_fun = getattr(self, fun)
171         f_call = salt.utils.args.format_call(l_fun, low)
172         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
173     def list_sizes(self, provider=None):
174         mapper = salt.cloud.Map(self._opts_defaults())
175         return salt.utils.data.simple_types_filter(mapper.size_list(provider))
176     def list_images(self, provider=None):
177         mapper = salt.cloud.Map(self._opts_defaults())
178         return salt.utils.data.simple_types_filter(mapper.image_list(provider))
179     def list_locations(self, provider=None):
180         mapper = salt.cloud.Map(self._opts_defaults())
181         return salt.utils.data.simple_types_filter(mapper.location_list(provider))
182     def query(self, query_type="list_nodes"):
183         mapper = salt.cloud.Map(self._opts_defaults())
184         mapper.opts["selected_query_option"] = "list_nodes"
185         return mapper.map_providers_parallel(query_type)
186     def full_query(self, query_type="list_nodes_full"):
187         mapper = salt.cloud.Map(self._opts_defaults())
188         mapper.opts["selected_query_option"] = "list_nodes_full"
189         return mapper.map_providers_parallel(query_type)
190     def select_query(self, query_type="list_nodes_select"):
191         mapper = salt.cloud.Map(self._opts_defaults())
192         mapper.opts["selected_query_option"] = "list_nodes_select"
193         return mapper.map_providers_parallel(query_type)
194     def min_query(self, query_type="list_nodes_min"):
195         mapper = salt.cloud.Map(self._opts_defaults())
196         mapper.opts["selected_query_option"] = "list_nodes_min"
197         return mapper.map_providers_parallel(query_type)
198     def profile(self, profile, names, vm_overrides=None, **kwargs):
199         if not vm_overrides:
200             vm_overrides = {}
201         kwargs["profile"] = profile
202         mapper = salt.cloud.Map(self._opts_defaults(**kwargs))
203         if isinstance(names, str):
204             names = names.split(",")
205         return salt.utils.data.simple_types_filter(
206             mapper.run_profile(profile, names, vm_overrides=vm_overrides)
207         )
208     def map_run(self, path=None, **kwargs):
209         kwarg = {}
210         if path:
211             kwarg["map"] = path
212         kwarg.update(kwargs)
213         mapper = salt.cloud.Map(self._opts_defaults(**kwarg))
214         dmap = mapper.map_data()
215         return salt.utils.data.simple_types_filter(mapper.run_map(dmap))
216     def destroy(self, names):
217         mapper = salt.cloud.Map(self._opts_defaults(destroy=True))
218         if isinstance(names, str):
219             names = names.split(",")
220         return salt.utils.data.simple_types_filter(mapper.destroy(names))
221     def create(self, provider, names, **kwargs):
222         mapper = salt.cloud.Map(self._opts_defaults())
223         providers = self.opts["providers"]
224         if provider in providers:
225             provider += ":{}".format(next(iter(providers[provider].keys())))
226         else:
227             return False
228         if isinstance(names, str):
229             names = names.split(",")
230         ret = {}
231         for name in names:
232             vm_ = kwargs.copy()
233             vm_["name"] = name
234             vm_["driver"] = provider
235             vm_["profile"] = None
236             vm_["provider"] = provider
237             ret[name] = salt.utils.data.simple_types_filter(mapper.create(vm_))
238         return ret
239     def extra_action(self, names, provider, action, **kwargs):
240         mapper = salt.cloud.Map(self._opts_defaults())
241         providers = mapper.map_providers_parallel()
242         if provider in providers:
243             provider += ":{}".format(next(iter(providers[provider].keys())))
244         else:
245             return False
246         if isinstance(names, str):
247             names = names.split(",")
248         ret = {}
249         for name in names:
250             extra_ = kwargs.copy()
251             extra_["name"] = name
252             extra_["provider"] = provider
253             extra_["profile"] = None
254             extra_["action"] = action
255             ret[name] = salt.utils.data.simple_types_filter(mapper.extras(extra_))
256         return ret
257     def action(
258         self,
259         fun=None,
260         cloudmap=None,
261         names=None,
262         provider=None,
263         instance=None,
264         kwargs=None,
265     ):
266         if kwargs is None:
267             kwargs = {}
268         mapper = salt.cloud.Map(self._opts_defaults(action=fun, names=names, **kwargs))
269         if instance:
270             if names:
271                 raise SaltCloudConfigError(
272                     "Please specify either a list of 'names' or a single "
273                     "'instance', but not both."
274                 )
275             names = [instance]
276         if names and not provider:
277             self.opts["action"] = fun
278             return mapper.do_action(names, kwargs)
279         if provider and not names:
280             return mapper.do_function(provider, fun, kwargs)
281         else:
282             raise SaltCloudConfigError(
283                 "Either an instance (or list of names) or a provider must be "
284                 "specified, but not both."
285             )
286 class Cloud:
287     def __init__(self, opts):
288         self.opts = opts
289         self.clouds = salt.loader.clouds(self.opts)
290         self.__filter_non_working_providers()
291         self.__cached_provider_queries = {}
292     def get_configured_providers(self):
293         providers = set()
294         for alias, drivers in self.opts["providers"].items():
295             if len(drivers) &gt; 1:
296                 for driver in drivers:
297                     providers.add("{}:{}".format(alias, driver))
298                 continue
299             providers.add(alias)
300         return providers
301     def lookup_providers(self, lookup):
302         if lookup is None:
303             lookup = "all"
304         if lookup == "all":
305             providers = set()
306             for alias, drivers in self.opts["providers"].items():
307                 for driver in drivers:
308                     providers.add((alias, driver))
309             if not providers:
310                 raise SaltCloudSystemExit("There are no cloud providers configured.")
311             return providers
312         if ":" in lookup:
313             alias, driver = lookup.split(":")
314             if (
315                 alias not in self.opts["providers"]
316                 or driver not in self.opts["providers"][alias]
317             ):
318                 raise SaltCloudSystemExit(
319                     "No cloud providers matched '{}'. Available: {}".format(
320                         lookup, ", ".join(self.get_configured_providers())
321                     )
322                 )
323         providers = set()
324         for alias, drivers in self.opts["providers"].items():
325             for driver in drivers:
326                 if lookup in (alias, driver):
327                     providers.add((alias, driver))
328         if not providers:
329             raise SaltCloudSystemExit(
330                 "No cloud providers matched '{}'. Available selections: {}".format(
331                     lookup, ", ".join(self.get_configured_providers())
332                 )
333             )
334         return providers
335     def lookup_profiles(self, provider, lookup):
336         if provider is None:
337             provider = "all"
338         if lookup is None:
339             lookup = "all"
340         if lookup == "all":
341             profiles = set()
342             provider_profiles = set()
343             for alias, info in self.opts["profiles"].items():
344                 providers = info.get("provider")
345                 if providers:
346                     given_prov_name = providers.split(":")[0]
347                     salt_prov_name = providers.split(":")[1]
348                     if given_prov_name == provider:
349                         provider_profiles.add((alias, given_prov_name))
350                     elif salt_prov_name == provider:
351                         provider_profiles.add((alias, salt_prov_name))
352                     profiles.add((alias, given_prov_name))
353             if not profiles:
354                 raise SaltCloudSystemExit("There are no cloud profiles configured.")
355             if provider != "all":
356                 return provider_profiles
357             return profiles
358     def map_providers(self, query="list_nodes", cached=False):
359         if cached is True and query in self.__cached_provider_queries:
360             return self.__cached_provider_queries[query]
361         pmap = {}
362         for alias, drivers in self.opts["providers"].items():
363             for driver, details in drivers.items():
364                 fun = "{}.{}".format(driver, query)
365                 if fun not in self.clouds:
366                     log.error("Public cloud provider %s is not available", driver)
367                     continue
368                 if alias not in pmap:
369                     pmap[alias] = {}
370                 try:
371                     with salt.utils.context.func_globals_inject(
372                         self.clouds[fun],
373                         __active_provider_name__=":".join([alias, driver]),
374                     ):
375                         pmap[alias][driver] = self.clouds[fun]()
376                 except Exception as err:  # pylint: disable=broad-except
377                     log.debug(
378                         "Failed to execute '%s()' while querying for running nodes: %s",
379                         fun,
380                         err,
381                         exc_info_on_loglevel=logging.DEBUG,
382                     )
383                     pmap[alias][driver] = []
384         self.__cached_provider_queries[query] = pmap
385         return pmap
386     def map_providers_parallel(self, query="list_nodes", cached=False):
387         if cached is True and query in self.__cached_provider_queries:
388             return self.__cached_provider_queries[query]
389         opts = self.opts.copy()
390         multiprocessing_data = []
391         opts["providers"] = self._optimize_providers(opts["providers"])
392         for alias, drivers in opts["providers"].items():
393             this_query = query
394             for driver, details in drivers.items():
395                 if (
396                     opts.get("selected_query_option") is None
397                     and "{}.list_nodes_min".format(driver) in self.clouds
398                 ):
399                     this_query = "list_nodes_min"
400                 fun = "{}.{}".format(driver, this_query)
401                 if fun not in self.clouds:
402                     log.error("Public cloud provider %s is not available", driver)
403                     continue
404                 multiprocessing_data.append(
405                     {
406                         "fun": fun,
407                         "opts": opts,
408                         "query": this_query,
409                         "alias": alias,
410                         "driver": driver,
411                     }
412                 )
413         output = {}
414         if not multiprocessing_data:
415             return output
416         data_count = len(multiprocessing_data)
417         pool = multiprocessing.Pool(
418             data_count &lt; 10 and data_count or 10, init_pool_worker
419         )
420         parallel_pmap = enter_mainloop(
421             _run_parallel_map_providers_query, multiprocessing_data, pool=pool
422         )
423         for alias, driver, details in parallel_pmap:
424             if not details:
425                 continue
426             if alias not in output:
427                 output[alias] = {}
428             output[alias][driver] = details
429         self.__cached_provider_queries[query] = output
430         return output
431     def get_running_by_names(
432         self, names, query="list_nodes", cached=False, profile=None
433     ):
434         if isinstance(names, str):
435             names = [names]
436         matches = {}
437         handled_drivers = {}
438         mapped_providers = self.map_providers_parallel(query, cached=cached)
439         for alias, drivers in mapped_providers.items():
440             for driver, vms in drivers.items():
441                 if driver not in handled_drivers:
442                     handled_drivers[driver] = alias
443                 if (
444                     profile
445                     and alias
446                     not in self.opts["profiles"][profile]["provider"].split(":")[0]
447                 ):
448                     continue
449                 for vm_name, details in vms.items():
450                     if vm_name not in names:
451                         continue
452                     elif (
453                         driver == "ec2"
454                         and "aws" in handled_drivers
455                         and "aws" in matches[handled_drivers["aws"]]
456                         and vm_name in matches[handled_drivers["aws"]]["aws"]
457                     ):
458                         continue
459                     elif (
460                         driver == "aws"
461                         and "ec2" in handled_drivers
462                         and "ec2" in matches[handled_drivers["ec2"]]
463                         and vm_name in matches[handled_drivers["ec2"]]["ec2"]
464                     ):
465                         continue
466                     if alias not in matches:
467                         matches[alias] = {}
468                     if driver not in matches[alias]:
469                         matches[alias][driver] = {}
470                     matches[alias][driver][vm_name] = details
471         return matches
472     def _optimize_providers(self, providers):
473         new_providers = {}
474         provider_by_driver = {}
475         for alias, driver in providers.items():
476             for name, data in driver.items():
477                 if name not in provider_by_driver:
478                     provider_by_driver[name] = {}
479                 provider_by_driver[name][alias] = data
480         for driver, providers_data in provider_by_driver.items():
481             fun = "{}.optimize_providers".format(driver)
482             if fun not in self.clouds:
483                 log.debug("The '%s' cloud driver is unable to be optimized.", driver)
484                 for name, prov_data in providers_data.items():
485                     if name not in new_providers:
486                         new_providers[name] = {}
487                     new_providers[name][driver] = prov_data
488                 continue
489             new_data = self.clouds[fun](providers_data)
490             if new_data:
491                 for name, prov_data in new_data.items():
492                     if name not in new_providers:
493                         new_providers[name] = {}
494                     new_providers[name][driver] = prov_data
495         return new_providers
496     def location_list(self, lookup="all"):
497         data = {}
498         lookups = self.lookup_providers(lookup)
499         if not lookups:
500             return data
501         for alias, driver in lookups:
502             fun = "{}.avail_locations".format(driver)
503             if fun not in self.clouds:
504                 log.debug(
505                     "The '%s' cloud driver defined under '%s' provider "
506                     "alias is unable to get the locations information",
507                     driver,
508                     alias,
509                 )
510                 continue
511             if alias not in data:
512                 data[alias] = {}
513             try:
514                 with salt.utils.context.func_globals_inject(
515                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
516                 ):
517                     data[alias][driver] = self.clouds[fun]()
518             except Exception as err:  # pylint: disable=broad-except
519                 log.error(
520                     "Failed to get the output of '%s()': %s",
521                     fun,
522                     err,
523                     exc_info_on_loglevel=logging.DEBUG,
524                 )
525         return data
526     def image_list(self, lookup="all"):
527         data = {}
528         lookups = self.lookup_providers(lookup)
529         if not lookups:
530             return data
531         for alias, driver in lookups:
532             fun = "{}.avail_images".format(driver)
533             if fun not in self.clouds:
534                 log.debug(
535                     "The '%s' cloud driver defined under '%s' provider "
536                     "alias is unable to get the images information",
537                     driver,
538                     alias,
539                 )
540                 continue
541             if alias not in data:
542                 data[alias] = {}
543             try:
544                 with salt.utils.context.func_globals_inject(
545                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
546                 ):
547                     data[alias][driver] = self.clouds[fun]()
548             except Exception as err:  # pylint: disable=broad-except
549                 log.error(
550                     "Failed to get the output of '%s()': %s",
551                     fun,
552                     err,
553                     exc_info_on_loglevel=logging.DEBUG,
554                 )
555         return data
556     def size_list(self, lookup="all"):
557         data = {}
558         lookups = self.lookup_providers(lookup)
559         if not lookups:
560             return data
561         for alias, driver in lookups:
562             fun = "{}.avail_sizes".format(driver)
563             if fun not in self.clouds:
564                 log.debug(
565                     "The '%s' cloud driver defined under '%s' provider "
566                     "alias is unable to get the sizes information",
567                     driver,
568                     alias,
569                 )
570                 continue
571             if alias not in data:
572                 data[alias] = {}
573             try:
574                 with salt.utils.context.func_globals_inject(
575                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
576                 ):
577                     data[alias][driver] = self.clouds[fun]()
578             except Exception as err:  # pylint: disable=broad-except
579                 log.error(
580                     "Failed to get the output of '%s()': %s",
581                     fun,
582                     err,
583                     exc_info_on_loglevel=logging.DEBUG,
584                 )
585         return data
586     def provider_list(self, lookup="all"):
587         data = {}
588         lookups = self.lookup_providers(lookup)
589         if not lookups:
590             return data
591         for alias, driver in lookups:
592             if alias not in data:
593                 data[alias] = {}
594             if driver not in data[alias]:
595                 data[alias][driver] = {}
596         return data
597     def profile_list(self, provider, lookup="all"):
598         data = {}
599         lookups = self.lookup_profiles(provider, lookup)
600         if not lookups:
601             return data
602         for alias, driver in lookups:
603             if alias not in data:
604                 data[alias] = {}
605             if driver not in data[alias]:
606                 data[alias][driver] = {}
607         return data
608     def create_all(self):
609         ret = []
610         for vm_name, vm_details in self.opts["profiles"].items():
611             ret.append({vm_name: self.create(vm_details)})
612         return ret
613     def destroy(self, names, cached=False):
614         processed = {}
615         names = set(names)
616         matching = self.get_running_by_names(names, cached=cached)
617         vms_to_destroy = set()
618         parallel_data = []
619         for alias, drivers in matching.items():
620             for driver, vms in drivers.items():
621                 for name in vms:
622                     if name in names:
623                         vms_to_destroy.add((alias, driver, name))
624                         if self.opts["parallel"]:
625                             parallel_data.append(
626                                 {
627                                     "opts": self.opts,
628                                     "name": name,
629                                     "alias": alias,
630                                     "driver": driver,
631                                 }
632                             )
633         if self.opts["parallel"] and parallel_data:
634             if "pool_size" in self.opts:
635                 pool_size = self.opts["pool_size"]
636             else:
637                 pool_size = len(parallel_data)
638             log.info("Destroying in parallel mode; Cloud pool size: %s", pool_size)
639             output_multip = enter_mainloop(
640                 _destroy_multiprocessing, parallel_data, pool_size=pool_size
641             )
642             ret_multip = {}
643             for obj in output_multip:
644                 ret_multip.update(obj)
645             for obj in parallel_data:
646                 alias = obj["alias"]
647                 driver = obj["driver"]
648                 name = obj["name"]
649                 if alias not in processed:
650                     processed[alias] = {}
651                 if driver not in processed[alias]:
652                     processed[alias][driver] = {}
653                 processed[alias][driver][name] = ret_multip[name]
654                 if name in names:
655                     names.remove(name)
656         else:
657             log.info("Destroying in non-parallel mode.")
658             for alias, driver, name in vms_to_destroy:
659                 fun = "{}.destroy".format(driver)
660                 with salt.utils.context.func_globals_inject(
661                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
662                 ):
663                     ret = self.clouds[fun](name)
664                 if alias not in processed:
665                     processed[alias] = {}
666                 if driver not in processed[alias]:
667                     processed[alias][driver] = {}
668                 processed[alias][driver][name] = ret
669                 if name in names:
670                     names.remove(name)
671         for alias, driver, name in vms_to_destroy:
672             ret = processed[alias][driver][name]
673             if not ret:
674                 continue
675             vm_ = {
676                 "name": name,
677                 "profile": None,
678                 "provider": ":".join([alias, driver]),
679                 "driver": driver,
680             }
681             minion_dict = salt.config.get_cloud_config_value(
682                 "minion", vm_, self.opts, default={}
683             )
684             key_file = os.path.join(
685                 self.opts["pki_dir"], "minions", minion_dict.get("id", name)
686             )
687             globbed_key_file = glob.glob("{}.*".format(key_file))
688             if not os.path.isfile(key_file) and not globbed_key_file:
689                 if isinstance(ret, dict) and "newname" in ret:
690                     salt.utils.cloud.remove_key(self.opts["pki_dir"], ret["newname"])
691                 continue
692             if os.path.isfile(key_file) and not globbed_key_file:
693                 salt.utils.cloud.remove_key(
694                     self.opts["pki_dir"], os.path.basename(key_file)
695                 )
696                 continue
697             if (
698                 not os.path.isfile(key_file)
699                 and globbed_key_file
700                 and len(globbed_key_file) == 1
701             ):
702                 salt.utils.cloud.remove_key(
703                     self.opts["pki_dir"], os.path.basename(globbed_key_file[0])
704                 )
705                 continue
706             print(
707                 "There are several minion keys who's name starts "
708                 "with '{}'. We need to ask you which one should be "
709                 "deleted:".format(name)
710             )
711             while True:
712                 for idx, filename in enumerate(globbed_key_file):
713                     print(" {}: {}".format(idx, os.path.basename(filename)))
714                 selection = input("Which minion key should be deleted(number)? ")
715                 try:
716                     selection = int(selection)
717                 except ValueError:
718                     print("'{}' is not a valid selection.".format(selection))
719                 try:
720                     filename = os.path.basename(globbed_key_file.pop(selection))
721                 except Exception:  # pylint: disable=broad-except
722                     continue
723                 delete = input("Delete '{}'? [Y/n]? ".format(filename))
724                 if delete == "" or delete.lower().startswith("y"):
725                     salt.utils.cloud.remove_key(self.opts["pki_dir"], filename)
726                     print("Deleted '{}'".format(filename))
727                     break
728                 print("Did not delete '{}'".format(filename))
729                 break
730         if names and not processed:
731             raise SaltCloudSystemExit(
732                 "The following VM's were not found: {}".format(", ".join(names))
733             )
734         elif names and processed:
735             processed["Not Found"] = names
736         elif not processed:
737             raise SaltCloudSystemExit("No machines were destroyed!")
738         return processed
739     def reboot(self, names):
740         ret = []
741         pmap = self.map_providers_parallel()
742         acts = {}
743         for prov, nodes in pmap.items():
744             acts[prov] = []
745             for node in nodes:
746                 if node in names:
747                     acts[prov].append(node)
748         for prov, names_ in acts.items():
749             fun = "{}.reboot".format(prov)
750             for name in names_:
751                 ret.append({name: self.clouds[fun](name)})
752         return ret
753     def create(self, vm_, local_master=True):
754         output = {}
755         minion_dict = salt.config.get_cloud_config_value(
756             "minion", vm_, self.opts, default={}
757         )
758         alias, driver = vm_["provider"].split(":")
759         fun = "{}.create".format(driver)
760         if fun not in self.clouds:
761             log.error(
762                 "Creating '%s' using '%s' as the provider "
763                 "cannot complete since '%s' is not available",
764                 vm_["name"],
765                 vm_["provider"],
766                 driver,
767             )
768             return
769         deploy = salt.config.get_cloud_config_value("deploy", vm_, self.opts)
770         make_master = salt.config.get_cloud_config_value("make_master", vm_, self.opts)
771         if deploy:
772             if not make_master and "master" not in minion_dict:
773                 log.warning(
774                     "There's no master defined on the '%s' VM settings.", vm_["name"]
775                 )
776             if "pub_key" not in vm_ and "priv_key" not in vm_:
777                 log.debug("Generating minion keys for '%s'", vm_["name"])
778                 priv, pub = salt.utils.cloud.gen_keys(
779                     salt.config.get_cloud_config_value("keysize", vm_, self.opts)
780                 )
781                 vm_["pub_key"] = pub
782                 vm_["priv_key"] = priv
783         else:
784             vm_["pub_key"] = None
785             vm_["priv_key"] = None
786         key_id = minion_dict.get("id", vm_["name"])
787         domain = vm_.get("domain")
788         if vm_.get("use_fqdn") and domain:
789             minion_dict["append_domain"] = domain
790         if "append_domain" in minion_dict:
791             key_id = ".".join([key_id, minion_dict["append_domain"]])
792         if make_master is True and "master_pub" not in vm_ and "master_pem" not in vm_:
793             log.debug("Generating the master keys for '%s'", vm_["name"])
794             master_priv, master_pub = salt.utils.cloud.gen_keys(
795                 salt.config.get_cloud_config_value("keysize", vm_, self.opts)
796             )
797             vm_["master_pub"] = master_pub
798             vm_["master_pem"] = master_priv
799         if local_master is True and deploy is True:
800             salt.utils.cloud.accept_key(self.opts["pki_dir"], vm_["pub_key"], key_id)
801         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, self.opts)
802         try:
803             vm_["inline_script"] = salt.config.get_cloud_config_value(
804                 "inline_script", vm_, self.opts
805             )
806         except KeyError:
807             pass
808         try:
809             alias, driver = vm_["provider"].split(":")
810             func = "{}.create".format(driver)
811             with salt.utils.context.func_globals_inject(
812                 self.clouds[fun], __active_provider_name__=":".join([alias, driver])
813             ):
814                 output = self.clouds[func](vm_)
815             if output is not False and "sync_after_install" in self.opts:
816                 if self.opts["sync_after_install"] not in (
817                     "all",
818                     "modules",
819                     "states",
820                     "grains",
821                 ):
822                     log.error("Bad option for sync_after_install")
823                     return output
824                 time.sleep(3)
825                 start = int(time.time())
826                     mopts_ = salt.config.DEFAULT_MASTER_OPTS
827                     conf_path = "/".join(self.opts<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["conf_file"].split("/")[:-1])
828                     mopts_.update(
829                         salt.config.master_config(os.path.join(</b></font>conf_path, "master"))
830                     )
831                     with salt.client.get_local_client(mopts=mopts_) as client:
832                         ret = client.cmd(
833                             vm_["name"],
834                             "saltutil.sync_{}".format(self.opts["sync_after_install"]),
835                             timeout=self.opts["timeout"],
836                         )
837                         if ret:
838                             log.info(
839                                 "Synchronized the following dynamic modules: %s", ret
840                             )
841                             break
842         except KeyError as exc:
843             log.exception(
844                 "Failed to create VM %s. Configuration value %s needs to be set",
845                 vm_["name"],
846                 exc,
847             )
848         try:
849             opt_map = self.opts["map"]
850         except KeyError:
851             opt_map = False
852         if self.opts["parallel"] and self.opts["start_action"] and not opt_map:
853             log.info("Running %s on %s", self.opts["start_action"], vm_["name"])
854             with salt.client.get_local_client(mopts=self.opts) as client:
855                 action_out = client.cmd(
856                     vm_["name"],
857                     self.opts["start_action"],
858                     timeout=self.opts["timeout"] * 60,
859                 )
860             output["ret"] = action_out
861         return output
862     @staticmethod
863     def vm_config(name, main, provider, profile, overrides):
864         vm = main.copy()
865         vm = salt.utils.dictupdate.update(vm, provider)
866         vm = salt.utils.dictupdate.update(vm, profile)
867         vm.update(overrides)
868         vm["name"] = name
869         return vm
870     def extras(self, extra_):
871         output = {}
872         alias, driver = extra_["provider"].split(":")
873         fun = "{}.{}".format(driver, extra_["action"])
874         if fun not in self.clouds:
875             log.error(
876                 "Creating '%s' using '%s' as the provider "
877                 "cannot complete since '%s' is not available",
878                 extra_["name"],
879                 extra_["provider"],
880                 driver,
881             )
882             return
883         try:
884             with salt.utils.context.func_globals_inject(
885                 self.clouds[fun], __active_provider_name__=extra_["provider"]
886             ):
887                 output = self.clouds[fun](**extra_)
888         except KeyError as exc:
889             log.exception(
890                 "Failed to perform %s.%s on %s. Configuration value %s needs to be set",
891                 extra_["provider"],
892                 extra_["action"],
893                 extra_["name"],
894                 exc,
895             )
896         return output
897     def run_profile(self, profile, names, vm_overrides=None):
898         if profile not in self.opts["profiles"]:
899             msg = "Profile {} is not defined".format(profile)
900             log.error(msg)
901             return {"Error": msg}
902         ret = {}
903         if not vm_overrides:
904             vm_overrides = {}
905         try:
906             with salt.utils.files.fopen(self.opts["conf_file"], "r") as mcc:
907                 main_cloud_config = salt.utils.yaml.safe_load(mcc)
908             if not main_cloud_config:
909                 main_cloud_config = {}
910         except KeyError:
911             main_cloud_config = {}
912         except OSError:
913             main_cloud_config = {}
914         if main_cloud_config is None:
915             main_cloud_config = {}
916         mapped_providers = self.map_providers_parallel()
917         profile_details = self.opts["profiles"][profile]
918         vms = {}
919         for prov, val in mapped_providers.items():
920             prov_name = next(iter(val))
921             for node in mapped_providers[prov][prov_name]:
922                 vms[node] = mapped_providers[prov][prov_name][node]
923                 vms[node]["provider"] = prov
924                 vms[node]["driver"] = prov_name
925         alias, driver = profile_details["provider"].split(":")
926         provider_details = self.opts["providers"][alias][driver].copy()
927         del provider_details["profiles"]
928         for name in names:
929             if name in vms:
930                 prov = vms[name]["provider"]
931                 driv = vms[name]["driver"]
932                 msg = "{} already exists under {}:{}".format(name, prov, driv)
933                 log.error(msg)
934                 ret[name] = {"Error": msg}
935                 continue
936             vm_ = self.vm_config(
937                 name,
938                 main_cloud_config,
939                 provider_details,
940                 profile_details,
941                 vm_overrides,
942             )
943             if self.opts["parallel"]:
944                 process = multiprocessing.Process(target=self.create, args=(vm_,))
945                 process.start()
946                 ret[name] = {
947                     "Provisioning": "VM being provisioned in parallel. PID: {}".format(
948                         process.pid
949                     )
950                 }
951                 continue
952             try:
953                 ret[name] = self.create(vm_)
954                 if not ret[name]:
955                     ret[name] = {"Error": "Failed to deploy VM"}
956                     if len(names) == 1:
957                         raise SaltCloudSystemExit("Failed to deploy VM")
958                     continue
959                 if self.opts.get("show_deploy_args", False) is False:
960                     ret[name].pop("deploy_kwargs", None)
961             except (SaltCloudSystemExit, SaltCloudConfigError) as exc:
962                 if len(names) == 1:
963                     raise
964                 ret[name] = {"Error": str(exc)}
965         return ret
966     def do_action(self, names, kwargs):
967         ret = {}
968         invalid_functions = {}
969         names = set(names)
970         for alias, drivers in self.map_providers_parallel().items():
971             if not names:
972                 break
973             for driver, vms in drivers.items():
974                 if not names:
975                     break
976                 valid_function = True
977                 fun = "{}.{}".format(driver, self.opts["action"])
978                 if fun not in self.clouds:
979                     log.info("'%s()' is not available. Not actioning...", fun)
980                     valid_function = False
981                 for vm_name, vm_details in vms.items():
982                     if not names:
983                         break
984                     if vm_name not in names:
985                         if not isinstance(vm_details, dict):
986                             vm_details = {}
987                         if "id" in vm_details and vm_details["id"] in names:
988                             vm_name = vm_details["id"]
989                         else:
990                             log.debug(
991                                 "vm:%s in provider:%s is not in name list:'%s'",
992                                 vm_name,
993                                 driver,
994                                 names,
995                             )
996                             continue
997                     if valid_function is False:
998                         if invalid_functions.get(fun) is None:
999                             invalid_functions.update({fun: []})
1000                         invalid_functions[fun].append(vm_name)
1001                         continue
1002                     with salt.utils.context.func_globals_inject(
1003                         self.clouds[fun],
1004                         __active_provider_name__=":".join([alias, driver]),
1005                     ):
1006                         if alias not in ret:
1007                             ret[alias] = {}
1008                         if driver not in ret[alias]:
1009                             ret[alias][driver] = {}
1010                         kwargs = salt.utils.args.clean_kwargs(**kwargs)
1011                         if kwargs:
1012                             ret[alias][driver][vm_name] = self.clouds[fun](
1013                                 vm_name, kwargs, call="action"
1014                             )
1015                         else:
1016                             ret[alias][driver][vm_name] = self.clouds[fun](
1017                                 vm_name, call="action"
1018                             )
1019                         names.remove(vm_name)
1020         missing_vms = set()
1021         if invalid_functions:
1022             ret["Invalid Actions"] = invalid_functions
1023             invalid_func_vms = set()
1024             for key, val in invalid_functions.items():
1025                 invalid_func_vms = invalid_func_vms.union(set(val))
1026             missing_vms = names.difference(invalid_func_vms)
1027             if missing_vms:
1028                 ret["Not Found"] = list(missing_vms)
1029                 ret["Not Actioned/Not Running"] = list(names)
1030         if not names:
1031             return ret
1032         if missing_vms:
1033             return ret
1034         ret["Not Actioned/Not Running"] = list(names)
1035         ret["Not Found"] = list(names)
1036         return ret
1037     def do_function(self, prov, func, kwargs):
1038         matches = self.lookup_providers(prov)
1039         if len(matches) &gt; 1:
1040             raise SaltCloudSystemExit(
1041                 "More than one results matched '{}'. Please specify one of: {}".format(
1042                     prov,
1043                     ", ".join(
1044                         ["{}:{}".format(alias, driver) for (alias, driver) in matches]
1045                     ),
1046                 )
1047             )
1048         alias, driver = matches.pop()
1049         fun = "{}.{}".format(driver, func)
1050         if fun not in self.clouds:
1051             raise SaltCloudSystemExit(
1052                 "The '{}' cloud provider alias, for the '{}' driver, does "
1053                 "not define the function '{}'".format(alias, driver, func)
1054             )
1055         log.debug("Trying to execute '%s' with the following kwargs: %s", fun, kwargs)
1056         with salt.utils.context.func_globals_inject(
1057             self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1058         ):
1059             if kwargs:
1060                 return {
1061                     alias: {driver: self.clouds[fun](call="function", kwargs=kwargs)}
1062                 }
1063             return {alias: {driver: self.clouds[fun](call="function")}}
1064     def __filter_non_working_providers(self):
1065         for alias, drivers in self.opts["providers"].copy().items():
1066             for driver in drivers.copy():
1067                 fun = "{}.get_configured_provider".format(driver)
1068                 if fun not in self.clouds:
1069                     log.warning(
1070                         "The cloud driver, '%s', configured under the "
1071                         "'%s' cloud provider alias, could not be loaded. "
1072                         "Please check your provider configuration files and "
1073                         "ensure all required dependencies are installed "
1074                         "for the '%s' driver.\n"
1075                         "In rare cases, this could indicate the '%s()' "
1076                         "function could not be found.\nRemoving '%s' from "
1077                         "the available providers list",
1078                         driver,
1079                         alias,
1080                         driver,
1081                         fun,
1082                         driver,
1083                     )
1084                     self.opts["providers"][alias].pop(driver)
1085                     if alias not in self.opts["providers"]:
1086                         continue
1087                     if not self.opts["providers"][alias]:
1088                         self.opts["providers"].pop(alias)
1089                     continue
1090                 with salt.utils.context.func_globals_inject(
1091                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1092                 ):
1093                     if self.clouds[fun]() is False:
1094                         log.warning(
1095                             "The cloud driver, '%s', configured under the "
1096                             "'%s' cloud provider alias is not properly "
1097                             "configured. Removing it from the available "
1098                             "providers list.",
1099                             driver,
1100                             alias,
1101                         )
1102                         self.opts["providers"][alias].pop(driver)
1103             if alias not in self.opts["providers"]:
1104                 continue
1105             if not self.opts["providers"][alias]:
1106                 self.opts["providers"].pop(alias)
1107 class Map(Cloud):
1108     def __init__(self, opts):
1109         Cloud.__init__(self, opts)
1110         self.rendered_map = self.read()
1111     def interpolated_map(self, query="list_nodes", cached=False):
1112         rendered_map = self.read().copy()
1113         interpolated_map = {}
1114         for profile, mapped_vms in rendered_map.items():
1115             names = set(mapped_vms)
1116             if profile not in self.opts["profiles"]:
1117                 if "Errors" not in interpolated_map:
1118                     interpolated_map["Errors"] = {}
1119                 msg = (
1120                     "No provider for the mapped '{}' profile was found. "
1121                     "Skipped VMS: {}".format(profile, ", ".join(names))
1122                 )
1123                 log.info(msg)
1124                 interpolated_map["Errors"][profile] = msg
1125                 continue
1126             matching = self.get_running_by_names(names, query, cached)
1127             for alias, drivers in matching.items():
1128                 for driver, vms in drivers.items():
1129                     for vm_name, vm_details in vms.items():
1130                         if alias not in interpolated_map:
1131                             interpolated_map[alias] = {}
1132                         if driver not in interpolated_map[alias]:
1133                             interpolated_map[alias][driver] = {}
1134                         interpolated_map[alias][driver][vm_name] = vm_details
1135                         try:
1136                             names.remove(vm_name)
1137                         except KeyError:
1138                             pass
1139             if not names:
1140                 continue
1141             profile_details = self.opts["profiles"][profile]
1142             alias, driver = profile_details["provider"].split(":")
1143             for vm_name in names:
1144                 if alias not in interpolated_map:
1145                     interpolated_map[alias] = {}
1146                 if driver not in interpolated_map[alias]:
1147                     interpolated_map[alias][driver] = {}
1148                 interpolated_map[alias][driver][vm_name] = "Absent"
1149         return interpolated_map
1150     def delete_map(self, query=None):
1151         query_map = self.interpolated_map(query=query)
1152         for alias, drivers in query_map.copy().items():
1153             if alias == "Errors":
1154                 continue
1155             for driver, vms in drivers.copy().items():
1156                 for vm_name, vm_details in vms.copy().items():
1157                     if vm_details == "Absent":
1158                         query_map[alias][driver].pop(vm_name)
1159                 if not query_map[alias][driver]:
1160                     query_map[alias].pop(driver)
1161             if not query_map[alias]:
1162                 query_map.pop(alias)
1163         return query_map
1164     def get_vmnames_by_action(self, action):
1165         query_map = self.interpolated_map("list_nodes")
1166         matching_states = {
1167             "start": ["stopped"],
1168             "stop": ["running", "active"],
1169             "reboot": ["running", "active"],
1170         }
1171         vm_names = []
1172         for alias, drivers in query_map.items():
1173             for driver, vms in drivers.items():
1174                 for vm_name, vm_details in vms.items():
1175                     try:
1176                         state_action = matching_states[action]
1177                     except KeyError:
1178                         log.error(
1179                             "The use of '%s' as an action is not supported "
1180                             "in this context. Only 'start', 'stop', and "
1181                             "'reboot' are supported options.",
1182                             action,
1183                         )
1184                         raise SaltCloudException()
1185                     if (
1186                         vm_details != "Absent"
1187                         and vm_details["state"].lower() in state_action
1188                     ):
1189                         vm_names.append(vm_name)
1190         return vm_names
1191     def read(self):
1192         map_ = None
1193         if self.opts.get("map", None) is None:
1194             if self.opts.get("map_data", None) is None:
1195                 if self.opts.get("map_pillar", None) is None:
1196                     pass
1197                 elif self.opts.get("map_pillar") not in self.opts.get("maps"):
1198                     log.error(
1199                         "The specified map not found in pillar at 'cloud:maps:%s'",
1200                         self.opts["map_pillar"],
1201                     )
1202                     raise SaltCloudNotFound()
1203                 else:
1204                     map_ = self.opts["maps"][self.opts.get("map_pillar")]
1205             else:
1206                 map_ = self.opts["map_data"]
1207         else:
1208             local_minion_opts = copy.deepcopy(self.opts)
1209             local_minion_opts["file_client"] = "local"
1210             self.minion = salt.minion.MasterMinion(local_minion_opts)
1211             if not os.path.isfile(self.opts["map"]):
1212                 if not (self.opts["map"]).startswith("salt://"):
1213                     log.error(
1214                         "The specified map file does not exist: '%s'", self.opts["map"]
1215                     )
1216                     raise SaltCloudNotFound()
1217             if (self.opts["map"]).startswith("salt://"):
1218                 cached_map = self.minion.functions["cp.cache_file"](self.opts["map"])
1219             else:
1220                 cached_map = self.opts["map"]
1221             try:
1222                 renderer = self.opts.get("renderer", "jinja|yaml")
1223                 rend = salt.loader.render(self.opts, {})
1224                 blacklist = self.opts.get("renderer_blacklist")
1225                 whitelist = self.opts.get("renderer_whitelist")
1226                 map_ = compile_template(
1227                     cached_map, rend, renderer, blacklist, whitelist
1228                 )
1229             except Exception as exc:  # pylint: disable=broad-except
1230                 log.error(
1231                     "Rendering map %s failed, render error:\n%s",
1232                     self.opts["map"],
1233                     exc,
1234                     exc_info_on_loglevel=logging.DEBUG,
1235                 )
1236                 return {}
1237             if "include" in map_:
1238                 map_ = salt.config.include_config(map_, self.opts["map"], verbose=False)
1239         if not map_:
1240             return {}
1241         for profile, mapped in map_.copy().items():
1242             if isinstance(mapped, (list, tuple)):
1243                 entries = {}
1244                 for mapping in mapped:
1245                     if isinstance(mapping, str):
1246                         mapping = {mapping: None}
1247                     for name, overrides in mapping.items():
1248                         if overrides is None or isinstance(overrides, bool):
1249                             overrides = {}
1250                         try:
1251                             overrides.setdefault("name", name)
1252                         except AttributeError:
1253                             log.error(
1254                                 "Cannot use 'name' as a minion id in a cloud map as it"
1255                                 " is a reserved word. Please change 'name' to a"
1256                                 " different minion id reference."
1257                             )
1258                             return {}
1259                         entries[name] = overrides
1260                 map_[profile] = entries
1261                 continue
1262             if isinstance(mapped, dict):
1263                 entries = {}
1264                 for name, overrides in mapped.items():
1265                     overrides.setdefault("name", name)
1266                     entries[name] = overrides
1267                 map_[profile] = entries
1268                 continue
1269             if isinstance(mapped, str):
1270                 mapped = [mapped]
1271             map_[profile] = {}
1272             for name in mapped:
1273                 map_[profile][name] = {"name": name}
1274         return map_
1275     def _has_loop(self, dmap, seen=None, val=None):
1276         if seen is None:
1277             for values in dmap["create"].values():
1278                 seen = []
1279                 try:
1280                     machines = values["requires"]
1281                 except KeyError:
1282                     machines = []
1283                 for machine in machines:
1284                     if self._has_loop(dmap, seen=list(seen), val=machine):
1285                         return True
1286         else:
1287             if val in seen:
1288                 return True
1289             seen.append(val)
1290             try:
1291                 machines = dmap["create"][val]["requires"]
1292             except KeyError:
1293                 machines = []
1294             for machine in machines:
1295                 if self._has_loop(dmap, seen=list(seen), val=machine):
1296                     return True
1297         return False
1298     def _calcdep(self, dmap, machine, data, level):
1299         try:
1300             deplist = data["requires"]
1301         except KeyError:
1302             return level
1303         levels = []
1304         for name in deplist:
1305             try:
1306                 data = dmap["create"][name]
1307             except KeyError:
1308                 try:
1309                     data = dmap["existing"][name]
1310                 except KeyError:
1311                     msg = "Missing dependency in cloud map"
1312                     log.error(msg)
1313                     raise SaltCloudException(msg)
1314             levels.append(self._calcdep(dmap, name, data, level))
1315         level = max(levels) + 1
1316         return level
1317     def map_data(self, cached=False):
1318         ret = {"create": {}}
1319         pmap = self.map_providers_parallel(cached=cached)
1320         exist = set()
1321         defined = set()
1322         rendered_map = copy.deepcopy(self.rendered_map)
1323         for profile_name, nodes in rendered_map.items():
1324             if profile_name not in self.opts["profiles"]:
1325                 msg = (
1326                     "The required profile, '{}', defined in the map "
1327                     "does not exist. The defined nodes, {}, will not "
1328                     "be created.".format(
1329                         profile_name, ", ".join("'{}'".format(node) for node in nodes)
1330                     )
1331                 )
1332                 log.error(msg)
1333                 if "errors" not in ret:
1334                     ret["errors"] = {}
1335                 ret["errors"][profile_name] = msg
1336                 continue
1337             profile_data = self.opts["profiles"].get(profile_name)
1338             for nodename, overrides in nodes.items():
1339                 if (
1340                     "provider" in overrides
1341                     and overrides["provider"] != profile_data["provider"]
1342                 ):
1343                     alias, driver = overrides.get("provider").split(":")
1344                 else:
1345                     alias, driver = profile_data.get("provider").split(":")
1346                 provider_details = copy.deepcopy(self.opts["providers"][alias][driver])
1347                 del provider_details["profiles"]
1348                 salt.utils.dictupdate.update(provider_details, profile_data)
1349                 nodedata = copy.deepcopy(provider_details)
1350                 for setting in ("grains", "master", "minion", "volumes", "requires"):
1351                     deprecated = "map_{}".format(setting)
1352                     if deprecated in overrides:
1353                         log.warning(
1354                             "The use of '%s' on the '%s' mapping has "
1355                             "been deprecated. The preferred way now is to "
1356                             "just define '%s'. For now, salt-cloud will do "
1357                             "the proper thing and convert the deprecated "
1358                             "mapping into the preferred one.",
1359                             deprecated,
1360                             nodename,
1361                             setting,
1362                         )
1363                         overrides[setting] = overrides.pop(deprecated)
1364                 if (
1365                     "minion" in overrides
1366                     and "minion" in nodedata
1367                     and "grains" in overrides["minion"]
1368                     and "grains" in nodedata["minion"]
1369                 ):
1370                     nodedata["minion"]["grains"].update(overrides["minion"]["grains"])
1371                     del overrides["minion"]["grains"]
1372                     if not overrides["minion"]:
1373                         del overrides["minion"]
1374                 nodedata = salt.utils.dictupdate.update(nodedata, overrides)
1375                 ret["create"][nodename] = nodedata
1376                 alias, driver = nodedata["provider"].split(":")
1377                 defined.add((alias, driver, nodename))
1378         def get_matching_by_name(name):
1379             matches = {}
1380             for alias, drivers in pmap.items():
1381                 for driver, vms in drivers.items():
1382                     for vm_name, details in vms.items():
1383                         if vm_name == name and driver not in matches:
1384                             matches[driver] = details["state"]
1385             return matches
1386         for alias, drivers in pmap.items():
1387             for driver, vms in drivers.items():
1388                 for name, details in vms.items():
1389                     exist.add((alias, driver, name))
1390                     if name not in ret["create"]:
1391                         continue
1392                     matching = get_matching_by_name(name)
1393                     if not matching:
1394                         continue
1395                     for item in matching:
1396                         if name not in ret["create"]:
1397                             break
1398                         log.warning(
1399                             "%r already exists, removing from the create map.", name
1400                         )
1401                         if "existing" not in ret:
1402                             ret["existing"] = {}
1403                         ret["existing"][name] = ret["create"].pop(name)
1404         if "hard" in self.opts and self.opts["hard"]:
1405             if self.opts["enable_hard_maps"] is False:
1406                 raise SaltCloudSystemExit(
1407                     "The --hard map can be extremely dangerous to use, "
1408                     "and therefore must explicitly be enabled in the main "
1409                     "configuration file, by setting 'enable_hard_maps' "
1410                     "to True"
1411                 )
1412             ret["destroy"] = exist.difference(defined)
1413         return ret
1414     def run_map(self, dmap):
1415         if self._has_loop(dmap):
1416             msg = "Uh-oh, that cloud map has a dependency loop!"
1417             log.error(msg)
1418             raise SaltCloudException(msg)
1419         for key, val in dmap["create"].items():
1420             log.info("Calculating dependencies for %s", key)
1421             level = 0
1422             level = self._calcdep(dmap, key, val, level)
1423             log.debug("Got execution order %s for %s", level, key)
1424             dmap["create"][key]["level"] = level
1425         try:
1426             existing_list = dmap["existing"].items()
1427         except KeyError:
1428             existing_list = {}.items()
1429         for key, val in existing_list:
1430             log.info("Calculating dependencies for %s", key)
1431             level = 0
1432             level = self._calcdep(dmap, key, val, level)
1433             log.debug("Got execution order %s for %s", level, key)
1434             dmap["existing"][key]["level"] = level
1435         create_list = sorted(dmap["create"].items(), key=lambda x: x[1]["level"])
1436         output = {}
1437         if self.opts["parallel"]:
1438             parallel_data = []
1439         master_name = None
1440         master_minion_name = None
1441         master_host = None
1442         master_finger = None
1443         try:
1444             master_name, master_profile = next(
1445                 (
1446                     (name, profile)
1447                     for name, profile in create_list
1448                     if profile.get("make_master", False) is True
1449                 )
1450             )
1451             master_minion_name = master_name
1452             log.debug("Creating new master '%s'", master_name)
1453             if (
1454                 salt.config.get_cloud_config_value("deploy", master_profile, self.opts)
1455                 is False
1456             ):
1457                 raise SaltCloudSystemExit(
1458                     "Cannot proceed with 'make_master' when salt deployment "
1459                     "is disabled(ex: --no-deploy)."
1460                 )
1461             log.debug("Generating master keys for '%s'", master_profile["name"])
1462             priv, pub = salt.utils.cloud.gen_keys(
1463                 salt.config.get_cloud_config_value("keysize", master_profile, self.opts)
1464             )
1465             master_profile["master_pub"] = pub
1466             master_profile["master_pem"] = priv
1467             master_temp_pub = salt.utils.files.mkstemp()
1468             with salt.utils.files.fopen(master_temp_pub, "w") as mtp:
1469                 mtp.write(pub)
1470             master_finger = salt.utils.crypt.pem_finger(
1471                 master_temp_pub, sum_type=self.opts["hash_type"]
1472             )
1473             os.unlink(master_temp_pub)
1474             if master_profile.get("make_minion", True) is True:
1475                 master_profile.setdefault("minion", {})
1476                 if "id" in master_profile["minion"]:
1477                     master_minion_name = master_profile["minion"]["id"]
1478                 if "master" not in master_profile["minion"]:
1479                     master_profile["minion"]["master"] = "127.0.0.1"
1480                     if master_finger is not None:
1481                         master_profile["master_finger"] = master_finger
1482             for name, profile in create_list:
1483                 make_minion = salt.config.get_cloud_config_value(
1484                     "make_minion", profile, self.opts, default=True
1485                 )
1486                 if make_minion is False:
1487                     continue
1488                 log.debug("Generating minion keys for '%s'", profile["name"])
1489                 priv, pub = salt.utils.cloud.gen_keys(
1490                     salt.config.get_cloud_config_value("keysize", profile, self.opts)
1491                 )
1492                 profile["pub_key"] = pub
1493                 profile["priv_key"] = priv
1494                 master_profile.setdefault("preseed_minion_keys", {})
1495                 master_profile["preseed_minion_keys"].update({name: pub})
1496             local_master = False
1497             if (
1498                 master_profile["minion"].get("local_master", False)
1499                 and master_profile["minion"].get("master", None) is not None
1500             ):
1501                 local_master = True
1502             out = self.create(master_profile, local_master=local_master)
1503             if not isinstance(out, dict):
1504                 log.debug("Master creation details is not a dictionary: %s", out)
1505             elif "Errors" in out:
1506                 raise SaltCloudSystemExit(
1507                     "An error occurred while creating the master, not "
1508                     "continuing: {}".format(out["Errors"])
1509                 )
1510             deploy_kwargs = (
1511                 self.opts.get("show_deploy_args", False) is True
1512                 and
1513                 out.get("deploy_kwargs", {})
1514                 or
1515                 out.pop("deploy_kwargs", {})
1516             )
1517             master_host = deploy_kwargs.get(
1518                 "salt_host", deploy_kwargs.get("host", None)
1519             )
1520             if master_host is None:
1521                 raise SaltCloudSystemExit(
1522                     "Host for new master {} was not found, aborting map".format(
1523                         master_name
1524                     )
1525                 )
1526             output[master_name] = out
1527         except StopIteration:
1528             log.debug("No make_master found in map")
1529             master_pub = os.path.join(self.opts["pki_dir"], "master.pub")
1530             if os.path.isfile(master_pub):
1531                 master_finger = salt.utils.crypt.pem_finger(
1532                     master_pub, sum_type=self.opts["hash_type"]
1533                 )
1534         opts = self.opts.copy()
1535         if self.opts["parallel"]:
1536             log.info(
1537                 "Since parallel deployment is in use, ssh console output "
1538                 "is disabled. All ssh output will be logged though"
1539             )
1540             opts["display_ssh_output"] = False
1541         local_master = master_name is None
1542         for name, profile in create_list:
1543             if name in (master_name, master_minion_name):
1544                 continue
1545             if (
1546                 "minion" in profile
1547                 and profile["minion"].get("local_master", False)
1548                 and profile["minion"].get("master", None) is not None
1549             ):
1550                 local_master = True
1551             if master_finger is not None and local_master is False:
1552                 profile["master_finger"] = master_finger
1553             if master_host is not None:
1554                 profile.setdefault("minion", {})
1555                 profile["minion"].setdefault("master", master_host)
1556             if self.opts["parallel"]:
1557                 parallel_data.append(
1558                     {
1559                         "opts": opts,
1560                         "name": name,
1561                         "profile": profile,
1562                         "local_master": local_master,
1563                     }
1564                 )
1565                 continue
1566             try:
1567                 output[name] = self.create(profile, local_master=local_master)
1568                 if (
1569                     self.opts.get("show_deploy_args", False) is False
1570                     and "deploy_kwargs" in output
1571                     and isinstance(output[name], dict)
1572                 ):
1573                     output[name].pop("deploy_kwargs", None)
1574             except SaltCloudException as exc:
1575                 log.error(
1576                     "Failed to deploy '%s'. Error: %s",
1577                     name,
1578                     exc,
1579                     exc_info_on_loglevel=logging.DEBUG,
1580                 )
1581                 output[name] = {"Error": str(exc)}
1582         for name in dmap.get("destroy", ()):
1583             output[name] = self.destroy(name)
1584         if self.opts["parallel"] and parallel_data:
1585             if "pool_size" in self.opts:
1586                 pool_size = self.opts["pool_size"]
1587             else:
1588                 pool_size = len(parallel_data)
1589             log.info("Cloud pool size: %s", pool_size)
1590             output_multip = enter_mainloop(
1591                 _create_multiprocessing, parallel_data, pool_size=pool_size
1592             )
1593             if self.opts["start_action"]:
1594                 actionlist = []
1595                 grp = -1
1596                 for key, val in groupby(dmap["create"].values(), lambda x: x["level"]):
1597                     actionlist.append([])
1598                     grp += 1
1599                     for item in val:
1600                         actionlist[grp].append(item["name"])
1601                 out = {}
1602                 for group in actionlist:
1603                     log.info(
1604                         "Running %s on %s", self.opts["start_action"], ", ".join(group)
1605                     )
1606                     with salt.client.get_local_client() as client:
1607                         out.update(
1608                             client.cmd(
1609                                 ",".join(group),
1610                                 self.opts["start_action"],
1611                                 timeout=self.opts["timeout"] * 60,
1612                                 tgt_type="list",
1613                             )
1614                         )
1615                 for obj in output_multip:
1616                     next(iter(obj.values()))["ret"] = out[next(iter(obj.keys()))]
1617                     output.update(obj)
1618             else:
1619                 for obj in output_multip:
1620                     output.update(obj)
1621         return output
1622 def init_pool_worker():
1623     signal.signal(signal.SIGINT, signal.SIG_IGN)
1624 def create_multiprocessing(parallel_data, queue=None):
1625     salt.utils.crypt.reinit_crypto()
1626     parallel_data["opts"]["output"] = "json"
1627     cloud = Cloud(parallel_data["opts"])
1628     try:
1629         output = cloud.create(
1630             parallel_data["profile"], local_master=parallel_data["local_master"]
1631         )
1632     except SaltCloudException as exc:
1633         log.error(
1634             "Failed to deploy '%s'. Error: %s",
1635             parallel_data["name"],
1636             exc,
1637             exc_info_on_loglevel=logging.DEBUG,
1638         )
1639         return {parallel_data["name"]: {"Error": str(exc)}}
1640     if parallel_data["opts"].get("show_deploy_args", False) is False and isinstance(
1641         output, dict
1642     ):
1643         output.pop("deploy_kwargs", None)
1644     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1645 def destroy_multiprocessing(parallel_data, queue=None):
1646     salt.utils.crypt.reinit_crypto()
1647     parallel_data["opts"]["output"] = "json"
1648     clouds = salt.loader.clouds(parallel_data["opts"])
1649     try:
1650         fun = clouds["{}.destroy".format(parallel_data["driver"])]
1651         with salt.utils.context.func_globals_inject(
1652             fun,
1653             __active_provider_name__=":".join(
1654                 [parallel_data["alias"], parallel_data["driver"]]
1655             ),
1656         ):
1657             output = fun(parallel_data["name"])
1658     except SaltCloudException as exc:
1659         log.error(
1660             "Failed to destroy %s. Error: %s",
1661             parallel_data["name"],
1662             exc,
1663             exc_info_on_loglevel=logging.DEBUG,
1664         )
1665         return {parallel_data["name"]: {"Error": str(exc)}}
1666     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1667 def run_parallel_map_providers_query(data, queue=None):
1668     salt.utils.crypt.reinit_crypto()
1669     cloud = Cloud(data["opts"])
1670     try:
1671         with salt.utils.context.func_globals_inject(
1672             cloud.clouds[data["fun"]],
1673             __active_provider_name__=":".join([data["alias"], data["driver"]]),
1674         ):
1675             return (
1676                 data["alias"],
1677                 data["driver"],
1678                 salt.utils.data.simple_types_filter(cloud.clouds[data["fun"]]()),
1679             )
1680     except Exception as err:  # pylint: disable=broad-except
1681         log.debug(
1682             "Failed to execute '%s()' while querying for running nodes: %s",
1683             data["fun"],
1684             err,
1685             exc_info_on_loglevel=logging.DEBUG,
1686         )
1687         return data["alias"], data["driver"], ()
1688 def _run_parallel_map_providers_query(*args, **kw):
1689     return communicator(run_parallel_map_providers_query)(*args[0], **kw)
1690 def _destroy_multiprocessing(*args, **kw):
1691     return communicator(destroy_multiprocessing)(*args[0], **kw)
1692 def _create_multiprocessing(*args, **kw):
1693     return communicator(create_multiprocessing)(*args[0], **kw)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
