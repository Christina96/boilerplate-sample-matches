<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for generate-names-file-from-failed-test-reports.py &amp; __init___57.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for generate-names-file-from-failed-test-reports.py &amp; __init___57.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>generate-names-file-from-failed-test-reports.py (11.650485%)<th>__init___57.py (0.32206118%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-24)<td><a href="#" name="0">(1244-1246)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>generate-names-file-from-failed-test-reports.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import argparse
2 import glob
3 import os
4 import sys
5 try:
6     import xunitparser
7 except ImportError:
8     sys.stderr.write(
9         "Please install the xunitparser python package to run this script\n"
10     )
11 <a name="0"></a>    sys.stderr.flush()
12     sys.exit(1)
13 REPO_ROOT = os<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(</b></font>__file__))))
14 def main():
15     parser = argparse.ArgumentParser()
16     parser.add_argument(
17         "--reports-dir",
18         default=os.path.join(REPO_ROOT, "artifacts", "xml-unittests-output"),
19         help="Path to the directory where the JUnit XML reports can be found",
20     )
21     parser.add_argument(
22         "output_file",
23         help=(
24             "Path to the file containing the failed tests listing to be fed to"
25             " --names-files"
26         ),
27     )
28     options = parser.parse_args()
29     total_xml_reports = 0
30     failures = set()
31     for fname in sorted(glob.glob(os.path.join(options.reports_dir, "*.xml"))):
32         total_xml_reports += 1
33         with open(fname) as rfh:
34             test_suite, test_result = xunitparser.parse(rfh)
35             if not test_result.errors and not test_result.failures:
36                 continue
37             for test in test_suite:
38                 if test.bad:
39                     failures.add("{classname}.{methodname}".format(**test.__dict__))
40     if not total_xml_reports:
41         parser.exit(status=1, message="No JUnit XML files were parsed")
42     with open(options.output_file, "w") as wfh:
43         wfh.write(os.linesep.join(sorted(failures)))
44     parser.exit(status=0)
45 if __name__ == "__main__":
46     main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___57.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import glob
3 import logging
4 import multiprocessing
5 import os
6 import signal
7 import time
8 import traceback
9 from itertools import groupby
10 import salt.client
11 import salt.config
12 import salt.loader
13 import salt.syspaths
14 import salt.utils.args
15 import salt.utils.cloud
16 import salt.utils.context
17 import salt.utils.crypt
18 import salt.utils.data
19 import salt.utils.dictupdate
20 import salt.utils.files
21 import salt.utils.user
22 import salt.utils.verify
23 import salt.utils.yaml
24 from salt.exceptions import (
25     SaltCloudConfigError,
26     SaltCloudException,
27     SaltCloudNotFound,
28     SaltCloudSystemExit,
29 )
30 from salt.template import compile_template
31 try:
32     import Cryptodome.Random
33 except ImportError:
34     try:
35         import Crypto.Random  # nosec
36     except ImportError:
37         pass  # pycrypto &lt; 2.1
38 log = logging.getLogger(__name__)
39 def communicator(func):
40     def _call(queue, args, kwargs):
41         kwargs["queue"] = queue
42         ret = None
43         try:
44             ret = func(*args, **kwargs)
45             queue.put("END")
46         except KeyboardInterrupt as ex:
47             trace = traceback.format_exc()
48             queue.put("KEYBOARDINT")
49             queue.put("Keyboard interrupt")
50             queue.put("{}\n{}\n".format(ex, trace))
51         except Exception as ex:  # pylint: disable=broad-except
52             trace = traceback.format_exc()
53             queue.put("ERROR")
54             queue.put("Exception")
55             queue.put("{}\n{}\n".format(ex, trace))
56         except SystemExit as ex:
57             trace = traceback.format_exc()
58             queue.put("ERROR")
59             queue.put("System exit")
60             queue.put("{}\n{}\n".format(ex, trace))
61         return ret
62     return _call
63 def enter_mainloop(
64     target,
65     mapped_args=None,
66     args=None,
67     kwargs=None,
68     pool=None,
69     pool_size=None,
70     callback=None,
71     queue=None,
72 ):
73     if not kwargs:
74         kwargs = {}
75     if not pool_size:
76         pool_size = 1
77     if not pool:
78         pool = multiprocessing.Pool(pool_size)
79     if not queue:
80         manager = multiprocessing.Manager()
81         queue = manager.Queue()
82     if mapped_args is not None and not mapped_args:
83         msg = (
84             "We are called to asynchronously execute {}"
85             " but we do no have anything to execute, weird,"
86             " we bail out".format(target)
87         )
88         log.error(msg)
89         raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
90     elif mapped_args is not None:
91         iterable = [[queue, [arg], kwargs] for arg in mapped_args]
92         ret = pool.map(func=target, iterable=iterable)
93     else:
94         ret = pool.apply(target, [queue, args, kwargs])
95     while True:
96         test = queue.get()
97         if test in ["ERROR", "KEYBOARDINT"]:
98             type_ = queue.get()
99             trace = queue.get()
100             msg = "Caught {}, terminating workers\n".format(type_)
101             msg += "TRACE: {}\n".format(trace)
102             log.error(msg)
103             pool.terminate()
104             pool.join()
105             raise SaltCloudSystemExit("Exception caught\n{}".format(msg))
106         elif test in ["END"] or (callback and callback(test)):
107             pool.close()
108             pool.join()
109             break
110         else:
111             time.sleep(0.125)
112     return ret
113 class CloudClient:
114     def __init__(self, path=None, opts=None, config_dir=None, pillars=None):
115         if opts:
116             self.opts = opts
117         else:
118             self.opts = salt.config.cloud_config(path)
119         v_dirs = [self.opts["cachedir"]]
120         salt.utils.verify.verify_env(v_dirs, salt.utils.user.get_user())
121         if pillars:
122             for name, provider in pillars.pop("providers", {}).items():
123                 driver = provider["driver"]
124                 provider["profiles"] = {}
125                 self.opts["providers"].update({name: {driver: provider}})
126             for name, profile in pillars.pop("profiles", {}).items():
127                 provider = profile["provider"].split(":")[0]
128                 driver = next(iter(self.opts["providers"][provider].keys()))
129                 profile["provider"] = "{}:{}".format(provider, driver)
130                 profile["profile"] = name
131                 self.opts["profiles"].update({name: profile})
132                 self.opts["providers"][provider][driver]["profiles"].update(
133                     {name: profile}
134                 )
135             for name, map_dct in pillars.pop("maps", {}).items():
136                 if "maps" not in self.opts:
137                     self.opts["maps"] = {}
138                 self.opts["maps"][name] = map_dct
139             self.opts.update(pillars)
140     def _opts_defaults(self, **kwargs):
141         opts = salt.config.DEFAULT_CLOUD_OPTS.copy()
142         opts.update(self.opts.copy())
143         opts["parallel"] = False
144         opts["keep_tmp"] = False
145         opts["deploy"] = True
146         opts["update_bootstrap"] = False
147         opts["show_deploy_args"] = False
148         opts["script_args"] = ""
149         if "kwargs" in kwargs:
150             opts.update(kwargs["kwargs"])
151         opts.update(kwargs)
152         profile = opts.get("profile", None)
153         if profile:
154             tmp_profiles = opts.get("profiles", {}).copy()
155             for _profile in [a for a in tmp_profiles]:
156                 if not _profile == profile:
157                     tmp_profiles.pop(_profile)
158             providers = [
159                 a.get("provider", "").split(":")[0]
160                 for a in tmp_profiles.values()
161                 if a.get("provider", "")
162             ]
163             if providers:
164                 _providers = opts.get("providers", {})
165                 for provider in _providers.copy():
166                     if provider not in providers:
167                         _providers.pop(provider)
168         return opts
169     def low(self, fun, low):
170         l_fun = getattr(self, fun)
171         f_call = salt.utils.args.format_call(l_fun, low)
172         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
173     def list_sizes(self, provider=None):
174         mapper = salt.cloud.Map(self._opts_defaults())
175         return salt.utils.data.simple_types_filter(mapper.size_list(provider))
176     def list_images(self, provider=None):
177         mapper = salt.cloud.Map(self._opts_defaults())
178         return salt.utils.data.simple_types_filter(mapper.image_list(provider))
179     def list_locations(self, provider=None):
180         mapper = salt.cloud.Map(self._opts_defaults())
181         return salt.utils.data.simple_types_filter(mapper.location_list(provider))
182     def query(self, query_type="list_nodes"):
183         mapper = salt.cloud.Map(self._opts_defaults())
184         mapper.opts["selected_query_option"] = "list_nodes"
185         return mapper.map_providers_parallel(query_type)
186     def full_query(self, query_type="list_nodes_full"):
187         mapper = salt.cloud.Map(self._opts_defaults())
188         mapper.opts["selected_query_option"] = "list_nodes_full"
189         return mapper.map_providers_parallel(query_type)
190     def select_query(self, query_type="list_nodes_select"):
191         mapper = salt.cloud.Map(self._opts_defaults())
192         mapper.opts["selected_query_option"] = "list_nodes_select"
193         return mapper.map_providers_parallel(query_type)
194     def min_query(self, query_type="list_nodes_min"):
195         mapper = salt.cloud.Map(self._opts_defaults())
196         mapper.opts["selected_query_option"] = "list_nodes_min"
197         return mapper.map_providers_parallel(query_type)
198     def profile(self, profile, names, vm_overrides=None, **kwargs):
199         if not vm_overrides:
200             vm_overrides = {}
201         kwargs["profile"] = profile
202         mapper = salt.cloud.Map(self._opts_defaults(**kwargs))
203         if isinstance(names, str):
204             names = names.split(",")
205         return salt.utils.data.simple_types_filter(
206             mapper.run_profile(profile, names, vm_overrides=vm_overrides)
207         )
208     def map_run(self, path=None, **kwargs):
209         kwarg = {}
210         if path:
211             kwarg["map"] = path
212         kwarg.update(kwargs)
213         mapper = salt.cloud.Map(self._opts_defaults(**kwarg))
214         dmap = mapper.map_data()
215         return salt.utils.data.simple_types_filter(mapper.run_map(dmap))
216     def destroy(self, names):
217         mapper = salt.cloud.Map(self._opts_defaults(destroy=True))
218         if isinstance(names, str):
219             names = names.split(",")
220         return salt.utils.data.simple_types_filter(mapper.destroy(names))
221     def create(self, provider, names, **kwargs):
222         mapper = salt.cloud.Map(self._opts_defaults())
223         providers = self.opts["providers"]
224         if provider in providers:
225             provider += ":{}".format(next(iter(providers[provider].keys())))
226         else:
227             return False
228         if isinstance(names, str):
229             names = names.split(",")
230         ret = {}
231         for name in names:
232             vm_ = kwargs.copy()
233             vm_["name"] = name
234             vm_["driver"] = provider
235             vm_["profile"] = None
236             vm_["provider"] = provider
237             ret[name] = salt.utils.data.simple_types_filter(mapper.create(vm_))
238         return ret
239     def extra_action(self, names, provider, action, **kwargs):
240         mapper = salt.cloud.Map(self._opts_defaults())
241         providers = mapper.map_providers_parallel()
242         if provider in providers:
243             provider += ":{}".format(next(iter(providers[provider].keys())))
244         else:
245             return False
246         if isinstance(names, str):
247             names = names.split(",")
248         ret = {}
249         for name in names:
250             extra_ = kwargs.copy()
251             extra_["name"] = name
252             extra_["provider"] = provider
253             extra_["profile"] = None
254             extra_["action"] = action
255             ret[name] = salt.utils.data.simple_types_filter(mapper.extras(extra_))
256         return ret
257     def action(
258         self,
259         fun=None,
260         cloudmap=None,
261         names=None,
262         provider=None,
263         instance=None,
264         kwargs=None,
265     ):
266         if kwargs is None:
267             kwargs = {}
268         mapper = salt.cloud.Map(self._opts_defaults(action=fun, names=names, **kwargs))
269         if instance:
270             if names:
271                 raise SaltCloudConfigError(
272                     "Please specify either a list of 'names' or a single "
273                     "'instance', but not both."
274                 )
275             names = [instance]
276         if names and not provider:
277             self.opts["action"] = fun
278             return mapper.do_action(names, kwargs)
279         if provider and not names:
280             return mapper.do_function(provider, fun, kwargs)
281         else:
282             raise SaltCloudConfigError(
283                 "Either an instance (or list of names) or a provider must be "
284                 "specified, but not both."
285             )
286 class Cloud:
287     def __init__(self, opts):
288         self.opts = opts
289         self.clouds = salt.loader.clouds(self.opts)
290         self.__filter_non_working_providers()
291         self.__cached_provider_queries = {}
292     def get_configured_providers(self):
293         providers = set()
294         for alias, drivers in self.opts["providers"].items():
295             if len(drivers) &gt; 1:
296                 for driver in drivers:
297                     providers.add("{}:{}".format(alias, driver))
298                 continue
299             providers.add(alias)
300         return providers
301     def lookup_providers(self, lookup):
302         if lookup is None:
303             lookup = "all"
304         if lookup == "all":
305             providers = set()
306             for alias, drivers in self.opts["providers"].items():
307                 for driver in drivers:
308                     providers.add((alias, driver))
309             if not providers:
310                 raise SaltCloudSystemExit("There are no cloud providers configured.")
311             return providers
312         if ":" in lookup:
313             alias, driver = lookup.split(":")
314             if (
315                 alias not in self.opts["providers"]
316                 or driver not in self.opts["providers"][alias]
317             ):
318                 raise SaltCloudSystemExit(
319                     "No cloud providers matched '{}'. Available: {}".format(
320                         lookup, ", ".join(self.get_configured_providers())
321                     )
322                 )
323         providers = set()
324         for alias, drivers in self.opts["providers"].items():
325             for driver in drivers:
326                 if lookup in (alias, driver):
327                     providers.add((alias, driver))
328         if not providers:
329             raise SaltCloudSystemExit(
330                 "No cloud providers matched '{}'. Available selections: {}".format(
331                     lookup, ", ".join(self.get_configured_providers())
332                 )
333             )
334         return providers
335     def lookup_profiles(self, provider, lookup):
336         if provider is None:
337             provider = "all"
338         if lookup is None:
339             lookup = "all"
340         if lookup == "all":
341             profiles = set()
342             provider_profiles = set()
343             for alias, info in self.opts["profiles"].items():
344                 providers = info.get("provider")
345                 if providers:
346                     given_prov_name = providers.split(":")[0]
347                     salt_prov_name = providers.split(":")[1]
348                     if given_prov_name == provider:
349                         provider_profiles.add((alias, given_prov_name))
350                     elif salt_prov_name == provider:
351                         provider_profiles.add((alias, salt_prov_name))
352                     profiles.add((alias, given_prov_name))
353             if not profiles:
354                 raise SaltCloudSystemExit("There are no cloud profiles configured.")
355             if provider != "all":
356                 return provider_profiles
357             return profiles
358     def map_providers(self, query="list_nodes", cached=False):
359         if cached is True and query in self.__cached_provider_queries:
360             return self.__cached_provider_queries[query]
361         pmap = {}
362         for alias, drivers in self.opts["providers"].items():
363             for driver, details in drivers.items():
364                 fun = "{}.{}".format(driver, query)
365                 if fun not in self.clouds:
366                     log.error("Public cloud provider %s is not available", driver)
367                     continue
368                 if alias not in pmap:
369                     pmap[alias] = {}
370                 try:
371                     with salt.utils.context.func_globals_inject(
372                         self.clouds[fun],
373                         __active_provider_name__=":".join([alias, driver]),
374                     ):
375                         pmap[alias][driver] = self.clouds[fun]()
376                 except Exception as err:  # pylint: disable=broad-except
377                     log.debug(
378                         "Failed to execute '%s()' while querying for running nodes: %s",
379                         fun,
380                         err,
381                         exc_info_on_loglevel=logging.DEBUG,
382                     )
383                     pmap[alias][driver] = []
384         self.__cached_provider_queries[query] = pmap
385         return pmap
386     def map_providers_parallel(self, query="list_nodes", cached=False):
387         if cached is True and query in self.__cached_provider_queries:
388             return self.__cached_provider_queries[query]
389         opts = self.opts.copy()
390         multiprocessing_data = []
391         opts["providers"] = self._optimize_providers(opts["providers"])
392         for alias, drivers in opts["providers"].items():
393             this_query = query
394             for driver, details in drivers.items():
395                 if (
396                     opts.get("selected_query_option") is None
397                     and "{}.list_nodes_min".format(driver) in self.clouds
398                 ):
399                     this_query = "list_nodes_min"
400                 fun = "{}.{}".format(driver, this_query)
401                 if fun not in self.clouds:
402                     log.error("Public cloud provider %s is not available", driver)
403                     continue
404                 multiprocessing_data.append(
405                     {
406                         "fun": fun,
407                         "opts": opts,
408                         "query": this_query,
409                         "alias": alias,
410                         "driver": driver,
411                     }
412                 )
413         output = {}
414         if not multiprocessing_data:
415             return output
416         data_count = len(multiprocessing_data)
417         pool = multiprocessing.Pool(
418             data_count &lt; 10 and data_count or 10, init_pool_worker
419         )
420         parallel_pmap = enter_mainloop(
421             _run_parallel_map_providers_query, multiprocessing_data, pool=pool
422         )
423         for alias, driver, details in parallel_pmap:
424             if not details:
425                 continue
426             if alias not in output:
427                 output[alias] = {}
428             output[alias][driver] = details
429         self.__cached_provider_queries[query] = output
430         return output
431     def get_running_by_names(
432         self, names, query="list_nodes", cached=False, profile=None
433     ):
434         if isinstance(names, str):
435             names = [names]
436         matches = {}
437         handled_drivers = {}
438         mapped_providers = self.map_providers_parallel(query, cached=cached)
439         for alias, drivers in mapped_providers.items():
440             for driver, vms in drivers.items():
441                 if driver not in handled_drivers:
442                     handled_drivers[driver] = alias
443                 if (
444                     profile
445                     and alias
446                     not in self.opts["profiles"][profile]["provider"].split(":")[0]
447                 ):
448                     continue
449                 for vm_name, details in vms.items():
450                     if vm_name not in names:
451                         continue
452                     elif (
453                         driver == "ec2"
454                         and "aws" in handled_drivers
455                         and "aws" in matches[handled_drivers["aws"]]
456                         and vm_name in matches[handled_drivers["aws"]]["aws"]
457                     ):
458                         continue
459                     elif (
460                         driver == "aws"
461                         and "ec2" in handled_drivers
462                         and "ec2" in matches[handled_drivers["ec2"]]
463                         and vm_name in matches[handled_drivers["ec2"]]["ec2"]
464                     ):
465                         continue
466                     if alias not in matches:
467                         matches[alias] = {}
468                     if driver not in matches[alias]:
469                         matches[alias][driver] = {}
470                     matches[alias][driver][vm_name] = details
471         return matches
472     def _optimize_providers(self, providers):
473         new_providers = {}
474         provider_by_driver = {}
475         for alias, driver in providers.items():
476             for name, data in driver.items():
477                 if name not in provider_by_driver:
478                     provider_by_driver[name] = {}
479                 provider_by_driver[name][alias] = data
480         for driver, providers_data in provider_by_driver.items():
481             fun = "{}.optimize_providers".format(driver)
482             if fun not in self.clouds:
483                 log.debug("The '%s' cloud driver is unable to be optimized.", driver)
484                 for name, prov_data in providers_data.items():
485                     if name not in new_providers:
486                         new_providers[name] = {}
487                     new_providers[name][driver] = prov_data
488                 continue
489             new_data = self.clouds[fun](providers_data)
490             if new_data:
491                 for name, prov_data in new_data.items():
492                     if name not in new_providers:
493                         new_providers[name] = {}
494                     new_providers[name][driver] = prov_data
495         return new_providers
496     def location_list(self, lookup="all"):
497         data = {}
498         lookups = self.lookup_providers(lookup)
499         if not lookups:
500             return data
501         for alias, driver in lookups:
502             fun = "{}.avail_locations".format(driver)
503             if fun not in self.clouds:
504                 log.debug(
505                     "The '%s' cloud driver defined under '%s' provider "
506                     "alias is unable to get the locations information",
507                     driver,
508                     alias,
509                 )
510                 continue
511             if alias not in data:
512                 data[alias] = {}
513             try:
514                 with salt.utils.context.func_globals_inject(
515                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
516                 ):
517                     data[alias][driver] = self.clouds[fun]()
518             except Exception as err:  # pylint: disable=broad-except
519                 log.error(
520                     "Failed to get the output of '%s()': %s",
521                     fun,
522                     err,
523                     exc_info_on_loglevel=logging.DEBUG,
524                 )
525         return data
526     def image_list(self, lookup="all"):
527         data = {}
528         lookups = self.lookup_providers(lookup)
529         if not lookups:
530             return data
531         for alias, driver in lookups:
532             fun = "{}.avail_images".format(driver)
533             if fun not in self.clouds:
534                 log.debug(
535                     "The '%s' cloud driver defined under '%s' provider "
536                     "alias is unable to get the images information",
537                     driver,
538                     alias,
539                 )
540                 continue
541             if alias not in data:
542                 data[alias] = {}
543             try:
544                 with salt.utils.context.func_globals_inject(
545                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
546                 ):
547                     data[alias][driver] = self.clouds[fun]()
548             except Exception as err:  # pylint: disable=broad-except
549                 log.error(
550                     "Failed to get the output of '%s()': %s",
551                     fun,
552                     err,
553                     exc_info_on_loglevel=logging.DEBUG,
554                 )
555         return data
556     def size_list(self, lookup="all"):
557         data = {}
558         lookups = self.lookup_providers(lookup)
559         if not lookups:
560             return data
561         for alias, driver in lookups:
562             fun = "{}.avail_sizes".format(driver)
563             if fun not in self.clouds:
564                 log.debug(
565                     "The '%s' cloud driver defined under '%s' provider "
566                     "alias is unable to get the sizes information",
567                     driver,
568                     alias,
569                 )
570                 continue
571             if alias not in data:
572                 data[alias] = {}
573             try:
574                 with salt.utils.context.func_globals_inject(
575                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
576                 ):
577                     data[alias][driver] = self.clouds[fun]()
578             except Exception as err:  # pylint: disable=broad-except
579                 log.error(
580                     "Failed to get the output of '%s()': %s",
581                     fun,
582                     err,
583                     exc_info_on_loglevel=logging.DEBUG,
584                 )
585         return data
586     def provider_list(self, lookup="all"):
587         data = {}
588         lookups = self.lookup_providers(lookup)
589         if not lookups:
590             return data
591         for alias, driver in lookups:
592             if alias not in data:
593                 data[alias] = {}
594             if driver not in data[alias]:
595                 data[alias][driver] = {}
596         return data
597     def profile_list(self, provider, lookup="all"):
598         data = {}
599         lookups = self.lookup_profiles(provider, lookup)
600         if not lookups:
601             return data
602         for alias, driver in lookups:
603             if alias not in data:
604                 data[alias] = {}
605             if driver not in data[alias]:
606                 data[alias][driver] = {}
607         return data
608     def create_all(self):
609         ret = []
610         for vm_name, vm_details in self.opts["profiles"].items():
611             ret.append({vm_name: self.create(vm_details)})
612         return ret
613     def destroy(self, names, cached=False):
614         processed = {}
615         names = set(names)
616         matching = self.get_running_by_names(names, cached=cached)
617         vms_to_destroy = set()
618         parallel_data = []
619         for alias, drivers in matching.items():
620             for driver, vms in drivers.items():
621                 for name in vms:
622                     if name in names:
623                         vms_to_destroy.add((alias, driver, name))
624                         if self.opts["parallel"]:
625                             parallel_data.append(
626                                 {
627                                     "opts": self.opts,
628                                     "name": name,
629                                     "alias": alias,
630                                     "driver": driver,
631                                 }
632                             )
633         if self.opts["parallel"] and parallel_data:
634             if "pool_size" in self.opts:
635                 pool_size = self.opts["pool_size"]
636             else:
637                 pool_size = len(parallel_data)
638             log.info("Destroying in parallel mode; Cloud pool size: %s", pool_size)
639             output_multip = enter_mainloop(
640                 _destroy_multiprocessing, parallel_data, pool_size=pool_size
641             )
642             ret_multip = {}
643             for obj in output_multip:
644                 ret_multip.update(obj)
645             for obj in parallel_data:
646                 alias = obj["alias"]
647                 driver = obj["driver"]
648                 name = obj["name"]
649                 if alias not in processed:
650                     processed[alias] = {}
651                 if driver not in processed[alias]:
652                     processed[alias][driver] = {}
653                 processed[alias][driver][name] = ret_multip[name]
654                 if name in names:
655                     names.remove(name)
656         else:
657             log.info("Destroying in non-parallel mode.")
658             for alias, driver, name in vms_to_destroy:
659                 fun = "{}.destroy".format(driver)
660                 with salt.utils.context.func_globals_inject(
661                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
662                 ):
663                     ret = self.clouds[fun](name)
664                 if alias not in processed:
665                     processed[alias] = {}
666                 if driver not in processed[alias]:
667                     processed[alias][driver] = {}
668                 processed[alias][driver][name] = ret
669                 if name in names:
670                     names.remove(name)
671         for alias, driver, name in vms_to_destroy:
672             ret = processed[alias][driver][name]
673             if not ret:
674                 continue
675             vm_ = {
676                 "name": name,
677                 "profile": None,
678                 "provider": ":".join([alias, driver]),
679                 "driver": driver,
680             }
681             minion_dict = salt.config.get_cloud_config_value(
682                 "minion", vm_, self.opts, default={}
683             )
684             key_file = os.path.join(
685                 self.opts["pki_dir"], "minions", minion_dict.get("id", name)
686             )
687             globbed_key_file = glob.glob("{}.*".format(key_file))
688             if not os.path.isfile(key_file) and not globbed_key_file:
689                 if isinstance(ret, dict) and "newname" in ret:
690                     salt.utils.cloud.remove_key(self.opts["pki_dir"], ret["newname"])
691                 continue
692             if os.path.isfile(key_file) and not globbed_key_file:
693                 salt.utils.cloud.remove_key(
694                     self.opts["pki_dir"], os.path.basename(key_file)
695                 )
696                 continue
697             if (
698                 not os.path.isfile(key_file)
699                 and globbed_key_file
700                 and len(globbed_key_file) == 1
701             ):
702                 salt.utils.cloud.remove_key(
703                     self.opts["pki_dir"], os.path.basename(globbed_key_file[0])
704                 )
705                 continue
706             print(
707                 "There are several minion keys who's name starts "
708                 "with '{}'. We need to ask you which one should be "
709                 "deleted:".format(name)
710             )
711             while True:
712                 for idx, filename in enumerate(globbed_key_file):
713                     print(" {}: {}".format(idx, os.path.basename(filename)))
714                 selection = input("Which minion key should be deleted(number)? ")
715                 try:
716                     selection = int(selection)
717                 except ValueError:
718                     print("'{}' is not a valid selection.".format(selection))
719                 try:
720                     filename = os.path.basename(globbed_key_file.pop(selection))
721                 except Exception:  # pylint: disable=broad-except
722                     continue
723                 delete = input("Delete '{}'? [Y/n]? ".format(filename))
724                 if delete == "" or delete.lower().startswith("y"):
725                     salt.utils.cloud.remove_key(self.opts["pki_dir"], filename)
726                     print("Deleted '{}'".format(filename))
727                     break
728                 print("Did not delete '{}'".format(filename))
729                 break
730         if names and not processed:
731             raise SaltCloudSystemExit(
732                 "The following VM's were not found: {}".format(", ".join(names))
733             )
734         elif names and processed:
735             processed["Not Found"] = names
736         elif not processed:
737             raise SaltCloudSystemExit("No machines were destroyed!")
738         return processed
739     def reboot(self, names):
740         ret = []
741         pmap = self.map_providers_parallel()
742         acts = {}
743         for prov, nodes in pmap.items():
744             acts[prov] = []
745             for node in nodes:
746                 if node in names:
747                     acts[prov].append(node)
748         for prov, names_ in acts.items():
749             fun = "{}.reboot".format(prov)
750             for name in names_:
751                 ret.append({name: self.clouds[fun](name)})
752         return ret
753     def create(self, vm_, local_master=True):
754         output = {}
755         minion_dict = salt.config.get_cloud_config_value(
756             "minion", vm_, self.opts, default={}
757         )
758         alias, driver = vm_["provider"].split(":")
759         fun = "{}.create".format(driver)
760         if fun not in self.clouds:
761             log.error(
762                 "Creating '%s' using '%s' as the provider "
763                 "cannot complete since '%s' is not available",
764                 vm_["name"],
765                 vm_["provider"],
766                 driver,
767             )
768             return
769         deploy = salt.config.get_cloud_config_value("deploy", vm_, self.opts)
770         make_master = salt.config.get_cloud_config_value("make_master", vm_, self.opts)
771         if deploy:
772             if not make_master and "master" not in minion_dict:
773                 log.warning(
774                     "There's no master defined on the '%s' VM settings.", vm_["name"]
775                 )
776             if "pub_key" not in vm_ and "priv_key" not in vm_:
777                 log.debug("Generating minion keys for '%s'", vm_["name"])
778                 priv, pub = salt.utils.cloud.gen_keys(
779                     salt.config.get_cloud_config_value("keysize", vm_, self.opts)
780                 )
781                 vm_["pub_key"] = pub
782                 vm_["priv_key"] = priv
783         else:
784             vm_["pub_key"] = None
785             vm_["priv_key"] = None
786         key_id = minion_dict.get("id", vm_["name"])
787         domain = vm_.get("domain")
788         if vm_.get("use_fqdn") and domain:
789             minion_dict["append_domain"] = domain
790         if "append_domain" in minion_dict:
791             key_id = ".".join([key_id, minion_dict["append_domain"]])
792         if make_master is True and "master_pub" not in vm_ and "master_pem" not in vm_:
793             log.debug("Generating the master keys for '%s'", vm_["name"])
794             master_priv, master_pub = salt.utils.cloud.gen_keys(
795                 salt.config.get_cloud_config_value("keysize", vm_, self.opts)
796             )
797             vm_["master_pub"] = master_pub
798             vm_["master_pem"] = master_priv
799         if local_master is True and deploy is True:
800             salt.utils.cloud.accept_key(self.opts["pki_dir"], vm_["pub_key"], key_id)
801         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, self.opts)
802         try:
803             vm_["inline_script"] = salt.config.get_cloud_config_value(
804                 "inline_script", vm_, self.opts
805             )
806         except KeyError:
807             pass
808         try:
809             alias, driver = vm_["provider"].split(":")
810             func = "{}.create".format(driver)
811             with salt.utils.context.func_globals_inject(
812                 self.clouds[fun], __active_provider_name__=":".join([alias, driver])
813             ):
814                 output = self.clouds[func](vm_)
815             if output is not False and "sync_after_install" in self.opts:
816                 if self.opts["sync_after_install"] not in (
817                     "all",
818                     "modules",
819                     "states",
820                     "grains",
821                 ):
822                     log.error("Bad option for sync_after_install")
823                     return output
824                 time.sleep(3)
825                 start = int(time.time())
826 <a name="0"></a>                while int(time.time()) &lt; start + 60:
827                     mopts_ = salt.config.DEFAULT_MASTER_OPTS
828                     conf_path = "/".join(self.opts<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["conf_file"].split("/")[:-1])
829                     mopts_.update(
830                         salt.config.master_config(os.path.join(</b></font>conf_path, "master"))
831                     )
832                     with salt.client.get_local_client(mopts=mopts_) as client:
833                         ret = client.cmd(
834                             vm_["name"],
835                             "saltutil.sync_{}".format(self.opts["sync_after_install"]),
836                             timeout=self.opts["timeout"],
837                         )
838                         if ret:
839                             log.info(
840                                 "Synchronized the following dynamic modules: %s", ret
841                             )
842                             break
843         except KeyError as exc:
844             log.exception(
845                 "Failed to create VM %s. Configuration value %s needs to be set",
846                 vm_["name"],
847                 exc,
848             )
849         try:
850             opt_map = self.opts["map"]
851         except KeyError:
852             opt_map = False
853         if self.opts["parallel"] and self.opts["start_action"] and not opt_map:
854             log.info("Running %s on %s", self.opts["start_action"], vm_["name"])
855             with salt.client.get_local_client(mopts=self.opts) as client:
856                 action_out = client.cmd(
857                     vm_["name"],
858                     self.opts["start_action"],
859                     timeout=self.opts["timeout"] * 60,
860                 )
861             output["ret"] = action_out
862         return output
863     @staticmethod
864     def vm_config(name, main, provider, profile, overrides):
865         vm = main.copy()
866         vm = salt.utils.dictupdate.update(vm, provider)
867         vm = salt.utils.dictupdate.update(vm, profile)
868         vm.update(overrides)
869         vm["name"] = name
870         return vm
871     def extras(self, extra_):
872         output = {}
873         alias, driver = extra_["provider"].split(":")
874         fun = "{}.{}".format(driver, extra_["action"])
875         if fun not in self.clouds:
876             log.error(
877                 "Creating '%s' using '%s' as the provider "
878                 "cannot complete since '%s' is not available",
879                 extra_["name"],
880                 extra_["provider"],
881                 driver,
882             )
883             return
884         try:
885             with salt.utils.context.func_globals_inject(
886                 self.clouds[fun], __active_provider_name__=extra_["provider"]
887             ):
888                 output = self.clouds[fun](**extra_)
889         except KeyError as exc:
890             log.exception(
891                 "Failed to perform %s.%s on %s. Configuration value %s needs to be set",
892                 extra_["provider"],
893                 extra_["action"],
894                 extra_["name"],
895                 exc,
896             )
897         return output
898     def run_profile(self, profile, names, vm_overrides=None):
899         if profile not in self.opts["profiles"]:
900             msg = "Profile {} is not defined".format(profile)
901             log.error(msg)
902             return {"Error": msg}
903         ret = {}
904         if not vm_overrides:
905             vm_overrides = {}
906         try:
907             with salt.utils.files.fopen(self.opts["conf_file"], "r") as mcc:
908                 main_cloud_config = salt.utils.yaml.safe_load(mcc)
909             if not main_cloud_config:
910                 main_cloud_config = {}
911         except KeyError:
912             main_cloud_config = {}
913         except OSError:
914             main_cloud_config = {}
915         if main_cloud_config is None:
916             main_cloud_config = {}
917         mapped_providers = self.map_providers_parallel()
918         profile_details = self.opts["profiles"][profile]
919         vms = {}
920         for prov, val in mapped_providers.items():
921             prov_name = next(iter(val))
922             for node in mapped_providers[prov][prov_name]:
923                 vms[node] = mapped_providers[prov][prov_name][node]
924                 vms[node]["provider"] = prov
925                 vms[node]["driver"] = prov_name
926         alias, driver = profile_details["provider"].split(":")
927         provider_details = self.opts["providers"][alias][driver].copy()
928         del provider_details["profiles"]
929         for name in names:
930             if name in vms:
931                 prov = vms[name]["provider"]
932                 driv = vms[name]["driver"]
933                 msg = "{} already exists under {}:{}".format(name, prov, driv)
934                 log.error(msg)
935                 ret[name] = {"Error": msg}
936                 continue
937             vm_ = self.vm_config(
938                 name,
939                 main_cloud_config,
940                 provider_details,
941                 profile_details,
942                 vm_overrides,
943             )
944             if self.opts["parallel"]:
945                 process = multiprocessing.Process(target=self.create, args=(vm_,))
946                 process.start()
947                 ret[name] = {
948                     "Provisioning": "VM being provisioned in parallel. PID: {}".format(
949                         process.pid
950                     )
951                 }
952                 continue
953             try:
954                 ret[name] = self.create(vm_)
955                 if not ret[name]:
956                     ret[name] = {"Error": "Failed to deploy VM"}
957                     if len(names) == 1:
958                         raise SaltCloudSystemExit("Failed to deploy VM")
959                     continue
960                 if self.opts.get("show_deploy_args", False) is False:
961                     ret[name].pop("deploy_kwargs", None)
962             except (SaltCloudSystemExit, SaltCloudConfigError) as exc:
963                 if len(names) == 1:
964                     raise
965                 ret[name] = {"Error": str(exc)}
966         return ret
967     def do_action(self, names, kwargs):
968         ret = {}
969         invalid_functions = {}
970         names = set(names)
971         for alias, drivers in self.map_providers_parallel().items():
972             if not names:
973                 break
974             for driver, vms in drivers.items():
975                 if not names:
976                     break
977                 valid_function = True
978                 fun = "{}.{}".format(driver, self.opts["action"])
979                 if fun not in self.clouds:
980                     log.info("'%s()' is not available. Not actioning...", fun)
981                     valid_function = False
982                 for vm_name, vm_details in vms.items():
983                     if not names:
984                         break
985                     if vm_name not in names:
986                         if not isinstance(vm_details, dict):
987                             vm_details = {}
988                         if "id" in vm_details and vm_details["id"] in names:
989                             vm_name = vm_details["id"]
990                         else:
991                             log.debug(
992                                 "vm:%s in provider:%s is not in name list:'%s'",
993                                 vm_name,
994                                 driver,
995                                 names,
996                             )
997                             continue
998                     if valid_function is False:
999                         if invalid_functions.get(fun) is None:
1000                             invalid_functions.update({fun: []})
1001                         invalid_functions[fun].append(vm_name)
1002                         continue
1003                     with salt.utils.context.func_globals_inject(
1004                         self.clouds[fun],
1005                         __active_provider_name__=":".join([alias, driver]),
1006                     ):
1007                         if alias not in ret:
1008                             ret[alias] = {}
1009                         if driver not in ret[alias]:
1010                             ret[alias][driver] = {}
1011                         kwargs = salt.utils.args.clean_kwargs(**kwargs)
1012                         if kwargs:
1013                             ret[alias][driver][vm_name] = self.clouds[fun](
1014                                 vm_name, kwargs, call="action"
1015                             )
1016                         else:
1017                             ret[alias][driver][vm_name] = self.clouds[fun](
1018                                 vm_name, call="action"
1019                             )
1020                         names.remove(vm_name)
1021         missing_vms = set()
1022         if invalid_functions:
1023             ret["Invalid Actions"] = invalid_functions
1024             invalid_func_vms = set()
1025             for key, val in invalid_functions.items():
1026                 invalid_func_vms = invalid_func_vms.union(set(val))
1027             missing_vms = names.difference(invalid_func_vms)
1028             if missing_vms:
1029                 ret["Not Found"] = list(missing_vms)
1030                 ret["Not Actioned/Not Running"] = list(names)
1031         if not names:
1032             return ret
1033         if missing_vms:
1034             return ret
1035         ret["Not Actioned/Not Running"] = list(names)
1036         ret["Not Found"] = list(names)
1037         return ret
1038     def do_function(self, prov, func, kwargs):
1039         matches = self.lookup_providers(prov)
1040         if len(matches) &gt; 1:
1041             raise SaltCloudSystemExit(
1042                 "More than one results matched '{}'. Please specify one of: {}".format(
1043                     prov,
1044                     ", ".join(
1045                         ["{}:{}".format(alias, driver) for (alias, driver) in matches]
1046                     ),
1047                 )
1048             )
1049         alias, driver = matches.pop()
1050         fun = "{}.{}".format(driver, func)
1051         if fun not in self.clouds:
1052             raise SaltCloudSystemExit(
1053                 "The '{}' cloud provider alias, for the '{}' driver, does "
1054                 "not define the function '{}'".format(alias, driver, func)
1055             )
1056         log.debug("Trying to execute '%s' with the following kwargs: %s", fun, kwargs)
1057         with salt.utils.context.func_globals_inject(
1058             self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1059         ):
1060             if kwargs:
1061                 return {
1062                     alias: {driver: self.clouds[fun](call="function", kwargs=kwargs)}
1063                 }
1064             return {alias: {driver: self.clouds[fun](call="function")}}
1065     def __filter_non_working_providers(self):
1066         for alias, drivers in self.opts["providers"].copy().items():
1067             for driver in drivers.copy():
1068                 fun = "{}.get_configured_provider".format(driver)
1069                 if fun not in self.clouds:
1070                     log.warning(
1071                         "The cloud driver, '%s', configured under the "
1072                         "'%s' cloud provider alias, could not be loaded. "
1073                         "Please check your provider configuration files and "
1074                         "ensure all required dependencies are installed "
1075                         "for the '%s' driver.\n"
1076                         "In rare cases, this could indicate the '%s()' "
1077                         "function could not be found.\nRemoving '%s' from "
1078                         "the available providers list",
1079                         driver,
1080                         alias,
1081                         driver,
1082                         fun,
1083                         driver,
1084                     )
1085                     self.opts["providers"][alias].pop(driver)
1086                     if alias not in self.opts["providers"]:
1087                         continue
1088                     if not self.opts["providers"][alias]:
1089                         self.opts["providers"].pop(alias)
1090                     continue
1091                 with salt.utils.context.func_globals_inject(
1092                     self.clouds[fun], __active_provider_name__=":".join([alias, driver])
1093                 ):
1094                     if self.clouds[fun]() is False:
1095                         log.warning(
1096                             "The cloud driver, '%s', configured under the "
1097                             "'%s' cloud provider alias is not properly "
1098                             "configured. Removing it from the available "
1099                             "providers list.",
1100                             driver,
1101                             alias,
1102                         )
1103                         self.opts["providers"][alias].pop(driver)
1104             if alias not in self.opts["providers"]:
1105                 continue
1106             if not self.opts["providers"][alias]:
1107                 self.opts["providers"].pop(alias)
1108 class Map(Cloud):
1109     def __init__(self, opts):
1110         Cloud.__init__(self, opts)
1111         self.rendered_map = self.read()
1112     def interpolated_map(self, query="list_nodes", cached=False):
1113         rendered_map = self.read().copy()
1114         interpolated_map = {}
1115         for profile, mapped_vms in rendered_map.items():
1116             names = set(mapped_vms)
1117             if profile not in self.opts["profiles"]:
1118                 if "Errors" not in interpolated_map:
1119                     interpolated_map["Errors"] = {}
1120                 msg = (
1121                     "No provider for the mapped '{}' profile was found. "
1122                     "Skipped VMS: {}".format(profile, ", ".join(names))
1123                 )
1124                 log.info(msg)
1125                 interpolated_map["Errors"][profile] = msg
1126                 continue
1127             matching = self.get_running_by_names(names, query, cached)
1128             for alias, drivers in matching.items():
1129                 for driver, vms in drivers.items():
1130                     for vm_name, vm_details in vms.items():
1131                         if alias not in interpolated_map:
1132                             interpolated_map[alias] = {}
1133                         if driver not in interpolated_map[alias]:
1134                             interpolated_map[alias][driver] = {}
1135                         interpolated_map[alias][driver][vm_name] = vm_details
1136                         try:
1137                             names.remove(vm_name)
1138                         except KeyError:
1139                             pass
1140             if not names:
1141                 continue
1142             profile_details = self.opts["profiles"][profile]
1143             alias, driver = profile_details["provider"].split(":")
1144             for vm_name in names:
1145                 if alias not in interpolated_map:
1146                     interpolated_map[alias] = {}
1147                 if driver not in interpolated_map[alias]:
1148                     interpolated_map[alias][driver] = {}
1149                 interpolated_map[alias][driver][vm_name] = "Absent"
1150         return interpolated_map
1151     def delete_map(self, query=None):
1152         query_map = self.interpolated_map(query=query)
1153         for alias, drivers in query_map.copy().items():
1154             if alias == "Errors":
1155                 continue
1156             for driver, vms in drivers.copy().items():
1157                 for vm_name, vm_details in vms.copy().items():
1158                     if vm_details == "Absent":
1159                         query_map[alias][driver].pop(vm_name)
1160                 if not query_map[alias][driver]:
1161                     query_map[alias].pop(driver)
1162             if not query_map[alias]:
1163                 query_map.pop(alias)
1164         return query_map
1165     def get_vmnames_by_action(self, action):
1166         query_map = self.interpolated_map("list_nodes")
1167         matching_states = {
1168             "start": ["stopped"],
1169             "stop": ["running", "active"],
1170             "reboot": ["running", "active"],
1171         }
1172         vm_names = []
1173         for alias, drivers in query_map.items():
1174             for driver, vms in drivers.items():
1175                 for vm_name, vm_details in vms.items():
1176                     try:
1177                         state_action = matching_states[action]
1178                     except KeyError:
1179                         log.error(
1180                             "The use of '%s' as an action is not supported "
1181                             "in this context. Only 'start', 'stop', and "
1182                             "'reboot' are supported options.",
1183                             action,
1184                         )
1185                         raise SaltCloudException()
1186                     if (
1187                         vm_details != "Absent"
1188                         and vm_details["state"].lower() in state_action
1189                     ):
1190                         vm_names.append(vm_name)
1191         return vm_names
1192     def read(self):
1193         map_ = None
1194         if self.opts.get("map", None) is None:
1195             if self.opts.get("map_data", None) is None:
1196                 if self.opts.get("map_pillar", None) is None:
1197                     pass
1198                 elif self.opts.get("map_pillar") not in self.opts.get("maps"):
1199                     log.error(
1200                         "The specified map not found in pillar at 'cloud:maps:%s'",
1201                         self.opts["map_pillar"],
1202                     )
1203                     raise SaltCloudNotFound()
1204                 else:
1205                     map_ = self.opts["maps"][self.opts.get("map_pillar")]
1206             else:
1207                 map_ = self.opts["map_data"]
1208         else:
1209             local_minion_opts = copy.deepcopy(self.opts)
1210             local_minion_opts["file_client"] = "local"
1211             self.minion = salt.minion.MasterMinion(local_minion_opts)
1212             if not os.path.isfile(self.opts["map"]):
1213                 if not (self.opts["map"]).startswith("salt://"):
1214                     log.error(
1215                         "The specified map file does not exist: '%s'", self.opts["map"]
1216                     )
1217                     raise SaltCloudNotFound()
1218             if (self.opts["map"]).startswith("salt://"):
1219                 cached_map = self.minion.functions["cp.cache_file"](self.opts["map"])
1220             else:
1221                 cached_map = self.opts["map"]
1222             try:
1223                 renderer = self.opts.get("renderer", "jinja|yaml")
1224                 rend = salt.loader.render(self.opts, {})
1225                 blacklist = self.opts.get("renderer_blacklist")
1226                 whitelist = self.opts.get("renderer_whitelist")
1227                 map_ = compile_template(
1228                     cached_map, rend, renderer, blacklist, whitelist
1229                 )
1230             except Exception as exc:  # pylint: disable=broad-except
1231                 log.error(
1232                     "Rendering map %s failed, render error:\n%s",
1233                     self.opts["map"],
1234                     exc,
1235                     exc_info_on_loglevel=logging.DEBUG,
1236                 )
1237                 return {}
1238             if "include" in map_:
1239                 map_ = salt.config.include_config(map_, self.opts["map"], verbose=False)
1240         if not map_:
1241             return {}
1242         for profile, mapped in map_.copy().items():
1243             if isinstance(mapped, (list, tuple)):
1244                 entries = {}
1245                 for mapping in mapped:
1246                     if isinstance(mapping, str):
1247                         mapping = {mapping: None}
1248                     for name, overrides in mapping.items():
1249                         if overrides is None or isinstance(overrides, bool):
1250                             overrides = {}
1251                         try:
1252                             overrides.setdefault("name", name)
1253                         except AttributeError:
1254                             log.error(
1255                                 "Cannot use 'name' as a minion id in a cloud map as it"
1256                                 " is a reserved word. Please change 'name' to a"
1257                                 " different minion id reference."
1258                             )
1259                             return {}
1260                         entries[name] = overrides
1261                 map_[profile] = entries
1262                 continue
1263             if isinstance(mapped, dict):
1264                 entries = {}
1265                 for name, overrides in mapped.items():
1266                     overrides.setdefault("name", name)
1267                     entries[name] = overrides
1268                 map_[profile] = entries
1269                 continue
1270             if isinstance(mapped, str):
1271                 mapped = [mapped]
1272             map_[profile] = {}
1273             for name in mapped:
1274                 map_[profile][name] = {"name": name}
1275         return map_
1276     def _has_loop(self, dmap, seen=None, val=None):
1277         if seen is None:
1278             for values in dmap["create"].values():
1279                 seen = []
1280                 try:
1281                     machines = values["requires"]
1282                 except KeyError:
1283                     machines = []
1284                 for machine in machines:
1285                     if self._has_loop(dmap, seen=list(seen), val=machine):
1286                         return True
1287         else:
1288             if val in seen:
1289                 return True
1290             seen.append(val)
1291             try:
1292                 machines = dmap["create"][val]["requires"]
1293             except KeyError:
1294                 machines = []
1295             for machine in machines:
1296                 if self._has_loop(dmap, seen=list(seen), val=machine):
1297                     return True
1298         return False
1299     def _calcdep(self, dmap, machine, data, level):
1300         try:
1301             deplist = data["requires"]
1302         except KeyError:
1303             return level
1304         levels = []
1305         for name in deplist:
1306             try:
1307                 data = dmap["create"][name]
1308             except KeyError:
1309                 try:
1310                     data = dmap["existing"][name]
1311                 except KeyError:
1312                     msg = "Missing dependency in cloud map"
1313                     log.error(msg)
1314                     raise SaltCloudException(msg)
1315             levels.append(self._calcdep(dmap, name, data, level))
1316         level = max(levels) + 1
1317         return level
1318     def map_data(self, cached=False):
1319         ret = {"create": {}}
1320         pmap = self.map_providers_parallel(cached=cached)
1321         exist = set()
1322         defined = set()
1323         rendered_map = copy.deepcopy(self.rendered_map)
1324         for profile_name, nodes in rendered_map.items():
1325             if profile_name not in self.opts["profiles"]:
1326                 msg = (
1327                     "The required profile, '{}', defined in the map "
1328                     "does not exist. The defined nodes, {}, will not "
1329                     "be created.".format(
1330                         profile_name, ", ".join("'{}'".format(node) for node in nodes)
1331                     )
1332                 )
1333                 log.error(msg)
1334                 if "errors" not in ret:
1335                     ret["errors"] = {}
1336                 ret["errors"][profile_name] = msg
1337                 continue
1338             profile_data = self.opts["profiles"].get(profile_name)
1339             for nodename, overrides in nodes.items():
1340                 if (
1341                     "provider" in overrides
1342                     and overrides["provider"] != profile_data["provider"]
1343                 ):
1344                     alias, driver = overrides.get("provider").split(":")
1345                 else:
1346                     alias, driver = profile_data.get("provider").split(":")
1347                 provider_details = copy.deepcopy(self.opts["providers"][alias][driver])
1348                 del provider_details["profiles"]
1349                 salt.utils.dictupdate.update(provider_details, profile_data)
1350                 nodedata = copy.deepcopy(provider_details)
1351                 for setting in ("grains", "master", "minion", "volumes", "requires"):
1352                     deprecated = "map_{}".format(setting)
1353                     if deprecated in overrides:
1354                         log.warning(
1355                             "The use of '%s' on the '%s' mapping has "
1356                             "been deprecated. The preferred way now is to "
1357                             "just define '%s'. For now, salt-cloud will do "
1358                             "the proper thing and convert the deprecated "
1359                             "mapping into the preferred one.",
1360                             deprecated,
1361                             nodename,
1362                             setting,
1363                         )
1364                         overrides[setting] = overrides.pop(deprecated)
1365                 if (
1366                     "minion" in overrides
1367                     and "minion" in nodedata
1368                     and "grains" in overrides["minion"]
1369                     and "grains" in nodedata["minion"]
1370                 ):
1371                     nodedata["minion"]["grains"].update(overrides["minion"]["grains"])
1372                     del overrides["minion"]["grains"]
1373                     if not overrides["minion"]:
1374                         del overrides["minion"]
1375                 nodedata = salt.utils.dictupdate.update(nodedata, overrides)
1376                 ret["create"][nodename] = nodedata
1377                 alias, driver = nodedata["provider"].split(":")
1378                 defined.add((alias, driver, nodename))
1379         def get_matching_by_name(name):
1380             matches = {}
1381             for alias, drivers in pmap.items():
1382                 for driver, vms in drivers.items():
1383                     for vm_name, details in vms.items():
1384                         if vm_name == name and driver not in matches:
1385                             matches[driver] = details["state"]
1386             return matches
1387         for alias, drivers in pmap.items():
1388             for driver, vms in drivers.items():
1389                 for name, details in vms.items():
1390                     exist.add((alias, driver, name))
1391                     if name not in ret["create"]:
1392                         continue
1393                     matching = get_matching_by_name(name)
1394                     if not matching:
1395                         continue
1396                     for item in matching:
1397                         if name not in ret["create"]:
1398                             break
1399                         log.warning(
1400                             "%r already exists, removing from the create map.", name
1401                         )
1402                         if "existing" not in ret:
1403                             ret["existing"] = {}
1404                         ret["existing"][name] = ret["create"].pop(name)
1405         if "hard" in self.opts and self.opts["hard"]:
1406             if self.opts["enable_hard_maps"] is False:
1407                 raise SaltCloudSystemExit(
1408                     "The --hard map can be extremely dangerous to use, "
1409                     "and therefore must explicitly be enabled in the main "
1410                     "configuration file, by setting 'enable_hard_maps' "
1411                     "to True"
1412                 )
1413             ret["destroy"] = exist.difference(defined)
1414         return ret
1415     def run_map(self, dmap):
1416         if self._has_loop(dmap):
1417             msg = "Uh-oh, that cloud map has a dependency loop!"
1418             log.error(msg)
1419             raise SaltCloudException(msg)
1420         for key, val in dmap["create"].items():
1421             log.info("Calculating dependencies for %s", key)
1422             level = 0
1423             level = self._calcdep(dmap, key, val, level)
1424             log.debug("Got execution order %s for %s", level, key)
1425             dmap["create"][key]["level"] = level
1426         try:
1427             existing_list = dmap["existing"].items()
1428         except KeyError:
1429             existing_list = {}.items()
1430         for key, val in existing_list:
1431             log.info("Calculating dependencies for %s", key)
1432             level = 0
1433             level = self._calcdep(dmap, key, val, level)
1434             log.debug("Got execution order %s for %s", level, key)
1435             dmap["existing"][key]["level"] = level
1436         create_list = sorted(dmap["create"].items(), key=lambda x: x[1]["level"])
1437         output = {}
1438         if self.opts["parallel"]:
1439             parallel_data = []
1440         master_name = None
1441         master_minion_name = None
1442         master_host = None
1443         master_finger = None
1444         try:
1445             master_name, master_profile = next(
1446                 (
1447                     (name, profile)
1448                     for name, profile in create_list
1449                     if profile.get("make_master", False) is True
1450                 )
1451             )
1452             master_minion_name = master_name
1453             log.debug("Creating new master '%s'", master_name)
1454             if (
1455                 salt.config.get_cloud_config_value("deploy", master_profile, self.opts)
1456                 is False
1457             ):
1458                 raise SaltCloudSystemExit(
1459                     "Cannot proceed with 'make_master' when salt deployment "
1460                     "is disabled(ex: --no-deploy)."
1461                 )
1462             log.debug("Generating master keys for '%s'", master_profile["name"])
1463             priv, pub = salt.utils.cloud.gen_keys(
1464                 salt.config.get_cloud_config_value("keysize", master_profile, self.opts)
1465             )
1466             master_profile["master_pub"] = pub
1467             master_profile["master_pem"] = priv
1468             master_temp_pub = salt.utils.files.mkstemp()
1469             with salt.utils.files.fopen(master_temp_pub, "w") as mtp:
1470                 mtp.write(pub)
1471             master_finger = salt.utils.crypt.pem_finger(
1472                 master_temp_pub, sum_type=self.opts["hash_type"]
1473             )
1474             os.unlink(master_temp_pub)
1475             if master_profile.get("make_minion", True) is True:
1476                 master_profile.setdefault("minion", {})
1477                 if "id" in master_profile["minion"]:
1478                     master_minion_name = master_profile["minion"]["id"]
1479                 if "master" not in master_profile["minion"]:
1480                     master_profile["minion"]["master"] = "127.0.0.1"
1481                     if master_finger is not None:
1482                         master_profile["master_finger"] = master_finger
1483             for name, profile in create_list:
1484                 make_minion = salt.config.get_cloud_config_value(
1485                     "make_minion", profile, self.opts, default=True
1486                 )
1487                 if make_minion is False:
1488                     continue
1489                 log.debug("Generating minion keys for '%s'", profile["name"])
1490                 priv, pub = salt.utils.cloud.gen_keys(
1491                     salt.config.get_cloud_config_value("keysize", profile, self.opts)
1492                 )
1493                 profile["pub_key"] = pub
1494                 profile["priv_key"] = priv
1495                 master_profile.setdefault("preseed_minion_keys", {})
1496                 master_profile["preseed_minion_keys"].update({name: pub})
1497             local_master = False
1498             if (
1499                 master_profile["minion"].get("local_master", False)
1500                 and master_profile["minion"].get("master", None) is not None
1501             ):
1502                 local_master = True
1503             out = self.create(master_profile, local_master=local_master)
1504             if not isinstance(out, dict):
1505                 log.debug("Master creation details is not a dictionary: %s", out)
1506             elif "Errors" in out:
1507                 raise SaltCloudSystemExit(
1508                     "An error occurred while creating the master, not "
1509                     "continuing: {}".format(out["Errors"])
1510                 )
1511             deploy_kwargs = (
1512                 self.opts.get("show_deploy_args", False) is True
1513                 and
1514                 out.get("deploy_kwargs", {})
1515                 or
1516                 out.pop("deploy_kwargs", {})
1517             )
1518             master_host = deploy_kwargs.get(
1519                 "salt_host", deploy_kwargs.get("host", None)
1520             )
1521             if master_host is None:
1522                 raise SaltCloudSystemExit(
1523                     "Host for new master {} was not found, aborting map".format(
1524                         master_name
1525                     )
1526                 )
1527             output[master_name] = out
1528         except StopIteration:
1529             log.debug("No make_master found in map")
1530             master_pub = os.path.join(self.opts["pki_dir"], "master.pub")
1531             if os.path.isfile(master_pub):
1532                 master_finger = salt.utils.crypt.pem_finger(
1533                     master_pub, sum_type=self.opts["hash_type"]
1534                 )
1535         opts = self.opts.copy()
1536         if self.opts["parallel"]:
1537             log.info(
1538                 "Since parallel deployment is in use, ssh console output "
1539                 "is disabled. All ssh output will be logged though"
1540             )
1541             opts["display_ssh_output"] = False
1542         local_master = master_name is None
1543         for name, profile in create_list:
1544             if name in (master_name, master_minion_name):
1545                 continue
1546             if (
1547                 "minion" in profile
1548                 and profile["minion"].get("local_master", False)
1549                 and profile["minion"].get("master", None) is not None
1550             ):
1551                 local_master = True
1552             if master_finger is not None and local_master is False:
1553                 profile["master_finger"] = master_finger
1554             if master_host is not None:
1555                 profile.setdefault("minion", {})
1556                 profile["minion"].setdefault("master", master_host)
1557             if self.opts["parallel"]:
1558                 parallel_data.append(
1559                     {
1560                         "opts": opts,
1561                         "name": name,
1562                         "profile": profile,
1563                         "local_master": local_master,
1564                     }
1565                 )
1566                 continue
1567             try:
1568                 output[name] = self.create(profile, local_master=local_master)
1569                 if (
1570                     self.opts.get("show_deploy_args", False) is False
1571                     and "deploy_kwargs" in output
1572                     and isinstance(output[name], dict)
1573                 ):
1574                     output[name].pop("deploy_kwargs", None)
1575             except SaltCloudException as exc:
1576                 log.error(
1577                     "Failed to deploy '%s'. Error: %s",
1578                     name,
1579                     exc,
1580                     exc_info_on_loglevel=logging.DEBUG,
1581                 )
1582                 output[name] = {"Error": str(exc)}
1583         for name in dmap.get("destroy", ()):
1584             output[name] = self.destroy(name)
1585         if self.opts["parallel"] and parallel_data:
1586             if "pool_size" in self.opts:
1587                 pool_size = self.opts["pool_size"]
1588             else:
1589                 pool_size = len(parallel_data)
1590             log.info("Cloud pool size: %s", pool_size)
1591             output_multip = enter_mainloop(
1592                 _create_multiprocessing, parallel_data, pool_size=pool_size
1593             )
1594             if self.opts["start_action"]:
1595                 actionlist = []
1596                 grp = -1
1597                 for key, val in groupby(dmap["create"].values(), lambda x: x["level"]):
1598                     actionlist.append([])
1599                     grp += 1
1600                     for item in val:
1601                         actionlist[grp].append(item["name"])
1602                 out = {}
1603                 for group in actionlist:
1604                     log.info(
1605                         "Running %s on %s", self.opts["start_action"], ", ".join(group)
1606                     )
1607                     with salt.client.get_local_client() as client:
1608                         out.update(
1609                             client.cmd(
1610                                 ",".join(group),
1611                                 self.opts["start_action"],
1612                                 timeout=self.opts["timeout"] * 60,
1613                                 tgt_type="list",
1614                             )
1615                         )
1616                 for obj in output_multip:
1617                     next(iter(obj.values()))["ret"] = out[next(iter(obj.keys()))]
1618                     output.update(obj)
1619             else:
1620                 for obj in output_multip:
1621                     output.update(obj)
1622         return output
1623 def init_pool_worker():
1624     signal.signal(signal.SIGINT, signal.SIG_IGN)
1625 def create_multiprocessing(parallel_data, queue=None):
1626     salt.utils.crypt.reinit_crypto()
1627     parallel_data["opts"]["output"] = "json"
1628     cloud = Cloud(parallel_data["opts"])
1629     try:
1630         output = cloud.create(
1631             parallel_data["profile"], local_master=parallel_data["local_master"]
1632         )
1633     except SaltCloudException as exc:
1634         log.error(
1635             "Failed to deploy '%s'. Error: %s",
1636             parallel_data["name"],
1637             exc,
1638             exc_info_on_loglevel=logging.DEBUG,
1639         )
1640         return {parallel_data["name"]: {"Error": str(exc)}}
1641     if parallel_data["opts"].get("show_deploy_args", False) is False and isinstance(
1642         output, dict
1643     ):
1644         output.pop("deploy_kwargs", None)
1645     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1646 def destroy_multiprocessing(parallel_data, queue=None):
1647     salt.utils.crypt.reinit_crypto()
1648     parallel_data["opts"]["output"] = "json"
1649     clouds = salt.loader.clouds(parallel_data["opts"])
1650     try:
1651         fun = clouds["{}.destroy".format(parallel_data["driver"])]
1652         with salt.utils.context.func_globals_inject(
1653             fun,
1654             __active_provider_name__=":".join(
1655                 [parallel_data["alias"], parallel_data["driver"]]
1656             ),
1657         ):
1658             output = fun(parallel_data["name"])
1659     except SaltCloudException as exc:
1660         log.error(
1661             "Failed to destroy %s. Error: %s",
1662             parallel_data["name"],
1663             exc,
1664             exc_info_on_loglevel=logging.DEBUG,
1665         )
1666         return {parallel_data["name"]: {"Error": str(exc)}}
1667     return {parallel_data["name"]: salt.utils.data.simple_types_filter(output)}
1668 def run_parallel_map_providers_query(data, queue=None):
1669     salt.utils.crypt.reinit_crypto()
1670     cloud = Cloud(data["opts"])
1671     try:
1672         with salt.utils.context.func_globals_inject(
1673             cloud.clouds[data["fun"]],
1674             __active_provider_name__=":".join([data["alias"], data["driver"]]),
1675         ):
1676             return (
1677                 data["alias"],
1678                 data["driver"],
1679                 salt.utils.data.simple_types_filter(cloud.clouds[data["fun"]]()),
1680             )
1681     except Exception as err:  # pylint: disable=broad-except
1682         log.debug(
1683             "Failed to execute '%s()' while querying for running nodes: %s",
1684             data["fun"],
1685             err,
1686             exc_info_on_loglevel=logging.DEBUG,
1687         )
1688         return data["alias"], data["driver"], ()
1689 def _run_parallel_map_providers_query(*args, **kw):
1690     return communicator(run_parallel_map_providers_query)(*args[0], **kw)
1691 def _destroy_multiprocessing(*args, **kw):
1692     return communicator(destroy_multiprocessing)(*args[0], **kw)
1693 def _create_multiprocessing(*args, **kw):
1694     return communicator(create_multiprocessing)(*args[0], **kw)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
