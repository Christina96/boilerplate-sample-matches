<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for haproxyconn.py &amp; boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for haproxyconn.py &amp; boto_apigateway.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>haproxyconn.py (3.7790697%)<th>boto_apigateway.py (0.513834%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-58)<td><a href="#" name="0">(1660-1673)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>haproxyconn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import stat
4 import time
5 try:
6     import haproxy.cmds  # pylint: disable=no-name-in-module
7     import haproxy.conn  # pylint: disable=no-name-in-module
8     HAS_HAPROXY = True
9 except ImportError:
10     HAS_HAPROXY = False
11 log = logging.getLogger(__name__)
12 __virtualname__ = "haproxy"
13 DEFAULT_SOCKET_URL = "/var/run/haproxy.sock"
14 FIELD_NUMERIC = ["weight", "bin", "bout"]
15 FIELD_NODE_NAME = "name"
16 def __virtual__():
17     if HAS_HAPROXY:
18         return __virtualname__
19     return (
20         False,
21         "The haproxyconn execution module cannot be loaded: haproxyctl module not"
22         " available",
23     )
24 def _get_conn(socket=DEFAULT_SOCKET_URL):
25     assert stat<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.S_ISSOCK(issock), "{} is not a socket.".format(socket)
26     ha_conn = haproxy.conn.HaPConn(socket)
27     return ha_conn
28 def list_servers(backend, socket=DEFAULT_SOCKET_URL, objectify=</b></font>False):
29     ha_conn = _get_conn(socket)
30     ha_cmd = haproxy.cmds.listServers(backend=backend)
31     return ha_conn.sendCmd(ha_cmd, objectify=objectify)
32 def wait_state(backend, server, value="up", timeout=60 * 5, socket=DEFAULT_SOCKET_URL):
33     t = time.time() + timeout
34     while time.time() &lt; t:
35         if (
36             get_backend(backend=backend, socket=socket)[server]["status"].lower()
37             == value.lower()
38         ):
39             return True
40     return False
41 def get_backend(backend, socket=DEFAULT_SOCKET_URL):
42     backend_data = (
43         list_servers(backend=backend, socket=socket).replace("\n", " ").split(" ")
44     )
45     result = {}
46     def num(s):
47         try:
48             return int(s)
49         except ValueError:
50             return s
51     for data in backend_data:
52         if ":" in data:
53             active_field = data.replace(":", "").lower()
54             continue
55         elif active_field.lower() == FIELD_NODE_NAME:
56             active_server = data
57             result[active_server] = {}
58             continue
59         if active_field in FIELD_NUMERIC:
60             if data == "":
61                 result[active_server][active_field] = 0
62             else:
63                 result[active_server][active_field] = num(data)
64         else:
65             result[active_server][active_field] = data
66     return result
67 def enable_server(name, backend, socket=DEFAULT_SOCKET_URL):
68     if backend == "*":
69         backends = show_backends(socket=socket).split("\n")
70     else:
71         backends = [backend]
72     results = {}
73     for backend in backends:
74         ha_conn = _get_conn(socket)
75         ha_cmd = haproxy.cmds.enableServer(server=name, backend=backend)
76         ha_conn.sendCmd(ha_cmd)
77         results[backend] = list_servers(backend, socket=socket)
78     return results
79 def disable_server(name, backend, socket=DEFAULT_SOCKET_URL):
80     if backend == "*":
81         backends = show_backends(socket=socket).split("\n")
82     else:
83         backends = [backend]
84     results = {}
85     for backend in backends:
86         ha_conn = _get_conn(socket)
87         ha_cmd = haproxy.cmds.disableServer(server=name, backend=backend)
88         ha_conn.sendCmd(ha_cmd)
89         results[backend] = list_servers(backend, socket=socket)
90     return results
91 def get_weight(name, backend, socket=DEFAULT_SOCKET_URL):
92     ha_conn = _get_conn(socket)
93     ha_cmd = haproxy.cmds.getWeight(server=name, backend=backend)
94     return ha_conn.sendCmd(ha_cmd)
95 def set_weight(name, backend, weight=0, socket=DEFAULT_SOCKET_URL):
96     ha_conn = _get_conn(socket)
97     ha_cmd = haproxy.cmds.getWeight(server=name, backend=backend, weight=weight)
98     ha_conn.sendCmd(ha_cmd)
99     return get_weight(name, backend, socket=socket)
100 def set_state(name, backend, state, socket=DEFAULT_SOCKET_URL):
101     class setServerState(haproxy.cmds.Cmd):
102         cmdTxt = "set server %(backend)s/%(server)s state %(value)s\r\n"
103         p_args = ["backend", "server", "value"]
104         helpTxt = "Force a server's administrative state to a new state."
105     ha_conn = _get_conn(socket)
106     ha_cmd = setServerState(server=name, backend=backend, value=state)
107     return ha_conn.sendCmd(ha_cmd)
108 def show_frontends(socket=DEFAULT_SOCKET_URL):
109     ha_conn = _get_conn(socket)
110     ha_cmd = haproxy.cmds.showFrontends()
111     return ha_conn.sendCmd(ha_cmd)
112 def list_frontends(socket=DEFAULT_SOCKET_URL):
113     return show_frontends(socket=socket).split("\n")
114 def show_backends(socket=DEFAULT_SOCKET_URL):
115     ha_conn = _get_conn(socket)
116     ha_cmd = haproxy.cmds.showBackends()
117     return ha_conn.sendCmd(ha_cmd)
118 def list_backends(servers=True, socket=DEFAULT_SOCKET_URL):
119     if not servers:
120         return show_backends(socket=socket).split("\n")
121     else:
122         result = {}
123         for backend in list_backends(servers=False, socket=socket):
124             result[backend] = get_backend(backend=backend, socket=socket)
125         return result
126 def get_sessions(name, backend, socket=DEFAULT_SOCKET_URL):
127     class getStats(haproxy.cmds.Cmd):
128         p_args = ["backend", "server"]
129         cmdTxt = "show stat\r\n"
130         helpText = "Fetch all statistics"
131     ha_conn = _get_conn(socket)
132     ha_cmd = getStats(server=name, backend=backend)
133     result = ha_conn.sendCmd(ha_cmd)
134     for line in result.split("\n"):
135         if line.startswith(backend):
136             outCols = line.split(",")
137             if outCols[1] == name:
138                 return outCols[4]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import hashlib
2 import logging
3 import os
4 import re
5 import salt.utils.files
6 import salt.utils.json
7 import salt.utils.yaml
8 log = logging.getLogger(__name__)
9 def __virtual__():
10     if "boto_apigateway.describe_apis" in __salt__:
11         return "boto_apigateway"
12     return (False, "boto_apigateway module could not be loaded")
13 def present(
14     name,
15     api_name,
16     swagger_file,
17     stage_name,
18     api_key_required,
19     lambda_integration_role,
20     lambda_region=None,
21     stage_variables=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     lambda_funcname_format="{stage}_{api}_{resource}_{method}",
27     authorization_type="NONE",
28     error_response_template=None,
29     response_template=None,
30 ):
31     ret = {"name": name, "result": True, "comment": "", "changes": {}}
32     try:
33         common_args = dict(
34             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
35         )
36         swagger = _Swagger(
37             api_name,
38             stage_name,
39             lambda_funcname_format,
40             swagger_file,
41             error_response_template,
42             response_template,
43             common_args,
44         )
45         stage_vars = _get_stage_variables(stage_variables)
46         ret = swagger.verify_api(ret)
47         if ret.get("publish"):
48             if __opts__["test"]:
49                 ret["comment"] = (
50                     "[stage: {}] will be reassociated to an already available "
51                     "deployment that matched the given [api_name: {}] "
52                     "and [swagger_file: {}].\n"
53                     "Stage variables will be set "
54                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
55                 )
56                 ret["result"] = None
57                 return ret
58             return swagger.publish_api(ret, stage_vars)
59         if ret.get("current"):
60             if __opts__["test"]:
61                 ret["comment"] = (
62                     "[stage: {}] is already at desired state with an associated "
63                     "deployment matching the given [api_name: {}] "
64                     "and [swagger_file: {}].\n"
65                     "Stage variables will be set "
66                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
67                 )
68                 ret["result"] = None
69             return swagger.overwrite_stage_variables(ret, stage_vars)
70         if __opts__["test"]:
71             ret["comment"] = (
72                 "There is no deployment matching the given [api_name: {}] "
73                 "and [swagger_file: {}].  A new deployment will be "
74                 "created and the [stage_name: {}] will then be associated "
75                 "to the newly created deployment.\n"
76                 "Stage variables will be set "
77                 "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
78             )
79             ret["result"] = None
80             return ret
81         ret = swagger.deploy_api(ret)
82         if ret.get("abort"):
83             return ret
84         ret = swagger.deploy_models(ret)
85         if ret.get("abort"):
86             return ret
87         ret = swagger.deploy_resources(
88             ret,
89             api_key_required=api_key_required,
90             lambda_integration_role=lambda_integration_role,
91             lambda_region=lambda_region,
92             authorization_type=authorization_type,
93         )
94         if ret.get("abort"):
95             return ret
96         ret = swagger.publish_api(ret, stage_vars)
97     except (ValueError, OSError) as e:
98         ret["result"] = False
99         ret["comment"] = "{}".format(e.args)
100     return ret
101 def _get_stage_variables(stage_variables):
102     ret = dict()
103     if stage_variables is None:
104         return ret
105     if isinstance(stage_variables, str):
106         if stage_variables in __opts__:
107             ret = __opts__[stage_variables]
108         master_opts = __pillar__.get("master", {})
109         if stage_variables in master_opts:
110             ret = master_opts[stage_variables]
111         if stage_variables in __pillar__:
112             ret = __pillar__[stage_variables]
113     elif isinstance(stage_variables, dict):
114         ret = stage_variables
115     if not isinstance(ret, dict):
116         ret = dict()
117     return ret
118 def absent(
119     name,
120     api_name,
121     stage_name,
122     nuke_api=False,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127 ):
128     ret = {"name": name, "result": True, "comment": "", "changes": {}}
129     try:
130         common_args = dict(
131             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
132         )
133         swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
134         if not swagger.restApiId:
135             ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
136             return ret
137         if __opts__["test"]:
138             if nuke_api:
139                 ret["comment"] = (
140                     "[stage: {}] will be deleted, if there are no other "
141                     "active stages, the [api: {} will also be "
142                     "deleted.".format(stage_name, api_name)
143                 )
144             else:
145                 ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
146             ret["result"] = None
147             return ret
148         ret = swagger.delete_stage(ret)
149         if ret.get("abort"):
150             return ret
151         if nuke_api and swagger.no_more_deployments_remain():
152             ret = swagger.delete_api(ret)
153     except (ValueError, OSError) as e:
154         ret["result"] = False
155         ret["comment"] = "{}".format(e.args)
156     return ret
157 def _gen_md5_filehash(fname, *args):
158     _hash = hashlib.md5()
159     with salt.utils.files.fopen(fname, "rb") as f:
160         for chunk in iter(lambda: f.read(4096), b""):
161             _hash.update(chunk)
162     for extra_arg in args:
163         _hash.update(str(extra_arg).encode())
164     return _hash.hexdigest()
165 def _dict_to_json_pretty(d, sort_keys=True):
166     return salt.utils.json.dumps(
167         d, indent=4, separators=(",", ": "), sort_keys=sort_keys
168     )
169 def _name_matches(name, matches):
170     for m in matches:
171         if name.endswith(m):
172             return True
173         if name.lower().endswith("_" + m.lower()):
174             return True
175         if name.lower() == m.lower():
176             return True
177     return False
178 def _object_reducer(
179     o,
180     names=(
181         "id",
182         "name",
183         "path",
184         "httpMethod",
185         "statusCode",
186         "Created",
187         "Deleted",
188         "Updated",
189         "Flushed",
190         "Associated",
191         "Disassociated",
192     ),
193 ):
194     result = {}
195     if isinstance(o, dict):
196         for k, v in o.items():
197             if isinstance(v, dict):
198                 reduced = v if k == "variables" else _object_reducer(v, names)
199                 if reduced or _name_matches(k, names):
200                     result[k] = reduced
201             elif isinstance(v, list):
202                 newlist = []
203                 for val in v:
204                     reduced = _object_reducer(val, names)
205                     if reduced or _name_matches(k, names):
206                         newlist.append(reduced)
207                 if newlist:
208                     result[k] = newlist
209             else:
210                 if _name_matches(k, names):
211                     result[k] = v
212     return result
213 def _log_changes(ret, changekey, changevalue):
214     cl = ret["changes"].get("new", [])
215     cl.append({changekey: _object_reducer(changevalue)})
216     ret["changes"]["new"] = cl
217     return ret
218 def _log_error_and_abort(ret, obj):
219     ret["result"] = False
220     ret["abort"] = True
221     if "error" in obj:
222         ret["comment"] = "{}".format(obj.get("error"))
223     return ret
224 class _Swagger:
225     SWAGGER_OBJ_V2_FIELDS = (
226         "swagger",
227         "info",
228         "host",
229         "basePath",
230         "schemes",
231         "consumes",
232         "produces",
233         "paths",
234         "definitions",
235         "parameters",
236         "responses",
237         "securityDefinitions",
238         "security",
239         "tags",
240         "externalDocs",
241     )
242     SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
243         "swagger",
244         "info",
245         "basePath",
246         "schemes",
247         "paths",
248         "definitions",
249     )
250     SWAGGER_OPERATION_NAMES = (
251         "get",
252         "put",
253         "post",
254         "delete",
255         "options",
256         "head",
257         "patch",
258     )
259     SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
260     VENDOR_EXT_PATTERN = re.compile("^x-")
261     JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
262     REQUEST_TEMPLATE = {
263         "application/json": (
264             "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
265             " = $input.params().header)\n#foreach( $param in $map.entrySet()"
266             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
267             ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
268             " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
269             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
270             ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
271             " $input.params().path)\n#foreach( $param in $map.entrySet()"
272             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
273             ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
274             ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
275             ' "$context.requestId",\n"resourceId":'
276             ' "$context.resourceId",\n"resourcePath":'
277             ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
278             ' "user":"$context.identity.user",\n '
279             ' "userArn":"$context.identity.userArn",\n '
280             ' "userAgent":"$context.identity.userAgent",\n '
281             ' "sourceIp":"$context.identity.sourceIp",\n '
282             ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
283             ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
284             ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
285             '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
286             '  "caller":"$context.identity.caller",\n '
287             ' "apiKey":"$context.identity.apiKey",\n '
288             ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
289             " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
290             ' $stageVariables.keySet())\n"$variable":'
291             ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
292             " #end\n#end\n}\n}"
293         )
294     }
295     REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
296     RESPONSE_TEMPLATE = {
297         "application/json": (
298             "#set($inputRoot = $input.path('$'))\n"
299             "{\n"
300             '  "errorMessage" : "$inputRoot.errorMessage",\n'
301             '  "errorType" : "$inputRoot.errorType",\n'
302             '  "stackTrace" : [\n'
303             "#foreach($stackTrace in $inputRoot.stackTrace)\n"
304             "    [\n"
305             "#foreach($elem in $stackTrace)\n"
306             '      "$elem"\n'
307             "#if($foreach.hasNext),#end\n"
308             "#end\n"
309             "    ]\n"
310             "#if($foreach.hasNext),#end\n"
311             "#end\n"
312             "  ]\n"
313             "}"
314         )
315     }
316     RESPONSE_OPTION_TEMPLATE = {}
317     AWS_API_DESCRIPTION = _dict_to_json_pretty(
318         {
319             "provisioned_by": "Salt boto_apigateway.present State",
320             "context": "See deployment or stage description",
321         }
322     )
323     class SwaggerParameter:
324         LOCATIONS = ("body", "query", "header", "path")
325         def __init__(self, paramdict):
326             self._paramdict = paramdict
327         @property
328         def location(self):
329             _location = self._paramdict.get("in")
330             if _location in _Swagger.SwaggerParameter.LOCATIONS:
331                 return _location
332             raise ValueError(
333                 "Unsupported parameter location: {} in Parameter Object".format(
334                     _location
335                 )
336             )
337         @property
338         def name(self):
339             _name = self._paramdict.get("name")
340             if _name:
341                 if self.location == "header":
342                     return "method.request.header.{}".format(_name)
343                 elif self.location == "query":
344                     return "method.request.querystring.{}".format(_name)
345                 elif self.location == "path":
346                     return "method.request.path.{}".format(_name)
347                 return None
348             raise ValueError(
349                 "Parameter must have a name: {}".format(
350                     _dict_to_json_pretty(self._paramdict)
351                 )
352             )
353         @property
354         def schema(self):
355             if self.location == "body":
356                 _schema = self._paramdict.get("schema")
357                 if _schema:
358                     if "$ref" in _schema:
359                         schema_name = _schema.get("$ref").split("/")[-1]
360                         return schema_name
361                     raise ValueError(
362                         "Body parameter must have a JSON reference "
363                         "to the schema definition due to Amazon API restrictions: {}".format(
364                             self.name
365                         )
366                     )
367                 raise ValueError(
368                     "Body parameter must have a schema: {}".format(self.name)
369                 )
370             return None
371     class SwaggerMethodResponse:
372         def __init__(self, r):
373             self._r = r
374         @property
375         def schema(self):
376             _schema = self._r.get("schema")
377             if _schema:
378                 if "$ref" in _schema:
379                     return _schema.get("$ref").split("/")[-1]
380                 raise ValueError(
381                     "Method response must have a JSON reference "
382                     "to the schema definition: {}".format(_schema)
383                 )
384             return None
385         @property
386         def headers(self):
387             _headers = self._r.get("headers", {})
388             return _headers
389     def __init__(
390         self,
391         api_name,
392         stage_name,
393         lambda_funcname_format,
394         swagger_file_path,
395         error_response_template,
396         response_template,
397         common_aws_args,
398     ):
399         self._api_name = api_name
400         self._stage_name = stage_name
401         self._lambda_funcname_format = lambda_funcname_format
402         self._common_aws_args = common_aws_args
403         self._restApiId = ""
404         self._deploymentId = ""
405         self._error_response_template = error_response_template
406         self._response_template = response_template
407         if swagger_file_path is not None:
408             if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
409                 self._swagger_file = swagger_file_path
410                 self._md5_filehash = _gen_md5_filehash(
411                     self._swagger_file, error_response_template, response_template
412                 )
413                 with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
414                     self._cfg = salt.utils.yaml.safe_load(sf)
415                 self._swagger_version = ""
416             else:
417                 raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
418             self._validate_swagger_file()
419         self._validate_lambda_funcname_format()
420         self._resolve_api_id()
421     def _is_http_error_rescode(self, code):
422         return bool(re.match(r"^\s*[45]\d\d\s*$", code))
423     def _validate_error_response_model(self, paths, mods):
424         for path, ops in paths:
425             for opname, opobj in ops.items():
426                 if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
427                     continue
428                 if "responses" not in opobj:
429                     raise ValueError(
430                         "missing mandatory responses field in path item object"
431                     )
432                 for rescode, resobj in opobj.get("responses").items():
433                     if not self._is_http_error_rescode(str(rescode)):
434                         continue
435                     if "schema" not in resobj:
436                         raise ValueError(
437                             "missing schema field in path {}, "
438                             "op {}, response {}".format(path, opname, rescode)
439                         )
440                     schemaobj = resobj.get("schema")
441                     if "$ref" not in schemaobj:
442                         raise ValueError(
443                             "missing $ref field under schema in "
444                             "path {}, op {}, response {}".format(path, opname, rescode)
445                         )
446                     schemaobjref = schemaobj.get("$ref", "/")
447                     modelname = schemaobjref.split("/")[-1]
448                     if modelname not in mods:
449                         raise ValueError(
450                             "model schema {} reference not found "
451                             "under /definitions".format(schemaobjref)
452                         )
453                     model = mods.get(modelname)
454                     if model.get("type") != "object":
455                         raise ValueError(
456                             "model schema {} must be type object".format(modelname)
457                         )
458                     if "properties" not in model:
459                         raise ValueError(
460                             "model schema {} must have properties fields".format(
461                                 modelname
462                             )
463                         )
464                     modelprops = model.get("properties")
465                     if "errorMessage" not in modelprops:
466                         raise ValueError(
467                             "model schema {} must have errorMessage as a property to "
468                             "match AWS convention. If pattern is not set, .+ will "
469                             "be used".format(modelname)
470                         )
471     def _validate_lambda_funcname_format(self):
472         try:
473             if self._lambda_funcname_format:
474                 known_kwargs = dict(stage="", api="", resource="", method="")
475                 self._lambda_funcname_format.format(**known_kwargs)
476             return True
477         except Exception:  # pylint: disable=broad-except
478             raise ValueError(
479                 "Invalid lambda_funcname_format {}.  Please review "
480                 "documentation for known substitutable keys".format(
481                     self._lambda_funcname_format
482                 )
483             )
484     def _validate_swagger_file(self):
485         for field in self._cfg:
486             if (
487                 field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
488                 and not _Swagger.VENDOR_EXT_PATTERN.match(field)
489             ):
490                 raise ValueError("Invalid Swagger Object Field: {}".format(field))
491         for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
492             if field not in self._cfg:
493                 raise ValueError("Missing Swagger Object Field: {}".format(field))
494         self._swagger_version = self._cfg.get("swagger")
495         if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
496             raise ValueError(
497                 "Unsupported Swagger version: {},Supported versions are {}".format(
498                     self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
499                 )
500             )
501         log.info(type(self._models))
502         self._validate_error_response_model(self.paths, self._models())
503     @property
504     def md5_filehash(self):
505         return self._md5_filehash
506     @property
507     def info(self):
508         info = self._cfg.get("info")
509         if not info:
510             raise ValueError("Info Object has no values")
511         return info
512     @property
513     def info_json(self):
514         return _dict_to_json_pretty(self.info)
515     @property
516     def rest_api_name(self):
517         return self._api_name
518     @property
519     def rest_api_version(self):
520         version = self.info.get("version")
521         if not version:
522             raise ValueError("Missing version value in Info Object")
523         return version
524     def _models(self):
525         models = self._cfg.get("definitions")
526         if not models:
527             raise ValueError(
528                 "Definitions Object has no values, You need to define them in your"
529                 " swagger file"
530             )
531         return models
532     def models(self):
533         model_dict = self._build_all_dependencies()
534         while True:
535             model = self._get_model_without_dependencies(model_dict)
536             if not model:
537                 break
538             yield (model, self._models().get(model))
539     @property
540     def paths(self):
541         paths = self._cfg.get("paths")
542         if not paths:
543             raise ValueError(
544                 "Paths Object has no values, You need to define them in your swagger"
545                 " file"
546             )
547         for path in paths:
548             if not path.startswith("/"):
549                 raise ValueError(
550                     "Path object {} should start with /. Please fix it".format(path)
551                 )
552         return paths.items()
553     @property
554     def basePath(self):
555         basePath = self._cfg.get("basePath", "")
556         return basePath
557     @property
558     def restApiId(self):
559         return self._restApiId
560     @restApiId.setter
561     def restApiId(self, restApiId):
562         self._restApiId = restApiId
563     @property
564     def deployment_label_json(self):
565         return _dict_to_json_pretty(self.deployment_label)
566     @property
567     def deployment_label(self):
568         label = dict()
569         label["swagger_info_object"] = self.info
570         label["api_name"] = self.rest_api_name
571         label["swagger_file"] = os.path.basename(self._swagger_file)
572         label["swagger_file_md5sum"] = self.md5_filehash
573         return label
574     def _one_or_more_stages_remain(self, deploymentId):
575         stages = __salt__["boto_apigateway.describe_api_stages"](
576             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
577         ).get("stages")
578         return bool(stages)
579     def no_more_deployments_remain(self):
580         no_more_deployments = True
581         deployments = __salt__["boto_apigateway.describe_api_deployments"](
582             restApiId=self.restApiId, **self._common_aws_args
583         ).get("deployments")
584         if deployments:
585             for deployment in deployments:
586                 deploymentId = deployment.get("id")
587                 stages = __salt__["boto_apigateway.describe_api_stages"](
588                     restApiId=self.restApiId,
589                     deploymentId=deploymentId,
590                     **self._common_aws_args
591                 ).get("stages")
592                 if stages:
593                     no_more_deployments = False
594                     break
595         return no_more_deployments
596     def _get_current_deployment_id(self):
597         deploymentId = ""
598         stage = __salt__["boto_apigateway.describe_api_stage"](
599             restApiId=self.restApiId,
600             stageName=self._stage_name,
601             **self._common_aws_args
602         ).get("stage")
603         if stage:
604             deploymentId = stage.get("deploymentId")
605         return deploymentId
606     def _get_current_deployment_label(self):
607         deploymentId = self._get_current_deployment_id()
608         deployment = __salt__["boto_apigateway.describe_api_deployment"](
609             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
610         ).get("deployment")
611         if deployment:
612             return deployment.get("description")
613         return None
614     def _get_desired_deployment_id(self):
615         deployments = __salt__["boto_apigateway.describe_api_deployments"](
616             restApiId=self.restApiId, **self._common_aws_args
617         ).get("deployments")
618         if deployments:
619             for deployment in deployments:
620                 if deployment.get("description") == self.deployment_label_json:
621                     return deployment.get("id")
622         return ""
623     def overwrite_stage_variables(self, ret, stage_variables):
624         res = __salt__["boto_apigateway.overwrite_api_stage_variables"](
625             restApiId=self.restApiId,
626             stageName=self._stage_name,
627             variables=stage_variables,
628             **self._common_aws_args
629         )
630         if not res.get("overwrite"):
631             ret["result"] = False
632             ret["abort"] = True
633             ret["comment"] = res.get("error")
634         else:
635             ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
636         return ret
637     def _set_current_deployment(self, stage_desc_json, stage_variables):
638         stage = __salt__["boto_apigateway.describe_api_stage"](
639             restApiId=self.restApiId,
640             stageName=self._stage_name,
641             **self._common_aws_args
642         ).get("stage")
643         if not stage:
644             stage = __salt__["boto_apigateway.create_api_stage"](
645                 restApiId=self.restApiId,
646                 stageName=self._stage_name,
647                 deploymentId=self._deploymentId,
648                 description=stage_desc_json,
649                 variables=stage_variables,
650                 **self._common_aws_args
651             )
652             if not stage.get("stage"):
653                 return {"set": False, "error": stage.get("error")}
654         else:
655             overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
656                 restApiId=self.restApiId,
657                 stageName=self._stage_name,
658                 variables=stage_variables,
659                 **self._common_aws_args
660             )
661             if not overwrite.get("stage"):
662                 return {"set": False, "error": overwrite.get("error")}
663         return __salt__["boto_apigateway.activate_api_deployment"](
664             restApiId=self.restApiId,
665             stageName=self._stage_name,
666             deploymentId=self._deploymentId,
667             **self._common_aws_args
668         )
669     def _resolve_api_id(self):
670         apis = __salt__["boto_apigateway.describe_apis"](
671             name=self.rest_api_name,
672             description=_Swagger.AWS_API_DESCRIPTION,
673             **self._common_aws_args
674         ).get("restapi")
675         if apis:
676             if len(apis) == 1:
677                 self.restApiId = apis[0].get("id")
678             else:
679                 raise ValueError(
680                     "Multiple APIs matching given name {} and description {}".format(
681                         self.rest_api_name, self.info_json
682                     )
683                 )
684     def delete_stage(self, ret):
685         deploymentId = self._get_current_deployment_id()
686         if deploymentId:
687             result = __salt__["boto_apigateway.delete_api_stage"](
688                 restApiId=self.restApiId,
689                 stageName=self._stage_name,
690                 **self._common_aws_args
691             )
692             if not result.get("deleted"):
693                 ret["abort"] = True
694                 ret["result"] = False
695                 ret["comment"] = "delete_stage delete_api_stage, {}".format(
696                     result.get("error")
697                 )
698             else:
699                 if not self._one_or_more_stages_remain(deploymentId):
700                     result = __salt__["boto_apigateway.delete_api_deployment"](
701                         restApiId=self.restApiId,
702                         deploymentId=deploymentId,
703                         **self._common_aws_args
704                     )
705                     if not result.get("deleted"):
706                         ret["abort"] = True
707                         ret["result"] = False
708                         ret[
709                             "comment"
710                         ] = "delete_stage delete_api_deployment, {}".format(
711                             result.get("error")
712                         )
713                 else:
714                     ret["comment"] = "stage {} has been deleted.\n".format(
715                         self._stage_name
716                     )
717         else:
718             ret["comment"] = "stage {} does not exist".format(self._stage_name)
719         return ret
720     def verify_api(self, ret):
721         if self.restApiId:
722             deployed_label_json = self._get_current_deployment_label()
723             if deployed_label_json == self.deployment_label_json:
724                 ret["comment"] = (
725                     "Already at desired state, the stage {} is already at the desired "
726                     "deployment label:\n{}".format(
727                         self._stage_name, deployed_label_json
728                     )
729                 )
730                 ret["current"] = True
731                 return ret
732             else:
733                 self._deploymentId = self._get_desired_deployment_id()
734                 if self._deploymentId:
735                     ret["publish"] = True
736         return ret
737     def publish_api(self, ret, stage_variables):
738         stage_desc = dict()
739         stage_desc["current_deployment_label"] = self.deployment_label
740         stage_desc_json = _dict_to_json_pretty(stage_desc)
741         if self._deploymentId:
742             res = self._set_current_deployment(stage_desc_json, stage_variables)
743             if not res.get("set"):
744                 ret["abort"] = True
745                 ret["result"] = False
746                 ret["comment"] = res.get("error")
747             else:
748                 ret = _log_changes(
749                     ret,
750                     "publish_api (reassociate deployment, set stage_variables)",
751                     res.get("response"),
752                 )
753         else:
754             res = __salt__["boto_apigateway.create_api_deployment"](
755                 restApiId=self.restApiId,
756                 stageName=self._stage_name,
757                 stageDescription=stage_desc_json,
758                 description=self.deployment_label_json,
759                 variables=stage_variables,
760                 **self._common_aws_args
761             )
762             if not res.get("created"):
763                 ret["abort"] = True
764                 ret["result"] = False
765                 ret["comment"] = res.get("error")
766             else:
767                 ret = _log_changes(
768                     ret, "publish_api (new deployment)", res.get("deployment")
769                 )
770         return ret
771     def _cleanup_api(self):
772         resources = __salt__["boto_apigateway.describe_api_resources"](
773             restApiId=self.restApiId, **self._common_aws_args
774         )
775         if resources.get("resources"):
776             res = resources.get("resources")[1:]
777             res.reverse()
778             for resource in res:
779                 delres = __salt__["boto_apigateway.delete_api_resources"](
780                     restApiId=self.restApiId,
781                     path=resource.get("path"),
782                     **self._common_aws_args
783                 )
784                 if not delres.get("deleted"):
785                     return delres
786         models = __salt__["boto_apigateway.describe_api_models"](
787             restApiId=self.restApiId, **self._common_aws_args
788         )
789         if models.get("models"):
790             for model in models.get("models"):
791                 delres = __salt__["boto_apigateway.delete_api_model"](
792                     restApiId=self.restApiId,
793                     modelName=model.get("name"),
794                     **self._common_aws_args
795                 )
796                 if not delres.get("deleted"):
797                     return delres
798         return {"deleted": True}
799     def deploy_api(self, ret):
800         if self.restApiId:
801             res = self._cleanup_api()
802             if not res.get("deleted"):
803                 ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
804                 ret["abort"] = True
805                 ret["result"] = False
806                 return ret
807             return ret
808         response = __salt__["boto_apigateway.create_api"](
809             name=self.rest_api_name,
810             description=_Swagger.AWS_API_DESCRIPTION,
811             **self._common_aws_args
812         )
813         if not response.get("created"):
814             ret["result"] = False
815             ret["abort"] = True
816             if "error" in response:
817                 ret["comment"] = "Failed to create rest api: {}.".format(
818                     response["error"]["message"]
819                 )
820             return ret
821         self.restApiId = response.get("restapi", {}).get("id")
822         return _log_changes(ret, "deploy_api", response.get("restapi"))
823     def delete_api(self, ret):
824         exists_response = __salt__["boto_apigateway.api_exists"](
825             name=self.rest_api_name,
826             description=_Swagger.AWS_API_DESCRIPTION,
827             **self._common_aws_args
828         )
829         if exists_response.get("exists"):
830             if __opts__["test"]:
831                 ret["comment"] = "Rest API named {} is set to be deleted.".format(
832                     self.rest_api_name
833                 )
834                 ret["result"] = None
835                 ret["abort"] = True
836                 return ret
837             delete_api_response = __salt__["boto_apigateway.delete_api"](
838                 name=self.rest_api_name,
839                 description=_Swagger.AWS_API_DESCRIPTION,
840                 **self._common_aws_args
841             )
842             if not delete_api_response.get("deleted"):
843                 ret["result"] = False
844                 ret["abort"] = True
845                 if "error" in delete_api_response:
846                     ret["comment"] = "Failed to delete rest api: {}.".format(
847                         delete_api_response["error"]["message"]
848                     )
849                 return ret
850             ret = _log_changes(ret, "delete_api", delete_api_response)
851         else:
852             ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
853                 self.rest_api_name, self.info_json
854             )
855         return ret
856     def _aws_model_ref_from_swagger_ref(self, r):
857         model_name = r.split("/")[-1]
858         return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
859             self.restApiId, model_name
860         )
861     def _update_schema_to_aws_notation(self, schema):
862         result = {}
863         for k, v in schema.items():
864             if k == "$ref":
865                 v = self._aws_model_ref_from_swagger_ref(v)
866             if isinstance(v, dict):
867                 v = self._update_schema_to_aws_notation(v)
868             result[k] = v
869         return result
870     def _build_dependent_model_list(self, obj_schema):
871         dep_models_list = []
872         if obj_schema:
873             obj_schema["type"] = obj_schema.get("type", "object")
874         if obj_schema["type"] == "array":
875             dep_models_list.extend(
876                 self._build_dependent_model_list(obj_schema.get("items", {}))
877             )
878         else:
879             ref = obj_schema.get("$ref")
880             if ref:
881                 ref_obj_model = ref.split("/")[-1]
882                 ref_obj_schema = self._models().get(ref_obj_model)
883                 dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
884                 dep_models_list.extend([ref_obj_model])
885             else:
886                 properties = obj_schema.get("properties")
887                 if properties:
888                     for _, prop_obj_schema in properties.items():
889                         dep_models_list.extend(
890                             self._build_dependent_model_list(prop_obj_schema)
891                         )
892         return list(set(dep_models_list))
893     def _build_all_dependencies(self):
894         ret = {}
895         for model, schema in self._models().items():
896             dep_list = self._build_dependent_model_list(schema)
897             ret[model] = dep_list
898         return ret
899     def _get_model_without_dependencies(self, models_dict):
900         next_model = None
901         if not models_dict:
902             return next_model
903         for model, dependencies in models_dict.items():
904             if dependencies == []:
905                 next_model = model
906                 break
907         if next_model is None:
908             raise ValueError(
909                 "incomplete model definitions, models in dependency "
910                 "list not defined: {}".format(models_dict)
911             )
912         models_dict.pop(next_model)
913         for model, dep_list in models_dict.items():
914             if next_model in dep_list:
915                 dep_list.remove(next_model)
916         return next_model
917     def deploy_models(self, ret):
918         for model, schema in self.models():
919             _schema = self._update_schema_to_aws_notation(schema)
920             _schema.update(
921                 {
922                     "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
923                     "title": "{} Schema".format(model),
924                 }
925             )
926             model_exists_response = __salt__["boto_apigateway.api_model_exists"](
927                 restApiId=self.restApiId, modelName=model, **self._common_aws_args
928             )
929             if model_exists_response.get("exists"):
930                 update_model_schema_response = __salt__[
931                     "boto_apigateway.update_api_model_schema"
932                 ](
933                     restApiId=self.restApiId,
934                     modelName=model,
935                     schema=_dict_to_json_pretty(_schema),
936                     **self._common_aws_args
937                 )
938                 if not update_model_schema_response.get("updated"):
939                     ret["result"] = False
940                     ret["abort"] = True
941                     if "error" in update_model_schema_response:
942                         ret[
943                             "comment"
944                         ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
945                             model,
946                             _dict_to_json_pretty(schema),
947                             update_model_schema_response["error"]["message"],
948                         )
949                     return ret
950                 ret = _log_changes(ret, "deploy_models", update_model_schema_response)
951             else:
952                 create_model_response = __salt__["boto_apigateway.create_api_model"](
953                     restApiId=self.restApiId,
954                     modelName=model,
955                     modelDescription=model,
956                     schema=_dict_to_json_pretty(_schema),
957                     contentType="application/json",
958                     **self._common_aws_args
959                 )
960                 if not create_model_response.get("created"):
961                     ret["result"] = False
962                     ret["abort"] = True
963                     if "error" in create_model_response:
964                         ret[
965                             "comment"
966                         ] = "Failed to create model {}, schema {}, error: {}".format(
967                             model,
968                             _dict_to_json_pretty(schema),
969                             create_model_response["error"]["message"],
970                         )
971                     return ret
972                 ret = _log_changes(ret, "deploy_models", create_model_response)
973         return ret
974     def _lambda_name(self, resourcePath, httpMethod):
975         lambda_name = self._lambda_funcname_format.format(
976             stage=self._stage_name,
977             api=self.rest_api_name,
978             resource=resourcePath,
979             method=httpMethod,
980         )
981         lambda_name = lambda_name.strip()
982         lambda_name = re.sub(r"{|}", "", lambda_name)
983         lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
984         return re.sub(r"_+", "_", lambda_name)
985     def _lambda_uri(self, lambda_name, lambda_region):
986         profile = self._common_aws_args.get("profile")
987         region = self._common_aws_args.get("region")
988         lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
989         apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
990         lambda_desc = __salt__["boto_lambda.describe_function"](
991             lambda_name, **self._common_aws_args
992         )
993         if lambda_region != apigw_region:
994             if not lambda_desc.get("function"):
995                 lambda_desc = __salt__["boto_lambda.describe_function"](
996                     lambda_name, **self._common_aws_args
997                 )
998         if not lambda_desc.get("function"):
999             raise ValueError(
1000                 "Could not find lambda function {} in regions [{}, {}].".format(
1001                     lambda_name, lambda_region, apigw_region
1002 <a name="0"></a>                )
1003             )
1004         lambda_arn = lambda_desc<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("function").get("FunctionArn")
1005         lambda_uri = (
1006             "arn:aws:apigateway:{}:lambda:path/2015-03-31"
1007             "/functions/{}/invocations".format(apigw_region, lambda_arn)
1008         )
1009         return lambda_uri
1010     def _parse_method_data(self, method_name, method_data):
1011         method_params = {}
1012         method_models =</b></font> {}
1013         if "parameters" in method_data:
1014             for param in method_data["parameters"]:
1015                 p = _Swagger.SwaggerParameter(param)
1016                 if p.name:
1017                     method_params[p.name] = True
1018                 if p.schema:
1019                     method_models["application/json"] = p.schema
1020         request_templates = (
1021             _Swagger.REQUEST_OPTION_TEMPLATE
1022             if method_name == "options"
1023             else _Swagger.REQUEST_TEMPLATE
1024         )
1025         integration_type = "MOCK" if method_name == "options" else "AWS"
1026         return {
1027             "params": method_params,
1028             "models": method_models,
1029             "request_templates": request_templates,
1030             "integration_type": integration_type,
1031         }
1032     def _find_patterns(self, o):
1033         result = []
1034         if isinstance(o, dict):
1035             for k, v in o.items():
1036                 if isinstance(v, dict):
1037                     result.extend(self._find_patterns(v))
1038                 else:
1039                     if k == "pattern":
1040                         result.append(v)
1041         return result
1042     def _get_pattern_for_schema(self, schema_name, httpStatus):
1043         defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
1044         model = self._models().get(schema_name)
1045         patterns = self._find_patterns(model)
1046         return patterns[0] if patterns else defaultPattern
1047     def _get_response_template(self, method_name, http_status):
1048         if method_name == "options" or not self._is_http_error_rescode(http_status):
1049             response_templates = (
1050                 {"application/json": self._response_template}
1051                 if self._response_template
1052                 else self.RESPONSE_OPTION_TEMPLATE
1053             )
1054         else:
1055             response_templates = (
1056                 {"application/json": self._error_response_template}
1057                 if self._error_response_template
1058                 else self.RESPONSE_TEMPLATE
1059             )
1060         return response_templates
1061     def _parse_method_response(self, method_name, method_response, httpStatus):
1062         method_response_models = {}
1063         method_response_pattern = ".*"
1064         if method_response.schema:
1065             method_response_models["application/json"] = method_response.schema
1066             method_response_pattern = self._get_pattern_for_schema(
1067                 method_response.schema, httpStatus
1068             )
1069         method_response_params = {}
1070         method_integration_response_params = {}
1071         for header in method_response.headers:
1072             response_header = "method.response.header.{}".format(header)
1073             method_response_params[response_header] = False
1074             header_data = method_response.headers.get(header)
1075             method_integration_response_params[response_header] = (
1076                 "'{}'".format(header_data.get("default"))
1077                 if "default" in header_data
1078                 else "'*'"
1079             )
1080         response_templates = self._get_response_template(method_name, httpStatus)
1081         return {
1082             "params": method_response_params,
1083             "models": method_response_models,
1084             "integration_params": method_integration_response_params,
1085             "pattern": method_response_pattern,
1086             "response_templates": response_templates,
1087         }
1088     def _deploy_method(
1089         self,
1090         ret,
1091         resource_path,
1092         method_name,
1093         method_data,
1094         api_key_required,
1095         lambda_integration_role,
1096         lambda_region,
1097         authorization_type,
1098     ):
1099         method = self._parse_method_data(method_name.lower(), method_data)
1100         if method_name.lower() == "options":
1101             api_key_required = False
1102             authorization_type = "NONE"
1103         m = __salt__["boto_apigateway.create_api_method"](
1104             restApiId=self.restApiId,
1105             resourcePath=resource_path,
1106             httpMethod=method_name.upper(),
1107             authorizationType=authorization_type,
1108             apiKeyRequired=api_key_required,
1109             requestParameters=method.get("params"),
1110             requestModels=method.get("models"),
1111             **self._common_aws_args
1112         )
1113         if not m.get("created"):
1114             ret = _log_error_and_abort(ret, m)
1115             return ret
1116         ret = _log_changes(ret, "_deploy_method.create_api_method", m)
1117         lambda_uri = ""
1118         if method_name.lower() != "options":
1119             lambda_uri = self._lambda_uri(
1120                 self._lambda_name(resource_path, method_name),
1121                 lambda_region=lambda_region,
1122             )
1123         integration = __salt__["boto_apigateway.create_api_integration"](
1124             restApiId=self.restApiId,
1125             resourcePath=resource_path,
1126             httpMethod=method_name.upper(),
1127             integrationType=method.get("integration_type"),
1128             integrationHttpMethod="POST",
1129             uri=lambda_uri,
1130             credentials=lambda_integration_role,
1131             requestTemplates=method.get("request_templates"),
1132             **self._common_aws_args
1133         )
1134         if not integration.get("created"):
1135             ret = _log_error_and_abort(ret, integration)
1136             return ret
1137         ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
1138         if "responses" in method_data:
1139             for response, response_data in method_data["responses"].items():
1140                 httpStatus = str(response)
1141                 method_response = self._parse_method_response(
1142                     method_name.lower(),
1143                     _Swagger.SwaggerMethodResponse(response_data),
1144                     httpStatus,
1145                 )
1146                 mr = __salt__["boto_apigateway.create_api_method_response"](
1147                     restApiId=self.restApiId,
1148                     resourcePath=resource_path,
1149                     httpMethod=method_name.upper(),
1150                     statusCode=httpStatus,
1151                     responseParameters=method_response.get("params"),
1152                     responseModels=method_response.get("models"),
1153                     **self._common_aws_args
1154                 )
1155                 if not mr.get("created"):
1156                     ret = _log_error_and_abort(ret, mr)
1157                     return ret
1158                 ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
1159                 mir = __salt__["boto_apigateway.create_api_integration_response"](
1160                     restApiId=self.restApiId,
1161                     resourcePath=resource_path,
1162                     httpMethod=method_name.upper(),
1163                     statusCode=httpStatus,
1164                     selectionPattern=method_response.get("pattern"),
1165                     responseParameters=method_response.get("integration_params"),
1166                     responseTemplates=method_response.get("response_templates"),
1167                     **self._common_aws_args
1168                 )
1169                 if not mir.get("created"):
1170                     ret = _log_error_and_abort(ret, mir)
1171                     return ret
1172                 ret = _log_changes(
1173                     ret, "_deploy_method.create_api_integration_response", mir
1174                 )
1175         else:
1176             raise ValueError(
1177                 "No responses specified for {} {}".format(resource_path, method_name)
1178             )
1179         return ret
1180     def deploy_resources(
1181         self,
1182         ret,
1183         api_key_required,
1184         lambda_integration_role,
1185         lambda_region,
1186         authorization_type,
1187     ):
1188         for path, pathData in self.paths:
1189             resource = __salt__["boto_apigateway.create_api_resources"](
1190                 restApiId=self.restApiId, path=path, **self._common_aws_args
1191             )
1192             if not resource.get("created"):
1193                 ret = _log_error_and_abort(ret, resource)
1194                 return ret
1195             ret = _log_changes(ret, "deploy_resources", resource)
1196             for method, method_data in pathData.items():
1197                 if method in _Swagger.SWAGGER_OPERATION_NAMES:
1198                     ret = self._deploy_method(
1199                         ret,
1200                         path,
1201                         method,
1202                         method_data,
1203                         api_key_required,
1204                         lambda_integration_role,
1205                         lambda_region,
1206                         authorization_type,
1207                     )
1208         return ret
1209 def usage_plan_present(
1210     name,
1211     plan_name,
1212     description=None,
1213     throttle=None,
1214     quota=None,
1215     region=None,
1216     key=None,
1217     keyid=None,
1218     profile=None,
1219 ):
1220     func_params = locals()
1221     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1222     try:
1223         common_args = dict(
1224             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1225         )
1226         existing = __salt__["boto_apigateway.describe_usage_plans"](
1227             name=plan_name, **common_args
1228         )
1229         if "error" in existing:
1230             ret["result"] = False
1231             ret["comment"] = "Failed to describe existing usage plans"
1232             return ret
1233         if not existing["plans"]:
1234             if __opts__["test"]:
1235                 ret["comment"] = "a new usage plan {} would be created".format(
1236                     plan_name
1237                 )
1238                 ret["result"] = None
1239                 return ret
1240             result = __salt__["boto_apigateway.create_usage_plan"](
1241                 name=plan_name,
1242                 description=description,
1243                 throttle=throttle,
1244                 quota=quota,
1245                 **common_args
1246             )
1247             if "error" in result:
1248                 ret["result"] = False
1249                 ret["comment"] = "Failed to create a usage plan {}, {}".format(
1250                     plan_name, result["error"]
1251                 )
1252                 return ret
1253             ret["changes"]["old"] = {"plan": None}
1254             ret["comment"] = "A new usage plan {} has been created".format(plan_name)
1255         else:
1256             plan = existing["plans"][0]
1257             needs_updating = False
1258             modifiable_params = (
1259                 ("throttle", ("rateLimit", "burstLimit")),
1260                 ("quota", ("limit", "offset", "period")),
1261             )
1262             for p, fields in modifiable_params:
1263                 for f in fields:
1264                     actual_param = (
1265                         {} if func_params.get(p) is None else func_params.get(p)
1266                     )
1267                     if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
1268                         needs_updating = True
1269                         break
1270             if not needs_updating:
1271                 ret["comment"] = "usage plan {} is already in a correct state".format(
1272                     plan_name
1273                 )
1274                 ret["result"] = True
1275                 return ret
1276             if __opts__["test"]:
1277                 ret["comment"] = "a new usage plan {} would be updated".format(
1278                     plan_name
1279                 )
1280                 ret["result"] = None
1281                 return ret
1282             result = __salt__["boto_apigateway.update_usage_plan"](
1283                 plan["id"], throttle=throttle, quota=quota, **common_args
1284             )
1285             if "error" in result:
1286                 ret["result"] = False
1287                 ret["comment"] = "Failed to update a usage plan {}, {}".format(
1288                     plan_name, result["error"]
1289                 )
1290                 return ret
1291             ret["changes"]["old"] = {"plan": plan}
1292             ret["comment"] = "usage plan {} has been updated".format(plan_name)
1293         newstate = __salt__["boto_apigateway.describe_usage_plans"](
1294             name=plan_name, **common_args
1295         )
1296         if "error" in existing:
1297             ret["result"] = False
1298             ret["comment"] = "Failed to describe existing usage plans after updates"
1299             return ret
1300         ret["changes"]["new"] = {"plan": newstate["plans"][0]}
1301     except (ValueError, OSError) as e:
1302         ret["result"] = False
1303         ret["comment"] = "{}".format(e.args)
1304     return ret
1305 def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
1306     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1307     try:
1308         common_args = dict(
1309             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1310         )
1311         existing = __salt__["boto_apigateway.describe_usage_plans"](
1312             name=plan_name, **common_args
1313         )
1314         if "error" in existing:
1315             ret["result"] = False
1316             ret["comment"] = "Failed to describe existing usage plans"
1317             return ret
1318         if not existing["plans"]:
1319             ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
1320             return ret
1321         if __opts__["test"]:
1322             ret["comment"] = "Usage plan {} exists and would be deleted".format(
1323                 plan_name
1324             )
1325             ret["result"] = None
1326             return ret
1327         plan_id = existing["plans"][0]["id"]
1328         result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
1329         if "error" in result:
1330             ret["result"] = False
1331             ret["comment"] = "Failed to delete usage plan {}, {}".format(
1332                 plan_name, result
1333             )
1334             return ret
1335         ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
1336         ret["changes"]["old"] = {"plan": existing["plans"][0]}
1337         ret["changes"]["new"] = {"plan": None}
1338     except (ValueError, OSError) as e:
1339         ret["result"] = False
1340         ret["comment"] = "{}".format(e.args)
1341     return ret
1342 def usage_plan_association_present(
1343     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1344 ):
1345     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1346     try:
1347         common_args = dict(
1348             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1349         )
1350         existing = __salt__["boto_apigateway.describe_usage_plans"](
1351             name=plan_name, **common_args
1352         )
1353         if "error" in existing:
1354             ret["result"] = False
1355             ret["comment"] = "Failed to describe existing usage plans"
1356             return ret
1357         if not existing["plans"]:
1358             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1359             ret["result"] = False
1360             return ret
1361         if len(existing["plans"]) != 1:
1362             ret["comment"] = (
1363                 "There are multiple usage plans with the same name - it is not"
1364                 " supported"
1365             )
1366             ret["result"] = False
1367             return ret
1368         plan = existing["plans"][0]
1369         plan_id = plan["id"]
1370         plan_stages = plan.get("apiStages", [])
1371         stages_to_add = []
1372         for api in api_stages:
1373             if api not in plan_stages:
1374                 stages_to_add.append(api)
1375         if not stages_to_add:
1376             ret["comment"] = "Usage plan is already asssociated to all api stages"
1377             return ret
1378         result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
1379             plan_id, stages_to_add, **common_args
1380         )
1381         if "error" in result:
1382             ret[
1383                 "comment"
1384             ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
1385                 plan_name, stages_to_add, result["error"]
1386             )
1387             ret["result"] = False
1388             return ret
1389         ret["comment"] = "successfully associated usage plan to apis"
1390         ret["changes"]["old"] = plan_stages
1391         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1392     except (ValueError, OSError) as e:
1393         ret["result"] = False
1394         ret["comment"] = "{}".format(e.args)
1395     return ret
1396 def usage_plan_association_absent(
1397     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1398 ):
1399     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1400     try:
1401         common_args = dict(
1402             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1403         )
1404         existing = __salt__["boto_apigateway.describe_usage_plans"](
1405             name=plan_name, **common_args
1406         )
1407         if "error" in existing:
1408             ret["result"] = False
1409             ret["comment"] = "Failed to describe existing usage plans"
1410             return ret
1411         if not existing["plans"]:
1412             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1413             ret["result"] = False
1414             return ret
1415         if len(existing["plans"]) != 1:
1416             ret["comment"] = (
1417                 "There are multiple usage plans with the same name - it is not"
1418                 " supported"
1419             )
1420             ret["result"] = False
1421             return ret
1422         plan = existing["plans"][0]
1423         plan_id = plan["id"]
1424         plan_stages = plan.get("apiStages", [])
1425         if not plan_stages:
1426             ret["comment"] = "Usage plan {} has no associated stages already".format(
1427                 plan_name
1428             )
1429             return ret
1430         stages_to_remove = []
1431         for api in api_stages:
1432             if api in plan_stages:
1433                 stages_to_remove.append(api)
1434         if not stages_to_remove:
1435             ret["comment"] = "Usage plan is already not asssociated to any api stages"
1436             return ret
1437         result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
1438             plan_id, stages_to_remove, **common_args
1439         )
1440         if "error" in result:
1441             ret[
1442                 "comment"
1443             ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
1444                 plan_name, stages_to_remove, result["error"]
1445             )
1446             ret["result"] = False
1447             return ret
1448         ret["comment"] = "successfully disassociated usage plan from apis"
1449         ret["changes"]["old"] = plan_stages
1450         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1451     except (ValueError, OSError) as e:
1452         ret["result"] = False
1453         ret["comment"] = "{}".format(e.args)
1454     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
