<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for haproxyconn.py &amp; boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for haproxyconn.py &amp; boto_apigateway.py
      </h3>
<h1 align="center">
        0.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>haproxyconn.py (3.7790697%)<th>boto_apigateway.py (0.513834%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-58)<td><a href="#" name="0">(1660-1673)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>haproxyconn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import stat
4 import time
5 try:
6     import haproxy.cmds  # pylint: disable=no-name-in-module
7     import haproxy.conn  # pylint: disable=no-name-in-module
8     HAS_HAPROXY = True
9 except ImportError:
10     HAS_HAPROXY = False
11 log = logging.getLogger(__name__)
12 __virtualname__ = "haproxy"
13 DEFAULT_SOCKET_URL = "/var/run/haproxy.sock"
14 FIELD_NUMERIC = ["weight", "bin", "bout"]
15 FIELD_NODE_NAME = "name"
16 def __virtual__():
17     if HAS_HAPROXY:
18         return __virtualname__
19     return (
20         False,
21         "The haproxyconn execution module cannot be loaded: haproxyctl module not"
22         " available",
23     )
24 def _get_conn(socket=DEFAULT_SOCKET_URL):
25     """
26     assert stat<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.S_ISSOCK(issock), "{} is not a socket.".format(socket)
27     ha_conn = haproxy.conn.HaPConn(socket)
28     return ha_conn
29 def list_servers(backend, socket=DEFAULT_SOCKET_URL, objectify=</b></font>False):
30     """
31     List servers in haproxy backend.
32     backend
33         haproxy backend
34     socket
35         haproxy stats socket, default ``/var/run/haproxy.sock``
36     CLI Example:
37     .. code-block:: bash
38         salt '*' haproxy.list_servers mysql
39     """
40     ha_conn = _get_conn(socket)
41     ha_cmd = haproxy.cmds.listServers(backend=backend)
42     return ha_conn.sendCmd(ha_cmd, objectify=objectify)
43 def wait_state(backend, server, value="up", timeout=60 * 5, socket=DEFAULT_SOCKET_URL):
44     """
45     Wait for a specific server state
46     backend
47         haproxy backend
48     server
49         targeted server
50     value
51         state value
52     timeout
53         timeout before giving up state value, default 5 min
54     socket
55         haproxy stats socket, default ``/var/run/haproxy.sock``
56     CLI Example:
57     .. code-block:: bash
58         salt '*' haproxy.wait_state mysql server01 up 60
59     """
60     t = time.time() + timeout
61     while time.time() &lt; t:
62         if (
63             get_backend(backend=backend, socket=socket)[server]["status"].lower()
64             == value.lower()
65         ):
66             return True
67     return False
68 def get_backend(backend, socket=DEFAULT_SOCKET_URL):
69     """
70     Receive information about a specific backend.
71     backend
72         haproxy backend
73     socket
74         haproxy stats socket, default ``/var/run/haproxy.sock``
75     CLI Example:
76     .. code-block:: bash
77         salt '*' haproxy.get_backend mysql
78     """
79     backend_data = (
80         list_servers(backend=backend, socket=socket).replace("\n", " ").split(" ")
81     )
82     result = {}
83     def num(s):
84         try:
85             return int(s)
86         except ValueError:
87             return s
88     for data in backend_data:
89         if ":" in data:
90             active_field = data.replace(":", "").lower()
91             continue
92         elif active_field.lower() == FIELD_NODE_NAME:
93             active_server = data
94             result[active_server] = {}
95             continue
96         if active_field in FIELD_NUMERIC:
97             if data == "":
98                 result[active_server][active_field] = 0
99             else:
100                 result[active_server][active_field] = num(data)
101         else:
102             result[active_server][active_field] = data
103     return result
104 def enable_server(name, backend, socket=DEFAULT_SOCKET_URL):
105     """
106     Enable Server in haproxy
107     name
108         Server to enable
109     backend
110         haproxy backend, or all backends if "*" is supplied
111     socket
112         haproxy stats socket, default ``/var/run/haproxy.sock``
113     CLI Example:
114     .. code-block:: bash
115         salt '*' haproxy.enable_server web1.example.com www
116     """
117     if backend == "*":
118         backends = show_backends(socket=socket).split("\n")
119     else:
120         backends = [backend]
121     results = {}
122     for backend in backends:
123         ha_conn = _get_conn(socket)
124         ha_cmd = haproxy.cmds.enableServer(server=name, backend=backend)
125         ha_conn.sendCmd(ha_cmd)
126         results[backend] = list_servers(backend, socket=socket)
127     return results
128 def disable_server(name, backend, socket=DEFAULT_SOCKET_URL):
129     """
130     Disable server in haproxy.
131     name
132         Server to disable
133     backend
134         haproxy backend, or all backends if "*" is supplied
135     socket
136         haproxy stats socket, default ``/var/run/haproxy.sock``
137     CLI Example:
138     .. code-block:: bash
139         salt '*' haproxy.disable_server db1.example.com mysql
140     """
141     if backend == "*":
142         backends = show_backends(socket=socket).split("\n")
143     else:
144         backends = [backend]
145     results = {}
146     for backend in backends:
147         ha_conn = _get_conn(socket)
148         ha_cmd = haproxy.cmds.disableServer(server=name, backend=backend)
149         ha_conn.sendCmd(ha_cmd)
150         results[backend] = list_servers(backend, socket=socket)
151     return results
152 def get_weight(name, backend, socket=DEFAULT_SOCKET_URL):
153     """
154     Get server weight
155     name
156         Server name
157     backend
158         haproxy backend
159     socket
160         haproxy stats socket, default ``/var/run/haproxy.sock``
161     CLI Example:
162     .. code-block:: bash
163         salt '*' haproxy.get_weight web1.example.com www
164     """
165     ha_conn = _get_conn(socket)
166     ha_cmd = haproxy.cmds.getWeight(server=name, backend=backend)
167     return ha_conn.sendCmd(ha_cmd)
168 def set_weight(name, backend, weight=0, socket=DEFAULT_SOCKET_URL):
169     """
170     Set server weight
171     name
172         Server name
173     backend
174         haproxy backend
175     weight
176         Server Weight
177     socket
178         haproxy stats socket, default ``/var/run/haproxy.sock``
179     CLI Example:
180     .. code-block:: bash
181         salt '*' haproxy.set_weight web1.example.com www 13
182     """
183     ha_conn = _get_conn(socket)
184     ha_cmd = haproxy.cmds.getWeight(server=name, backend=backend, weight=weight)
185     ha_conn.sendCmd(ha_cmd)
186     return get_weight(name, backend, socket=socket)
187 def set_state(name, backend, state, socket=DEFAULT_SOCKET_URL):
188     """
189     Force a server's administrative state to a new state. This can be useful to
190     disable load balancing and/or any traffic to a server. Setting the state to
191     "ready" puts the server in normal mode, and the command is the equivalent of
192     the "enable server" command. Setting the state to "maint" disables any traffic
193     to the server as well as any health checks. This is the equivalent of the
194     "disable server" command. Setting the mode to "drain" only removes the server
195     from load balancing but still allows it to be checked and to accept new
196     persistent connections. Changes are propagated to tracking servers if any.
197     name
198         Server name
199     backend
200         haproxy backend
201     state
202         A string of the state to set. Must be 'ready', 'drain', or 'maint'
203     socket
204         haproxy stats socket, default ``/var/run/haproxy.sock``
205     CLI Example:
206     .. code-block:: bash
207         salt '*' haproxy.set_state my_proxy_server my_backend ready
208     """
209     class setServerState(haproxy.cmds.Cmd):
210         cmdTxt = "set server %(backend)s/%(server)s state %(value)s\r\n"
211         p_args = ["backend", "server", "value"]
212         helpTxt = "Force a server's administrative state to a new state."
213     ha_conn = _get_conn(socket)
214     ha_cmd = setServerState(server=name, backend=backend, value=state)
215     return ha_conn.sendCmd(ha_cmd)
216 def show_frontends(socket=DEFAULT_SOCKET_URL):
217     """
218     Show HaProxy frontends
219     socket
220         haproxy stats socket, default ``/var/run/haproxy.sock``
221     CLI Example:
222     .. code-block:: bash
223         salt '*' haproxy.show_frontends
224     """
225     ha_conn = _get_conn(socket)
226     ha_cmd = haproxy.cmds.showFrontends()
227     return ha_conn.sendCmd(ha_cmd)
228 def list_frontends(socket=DEFAULT_SOCKET_URL):
229     """
230     List HaProxy frontends
231     socket
232         haproxy stats socket, default ``/var/run/haproxy.sock``
233     CLI Example:
234     .. code-block:: bash
235         salt '*' haproxy.list_frontends
236     """
237     return show_frontends(socket=socket).split("\n")
238 def show_backends(socket=DEFAULT_SOCKET_URL):
239     """
240     Show HaProxy Backends
241     socket
242         haproxy stats socket, default ``/var/run/haproxy.sock``
243     CLI Example:
244     .. code-block:: bash
245         salt '*' haproxy.show_backends
246     """
247     ha_conn = _get_conn(socket)
248     ha_cmd = haproxy.cmds.showBackends()
249     return ha_conn.sendCmd(ha_cmd)
250 def list_backends(servers=True, socket=DEFAULT_SOCKET_URL):
251     """
252     List HaProxy Backends
253     socket
254         haproxy stats socket, default ``/var/run/haproxy.sock``
255     servers
256         list backends with servers
257     CLI Example:
258     .. code-block:: bash
259         salt '*' haproxy.list_backends
260     """
261     if not servers:
262         return show_backends(socket=socket).split("\n")
263     else:
264         result = {}
265         for backend in list_backends(servers=False, socket=socket):
266             result[backend] = get_backend(backend=backend, socket=socket)
267         return result
268 def get_sessions(name, backend, socket=DEFAULT_SOCKET_URL):
269     """
270     .. versionadded:: 2016.11.0
271     Get number of current sessions on server in backend (scur)
272     name
273         Server name
274     backend
275         haproxy backend
276     socket
277         haproxy stats socket, default ``/var/run/haproxy.sock``
278     CLI Example:
279     .. code-block:: bash
280         salt '*' haproxy.get_sessions web1.example.com www
281     """
282     class getStats(haproxy.cmds.Cmd):
283         p_args = ["backend", "server"]
284         cmdTxt = "show stat\r\n"
285         helpText = "Fetch all statistics"
286     ha_conn = _get_conn(socket)
287     ha_cmd = getStats(server=name, backend=backend)
288     result = ha_conn.sendCmd(ha_cmd)
289     for line in result.split("\n"):
290         if line.startswith(backend):
291             outCols = line.split(",")
292             if outCols[1] == name:
293                 return outCols[4]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage Apigateway Rest APIs
3 ===========================
4 .. versionadded:: 2016.11.0
5 :depends:
6   - boto &gt;= 2.8.0
7   - boto3 &gt;= 1.2.1
8   - botocore &gt;= 1.4.49
9 Create and destroy rest apis depending on a swagger version 2 definition file.
10 Be aware that this interacts with Amazon's services, and so may incur charges.
11 This module uses ``boto3``, which can be installed via package, or pip.
12 This module accepts explicit vpc credentials but can also utilize
13 IAM roles assigned to the instance through Instance Profiles. Dynamic
14 credentials are then automatically obtained from AWS API and no further
15 configuration is necessary. More information available `here
16 &lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.
17 If IAM roles are not used you need to specify them either in a pillar file or
18 in the minion's config file:
19 .. code-block:: yaml
20     vpc.keyid: GKTADJGHEIQSXMKKRBJ08H
21     vpc.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
22 It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile,
23 either passed in as a dict, or as a string to pull from pillars or minion
24 config:
25 .. code-block:: yaml
26     myprofile:
27       keyid: GKTADJGHEIQSXMKKRBJ08H
28       key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
29       region: us-east-1
30 .. code-block:: yaml
31     Ensure Apigateway API exists:
32       boto_apigateway.present:
33         - name: myfunction
34         - region: us-east-1
35         - keyid: GKTADJGHEIQSXMKKRBJ08H
36         - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
37 """
38 import hashlib
39 import logging
40 import os
41 import re
42 import salt.utils.files
43 import salt.utils.json
44 import salt.utils.yaml
45 log = logging.getLogger(__name__)
46 def __virtual__():
47     """
48     Only load if boto is available.
49     """
50     if "boto_apigateway.describe_apis" in __salt__:
51         return "boto_apigateway"
52     return (False, "boto_apigateway module could not be loaded")
53 def present(
54     name,
55     api_name,
56     swagger_file,
57     stage_name,
58     api_key_required,
59     lambda_integration_role,
60     lambda_region=None,
61     stage_variables=None,
62     region=None,
63     key=None,
64     keyid=None,
65     profile=None,
66     lambda_funcname_format="{stage}_{api}_{resource}_{method}",
67     authorization_type="NONE",
68     error_response_template=None,
69     response_template=None,
70 ):
71     """
72     Ensure the spcified api_name with the corresponding swaggerfile is deployed to the
73     given stage_name in AWS ApiGateway.
74     this state currently only supports ApiGateway integration with AWS Lambda, and CORS support is
75     handled through a Mock integration.
76     There may be multiple deployments for the API object, each deployment is tagged with a description
77     (i.e. unique label) in pretty printed json format consisting of the following key/values.
78     .. code-block:: text
79         {
80             "api_name": api_name,
81             "swagger_file": basename_of_swagger_file
82             "swagger_file_md5sum": md5sum_of_swagger_file,
83             "swagger_info_object": info_object_content_in_swagger_file
84         }
85     Please note that the name of the lambda function to be integrated will be derived
86     via the provided lambda_funcname_format parameters:
87     - the default lambda_funcname_format is a string with the following
88       substitutable keys: "{stage}_{api}_{resource}_{method}".  The user can
89       choose to reorder the known keys.
90     - the stage key corresponds to the stage_name passed in.
91     - the api key corresponds to the api_name passed in.
92     - the resource corresponds to the resource path defined in the passed swagger file.
93     - the method corresponds to the method for a resource path defined in the passed swagger file.
94     For the default lambda_funcname_format, given the following input:
95     .. code-block:: python
96         api_name = '  Test    Service'
97         stage_name = 'alpha'
98         basePath = '/api'
99         path = '/a/{b}/c'
100         method = 'POST'
101     We will end up with the following Lambda Function Name that will be looked
102     up: 'test_service_alpha_a_b_c_post'
103     The canconicalization of these input parameters is done in the following order:
104     1. lambda_funcname_format is formatted with the input parameters as passed,
105     2. resulting string is stripped for leading/trailing spaces,
106     3. path parameter's curly braces are removed from the resource path,
107     4. consecutive spaces and forward slashes in the paths are replaced with '_'
108     5. consecutive '_' are replaced with '_'
109     Please note that for error response handling, the swagger file must have an error response model
110     with the following schema.  The lambda functions should throw exceptions for any non successful responses.
111     An optional pattern field can be specified in errorMessage field to aid the response mapping from Lambda
112     to the proper error return status codes.
113     .. code-block:: yaml
114         Error:
115           type: object
116           properties:
117             stackTrace:
118               type: array
119               items:
120                 type: array
121                 items:
122                   type: string
123               description: call stack
124           errorType:
125             type: string
126             description: error type
127           errorMessage:
128             type: string
129             description: |
130               Error message, will be matched based on pattern.
131               If no pattern is specified, the default pattern used for response mapping will be +*.
132     name
133         The name of the state definition
134     api_name
135         The name of the rest api that we want to ensure exists in AWS API Gateway
136     swagger_file
137         Name of the location of the swagger rest api definition file in YAML format.
138     stage_name
139         Name of the stage we want to be associated with the given api_name and swagger_file
140         definition
141     api_key_required
142         True or False - whether the API Key is required to call API methods
143     lambda_integration_role
144         The name or ARN of the IAM role that the AWS ApiGateway assumes when it
145         executes your lambda function to handle incoming requests
146     lambda_region
147         The region where we expect to find the lambda functions.  This is used to
148         determine the region where we should look for the Lambda Function for
149         integration purposes.  The region determination is based on the following
150         priority:
151         1. lambda_region as passed in (is not None)
152         2. if lambda_region is None, use the region as if a boto_lambda
153            function were executed without explicitly specifying lambda region.
154         3. if region determined in (2) is different than the region used by
155            boto_apigateway functions, a final lookup will be attempted using
156            the boto_apigateway region.
157     stage_variables
158         A dict with variables and their values, or a pillar key (string) that
159         contains a dict with variables and their values.
160         key and values in the dict must be strings.  {'string': 'string'}
161     region
162         Region to connect to.
163     key
164         Secret key to be used.
165     keyid
166         Access key to be used.
167     profile
168         A dict with region, key and keyid, or a pillar key (string) that
169         contains a dict with region, key and keyid.
170     lambda_funcname_format
171         Please review the earlier example for the usage.  The only substituable keys in the funcname
172         format are {stage}, {api}, {resource}, {method}.
173         Any other keys or positional substitution parameters will be flagged as an invalid input.
174     authorization_type
175         This field can be either 'NONE', or 'AWS_IAM'.  This will be applied to all methods in the given
176         swagger spec file.  Default is set to 'NONE'
177     error_response_template
178         String value that defines the response template mapping that should be applied in cases error occurs.
179         Refer to AWS documentation for details: http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html
180         If set to None, the following default value is used:
181         .. code-block:: text
182             '#set($inputRoot = $input.path(\'$\'))\\n'
183             '{\\n'
184             '  "errorMessage" : "$inputRoot.errorMessage",\\n'
185             '  "errorType" : "$inputRoot.errorType",\\n'
186             '  "stackTrace" : [\\n'
187             '#foreach($stackTrace in $inputRoot.stackTrace)\\n'
188             '    [\\n'
189             '#foreach($elem in $stackTrace)\\n'
190             '      "$elem"\\n'
191             '#if($foreach.hasNext),#end\\n'
192             '#end\\n'
193             '    ]\\n'
194             '#if($foreach.hasNext),#end\\n'
195             '#end\\n'
196             '  ]\\n'
197         .. versionadded:: 2017.7.0
198     response_template
199         String value that defines the response template mapping applied in case
200         of success (including OPTIONS method) If set to None, empty ({})
201         template is assumed, which will transfer response from the lambda
202         function as is.
203         .. versionadded:: 2017.7.0
204     """
205     ret = {"name": name, "result": True, "comment": "", "changes": {}}
206     try:
207         common_args = dict(
208             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
209         )
210         swagger = _Swagger(
211             api_name,
212             stage_name,
213             lambda_funcname_format,
214             swagger_file,
215             error_response_template,
216             response_template,
217             common_args,
218         )
219         stage_vars = _get_stage_variables(stage_variables)
220         ret = swagger.verify_api(ret)
221         if ret.get("publish"):
222             if __opts__["test"]:
223                 ret["comment"] = (
224                     "[stage: {}] will be reassociated to an already available "
225                     "deployment that matched the given [api_name: {}] "
226                     "and [swagger_file: {}].\n"
227                     "Stage variables will be set "
228                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
229                 )
230                 ret["result"] = None
231                 return ret
232             return swagger.publish_api(ret, stage_vars)
233         if ret.get("current"):
234             if __opts__["test"]:
235                 ret["comment"] = (
236                     "[stage: {}] is already at desired state with an associated "
237                     "deployment matching the given [api_name: {}] "
238                     "and [swagger_file: {}].\n"
239                     "Stage variables will be set "
240                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
241                 )
242                 ret["result"] = None
243             return swagger.overwrite_stage_variables(ret, stage_vars)
244         if __opts__["test"]:
245             ret["comment"] = (
246                 "There is no deployment matching the given [api_name: {}] "
247                 "and [swagger_file: {}].  A new deployment will be "
248                 "created and the [stage_name: {}] will then be associated "
249                 "to the newly created deployment.\n"
250                 "Stage variables will be set "
251                 "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
252             )
253             ret["result"] = None
254             return ret
255         ret = swagger.deploy_api(ret)
256         if ret.get("abort"):
257             return ret
258         ret = swagger.deploy_models(ret)
259         if ret.get("abort"):
260             return ret
261         ret = swagger.deploy_resources(
262             ret,
263             api_key_required=api_key_required,
264             lambda_integration_role=lambda_integration_role,
265             lambda_region=lambda_region,
266             authorization_type=authorization_type,
267         )
268         if ret.get("abort"):
269             return ret
270         ret = swagger.publish_api(ret, stage_vars)
271     except (ValueError, OSError) as e:
272         ret["result"] = False
273         ret["comment"] = "{}".format(e.args)
274     return ret
275 def _get_stage_variables(stage_variables):
276     """
277     Helper function to retrieve stage variables from pillars/options, if the
278     input is a string
279     """
280     ret = dict()
281     if stage_variables is None:
282         return ret
283     if isinstance(stage_variables, str):
284         if stage_variables in __opts__:
285             ret = __opts__[stage_variables]
286         master_opts = __pillar__.get("master", {})
287         if stage_variables in master_opts:
288             ret = master_opts[stage_variables]
289         if stage_variables in __pillar__:
290             ret = __pillar__[stage_variables]
291     elif isinstance(stage_variables, dict):
292         ret = stage_variables
293     if not isinstance(ret, dict):
294         ret = dict()
295     return ret
296 def absent(
297     name,
298     api_name,
299     stage_name,
300     nuke_api=False,
301     region=None,
302     key=None,
303     keyid=None,
304     profile=None,
305 ):
306     """
307     Ensure the stage_name associated with the given api_name deployed by boto_apigateway's
308     present state is removed.  If the currently associated deployment to the given stage_name has
309     no other stages associated with it, the deployment will also be removed.
310     name
311         Name of the swagger file in YAML format
312     api_name
313         Name of the rest api on AWS ApiGateway to ensure is absent.
314     stage_name
315         Name of the stage to be removed irrespective of the swagger file content.
316         If the current deployment associated with the stage_name has no other stages associated
317         with it, the deployment will also be removed.
318     nuke_api
319         If True, removes the API itself only if there are no other stages associated with any other
320         deployments once the given stage_name is removed.
321     region
322         Region to connect to.
323     key
324         Secret key to be used.
325     keyid
326         Access key to be used.
327     profile
328         A dict with region, key and keyid, or a pillar key (string) that
329         contains a dict with region, key and keyid.
330     """
331     ret = {"name": name, "result": True, "comment": "", "changes": {}}
332     try:
333         common_args = dict(
334             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
335         )
336         swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
337         if not swagger.restApiId:
338             ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
339             return ret
340         if __opts__["test"]:
341             if nuke_api:
342                 ret["comment"] = (
343                     "[stage: {}] will be deleted, if there are no other "
344                     "active stages, the [api: {} will also be "
345                     "deleted.".format(stage_name, api_name)
346                 )
347             else:
348                 ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
349             ret["result"] = None
350             return ret
351         ret = swagger.delete_stage(ret)
352         if ret.get("abort"):
353             return ret
354         if nuke_api and swagger.no_more_deployments_remain():
355             ret = swagger.delete_api(ret)
356     except (ValueError, OSError) as e:
357         ret["result"] = False
358         ret["comment"] = "{}".format(e.args)
359     return ret
360 def _gen_md5_filehash(fname, *args):
361     """
362     helper function to generate a md5 hash of the swagger definition file
363     any extra argument passed to the function is converted to a string
364     and participates in the hash calculation
365     """
366     _hash = hashlib.md5()
367     with salt.utils.files.fopen(fname, "rb") as f:
368         for chunk in iter(lambda: f.read(4096), b""):
369             _hash.update(chunk)
370     for extra_arg in args:
371         _hash.update(str(extra_arg).encode())
372     return _hash.hexdigest()
373 def _dict_to_json_pretty(d, sort_keys=True):
374     """
375     helper function to generate pretty printed json output
376     """
377     return salt.utils.json.dumps(
378         d, indent=4, separators=(",", ": "), sort_keys=sort_keys
379     )
380 def _name_matches(name, matches):
381     """
382     Helper function to see if given name has any of the patterns in given matches
383     """
384     for m in matches:
385         if name.endswith(m):
386             return True
387         if name.lower().endswith("_" + m.lower()):
388             return True
389         if name.lower() == m.lower():
390             return True
391     return False
392 def _object_reducer(
393     o,
394     names=(
395         "id",
396         "name",
397         "path",
398         "httpMethod",
399         "statusCode",
400         "Created",
401         "Deleted",
402         "Updated",
403         "Flushed",
404         "Associated",
405         "Disassociated",
406     ),
407 ):
408     """
409     Helper function to reduce the amount of information that will be kept in the change log
410     for API GW related return values
411     """
412     result = {}
413     if isinstance(o, dict):
414         for k, v in o.items():
415             if isinstance(v, dict):
416                 reduced = v if k == "variables" else _object_reducer(v, names)
417                 if reduced or _name_matches(k, names):
418                     result[k] = reduced
419             elif isinstance(v, list):
420                 newlist = []
421                 for val in v:
422                     reduced = _object_reducer(val, names)
423                     if reduced or _name_matches(k, names):
424                         newlist.append(reduced)
425                 if newlist:
426                     result[k] = newlist
427             else:
428                 if _name_matches(k, names):
429                     result[k] = v
430     return result
431 def _log_changes(ret, changekey, changevalue):
432     """
433     For logging create/update/delete operations to AWS ApiGateway
434     """
435     cl = ret["changes"].get("new", [])
436     cl.append({changekey: _object_reducer(changevalue)})
437     ret["changes"]["new"] = cl
438     return ret
439 def _log_error_and_abort(ret, obj):
440     """
441     helper function to update errors in the return structure
442     """
443     ret["result"] = False
444     ret["abort"] = True
445     if "error" in obj:
446         ret["comment"] = "{}".format(obj.get("error"))
447     return ret
448 class _Swagger:
449     """
450     this is a helper class that holds the swagger definition file and the associated logic
451     related to how to interpret the file and apply it to AWS Api Gateway.
452     The main interface to the outside world is in deploy_api, deploy_models, and deploy_resources
453     methods.
454     """
455     SWAGGER_OBJ_V2_FIELDS = (
456         "swagger",
457         "info",
458         "host",
459         "basePath",
460         "schemes",
461         "consumes",
462         "produces",
463         "paths",
464         "definitions",
465         "parameters",
466         "responses",
467         "securityDefinitions",
468         "security",
469         "tags",
470         "externalDocs",
471     )
472     SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
473         "swagger",
474         "info",
475         "basePath",
476         "schemes",
477         "paths",
478         "definitions",
479     )
480     SWAGGER_OPERATION_NAMES = (
481         "get",
482         "put",
483         "post",
484         "delete",
485         "options",
486         "head",
487         "patch",
488     )
489     SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
490     VENDOR_EXT_PATTERN = re.compile("^x-")
491     JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
492     REQUEST_TEMPLATE = {
493         "application/json": (
494             "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
495             " = $input.params().header)\n#foreach( $param in $map.entrySet()"
496             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
497             ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
498             " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
499             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
500             ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
501             " $input.params().path)\n#foreach( $param in $map.entrySet()"
502             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
503             ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
504             ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
505             ' "$context.requestId",\n"resourceId":'
506             ' "$context.resourceId",\n"resourcePath":'
507             ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
508             ' "user":"$context.identity.user",\n '
509             ' "userArn":"$context.identity.userArn",\n '
510             ' "userAgent":"$context.identity.userAgent",\n '
511             ' "sourceIp":"$context.identity.sourceIp",\n '
512             ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
513             ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
514             ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
515             '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
516             '  "caller":"$context.identity.caller",\n '
517             ' "apiKey":"$context.identity.apiKey",\n '
518             ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
519             " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
520             ' $stageVariables.keySet())\n"$variable":'
521             ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
522             " #end\n#end\n}\n}"
523         )
524     }
525     REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
526     RESPONSE_TEMPLATE = {
527         "application/json": (
528             "#set($inputRoot = $input.path('$'))\n"
529             "{\n"
530             '  "errorMessage" : "$inputRoot.errorMessage",\n'
531             '  "errorType" : "$inputRoot.errorType",\n'
532             '  "stackTrace" : [\n'
533             "#foreach($stackTrace in $inputRoot.stackTrace)\n"
534             "    [\n"
535             "#foreach($elem in $stackTrace)\n"
536             '      "$elem"\n'
537             "#if($foreach.hasNext),#end\n"
538             "#end\n"
539             "    ]\n"
540             "#if($foreach.hasNext),#end\n"
541             "#end\n"
542             "  ]\n"
543             "}"
544         )
545     }
546     RESPONSE_OPTION_TEMPLATE = {}
547     AWS_API_DESCRIPTION = _dict_to_json_pretty(
548         {
549             "provisioned_by": "Salt boto_apigateway.present State",
550             "context": "See deployment or stage description",
551         }
552     )
553     class SwaggerParameter:
554         """
555         This is a helper class for the Swagger Parameter Object
556         """
557         LOCATIONS = ("body", "query", "header", "path")
558         def __init__(self, paramdict):
559             self._paramdict = paramdict
560         @property
561         def location(self):
562             """
563             returns location in the swagger parameter object
564             """
565             _location = self._paramdict.get("in")
566             if _location in _Swagger.SwaggerParameter.LOCATIONS:
567                 return _location
568             raise ValueError(
569                 "Unsupported parameter location: {} in Parameter Object".format(
570                     _location
571                 )
572             )
573         @property
574         def name(self):
575             """
576             returns parameter name in the swagger parameter object
577             """
578             _name = self._paramdict.get("name")
579             if _name:
580                 if self.location == "header":
581                     return "method.request.header.{}".format(_name)
582                 elif self.location == "query":
583                     return "method.request.querystring.{}".format(_name)
584                 elif self.location == "path":
585                     return "method.request.path.{}".format(_name)
586                 return None
587             raise ValueError(
588                 "Parameter must have a name: {}".format(
589                     _dict_to_json_pretty(self._paramdict)
590                 )
591             )
592         @property
593         def schema(self):
594             """
595             returns the name of the schema given the reference in the swagger parameter object
596             """
597             if self.location == "body":
598                 _schema = self._paramdict.get("schema")
599                 if _schema:
600                     if "$ref" in _schema:
601                         schema_name = _schema.get("$ref").split("/")[-1]
602                         return schema_name
603                     raise ValueError(
604                         "Body parameter must have a JSON reference "
605                         "to the schema definition due to Amazon API restrictions: {}".format(
606                             self.name
607                         )
608                     )
609                 raise ValueError(
610                     "Body parameter must have a schema: {}".format(self.name)
611                 )
612             return None
613     class SwaggerMethodResponse:
614         """
615         Helper class for Swagger Method Response Object
616         """
617         def __init__(self, r):
618             self._r = r
619         @property
620         def schema(self):
621             """
622             returns the name of the schema given the reference in the swagger method response object
623             """
624             _schema = self._r.get("schema")
625             if _schema:
626                 if "$ref" in _schema:
627                     return _schema.get("$ref").split("/")[-1]
628                 raise ValueError(
629                     "Method response must have a JSON reference "
630                     "to the schema definition: {}".format(_schema)
631                 )
632             return None
633         @property
634         def headers(self):
635             """
636             returns the headers dictionary in the method response object
637             """
638             _headers = self._r.get("headers", {})
639             return _headers
640     def __init__(
641         self,
642         api_name,
643         stage_name,
644         lambda_funcname_format,
645         swagger_file_path,
646         error_response_template,
647         response_template,
648         common_aws_args,
649     ):
650         self._api_name = api_name
651         self._stage_name = stage_name
652         self._lambda_funcname_format = lambda_funcname_format
653         self._common_aws_args = common_aws_args
654         self._restApiId = ""
655         self._deploymentId = ""
656         self._error_response_template = error_response_template
657         self._response_template = response_template
658         if swagger_file_path is not None:
659             if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
660                 self._swagger_file = swagger_file_path
661                 self._md5_filehash = _gen_md5_filehash(
662                     self._swagger_file, error_response_template, response_template
663                 )
664                 with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
665                     self._cfg = salt.utils.yaml.safe_load(sf)
666                 self._swagger_version = ""
667             else:
668                 raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
669             self._validate_swagger_file()
670         self._validate_lambda_funcname_format()
671         self._resolve_api_id()
672     def _is_http_error_rescode(self, code):
673         """
674         Helper function to determine if the passed code is in the 400~599 range of http error
675         codes
676         """
677         return bool(re.match(r"^\s*[45]\d\d\s*$", code))
678     def _validate_error_response_model(self, paths, mods):
679         """
680         Helper function to help validate the convention established in the swagger file on how
681         to handle response code mapping/integration
682         """
683         for path, ops in paths:
684             for opname, opobj in ops.items():
685                 if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
686                     continue
687                 if "responses" not in opobj:
688                     raise ValueError(
689                         "missing mandatory responses field in path item object"
690                     )
691                 for rescode, resobj in opobj.get("responses").items():
692                     if not self._is_http_error_rescode(str(rescode)):
693                         continue
694                     if "schema" not in resobj:
695                         raise ValueError(
696                             "missing schema field in path {}, "
697                             "op {}, response {}".format(path, opname, rescode)
698                         )
699                     schemaobj = resobj.get("schema")
700                     if "$ref" not in schemaobj:
701                         raise ValueError(
702                             "missing $ref field under schema in "
703                             "path {}, op {}, response {}".format(path, opname, rescode)
704                         )
705                     schemaobjref = schemaobj.get("$ref", "/")
706                     modelname = schemaobjref.split("/")[-1]
707                     if modelname not in mods:
708                         raise ValueError(
709                             "model schema {} reference not found "
710                             "under /definitions".format(schemaobjref)
711                         )
712                     model = mods.get(modelname)
713                     if model.get("type") != "object":
714                         raise ValueError(
715                             "model schema {} must be type object".format(modelname)
716                         )
717                     if "properties" not in model:
718                         raise ValueError(
719                             "model schema {} must have properties fields".format(
720                                 modelname
721                             )
722                         )
723                     modelprops = model.get("properties")
724                     if "errorMessage" not in modelprops:
725                         raise ValueError(
726                             "model schema {} must have errorMessage as a property to "
727                             "match AWS convention. If pattern is not set, .+ will "
728                             "be used".format(modelname)
729                         )
730     def _validate_lambda_funcname_format(self):
731         """
732         Checks if the lambda function name format contains only known elements
733         :return: True on success, ValueError raised on error
734         """
735         try:
736             if self._lambda_funcname_format:
737                 known_kwargs = dict(stage="", api="", resource="", method="")
738                 self._lambda_funcname_format.format(**known_kwargs)
739             return True
740         except Exception:  # pylint: disable=broad-except
741             raise ValueError(
742                 "Invalid lambda_funcname_format {}.  Please review "
743                 "documentation for known substitutable keys".format(
744                     self._lambda_funcname_format
745                 )
746             )
747     def _validate_swagger_file(self):
748         """
749         High level check/validation of the input swagger file based on
750         https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md
751         This is not a full schema compliance check, but rather make sure that the input file (YAML or
752         JSON) can be read into a dictionary, and we check for the content of the Swagger Object for version
753         and info.
754         """
755         for field in self._cfg:
756             if (
757                 field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
758                 and not _Swagger.VENDOR_EXT_PATTERN.match(field)
759             ):
760                 raise ValueError("Invalid Swagger Object Field: {}".format(field))
761         for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
762             if field not in self._cfg:
763                 raise ValueError("Missing Swagger Object Field: {}".format(field))
764         self._swagger_version = self._cfg.get("swagger")
765         if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
766             raise ValueError(
767                 "Unsupported Swagger version: {},Supported versions are {}".format(
768                     self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
769                 )
770             )
771         log.info(type(self._models))
772         self._validate_error_response_model(self.paths, self._models())
773     @property
774     def md5_filehash(self):
775         """
776         returns md5 hash for the swagger file
777         """
778         return self._md5_filehash
779     @property
780     def info(self):
781         """
782         returns the swagger info object as a dictionary
783         """
784         info = self._cfg.get("info")
785         if not info:
786             raise ValueError("Info Object has no values")
787         return info
788     @property
789     def info_json(self):
790         """
791         returns the swagger info object as a pretty printed json string.
792         """
793         return _dict_to_json_pretty(self.info)
794     @property
795     def rest_api_name(self):
796         """
797         returns the name of the api
798         """
799         return self._api_name
800     @property
801     def rest_api_version(self):
802         """
803         returns the version field in the swagger info object
804         """
805         version = self.info.get("version")
806         if not version:
807             raise ValueError("Missing version value in Info Object")
808         return version
809     def _models(self):
810         """
811         returns an iterator for the models specified in the swagger file
812         """
813         models = self._cfg.get("definitions")
814         if not models:
815             raise ValueError(
816                 "Definitions Object has no values, You need to define them in your"
817                 " swagger file"
818             )
819         return models
820     def models(self):
821         """
822         generator to return the tuple of model and its schema to create on aws.
823         """
824         model_dict = self._build_all_dependencies()
825         while True:
826             model = self._get_model_without_dependencies(model_dict)
827             if not model:
828                 break
829             yield (model, self._models().get(model))
830     @property
831     def paths(self):
832         """
833         returns an iterator for the relative resource paths specified in the swagger file
834         """
835         paths = self._cfg.get("paths")
836         if not paths:
837             raise ValueError(
838                 "Paths Object has no values, You need to define them in your swagger"
839                 " file"
840             )
841         for path in paths:
842             if not path.startswith("/"):
843                 raise ValueError(
844                     "Path object {} should start with /. Please fix it".format(path)
845                 )
846         return paths.items()
847     @property
848     def basePath(self):
849         """
850         returns the base path field as defined in the swagger file
851         """
852         basePath = self._cfg.get("basePath", "")
853         return basePath
854     @property
855     def restApiId(self):
856         """
857         returns the rest api id as returned by AWS on creation of the rest api
858         """
859         return self._restApiId
860     @restApiId.setter
861     def restApiId(self, restApiId):
862         """
863         allows the assignment of the rest api id on creation of the rest api
864         """
865         self._restApiId = restApiId
866     @property
867     def deployment_label_json(self):
868         """
869         this property returns the unique description in pretty printed json for
870         a particular api deployment
871         """
872         return _dict_to_json_pretty(self.deployment_label)
873     @property
874     def deployment_label(self):
875         """
876         this property returns the deployment label dictionary (mainly used by
877         stage description)
878         """
879         label = dict()
880         label["swagger_info_object"] = self.info
881         label["api_name"] = self.rest_api_name
882         label["swagger_file"] = os.path.basename(self._swagger_file)
883         label["swagger_file_md5sum"] = self.md5_filehash
884         return label
885     def _one_or_more_stages_remain(self, deploymentId):
886         """
887         Helper function to find whether there are other stages still associated with a deployment
888         """
889         stages = __salt__["boto_apigateway.describe_api_stages"](
890             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
891         ).get("stages")
892         return bool(stages)
893     def no_more_deployments_remain(self):
894         """
895         Helper function to find whether there are deployments left with stages associated
896         """
897         no_more_deployments = True
898         deployments = __salt__["boto_apigateway.describe_api_deployments"](
899             restApiId=self.restApiId, **self._common_aws_args
900         ).get("deployments")
901         if deployments:
902             for deployment in deployments:
903                 deploymentId = deployment.get("id")
904                 stages = __salt__["boto_apigateway.describe_api_stages"](
905                     restApiId=self.restApiId,
906                     deploymentId=deploymentId,
907                     **self._common_aws_args
908                 ).get("stages")
909                 if stages:
910                     no_more_deployments = False
911                     break
912         return no_more_deployments
913     def _get_current_deployment_id(self):
914         """
915         Helper method to find the deployment id that the stage name is currently assocaited with.
916         """
917         deploymentId = ""
918         stage = __salt__["boto_apigateway.describe_api_stage"](
919             restApiId=self.restApiId,
920             stageName=self._stage_name,
921             **self._common_aws_args
922         ).get("stage")
923         if stage:
924             deploymentId = stage.get("deploymentId")
925         return deploymentId
926     def _get_current_deployment_label(self):
927         """
928         Helper method to find the deployment label that the stage_name is currently associated with.
929         """
930         deploymentId = self._get_current_deployment_id()
931         deployment = __salt__["boto_apigateway.describe_api_deployment"](
932             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
933         ).get("deployment")
934         if deployment:
935             return deployment.get("description")
936         return None
937     def _get_desired_deployment_id(self):
938         """
939         Helper method to return the deployment id matching the desired deployment label for
940         this Swagger object based on the given api_name, swagger_file
941         """
942         deployments = __salt__["boto_apigateway.describe_api_deployments"](
943             restApiId=self.restApiId, **self._common_aws_args
944         ).get("deployments")
945         if deployments:
946             for deployment in deployments:
947                 if deployment.get("description") == self.deployment_label_json:
948                     return deployment.get("id")
949         return ""
950     def overwrite_stage_variables(self, ret, stage_variables):
951         """
952         overwrite the given stage_name's stage variables with the given stage_variables
953         """
954         res = __salt__["boto_apigateway.overwrite_api_stage_variables"](
955             restApiId=self.restApiId,
956             stageName=self._stage_name,
957             variables=stage_variables,
958             **self._common_aws_args
959         )
960         if not res.get("overwrite"):
961             ret["result"] = False
962             ret["abort"] = True
963             ret["comment"] = res.get("error")
964         else:
965             ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
966         return ret
967     def _set_current_deployment(self, stage_desc_json, stage_variables):
968         """
969         Helper method to associate the stage_name to the given deploymentId and make this current
970         """
971         stage = __salt__["boto_apigateway.describe_api_stage"](
972             restApiId=self.restApiId,
973             stageName=self._stage_name,
974             **self._common_aws_args
975         ).get("stage")
976         if not stage:
977             stage = __salt__["boto_apigateway.create_api_stage"](
978                 restApiId=self.restApiId,
979                 stageName=self._stage_name,
980                 deploymentId=self._deploymentId,
981                 description=stage_desc_json,
982                 variables=stage_variables,
983                 **self._common_aws_args
984             )
985             if not stage.get("stage"):
986                 return {"set": False, "error": stage.get("error")}
987         else:
988             overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
989                 restApiId=self.restApiId,
990                 stageName=self._stage_name,
991                 variables=stage_variables,
992                 **self._common_aws_args
993             )
994             if not overwrite.get("stage"):
995                 return {"set": False, "error": overwrite.get("error")}
996         return __salt__["boto_apigateway.activate_api_deployment"](
997             restApiId=self.restApiId,
998             stageName=self._stage_name,
999             deploymentId=self._deploymentId,
1000             **self._common_aws_args
1001         )
1002     def _resolve_api_id(self):
1003         """
1004         returns an Api Id that matches the given api_name and the hardcoded _Swagger.AWS_API_DESCRIPTION
1005         as the api description
1006         """
1007         apis = __salt__["boto_apigateway.describe_apis"](
1008             name=self.rest_api_name,
1009             description=_Swagger.AWS_API_DESCRIPTION,
1010             **self._common_aws_args
1011         ).get("restapi")
1012         if apis:
1013             if len(apis) == 1:
1014                 self.restApiId = apis[0].get("id")
1015             else:
1016                 raise ValueError(
1017                     "Multiple APIs matching given name {} and description {}".format(
1018                         self.rest_api_name, self.info_json
1019                     )
1020                 )
1021     def delete_stage(self, ret):
1022         """
1023         Method to delete the given stage_name.  If the current deployment tied to the given
1024         stage_name has no other stages associated with it, the deployment will be removed
1025         as well
1026         """
1027         deploymentId = self._get_current_deployment_id()
1028         if deploymentId:
1029             result = __salt__["boto_apigateway.delete_api_stage"](
1030                 restApiId=self.restApiId,
1031                 stageName=self._stage_name,
1032                 **self._common_aws_args
1033             )
1034             if not result.get("deleted"):
1035                 ret["abort"] = True
1036                 ret["result"] = False
1037                 ret["comment"] = "delete_stage delete_api_stage, {}".format(
1038                     result.get("error")
1039                 )
1040             else:
1041                 if not self._one_or_more_stages_remain(deploymentId):
1042                     result = __salt__["boto_apigateway.delete_api_deployment"](
1043                         restApiId=self.restApiId,
1044                         deploymentId=deploymentId,
1045                         **self._common_aws_args
1046                     )
1047                     if not result.get("deleted"):
1048                         ret["abort"] = True
1049                         ret["result"] = False
1050                         ret[
1051                             "comment"
1052                         ] = "delete_stage delete_api_deployment, {}".format(
1053                             result.get("error")
1054                         )
1055                 else:
1056                     ret["comment"] = "stage {} has been deleted.\n".format(
1057                         self._stage_name
1058                     )
1059         else:
1060             ret["comment"] = "stage {} does not exist".format(self._stage_name)
1061         return ret
1062     def verify_api(self, ret):
1063         """
1064         this method helps determine if the given stage_name is already on a deployment
1065         label matching the input api_name, swagger_file.
1066         If yes, returns abort with comment indicating already at desired state.
1067         If not and there is previous deployment labels in AWS matching the given input api_name and
1068         swagger file, indicate to the caller that we only need to reassociate stage_name to the
1069         previously existing deployment label.
1070         """
1071         if self.restApiId:
1072             deployed_label_json = self._get_current_deployment_label()
1073             if deployed_label_json == self.deployment_label_json:
1074                 ret["comment"] = (
1075                     "Already at desired state, the stage {} is already at the desired "
1076                     "deployment label:\n{}".format(
1077                         self._stage_name, deployed_label_json
1078                     )
1079                 )
1080                 ret["current"] = True
1081                 return ret
1082             else:
1083                 self._deploymentId = self._get_desired_deployment_id()
1084                 if self._deploymentId:
1085                     ret["publish"] = True
1086         return ret
1087     def publish_api(self, ret, stage_variables):
1088         """
1089         this method tie the given stage_name to a deployment matching the given swagger_file
1090         """
1091         stage_desc = dict()
1092         stage_desc["current_deployment_label"] = self.deployment_label
1093         stage_desc_json = _dict_to_json_pretty(stage_desc)
1094         if self._deploymentId:
1095             res = self._set_current_deployment(stage_desc_json, stage_variables)
1096             if not res.get("set"):
1097                 ret["abort"] = True
1098                 ret["result"] = False
1099                 ret["comment"] = res.get("error")
1100             else:
1101                 ret = _log_changes(
1102                     ret,
1103                     "publish_api (reassociate deployment, set stage_variables)",
1104                     res.get("response"),
1105                 )
1106         else:
1107             res = __salt__["boto_apigateway.create_api_deployment"](
1108                 restApiId=self.restApiId,
1109                 stageName=self._stage_name,
1110                 stageDescription=stage_desc_json,
1111                 description=self.deployment_label_json,
1112                 variables=stage_variables,
1113                 **self._common_aws_args
1114             )
1115             if not res.get("created"):
1116                 ret["abort"] = True
1117                 ret["result"] = False
1118                 ret["comment"] = res.get("error")
1119             else:
1120                 ret = _log_changes(
1121                     ret, "publish_api (new deployment)", res.get("deployment")
1122                 )
1123         return ret
1124     def _cleanup_api(self):
1125         """
1126         Helper method to clean up resources and models if we detected a change in the swagger file
1127         for a stage
1128         """
1129         resources = __salt__["boto_apigateway.describe_api_resources"](
1130             restApiId=self.restApiId, **self._common_aws_args
1131         )
1132         if resources.get("resources"):
1133             res = resources.get("resources")[1:]
1134             res.reverse()
1135             for resource in res:
1136                 delres = __salt__["boto_apigateway.delete_api_resources"](
1137                     restApiId=self.restApiId,
1138                     path=resource.get("path"),
1139                     **self._common_aws_args
1140                 )
1141                 if not delres.get("deleted"):
1142                     return delres
1143         models = __salt__["boto_apigateway.describe_api_models"](
1144             restApiId=self.restApiId, **self._common_aws_args
1145         )
1146         if models.get("models"):
1147             for model in models.get("models"):
1148                 delres = __salt__["boto_apigateway.delete_api_model"](
1149                     restApiId=self.restApiId,
1150                     modelName=model.get("name"),
1151                     **self._common_aws_args
1152                 )
1153                 if not delres.get("deleted"):
1154                     return delres
1155         return {"deleted": True}
1156     def deploy_api(self, ret):
1157         """
1158         this method create the top level rest api in AWS apigateway
1159         """
1160         if self.restApiId:
1161             res = self._cleanup_api()
1162             if not res.get("deleted"):
1163                 ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
1164                 ret["abort"] = True
1165                 ret["result"] = False
1166                 return ret
1167             return ret
1168         response = __salt__["boto_apigateway.create_api"](
1169             name=self.rest_api_name,
1170             description=_Swagger.AWS_API_DESCRIPTION,
1171             **self._common_aws_args
1172         )
1173         if not response.get("created"):
1174             ret["result"] = False
1175             ret["abort"] = True
1176             if "error" in response:
1177                 ret["comment"] = "Failed to create rest api: {}.".format(
1178                     response["error"]["message"]
1179                 )
1180             return ret
1181         self.restApiId = response.get("restapi", {}).get("id")
1182         return _log_changes(ret, "deploy_api", response.get("restapi"))
1183     def delete_api(self, ret):
1184         """
1185         Method to delete a Rest Api named defined in the swagger file's Info Object's title value.
1186         ret
1187             a dictionary for returning status to Saltstack
1188         """
1189         exists_response = __salt__["boto_apigateway.api_exists"](
1190             name=self.rest_api_name,
1191             description=_Swagger.AWS_API_DESCRIPTION,
1192             **self._common_aws_args
1193         )
1194         if exists_response.get("exists"):
1195             if __opts__["test"]:
1196                 ret["comment"] = "Rest API named {} is set to be deleted.".format(
1197                     self.rest_api_name
1198                 )
1199                 ret["result"] = None
1200                 ret["abort"] = True
1201                 return ret
1202             delete_api_response = __salt__["boto_apigateway.delete_api"](
1203                 name=self.rest_api_name,
1204                 description=_Swagger.AWS_API_DESCRIPTION,
1205                 **self._common_aws_args
1206             )
1207             if not delete_api_response.get("deleted"):
1208                 ret["result"] = False
1209                 ret["abort"] = True
1210                 if "error" in delete_api_response:
1211                     ret["comment"] = "Failed to delete rest api: {}.".format(
1212                         delete_api_response["error"]["message"]
1213                     )
1214                 return ret
1215             ret = _log_changes(ret, "delete_api", delete_api_response)
1216         else:
1217             ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
1218                 self.rest_api_name, self.info_json
1219             )
1220         return ret
1221     def _aws_model_ref_from_swagger_ref(self, r):
1222         """
1223         Helper function to reference models created on aws apigw
1224         """
1225         model_name = r.split("/")[-1]
1226         return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
1227             self.restApiId, model_name
1228         )
1229     def _update_schema_to_aws_notation(self, schema):
1230         """
1231         Helper function to map model schema to aws notation
1232         """
1233         result = {}
1234         for k, v in schema.items():
1235             if k == "$ref":
1236                 v = self._aws_model_ref_from_swagger_ref(v)
1237             if isinstance(v, dict):
1238                 v = self._update_schema_to_aws_notation(v)
1239             result[k] = v
1240         return result
1241     def _build_dependent_model_list(self, obj_schema):
1242         """
1243         Helper function to build the list of models the given object schema is referencing.
1244         """
1245         dep_models_list = []
1246         if obj_schema:
1247             obj_schema["type"] = obj_schema.get("type", "object")
1248         if obj_schema["type"] == "array":
1249             dep_models_list.extend(
1250                 self._build_dependent_model_list(obj_schema.get("items", {}))
1251             )
1252         else:
1253             ref = obj_schema.get("$ref")
1254             if ref:
1255                 ref_obj_model = ref.split("/")[-1]
1256                 ref_obj_schema = self._models().get(ref_obj_model)
1257                 dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
1258                 dep_models_list.extend([ref_obj_model])
1259             else:
1260                 properties = obj_schema.get("properties")
1261                 if properties:
1262                     for _, prop_obj_schema in properties.items():
1263                         dep_models_list.extend(
1264                             self._build_dependent_model_list(prop_obj_schema)
1265                         )
1266         return list(set(dep_models_list))
1267     def _build_all_dependencies(self):
1268         """
1269         Helper function to build a map of model to their list of model reference dependencies
1270         """
1271         ret = {}
1272         for model, schema in self._models().items():
1273             dep_list = self._build_dependent_model_list(schema)
1274             ret[model] = dep_list
1275         return ret
1276     def _get_model_without_dependencies(self, models_dict):
1277         """
1278         Helper function to find the next model that should be created
1279         """
1280         next_model = None
1281         if not models_dict:
1282             return next_model
1283         for model, dependencies in models_dict.items():
1284             if dependencies == []:
1285                 next_model = model
1286                 break
1287         if next_model is None:
1288             raise ValueError(
1289                 "incomplete model definitions, models in dependency "
1290                 "list not defined: {}".format(models_dict)
1291             )
1292         models_dict.pop(next_model)
1293         for model, dep_list in models_dict.items():
1294             if next_model in dep_list:
1295                 dep_list.remove(next_model)
1296         return next_model
1297     def deploy_models(self, ret):
1298         """
1299         Method to deploy swagger file's definition objects and associated schema to AWS Apigateway as Models
1300         ret
1301             a dictionary for returning status to Saltstack
1302         """
1303         for model, schema in self.models():
1304             _schema = self._update_schema_to_aws_notation(schema)
1305             _schema.update(
1306                 {
1307                     "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
1308                     "title": "{} Schema".format(model),
1309                 }
1310             )
1311             model_exists_response = __salt__["boto_apigateway.api_model_exists"](
1312                 restApiId=self.restApiId, modelName=model, **self._common_aws_args
1313             )
1314             if model_exists_response.get("exists"):
1315                 update_model_schema_response = __salt__[
1316                     "boto_apigateway.update_api_model_schema"
1317                 ](
1318                     restApiId=self.restApiId,
1319                     modelName=model,
1320                     schema=_dict_to_json_pretty(_schema),
1321                     **self._common_aws_args
1322                 )
1323                 if not update_model_schema_response.get("updated"):
1324                     ret["result"] = False
1325                     ret["abort"] = True
1326                     if "error" in update_model_schema_response:
1327                         ret[
1328                             "comment"
1329                         ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
1330                             model,
1331                             _dict_to_json_pretty(schema),
1332                             update_model_schema_response["error"]["message"],
1333                         )
1334                     return ret
1335                 ret = _log_changes(ret, "deploy_models", update_model_schema_response)
1336             else:
1337                 create_model_response = __salt__["boto_apigateway.create_api_model"](
1338                     restApiId=self.restApiId,
1339                     modelName=model,
1340                     modelDescription=model,
1341                     schema=_dict_to_json_pretty(_schema),
1342                     contentType="application/json",
1343                     **self._common_aws_args
1344                 )
1345                 if not create_model_response.get("created"):
1346                     ret["result"] = False
1347                     ret["abort"] = True
1348                     if "error" in create_model_response:
1349                         ret[
1350                             "comment"
1351                         ] = "Failed to create model {}, schema {}, error: {}".format(
1352                             model,
1353                             _dict_to_json_pretty(schema),
1354                             create_model_response["error"]["message"],
1355                         )
1356                     return ret
1357                 ret = _log_changes(ret, "deploy_models", create_model_response)
1358         return ret
1359     def _lambda_name(self, resourcePath, httpMethod):
1360         """
1361         Helper method to construct lambda name based on the rule specified in doc string of
1362         boto_apigateway.api_present function
1363         """
1364         lambda_name = self._lambda_funcname_format.format(
1365             stage=self._stage_name,
1366             api=self.rest_api_name,
1367             resource=resourcePath,
1368             method=httpMethod,
1369         )
1370         lambda_name = lambda_name.strip()
1371         lambda_name = re.sub(r"{|}", "", lambda_name)
1372         lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
1373         return re.sub(r"_+", "_", lambda_name)
1374     def _lambda_uri(self, lambda_name, lambda_region):
1375         """
1376         Helper Method to construct the lambda uri for use in method integration
1377         """
1378         profile = self._common_aws_args.get("profile")
1379         region = self._common_aws_args.get("region")
1380         lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
1381         apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
1382         lambda_desc = __salt__["boto_lambda.describe_function"](
1383             lambda_name, **self._common_aws_args
1384         )
1385         if lambda_region != apigw_region:
1386             if not lambda_desc.get("function"):
1387                 lambda_desc = __salt__["boto_lambda.describe_function"](
1388                     lambda_name, **self._common_aws_args
1389                 )
1390         if not lambda_desc.get("function"):
1391             raise ValueError(
1392                 "Could not find lambda function {} in regions [{}, {}].".format(
1393                     lambda_name, lambda_region, apigw_region
1394             )
1395         lambda_arn = lambda_desc<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("function").get("FunctionArn")
1396         lambda_uri = (
1397             "arn:aws:apigateway:{}:lambda:path/2015-03-31"
1398             "/functions/{}/invocations".format(apigw_region, lambda_arn)
1399         )
1400         return lambda_uri
1401     def _parse_method_data(self, method_name, method_data):
1402         """
1403         Helper function to construct the method request params, models, request_templates and
1404         integration_type values needed to configure method request integration/mappings.
1405         """
1406         method_params = {}
1407         method_models =</b></font> {}
1408         if "parameters" in method_data:
1409             for param in method_data["parameters"]:
1410                 p = _Swagger.SwaggerParameter(param)
1411                 if p.name:
1412                     method_params[p.name] = True
1413                 if p.schema:
1414                     method_models["application/json"] = p.schema
1415         request_templates = (
1416             _Swagger.REQUEST_OPTION_TEMPLATE
1417             if method_name == "options"
1418             else _Swagger.REQUEST_TEMPLATE
1419         )
1420         integration_type = "MOCK" if method_name == "options" else "AWS"
1421         return {
1422             "params": method_params,
1423             "models": method_models,
1424             "request_templates": request_templates,
1425             "integration_type": integration_type,
1426         }
1427     def _find_patterns(self, o):
1428         result = []
1429         if isinstance(o, dict):
1430             for k, v in o.items():
1431                 if isinstance(v, dict):
1432                     result.extend(self._find_patterns(v))
1433                 else:
1434                     if k == "pattern":
1435                         result.append(v)
1436         return result
1437     def _get_pattern_for_schema(self, schema_name, httpStatus):
1438         """
1439         returns the pattern specified in a response schema
1440         """
1441         defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
1442         model = self._models().get(schema_name)
1443         patterns = self._find_patterns(model)
1444         return patterns[0] if patterns else defaultPattern
1445     def _get_response_template(self, method_name, http_status):
1446         if method_name == "options" or not self._is_http_error_rescode(http_status):
1447             response_templates = (
1448                 {"application/json": self._response_template}
1449                 if self._response_template
1450                 else self.RESPONSE_OPTION_TEMPLATE
1451             )
1452         else:
1453             response_templates = (
1454                 {"application/json": self._error_response_template}
1455                 if self._error_response_template
1456                 else self.RESPONSE_TEMPLATE
1457             )
1458         return response_templates
1459     def _parse_method_response(self, method_name, method_response, httpStatus):
1460         """
1461         Helper function to construct the method response params, models, and integration_params
1462         values needed to configure method response integration/mappings.
1463         """
1464         method_response_models = {}
1465         method_response_pattern = ".*"
1466         if method_response.schema:
1467             method_response_models["application/json"] = method_response.schema
1468             method_response_pattern = self._get_pattern_for_schema(
1469                 method_response.schema, httpStatus
1470             )
1471         method_response_params = {}
1472         method_integration_response_params = {}
1473         for header in method_response.headers:
1474             response_header = "method.response.header.{}".format(header)
1475             method_response_params[response_header] = False
1476             header_data = method_response.headers.get(header)
1477             method_integration_response_params[response_header] = (
1478                 "'{}'".format(header_data.get("default"))
1479                 if "default" in header_data
1480                 else "'*'"
1481             )
1482         response_templates = self._get_response_template(method_name, httpStatus)
1483         return {
1484             "params": method_response_params,
1485             "models": method_response_models,
1486             "integration_params": method_integration_response_params,
1487             "pattern": method_response_pattern,
1488             "response_templates": response_templates,
1489         }
1490     def _deploy_method(
1491         self,
1492         ret,
1493         resource_path,
1494         method_name,
1495         method_data,
1496         api_key_required,
1497         lambda_integration_role,
1498         lambda_region,
1499         authorization_type,
1500     ):
1501         """
1502         Method to create a method for the given resource path, along with its associated
1503         request and response integrations.
1504         ret
1505             a dictionary for returning status to Saltstack
1506         resource_path
1507             the full resource path where the named method_name will be associated with.
1508         method_name
1509             a string that is one of the following values: 'delete', 'get', 'head', 'options',
1510             'patch', 'post', 'put'
1511         method_data
1512             the value dictionary for this method in the swagger definition file.
1513         api_key_required
1514             True or False, whether api key is required to access this method.
1515         lambda_integration_role
1516             name of the IAM role or IAM role arn that Api Gateway will assume when executing
1517             the associated lambda function
1518         lambda_region
1519             the region for the lambda function that Api Gateway will integrate to.
1520         authorization_type
1521             'NONE' or 'AWS_IAM'
1522         """
1523         method = self._parse_method_data(method_name.lower(), method_data)
1524         if method_name.lower() == "options":
1525             api_key_required = False
1526             authorization_type = "NONE"
1527         m = __salt__["boto_apigateway.create_api_method"](
1528             restApiId=self.restApiId,
1529             resourcePath=resource_path,
1530             httpMethod=method_name.upper(),
1531             authorizationType=authorization_type,
1532             apiKeyRequired=api_key_required,
1533             requestParameters=method.get("params"),
1534             requestModels=method.get("models"),
1535             **self._common_aws_args
1536         )
1537         if not m.get("created"):
1538             ret = _log_error_and_abort(ret, m)
1539             return ret
1540         ret = _log_changes(ret, "_deploy_method.create_api_method", m)
1541         lambda_uri = ""
1542         if method_name.lower() != "options":
1543             lambda_uri = self._lambda_uri(
1544                 self._lambda_name(resource_path, method_name),
1545                 lambda_region=lambda_region,
1546             )
1547         integration = __salt__["boto_apigateway.create_api_integration"](
1548             restApiId=self.restApiId,
1549             resourcePath=resource_path,
1550             httpMethod=method_name.upper(),
1551             integrationType=method.get("integration_type"),
1552             integrationHttpMethod="POST",
1553             uri=lambda_uri,
1554             credentials=lambda_integration_role,
1555             requestTemplates=method.get("request_templates"),
1556             **self._common_aws_args
1557         )
1558         if not integration.get("created"):
1559             ret = _log_error_and_abort(ret, integration)
1560             return ret
1561         ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
1562         if "responses" in method_data:
1563             for response, response_data in method_data["responses"].items():
1564                 httpStatus = str(response)
1565                 method_response = self._parse_method_response(
1566                     method_name.lower(),
1567                     _Swagger.SwaggerMethodResponse(response_data),
1568                     httpStatus,
1569                 )
1570                 mr = __salt__["boto_apigateway.create_api_method_response"](
1571                     restApiId=self.restApiId,
1572                     resourcePath=resource_path,
1573                     httpMethod=method_name.upper(),
1574                     statusCode=httpStatus,
1575                     responseParameters=method_response.get("params"),
1576                     responseModels=method_response.get("models"),
1577                     **self._common_aws_args
1578                 )
1579                 if not mr.get("created"):
1580                     ret = _log_error_and_abort(ret, mr)
1581                     return ret
1582                 ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
1583                 mir = __salt__["boto_apigateway.create_api_integration_response"](
1584                     restApiId=self.restApiId,
1585                     resourcePath=resource_path,
1586                     httpMethod=method_name.upper(),
1587                     statusCode=httpStatus,
1588                     selectionPattern=method_response.get("pattern"),
1589                     responseParameters=method_response.get("integration_params"),
1590                     responseTemplates=method_response.get("response_templates"),
1591                     **self._common_aws_args
1592                 )
1593                 if not mir.get("created"):
1594                     ret = _log_error_and_abort(ret, mir)
1595                     return ret
1596                 ret = _log_changes(
1597                     ret, "_deploy_method.create_api_integration_response", mir
1598                 )
1599         else:
1600             raise ValueError(
1601                 "No responses specified for {} {}".format(resource_path, method_name)
1602             )
1603         return ret
1604     def deploy_resources(
1605         self,
1606         ret,
1607         api_key_required,
1608         lambda_integration_role,
1609         lambda_region,
1610         authorization_type,
1611     ):
1612         """
1613         Method to deploy resources defined in the swagger file.
1614         ret
1615             a dictionary for returning status to Saltstack
1616         api_key_required
1617             True or False, whether api key is required to access this method.
1618         lambda_integration_role
1619             name of the IAM role or IAM role arn that Api Gateway will assume when executing
1620             the associated lambda function
1621         lambda_region
1622             the region for the lambda function that Api Gateway will integrate to.
1623         authorization_type
1624             'NONE' or 'AWS_IAM'
1625         """
1626         for path, pathData in self.paths:
1627             resource = __salt__["boto_apigateway.create_api_resources"](
1628                 restApiId=self.restApiId, path=path, **self._common_aws_args
1629             )
1630             if not resource.get("created"):
1631                 ret = _log_error_and_abort(ret, resource)
1632                 return ret
1633             ret = _log_changes(ret, "deploy_resources", resource)
1634             for method, method_data in pathData.items():
1635                 if method in _Swagger.SWAGGER_OPERATION_NAMES:
1636                     ret = self._deploy_method(
1637                         ret,
1638                         path,
1639                         method,
1640                         method_data,
1641                         api_key_required,
1642                         lambda_integration_role,
1643                         lambda_region,
1644                         authorization_type,
1645                     )
1646         return ret
1647 def usage_plan_present(
1648     name,
1649     plan_name,
1650     description=None,
1651     throttle=None,
1652     quota=None,
1653     region=None,
1654     key=None,
1655     keyid=None,
1656     profile=None,
1657 ):
1658     """
1659     Ensure the spcifieda usage plan with the corresponding metrics is deployed
1660     .. versionadded:: 2017.7.0
1661     name
1662         name of the state
1663     plan_name
1664         [Required] name of the usage plan
1665     throttle
1666         [Optional] throttling parameters expressed as a dictionary.
1667         If provided, at least one of the throttling parameters must be present
1668         rateLimit
1669             rate per second at which capacity bucket is populated
1670         burstLimit
1671             maximum rate allowed
1672     quota
1673         [Optional] quota on the number of api calls permitted by the plan.
1674         If provided, limit and period must be present
1675         limit
1676             [Required] number of calls permitted per quota period
1677         offset
1678             [Optional] number of calls to be subtracted from the limit at the beginning of the period
1679         period
1680             [Required] period to which quota applies. Must be DAY, WEEK or MONTH
1681     .. code-block:: yaml
1682         UsagePlanPresent:
1683           boto_apigateway.usage_plan_present:
1684             - plan_name: my_usage_plan
1685             - throttle:
1686                 rateLimit: 70
1687                 burstLimit: 100
1688             - quota:
1689                 limit: 1000
1690                 offset: 0
1691                 period: DAY
1692             - profile: my_profile
1693     """
1694     func_params = locals()
1695     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1696     try:
1697         common_args = dict(
1698             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1699         )
1700         existing = __salt__["boto_apigateway.describe_usage_plans"](
1701             name=plan_name, **common_args
1702         )
1703         if "error" in existing:
1704             ret["result"] = False
1705             ret["comment"] = "Failed to describe existing usage plans"
1706             return ret
1707         if not existing["plans"]:
1708             if __opts__["test"]:
1709                 ret["comment"] = "a new usage plan {} would be created".format(
1710                     plan_name
1711                 )
1712                 ret["result"] = None
1713                 return ret
1714             result = __salt__["boto_apigateway.create_usage_plan"](
1715                 name=plan_name,
1716                 description=description,
1717                 throttle=throttle,
1718                 quota=quota,
1719                 **common_args
1720             )
1721             if "error" in result:
1722                 ret["result"] = False
1723                 ret["comment"] = "Failed to create a usage plan {}, {}".format(
1724                     plan_name, result["error"]
1725                 )
1726                 return ret
1727             ret["changes"]["old"] = {"plan": None}
1728             ret["comment"] = "A new usage plan {} has been created".format(plan_name)
1729         else:
1730             plan = existing["plans"][0]
1731             needs_updating = False
1732             modifiable_params = (
1733                 ("throttle", ("rateLimit", "burstLimit")),
1734                 ("quota", ("limit", "offset", "period")),
1735             )
1736             for p, fields in modifiable_params:
1737                 for f in fields:
1738                     actual_param = (
1739                         {} if func_params.get(p) is None else func_params.get(p)
1740                     )
1741                     if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
1742                         needs_updating = True
1743                         break
1744             if not needs_updating:
1745                 ret["comment"] = "usage plan {} is already in a correct state".format(
1746                     plan_name
1747                 )
1748                 ret["result"] = True
1749                 return ret
1750             if __opts__["test"]:
1751                 ret["comment"] = "a new usage plan {} would be updated".format(
1752                     plan_name
1753                 )
1754                 ret["result"] = None
1755                 return ret
1756             result = __salt__["boto_apigateway.update_usage_plan"](
1757                 plan["id"], throttle=throttle, quota=quota, **common_args
1758             )
1759             if "error" in result:
1760                 ret["result"] = False
1761                 ret["comment"] = "Failed to update a usage plan {}, {}".format(
1762                     plan_name, result["error"]
1763                 )
1764                 return ret
1765             ret["changes"]["old"] = {"plan": plan}
1766             ret["comment"] = "usage plan {} has been updated".format(plan_name)
1767         newstate = __salt__["boto_apigateway.describe_usage_plans"](
1768             name=plan_name, **common_args
1769         )
1770         if "error" in existing:
1771             ret["result"] = False
1772             ret["comment"] = "Failed to describe existing usage plans after updates"
1773             return ret
1774         ret["changes"]["new"] = {"plan": newstate["plans"][0]}
1775     except (ValueError, OSError) as e:
1776         ret["result"] = False
1777         ret["comment"] = "{}".format(e.args)
1778     return ret
1779 def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
1780     """
1781     Ensures usage plan identified by name is no longer present
1782     .. versionadded:: 2017.7.0
1783     name
1784         name of the state
1785     plan_name
1786         name of the plan to remove
1787     .. code-block:: yaml
1788         usage plan absent:
1789           boto_apigateway.usage_plan_absent:
1790             - plan_name: my_usage_plan
1791             - profile: my_profile
1792     """
1793     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1794     try:
1795         common_args = dict(
1796             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1797         )
1798         existing = __salt__["boto_apigateway.describe_usage_plans"](
1799             name=plan_name, **common_args
1800         )
1801         if "error" in existing:
1802             ret["result"] = False
1803             ret["comment"] = "Failed to describe existing usage plans"
1804             return ret
1805         if not existing["plans"]:
1806             ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
1807             return ret
1808         if __opts__["test"]:
1809             ret["comment"] = "Usage plan {} exists and would be deleted".format(
1810                 plan_name
1811             )
1812             ret["result"] = None
1813             return ret
1814         plan_id = existing["plans"][0]["id"]
1815         result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
1816         if "error" in result:
1817             ret["result"] = False
1818             ret["comment"] = "Failed to delete usage plan {}, {}".format(
1819                 plan_name, result
1820             )
1821             return ret
1822         ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
1823         ret["changes"]["old"] = {"plan": existing["plans"][0]}
1824         ret["changes"]["new"] = {"plan": None}
1825     except (ValueError, OSError) as e:
1826         ret["result"] = False
1827         ret["comment"] = "{}".format(e.args)
1828     return ret
1829 def usage_plan_association_present(
1830     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1831 ):
1832     """
1833     Ensures usage plan identified by name is added to provided api_stages
1834     .. versionadded:: 2017.7.0
1835     name
1836         name of the state
1837     plan_name
1838         name of the plan to use
1839     api_stages
1840         list of dictionaries, where each dictionary consists of the following keys:
1841         apiId
1842             apiId of the api to attach usage plan to
1843         stage
1844             stage name of the api to attach usage plan to
1845     .. code-block:: yaml
1846         UsagePlanAssociationPresent:
1847           boto_apigateway.usage_plan_association_present:
1848             - plan_name: my_plan
1849             - api_stages:
1850               - apiId: 9kb0404ec0
1851                 stage: my_stage
1852               - apiId: l9v7o2aj90
1853                 stage: my_stage
1854             - profile: my_profile
1855     """
1856     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1857     try:
1858         common_args = dict(
1859             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1860         )
1861         existing = __salt__["boto_apigateway.describe_usage_plans"](
1862             name=plan_name, **common_args
1863         )
1864         if "error" in existing:
1865             ret["result"] = False
1866             ret["comment"] = "Failed to describe existing usage plans"
1867             return ret
1868         if not existing["plans"]:
1869             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1870             ret["result"] = False
1871             return ret
1872         if len(existing["plans"]) != 1:
1873             ret["comment"] = (
1874                 "There are multiple usage plans with the same name - it is not"
1875                 " supported"
1876             )
1877             ret["result"] = False
1878             return ret
1879         plan = existing["plans"][0]
1880         plan_id = plan["id"]
1881         plan_stages = plan.get("apiStages", [])
1882         stages_to_add = []
1883         for api in api_stages:
1884             if api not in plan_stages:
1885                 stages_to_add.append(api)
1886         if not stages_to_add:
1887             ret["comment"] = "Usage plan is already asssociated to all api stages"
1888             return ret
1889         result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
1890             plan_id, stages_to_add, **common_args
1891         )
1892         if "error" in result:
1893             ret[
1894                 "comment"
1895             ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
1896                 plan_name, stages_to_add, result["error"]
1897             )
1898             ret["result"] = False
1899             return ret
1900         ret["comment"] = "successfully associated usage plan to apis"
1901         ret["changes"]["old"] = plan_stages
1902         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1903     except (ValueError, OSError) as e:
1904         ret["result"] = False
1905         ret["comment"] = "{}".format(e.args)
1906     return ret
1907 def usage_plan_association_absent(
1908     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1909 ):
1910     """
1911     Ensures usage plan identified by name is removed from provided api_stages
1912     If a plan is associated to stages not listed in api_stages parameter,
1913     those associations remain intact.
1914     .. versionadded:: 2017.7.0
1915     name
1916         name of the state
1917     plan_name
1918         name of the plan to use
1919     api_stages
1920         list of dictionaries, where each dictionary consists of the following keys:
1921         apiId
1922             apiId of the api to detach usage plan from
1923         stage
1924             stage name of the api to detach usage plan from
1925     .. code-block:: yaml
1926         UsagePlanAssociationAbsent:
1927           boto_apigateway.usage_plan_association_absent:
1928             - plan_name: my_plan
1929             - api_stages:
1930               - apiId: 9kb0404ec0
1931                 stage: my_stage
1932               - apiId: l9v7o2aj90
1933                 stage: my_stage
1934             - profile: my_profile
1935     """
1936     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1937     try:
1938         common_args = dict(
1939             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1940         )
1941         existing = __salt__["boto_apigateway.describe_usage_plans"](
1942             name=plan_name, **common_args
1943         )
1944         if "error" in existing:
1945             ret["result"] = False
1946             ret["comment"] = "Failed to describe existing usage plans"
1947             return ret
1948         if not existing["plans"]:
1949             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1950             ret["result"] = False
1951             return ret
1952         if len(existing["plans"]) != 1:
1953             ret["comment"] = (
1954                 "There are multiple usage plans with the same name - it is not"
1955                 " supported"
1956             )
1957             ret["result"] = False
1958             return ret
1959         plan = existing["plans"][0]
1960         plan_id = plan["id"]
1961         plan_stages = plan.get("apiStages", [])
1962         if not plan_stages:
1963             ret["comment"] = "Usage plan {} has no associated stages already".format(
1964                 plan_name
1965             )
1966             return ret
1967         stages_to_remove = []
1968         for api in api_stages:
1969             if api in plan_stages:
1970                 stages_to_remove.append(api)
1971         if not stages_to_remove:
1972             ret["comment"] = "Usage plan is already not asssociated to any api stages"
1973             return ret
1974         result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
1975             plan_id, stages_to_remove, **common_args
1976         )
1977         if "error" in result:
1978             ret[
1979                 "comment"
1980             ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
1981                 plan_name, stages_to_remove, result["error"]
1982             )
1983             ret["result"] = False
1984             return ret
1985         ret["comment"] = "successfully disassociated usage plan from apis"
1986         ret["changes"]["old"] = plan_stages
1987         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1988     except (ValueError, OSError) as e:
1989         ret["result"] = False
1990         ret["comment"] = "{}".format(e.args)
1991     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
