
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.641590800191662%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_17.py</h3>
            <pre><code>1  import binascii
2  import struct
3  import time
4  from bitstring import BitArray
5  import esptool
6  import reedsolo
7  from .mem_definition import EfuseDefineBlocks, EfuseDefineFields, EfuseDefineRegisters
8  from .. import base_fields
9  from .. import util
10  class EfuseBlock(base_fields.EfuseBlockBase):
11      def len_of_burn_unit(self):
12          return 8 * 4
13      def __init__(self, parent, param, skip_read=False):
14          parent.read_coding_scheme()
15          super(EfuseBlock, self).__init__(parent, param, skip_read=skip_read)
16      def apply_coding_scheme(self):
17          data = self.get_raw(from_read=False)[::-1]
18          if len(data) < self.len_of_burn_unit():
19              add_empty_bytes = self.len_of_burn_unit() - len(data)
20              data = data + (b"\x00" * add_empty_bytes)
21          if self.get_coding_scheme() == self.parent.REGS.CODING_SCHEME_RS:
22              rs = reedsolo.RSCodec(12)
23              encoded_data = rs.encode([x for x in data])
24              words = struct.unpack("<" + "I" * 11, encoded_data)
25          else:
26              words = struct.unpack("<" + ("I" * (len(data) // 4)), data)
27          return words
28  class EspEfuses(base_fields.EspEfusesBase):
29      debug = False
30      do_not_confirm = False
31      def __init__(self, esp, skip_connect=False, debug=False, do_not_confirm=False):
32          self.Blocks = EfuseDefineBlocks()
33          self.Fields = EfuseDefineFields()
34          self.REGS = EfuseDefineRegisters
35          self.BURN_BLOCK_DATA_NAMES = self.Blocks.get_burn_block_data_names()
36          self.BLOCKS_FOR_KEYS = self.Blocks.get_blocks_for_keys()
37          self._esp = esp
38          self.debug = debug
39          self.do_not_confirm = do_not_confirm
40          if esp.CHIP_NAME != "ESP32-C6":
41              raise esptool.FatalError(
42                  "Expected the 'esp' param for ESP32-C6 chip but got for '%s'."
43                  % (esp.CHIP_NAME)
44              )
45          if not skip_connect:
46              flags = self._esp.get_security_info()["flags"]
47              GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE = 1 << 2
48              if flags & GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE:
49                  raise esptool.FatalError(
50                      "Secure Download Mode is enabled. The tool can not read eFuses."
51                  )
52          self.blocks = [
53              EfuseBlock(self, self.Blocks.get(block), skip_read=skip_connect)
54              for block in self.Blocks.BLOCKS
55          ]
56          if not skip_connect:
57              self.get_coding_scheme_warnings()
58          self.efuses = [EfuseField.convert(self, efuse) for efuse in self.Fields.EFUSES]
59          self.efuses += [
60              EfuseField.convert(self, efuse) for efuse in self.Fields.KEYBLOCKS
61          ]
62          if skip_connect:
63              self.efuses += [
64                  EfuseField.convert(self, efuse)
65                  for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
66              ]
67          else:
68              if self["BLK_VERSION_MINOR"].get() == 1:
69                  self.efuses += [
70                      EfuseField.convert(self, efuse)
71                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
72                  ]
73              self.efuses += [
74                  EfuseField.convert(self, efuse) for efuse in self.Fields.CALC
75              ]
76      def __getitem__(self, efuse_name):
77          for e in self.efuses:
78              if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
79                  return e
80          new_fields = False
81          for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES:
82              if efuse.name == efuse_name or any(
83                  x == efuse_name for x in efuse.alt_names
84              ):
85                  self.efuses += [
86                      EfuseField.convert(self, efuse)
87                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
88                  ]
89                  new_fields = True
90          if new_fields:
91              for e in self.efuses:
92                  if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
93                      return e
94          raise KeyError
95      def read_coding_scheme(self):
96          self.coding_scheme = self.REGS.CODING_SCHEME_RS
97      def print_status_regs(self):
98          print("")
99          self.blocks[0].print_block(self.blocks[0].err_bitarray, "err__regs", debug=True)
100          print(
101              "{:27} 0x{:08x}".format(
102                  "EFUSE_RD_RS_ERR0_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR0_REG)
103              )
104          )
105          print(
106              "{:27} 0x{:08x}".format(
107                  "EFUSE_RD_RS_ERR1_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR1_REG)
108              )
109          )
110      def efuse_controller_setup(self):
111          self.set_efuse_timing()
112          self.clear_pgm_registers()
113          self.wait_efuse_idle()
114      def write_efuses(self, block):
115          self.efuse_program(block)
116          return self.get_coding_scheme_warnings(silent=True)
117      def clear_pgm_registers(self):
118          self.wait_efuse_idle()
119          for r in range(
120              self.REGS.EFUSE_PGM_DATA0_REG, self.REGS.EFUSE_PGM_DATA0_REG + 32, 4
121          ):
122              self.write_reg(r, 0)
123      def wait_efuse_idle(self):
124          deadline = time.time() + self.REGS.EFUSE_BURN_TIMEOUT
125          while time.time() < deadline:
126              if self.read_reg(self.REGS.EFUSE_STATUS_REG) & 0x7 == 1:
127                  return
128          raise esptool.FatalError(
129              "Timed out waiting for Efuse controller command to complete"
130          )
131      def efuse_program(self, block):
132          self.wait_efuse_idle()
133          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_WRITE_OP_CODE)
134          self.write_reg(self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_PGM_CMD | (block << 2))
135          self.wait_efuse_idle()
136          self.clear_pgm_registers()
137          self.efuse_read()
138      def efuse_read(self):
139          self.wait_efuse_idle()
140          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_READ_OP_CODE)
141          try:
142              self.write_reg(
143                  self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_READ_CMD, delay_after_us=1000
144              )
145              self.wait_efuse_idle()
146          except esptool.FatalError:
147              secure_download_mode_before = self._esp.secure_download_mode
148              try:
149                  self._esp = self.reconnect_chip(self._esp)
150              except esptool.FatalError:
151                  print("Can not re-connect to the chip")
152                  if not self["DIS_DOWNLOAD_MODE"].get() and self[
153                      "DIS_DOWNLOAD_MODE"
154                  ].get(from_read=False):
155                      print(
156                          "This is the correct behavior as we are actually burning "
157                          "DIS_DOWNLOAD_MODE which disables the connection to the chip"
158                      )
159                      print("DIS_DOWNLOAD_MODE is enabled")
160                      print("Successful")
161                      exit(0)  # finish without errors
162                  raise
163              print("Established a connection with the chip")
164              if self._esp.secure_download_mode and not secure_download_mode_before:
165                  print("Secure download mode is enabled")
166                  if not self["ENABLE_SECURITY_DOWNLOAD"].get() and self[
167                      "ENABLE_SECURITY_DOWNLOAD"
168                  ].get(from_read=False):
169                      print(
170                          "espefuse tool can not continue to work in Secure download mode"
171                      )
172                      print("ENABLE_SECURITY_DOWNLOAD is enabled")
173                      print("Successful")
174                      exit(0)  # finish without errors
175              raise
176      def set_efuse_timing(self):
177          apb_freq = self.get_crystal_freq()
178          if apb_freq != 40:
179              raise esptool.FatalError(
180                  "The eFuse supports only xtal=40M (xtal was %d)" % apb_freq
181              )
<span onclick='openModal()' class='match'>182          self.update_reg(self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_NUM_M, 0xFF)
183          self.update_reg(
184              self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_CLK_DIV_M, 0x28
185          )
186          self.update_reg(
187              self.REGS.EFUSE_WR_TIM_CONF1_REG, self.REGS.EFUSE_PWR_ON_NUM_M, 0x3000
</span>188          )
189          self.update_reg(
190              self.REGS.EFUSE_WR_TIM_CONF2_REG, self.REGS.EFUSE_PWR_OFF_NUM_M, 0x190
191          )
192      def get_coding_scheme_warnings(self, silent=False):
193          old_addr_reg = 0
194          reg_value = 0
195          ret_fail = False
196          for block in self.blocks:
197              if block.id == 0:
198                  words = [
199                      self.read_reg(self.REGS.EFUSE_RD_REPEAT_ERR0_REG + offs * 4)
200                      for offs in range(5)
201                  ]
202                  block.err_bitarray.pos = 0
203                  for word in reversed(words):
204                      block.err_bitarray.overwrite(BitArray("uint:32=%d" % word))
205                  block.num_errors = block.err_bitarray.count(True)
206                  block.fail = block.num_errors != 0
207              else:
208                  addr_reg, err_num_mask, err_num_offs, fail_bit = self.REGS.BLOCK_ERRORS[
209                      block.id
210                  ]
211                  if err_num_mask is None or err_num_offs is None or fail_bit is None:
212                      continue
213                  if addr_reg != old_addr_reg:
214                      old_addr_reg = addr_reg
215                      reg_value = self.read_reg(addr_reg)
216                  block.fail = reg_value & (1 << fail_bit) != 0
217                  block.num_errors = (reg_value >> err_num_offs) & err_num_mask
218              ret_fail |= block.fail
219              if not silent and (block.fail or block.num_errors):
220                  print(
221                      "Error(s) in BLOCK%d [ERRORS:%d FAIL:%d]"
222                      % (block.id, block.num_errors, block.fail)
223                  )
224          if (self.debug or ret_fail) and not silent:
225              self.print_status_regs()
226          return ret_fail
227      def summary(self):
228          return ""
229  class EfuseField(base_fields.EfuseFieldBase):
230      @staticmethod
231      def convert(parent, efuse):
232          return {
233              "mac": EfuseMacField,
234              "keypurpose": EfuseKeyPurposeField,
235              "t_sensor": EfuseTempSensor,
236              "adc_tp": EfuseAdcPointCalibration,
237              "wafer": EfuseWafer,
238          }.get(efuse.class_type, EfuseField)(parent, efuse)
239  class EfuseWafer(EfuseField):
240      def get(self, from_read=True):
241          hi_bits = self.parent["WAFER_VERSION_MINOR_HI"].get(from_read)
242          assert self.parent["WAFER_VERSION_MINOR_HI"].bit_len == 1
243          lo_bits = self.parent["WAFER_VERSION_MINOR_LO"].get(from_read)
244          assert self.parent["WAFER_VERSION_MINOR_LO"].bit_len == 3
245          return (hi_bits << 3) + lo_bits
246      def save(self, new_value):
247          raise esptool.FatalError("Burning %s is not supported" % self.name)
248  class EfuseTempSensor(EfuseField):
249      def get(self, from_read=True):
250          value = self.get_bitstring(from_read)
251          sig = -1 if value[0] else 1
252          return sig * value[1:].uint * 0.1
253  class EfuseAdcPointCalibration(EfuseField):
254      def get(self, from_read=True):
255          STEP_SIZE = 4
256          value = self.get_bitstring(from_read)
257          sig = -1 if value[0] else 1
258          return sig * value[1:].uint * STEP_SIZE
259  class EfuseMacField(EfuseField):
260      def check_format(self, new_value_str):
261          if new_value_str is None:
262              raise esptool.FatalError(
263                  "Required MAC Address in AA:CD:EF:01:02:03 format!"
264              )
265          if new_value_str.count(":") != 5:
266              raise esptool.FatalError(
267                  "MAC Address needs to be a 6-byte hexadecimal format "
268                  "separated by colons (:)!"
269              )
270          hexad = new_value_str.replace(":", "")
271          if len(hexad) != 12:
272              raise esptool.FatalError(
273                  "MAC Address needs to be a 6-byte hexadecimal number "
274                  "(12 hexadecimal characters)!"
275              )
276          bindata = binascii.unhexlify(hexad)
277          if esptool.util.byte(bindata, 0) & 0x01:
278              raise esptool.FatalError("Custom MAC must be a unicast MAC!")
279          return bindata
280      def check(self):
281          errs, fail = self.parent.get_block_errors(self.block)
282          if errs != 0 or fail:
283              output = "Block%d has ERRORS:%d FAIL:%d" % (self.block, errs, fail)
284          else:
285              output = "OK"
286          return "(" + output + ")"
287      def get(self, from_read=True):
288          if self.name == "CUSTOM_MAC":
289              mac = self.get_raw(from_read)[::-1]
290          else:
291              mac = self.get_raw(from_read)
292          return "%s %s" % (util.hexify(mac, ":"), self.check())
293      def save(self, new_value):
294          def print_field(e, new_value):
295              print(
296                  "    - '{}' ({}) {} -> {}".format(
297                      e.name, e.description, e.get_bitstring(), new_value
298                  )
299              )
300          if self.name == "CUSTOM_MAC":
301              bitarray_mac = self.convert_to_bitstring(new_value)
302              print_field(self, bitarray_mac)
303              super(EfuseMacField, self).save(new_value)
304          else:
305              raise esptool.FatalError("Writing Factory MAC address is not supported")
306  class EfuseKeyPurposeField(EfuseField):
307      KEY_PURPOSES = [
308          ("USER",                         0,  None,       None,      "no_need_rd_protect"),   # User purposes (software-only use)
309          ("RESERVED",                     1,  None,       None,      "no_need_rd_protect"),   # Reserved
310          ("XTS_AES_128_KEY",              4,  None,       "Reverse", "need_rd_protect"),      # XTS_AES_128_KEY (flash/PSRAM encryption)
311          ("HMAC_DOWN_ALL",                5,  None,       None,      "need_rd_protect"),      # HMAC Downstream mode
312          ("HMAC_DOWN_JTAG",               6,  None,       None,      "need_rd_protect"),      # JTAG soft enable key (uses HMAC Downstream mode)
313          ("HMAC_DOWN_DIGITAL_SIGNATURE",  7,  None,       None,      "need_rd_protect"),      # Digital Signature peripheral key (uses HMAC Downstream mode)
314          ("HMAC_UP",                      8,  None,       None,      "need_rd_protect"),      # HMAC Upstream mode
315          ("SECURE_BOOT_DIGEST0",          9,  "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST0 (Secure Boot key digest)
316          ("SECURE_BOOT_DIGEST1",          10, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST1 (Secure Boot key digest)
317          ("SECURE_BOOT_DIGEST2",          11, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST2 (Secure Boot key digest)
318      ]
319      KEY_PURPOSES_NAME = [name[0] for name in KEY_PURPOSES]
320      DIGEST_KEY_PURPOSES = [name[0] for name in KEY_PURPOSES if name[2] == "DIGEST"]
321      def check_format(self, new_value_str):
322          raw_val = new_value_str
323          for purpose_name in self.KEY_PURPOSES:
324              if purpose_name[0] == new_value_str:
325                  raw_val = str(purpose_name[1])
326                  break
327          if raw_val.isdigit():
328              if int(raw_val) not in [p[1] for p in self.KEY_PURPOSES if p[1] > 0]:
329                  raise esptool.FatalError("'%s' can not be set (value out of range)" % raw_val)
330          else:
331              raise esptool.FatalError("'%s' unknown name" % raw_val)
332          return raw_val
333      def need_reverse(self, new_key_purpose):
334          for key in self.KEY_PURPOSES:
335              if key[0] == new_key_purpose:
336                  return key[3] == "Reverse"
337      def need_rd_protect(self, new_key_purpose):
338          for key in self.KEY_PURPOSES:
339              if key[0] == new_key_purpose:
340                  return key[4] == "need_rd_protect"
341      def get(self, from_read=True):
342          for p in self.KEY_PURPOSES:
343              if p[1] == self.get_raw(from_read):
344                  return p[0]
345          return "FORBIDDEN_STATE"
346      def get_name(self, raw_val):
347          for key in self.KEY_PURPOSES:
348              if key[1] == raw_val:
349                  return key[0]
350      def save(self, new_value):
351          raw_val = int(self.check_format(str(new_value)))
352          str_new_value = self.get_name(raw_val)
353          if self.name == "KEY_PURPOSE_5" and str_new_value.startswith("XTS_AES"):
354              raise esptool.FatalError(f"{self.name} can not have {str_new_value} key due to a hardware bug (please see TRM for more details)")
355          return super(EfuseKeyPurposeField, self).save(raw_val)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</h3>
            <pre><code>1  import binascii
2  import sys
3  from bitstring import BitArray, BitStream, CreationError
4  import esptool
5  from . import util
6  class CheckArgValue(object):
7      def __init__(self, efuses, name):
8          self.efuses = efuses
9          self.name = name
10      def __call__(self, new_value_str):
11          def check_arg_value(efuse, new_value):
12              if efuse.efuse_type.startswith("bool"):
13                  new_value = 1 if new_value is None else int(new_value, 0)
14                  if new_value != 1:
15                      raise esptool.FatalError(
16                          "New value is not accepted for efuse '{}' "
17                          "(will always burn 0->1), given value={}".format(
18                              efuse.name, new_value
19                          )
20                      )
21              elif efuse.efuse_type.startswith(("int", "uint")):
22                  if efuse.efuse_class == "bitcount":
23                      if new_value is None:
24                          old_value = efuse.get_raw()
25                          new_value = old_value
26                          bit = 1
27                          while new_value == old_value:
28                              new_value = bit | old_value
29                              bit <<= 1
30                      else:
31                          new_value = int(new_value, 0)
32                  else:
33                      if new_value is None:
34                          raise esptool.FatalError(
35                              "New value required for efuse '{}' (given None)".format(
36                                  efuse.name
37                              )
38                          )
39                      new_value = int(new_value, 0)
40                      if new_value == 0:
41                          raise esptool.FatalError(
42                              "New value should not be 0 for '{}' "
43                              "(given value= {})".format(efuse.name, new_value)
44                          )
45              elif efuse.efuse_type.startswith("bytes"):
46                  if new_value is None:
47                      raise esptool.FatalError(
48                          "New value required for efuse '{}' "
49                          "(given None)".format(efuse.name)
50                      )
51                  if len(new_value) * 8 != efuse.bitarray.len:
52                      raise esptool.FatalError(
53                          "The length of efuse '{}' ({} bits) "
54                          "(given len of the new value= {} bits)".format(
55                              efuse.name, efuse.bitarray.len, len(new_value) * 8
56                          )
57                      )
58              else:
59                  raise esptool.FatalError(
60                      "The '{}' type for the '{}' efuse is not supported yet.".format(
61                          efuse.efuse_type, efuse.name
62                      )
63                  )
64              return new_value
65          efuse = self.efuses[self.name]
66          new_value = efuse.check_format(new_value_str)
67          return check_arg_value(efuse, new_value)
68  class EfuseProtectBase(object):
69      def get_read_disable_mask(self, blk_part=None):
70          mask = 0
71          if isinstance(self.read_disable_bit, list):
72              if blk_part is None:
73                  for i in self.read_disable_bit:
74                      mask |= 1 << i
75              else:
76                  mask |= 1 << self.read_disable_bit[blk_part]
77          else:
78              mask = 1 << self.read_disable_bit
79          return mask
80      def get_count_read_disable_bits(self):
81          return bin(self.get_read_disable_mask()).count("1")
82      def is_readable(self, blk_part=None):
83          num_bit = self.read_disable_bit
84          if num_bit is None:
85              return True  # read cannot be disabled
86          return (self.parent["RD_DIS"].get() & self.get_read_disable_mask(blk_part)) == 0
87      def disable_read(self):
88          num_bit = self.read_disable_bit
89          if num_bit is None:
90              raise esptool.FatalError("This efuse cannot be read-disabled")
91          if not self.parent["RD_DIS"].is_writeable():
92              raise esptool.FatalError(
93                  "This efuse cannot be read-disabled due the to RD_DIS field is "
94                  "already write-disabled"
95              )
96          self.parent["RD_DIS"].save(self.get_read_disable_mask())
97      def is_writeable(self):
98          num_bit = self.write_disable_bit
99          if num_bit is None:
100              return True  # write cannot be disabled
101          return (self.parent["WR_DIS"].get() & (1 << num_bit)) == 0
102      def disable_write(self):
103          num_bit = self.write_disable_bit
104          if not self.parent["WR_DIS"].is_writeable():
105              raise esptool.FatalError(
106                  "This efuse cannot be write-disabled due to the WR_DIS field is "
107                  "already write-disabled"
108              )
109          self.parent["WR_DIS"].save(1 << num_bit)
110      def check_wr_rd_protect(self):
111          if not self.is_readable():
112              error_msg = "\t{} is read-protected.".format(self.name)
113              "The written value can not be read, the efuse/block looks as all 0.\n"
114              error_msg += "\tBurn in this case may damage an already written value."
115              self.parent.print_error_msg(error_msg)
116          if not self.is_writeable():
117              error_msg = "\t{} is write-protected. Burn is not possible.".format(
118                  self.name
119              )
120              self.parent.print_error_msg(error_msg)
121  class EfuseBlockBase(EfuseProtectBase):
122      def __init__(self, parent, param, skip_read=False):
123          self.parent = parent
124          self.name = param.name
125          self.alias = param.alias
126          self.id = param.id
127          self.rd_addr = param.rd_addr
128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
131          self.len = param.len
132          self.key_purpose_name = param.key_purpose
133          bit_block_len = self.get_block_len() * 8
134          self.bitarray = BitStream(bit_block_len)
135          self.bitarray.set(0)
136          self.wr_bitarray = BitStream(bit_block_len)
137          self.wr_bitarray.set(0)
138          self.fail = False
139          self.num_errors = 0
140          if self.id == 0:
141              self.err_bitarray = BitStream(bit_block_len)
142              self.err_bitarray.set(0)
143          else:
144              self.err_bitarray = None
145          if not skip_read:
146              self.read()
147      def get_block_len(self):
148          coding_scheme = self.get_coding_scheme()
149          if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
150              return self.len * 4
151          elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
152              return (self.len * 3 // 4) * 4
153          elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
154              return self.len * 4
155          else:
156              raise esptool.FatalError(
157                  "Coding scheme (%d) not supported" % (coding_scheme)
158              )
159      def get_coding_scheme(self):
160          if self.id == 0:
161              return self.parent.REGS.CODING_SCHEME_NONE
162          else:
163              return self.parent.coding_scheme
164      def get_raw(self, from_read=True):
165          if from_read:
166              return self.bitarray.bytes
167          else:
168              return self.wr_bitarray.bytes
169      def get(self, from_read=True):
170          self.get_bitstring(from_read=from_read)
171      def get_bitstring(self, from_read=True):
172          if from_read:
173              return self.bitarray
174          else:
175              return self.wr_bitarray
176      def convert_to_bitstring(self, new_data):
177          if isinstance(new_data, BitArray):
178              return new_data
179          else:
180              return BitArray(bytes=new_data, length=len(new_data) * 8)
181      def get_words(self):
182          def get_offsets(self):
183              return [x + self.rd_addr for x in range(0, self.get_block_len(), 4)]
184          return [self.parent.read_reg(offs) for offs in get_offsets(self)]
185      def read(self):
186          words = self.get_words()
187          data = BitArray()
188          for word in reversed(words):
189              data.append("uint:32=%d" % word)
190          self.bitarray.overwrite(data, pos=0)
191          self.print_block(self.bitarray, "read_regs")
192      def print_block(self, bit_string, comment, debug=False):
193          if self.parent.debug or debug:
194              bit_string.pos = 0
195              print(
196                  "%-15s (%-16s) [%-2d] %s:"
197                  % (self.name, " ".join(self.alias)[:16], self.id, comment),
198                  " ".join(
199                      [
200                          "%08x" % word
201                          for word in bit_string.readlist(
202                              "%d*uint:32" % (bit_string.len / 32)
203                          )[::-1]
204                      ]
205                  ),
206              )
207      def check_wr_data(self):
208          wr_data = self.wr_bitarray
209          if wr_data.all(False):
210              if self.parent.debug:
211                  print("[{:02}] {:20} nothing to burn".format(self.id, self.name))
212              return False
213          if len(wr_data.bytes) != len(self.bitarray.bytes):
214              raise esptool.FatalError(
215                  "Data does not fit: the block%d size is %d bytes, data is %d bytes"
216                  % (self.id, len(self.bitarray.bytes), len(wr_data.bytes))
217              )
218          self.check_wr_rd_protect()
219          if self.get_bitstring().all(False):
220              print(
221                  "[{:02}] {:20} is empty, will burn the new value".format(
222                      self.id, self.name
223                  )
224              )
225          else:
226              if self.get_bitstring() == wr_data:
227                  print(
228                      "[{:02}] {:20} is already written the same value, "
229                      "continue with EMPTY_BLOCK".format(self.id, self.name)
230                  )
231                  wr_data.set(0)
232              else:
233                  print("[{:02}] {:20} is not empty".format(self.id, self.name))
234                  print("\t(written ):", self.get_bitstring())
235                  print("\t(to write):", wr_data)
236                  mask = self.get_bitstring() & wr_data
237                  if mask == wr_data:
238                      print(
239                          "\tAll wr_data bits are set in the written block, "
240                          "continue with EMPTY_BLOCK."
241                      )
242                      wr_data.set(0)
243                  else:
244                      coding_scheme = self.get_coding_scheme()
245                      if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
246                          print("\t(coding scheme = NONE)")
247                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
248                          print("\t(coding scheme = RS)")
249                          error_msg = (
250                              "\tBurn into %s is forbidden "
251                              "(RS coding scheme does not allow this)." % (self.name)
252                          )
253                          self.parent.print_error_msg(error_msg)
254                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
255                          print("\t(coding scheme = 3/4)")
256                          data_can_not_be_burn = False
257                          for i in range(0, self.get_bitstring().len, 6 * 8):
258                              rd_chunk = self.get_bitstring()[i : i + 6 * 8 :]
259                              wr_chunk = wr_data[i : i + 6 * 8 :]
260                              if rd_chunk.any(True):
261                                  if wr_chunk.any(True):
262                                      print(
263                                          "\twritten chunk [%d] and wr_chunk "
264                                          "are not empty. " % (i // (6 * 8)),
265                                          end="",
266                                      )
267                                      if rd_chunk == wr_chunk:
268                                          print(
269                                              "wr_chunk == rd_chunk. "
270                                              "Countinue with empty chunk."
271                                          )
272                                          wr_data[i : i + 6 * 8 :].set(0)
273                                      else:
274                                          print("wr_chunk != rd_chunk. Can not burn.")
275                                          print("\twritten ", rd_chunk)
276                                          print("\tto write", wr_chunk)
277                                          data_can_not_be_burn = True
278                          if data_can_not_be_burn:
279                              error_msg = (
280                                  "\tBurn into %s is forbidden "
281                                  "(3/4 coding scheme does not allow this)." % (self.name)
282                              )
283                              self.parent.print_error_msg(error_msg)
284                      else:
285                          raise esptool.FatalError(
286                              "The coding scheme ({}) is not supported".format(
287                                  coding_scheme
288                              )
289                          )
290      def save(self, new_data):
291          data = BitStream(bytes=new_data[::-1], length=len(new_data) * 8)
292          if self.parent.debug:
293              print(
294                  "\twritten : {} ->\n\tto write: {}".format(self.get_bitstring(), data)
295              )
296          self.wr_bitarray.overwrite(self.wr_bitarray | data, pos=0)
297      def burn_words(self, words):
298          for burns in range(3):
299              self.parent.efuse_controller_setup()
300              if self.parent.debug:
301                  print("Write data to BLOCK%d" % (self.id))
302              write_reg_addr = self.wr_addr
303              for word in words:
304                  if self.parent.debug:
305                      print("Addr 0x%08x, data=0x%08x" % (write_reg_addr, word))
306                  self.parent.write_reg(write_reg_addr, word)
307                  write_reg_addr += 4
308              self.parent.write_efuses(self.id)
309              for _ in range(5):
310                  self.parent.efuse_read()
311                  self.parent.get_coding_scheme_warnings(silent=True)
312                  if self.fail or self.num_errors:
313                      print(
314                          "Error in BLOCK%d, re-burn it again (#%d), to fix it. "
315                          "fail_bit=%d, num_errors=%d"
316                          % (self.id, burns, self.fail, self.num_errors)
317                      )
318                      break
319              if not self.fail and self.num_errors == 0:
320                  break
321      def burn(self):
322          if self.wr_bitarray.all(False):
323              return
324          before_burn_bitarray = self.bitarray[:]
325          assert before_burn_bitarray is not self.bitarray
326          self.print_block(self.wr_bitarray, "to_write")
327          words = self.apply_coding_scheme()
328          self.burn_words(words)
329          self.read()
330          if not self.is_readable():
331              print(
332                  "{} ({}) is read-protected. "
333                  "Read back the burn value is not possible.".format(
334                      self.name, self.alias
335                  )
336              )
337              if self.bitarray.all(False):
338                  print("Read all '0'")
339              else:
340                  raise esptool.FatalError(
341                      "The {} is read-protected but not all '0' ({})".format(
342                          self.name, self.bitarray.hex
343                      )
344                  )
345          else:
<span onclick='openModal()' class='match'>346              if self.wr_bitarray == self.bitarray:
347                  print("BURN BLOCK%-2d - OK (write block == read block)" % self.id)
348              elif (
349                  self.wr_bitarray & self.bitarray == self.wr_bitarray
350                  and self.bitarray & before_burn_bitarray == before_burn_bitarray
351              ):
352                  print("BURN BLOCK%-2d - OK (all write block bits are set)" % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, "Expected")
</span>355                  self.print_block(self.bitarray, "Real    ")
356                  if self.id != 0:
357                      raise esptool.FatalError(
358                          "Burn {} ({}) was not successful".format(self.name, self.alias)
359                      )
360          self.wr_bitarray.set(0)
361  class EspEfusesBase(object):
362      _esp = None
363      blocks = []
364      efuses = []
365      coding_scheme = None
366      force_write_always = None
367      batch_mode_cnt = 0
368      def __iter__(self):
369          return self.efuses.__iter__()
370      def get_crystal_freq(self):
371          return self._esp.get_crystal_freq()
372      def read_efuse(self, n):
373          return self._esp.read_efuse(n)
374      def read_reg(self, addr):
375          return self._esp.read_reg(addr)
376      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
377          return self._esp.write_reg(addr, value, mask, delay_us, delay_after_us)
378      def update_reg(self, addr, mask, new_val):
379          return self._esp.update_reg(addr, mask, new_val)
380      def efuse_controller_setup(self):
381          pass
382      def reconnect_chip(self, esp):
383          print("Re-connecting...")
384          baudrate = esp._port.baudrate
385          port = esp._port.port
386          esp._port.close()
387          return esptool.cmds.detect_chip(port, baudrate)
388      def get_index_block_by_name(self, name):
389          for block in self.blocks:
390              if block.name == name or name in block.alias:
391                  return block.id
392          return None
393      def read_blocks(self):
394          for block in self.blocks:
395              block.read()
396      def update_efuses(self):
397          for efuse in self.efuses:
398              efuse.update(self.blocks[efuse.block].bitarray)
399      def burn_all(self, check_batch_mode=False):
400          if check_batch_mode:
401              if self.batch_mode_cnt != 0:
402                  print(
403                      "\nBatch mode is enabled, "
404                      "the burn will be done at the end of the command."
405                  )
406                  return False
407          print("\nCheck all blocks for burn...")
408          print("idx, BLOCK_NAME,          Conclusion")
409          have_wr_data_for_burn = False
410          for block in self.blocks:
411              block.check_wr_data()
412              if not have_wr_data_for_burn and block.get_bitstring(from_read=False).any(
413                  True
414              ):
415                  have_wr_data_for_burn = True
416          if not have_wr_data_for_burn:
417              print("Nothing to burn, see messages above.")
418              return
419          EspEfusesBase.confirm("", self.do_not_confirm)
420          for block in reversed(self.blocks):
421              old_fail = block.fail
422              old_num_errors = block.num_errors
423              block.burn()
424              if (block.fail and old_fail != block.fail) or (
425                  block.num_errors and block.num_errors > old_num_errors
426              ):
427                  raise esptool.FatalError("Error(s) were detected in eFuses")
428          print("Reading updated efuses...")
429          self.read_coding_scheme()
430          self.read_blocks()
431          self.update_efuses()
432          return True
433      @staticmethod
434      def confirm(action, do_not_confirm):
435          print(
436              "%s%s\nThis is an irreversible operation!"
437              % (action, "" if action.endswith("\n") else ". ")
438          )
439          if not do_not_confirm:
440              print("Type 'BURN' (all capitals) to continue.")
441              sys.stdout.flush()
442              yes = input()
443              if yes != "BURN":
444                  print("Aborting.")
445                  sys.exit(0)
446      def print_error_msg(self, error_msg):
447          if self.force_write_always is not None:
448              if not self.force_write_always:
449                  error_msg += "(use '--force-write-always' option to ignore it)"
450          if self.force_write_always:
451              print(error_msg, "Skipped because '--force-write-always' option.")
452          else:
453              raise esptool.FatalError(error_msg)
454      def get_block_errors(self, block_num):
455          return self.blocks[block_num].num_errors, self.blocks[block_num].fail
456  class EfuseFieldBase(EfuseProtectBase):
457      def __init__(self, parent, param):
458          self.category = param.category
459          self.parent = parent
460          self.block = param.block
461          self.word = param.word
462          self.pos = param.pos
463          self.write_disable_bit = param.write_disable_bit
464          self.read_disable_bit = param.read_disable_bit
465          self.name = param.name
466          self.efuse_class = param.class_type
467          self.efuse_type = param.type
468          self.description = param.description
469          self.dict_value = param.dictionary
470          self.bit_len = param.bit_len
471          self.alt_names = param.alt_names
472          self.fail = False
473          self.num_errors = 0
474          self.bitarray = BitStream(self.bit_len)
475          self.bitarray.set(0)
476          self.update(self.parent.blocks[self.block].bitarray)
477      def check_format(self, new_value_str):
478          if new_value_str is None:
479              return new_value_str
480          else:
481              if self.efuse_type.startswith("bytes"):
482                  if new_value_str.startswith("0x"):
483                      return binascii.unhexlify(new_value_str[2:])[::-1]
484                  else:
485                      return binascii.unhexlify(new_value_str)
486              else:
487                  return new_value_str
488      def convert_to_bitstring(self, new_value):
489          if isinstance(new_value, BitArray):
490              return new_value
491          else:
492              if self.efuse_type.startswith("bytes"):
493                  return BitArray(bytes=new_value[::-1], length=len(new_value) * 8)
494              else:
495                  try:
496                      return BitArray(self.efuse_type + "={}".format(new_value))
497                  except CreationError as err:
498                      print(
499                          "New value '{}' is not suitable for {} ({})".format(
500                              new_value, self.name, self.efuse_type
501                          )
502                      )
503                      raise esptool.FatalError(err)
504      def check_new_value(self, bitarray_new_value):
505          bitarray_old_value = self.get_bitstring() | self.get_bitstring(from_read=False)
506          if bitarray_new_value.len != bitarray_old_value.len:
507              raise esptool.FatalError(
508                  "For {} efuse, the length of the new value is wrong, "
509                  "expected {} bits, was {} bits.".format(
510                      self.name, bitarray_old_value.len, bitarray_new_value.len
511                  )
512              )
513          if bitarray_new_value == bitarray_old_value:
514              error_msg = "\tThe same value for {} ".format(self.name)
515              error_msg += "is already burned. Do not change the efuse."
516              print(error_msg)
517              bitarray_new_value.set(0)
518          elif bitarray_new_value == self.get_bitstring(from_read=False):
519              error_msg = "\tThe same value for {} ".format(self.name)
520              error_msg += "is already prepared for the burn operation."
521              print(error_msg)
522              bitarray_new_value.set(0)
523          else:
524              if self.name not in ["WR_DIS", "RD_DIS"]:
525                  if bitarray_new_value | bitarray_old_value != bitarray_new_value:
526                      error_msg = "\tNew value contains some bits that cannot be cleared "
527                      error_msg += "(value will be {})".format(
528                          bitarray_old_value | bitarray_new_value
529                      )
530                      self.parent.print_error_msg(error_msg)
531              self.check_wr_rd_protect()
532      def save_to_block(self, bitarray_field):
533          block = self.parent.blocks[self.block]
534          wr_bitarray_temp = block.wr_bitarray.copy()
535          position = wr_bitarray_temp.length - (
536              self.word * 32 + self.pos + bitarray_field.len
537          )
538          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
539          block.wr_bitarray |= wr_bitarray_temp
540      def save(self, new_value):
541          bitarray_field = self.convert_to_bitstring(new_value)
542          self.check_new_value(bitarray_field)
543          self.save_to_block(bitarray_field)
544      def update(self, bit_array_block):
545          if self.word is None or self.pos is None:
546              self.bitarray.overwrite(self.convert_to_bitstring(self.get()), pos=0)
547              return
548          field_len = self.bitarray.len
549          bit_array_block.pos = bit_array_block.length - (
550              self.word * 32 + self.pos + field_len
551          )
552          self.bitarray.overwrite(bit_array_block.read(field_len), pos=0)
553          err_bitarray = self.parent.blocks[self.block].err_bitarray
554          if err_bitarray is not None:
555              err_bitarray.pos = err_bitarray.length - (
556                  self.word * 32 + self.pos + field_len
557              )
558              self.fail = not err_bitarray.read(field_len).all(False)
559          else:
560              self.fail = self.parent.blocks[self.block].fail
561              self.num_errors = self.parent.blocks[self.block].num_errors
562      def get_raw(self, from_read=True):
563          return self.get_bitstring(from_read).read(self.efuse_type)
564      def get(self, from_read=True):
565          if self.efuse_type.startswith("bytes"):
566              return util.hexify(self.get_bitstring(from_read).bytes[::-1], " ")
567          else:
568              return self.get_raw(from_read)
569      def get_meaning(self, from_read=True):
570          if self.dict_value:
571              try:
572                  return self.dict_value[self.get_raw(from_read)]
573              except KeyError:
574                  pass
575          return self.get(from_read)
576      def get_bitstring(self, from_read=True):
577          if from_read:
578              self.bitarray.pos = 0
579              return self.bitarray
580          else:
581              field_len = self.bitarray.len
582              block = self.parent.blocks[self.block]
583              block.wr_bitarray.pos = block.wr_bitarray.length - (
584                  self.word * 32 + self.pos + field_len
585              )
586              return block.wr_bitarray.read(self.bitarray.len)
587      def burn(self, new_value):
588          self.save(new_value)
589          self.parent.burn_all()
590      def get_info(self):
591          output = f"{self.name} (BLOCK{self.block})"
592          if self.block == 0:
593              if self.fail:
594                  output += "[error]"
595          else:
596              errs, fail = self.parent.get_block_errors(self.block)
597              if errs != 0 or fail:
598                  output += "[error]"
599          if self.efuse_class == "keyblock":
600              name = self.parent.blocks[self.block].key_purpose_name
601              if name is not None:
602                  output += f"\n  Purpose: {self.parent[name].get()}\n "
603          return output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_17.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</div>
                </div>
                <div class="column column_space"><pre><code>182          self.update_reg(self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_NUM_M, 0xFF)
183          self.update_reg(
184              self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_CLK_DIV_M, 0x28
185          )
186          self.update_reg(
187              self.REGS.EFUSE_WR_TIM_CONF1_REG, self.REGS.EFUSE_PWR_ON_NUM_M, 0x3000
</pre></code></div>
                <div class="column column_space"><pre><code>346              if self.wr_bitarray == self.bitarray:
347                  print("BURN BLOCK%-2d - OK (write block == read block)" % self.id)
348              elif (
349                  self.wr_bitarray & self.bitarray == self.wr_bitarray
350                  and self.bitarray & before_burn_bitarray == before_burn_bitarray
351              ):
352                  print("BURN BLOCK%-2d - OK (all write block bits are set)" % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, "Expected")
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    