<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for spankbang.py &amp; srgssr.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for spankbang.py &amp; srgssr.py
      </h3>
<h1 align="center">
        8.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>spankbang.py (9.313725%)<th>srgssr.py (7.949791%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(28-74)<td><a href="#" name="0">(197-249)</a><td align="center"><font color="#ff0000">19</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>spankbang.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from .common import InfoExtractor
4 from ..utils import (
5     determine_ext,
6     ExtractorError,
7     merge_dicts,
8     parse_duration,
9     parse_resolution,
10     str_to_int,
11     url_or_none,
12     urlencode_postdata,
13     urljoin,
14 )
15 class SpankBangIE(InfoExtractor):
16     _VALID_URL = r'''(?x)
17                     https?://
18                         (?:[^/]+\.)?spankbang\.com/
19                         (?:
20                             (?P&lt;id&gt;[\da-z]+)/(?:video|play|embed)\b|
21                         )
22                     '''
23     _TESTS = [<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
24         'url': 'http://spankbang.com/3vvn/video/fantasy+solo',
25         'md5': '1cc433e1d6aa14bc376535b8679302f7',
26         'info_dict': {
27             'id': '3vvn',
28             'ext': 'mp4',
29             'title': 'fantasy solo',
30             'description': 'dillion harper masturbates on a bed',
31             'thumbnail': r're:^https?://.*\.jpg$',
32             'uploader': 'silly2587',
33             'timestamp': 1422571989,
34             'upload_date': '20150129',
35             'age_limit': 18,
36         }
37     }, {
38         'url': 'http://spankbang.com/1vt0/video/solvane+gangbang',
39         'only_matching': True,
40     }, {
41         'url': 'http://spankbang.com/lklg/video/sex+with+anyone+wedding+edition+2',
42         'only_matching': True,
43     }, {
44         'url': 'http://m.spankbang.com/1o2de/video/can+t+remember+her+name',
45         'only_matching': True,
46     }, {
47         'url': 'https://spankbang.com/1vwqx/video/jade+kush+solo+4k',
48         'only_matching': True,
49     }, {
50         'url': 'https://m.spankbang.com/3vvn/play/fantasy+solo/480p/',
51         'only_matching': True,
52     }, {
53         'url': 'https://m.spankbang.com/3vvn/play',
54         'only_matching': True,
55     }, {
56         'url': 'https://spankbang.com/2y3td/embed/',
57         'only_matching': True,
58     }, {
59         'url': 'https://spankbang.com/2v7ik-7ecbgu/playlist/latina+booty',
60         'only_matching': True,
61     }]
62     def _real_extract(self, url):
63         mobj = re.match(self._VALID_URL, url)
64         video_id = mobj.group(</b></font>'id') or mobj.group('id_2')
65         webpage = self._download_webpage(
66             url.replace('/%s/embed' % video_id, '/%s/video' % video_id),
67             video_id, headers={'Cookie': 'country=US'})
68         if re.search(r'&lt;[^&gt;]+\b(?:id|class)=["\']video_removed', webpage):
69             raise ExtractorError(
70                 'Video %s is not available' % video_id, expected=True)
71         formats = []
72         def extract_format(format_id, format_url):
73             f_url = url_or_none(format_url)
74             if not f_url:
75                 return
76             f = parse_resolution(format_id)
77             ext = determine_ext(f_url)
78             if format_id.startswith('m3u8') or ext == 'm3u8':
79                 formats.extend(self._extract_m3u8_formats(
80                     f_url, video_id, 'mp4', entry_protocol='m3u8_native',
81                     m3u8_id='hls', fatal=False))
82             elif format_id.startswith('mpd') or ext == 'mpd':
83                 formats.extend(self._extract_mpd_formats(
84                     f_url, video_id, mpd_id='dash', fatal=False))
85             elif ext == 'mp4' or f.get('width') or f.get('height'):
86                 f.update({
87                     'url': f_url,
88                     'format_id': format_id,
89                 })
90                 formats.append(f)
91         STREAM_URL_PREFIX = 'stream_url_'
92         for mobj in re.finditer(
93                 r'%s(?P&lt;id&gt;[^\s=]+)\s*=\s*(["\'])(?P&lt;url&gt;(?:(?!\2).)+)\2'
94                 % STREAM_URL_PREFIX, webpage):
95             extract_format(mobj.group('id', 'url'))
96         if not formats:
97             stream_key = self._search_regex(
98                 r'data-streamkey\s*=\s*(["\'])(?P&lt;value&gt;(?:(?!\1).)+)\1',
99                 webpage, 'stream key', group='value')
100             stream = self._download_json(
101                 'https://spankbang.com/api/videos/stream', video_id,
102                 'Downloading stream JSON', data=urlencode_postdata({
103                     'id': stream_key,
104                     'data': 0,
105                 }), headers={
106                     'Referer': url,
107                     'X-Requested-With': 'XMLHttpRequest',
108                 })
109             for format_id, format_url in stream.items():
110                 if format_url and isinstance(format_url, list):
111                     format_url = format_url[0]
112                 extract_format(format_id, format_url)
113         self._sort_formats(formats, field_preference=('preference', 'height', 'width', 'fps', 'tbr', 'format_id'))
114         info = self._search_json_ld(webpage, video_id, default={})
115         title = self._html_search_regex(
116             r'(?s)&lt;h1[^&gt;]*&gt;(.+?)&lt;/h1&gt;', webpage, 'title', default=None)
117         description = self._search_regex(
118             r'&lt;div[^&gt;]+\bclass=["\']bottom[^&gt;]+&gt;\s*&lt;p&gt;[^&lt;]*&lt;/p&gt;\s*&lt;p&gt;([^&lt;]+)',
119             webpage, 'description', default=None)
120         thumbnail = self._og_search_thumbnail(webpage, default=None)
121         uploader = self._html_search_regex(
122             (r'(?s)&lt;li[^&gt;]+class=["\']profile[^&gt;]+&gt;(.+?)&lt;/a&gt;',
123              r'class="user"[^&gt;]*&gt;&lt;img[^&gt;]+&gt;([^&lt;]+)'),
124             webpage, 'uploader', default=None)
125         duration = parse_duration(self._search_regex(
126             r'&lt;div[^&gt;]+\bclass=["\']right_side[^&gt;]+&gt;\s*&lt;span&gt;([^&lt;]+)',
127             webpage, 'duration', default=None))
128         view_count = str_to_int(self._search_regex(
129             r'([\d,.]+)\s+plays', webpage, 'view count', default=None))
130         age_limit = self._rta_search(webpage)
131         return merge_dicts({
132             'id': video_id,
133             'title': title or video_id,
134             'description': description,
135             'thumbnail': thumbnail,
136             'uploader': uploader,
137             'duration': duration,
138             'view_count': view_count,
139             'formats': formats,
140             'age_limit': age_limit,
141         }, info
142         )
143 class SpankBangPlaylistIE(InfoExtractor):
144     _VALID_URL = r'https?://(?:[^/]+\.)?spankbang\.com/(?P&lt;id&gt;[\da-z]+)/playlist/(?P&lt;display_id&gt;[^/]+)'
145     _TEST = {
146         'url': 'https://spankbang.com/ug0k/playlist/big+ass+titties',
147         'info_dict': {
148             'id': 'ug0k',
149             'title': 'Big Ass Titties',
150         },
151         'playlist_mincount': 40,
152     }
153     def _real_extract(self, url):
154         mobj = re.match(self._VALID_URL, url)
155         playlist_id = mobj.group('id')
156         display_id = mobj.group('display_id')
157         webpage = self._download_webpage(
158             url, playlist_id, headers={'Cookie': 'country=US; mobile=on'})
159         entries = [self.url_result(
160             urljoin(url, mobj.group('path')),
161             ie=SpankBangIE.ie_key(), video_id=mobj.group('id'))
162             for mobj in re.finditer(
163                 r'&lt;a[^&gt;]+\bhref=(["\'])(?P&lt;path&gt;/?[\da-z]+-(?P&lt;id&gt;[\da-z]+)/playlist/%s(?:(?!\1).)*)\1'
164                 % re.escape(display_id), webpage)]
165         title = self._html_search_regex(
166             r'&lt;h1&gt;([^&lt;]+)\s+playlist\s*&lt;', webpage, 'playlist title',
167             fatal=False)
168         return self.playlist_result(entries, playlist_id, title)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>srgssr.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from .common import InfoExtractor
4 from ..utils import (
5     ExtractorError,
6     float_or_none,
7     int_or_none,
8     parse_iso8601,
9     qualities,
10     try_get,
11 )
12 class SRGSSRIE(InfoExtractor):
13     _VALID_URL = r'''(?x)
14                     (?:
15                         https?://tp\.srgssr\.ch/p(?:/[^/]+)+\?urn=urn|
16                         srgssr
17                     ):
18                     (?P&lt;bu&gt;
19                         srf|rts|rsi|rtr|swi
20                     ):(?:[^:]+:)?
21                     (?P&lt;type&gt;
22                         video|audio
23                     ):
24                     (?P&lt;id&gt;
25                         [0-9a-f\-]{36}|\d+
26                     )
27                     '''
28     _GEO_BYPASS = False
29     _GEO_COUNTRIES = ['CH']
30     _ERRORS = {
31         'AGERATING12': 'To protect children under the age of 12, this video is only available between 8 p.m. and 6 a.m.',
32         'AGERATING18': 'To protect children under the age of 18, this video is only available between 11 p.m. and 5 a.m.',
33         'GEOBLOCK': 'For legal reasons, this video is only available in Switzerland.',
34         'LEGAL': 'The video cannot be transmitted for legal reasons.',
35         'STARTDATE': 'This video is not yet available. Please try again later.',
36     }
37     _DEFAULT_LANGUAGE_CODES = {
38         'srf': 'de',
39         'rts': 'fr',
40         'rsi': 'it',
41         'rtr': 'rm',
42         'swi': 'en',
43     }
44     def _get_tokenized_src(self, url, video_id, format_id):
45         token = self._download_json(
46             'http://tp.srgssr.ch/akahd/token?acl=*',
47             video_id, 'Downloading %s token' % format_id, fatal=False) or {}
48         auth_params = try_get(token, lambda x: x['token']['authparams'])
49         if auth_params:
50             url += ('?' if '?' not in url else '&amp;') + auth_params
51         return url
52     def _get_media_data(self, bu, media_type, media_id):
53         query = {'onlyChapters': True} if media_type == 'video' else {}
54         full_media_data = self._download_json(
55             'https://il.srgssr.ch/integrationlayer/2.0/%s/mediaComposition/%s/%s.json'
56             % (bu, media_type, media_id),
57             media_id, query=query)['chapterList']
58         try:
59             media_data = next(
60                 x for x in full_media_data if x.get('id') == media_id)
61         except StopIteration:
62             raise ExtractorError('No media information found')
63         block_reason = media_data.get('blockReason')
64         if block_reason and block_reason in self._ERRORS:
65             message = self._ERRORS[block_reason]
66             if block_reason == 'GEOBLOCK':
67                 self.raise_geo_restricted(
68                     msg=message, countries=self._GEO_COUNTRIES)
69             raise ExtractorError(
70                 '%s said: %s' % (self.IE_NAME, message), expected=True)
71         return media_data
72     def _real_extract(self, url):
73         bu, media_type, media_id = re.match(self._VALID_URL, url).groups()
74         media_data = self._get_media_data(bu, media_type, media_id)
75         title = media_data['title']
76         formats = []
77         q = qualities(['SD', 'HD'])
78         for source in (media_data.get('resourceList') or []):
79             format_url = source.get('url')
80             if not format_url:
81                 continue
82             protocol = source.get('protocol')
83             quality = source.get('quality')
84             format_id = []
85             for e in (protocol, source.get('encoding'), quality):
86                 if e:
87                     format_id.append(e)
88             format_id = '-'.join(format_id)
89             if protocol in ('HDS', 'HLS'):
90                 if source.get('tokenType') == 'AKAMAI':
91                     format_url = self._get_tokenized_src(
92                         format_url, media_id, format_id)
93                     formats.extend(self._extract_akamai_formats(
94                         format_url, media_id))
95                 elif protocol == 'HLS':
96                     formats.extend(self._extract_m3u8_formats(
97                         format_url, media_id, 'mp4', 'm3u8_native',
98                         m3u8_id=format_id, fatal=False))
99             elif protocol in ('HTTP', 'HTTPS'):
100                 formats.append({
101                     'format_id': format_id,
102                     'url': format_url,
103                     'quality': q(quality),
104                 })
105         if int_or_none(media_data.get('position')) == 0:
106             for p in ('S', 'H'):
107                 podcast_url = media_data.get('podcast%sdUrl' % p)
108                 if not podcast_url:
109                     continue
110                 quality = p + 'D'
111                 formats.append({
112                     'format_id': 'PODCAST-' + quality,
113                     'url': podcast_url,
114                     'quality': q(quality),
115                 })
116         self._sort_formats(formats)
117         subtitles = {}
118         if media_type == 'video':
119             for sub in (media_data.get('subtitleList') or []):
120                 sub_url = sub.get('url')
121                 if not sub_url:
122                     continue
123                 lang = sub.get('locale') or self._DEFAULT_LANGUAGE_CODES[bu]
124                 subtitles.setdefault(lang, []).append({
125                     'url': sub_url,
126                 })
127         return {
128             'id': media_id,
129             'title': title,
130             'description': media_data.get('description'),
131             'timestamp': parse_iso8601(media_data.get('date')),
132             'thumbnail': media_data.get('imageUrl'),
133             'duration': float_or_none(media_data.get('duration'), 1000),
134             'subtitles': subtitles,
135             'formats': formats,
136         }
137 class SRGSSRPlayIE(InfoExtractor):
138     IE_DESC = 'srf.ch, rts.ch, rsi.ch, rtr.ch and swissinfo.ch play sites'
139     _VALID_URL = r'''(?x)
140                     https?://
141                         (?:(?:www|play)\.)?
142                         (?P&lt;bu&gt;srf|rts|rsi|rtr|swissinfo)\.ch/play/(?:tv|radio)/
143                         (?:
144                             [^/]+/(?P&lt;type&gt;video|audio)/[^?]+|
145                             popup(?P&lt;type_2&gt;video|audio)player
146                         )
147                         \?.*?\b(?:id=|urn=urn:[^:]+:video:)(?P&lt;id&gt;[0-9a-f\-]{36}|\d+)
148                     '''
149     _TESTS = [{
150         'url': 'http://www.srf.ch/play/tv/10vor10/video/snowden-beantragt-asyl-in-russland?id=28e1a57d-5b76-4399-8ab3-9097f071e6c5',
151         'md5': '6db2226ba97f62ad42ce09783680046c',
152         'info_dict': {
153             'id': '28e1a57d-5b76-4399-8ab3-9097f071e6c5',
154             'ext': 'mp4',
155             'upload_date': '20130701',
156             'title': 'Snowden beantragt Asyl in Russland',
157             'timestamp': 1372708215,
158             'duration': 113.827,
159             'thumbnail': r're:^https?://.*1383719781\.png$',
160         },
161         'expected_warnings': ['Unable to download f4m manifest'],
162     }, {
163         'url': 'http://www.rtr.ch/play/radio/actualitad/audio/saira-tujetsch-tuttina-cuntinuar-cun-sedrun-muster-turissem?id=63cb0778-27f8-49af-9284-8c7a8c6d15fc',
164         'info_dict': {
165             'id': '63cb0778-27f8-49af-9284-8c7a8c6d15fc',
166             'ext': 'mp3',
167             'upload_date': '20151013',
168             'title': 'Saira: Tujetsch - tuttina cuntinuar cun Sedrun Must√©r Turissem',
169             'timestamp': 1444709160,
170             'duration': 336.816,
171         'params': {
172             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>'skip_download': True,
173         },
174     }, {
175         'url': 'http://www.rts.ch/play/tv/-/video/le-19h30?id=6348260',
176         'md5': '67a2a9ae4e8e62a68d0e9820cc9782df',
177         'info_dict': {
178             'id': '6348260',
179             'display_id': '6348260',
180             'ext': 'mp4',
181             'duration': 1796.76,
182             'title': 'Le 19h30',
183             'upload_date': '20141201',
184             'timestamp': 1417458600,
185             'thumbnail': r're:^https?://.*\.image',
186         },
187         'params': {
188             'skip_download': True,
189         }
190     }, {
191         'url': 'http://play.swissinfo.ch/play/tv/business/video/why-people-were-against-tax-reforms?id=42960270',
192         'info_dict': {
193             'id': '42960270',
194             'ext': 'mp4',
195             'title': 'Why people were against tax reforms',
196             'description': 'md5:7ac442c558e9630e947427469c4b824d',
197             'duration': 94.0,
198             'upload_date': '20170215',
199             'timestamp': 1487173560,
200             'thumbnail': r're:https?://www\.swissinfo\.ch/srgscalableimage/42961964',
201             'subtitles': 'count:9',
202         },
203         'params': {
204             'skip_download': True,
205         }
206     }, {
207         'url': 'https://www.srf.ch/play/tv/popupvideoplayer?id=c4dba0ca-e75b-43b2-a34f-f708a4932e01',
208         'only_matching': True,
209     }, {
210         'url': 'https://www.srf.ch/play/tv/10vor10/video/snowden-beantragt-asyl-in-russland?urn=urn:srf:video:28e1a57d-5b76-4399-8ab3-9097f071e6c5',
211         'only_matching': True,
212     }, {
213         'url': 'https://www.rts.ch/play/tv/19h30/video/le-19h30?urn=urn:rts:video:6348260',
214         'only_matching': True,
215     }, {
216         'url': 'https://www.srf.ch/play/radio/popupaudioplayer?id=50b20dc8-f05b-4972-bf03-e438ff2833eb',
217         'only_matching': True,
218     }]
219     def _real_extract(self, url):
220         mobj = re.match(self._VALID_URL, url)
221         bu = mobj.group(</b></font>'bu')
222         media_type = mobj.group('type') or mobj.group('type_2')
223         media_id = mobj.group('id')
224         return self.url_result('srgssr:%s:%s:%s' % (bu[:3], media_type, media_id), 'SRGSSR')
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
