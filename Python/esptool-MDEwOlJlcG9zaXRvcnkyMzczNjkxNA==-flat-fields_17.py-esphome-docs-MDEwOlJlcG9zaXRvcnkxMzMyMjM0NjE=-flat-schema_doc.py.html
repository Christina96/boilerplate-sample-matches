
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.9259259259259265%, Tokens: 9</h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_17.py</h3>
            <pre><code>1  import binascii
2  import struct
3  import time
4  from bitstring import BitArray
5  import esptool
6  import reedsolo
7  from .mem_definition import EfuseDefineBlocks, EfuseDefineFields, EfuseDefineRegisters
8  from .. import base_fields
9  from .. import util
10  class EfuseBlock(base_fields.EfuseBlockBase):
11      def len_of_burn_unit(self):
12          return 8 * 4
13      def __init__(self, parent, param, skip_read=False):
14          parent.read_coding_scheme()
15          super(EfuseBlock, self).__init__(parent, param, skip_read=skip_read)
16      def apply_coding_scheme(self):
17          data = self.get_raw(from_read=False)[::-1]
18          if len(data) < self.len_of_burn_unit():
19              add_empty_bytes = self.len_of_burn_unit() - len(data)
20              data = data + (b"\x00" * add_empty_bytes)
21          if self.get_coding_scheme() == self.parent.REGS.CODING_SCHEME_RS:
22              rs = reedsolo.RSCodec(12)
23              encoded_data = rs.encode([x for x in data])
24              words = struct.unpack("<" + "I" * 11, encoded_data)
25          else:
26              words = struct.unpack("<" + ("I" * (len(data) // 4)), data)
27          return words
28  class EspEfuses(base_fields.EspEfusesBase):
29      debug = False
30      do_not_confirm = False
31      def __init__(self, esp, skip_connect=False, debug=False, do_not_confirm=False):
32          self.Blocks = EfuseDefineBlocks()
33          self.Fields = EfuseDefineFields()
34          self.REGS = EfuseDefineRegisters
35          self.BURN_BLOCK_DATA_NAMES = self.Blocks.get_burn_block_data_names()
36          self.BLOCKS_FOR_KEYS = self.Blocks.get_blocks_for_keys()
37          self._esp = esp
38          self.debug = debug
39          self.do_not_confirm = do_not_confirm
40          if esp.CHIP_NAME != "ESP32-C6":
41              raise esptool.FatalError(
42                  "Expected the 'esp' param for ESP32-C6 chip but got for '%s'."
43                  % (esp.CHIP_NAME)
44              )
45          if not skip_connect:
46              flags = self._esp.get_security_info()["flags"]
47              GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE = 1 << 2
48              if flags & GET_SECURITY_INFO_FLAG_SECURE_DOWNLOAD_ENABLE:
49                  raise esptool.FatalError(
50                      "Secure Download Mode is enabled. The tool can not read eFuses."
51                  )
52          self.blocks = [
53              EfuseBlock(self, self.Blocks.get(block), skip_read=skip_connect)
54              for block in self.Blocks.BLOCKS
55          ]
56          if not skip_connect:
57              self.get_coding_scheme_warnings()
58          self.efuses = [EfuseField.convert(self, efuse) for efuse in self.Fields.EFUSES]
59          self.efuses += [
60              EfuseField.convert(self, efuse) for efuse in self.Fields.KEYBLOCKS
61          ]
62          if skip_connect:
63              self.efuses += [
64                  EfuseField.convert(self, efuse)
<span onclick='openModal()' class='match'>65                  for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
66              ]
67          else:
68              if self["BLK_VERSION_MINOR"].get() == 1:
69                  self.efuses += [
70                      EfuseField.convert(self, efuse)
</span>71                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
72                  ]
73              self.efuses += [
74                  EfuseField.convert(self, efuse) for efuse in self.Fields.CALC
75              ]
76      def __getitem__(self, efuse_name):
77          for e in self.efuses:
78              if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
79                  return e
80          new_fields = False
81          for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES:
82              if efuse.name == efuse_name or any(
83                  x == efuse_name for x in efuse.alt_names
84              ):
85                  self.efuses += [
86                      EfuseField.convert(self, efuse)
87                      for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
88                  ]
89                  new_fields = True
90          if new_fields:
91              for e in self.efuses:
92                  if efuse_name == e.name or any(x == efuse_name for x in e.alt_names):
93                      return e
94          raise KeyError
95      def read_coding_scheme(self):
96          self.coding_scheme = self.REGS.CODING_SCHEME_RS
97      def print_status_regs(self):
98          print("")
99          self.blocks[0].print_block(self.blocks[0].err_bitarray, "err__regs", debug=True)
100          print(
101              "{:27} 0x{:08x}".format(
102                  "EFUSE_RD_RS_ERR0_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR0_REG)
103              )
104          )
105          print(
106              "{:27} 0x{:08x}".format(
107                  "EFUSE_RD_RS_ERR1_REG", self.read_reg(self.REGS.EFUSE_RD_RS_ERR1_REG)
108              )
109          )
110      def efuse_controller_setup(self):
111          self.set_efuse_timing()
112          self.clear_pgm_registers()
113          self.wait_efuse_idle()
114      def write_efuses(self, block):
115          self.efuse_program(block)
116          return self.get_coding_scheme_warnings(silent=True)
117      def clear_pgm_registers(self):
118          self.wait_efuse_idle()
119          for r in range(
120              self.REGS.EFUSE_PGM_DATA0_REG, self.REGS.EFUSE_PGM_DATA0_REG + 32, 4
121          ):
122              self.write_reg(r, 0)
123      def wait_efuse_idle(self):
124          deadline = time.time() + self.REGS.EFUSE_BURN_TIMEOUT
125          while time.time() < deadline:
126              if self.read_reg(self.REGS.EFUSE_STATUS_REG) & 0x7 == 1:
127                  return
128          raise esptool.FatalError(
129              "Timed out waiting for Efuse controller command to complete"
130          )
131      def efuse_program(self, block):
132          self.wait_efuse_idle()
133          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_WRITE_OP_CODE)
134          self.write_reg(self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_PGM_CMD | (block << 2))
135          self.wait_efuse_idle()
136          self.clear_pgm_registers()
137          self.efuse_read()
138      def efuse_read(self):
139          self.wait_efuse_idle()
140          self.write_reg(self.REGS.EFUSE_CONF_REG, self.REGS.EFUSE_READ_OP_CODE)
141          try:
142              self.write_reg(
143                  self.REGS.EFUSE_CMD_REG, self.REGS.EFUSE_READ_CMD, delay_after_us=1000
144              )
145              self.wait_efuse_idle()
146          except esptool.FatalError:
147              secure_download_mode_before = self._esp.secure_download_mode
148              try:
149                  self._esp = self.reconnect_chip(self._esp)
150              except esptool.FatalError:
151                  print("Can not re-connect to the chip")
152                  if not self["DIS_DOWNLOAD_MODE"].get() and self[
153                      "DIS_DOWNLOAD_MODE"
154                  ].get(from_read=False):
155                      print(
156                          "This is the correct behavior as we are actually burning "
157                          "DIS_DOWNLOAD_MODE which disables the connection to the chip"
158                      )
159                      print("DIS_DOWNLOAD_MODE is enabled")
160                      print("Successful")
161                      exit(0)  # finish without errors
162                  raise
163              print("Established a connection with the chip")
164              if self._esp.secure_download_mode and not secure_download_mode_before:
165                  print("Secure download mode is enabled")
166                  if not self["ENABLE_SECURITY_DOWNLOAD"].get() and self[
167                      "ENABLE_SECURITY_DOWNLOAD"
168                  ].get(from_read=False):
169                      print(
170                          "espefuse tool can not continue to work in Secure download mode"
171                      )
172                      print("ENABLE_SECURITY_DOWNLOAD is enabled")
173                      print("Successful")
174                      exit(0)  # finish without errors
175              raise
176      def set_efuse_timing(self):
177          apb_freq = self.get_crystal_freq()
178          if apb_freq != 40:
179              raise esptool.FatalError(
180                  "The eFuse supports only xtal=40M (xtal was %d)" % apb_freq
181              )
182          self.update_reg(self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_NUM_M, 0xFF)
183          self.update_reg(
184              self.REGS.EFUSE_DAC_CONF_REG, self.REGS.EFUSE_DAC_CLK_DIV_M, 0x28
185          )
186          self.update_reg(
187              self.REGS.EFUSE_WR_TIM_CONF1_REG, self.REGS.EFUSE_PWR_ON_NUM_M, 0x3000
188          )
189          self.update_reg(
190              self.REGS.EFUSE_WR_TIM_CONF2_REG, self.REGS.EFUSE_PWR_OFF_NUM_M, 0x190
191          )
192      def get_coding_scheme_warnings(self, silent=False):
193          old_addr_reg = 0
194          reg_value = 0
195          ret_fail = False
196          for block in self.blocks:
197              if block.id == 0:
198                  words = [
199                      self.read_reg(self.REGS.EFUSE_RD_REPEAT_ERR0_REG + offs * 4)
200                      for offs in range(5)
201                  ]
202                  block.err_bitarray.pos = 0
203                  for word in reversed(words):
204                      block.err_bitarray.overwrite(BitArray("uint:32=%d" % word))
205                  block.num_errors = block.err_bitarray.count(True)
206                  block.fail = block.num_errors != 0
207              else:
208                  addr_reg, err_num_mask, err_num_offs, fail_bit = self.REGS.BLOCK_ERRORS[
209                      block.id
210                  ]
211                  if err_num_mask is None or err_num_offs is None or fail_bit is None:
212                      continue
213                  if addr_reg != old_addr_reg:
214                      old_addr_reg = addr_reg
215                      reg_value = self.read_reg(addr_reg)
216                  block.fail = reg_value & (1 << fail_bit) != 0
217                  block.num_errors = (reg_value >> err_num_offs) & err_num_mask
218              ret_fail |= block.fail
219              if not silent and (block.fail or block.num_errors):
220                  print(
221                      "Error(s) in BLOCK%d [ERRORS:%d FAIL:%d]"
222                      % (block.id, block.num_errors, block.fail)
223                  )
224          if (self.debug or ret_fail) and not silent:
225              self.print_status_regs()
226          return ret_fail
227      def summary(self):
228          return ""
229  class EfuseField(base_fields.EfuseFieldBase):
230      @staticmethod
231      def convert(parent, efuse):
232          return {
233              "mac": EfuseMacField,
234              "keypurpose": EfuseKeyPurposeField,
235              "t_sensor": EfuseTempSensor,
236              "adc_tp": EfuseAdcPointCalibration,
237              "wafer": EfuseWafer,
238          }.get(efuse.class_type, EfuseField)(parent, efuse)
239  class EfuseWafer(EfuseField):
240      def get(self, from_read=True):
241          hi_bits = self.parent["WAFER_VERSION_MINOR_HI"].get(from_read)
242          assert self.parent["WAFER_VERSION_MINOR_HI"].bit_len == 1
243          lo_bits = self.parent["WAFER_VERSION_MINOR_LO"].get(from_read)
244          assert self.parent["WAFER_VERSION_MINOR_LO"].bit_len == 3
245          return (hi_bits << 3) + lo_bits
246      def save(self, new_value):
247          raise esptool.FatalError("Burning %s is not supported" % self.name)
248  class EfuseTempSensor(EfuseField):
249      def get(self, from_read=True):
250          value = self.get_bitstring(from_read)
251          sig = -1 if value[0] else 1
252          return sig * value[1:].uint * 0.1
253  class EfuseAdcPointCalibration(EfuseField):
254      def get(self, from_read=True):
255          STEP_SIZE = 4
256          value = self.get_bitstring(from_read)
257          sig = -1 if value[0] else 1
258          return sig * value[1:].uint * STEP_SIZE
259  class EfuseMacField(EfuseField):
260      def check_format(self, new_value_str):
261          if new_value_str is None:
262              raise esptool.FatalError(
263                  "Required MAC Address in AA:CD:EF:01:02:03 format!"
264              )
265          if new_value_str.count(":") != 5:
266              raise esptool.FatalError(
267                  "MAC Address needs to be a 6-byte hexadecimal format "
268                  "separated by colons (:)!"
269              )
270          hexad = new_value_str.replace(":", "")
271          if len(hexad) != 12:
272              raise esptool.FatalError(
273                  "MAC Address needs to be a 6-byte hexadecimal number "
274                  "(12 hexadecimal characters)!"
275              )
276          bindata = binascii.unhexlify(hexad)
277          if esptool.util.byte(bindata, 0) & 0x01:
278              raise esptool.FatalError("Custom MAC must be a unicast MAC!")
279          return bindata
280      def check(self):
281          errs, fail = self.parent.get_block_errors(self.block)
282          if errs != 0 or fail:
283              output = "Block%d has ERRORS:%d FAIL:%d" % (self.block, errs, fail)
284          else:
285              output = "OK"
286          return "(" + output + ")"
287      def get(self, from_read=True):
288          if self.name == "CUSTOM_MAC":
289              mac = self.get_raw(from_read)[::-1]
290          else:
291              mac = self.get_raw(from_read)
292          return "%s %s" % (util.hexify(mac, ":"), self.check())
293      def save(self, new_value):
294          def print_field(e, new_value):
295              print(
296                  "    - '{}' ({}) {} -> {}".format(
297                      e.name, e.description, e.get_bitstring(), new_value
298                  )
299              )
300          if self.name == "CUSTOM_MAC":
301              bitarray_mac = self.convert_to_bitstring(new_value)
302              print_field(self, bitarray_mac)
303              super(EfuseMacField, self).save(new_value)
304          else:
305              raise esptool.FatalError("Writing Factory MAC address is not supported")
306  class EfuseKeyPurposeField(EfuseField):
307      KEY_PURPOSES = [
308          ("USER",                         0,  None,       None,      "no_need_rd_protect"),   # User purposes (software-only use)
309          ("RESERVED",                     1,  None,       None,      "no_need_rd_protect"),   # Reserved
310          ("XTS_AES_128_KEY",              4,  None,       "Reverse", "need_rd_protect"),      # XTS_AES_128_KEY (flash/PSRAM encryption)
311          ("HMAC_DOWN_ALL",                5,  None,       None,      "need_rd_protect"),      # HMAC Downstream mode
312          ("HMAC_DOWN_JTAG",               6,  None,       None,      "need_rd_protect"),      # JTAG soft enable key (uses HMAC Downstream mode)
313          ("HMAC_DOWN_DIGITAL_SIGNATURE",  7,  None,       None,      "need_rd_protect"),      # Digital Signature peripheral key (uses HMAC Downstream mode)
314          ("HMAC_UP",                      8,  None,       None,      "need_rd_protect"),      # HMAC Upstream mode
315          ("SECURE_BOOT_DIGEST0",          9,  "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST0 (Secure Boot key digest)
316          ("SECURE_BOOT_DIGEST1",          10, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST1 (Secure Boot key digest)
317          ("SECURE_BOOT_DIGEST2",          11, "DIGEST",   None,      "no_need_rd_protect"),   # SECURE_BOOT_DIGEST2 (Secure Boot key digest)
318      ]
319      KEY_PURPOSES_NAME = [name[0] for name in KEY_PURPOSES]
320      DIGEST_KEY_PURPOSES = [name[0] for name in KEY_PURPOSES if name[2] == "DIGEST"]
321      def check_format(self, new_value_str):
322          raw_val = new_value_str
323          for purpose_name in self.KEY_PURPOSES:
324              if purpose_name[0] == new_value_str:
325                  raw_val = str(purpose_name[1])
326                  break
327          if raw_val.isdigit():
328              if int(raw_val) not in [p[1] for p in self.KEY_PURPOSES if p[1] > 0]:
329                  raise esptool.FatalError("'%s' can not be set (value out of range)" % raw_val)
330          else:
331              raise esptool.FatalError("'%s' unknown name" % raw_val)
332          return raw_val
333      def need_reverse(self, new_key_purpose):
334          for key in self.KEY_PURPOSES:
335              if key[0] == new_key_purpose:
336                  return key[3] == "Reverse"
337      def need_rd_protect(self, new_key_purpose):
338          for key in self.KEY_PURPOSES:
339              if key[0] == new_key_purpose:
340                  return key[4] == "need_rd_protect"
341      def get(self, from_read=True):
342          for p in self.KEY_PURPOSES:
343              if p[1] == self.get_raw(from_read):
344                  return p[0]
345          return "FORBIDDEN_STATE"
346      def get_name(self, raw_val):
347          for key in self.KEY_PURPOSES:
348              if key[1] == raw_val:
349                  return key[0]
350      def save(self, new_value):
351          raw_val = int(self.check_format(str(new_value)))
352          str_new_value = self.get_name(raw_val)
353          if self.name == "KEY_PURPOSE_5" and str_new_value.startswith("XTS_AES"):
354              raise esptool.FatalError(f"{self.name} can not have {str_new_value} key due to a hardware bug (please see TRM for more details)")
355          return super(EfuseKeyPurposeField, self).save(raw_val)
</code></pre>
        </div>
        <div class="column">
            <h3>esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</h3>
            <pre><code>1  from genericpath import exists
2  import re
3  import json
4  import urllib
5  from typing import MutableMapping
6  from sphinx.util import logging
7  from docutils import nodes
8  SCHEMA_PATH = "../esphome-vscode/server/src/schema/"
9  CONFIGURATION_VARIABLES = "Configuration variables:"
10  CONFIGURATION_OPTIONS = "Configuration options:"
11  PIN_CONFIGURATION_VARIABLES = "Pin configuration variables:"
12  COMPONENT_HUB = "Component/Hub"
13  JSON_DUMP_PRETTY = True
14  class Statistics:
15      props_documented = 0
16      enums_good = 0
17      enums_bad = 0
18  statistics = Statistics()
19  logger = logging.getLogger(__name__)
20  def setup(app):
21      import os
22      if not os.path.isfile(SCHEMA_PATH + "esphome.json"):
23          logger.info(f"{SCHEMA_PATH} not found. Not documenting schema.")
24          return
25      app.connect("doctree-resolved", doctree_resolved)
26      app.connect("build-finished", build_finished)
27      app.files = {}
28      return {"version": "1.0.0", "parallel_read_safe": True, "parallel_write_safe": True}
29  def find_platform_component(app, platform, component):
30      file_data = get_component_file(app, component)
31      return file_data[f"{component}.{platform}"]["schemas"]["CONFIG_SCHEMA"]
32  def doctree_resolved(app, doctree, docname):
33      if docname == "components/index":
34          return
35      handle_component(app, doctree, docname)
36  PLATFORMS_TITLES = {
37      "Sensor": "sensor",
38      "Binary Sensor": "binary_sensor",
39      "Text Sensor": "text_sensor",
40      "Output": "output",
41      "Cover": "cover",
42      "Button": "button",
43      "Select": "select",
44      "Fan": "fan",
45      "Lock": "lock",
46      "Number": "number",
47      "Climate": "climate",
48      "CAN Bus": "canbus",
49      "Stepper": "stepper",
50      "Switch": "switch",
51      "I²C": "i2c",
52      "Media Player": "media_player",
53      "Microphone": "microphone",
54  }
55  CUSTOM_DOCS = {
56      "guides/automations": {
57          "Global Variables": "globals.schemas.CONFIG_SCHEMA",
58      },
59      "guides/configuration-types": {
60          "Pin Schema": [
61              "esp32.pin.schema",
62              "esp8266.pin.schema",
63          ],
64      },
65      "components/binary_sensor/index": {
66          "Binary Sensor Filters": "binary_sensor.registry.filter",
67      },
68      "components/canbus": {
69          "_LoadSchema": False,
70          "Base CAN Bus Configuration": "canbus.schemas.CANBUS_SCHEMA",
71      },
72      "components/climate/climate_ir": {"_LoadSchema": False, "IR Remote Climate": []},
73      "components/display/index": {
74          "Images": "image.schemas.CONFIG_SCHEMA",
75          "Fonts": "font.schemas.CONFIG_SCHEMA",
76          "Color": "color.schemas.CONFIG_SCHEMA",
77          "Animation": "animation.schemas.CONFIG_SCHEMA",
78      },
79      "components/light/index": {
80          "Base Light Configuration": [
81              "light.schemas.ADDRESSABLE_LIGHT_SCHEMA",
82              "light.schemas.BINARY_LIGHT_SCHEMA",
83              "light.schemas.BRIGHTNESS_ONLY_LIGHT_SCHEMA",
84              "light.schemas.LIGHT_SCHEMA",
85          ],
86          "Light Effects": "light.registry.effects",
87      },
88      "components/light/fastled": {
89          "_LoadSchema": False,
90          "Clockless": "fastled_clockless.platform.light.schemas.CONFIG_SCHEMA",
91          "SPI": "fastled_spi.platform.light.schemas.CONFIG_SCHEMA",
92      },
93      "components/binary_sensor/ttp229": {
94          "_LoadSchema": False,
95      },
96      "components/mcp230xx": {
97          "_LoadSchema": False,
98          PIN_CONFIGURATION_VARIABLES: "mcp23xxx.pin",
99      },
100      "components/mqtt": {
101          "MQTT Component Base Configuration": "core.schemas.MQTT_COMMAND_COMPONENT_SCHEMA",
102          "MQTTMessage": "mqtt.schemas.MQTT_MESSAGE_BASE",
103      },
104      "components/output/index": {
105          "Base Output Configuration": "output.schemas.FLOAT_OUTPUT_SCHEMA",
106      },
107      "components/remote_transmitter": {
108          "Remote Transmitter Actions": "remote_base.schemas.BASE_REMOTE_TRANSMITTER_SCHEMA",
109      },
110      "components/sensor/index": {
111          "Sensor Filters": "sensor.registry.filter",
112      },
113      "components/time": {
114          "_LoadSchema": False,
115          "Base Time Configuration": "time.schemas.TIME_SCHEMA",
116          "on_time Trigger": "time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema",
117          "Home Assistant Time Source": "homeassistant.platform.time.schemas.CONFIG_SCHEMA",
118          "SNTP Time Source": "sntp.platform.time.schemas.CONFIG_SCHEMA",
119          "GPS Time Source": "gps.platform.time.schemas.CONFIG_SCHEMA",
120          "DS1307 Time Source": "ds1307.platform.time.schemas.CONFIG_SCHEMA",
121      },
122      "components/wifi": {
123          "Connecting to Multiple Networks": "wifi.schemas.CONFIG_SCHEMA.schema.config_vars.networks.schema",
124          "Enterprise Authentication": "wifi.schemas.EAP_AUTH_SCHEMA",
125      },
126      "custom/custom_component": {
127          "Generic Custom Component": "custom_component.schemas.CONFIG_SCHEMA"
128      },
129      "components/esp32": {
130          "Arduino framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.arduino",
131          "ESP-IDF framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.esp-idf",
132      },
133      "components/sensor/airthings_ble": {
134          "_LoadSchema": False,
135      },
136      "components/sensor/radon_eye_ble": {
137          "_LoadSchema": False,
138      },
139      "components/sensor/xiaomi_ble": {
140          "_LoadSchema": False,
141      },
142      "components/sensor/xiaomi_miscale2": {
143          "_LoadSchema": False,
144      },
145      "components/mcp23Sxx": {
146          "_LoadSchema": False,
147      },
148      "components/display/lcd_display": {"_LoadSchema": False},
149      "components/display/ssd1306": {"_LoadSchema": False},
150      "components/display/ssd1322": {"_LoadSchema": False},
151      "components/display/ssd1325": {"_LoadSchema": False},
152      "components/display/ssd1327": {"_LoadSchema": False},
153      "components/display/ssd1351": {"_LoadSchema": False},
154      "components/copy": {"_LoadSchema": False},
155      "components/display_menu/index": {
156          "Display Menu": "display_menu_base.schemas.DISPLAY_MENU_BASE_SCHEMA",
157          "Select": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.select",
158          "Menu": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.menu",
159          "Number": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.number",
160          "Switch": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.switch",
161          "Custom": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.custom",
162      },
163      "components/display_menu/lcd_menu": {
164          "LCD Menu": "lcd_menu.schemas.CONFIG_SCHEMA",
165      },
166  }
167  REQUIRED_OPTIONAL_TYPE_REGEX = r"(\(((\*\*Required\*\*)|(\*Optional\*))(,\s(.*))*)\):\s"
168  def get_node_title(node):
169      return list(node.traverse(nodes.title))[0].astext()
170  def read_file(fileName):
171      f = open(SCHEMA_PATH + fileName + ".json", "r", encoding="utf-8-sig")
172      str = f.read()
173      return json.loads(str)
174  def is_config_vars_title(title_text):
175      return title_text == CONFIGURATION_VARIABLES or title_text == CONFIGURATION_OPTIONS
176  class SchemaGeneratorVisitor(nodes.NodeVisitor):
177      def __init__(self, app, doctree, docname):
178          nodes.NodeVisitor.__init__(self, doctree)
179          self.app = app
180          self.doctree = doctree
181          self.docname = docname
182          self.path = docname.split("/")
183          self.json_component = None
184          self.props = None
185          self.platform = None
186          self.json_platform_component = None
187          self.title_id = None
188          self.props_section_title = None
189          self.find_registry = None
190          self.component = None
191          self.section_level = 0
192          self.file_schema = None
193          self.custom_doc = CUSTOM_DOCS.get(docname)
194          if self.path[0] == "components":
195              if len(self.path) == 2:  # root component, e.g. dfplayer, logger
196                  self.component = docname[11:]
197                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
198                      self.file_schema = get_component_file(app, self.component)
199                      self.json_component = self.file_schema[self.component]["schemas"][
200                          "CONFIG_SCHEMA"
201                      ]
202              elif self.path[1] == "display_menu":  # weird folder naming
203                  if self.path[2] == "index":
204                      self.component = "display_menu_base"
205                  else:
206                      self.component = self.path[2]
207                      self.file_schema = get_component_file(app, self.component)
208                      self.json_component = self.file_schema[self.component]["schemas"][
209                          "CONFIG_SCHEMA"
210                      ]
211              else:  # sub component, e.g. output/esp8266_pwm
212                  self.platform = self.path[1]
213                  self.component = self.path[2]
214                  if self.component == "ssd1331":
215                      self.component = "ssd1331_spi"
216                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
217                      if self.component == "index":
218                          self.component = self.platform.replace(" ", "_").lower()
219                          self.file_schema = get_component_file(app, self.component)
220                          self.json_component = self.file_schema[self.component][
221                              "schemas"
222                          ].get(self.component.upper() + "_SCHEMA")
223                          pass
224                      else:
225                          self.json_component = get_component_file(app, self.component)
226                          self.json_platform_component = find_platform_component(
227                              app, self.platform, self.component
228                          )
229          self.previous_title_text = "No title"
230          self.is_component_hub = False
231          self.multi_component = None
232          self.prop_stack = []
233          self.current_prop = None
234          self.filled_props = False
235          self.accept_props = False
236          self.bullet_list_level = 0
237      def set_component_description(self, description, componentName, platformName=None):
238          if platformName is not None:
239              platform = get_component_file(self.app, platformName)
240              platform[platformName]["components"][componentName.lower()][
241                  "docs"
242              ] = description
243          else:
244              core = get_component_file(self.app, "esphome")["core"]
245              if componentName in core["components"]:
246                  core["components"][componentName]["docs"] = description
247              elif componentName in core["platforms"]:
248                  core["platforms"][componentName]["docs"] = description
249              else:
250                  if componentName != "display_menu_base":
251                      raise ValueError(
252                          "Cannot set description for component " + componentName
253                      )
254      def visit_document(self, node):
255          if self.docname in ["components/sensor/binary_sensor_map"]:
256              raise nodes.SkipChildren
257          if self.docname in ["components/climate/climate_ir"]:
258              return
259          if len(list(node.traverse(nodes.paragraph))) == 0:
260              raise nodes.SkipChildren
261          self.props_section_title = get_node_title(node)
262          description = self.getMarkdownParagraph(node)
263          if self.json_platform_component:
264              self.set_component_description(description, self.component, self.platform)
265          elif self.json_component:
266              self.set_component_description(description, self.component)
267          if self.json_component or self.json_platform_component:
268              if is_component_file(
269                  self.app,
270                  self.component,
271              ):
272                  self.props = self.find_props(
273                      self.json_platform_component
274                      if self.json_platform_component
275                      else self.json_component,
276                      True,
277                  )
278      def visit_table(self, node):
279          if (
280              self.docname == "components/climate/climate_ir"
281              and len(CUSTOM_DOCS["components/climate/climate_ir"]["IR Remote Climate"])
282              == 0
283          ):
284              table_rows = node[0][4]
285              for row in table_rows:
286                  components_paths = [
287                      components + ".platform.climate.schemas.CONFIG_SCHEMA"
288                      for components in row[1].astext().split("\n")
289                  ]
290                  CUSTOM_DOCS["components/climate/climate_ir"][
291                      "IR Remote Climate"
292                  ] += components_paths
293      def depart_document(self, node):
294          pass
295      def visit_section(self, node):
296          self.section_level += 1
297          section_title = get_node_title(node)
298          if self.custom_doc and section_title in self.custom_doc:
299              r = self.custom_doc[section_title]
300              if ".registry." in r:
301                  self.find_registry = r
302      def depart_section(self, node):
303          self.section_level -= 1
304          if self.section_level == 1:
305              self.find_registry = None
306      def unknown_visit(self, node):
307          pass
308      def unknown_departure(self, node):
309          pass
310      def visit_title(self, node):
311          title_text = node.astext()
312          if self.custom_doc is not None and title_text in self.custom_doc:
313              if isinstance(self.custom_doc[title_text], list):
314                  self.multi_component = self.custom_doc[title_text]
315                  self.filled_props = False
316                  self.props = None
317                  desc = self.getMarkdownParagraph(node.parent)
318                  for c in self.multi_component:
319                      if len(c.split(".")) == 2:
320                          self.set_component_description(desc, c.split(".")[0])
321                  return
322              json_component = self.find_component(self.custom_doc[title_text])
323              if not json_component:
324                  return
325              if self.json_component is None:
326                  self.json_component = json_component
327              parts = self.custom_doc[title_text].split(".")
328              if parts[0] not in ["core", "remote_base"] and parts[-1] != "pin":
329                  if parts[1] == "platform":
330                      self.set_component_description(
331                          self.getMarkdownParagraph(node.parent), parts[0], parts[2]
332                      )
333                  else:
334                      self.set_component_description(
335                          self.getMarkdownParagraph(node.parent),
336                          parts[0],
337                      )
338              self.props_section_title = title_text
339              self.props = self.find_props(json_component)
340              return
341          elif title_text == COMPONENT_HUB:
342              self.props_section_title = f"{self.path[-1]} {title_text}"
343              json_component = self.get_component_schema(
344                  self.path[-1] + ".CONFIG_SCHEMA"
345              ).get("schema", {})
346              if json_component:
347                  self.props = self.find_props(json_component)
348                  self.set_component_description(
349                      self.getMarkdownParagraph(node.parent), self.path[-1]
350                  )
351              self.is_component_hub = True
352          elif is_config_vars_title(title_text):
353              if not self.props and self.multi_component is None:
354                  raise ValueError(
355                      f'Found a "{title_text}": title after {self.previous_title_text}. Unknown object.'
356                  )
357          elif title_text == "Over SPI" or title_text == "Over I²C":
358              suffix = "_spi" if "SPI" in title_text else "_i2c"
359              component = self.path[-1] + suffix
360              self.props_section_title = self.path[-1] + " " + title_text
361              if self.platform is not None and not self.is_component_hub:
362                  json_platform_component = find_platform_component(
363                      self.app, self.platform, component
364                  )
365                  if not json_platform_component:
366                      raise ValueError(
367                          f"Cannot find platform {self.platform} component '{component}' after found title: '{title_text}'."
368                      )
369                  self.props = self.find_props(json_platform_component)
370                  json_platform_component["docs"] = self.getMarkdownParagraph(node.parent)
371              else:
372                  json_component = self.get_component_schema(
373                      component + ".CONFIG_SCHEMA"
374                  ).get("schema", {})
375                  if not json_component:
376                      raise ValueError(
377                          f"Cannot find component '{component}' after found title: '{title_text}'."
378                      )
379                  self.props = self.find_props(json_component)
380                  self.set_component_description(
381                      self.getMarkdownParagraph(node.parent), component
382                  )
383          elif (
384              len(
385                  list(
386                      filter(
387                          lambda x: title_text.endswith(x), list(PLATFORMS_TITLES.keys())
388                      )
389                  )
390              )
391              > 0
392          ):
393              if title_text in PLATFORMS_TITLES:
394                  platform_name = PLATFORMS_TITLES[title_text]
395                  if self.path[-1] == "index":
396                      component_name = self.path[-2]
397                  else:
398                      component_name = self.path[-1]
399                  self.props_section_title = component_name + " " + title_text
400              else:
401                  for t in PLATFORMS_TITLES:
402                      if title_text.endswith(t):
403                          component_name = title_text[
404                              0 : len(title_text) - len(t) - 1
405                          ].replace(" ", "_")
406                          platform_name = PLATFORMS_TITLES[t]
407                  if not platform_name:
408                      return
409                  self.props_section_title = title_text
410                  if not is_component_file(self.app, component_name):
411                      return
412              c = find_platform_component(self.app, platform_name, component_name.lower())
413              if c:
414                  self.json_platform_component = c
415                  self.set_component_description(
416                      self.getMarkdownParagraph(node.parent),
417                      component_name,
418                      platform_name,
419                  )
420              try:
421                  self.props = self.find_props(self.json_platform_component)
422              except KeyError:
423                  raise ValueError("Cannot find platform props")
424          elif title_text.endswith("Component") or title_text.endswith("Bus"):
425              split_text = title_text.split(" ")
426              self.props_section_title = title_text
427              component_name = (
428                  "_".join(split_text[:-1]).lower().replace(".", "").replace("i²c", "i2c")
429              )
430              if component_name != self.platform and is_component_file(
431                  self.app, component_name
432              ):
433                  f = get_component_file(self.app, component_name)
434                  description = self.getMarkdownParagraph(node.parent)
435                  if component_name in f:
436                      self.set_component_description(description, component_name)
437                      c = f[component_name]
438                      if c:
439                          self.json_component = c["schemas"]["CONFIG_SCHEMA"]
440                          try:
441                              self.props = self.find_props(self.json_component)
442                              self.multi_component = None
443                          except KeyError:
444                              raise ValueError(
445                                  "Cannot find props for component " + component_name
446                              )
447                          return
448                  elif f"{component_name}.{self.path[1]}" in f:
449                      self.set_component_description(
450                          description, component_name, self.path[1]
451                      )
452                      self.json_platform_component = f[
453                          f"{component_name}.{self.path[1]}"
454                      ]["schemas"]["CONFIG_SCHEMA"]
455                      try:
456                          self.props = self.find_props(self.json_platform_component)
457                      except KeyError:
458                          raise ValueError(
459                              f"Cannot find props for platform {self.path[1]} component {self.component_name}"
460                          )
461                      return
462          elif title_text.endswith("Trigger"):
463              description = self.getMarkdownParagraph(node.parent)
464              split_text = title_text.split(" ")
465              if len(split_text) != 2:
466                  return
467              key = split_text[0]
468              if (
469                  not self.props or not self.props.typed
470              ):  # props are right for typed components so far
471                  c = self.json_component
472                  if c:
473                      trigger_schema = self.find_props(c).get(key)
474                      if trigger_schema is not None:
475                          self.props = self.find_props(trigger_schema)
476              self.props_section_title = title_text
477          elif title_text == PIN_CONFIGURATION_VARIABLES:
478              self.component = self.find_component(self.path[-1] + ".pin")
479              self.props = self.find_props(self.component)
480              self.accept_props = True
481              if not self.component:
482                  raise ValueError(
483                      f'Found a "{PIN_CONFIGURATION_VARIABLES}" entry but could not find pin schema'
484                  )
485          elif title_text.endswith("Action") or title_text.endswith("Condition"):
486              description = self.getMarkdownParagraph(node.parent)
487              split_text = title_text.split(" ")
488              if len(split_text) != 2:
489                  return
490              key = split_text[0]
491              component_parts = split_text[0].split(".")
492              if len(component_parts) == 3:
493                  try:
494                      cv = get_component_file(self.app, component_parts[1])[
495                          component_parts[1] + "." + component_parts[0]
496                      ][split_text[1].lower()][component_parts[2]]
497                  except KeyError:
498                      logger.warn(
499                          f"In {self.docname} cannot found schema of {title_text}"
500                      )
501                      cv = None
502                  if cv is not None:
503                      cv["docs"] = description
504                      self.props = self.find_props(cv.get("schema", {}))
505              elif len(component_parts) == 2:
506                  registry_name = ".".join(
507                      [component_parts[0], "registry", split_text[1].lower()]
508                  )
509                  key = component_parts[1]
510                  self.find_registry_prop(registry_name, key, description)
511              else:
512                  registry_name = f"core.registry.{split_text[1].lower()}"
513                  self.find_registry_prop(registry_name, key, description)
514          if self.section_level == 3 and self.find_registry:
515              name = title_text
516              if name.endswith(" Effect"):
517                  name = title_text[: -len(" Effect")]
518              if name.endswith(" Light"):
519                  name = name[: -len(" Light")]
520              key = name.replace(" ", "_").replace(".", "").lower()
521              description = self.getMarkdownParagraph(node.parent)
522              self.find_registry_prop(self.find_registry, key, description)
523              self.props_section_title = title_text
524      def get_component_schema(self, name):
525          parts = name.split(".")
526          schema_file = get_component_file(self.app, parts[0])
527          if parts[1] == "registry":
528              schema = schema_file.get(parts[0], {}).get(parts[2], {})
529          elif len(parts) == 3:
530              schema = (
531                  schema_file.get(f"{parts[0]}.{parts[1]}")
532                  .get("schemas", {})
533                  .get(parts[2], {})
534              )
535          else:
536              schema = schema_file.get(parts[0], {}).get("schemas", {}).get(parts[1], {})
537          return schema
538      def get_component_config_var(self, name, key):
539          c = self.get_component_schema(name)
540          if key in c:
541              return c[key]
542          if "config_vars" not in c:
543              return c
544          if key in c["config_vars"]:
545              return c["config_vars"][c]
546      def find_registry_prop(self, registry_name, key, description):
547          c = self.get_component_schema(registry_name)
548          if key in c:
549              cv = c[key]
550              if cv is not None:
551                  cv["docs"] = description
552                  self.props = self.find_props(cv.get("schema", {}))
553      def depart_title(self, node):
554          if self.filled_props:
555              self.filled_props = False
556              self.props = None
557              self.current_prop = None
558              self.accept_props = False
559              self.multi_component = None
560          self.previous_title_text = node.astext()
561          self.title_id = node.parent["ids"][0]
562      def find_props_previous_title(self):
563          comp = self.json_component or self.json_platform_component
564          if comp:
565              props = self.find_props(comp)
566              if self.previous_title_text in props:
567                  prop = props[self.previous_title_text]
568                  if prop:
569                      self.props = self.find_props(prop)
570                  else:
571                      self.props = {"__": "none"}
572      def visit_Text(self, node):
573          if self.multi_component:
574              return
575          if is_config_vars_title(node.astext()):
576              if not self.props:
577                  self.find_props_previous_title()
578              if not self.props:
579                  raise ValueError(
580                      f'Found a "{node.astext()}" entry for unknown object after {self.previous_title_text}'
581                  )
582              self.accept_props = True
583          raise nodes.SkipChildren
584      def depart_Text(self, node):
585          pass
586      def visit_paragraph(self, node):
587          if is_config_vars_title(node.astext()):
588              if not self.props and not self.multi_component:
589                  self.find_props_previous_title()
590              if not self.props and not self.multi_component:
591                  logger.info(
592                      f"In {self.docname} / {self.previous_title_text} found a {node.astext()} title and there are no props."
593                  )
594              self.accept_props = True
595          raise nodes.SkipChildren
596      def depart_paragraph(self, node):
597          pass
598      def visit_bullet_list(self, node):
599          self.bullet_list_level = self.bullet_list_level + 1
600          if (
601              self.current_prop
602              and (self.props or self.multi_component)
603              and self.bullet_list_level > 1
604          ):
605              self.prop_stack.append((self.current_prop, node))
606              self.accept_props = True
607              return
608          if not self.props and self.multi_component is None:
609              raise nodes.SkipChildren
610      def depart_bullet_list(self, node):
611          self.bullet_list_level = self.bullet_list_level - 1
612          if len(self.prop_stack) > 0:
<span onclick='openModal()' class='match'>613              stack_prop, stack_node = self.prop_stack[-1]
614              if stack_node == node:
615                  self.prop_stack.pop()
616                  self.filled_props = True
617                  self.current_prop = stack_prop
</span>618      def visit_list_item(self, node):
619          if self.accept_props and self.props:
620              self.filled_props = True
621              self.current_prop, found = self.update_prop(node, self.props)
622              if self.current_prop and not found:
623                  logger.info(
624                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
625                  )
626          elif self.multi_component:
627              found_any = False
628              self.current_prop = None
629              for c in self.multi_component:
630                  props = self.find_props(self.find_component(c))
631                  self.current_prop, found = self.update_prop(node, props)
632                  if self.current_prop and found:
633                      found_any = True
634              if self.current_prop and not found_any:
635                  logger.info(
636                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
637                  )
638              self.filled_props = True
639      def depart_list_item(self, node):
640          pass
641      def visit_literal(self, node):
642          raise nodes.SkipChildren
643      def depart_literal(self, node):
644          pass
645      def getMarkdown(self, node):
646          from markdown import Translator
647          t = Translator(
648              urllib.parse.urljoin(self.app.config.html_baseurl, self.docname + ".html"),
649              self.doctree,
650          )
651          node.walkabout(t)
652          return t.output.strip("\n")
653      def getMarkdownParagraph(self, node):
654          paragraph = list(node.traverse(nodes.paragraph))[0]
655          markdown = self.getMarkdown(paragraph)
656          param_type = None
657          try:
658              name_type = markdown[: markdown.index(": ") + 2]
659              ntr = re.search(
660                  REQUIRED_OPTIONAL_TYPE_REGEX,
661                  name_type,
662                  re.IGNORECASE,
663              )
664              if ntr:
665                  param_type = ntr.group(6)
666                  if param_type:
667                      markdown = (
668                          f"**{param_type}**: {markdown[markdown.index(': ') + 2 :]}"
669                      )
670          except ValueError:
671              pass
672          title = list(node.traverse(nodes.title))[0]
673          if len(title) > 0:
674              url = urllib.parse.urljoin(
675                  self.app.config.html_baseurl,
676                  self.docname + ".html#" + title.parent["ids"][0],
677              )
678              if (
679                  self.props_section_title is not None
680                  and self.props_section_title.endswith(title.astext())
681              ):
682                  markdown += f"\n\n*See also: [{self.props_section_title}]({url})*"
683              else:
684                  markdown += f"\n\n*See also: [{self.getMarkdown(title)}]({url})*"
685          return markdown
686      def update_prop(self, node, props):
687          prop_name = None
688          for s_prop, n in self.prop_stack:
689              inner = props.get(s_prop)
690              if inner is not None and "schema" in inner:
691                  props = self.Props(self, inner["schema"])
692              elif inner is not None and inner.get("type") == "typed":
693                  props = self.Props(self, inner)
694              elif inner is not None and inner.get("type") == "enum":
695                  enum_raw = self.getMarkdown(node)
696                  enum_match = re.search(
697                      r"\* `([^`]*)`((:| -) (.*))*", enum_raw, re.IGNORECASE
698                  )
699                  if enum_match:
700                      enum_value = enum_match.group(1)
701                      enum_docs = enum_match.group(4)
702                      found = False
703                      for name in inner["values"]:
704                          if enum_value.upper().replace(" ", "_") == str(name).upper():
705                              found = True
706                              if enum_docs:
707                                  enum_docs = enum_docs.strip()
708                                  if inner["values"][name] is None:
709                                      inner["values"][name] = {"docs": enum_docs}
710                                  else:
711                                      inner["values"][name]["docs"] = enum_docs
712                                  statistics.props_documented += 1
713                                  statistics.enums_good += 1
714                      if not found:
715                          logger.info(
716                              f"In '{self.docname} {self.previous_title_text} Property {s_prop} cannot find enum value {enum_value}"
717                          )
718                  else:
719                      statistics.enums_bad += 1
720                      logger.info(
721                          f"In '{self.docname} {self.previous_title_text} Property {s_prop} unexpected enum member description format"
722                      )
723              else:
724                  return prop_name, False
725          raw = node.rawsource  # this has the full raw rst code for this property
726          if not raw.startswith("**"):
727              return prop_name, False
728          markdown = self.getMarkdown(node)
729          markdown += f"\n\n*See also: [{self.props_section_title}]({urllib.parse.urljoin(self.app.config.html_baseurl, self.docname +'.html#'+self.title_id)})*"
730          try:
731              name_type = markdown[: markdown.index(": ") + 2]
732          except ValueError:
733              logger.info(
734                  f"In '{self.docname} {self.previous_title_text} Property format error. Missing ': ' in {raw}'"
735              )
736              return prop_name, False
737          PROP_NAME_REGEX = r"\*\*(\w*(?:/\w*)*)\*\*"
738          FULL_ITEM_PROP_NAME_TYPE_REGEX = (
739              r"\* " + PROP_NAME_REGEX + r"\s" + REQUIRED_OPTIONAL_TYPE_REGEX
740          )
741          ntr = re.search(
742              FULL_ITEM_PROP_NAME_TYPE_REGEX,
743              name_type,
744              re.IGNORECASE,
745          )
746          if ntr:
747              prop_name = ntr.group(1)
748              param_type = ntr.group(7)
749          else:
750              s2 = re.search(
751                  FULL_ITEM_PROP_NAME_TYPE_REGEX,
752                  markdown,
753                  re.IGNORECASE,
754              )
755              if s2:
756                  s3 = re.search(r"\* " + PROP_NAME_REGEX + r"*:\s", name_type)
757                  if s3 is not None:
758                      prop_name = s3.group(1)
759                  else:
760                      logger.info(
761                          f"In '{self.docname} {self.previous_title_text} Invalid list format: {node.rawsource}"
762                      )
763                  param_type = None
764              else:
765                  logger.info(
766                      f"In '{self.docname} {self.previous_title_text} Invalid property format: {node.rawsource}"
767                  )
768                  return prop_name, False
769          prop_names = str(prop_name)
770          for k in prop_names.split("/"):
771              config_var = props.get(k)
772              if not config_var:
773                  if k in [
774                      "id",
775                      "name",
776                      "internal",
777                      "address",
778                      "i2c_id",
779                      "update_interval",
780                      "uart_id",
781                      "effects",
782                      "gamma_correct",
783                      "default_transition_length",
784                      "flash_transition_length",
785                      "color_correct",
786                      "lambda",
787                      "pages",
788                      "rotation",
789                      "spi_id",
790                      "cs_pin",
791                      "inverted",
792                      "power_supply",
793                      "receiver_id",
794                  ]:
795                      config_var = props[k] = {}
796                  else:
797                      if self.path[1] == "esphome" and k in [
798                          "platform",
799                          "board",
800                          "arduino_version",
801                          "esp8266_restore_from_flash",
802                      ]:
803                          return prop_name, True
804                      return prop_name, False
805              desc = markdown[markdown.index(": ") + 2 :].strip()
806              if param_type:
807                  desc = "**" + param_type + "**: " + desc
808              config_var["docs"] = desc
809          statistics.props_documented += 1
810          return prop_name, True
811      def find_component(self, component_path):
812          path = component_path.split(".")
813          file_content = get_component_file(self.app, path[0])
814          if path[1] == "platform":
815              path[2] = f"{path[0]}.{path[2]}"
816              path = path[2:]
817          component = file_content
818          for p in path:
819              component = component.get(p, {})
820          return component
821      class Props(MutableMapping):
822          def __init__(self, visitor, component, fail_silently=False):
823              self.visitor = visitor
824              self.component = component
825              self.store = self._get_props(component, fail_silently)
826              self.parent = None
827              self.typed = self.component.get("type") == "typed"
828          def _get_props(self, component, fail_silently):
829              if not (
830                  "config_vars" in component
831                  or "extends" in component
832                  or len(component) == 0
833                  or component.get("type") == "typed"
834              ):
835                  if fail_silently:
836                      return None
837                  raise ValueError("Unexpected component data to get props")
838              props = component.get("config_vars")
839              return props
840          def _find_extended(self, component, key):
841              for extended in component.get("extends", []):
842                  c = self.visitor.get_component_schema(extended)
843                  if c.get("type") == "typed":
844                      p = self.visitor.Props(self.visitor, c)
845                      return p[key]
846                  schema = c.get("schema", {})
847                  for k, cv in schema.get("config_vars", {}).items():
848                      if k == key:
849                          return SetObservable(
850                              cv,
851                              setitem_callback=self._set_extended,
852                              inner_key=key,
853                              original_dict=schema.get("config_vars"),
854                          )
855                  ex1 = self._find_extended(schema, key)
856                  if ex1:
857                      return ex1
858          def _set_extended(self, inner_key, original_dict, key, value):
859              original_dict[inner_key][key] = value
860          def _iter_extended(self, component):
861              for extended in component.get("extends", []):
862                  schema = self.visitor.get_component_schema(extended).get("schema", {})
863                  for s in self._iter_extended(schema):
864                      yield s
865                  yield schema
866          def __getitem__(self, key):
867              if self.store and key in self.store:
868                  return self.store[key]
869              extended = self._find_extended(self.component, key)
870              if extended is not None:
871                  return extended
872              if self.component.get("type") == "typed":
873                  return SetObservable(
874                      {key: {"type": "string"}},
875                      setitem_callback=self._set_typed,
876                      inner_key=key,
877                      original_dict={},
878                  )
879          def _set_typed(self, inner_key, original_dict, key, value):
880              if inner_key == self.component.get("typed_key", "type"):
881                  self.component[key] = value
882              else:
883                  for tk, tv in self.component["types"].items():
884                      for cv_k, cv_v in tv["config_vars"].items():
885                          if cv_k == inner_key:
886                              cv_v[key] = value
887          def __setitem__(self, key, value):
888              self.store[key] = value
889          def __delitem__(self, key):
890              self.store.pop(key)
891          def __iter__(self):
892              return iter(self.store)
893          def __len__(self):
894              len_extended = 0
895              if self.component.get("type"):
896                  types = self.component.get("types")
897                  for t, tv in types.items():
898                      for s in self._iter_extended(types.get(t, {})):
899                          len_extended += len(s.get("config_vars", {}))
900                      len_extended += len(tv.get("config_vars", {}))
901                  return len_extended
902              for s in self._iter_extended(self.component):
903                  len_extended += len(s.get("config_vars", {}))
904              return len_extended + (len(self.store) if self.store else 0)
905      def find_props(self, component, fail_silently=False):
906          if component.get("type") in ["trigger", "schema"]:
907              if "schema" not in component:
908                  return None
909              component = component.get("schema")
910          props = self.Props(self, component, fail_silently)
911          if props:
912              self.filled_props = False
913              self.accept_props = False
914              self.current_prop = None
915          return props
916  def handle_component(app, doctree, docname):
917      path = docname.split("/")
918      if path[0] == "components":
919          pass
920      elif docname not in CUSTOM_DOCS:
921          return
922      try:
923          v = SchemaGeneratorVisitor(app, doctree, docname)
924          doctree.walkabout(v)
925      except Exception as e:
926          err_str = f"In {docname}.rst: {str(e)}"
927          logger.warning(err_str)
928  def build_finished(app, exception):
929      for fname, contents in app.files.items():
930          f = open(SCHEMA_PATH + fname + ".json", "w", newline="\n")
931          if JSON_DUMP_PRETTY:
932              f.write(json.dumps(contents, indent=2))
933          else:
934              f.write(json.dumps(contents, separators=(",", ":")))
935      str = f"Documented: {statistics.props_documented} Enums: {statistics.enums_good}/{statistics.enums_bad}"
936      logger.info(str)
937  class SetObservable(dict):
938      def __init__(
939          self,
940          value,
941          setitem_callback=None,
942          inner_key=None,
943          original_dict=None,
944          *args,
945          **kwargs,
946      ):
947          super(SetObservable, self).__init__(value, *args, **kwargs)
948          self._setitem_callback = setitem_callback
949          self.inner_key = inner_key
950          self.original_dict = original_dict
951      def __setitem__(self, key, value):
952          if self._setitem_callback:
953              self._setitem_callback(self.inner_key, self.original_dict, key, value)
954          super(SetObservable, self).__setitem__(key, value)
955  def is_component_file(app: SchemaGeneratorVisitor, component):
956      if component == "core" or component == "automation":
957          component = "esphome"
958      return exists(SCHEMA_PATH + component + ".json")
959  def get_component_file(app: SchemaGeneratorVisitor, component):
960      if component == "core" or component == "automation":
961          component = "esphome"
962      if component not in app.files:
963          app.files[component] = read_file(component)
964      return app.files[component]
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-fields_17.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</div>
                <div class="column column_space"><pre><code>65                  for efuse in self.Fields.BLOCK2_CALIBRATION_EFUSES
66              ]
67          else:
68              if self["BLK_VERSION_MINOR"].get() == 1:
69                  self.efuses += [
70                      EfuseField.convert(self, efuse)
</pre></code></div>
                <div class="column column_space"><pre><code>613              stack_prop, stack_node = self.prop_stack[-1]
614              if stack_node == node:
615                  self.prop_stack.pop()
616                  self.filled_props = True
617                  self.current_prop = stack_prop
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    