<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for exception.py &amp; device.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for exception.py &amp; device.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>exception.py (6.3324537%)<th>device.py (1.717967%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(223-231)<td><a href="#" name="0">(205-219)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(31-36)<td><a href="#" name="1">(1280-1287)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>exception.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import re
2 from jnpr.junos import jxml
3 from jnpr.junos import jxml as JXML
4 from lxml.etree import _Element
5 from ncclient.operations.rpc import RPCError
6 class FactLoopError(RuntimeError):
7     pass
8 class RpcError(Exception):
9     def __init__(self, cmd=None, rsp=None, errs=None, dev=None, timeout=None, re=None):
10         self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.cmd = cmd
11         self.rsp = rsp
12         self.dev = dev
13         self.timeout = timeout
14         self.re = re
15         self.rpc_error =</b></font> None
16         self.xml = rsp
17         if isinstance(errs, RPCError) and hasattr(errs, "errors"):
18             self.errs = [JXML.rpc_error(error.xml) for error in errs.errors]
19             for error in errs.errors:
20                 if error.severity == "error":
21                     self.rsp = JXML.remove_namespaces(error.xml)
22                     break
23             else:
24                 if errs.severity == "warning":
25                     for error in errs.errors:
26                         if error.severity == "warning":
27                             self.rsp = JXML.remove_namespaces(error.xml)
28                             break
29             self.message = errs.message
30         else:
31             self.errs = errs
32             self.message = (
33                 "\n".join(
34                     [
35                         "%s: %s" % (err["severity"].strip(), err["message"].strip())
36                         for err in errs
37                         if err["message"] is not None and err["severity"] is not None
38                     ]
39                 )
40                 if isinstance(errs, list)
41                 else ""
42             )
43         if isinstance(self.rsp, _Element):
44             self.rpc_error = jxml.rpc_error(self.rsp)
45             self.message = self.message or self.rpc_error["message"]
46             if self.errs is None or not isinstance(self.errs, list):
47                 self.errs = [self.rpc_error]
48     def __repr__(self):
49         if self.rpc_error is not None:
50             return "{}(severity: {}, bad_element: {}, message: {})".format(
51                 self.__class__.__name__,
52                 self.rpc_error["severity"],
53                 self.rpc_error["bad_element"],
54                 self.message,
55             )
56         else:
57             return self.__class__.__name__
58     __str__ = __repr__
59 class CommitError(RpcError):
60     def __init__(self, rsp, cmd=None, errs=None):
61         RpcError.__init__(self, cmd, rsp, errs)
62     def __repr__(self):
63         return "{}(edit_path: {}, bad_element: {}, message: {})".format(
64             self.__class__.__name__,
65             self.rpc_error["edit_path"],
66             self.rpc_error["bad_element"],
67             self.message,
68         )
69     __str__ = __repr__
70 class ConfigLoadError(RpcError):
71     def __init__(self, rsp, cmd=None, errs=None):
72         RpcError.__init__(self, cmd, rsp, errs)
73     def __repr__(self):
74         return "{}(severity: {}, bad_element: {}, message: {})".format(
75             self.__class__.__name__,
76             self.rpc_error["severity"],
77             self.rpc_error["bad_element"],
78             self.message,
79         )
80     __str__ = __repr__
81 class LockError(RpcError):
82     def __init__(self, rsp):
83         RpcError.__init__(self, rsp=rsp)
84 class UnlockError(RpcError):
85     def __init__(self, rsp):
86         RpcError.__init__(self, rsp=rsp)
87 class PermissionError(RpcError):
88     def __init__(self, rsp, cmd=None, errs=None):
89         RpcError.__init__(self, cmd=cmd, rsp=rsp, errs=errs)
90         self.message = rsp.findtext(".//bad-element")
91 class RpcTimeoutError(RpcError):
92     def __init__(self, dev, cmd, timeout):
93         RpcError.__init__(self, dev=dev, cmd=cmd, timeout=timeout)
94     def __repr__(self):
95         return "{}(host: {}, cmd: {}, timeout: {})".format(
96             self.__class__.__name__, self.dev.hostname, self.cmd, self.timeout
97         )
98     __str__ = __repr__
99 class SwRollbackError(RpcError):
100     def __init__(self, rsp, re=None):
101         RpcError.__init__(self, re=re, rsp=rsp)
102     def __repr__(self):
103         if self.re:
104             return "{}(re: {}, output: {})".format(
105                 self.__class__.__name__, self.re, self.rsp
106             )
107         else:
108             return "{}(output: {})".format(self.__class__.__name__, self.rsp)
109     __str__ = __repr__
110 class ConnectError(Exception):
111     def __init__(self, dev, msg=None):
112         self.dev = dev
113         self._orig = msg
114     def user(self):
115         return self.dev<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user
116     @property
117     def host(self):
118         return self.dev.hostname
119     @property
120     def</b></font> port(self):
121         return self.dev._port
122     @property
123     def msg(self):
124         return self._orig
125     def __repr__(self):
126         if self._orig:
127             return "{}(host: {}, msg: {})".format(
128                 self.__class__.__name__, self.dev.hostname, self._orig
129             )
130         else:
131             return "{}({})".format(self.__class__.__name__, self.dev.hostname)
132     __str__ = __repr__
133 class ProbeError(ConnectError):
134     pass
135 class ConnectAuthError(ConnectError):
136     pass
137 class ConnectTimeoutError(ConnectError):
138     pass
139 class ConnectUnknownHostError(ConnectError):
140     pass
141 class ConnectRefusedError(ConnectError):
142     pass
143 class ConnectNotMasterError(ConnectError):
144     pass
145 class ConnectClosedError(ConnectError):
146     def __init__(self, dev):
147         ConnectError.__init__(self, dev=dev)
148         dev.connected = False
149 class JSONLoadError(Exception):
150     def __init__(self, exception, rpc_content):
151         self.ex_msg = str(exception)
152         self.rpc_content = rpc_content
153         self.offending_line = ""
154         obj = re.search("line (\d+)", self.ex_msg)
155         if obj:
156             line_no = int(obj.group(1))
157             rpc_lines = rpc_content.splitlines()
158             for line in range(line_no - 3, line_no + 2):
159                 self.offending_line += "%s: %s\n" % (line + 1, rpc_lines[line])
160     def __repr__(self):
161         if self.offending_line:
162             return (
163                 "{}(reason: {}, \nThe offending config appears "
164                 "to be: \n{})".format(
165                     self.__class__.__name__, self.ex_msg, self.offending_line
166                 )
167             )
168         else:
169             return "{}(reason: {})".format(self.__class__.__name__, self.ex_msg)
170     __str__ = __repr__
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>device.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import six
3 import types
4 import platform
5 import warnings
6 import logging
7 import socket
8 import datetime
9 import time
10 import sys
11 import json
12 import re
13 from lxml import etree
14 from ncclient import manager as netconf_ssh
15 import ncclient.transport.errors as NcErrors
16 from ncclient.transport.session import SessionListener
17 import ncclient.operations.errors as NcOpErrors
18 from ncclient.operations import RPCError
19 import paramiko
20 import jinja2
21 from jnpr.junos.rpcmeta import _RpcMetaExec
22 from jnpr.junos import exception as EzErrors
23 from jnpr.junos.factcache import _FactCache
24 from jnpr.junos.ofacts import *
25 from jnpr.junos import jxml as JXML
26 from jnpr.junos.decorators import (
27     timeoutDecorator,
28     normalizeDecorator,
29     ignoreWarnDecorator,
30 )
31 from jnpr.junos.exception import JSONLoadError, ConnectError
32 from ncclient.operations.third_party.juniper.rpc import ExecuteRpc
33 import inspect
34 if sys.version_info.major &gt;= 3:
35     NCCLIENT_FILTER_XML = len(inspect.signature(ExecuteRpc.request).parameters) == 3
36 else:
37     NCCLIENT_FILTER_XML = len(inspect.getargspec(ExecuteRpc.request).args) == 3
38 _MODULEPATH = os.path.dirname(__file__)
39 logger = logging.getLogger("jnpr.junos.device")
40 class _MyTemplateLoader(jinja2.BaseLoader):
41     def __init__(self):
42         self.paths = [".", os.path.join(_MODULEPATH, "templates")]
43     def get_source(self, environment, template):
44         def _in_path(dir):
45             return os.path.exists(os.path.join(dir, template))
46         path = list(filter(_in_path, self.paths))
47         if not path:
48             raise jinja2.TemplateNotFound(template)
49         path = os.path.join(path[0], template)
50         mtime = os.path.getmtime(path)
51         with open(path) as f:
52             source = f.read()
53         return source, path, lambda: mtime == os.path.getmtime(path)
54 _Jinja2ldr = jinja2.Environment(loader=_MyTemplateLoader())
55 class _Connection(object):
56     ON_JUNOS = (
57         platform.system().upper() == "JUNOS"
58         or platform.release().startswith("JNPR")
59         or os.path.isfile("/usr/share/cevo/cevo_version")
60     )
61     if ON_JUNOS is False:
62         if os.path.isfile("/etc/product.conf") is True:
63             model_dict = {}
64             with open("/etc/product.conf") as f:
65                 for line in f:
66                     if "=" in line:
67                         (key, val) = line.strip().split("=")
68                         model_dict[key] = val
69             if "model" in model_dict and model_dict["model"] in [
70                 "crpd",
71                 "cbng",
72                 "cmgd",
73             ]:
74                 ON_JUNOS = True
75     auto_probe = 0  # default is no auto-probe
76     @property
77     def hostname(self):
78         return (
79             self._hostname
80             if (self._hostname != "localhost")
81             else self.facts.get("hostname")
82         )
83     @property
84     def user(self):
85         return self._auth_user
86     @property
87     def password(self):
88         return None  # read-only
89     @password.setter
90     def password(self, value):
91         self._auth_password = value
92     @property
93     def logfile(self):
94         return self._logfile
95     @logfile.setter
96     def logfile(self, value):
97         if (not value) and (self._logfile is not None):
98             rc = self._logfile.close()
99             self._logfile = False
100             return rc
101         if sys.version &lt; "3":
102             if not isinstance(value, file):
103                 raise ValueError("value must be a file object")
104         else:
105             import io
106             if not isinstance(value, io.TextIOWrapper):
107         self._logfile = value
108         return self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._logfile
109     @property
110     def timeout(self):
111         return self._conn.timeout
112     @timeout.setter
113     def</b></font> timeout(self, value):
114         try:
115             self._conn.timeout = int(value)
116         except (ValueError, TypeError):
117             raise RuntimeError(
118                 "could not convert timeout value of %s to an " "integer" % (value)
119             )
120     @property
121     def ofacts(self):
122         if self._fact_style != "old" and self._fact_style != "both":
123             raise RuntimeError("Old-style facts gathering is not in use!")
124         if self._ofacts == {} and self.connected:
125             self.facts_refresh()
126         return self._ofacts
127     @ofacts.setter
128     def ofacts(self, value):
129         raise RuntimeError("facts is read-only!")
130     @property
131     def port(self):
132         return self._port
133     @property
134     def master(self):
135         master = None
136         if self.facts.get("current_re") is not None:
137             if "master" in self.facts["current_re"]:
138                 master = True
139             elif "backup" in self.facts["current_re"]:
140                 master = False
141             elif (
142                 self.facts.get("2RE") is False
143                 and self.facts.get("RE_hw_mi") is False
144                 and "re0" in self.facts["current_re"]
145             ):
146                 master = True
147             elif self.facts.get("srx_cluster") is True:
148                 if "primary" in self.facts["current_re"]:
149                     master = True
150                 else:
151                     master = False
152             else:
153                 if (
154                     self.re_name is not None
155                     and "gnf" in self.re_name
156                     and "-re" in self.re_name
157                 ):
158                     (gnf, _) = self.re_name.split("-re", 1)
159                     if gnf + "-master" in self.facts.get("current_re"):
160                         master = True
161                     elif gnf + "-backup" in self.facts.get("current_re"):
162                         master = False
163                 else:
164                     for re_state in self.facts["current_re"]:
165                         if "-backup" in re_state or "-master" in re_state:
166                             master = False
167                             break
168         return master
169     @master.setter
170     def master(self, value):
171         raise RuntimeError("master is read-only!")
172     @property
173     def uptime(self):
174         uptime = None
175         rsp = self.rpc.get_system_uptime_information(normalize=True)
176         if rsp is not None:
177             element = rsp.find(".//system-booted-time/time-length")
178             if element is not None:
179                 uptime_string = element.get("seconds")
180                 if uptime_string is not None:
181                     uptime = int(uptime_string)
182         return uptime
183     @uptime.setter
184     def uptime(self, value):
185         raise RuntimeError("uptime is read-only!")
186     @property
187     def re_name(self):
188         re_name = None
189         if (
190             self.facts.get("current_re") is not None
191             and self.facts.get("hostname_info") is not None
192         ):
193             intersect = set(self.facts["current_re"]) &amp; set(
194                 self.facts["hostname_info"].keys()
195             )
196             if len(intersect) == 1:
197                 re_name = list(intersect)[0]
198             elif len(intersect) == 0:
199                 for re_state in self.facts["current_re"]:
200                     if "-re" in re_state:
201                         re_name = re_state
202                         break
203                 if re_name is None:
204                     all_re_names = list(self.facts["hostname_info"].keys())
205                     if len(all_re_names) == 1:
206                         re_name = all_re_names[0]
207                 if re_name is None:
208                     for re_state in self.facts["current_re"]:
209                         match = re.search("^re\d+$", re_state)
210                         if match:
211                             re_string = "bsys-" + match.group(0)
212                             if re_string in self.facts["hostname_info"].keys():
213                                 re_name = re_string
214         return re_name
215     @re_name.setter
216     def re_name(self, value):
217         raise RuntimeError("re_name is read-only!")
218     def _sshconf_lkup(self):
219         if self.__class__.__name__ == "Device" and self._sock_fd is not None:
220             return None
221         if self._ssh_config:
222             sshconf_path = os.path.expanduser(self._ssh_config)
223         else:
224             sshconf_path = os.path.join(os.path.expanduser("~"), ".ssh", "config")
225         if not os.path.exists(sshconf_path):
226             return None
227         else:
228             sshconf = paramiko.SSHConfig()
229             with open(sshconf_path, "r") as fp:
230                 sshconf.parse(fp)
231                 found = sshconf.lookup(self._hostname)
232                 self._port = found.get("port", self._port)
233                 self._conf_auth_user = found.get("user")
234                 self._conf_ssh_private_key_file = found.get("identityfile")
235             return sshconf_path
236     def display_xml_rpc(self, command, format="xml"):
237         try:
238             command = command + "| display xml rpc"
239             rsp = self.rpc.cli(command, format="xml")
240             rsp = rsp.getparent().find(".//rpc")
241             if format == "text":
242                 encode = None if sys.version &lt; "3" else "unicode"
243                 return etree.tostring(rsp[0], encoding=encode)
244             return rsp[0]
245         except TypeError:
246             return "No RPC equivalent found for: " + command
247         except:
248             return "invalid command: " + command
249     def Template(self, filename, parent=None, gvars=None):
250         return self._j2ldr.get_template(filename, parent, gvars)
251     @property
252     def manages(self):
253         return self._manages
254     def bind(self, *vargs, **kvargs):
255         if len(vargs):
256             for fn in vargs:
257                 if hasattr(self, fn.__name__):
258                     raise ValueError(
259                         "request attribute name %s already exists" % fn.__name__
260                     )
261             for fn in vargs:
262                 if sys.version &lt; "3":
263                     self.__dict__[fn.__name__] = types.MethodType(
264                         fn, self, self.__class__
265                     )
266                 else:
267                     self.__dict__[fn.__name__] = types.MethodType(fn, self.__class__)
268             return
269         for name in kvargs.keys():
270             if hasattr(self, name):
271                 raise ValueError("requested attribute name %s already exists" % name)
272         for name, thing in kvargs.items():
273             new_inst = thing(self)
274             self.__dict__[name] = new_inst
275             self._manages.append(name)
276     @property
277     def _sshconf_path(self):
278         return self._sshconf_lkup()
279     def probe(self, timeout=5, intvtimeout=1):
280         start = datetime.datetime.now()
281         end = start + datetime.timedelta(seconds=timeout)
282         probe_ok = True
283         while datetime.datetime.now() &lt; end:
284             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
285             s.settimeout(intvtimeout)
286             try:
287                 s.connect((self.hostname, int(self._port)))
288                 s.shutdown(socket.SHUT_RDWR)
289                 s.close()
290                 break
291             except:
292                 time.sleep(1)
293                 pass
294         else:
295             probe_ok = False
296         return probe_ok
297     def cli_to_rpc_string(self, command):
298         (command, _, _) = command.partition("|")
299         command = command.strip()
300         rpc = self.display_xml_rpc(command)
301         if isinstance(rpc, six.string_types):
302             return None
303         rpc_string = "rpc.%s(" % (rpc.tag.replace("-", "_"))
304         arguments = []
305         for child in rpc:
306             key = child.tag.replace("-", "_")
307             if child.text:
308                 value = "'" + child.text + "'"
309             else:
310                 value = "True"
311             arguments.append("%s=%s" % (key, value))
312         if arguments:
313             rpc_string += ", ".join(arguments)
314         rpc_string += ")"
315         return rpc_string
316     def cli(self, command, format="text", warning=True):
317         if "display xml rpc" not in command and warning is True:
318             rpc_string = self.cli_to_rpc_string(command)
319             if rpc_string is not None:
320                 warning_string = "\nCLI command is for debug use only!\n"
321                 warning_string += "Instead of:\ncli('%s')\n" % (command)
322                 warning_string += "Use:\n%s\n" % (rpc_string)
323                 warnings.simplefilter("always")
324                 warnings.warn(warning_string, RuntimeWarning)
325                 warnings.resetwarnings()
326         try:
327             rsp = self.rpc.cli(command=command, format=format)
328             if isinstance(rsp, dict) and format.lower() == "json":
329                 return rsp
330             if rsp is True:
331                 return ""
332             if rsp.tag in ["output", "rpc-reply"]:
333                 encode = None if sys.version &lt; "3" else "unicode"
334                 return etree.tostring(
335                     rsp, method="text", with_tail=False, encoding=encode
336                 )
337             if rsp.tag == "configuration-information":
338                 return rsp.findtext("configuration-output")
339             if rsp.tag == "rpc":
340                 return rsp[0]
341             return rsp
342         except (
343             EzErrors.ConnectClosedError,
344             EzErrors.RpcError,
345             EzErrors.RpcTimeoutError,
346         ) as ex:
347             raise ex
348         except Exception as ex:
349             warnings.warn(
350                 "An unknown exception occurred : %s - please report." % ex,
351                 RuntimeWarning,
352             )
353             raise ex
354     @normalizeDecorator
355     @timeoutDecorator
356     def execute(self, rpc_cmd, ignore_warning=False, **kvargs):
357         if self.connected is not True:
358             raise EzErrors.ConnectClosedError(self)
359         if isinstance(rpc_cmd, str):
360             rpc_cmd_e = etree.XML(rpc_cmd)
361         elif isinstance(rpc_cmd, etree._Element):
362             rpc_cmd_e = rpc_cmd
363         else:
364             raise ValueError(
365                 "Dont know what to do with rpc of type %s" % rpc_cmd.__class__.__name__
366             )
367         try:
368             rpc_rsp_e = self._rpc_reply(
369                 rpc_cmd_e,
370                 ignore_warning=ignore_warning,
371                 filter_xml=kvargs.get("filter_xml"),
372             )
373         except NcOpErrors.TimeoutExpiredError:
374             raise EzErrors.RpcTimeoutError(self, rpc_cmd_e.tag, self.timeout)
375         except NcErrors.TransportError:
376             raise EzErrors.ConnectClosedError(self)
377         except RPCError as ex:
378             if hasattr(ex, "xml"):
379                 rsp = JXML.remove_namespaces(ex.xml)
380                 message = rsp.findtext("error-message")
381                 if message and message == "permission denied":
382                     raise EzErrors.PermissionError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
383             else:
384                 rsp = None
385             raise EzErrors.RpcError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
386         except Exception as err:
387             warnings.warn(
388                 "An unknown exception occurred - please report.", RuntimeWarning
389             )
390             raise
391         if rpc_cmd_e.tag != "load-configuration" and rpc_cmd_e.attrib.get("format") in [
392             "json",
393             "JSON",
394         ]:
395             ver_info = self.facts.get("version_info")
396             if (
397                 ver_info
398                 and ver_info.major[0] &gt;= 15
399                 or (ver_info.major[0] == 14 and ver_info.major[1] &gt;= 2)
400             ):
401                 try:
402                     return json.loads(rpc_rsp_e.text, strict=False)
403                 except ValueError as ex:
404                     if str(ex).startswith("Extra data"):
405                         return json.loads(re.sub("\s?{\s?}\s?", "", rpc_rsp_e.text))
406                     else:
407                         raise JSONLoadError(ex, rpc_rsp_e.text)
408             else:
409                 warnings.warn(
410                     "Native JSON support is only from 14.2 onwards", RuntimeWarning
411                 )
412         try:
413             ret_rpc_rsp = rpc_rsp_e[0]
414         except IndexError:
415             if rpc_rsp_e.text is not None and rpc_rsp_e.text.strip() is not "":
416                 return rpc_rsp_e
417             return True
418         if kvargs.get("to_py"):
419             return kvargs["to_py"](self, ret_rpc_rsp, **kvargs)
420         else:
421             return ret_rpc_rsp
422     def facts_refresh(
423         self, exception_on_failure=False, warnings_on_failure=None, keys=None
424     ):
425         if self._fact_style not in ["old", "new", "both"]:
426             raise RuntimeError("Unknown fact_style: %s" % (self._fact_style))
427         if self._fact_style == "old" or self._fact_style == "both":
428             if warnings_on_failure is None:
429                 warnings_on_failure = True
430             if keys is not None:
431                 raise RuntimeError(
432                     "The keys argument can not be specified "
433                     "when old-style fact gathering is in use!"
434                 )
435             should_warn = False
436             for gather in FACT_LIST:
437                 try:
438                     gather(self, self._ofacts)
439                 except:
440                     if exception_on_failure:
441                         raise
442                     should_warn = True
443             if (
444                 warnings_on_failure is True
445                 and should_warn is True
446                 and self._fact_style != "both"
447             ):
448                 warnings.warn(
449                     "Facts gathering is incomplete. "
450                     "To know the reason call "
451                     '"dev.facts_refresh(exception_on_failure=True)"',
452                     RuntimeWarning,
453                 )
454         if self._fact_style == "new" or self._fact_style == "both":
455             if warnings_on_failure is None:
456                 warnings_on_failure = False
457             self.facts._refresh(
458                 exception_on_failure=exception_on_failure,
459                 warnings_on_failure=warnings_on_failure,
460                 keys=keys,
461             )
462         return
463     def __repr__(self):
464         return "Device(%s)" % self.hostname
465 class DeviceSessionListener(SessionListener):
466     def __init__(self, device):
467         self._device = device
468     def callback(self, root, raw):
469         pass
470     def errback(self, ex):
471         self._device.connected = False
472 class Device(_Connection):
473     @property
474     def transform(self):
475         try:
476             return self._conn._device_handler.transform_reply
477         except AttributeError:
478             if self._conn is None:
479                 raise ConnectError(self, "Not connected to the Device")
480     @transform.setter
481     def transform(self, func):
482         self._conn._device_handler.transform_reply = func
483     def __new__(cls, *args, **kwargs):
484         if (
485             kwargs.get("port") in [23, "23"]
486             or kwargs.get("mode")
487             or kwargs.get("cs_user") is not None
488         ):
489             from jnpr.junos.console import Console
490             if kwargs.get("conn_open_timeout", None):
491                 kwargs["timeout"] = kwargs.pop("conn_open_timeout")
492             instance = object.__new__(Console, *args, **kwargs)
493             kwargs["host"] = args[0] if len(args) else kwargs.get("host")
494             instance.__init__(**kwargs)
495             return instance
496         else:
497             if sys.version &lt; "3":
498                 return super(Device, cls).__new__(cls, *args, **kwargs)
499             else:
500                 return super().__new__(cls)
501     def __init__(self, *vargs, **kvargs):
502         hostname = vargs[0] if len(vargs) else kvargs.get("host")
503         self._port = kvargs.get("port", 830)
504         self._sock_fd = kvargs.get("sock_fd", None)
505         self._gather_facts = kvargs.get("gather_facts", True)
506         self._normalize = kvargs.get("normalize", False)
507         self._auto_probe = kvargs.get("auto_probe", self.__class__.auto_probe)
508         self._fact_style = kvargs.get("fact_style", "new")
509         self._use_filter = kvargs.get("use_filter", False)
510         self._huge_tree = kvargs.get("huge_tree", False)
511         self._conn_open_timeout = kvargs.get("conn_open_timeout", None)
512         if self._fact_style != "new":
513             warnings.warn(
514                 "fact-style %s will be removed in a future "
515                 "release." % (self._fact_style),
516                 RuntimeWarning,
517             )
518         if self.__class__.ON_JUNOS is True and hostname is None:
519             self._auth_user = None
520             self._auth_password = None
521             self._hostname = "localhost"
522             self._ssh_private_key_file = None
523             self._ssh_config = None
524         else:
525             if hostname is None and self._sock_fd is None:
526                 raise ValueError("You must provide either 'host' or 'sock_fd' value")
527             self._hostname = hostname
528             self._auth_user = os.getenv("USER")
529             self._conf_auth_user = None
530             self._conf_ssh_private_key_file = None
531             self._ssh_config = kvargs.get("ssh_config")
532             self._sshconf_lkup()
533             self._auth_user = (
534                 kvargs.get("user") or self._conf_auth_user or self._auth_user
535             )
536             self._ssh_private_key_file = (
537                 kvargs.get("ssh_private_key_file") or self._conf_ssh_private_key_file
538             )
539             self._auth_password = kvargs.get("password") or kvargs.get("passwd")
540         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._conn = None
541         self._j2ldr = _Jinja2ldr
542         self._manages = []
543         self._ofacts = {}
544         self.connected = False
545         self.rpc =</b></font> _RpcMetaExec(self)
546         if self._fact_style == "old":
547             self.facts = self.ofacts
548         else:
549             self.facts = _FactCache(self)
550     @property
551     def connected(self):
552         return self._connected
553     @connected.setter
554     def connected(self, value):
555         if value in [True, False]:
556             self._connected = value
557     def open(self, *vargs, **kvargs):
558         auto_probe = kvargs.get("auto_probe", self._auto_probe)
559         if auto_probe is not 0:
560             if not self.probe(auto_probe):
561                 raise EzErrors.ProbeError(self)
562         try:
563             ts_start = datetime.datetime.now()
564             allow_agent = bool(
565                 (self._auth_password is None) and (self._ssh_private_key_file is None)
566             )
567             self._conn = netconf_ssh.connect(
568                 host=self._hostname,
569                 port=self._port,
570                 sock_fd=self._sock_fd,
571                 username=self._auth_user,
572                 password=self._auth_password,
573                 hostkey_verify=False,
574                 key_filename=self._ssh_private_key_file,
575                 allow_agent=allow_agent,
576                 ssh_config=self._sshconf_lkup(),
577                 timeout=self._conn_open_timeout,
578                 device_params={
579                     "name": "junos",
580                     "local": self.__class__.ON_JUNOS,
581                     "use_filter": self._use_filter,
582                 },
583             )
584             self._conn._session.add_listener(DeviceSessionListener(self))
585         except NcErrors.AuthenticationError as err:
586             raise EzErrors.ConnectAuthError(self)
587         except NcErrors.SSHError as err:
588             ts_err = datetime.datetime.now()
589             diff_ts = ts_err - ts_start
590             if diff_ts.seconds &lt; 3:
591                 raise EzErrors.ConnectRefusedError(self)
592             if str(err).find("not open") &gt; 0:
593                 raise EzErrors.ConnectTimeoutError(self)
594             else:
595                 cnx = EzErrors.ConnectError(self)
596                 cnx._orig = err
597                 raise cnx
598         except socket.gaierror:
599             raise EzErrors.ConnectUnknownHostError(self)
600         except Exception as err:
601             cnx_err = EzErrors.ConnectError(self)
602             cnx_err._orig = err
603             raise cnx_err
604         if self._huge_tree:
605             self._conn.huge_tree = True
606         self.connected = True
607         self._nc_transform = self.transform
608         self._norm_transform = lambda: JXML.normalize_xslt.encode("UTF-8")
609         self._normalize = kvargs.get("normalize", self._normalize)
610         if self._normalize is True:
611             self.transform = self._norm_transform
612         gather_facts = kvargs.get("gather_facts", self._gather_facts)
613         if gather_facts is True:
614             self.facts_refresh()
615         return self
616     def close(self):
617         if self.connected is True:
618             self.connected = False
619             try:
620                 self._conn.close_session()
621             except NcOpErrors.TimeoutExpiredError:
622                 raise EzErrors.RpcTimeoutError(self, "close", self.timeout)
623             except NcErrors.SessionCloseError:
624                 pass
625     @ignoreWarnDecorator
626     def _rpc_reply(self, rpc_cmd_e, filter_xml=None):
627         if NCCLIENT_FILTER_XML:
628             return self._conn.rpc(rpc_cmd_e, filter_xml)._NCElement__doc
629         else:
630             return self._conn.rpc(rpc_cmd_e)._NCElement__doc
631     def __enter__(self):
632         self.open()
633         return self
634     def __exit__(self, exc_type, exc_val, exc_tb):
635         if self._conn.connected and not isinstance(exc_val, EzErrors.ConnectError):
636             try:
637                 self.close()
638             except Exception as ex:
639                 logger.error("Close in context manager hit exception: {}".format(ex))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
