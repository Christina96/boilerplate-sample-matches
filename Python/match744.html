<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for exception.py &amp; device.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for exception.py &amp; device.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>exception.py (6.3324537%)<th>device.py (1.717967%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(223-231)<td><a href="#" name="0">(205-219)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(31-36)<td><a href="#" name="1">(1280-1287)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>exception.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import re
2 from jnpr.junos import jxml
3 from jnpr.junos import jxml as JXML
4 from lxml.etree import _Element
5 from ncclient.operations.rpc import RPCError
6 class FactLoopError(RuntimeError):
7     pass
8 class RpcError(Exception):
9     def __init__(self, cmd=None, rsp=None, errs=None, dev=None, timeout=None, re=None):
10         self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.cmd = cmd
11         self.rsp = rsp
12         self.dev = dev
13         self.timeout = timeout
14         self.re = re
15         self.rpc_error =</b></font> None
16         self.xml = rsp
17         if isinstance(errs, RPCError) and hasattr(errs, "errors"):
18             self.errs = [JXML.rpc_error(error.xml) for error in errs.errors]
19             for error in errs.errors:
20                 if error.severity == "error":
21                     self.rsp = JXML.remove_namespaces(error.xml)
22                     break
23             else:
24                 if errs.severity == "warning":
25                     for error in errs.errors:
26                         if error.severity == "warning":
27                             self.rsp = JXML.remove_namespaces(error.xml)
28                             break
29             self.message = errs.message
30         else:
31             self.errs = errs
32             self.message = (
33                 "\n".join(
34                     [
35                         "%s: %s" % (err["severity"].strip(), err["message"].strip())
36                         for err in errs
37                         if err["message"] is not None and err["severity"] is not None
38                     ]
39                 )
40                 if isinstance(errs, list)
41                 else ""
42             )
43         if isinstance(self.rsp, _Element):
44             self.rpc_error = jxml.rpc_error(self.rsp)
45             self.message = self.message or self.rpc_error["message"]
46             if self.errs is None or not isinstance(self.errs, list):
47                 self.errs = [self.rpc_error]
48     def __repr__(self):
49         if self.rpc_error is not None:
50             return "{}(severity: {}, bad_element: {}, message: {})".format(
51                 self.__class__.__name__,
52                 self.rpc_error["severity"],
53                 self.rpc_error["bad_element"],
54                 self.message,
55             )
56         else:
57             return self.__class__.__name__
58     __str__ = __repr__
59 class CommitError(RpcError):
60     def __init__(self, rsp, cmd=None, errs=None):
61         RpcError.__init__(self, cmd, rsp, errs)
62     def __repr__(self):
63         return "{}(edit_path: {}, bad_element: {}, message: {})".format(
64             self.__class__.__name__,
65             self.rpc_error["edit_path"],
66             self.rpc_error["bad_element"],
67             self.message,
68         )
69     __str__ = __repr__
70 class ConfigLoadError(RpcError):
71     def __init__(self, rsp, cmd=None, errs=None):
72         RpcError.__init__(self, cmd, rsp, errs)
73     def __repr__(self):
74         return "{}(severity: {}, bad_element: {}, message: {})".format(
75             self.__class__.__name__,
76             self.rpc_error["severity"],
77             self.rpc_error["bad_element"],
78             self.message,
79         )
80     __str__ = __repr__
81 class LockError(RpcError):
82     def __init__(self, rsp):
83         RpcError.__init__(self, rsp=rsp)
84 class UnlockError(RpcError):
85     def __init__(self, rsp):
86         RpcError.__init__(self, rsp=rsp)
87 class PermissionError(RpcError):
88     def __init__(self, rsp, cmd=None, errs=None):
89         RpcError.__init__(self, cmd=cmd, rsp=rsp, errs=errs)
90         self.message = rsp.findtext(".//bad-element")
91 class RpcTimeoutError(RpcError):
92     def __init__(self, dev, cmd, timeout):
93         RpcError.__init__(self, dev=dev, cmd=cmd, timeout=timeout)
94     def __repr__(self):
95         return "{}(host: {}, cmd: {}, timeout: {})".format(
96             self.__class__.__name__, self.dev.hostname, self.cmd, self.timeout
97         )
98     __str__ = __repr__
99 class SwRollbackError(RpcError):
100     def __init__(self, rsp, re=None):
101         RpcError.__init__(self, re=re, rsp=rsp)
102     def __repr__(self):
103         if self.re:
104             return "{}(re: {}, output: {})".format(
105                 self.__class__.__name__, self.re, self.rsp
106             )
107         else:
108             return "{}(output: {})".format(self.__class__.__name__, self.rsp)
109     __str__ = __repr__
110 class ConnectError(Exception):
111     def __init__(self, dev, msg=None):
112         self.dev = dev
113         self._orig = msg
114 <a name="0"></a>    @property
115     def user(self):
116         return self.dev<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user
117     @property
118     def host(self):
119         return self.dev.hostname
120     @property
121     def</b></font> port(self):
122         return self.dev._port
123     @property
124     def msg(self):
125         return self._orig
126     def __repr__(self):
127         if self._orig:
128             return "{}(host: {}, msg: {})".format(
129                 self.__class__.__name__, self.dev.hostname, self._orig
130             )
131         else:
132             return "{}({})".format(self.__class__.__name__, self.dev.hostname)
133     __str__ = __repr__
134 class ProbeError(ConnectError):
135     pass
136 class ConnectAuthError(ConnectError):
137     pass
138 class ConnectTimeoutError(ConnectError):
139     pass
140 class ConnectUnknownHostError(ConnectError):
141     pass
142 class ConnectRefusedError(ConnectError):
143     pass
144 class ConnectNotMasterError(ConnectError):
145     pass
146 class ConnectClosedError(ConnectError):
147     def __init__(self, dev):
148         ConnectError.__init__(self, dev=dev)
149         dev.connected = False
150 class JSONLoadError(Exception):
151     def __init__(self, exception, rpc_content):
152         self.ex_msg = str(exception)
153         self.rpc_content = rpc_content
154         self.offending_line = ""
155         obj = re.search("line (\d+)", self.ex_msg)
156         if obj:
157             line_no = int(obj.group(1))
158             rpc_lines = rpc_content.splitlines()
159             for line in range(line_no - 3, line_no + 2):
160                 self.offending_line += "%s: %s\n" % (line + 1, rpc_lines[line])
161     def __repr__(self):
162         if self.offending_line:
163             return (
164                 "{}(reason: {}, \nThe offending config appears "
165                 "to be: \n{})".format(
166                     self.__class__.__name__, self.ex_msg, self.offending_line
167                 )
168             )
169         else:
170             return "{}(reason: {})".format(self.__class__.__name__, self.ex_msg)
171     __str__ = __repr__
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>device.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import six
3 import types
4 import platform
5 import warnings
6 import logging
7 import socket
8 import datetime
9 import time
10 import sys
11 import json
12 import re
13 from lxml import etree
14 from ncclient import manager as netconf_ssh
15 import ncclient.transport.errors as NcErrors
16 from ncclient.transport.session import SessionListener
17 import ncclient.operations.errors as NcOpErrors
18 from ncclient.operations import RPCError
19 import paramiko
20 import jinja2
21 from jnpr.junos.rpcmeta import _RpcMetaExec
22 from jnpr.junos import exception as EzErrors
23 from jnpr.junos.factcache import _FactCache
24 from jnpr.junos.ofacts import *
25 from jnpr.junos import jxml as JXML
26 from jnpr.junos.decorators import (
27     timeoutDecorator,
28     normalizeDecorator,
29     ignoreWarnDecorator,
30 )
31 from jnpr.junos.exception import JSONLoadError, ConnectError
32 from ncclient.operations.third_party.juniper.rpc import ExecuteRpc
33 import inspect
34 if sys.version_info.major &gt;= 3:
35     NCCLIENT_FILTER_XML = len(inspect.signature(ExecuteRpc.request).parameters) == 3
36 else:
37     NCCLIENT_FILTER_XML = len(inspect.getargspec(ExecuteRpc.request).args) == 3
38 _MODULEPATH = os.path.dirname(__file__)
39 logger = logging.getLogger("jnpr.junos.device")
40 class _MyTemplateLoader(jinja2.BaseLoader):
41     def __init__(self):
42         self.paths = [".", os.path.join(_MODULEPATH, "templates")]
43     def get_source(self, environment, template):
44         def _in_path(dir):
45             return os.path.exists(os.path.join(dir, template))
46         path = list(filter(_in_path, self.paths))
47         if not path:
48             raise jinja2.TemplateNotFound(template)
49         path = os.path.join(path[0], template)
50         mtime = os.path.getmtime(path)
51         with open(path) as f:
52             source = f.read()
53         return source, path, lambda: mtime == os.path.getmtime(path)
54 _Jinja2ldr = jinja2.Environment(loader=_MyTemplateLoader())
55 class _Connection(object):
56     ON_JUNOS = (
57         platform.system().upper() == "JUNOS"
58         or platform.release().startswith("JNPR")
59         or os.path.isfile("/usr/share/cevo/cevo_version")
60     )
61     if ON_JUNOS is False:
62         if os.path.isfile("/etc/product.conf") is True:
63             model_dict = {}
64             with open("/etc/product.conf") as f:
65                 for line in f:
66                     if "=" in line:
67                         (key, val) = line.strip().split("=")
68                         model_dict[key] = val
69             if "model" in model_dict and model_dict["model"] in [
70                 "crpd",
71                 "cbng",
72                 "cmgd",
73             ]:
74                 ON_JUNOS = True
75     auto_probe = 0  # default is no auto-probe
76     @property
77     def hostname(self):
78         return (
79             self._hostname
80             if (self._hostname != "localhost")
81             else self.facts.get("hostname")
82         )
83     @property
84     def user(self):
85         return self._auth_user
86     @property
87     def password(self):
88         return None  # read-only
89     @password.setter
90     def password(self, value):
91         self._auth_password = value
92     @property
93     def logfile(self):
94         return self._logfile
95     @logfile.setter
96     def logfile(self, value):
97         if (not value) and (self._logfile is not None):
98             rc = self._logfile.close()
99             self._logfile = False
100             return rc
101         if sys.version &lt; "3":
102             if not isinstance(value, file):
103                 raise ValueError("value must be a file object")
104         else:
105             import io
106             if not isinstance(value, io.TextIOWrapper):
107 <a name="0"></a>                raise ValueError("value must be a file object")
108         self._logfile = value
109         return self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._logfile
110     @property
111     def timeout(self):
112         return self._conn.timeout
113     @timeout.setter
114     def</b></font> timeout(self, value):
115         try:
116             self._conn.timeout = int(value)
117         except (ValueError, TypeError):
118             raise RuntimeError(
119                 "could not convert timeout value of %s to an " "integer" % (value)
120             )
121     @property
122     def ofacts(self):
123         if self._fact_style != "old" and self._fact_style != "both":
124             raise RuntimeError("Old-style facts gathering is not in use!")
125         if self._ofacts == {} and self.connected:
126             self.facts_refresh()
127         return self._ofacts
128     @ofacts.setter
129     def ofacts(self, value):
130         raise RuntimeError("facts is read-only!")
131     @property
132     def port(self):
133         return self._port
134     @property
135     def master(self):
136         master = None
137         if self.facts.get("current_re") is not None:
138             if "master" in self.facts["current_re"]:
139                 master = True
140             elif "backup" in self.facts["current_re"]:
141                 master = False
142             elif (
143                 self.facts.get("2RE") is False
144                 and self.facts.get("RE_hw_mi") is False
145                 and "re0" in self.facts["current_re"]
146             ):
147                 master = True
148             elif self.facts.get("srx_cluster") is True:
149                 if "primary" in self.facts["current_re"]:
150                     master = True
151                 else:
152                     master = False
153             else:
154                 if (
155                     self.re_name is not None
156                     and "gnf" in self.re_name
157                     and "-re" in self.re_name
158                 ):
159                     (gnf, _) = self.re_name.split("-re", 1)
160                     if gnf + "-master" in self.facts.get("current_re"):
161                         master = True
162                     elif gnf + "-backup" in self.facts.get("current_re"):
163                         master = False
164                 else:
165                     for re_state in self.facts["current_re"]:
166                         if "-backup" in re_state or "-master" in re_state:
167                             master = False
168                             break
169         return master
170     @master.setter
171     def master(self, value):
172         raise RuntimeError("master is read-only!")
173     @property
174     def uptime(self):
175         uptime = None
176         rsp = self.rpc.get_system_uptime_information(normalize=True)
177         if rsp is not None:
178             element = rsp.find(".//system-booted-time/time-length")
179             if element is not None:
180                 uptime_string = element.get("seconds")
181                 if uptime_string is not None:
182                     uptime = int(uptime_string)
183         return uptime
184     @uptime.setter
185     def uptime(self, value):
186         raise RuntimeError("uptime is read-only!")
187     @property
188     def re_name(self):
189         re_name = None
190         if (
191             self.facts.get("current_re") is not None
192             and self.facts.get("hostname_info") is not None
193         ):
194             intersect = set(self.facts["current_re"]) &amp; set(
195                 self.facts["hostname_info"].keys()
196             )
197             if len(intersect) == 1:
198                 re_name = list(intersect)[0]
199             elif len(intersect) == 0:
200                 for re_state in self.facts["current_re"]:
201                     if "-re" in re_state:
202                         re_name = re_state
203                         break
204                 if re_name is None:
205                     all_re_names = list(self.facts["hostname_info"].keys())
206                     if len(all_re_names) == 1:
207                         re_name = all_re_names[0]
208                 if re_name is None:
209                     for re_state in self.facts["current_re"]:
210                         match = re.search("^re\d+$", re_state)
211                         if match:
212                             re_string = "bsys-" + match.group(0)
213                             if re_string in self.facts["hostname_info"].keys():
214                                 re_name = re_string
215         return re_name
216     @re_name.setter
217     def re_name(self, value):
218         raise RuntimeError("re_name is read-only!")
219     def _sshconf_lkup(self):
220         if self.__class__.__name__ == "Device" and self._sock_fd is not None:
221             return None
222         if self._ssh_config:
223             sshconf_path = os.path.expanduser(self._ssh_config)
224         else:
225             sshconf_path = os.path.join(os.path.expanduser("~"), ".ssh", "config")
226         if not os.path.exists(sshconf_path):
227             return None
228         else:
229             sshconf = paramiko.SSHConfig()
230             with open(sshconf_path, "r") as fp:
231                 sshconf.parse(fp)
232                 found = sshconf.lookup(self._hostname)
233                 self._port = found.get("port", self._port)
234                 self._conf_auth_user = found.get("user")
235                 self._conf_ssh_private_key_file = found.get("identityfile")
236             return sshconf_path
237     def display_xml_rpc(self, command, format="xml"):
238         try:
239             command = command + "| display xml rpc"
240             rsp = self.rpc.cli(command, format="xml")
241             rsp = rsp.getparent().find(".//rpc")
242             if format == "text":
243                 encode = None if sys.version &lt; "3" else "unicode"
244                 return etree.tostring(rsp[0], encoding=encode)
245             return rsp[0]
246         except TypeError:
247             return "No RPC equivalent found for: " + command
248         except:
249             return "invalid command: " + command
250     def Template(self, filename, parent=None, gvars=None):
251         return self._j2ldr.get_template(filename, parent, gvars)
252     @property
253     def manages(self):
254         return self._manages
255     def bind(self, *vargs, **kvargs):
256         if len(vargs):
257             for fn in vargs:
258                 if hasattr(self, fn.__name__):
259                     raise ValueError(
260                         "request attribute name %s already exists" % fn.__name__
261                     )
262             for fn in vargs:
263                 if sys.version &lt; "3":
264                     self.__dict__[fn.__name__] = types.MethodType(
265                         fn, self, self.__class__
266                     )
267                 else:
268                     self.__dict__[fn.__name__] = types.MethodType(fn, self.__class__)
269             return
270         for name in kvargs.keys():
271             if hasattr(self, name):
272                 raise ValueError("requested attribute name %s already exists" % name)
273         for name, thing in kvargs.items():
274             new_inst = thing(self)
275             self.__dict__[name] = new_inst
276             self._manages.append(name)
277     @property
278     def _sshconf_path(self):
279         return self._sshconf_lkup()
280     def probe(self, timeout=5, intvtimeout=1):
281         start = datetime.datetime.now()
282         end = start + datetime.timedelta(seconds=timeout)
283         probe_ok = True
284         while datetime.datetime.now() &lt; end:
285             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
286             s.settimeout(intvtimeout)
287             try:
288                 s.connect((self.hostname, int(self._port)))
289                 s.shutdown(socket.SHUT_RDWR)
290                 s.close()
291                 break
292             except:
293                 time.sleep(1)
294                 pass
295         else:
296             probe_ok = False
297         return probe_ok
298     def cli_to_rpc_string(self, command):
299         (command, _, _) = command.partition("|")
300         command = command.strip()
301         rpc = self.display_xml_rpc(command)
302         if isinstance(rpc, six.string_types):
303             return None
304         rpc_string = "rpc.%s(" % (rpc.tag.replace("-", "_"))
305         arguments = []
306         for child in rpc:
307             key = child.tag.replace("-", "_")
308             if child.text:
309                 value = "'" + child.text + "'"
310             else:
311                 value = "True"
312             arguments.append("%s=%s" % (key, value))
313         if arguments:
314             rpc_string += ", ".join(arguments)
315         rpc_string += ")"
316         return rpc_string
317     def cli(self, command, format="text", warning=True):
318         if "display xml rpc" not in command and warning is True:
319             rpc_string = self.cli_to_rpc_string(command)
320             if rpc_string is not None:
321                 warning_string = "\nCLI command is for debug use only!\n"
322                 warning_string += "Instead of:\ncli('%s')\n" % (command)
323                 warning_string += "Use:\n%s\n" % (rpc_string)
324                 warnings.simplefilter("always")
325                 warnings.warn(warning_string, RuntimeWarning)
326                 warnings.resetwarnings()
327         try:
328             rsp = self.rpc.cli(command=command, format=format)
329             if isinstance(rsp, dict) and format.lower() == "json":
330                 return rsp
331             if rsp is True:
332                 return ""
333             if rsp.tag in ["output", "rpc-reply"]:
334                 encode = None if sys.version &lt; "3" else "unicode"
335                 return etree.tostring(
336                     rsp, method="text", with_tail=False, encoding=encode
337                 )
338             if rsp.tag == "configuration-information":
339                 return rsp.findtext("configuration-output")
340             if rsp.tag == "rpc":
341                 return rsp[0]
342             return rsp
343         except (
344             EzErrors.ConnectClosedError,
345             EzErrors.RpcError,
346             EzErrors.RpcTimeoutError,
347         ) as ex:
348             raise ex
349         except Exception as ex:
350             warnings.warn(
351                 "An unknown exception occurred : %s - please report." % ex,
352                 RuntimeWarning,
353             )
354             raise ex
355     @normalizeDecorator
356     @timeoutDecorator
357     def execute(self, rpc_cmd, ignore_warning=False, **kvargs):
358         if self.connected is not True:
359             raise EzErrors.ConnectClosedError(self)
360         if isinstance(rpc_cmd, str):
361             rpc_cmd_e = etree.XML(rpc_cmd)
362         elif isinstance(rpc_cmd, etree._Element):
363             rpc_cmd_e = rpc_cmd
364         else:
365             raise ValueError(
366                 "Dont know what to do with rpc of type %s" % rpc_cmd.__class__.__name__
367             )
368         try:
369             rpc_rsp_e = self._rpc_reply(
370                 rpc_cmd_e,
371                 ignore_warning=ignore_warning,
372                 filter_xml=kvargs.get("filter_xml"),
373             )
374         except NcOpErrors.TimeoutExpiredError:
375             raise EzErrors.RpcTimeoutError(self, rpc_cmd_e.tag, self.timeout)
376         except NcErrors.TransportError:
377             raise EzErrors.ConnectClosedError(self)
378         except RPCError as ex:
379             if hasattr(ex, "xml"):
380                 rsp = JXML.remove_namespaces(ex.xml)
381                 message = rsp.findtext("error-message")
382                 if message and message == "permission denied":
383                     raise EzErrors.PermissionError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
384             else:
385                 rsp = None
386             raise EzErrors.RpcError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
387         except Exception as err:
388             warnings.warn(
389                 "An unknown exception occurred - please report.", RuntimeWarning
390             )
391             raise
392         if rpc_cmd_e.tag != "load-configuration" and rpc_cmd_e.attrib.get("format") in [
393             "json",
394             "JSON",
395         ]:
396             ver_info = self.facts.get("version_info")
397             if (
398                 ver_info
399                 and ver_info.major[0] &gt;= 15
400                 or (ver_info.major[0] == 14 and ver_info.major[1] &gt;= 2)
401             ):
402                 try:
403                     return json.loads(rpc_rsp_e.text, strict=False)
404                 except ValueError as ex:
405                     if str(ex).startswith("Extra data"):
406                         return json.loads(re.sub("\s?{\s?}\s?", "", rpc_rsp_e.text))
407                     else:
408                         raise JSONLoadError(ex, rpc_rsp_e.text)
409             else:
410                 warnings.warn(
411                     "Native JSON support is only from 14.2 onwards", RuntimeWarning
412                 )
413         try:
414             ret_rpc_rsp = rpc_rsp_e[0]
415         except IndexError:
416             if rpc_rsp_e.text is not None and rpc_rsp_e.text.strip() is not "":
417                 return rpc_rsp_e
418             return True
419         if kvargs.get("to_py"):
420             return kvargs["to_py"](self, ret_rpc_rsp, **kvargs)
421         else:
422             return ret_rpc_rsp
423     def facts_refresh(
424         self, exception_on_failure=False, warnings_on_failure=None, keys=None
425     ):
426         if self._fact_style not in ["old", "new", "both"]:
427             raise RuntimeError("Unknown fact_style: %s" % (self._fact_style))
428         if self._fact_style == "old" or self._fact_style == "both":
429             if warnings_on_failure is None:
430                 warnings_on_failure = True
431             if keys is not None:
432                 raise RuntimeError(
433                     "The keys argument can not be specified "
434                     "when old-style fact gathering is in use!"
435                 )
436             should_warn = False
437             for gather in FACT_LIST:
438                 try:
439                     gather(self, self._ofacts)
440                 except:
441                     if exception_on_failure:
442                         raise
443                     should_warn = True
444             if (
445                 warnings_on_failure is True
446                 and should_warn is True
447                 and self._fact_style != "both"
448             ):
449                 warnings.warn(
450                     "Facts gathering is incomplete. "
451                     "To know the reason call "
452                     '"dev.facts_refresh(exception_on_failure=True)"',
453                     RuntimeWarning,
454                 )
455         if self._fact_style == "new" or self._fact_style == "both":
456             if warnings_on_failure is None:
457                 warnings_on_failure = False
458             self.facts._refresh(
459                 exception_on_failure=exception_on_failure,
460                 warnings_on_failure=warnings_on_failure,
461                 keys=keys,
462             )
463         return
464     def __repr__(self):
465         return "Device(%s)" % self.hostname
466 class DeviceSessionListener(SessionListener):
467     def __init__(self, device):
468         self._device = device
469     def callback(self, root, raw):
470         pass
471     def errback(self, ex):
472         self._device.connected = False
473 class Device(_Connection):
474     @property
475     def transform(self):
476         try:
477             return self._conn._device_handler.transform_reply
478         except AttributeError:
479             if self._conn is None:
480                 raise ConnectError(self, "Not connected to the Device")
481     @transform.setter
482     def transform(self, func):
483         self._conn._device_handler.transform_reply = func
484     def __new__(cls, *args, **kwargs):
485         if (
486             kwargs.get("port") in [23, "23"]
487             or kwargs.get("mode")
488             or kwargs.get("cs_user") is not None
489         ):
490             from jnpr.junos.console import Console
491             if kwargs.get("conn_open_timeout", None):
492                 kwargs["timeout"] = kwargs.pop("conn_open_timeout")
493             instance = object.__new__(Console, *args, **kwargs)
494             kwargs["host"] = args[0] if len(args) else kwargs.get("host")
495             instance.__init__(**kwargs)
496             return instance
497         else:
498             if sys.version &lt; "3":
499                 return super(Device, cls).__new__(cls, *args, **kwargs)
500             else:
501                 return super().__new__(cls)
502     def __init__(self, *vargs, **kvargs):
503         hostname = vargs[0] if len(vargs) else kvargs.get("host")
504         self._port = kvargs.get("port", 830)
505         self._sock_fd = kvargs.get("sock_fd", None)
506         self._gather_facts = kvargs.get("gather_facts", True)
507         self._normalize = kvargs.get("normalize", False)
508         self._auto_probe = kvargs.get("auto_probe", self.__class__.auto_probe)
509         self._fact_style = kvargs.get("fact_style", "new")
510         self._use_filter = kvargs.get("use_filter", False)
511         self._huge_tree = kvargs.get("huge_tree", False)
512         self._conn_open_timeout = kvargs.get("conn_open_timeout", None)
513         if self._fact_style != "new":
514             warnings.warn(
515                 "fact-style %s will be removed in a future "
516                 "release." % (self._fact_style),
517                 RuntimeWarning,
518             )
519         if self.__class__.ON_JUNOS is True and hostname is None:
520             self._auth_user = None
521             self._auth_password = None
522             self._hostname = "localhost"
523             self._ssh_private_key_file = None
524             self._ssh_config = None
525         else:
526             if hostname is None and self._sock_fd is None:
527                 raise ValueError("You must provide either 'host' or 'sock_fd' value")
528             self._hostname = hostname
529             self._auth_user = os.getenv("USER")
530             self._conf_auth_user = None
531             self._conf_ssh_private_key_file = None
532             self._ssh_config = kvargs.get("ssh_config")
533             self._sshconf_lkup()
534             self._auth_user = (
535                 kvargs.get("user") or self._conf_auth_user or self._auth_user
536             )
537             self._ssh_private_key_file = (
538                 kvargs.get("ssh_private_key_file") or self._conf_ssh_private_key_file
539             )
540             self._auth_password = kvargs.get("password") or kvargs.get("passwd")
541         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._conn = None
542         self._j2ldr = _Jinja2ldr
543         self._manages = []
544         self._ofacts = {}
545         self.connected = False
546         self.rpc =</b></font> _RpcMetaExec(self)
547         if self._fact_style == "old":
548             self.facts = self.ofacts
549         else:
550             self.facts = _FactCache(self)
551     @property
552     def connected(self):
553         return self._connected
554     @connected.setter
555     def connected(self, value):
556         if value in [True, False]:
557             self._connected = value
558     def open(self, *vargs, **kvargs):
559         auto_probe = kvargs.get("auto_probe", self._auto_probe)
560         if auto_probe is not 0:
561             if not self.probe(auto_probe):
562                 raise EzErrors.ProbeError(self)
563         try:
564             ts_start = datetime.datetime.now()
565             allow_agent = bool(
566                 (self._auth_password is None) and (self._ssh_private_key_file is None)
567             )
568             self._conn = netconf_ssh.connect(
569                 host=self._hostname,
570                 port=self._port,
571                 sock_fd=self._sock_fd,
572                 username=self._auth_user,
573                 password=self._auth_password,
574                 hostkey_verify=False,
575                 key_filename=self._ssh_private_key_file,
576                 allow_agent=allow_agent,
577                 ssh_config=self._sshconf_lkup(),
578                 timeout=self._conn_open_timeout,
579                 device_params={
580                     "name": "junos",
581                     "local": self.__class__.ON_JUNOS,
582                     "use_filter": self._use_filter,
583                 },
584             )
585             self._conn._session.add_listener(DeviceSessionListener(self))
586         except NcErrors.AuthenticationError as err:
587             raise EzErrors.ConnectAuthError(self)
588         except NcErrors.SSHError as err:
589             ts_err = datetime.datetime.now()
590             diff_ts = ts_err - ts_start
591             if diff_ts.seconds &lt; 3:
592                 raise EzErrors.ConnectRefusedError(self)
593             if str(err).find("not open") &gt; 0:
594                 raise EzErrors.ConnectTimeoutError(self)
595             else:
596                 cnx = EzErrors.ConnectError(self)
597                 cnx._orig = err
598                 raise cnx
599         except socket.gaierror:
600             raise EzErrors.ConnectUnknownHostError(self)
601         except Exception as err:
602             cnx_err = EzErrors.ConnectError(self)
603             cnx_err._orig = err
604             raise cnx_err
605         if self._huge_tree:
606             self._conn.huge_tree = True
607         self.connected = True
608         self._nc_transform = self.transform
609         self._norm_transform = lambda: JXML.normalize_xslt.encode("UTF-8")
610         self._normalize = kvargs.get("normalize", self._normalize)
611         if self._normalize is True:
612             self.transform = self._norm_transform
613         gather_facts = kvargs.get("gather_facts", self._gather_facts)
614         if gather_facts is True:
615             self.facts_refresh()
616         return self
617     def close(self):
618         if self.connected is True:
619             self.connected = False
620             try:
621                 self._conn.close_session()
622             except NcOpErrors.TimeoutExpiredError:
623                 raise EzErrors.RpcTimeoutError(self, "close", self.timeout)
624             except NcErrors.SessionCloseError:
625                 pass
626     @ignoreWarnDecorator
627     def _rpc_reply(self, rpc_cmd_e, filter_xml=None):
628         if NCCLIENT_FILTER_XML:
629             return self._conn.rpc(rpc_cmd_e, filter_xml)._NCElement__doc
630         else:
631             return self._conn.rpc(rpc_cmd_e)._NCElement__doc
632     def __enter__(self):
633         self.open()
634         return self
635     def __exit__(self, exc_type, exc_val, exc_tb):
636         if self._conn.connected and not isinstance(exc_val, EzErrors.ConnectError):
637             try:
638                 self.close()
639             except Exception as ex:
640                 logger.error("Close in context manager hit exception: {}".format(ex))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
