<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for exception.py &amp; device.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for exception.py &amp; device.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>exception.py (6.3324537%)<th>device.py (1.717967%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(223-231)<td><a href="#" name="0">(205-219)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(31-36)<td><a href="#" name="1">(1280-1287)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>exception.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import re
from jnpr.junos import jxml
from jnpr.junos import jxml as JXML
from lxml.etree import _Element
from ncclient.operations.rpc import RPCError
class FactLoopError(RuntimeError):
    pass
class RpcError(Exception):
    def __init__(self, cmd=None, rsp=None, errs=None, dev=None, timeout=None, re=None):
        self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.cmd = cmd
        self.rsp = rsp
        self.dev = dev
        self.timeout = timeout
        self.re = re
        self.rpc_error =</b></font> None
        self.xml = rsp
        if isinstance(errs, RPCError) and hasattr(errs, "errors"):
            self.errs = [JXML.rpc_error(error.xml) for error in errs.errors]
            for error in errs.errors:
                if error.severity == "error":
                    self.rsp = JXML.remove_namespaces(error.xml)
                    break
            else:
                if errs.severity == "warning":
                    for error in errs.errors:
                        if error.severity == "warning":
                            self.rsp = JXML.remove_namespaces(error.xml)
                            break
            self.message = errs.message
        else:
            self.errs = errs
            self.message = (
                "\n".join(
                    [
                        "%s: %s" % (err["severity"].strip(), err["message"].strip())
                        for err in errs
                        if err["message"] is not None and err["severity"] is not None
                    ]
                )
                if isinstance(errs, list)
                else ""
            )
        if isinstance(self.rsp, _Element):
            self.rpc_error = jxml.rpc_error(self.rsp)
            self.message = self.message or self.rpc_error["message"]
            if self.errs is None or not isinstance(self.errs, list):
                self.errs = [self.rpc_error]
    def __repr__(self):
        if self.rpc_error is not None:
            return "{}(severity: {}, bad_element: {}, message: {})".format(
                self.__class__.__name__,
                self.rpc_error["severity"],
                self.rpc_error["bad_element"],
                self.message,
            )
        else:
            return self.__class__.__name__
    __str__ = __repr__
class CommitError(RpcError):
    def __init__(self, rsp, cmd=None, errs=None):
        RpcError.__init__(self, cmd, rsp, errs)
    def __repr__(self):
        return "{}(edit_path: {}, bad_element: {}, message: {})".format(
            self.__class__.__name__,
            self.rpc_error["edit_path"],
            self.rpc_error["bad_element"],
            self.message,
        )
    __str__ = __repr__
class ConfigLoadError(RpcError):
    def __init__(self, rsp, cmd=None, errs=None):
        RpcError.__init__(self, cmd, rsp, errs)
    def __repr__(self):
        return "{}(severity: {}, bad_element: {}, message: {})".format(
            self.__class__.__name__,
            self.rpc_error["severity"],
            self.rpc_error["bad_element"],
            self.message,
        )
    __str__ = __repr__
class LockError(RpcError):
    def __init__(self, rsp):
        RpcError.__init__(self, rsp=rsp)
class UnlockError(RpcError):
    def __init__(self, rsp):
        RpcError.__init__(self, rsp=rsp)
class PermissionError(RpcError):
    def __init__(self, rsp, cmd=None, errs=None):
        RpcError.__init__(self, cmd=cmd, rsp=rsp, errs=errs)
        self.message = rsp.findtext(".//bad-element")
class RpcTimeoutError(RpcError):
    def __init__(self, dev, cmd, timeout):
        RpcError.__init__(self, dev=dev, cmd=cmd, timeout=timeout)
    def __repr__(self):
        return "{}(host: {}, cmd: {}, timeout: {})".format(
            self.__class__.__name__, self.dev.hostname, self.cmd, self.timeout
        )
    __str__ = __repr__
class SwRollbackError(RpcError):
    def __init__(self, rsp, re=None):
        RpcError.__init__(self, re=re, rsp=rsp)
    def __repr__(self):
        if self.re:
            return "{}(re: {}, output: {})".format(
                self.__class__.__name__, self.re, self.rsp
            )
        else:
            return "{}(output: {})".format(self.__class__.__name__, self.rsp)
    __str__ = __repr__
class ConnectError(Exception):
    def __init__(self, dev, msg=None):
        self.dev = dev
        self._orig = msg
<a name="0"></a>    @property
    def user(self):
        return self.dev<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user
    @property
    def host(self):
        return self.dev.hostname
    @property
    def</b></font> port(self):
        return self.dev._port
    @property
    def msg(self):
        return self._orig
    def __repr__(self):
        if self._orig:
            return "{}(host: {}, msg: {})".format(
                self.__class__.__name__, self.dev.hostname, self._orig
            )
        else:
            return "{}({})".format(self.__class__.__name__, self.dev.hostname)
    __str__ = __repr__
class ProbeError(ConnectError):
    pass
class ConnectAuthError(ConnectError):
    pass
class ConnectTimeoutError(ConnectError):
    pass
class ConnectUnknownHostError(ConnectError):
    pass
class ConnectRefusedError(ConnectError):
    pass
class ConnectNotMasterError(ConnectError):
    pass
class ConnectClosedError(ConnectError):
    def __init__(self, dev):
        ConnectError.__init__(self, dev=dev)
        dev.connected = False
class JSONLoadError(Exception):
    def __init__(self, exception, rpc_content):
        self.ex_msg = str(exception)
        self.rpc_content = rpc_content
        self.offending_line = ""
        obj = re.search("line (\d+)", self.ex_msg)
        if obj:
            line_no = int(obj.group(1))
            rpc_lines = rpc_content.splitlines()
            for line in range(line_no - 3, line_no + 2):
                self.offending_line += "%s: %s\n" % (line + 1, rpc_lines[line])
    def __repr__(self):
        if self.offending_line:
            return (
                "{}(reason: {}, \nThe offending config appears "
                "to be: \n{})".format(
                    self.__class__.__name__, self.ex_msg, self.offending_line
                )
            )
        else:
            return "{}(reason: {})".format(self.__class__.__name__, self.ex_msg)
    __str__ = __repr__
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>device.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import six
import types
import platform
import warnings
import logging
import socket
import datetime
import time
import sys
import json
import re
from lxml import etree
from ncclient import manager as netconf_ssh
import ncclient.transport.errors as NcErrors
from ncclient.transport.session import SessionListener
import ncclient.operations.errors as NcOpErrors
from ncclient.operations import RPCError
import paramiko
import jinja2
from jnpr.junos.rpcmeta import _RpcMetaExec
from jnpr.junos import exception as EzErrors
from jnpr.junos.factcache import _FactCache
from jnpr.junos.ofacts import *
from jnpr.junos import jxml as JXML
from jnpr.junos.decorators import (
    timeoutDecorator,
    normalizeDecorator,
    ignoreWarnDecorator,
)
from jnpr.junos.exception import JSONLoadError, ConnectError
from ncclient.operations.third_party.juniper.rpc import ExecuteRpc
import inspect
if sys.version_info.major &gt;= 3:
    NCCLIENT_FILTER_XML = len(inspect.signature(ExecuteRpc.request).parameters) == 3
else:
    NCCLIENT_FILTER_XML = len(inspect.getargspec(ExecuteRpc.request).args) == 3
_MODULEPATH = os.path.dirname(__file__)
logger = logging.getLogger("jnpr.junos.device")
class _MyTemplateLoader(jinja2.BaseLoader):
    def __init__(self):
        self.paths = [".", os.path.join(_MODULEPATH, "templates")]
    def get_source(self, environment, template):
        def _in_path(dir):
            return os.path.exists(os.path.join(dir, template))
        path = list(filter(_in_path, self.paths))
        if not path:
            raise jinja2.TemplateNotFound(template)
        path = os.path.join(path[0], template)
        mtime = os.path.getmtime(path)
        with open(path) as f:
            source = f.read()
        return source, path, lambda: mtime == os.path.getmtime(path)
_Jinja2ldr = jinja2.Environment(loader=_MyTemplateLoader())
class _Connection(object):
    ON_JUNOS = (
        platform.system().upper() == "JUNOS"
        or platform.release().startswith("JNPR")
        or os.path.isfile("/usr/share/cevo/cevo_version")
    )
    if ON_JUNOS is False:
        if os.path.isfile("/etc/product.conf") is True:
            model_dict = {}
            with open("/etc/product.conf") as f:
                for line in f:
                    if "=" in line:
                        (key, val) = line.strip().split("=")
                        model_dict[key] = val
            if "model" in model_dict and model_dict["model"] in [
                "crpd",
                "cbng",
                "cmgd",
            ]:
                ON_JUNOS = True
    auto_probe = 0  # default is no auto-probe
    @property
    def hostname(self):
        return (
            self._hostname
            if (self._hostname != "localhost")
            else self.facts.get("hostname")
        )
    @property
    def user(self):
        return self._auth_user
    @property
    def password(self):
        return None  # read-only
    @password.setter
    def password(self, value):
        self._auth_password = value
    @property
    def logfile(self):
        return self._logfile
    @logfile.setter
    def logfile(self, value):
        if (not value) and (self._logfile is not None):
            rc = self._logfile.close()
            self._logfile = False
            return rc
        if sys.version &lt; "3":
            if not isinstance(value, file):
                raise ValueError("value must be a file object")
        else:
            import io
            if not isinstance(value, io.TextIOWrapper):
<a name="0"></a>                raise ValueError("value must be a file object")
        self._logfile = value
        return self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._logfile
    @property
    def timeout(self):
        return self._conn.timeout
    @timeout.setter
    def</b></font> timeout(self, value):
        try:
            self._conn.timeout = int(value)
        except (ValueError, TypeError):
            raise RuntimeError(
                "could not convert timeout value of %s to an " "integer" % (value)
            )
    @property
    def ofacts(self):
        if self._fact_style != "old" and self._fact_style != "both":
            raise RuntimeError("Old-style facts gathering is not in use!")
        if self._ofacts == {} and self.connected:
            self.facts_refresh()
        return self._ofacts
    @ofacts.setter
    def ofacts(self, value):
        raise RuntimeError("facts is read-only!")
    @property
    def port(self):
        return self._port
    @property
    def master(self):
        master = None
        if self.facts.get("current_re") is not None:
            if "master" in self.facts["current_re"]:
                master = True
            elif "backup" in self.facts["current_re"]:
                master = False
            elif (
                self.facts.get("2RE") is False
                and self.facts.get("RE_hw_mi") is False
                and "re0" in self.facts["current_re"]
            ):
                master = True
            elif self.facts.get("srx_cluster") is True:
                if "primary" in self.facts["current_re"]:
                    master = True
                else:
                    master = False
            else:
                if (
                    self.re_name is not None
                    and "gnf" in self.re_name
                    and "-re" in self.re_name
                ):
                    (gnf, _) = self.re_name.split("-re", 1)
                    if gnf + "-master" in self.facts.get("current_re"):
                        master = True
                    elif gnf + "-backup" in self.facts.get("current_re"):
                        master = False
                else:
                    for re_state in self.facts["current_re"]:
                        if "-backup" in re_state or "-master" in re_state:
                            master = False
                            break
        return master
    @master.setter
    def master(self, value):
        raise RuntimeError("master is read-only!")
    @property
    def uptime(self):
        uptime = None
        rsp = self.rpc.get_system_uptime_information(normalize=True)
        if rsp is not None:
            element = rsp.find(".//system-booted-time/time-length")
            if element is not None:
                uptime_string = element.get("seconds")
                if uptime_string is not None:
                    uptime = int(uptime_string)
        return uptime
    @uptime.setter
    def uptime(self, value):
        raise RuntimeError("uptime is read-only!")
    @property
    def re_name(self):
        re_name = None
        if (
            self.facts.get("current_re") is not None
            and self.facts.get("hostname_info") is not None
        ):
            intersect = set(self.facts["current_re"]) &amp; set(
                self.facts["hostname_info"].keys()
            )
            if len(intersect) == 1:
                re_name = list(intersect)[0]
            elif len(intersect) == 0:
                for re_state in self.facts["current_re"]:
                    if "-re" in re_state:
                        re_name = re_state
                        break
                if re_name is None:
                    all_re_names = list(self.facts["hostname_info"].keys())
                    if len(all_re_names) == 1:
                        re_name = all_re_names[0]
                if re_name is None:
                    for re_state in self.facts["current_re"]:
                        match = re.search("^re\d+$", re_state)
                        if match:
                            re_string = "bsys-" + match.group(0)
                            if re_string in self.facts["hostname_info"].keys():
                                re_name = re_string
        return re_name
    @re_name.setter
    def re_name(self, value):
        raise RuntimeError("re_name is read-only!")
    def _sshconf_lkup(self):
        if self.__class__.__name__ == "Device" and self._sock_fd is not None:
            return None
        if self._ssh_config:
            sshconf_path = os.path.expanduser(self._ssh_config)
        else:
            sshconf_path = os.path.join(os.path.expanduser("~"), ".ssh", "config")
        if not os.path.exists(sshconf_path):
            return None
        else:
            sshconf = paramiko.SSHConfig()
            with open(sshconf_path, "r") as fp:
                sshconf.parse(fp)
                found = sshconf.lookup(self._hostname)
                self._port = found.get("port", self._port)
                self._conf_auth_user = found.get("user")
                self._conf_ssh_private_key_file = found.get("identityfile")
            return sshconf_path
    def display_xml_rpc(self, command, format="xml"):
        try:
            command = command + "| display xml rpc"
            rsp = self.rpc.cli(command, format="xml")
            rsp = rsp.getparent().find(".//rpc")
            if format == "text":
                encode = None if sys.version &lt; "3" else "unicode"
                return etree.tostring(rsp[0], encoding=encode)
            return rsp[0]
        except TypeError:
            return "No RPC equivalent found for: " + command
        except:
            return "invalid command: " + command
    def Template(self, filename, parent=None, gvars=None):
        return self._j2ldr.get_template(filename, parent, gvars)
    @property
    def manages(self):
        return self._manages
    def bind(self, *vargs, **kvargs):
        if len(vargs):
            for fn in vargs:
                if hasattr(self, fn.__name__):
                    raise ValueError(
                        "request attribute name %s already exists" % fn.__name__
                    )
            for fn in vargs:
                if sys.version &lt; "3":
                    self.__dict__[fn.__name__] = types.MethodType(
                        fn, self, self.__class__
                    )
                else:
                    self.__dict__[fn.__name__] = types.MethodType(fn, self.__class__)
            return
        for name in kvargs.keys():
            if hasattr(self, name):
                raise ValueError("requested attribute name %s already exists" % name)
        for name, thing in kvargs.items():
            new_inst = thing(self)
            self.__dict__[name] = new_inst
            self._manages.append(name)
    @property
    def _sshconf_path(self):
        return self._sshconf_lkup()
    def probe(self, timeout=5, intvtimeout=1):
        start = datetime.datetime.now()
        end = start + datetime.timedelta(seconds=timeout)
        probe_ok = True
        while datetime.datetime.now() &lt; end:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(intvtimeout)
            try:
                s.connect((self.hostname, int(self._port)))
                s.shutdown(socket.SHUT_RDWR)
                s.close()
                break
            except:
                time.sleep(1)
                pass
        else:
            probe_ok = False
        return probe_ok
    def cli_to_rpc_string(self, command):
        (command, _, _) = command.partition("|")
        command = command.strip()
        rpc = self.display_xml_rpc(command)
        if isinstance(rpc, six.string_types):
            return None
        rpc_string = "rpc.%s(" % (rpc.tag.replace("-", "_"))
        arguments = []
        for child in rpc:
            key = child.tag.replace("-", "_")
            if child.text:
                value = "'" + child.text + "'"
            else:
                value = "True"
            arguments.append("%s=%s" % (key, value))
        if arguments:
            rpc_string += ", ".join(arguments)
        rpc_string += ")"
        return rpc_string
    def cli(self, command, format="text", warning=True):
        if "display xml rpc" not in command and warning is True:
            rpc_string = self.cli_to_rpc_string(command)
            if rpc_string is not None:
                warning_string = "\nCLI command is for debug use only!\n"
                warning_string += "Instead of:\ncli('%s')\n" % (command)
                warning_string += "Use:\n%s\n" % (rpc_string)
                warnings.simplefilter("always")
                warnings.warn(warning_string, RuntimeWarning)
                warnings.resetwarnings()
        try:
            rsp = self.rpc.cli(command=command, format=format)
            if isinstance(rsp, dict) and format.lower() == "json":
                return rsp
            if rsp is True:
                return ""
            if rsp.tag in ["output", "rpc-reply"]:
                encode = None if sys.version &lt; "3" else "unicode"
                return etree.tostring(
                    rsp, method="text", with_tail=False, encoding=encode
                )
            if rsp.tag == "configuration-information":
                return rsp.findtext("configuration-output")
            if rsp.tag == "rpc":
                return rsp[0]
            return rsp
        except (
            EzErrors.ConnectClosedError,
            EzErrors.RpcError,
            EzErrors.RpcTimeoutError,
        ) as ex:
            raise ex
        except Exception as ex:
            warnings.warn(
                "An unknown exception occurred : %s - please report." % ex,
                RuntimeWarning,
            )
            raise ex
    @normalizeDecorator
    @timeoutDecorator
    def execute(self, rpc_cmd, ignore_warning=False, **kvargs):
        if self.connected is not True:
            raise EzErrors.ConnectClosedError(self)
        if isinstance(rpc_cmd, str):
            rpc_cmd_e = etree.XML(rpc_cmd)
        elif isinstance(rpc_cmd, etree._Element):
            rpc_cmd_e = rpc_cmd
        else:
            raise ValueError(
                "Dont know what to do with rpc of type %s" % rpc_cmd.__class__.__name__
            )
        try:
            rpc_rsp_e = self._rpc_reply(
                rpc_cmd_e,
                ignore_warning=ignore_warning,
                filter_xml=kvargs.get("filter_xml"),
            )
        except NcOpErrors.TimeoutExpiredError:
            raise EzErrors.RpcTimeoutError(self, rpc_cmd_e.tag, self.timeout)
        except NcErrors.TransportError:
            raise EzErrors.ConnectClosedError(self)
        except RPCError as ex:
            if hasattr(ex, "xml"):
                rsp = JXML.remove_namespaces(ex.xml)
                message = rsp.findtext("error-message")
                if message and message == "permission denied":
                    raise EzErrors.PermissionError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
            else:
                rsp = None
            raise EzErrors.RpcError(cmd=rpc_cmd_e, rsp=rsp, errs=ex)
        except Exception as err:
            warnings.warn(
                "An unknown exception occurred - please report.", RuntimeWarning
            )
            raise
        if rpc_cmd_e.tag != "load-configuration" and rpc_cmd_e.attrib.get("format") in [
            "json",
            "JSON",
        ]:
            ver_info = self.facts.get("version_info")
            if (
                ver_info
                and ver_info.major[0] &gt;= 15
                or (ver_info.major[0] == 14 and ver_info.major[1] &gt;= 2)
            ):
                try:
                    return json.loads(rpc_rsp_e.text, strict=False)
                except ValueError as ex:
                    if str(ex).startswith("Extra data"):
                        return json.loads(re.sub("\s?{\s?}\s?", "", rpc_rsp_e.text))
                    else:
                        raise JSONLoadError(ex, rpc_rsp_e.text)
            else:
                warnings.warn(
                    "Native JSON support is only from 14.2 onwards", RuntimeWarning
                )
        try:
            ret_rpc_rsp = rpc_rsp_e[0]
        except IndexError:
            if rpc_rsp_e.text is not None and rpc_rsp_e.text.strip() is not "":
                return rpc_rsp_e
            return True
        if kvargs.get("to_py"):
            return kvargs["to_py"](self, ret_rpc_rsp, **kvargs)
        else:
            return ret_rpc_rsp
    def facts_refresh(
        self, exception_on_failure=False, warnings_on_failure=None, keys=None
    ):
        if self._fact_style not in ["old", "new", "both"]:
            raise RuntimeError("Unknown fact_style: %s" % (self._fact_style))
        if self._fact_style == "old" or self._fact_style == "both":
            if warnings_on_failure is None:
                warnings_on_failure = True
            if keys is not None:
                raise RuntimeError(
                    "The keys argument can not be specified "
                    "when old-style fact gathering is in use!"
                )
            should_warn = False
            for gather in FACT_LIST:
                try:
                    gather(self, self._ofacts)
                except:
                    if exception_on_failure:
                        raise
                    should_warn = True
            if (
                warnings_on_failure is True
                and should_warn is True
                and self._fact_style != "both"
            ):
                warnings.warn(
                    "Facts gathering is incomplete. "
                    "To know the reason call "
                    '"dev.facts_refresh(exception_on_failure=True)"',
                    RuntimeWarning,
                )
        if self._fact_style == "new" or self._fact_style == "both":
            if warnings_on_failure is None:
                warnings_on_failure = False
            self.facts._refresh(
                exception_on_failure=exception_on_failure,
                warnings_on_failure=warnings_on_failure,
                keys=keys,
            )
        return
    def __repr__(self):
        return "Device(%s)" % self.hostname
class DeviceSessionListener(SessionListener):
    def __init__(self, device):
        self._device = device
    def callback(self, root, raw):
        pass
    def errback(self, ex):
        self._device.connected = False
class Device(_Connection):
    @property
    def transform(self):
        try:
            return self._conn._device_handler.transform_reply
        except AttributeError:
            if self._conn is None:
                raise ConnectError(self, "Not connected to the Device")
    @transform.setter
    def transform(self, func):
        self._conn._device_handler.transform_reply = func
    def __new__(cls, *args, **kwargs):
        if (
            kwargs.get("port") in [23, "23"]
            or kwargs.get("mode")
            or kwargs.get("cs_user") is not None
        ):
            from jnpr.junos.console import Console
            if kwargs.get("conn_open_timeout", None):
                kwargs["timeout"] = kwargs.pop("conn_open_timeout")
            instance = object.__new__(Console, *args, **kwargs)
            kwargs["host"] = args[0] if len(args) else kwargs.get("host")
            instance.__init__(**kwargs)
            return instance
        else:
            if sys.version &lt; "3":
                return super(Device, cls).__new__(cls, *args, **kwargs)
            else:
                return super().__new__(cls)
    def __init__(self, *vargs, **kvargs):
        hostname = vargs[0] if len(vargs) else kvargs.get("host")
        self._port = kvargs.get("port", 830)
        self._sock_fd = kvargs.get("sock_fd", None)
        self._gather_facts = kvargs.get("gather_facts", True)
        self._normalize = kvargs.get("normalize", False)
        self._auto_probe = kvargs.get("auto_probe", self.__class__.auto_probe)
        self._fact_style = kvargs.get("fact_style", "new")
        self._use_filter = kvargs.get("use_filter", False)
        self._huge_tree = kvargs.get("huge_tree", False)
        self._conn_open_timeout = kvargs.get("conn_open_timeout", None)
        if self._fact_style != "new":
            warnings.warn(
                "fact-style %s will be removed in a future "
                "release." % (self._fact_style),
                RuntimeWarning,
            )
        if self.__class__.ON_JUNOS is True and hostname is None:
            self._auth_user = None
            self._auth_password = None
            self._hostname = "localhost"
            self._ssh_private_key_file = None
            self._ssh_config = None
        else:
            if hostname is None and self._sock_fd is None:
                raise ValueError("You must provide either 'host' or 'sock_fd' value")
            self._hostname = hostname
            self._auth_user = os.getenv("USER")
            self._conf_auth_user = None
            self._conf_ssh_private_key_file = None
            self._ssh_config = kvargs.get("ssh_config")
            self._sshconf_lkup()
            self._auth_user = (
                kvargs.get("user") or self._conf_auth_user or self._auth_user
            )
            self._ssh_private_key_file = (
                kvargs.get("ssh_private_key_file") or self._conf_ssh_private_key_file
            )
            self._auth_password = kvargs.get("password") or kvargs.get("passwd")
        self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._conn = None
        self._j2ldr = _Jinja2ldr
        self._manages = []
        self._ofacts = {}
        self.connected = False
        self.rpc =</b></font> _RpcMetaExec(self)
        if self._fact_style == "old":
            self.facts = self.ofacts
        else:
            self.facts = _FactCache(self)
    @property
    def connected(self):
        return self._connected
    @connected.setter
    def connected(self, value):
        if value in [True, False]:
            self._connected = value
    def open(self, *vargs, **kvargs):
        auto_probe = kvargs.get("auto_probe", self._auto_probe)
        if auto_probe is not 0:
            if not self.probe(auto_probe):
                raise EzErrors.ProbeError(self)
        try:
            ts_start = datetime.datetime.now()
            allow_agent = bool(
                (self._auth_password is None) and (self._ssh_private_key_file is None)
            )
            self._conn = netconf_ssh.connect(
                host=self._hostname,
                port=self._port,
                sock_fd=self._sock_fd,
                username=self._auth_user,
                password=self._auth_password,
                hostkey_verify=False,
                key_filename=self._ssh_private_key_file,
                allow_agent=allow_agent,
                ssh_config=self._sshconf_lkup(),
                timeout=self._conn_open_timeout,
                device_params={
                    "name": "junos",
                    "local": self.__class__.ON_JUNOS,
                    "use_filter": self._use_filter,
                },
            )
            self._conn._session.add_listener(DeviceSessionListener(self))
        except NcErrors.AuthenticationError as err:
            raise EzErrors.ConnectAuthError(self)
        except NcErrors.SSHError as err:
            ts_err = datetime.datetime.now()
            diff_ts = ts_err - ts_start
            if diff_ts.seconds &lt; 3:
                raise EzErrors.ConnectRefusedError(self)
            if str(err).find("not open") &gt; 0:
                raise EzErrors.ConnectTimeoutError(self)
            else:
                cnx = EzErrors.ConnectError(self)
                cnx._orig = err
                raise cnx
        except socket.gaierror:
            raise EzErrors.ConnectUnknownHostError(self)
        except Exception as err:
            cnx_err = EzErrors.ConnectError(self)
            cnx_err._orig = err
            raise cnx_err
        if self._huge_tree:
            self._conn.huge_tree = True
        self.connected = True
        self._nc_transform = self.transform
        self._norm_transform = lambda: JXML.normalize_xslt.encode("UTF-8")
        self._normalize = kvargs.get("normalize", self._normalize)
        if self._normalize is True:
            self.transform = self._norm_transform
        gather_facts = kvargs.get("gather_facts", self._gather_facts)
        if gather_facts is True:
            self.facts_refresh()
        return self
    def close(self):
        if self.connected is True:
            self.connected = False
            try:
                self._conn.close_session()
            except NcOpErrors.TimeoutExpiredError:
                raise EzErrors.RpcTimeoutError(self, "close", self.timeout)
            except NcErrors.SessionCloseError:
                pass
    @ignoreWarnDecorator
    def _rpc_reply(self, rpc_cmd_e, filter_xml=None):
        if NCCLIENT_FILTER_XML:
            return self._conn.rpc(rpc_cmd_e, filter_xml)._NCElement__doc
        else:
            return self._conn.rpc(rpc_cmd_e)._NCElement__doc
    def __enter__(self):
        self.open()
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self._conn.connected and not isinstance(exc_val, EzErrors.ConnectError):
            try:
                self.close()
            except Exception as ex:
                logger.error("Close in context manager hit exception: {}".format(ex))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
