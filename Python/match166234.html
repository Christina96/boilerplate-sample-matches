<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for riak.py &amp; test_data_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for riak.py &amp; test_data_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>riak.py (11.607142%)<th>test_data_3.py (1.1529933%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-39)<td><a href="#" name="0">(1275-1286)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-202)<td><a href="#" name="1">(369-373)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>riak.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.utils.path
def __virtual__():
    if salt.utils.path.which("riak"):
        return True
    return (
        False,
        "The riak execution module failed to load: the riak binary is not in the path.",
    )
def __execute_cmd(name, cmd):
<a name="0"></a>    """
    Execute Riak commands
    return __salt__<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["cmd.run_all"]("{} {}".format(salt.utils.path.which(name), cmd))
def start():
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd(</b></font>"riak", "start")
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stderr"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def stop():
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd("riak", "stop")
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stderr"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def cluster_join(username, hostname):
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd("riak-admin", "cluster join {}@{}".format(username, hostname))
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stdout"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def cluster_leave(username, hostname):
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd("riak-admin", "cluster leave {}@{}".format(username, hostname))
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stdout"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def cluster_plan():
    cmd = __execute_cmd("riak-admin", "cluster plan")
    if cmd["retcode"] != 0:
        return False
    return True
def cluster_commit():
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd("riak-admin", "cluster commit")
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stdout"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def member_status():
    ret = {
        "membership": {},
        "summary": {"Valid": 0, "Leaving": 0, "Exiting": 0, "Joining": 0, "Down": 0},
    }
    out = __execute_cmd("riak-admin", "member-status")["stdout"].splitlines()
    for line in out:
        if line.startswith(("=", "-", "Status")):
<a name="1"></a>            continue
        if "/" in line:
            for item in line<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.split("/"):
                key, val = item.split(":")
                ret["summary"][key.strip()] = val.strip(</b></font>)
        if len(line.split()) == 4:
            (status, ring, pending, node) = line.split()
            ret["membership"][node] = {
                "Status": status,
                "Ring": ring,
                "Pending": pending,
            }
    return ret
def status():
    ret = {}
    cmd = __execute_cmd("riak-admin", "status")
    for i in cmd["stdout"].splitlines():
        if ":" in i:
            (name, val) = i.split(":", 1)
            ret[name.strip()] = val.strip()
    return ret
def test():
    ret = {"comment": "", "success": False}
    cmd = __execute_cmd("riak-admin", "test")
    if cmd["retcode"] != 0:
        ret["comment"] = cmd["stdout"]
    else:
        ret["comment"] = cmd["stdout"]
        ret["success"] = True
    return ret
def services():
    cmd = __execute_cmd("riak-admin", "services")
    return cmd["stdout"][1:-1].split(",")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import builtins
import logging
import salt.utils.data
import salt.utils.stringutils
from salt.utils.odict import OrderedDict
from tests.support.mock import patch
from tests.support.unit import LOREM_IPSUM, TestCase
log = logging.getLogger(__name__)
_b = lambda x: x.encode("utf-8")
_s = lambda x: salt.utils.stringutils.to_str(x, normalize=True)
BYTES = b"1\x814\x10"
EGGS = "\u044f\u0438\u0306\u0446\u0430"
class DataTestCase(TestCase):
    test_data = [
        "unicode_str",
        _b("питон"),
        123,
        456.789,
        True,
        False,
        None,
        EGGS,
        BYTES,
        [123, 456.789, _b("спам"), True, False, None, EGGS, BYTES],
        (987, 654.321, _b("яйца"), EGGS, None, (True, EGGS, BYTES)),
        {
            _b("str_key"): _b("str_val"),
            None: True,
            123: 456.789,
            EGGS: BYTES,
            _b("subdict"): {
                "unicode_key": EGGS,
                _b("tuple"): (123, "hello", _b("world"), True, EGGS, BYTES),
                _b("list"): [456, _b("спам"), False, EGGS, BYTES],
            },
        },
        OrderedDict([(_b("foo"), "bar"), (123, 456), (EGGS, BYTES)]),
    ]
    def test_sorted_ignorecase(self):
        test_list = ["foo", "Foo", "bar", "Bar"]
        expected_list = ["bar", "Bar", "foo", "Foo"]
        self.assertEqual(salt.utils.data.sorted_ignorecase(test_list), expected_list)
    def test_mysql_to_dict(self):
        test_mysql_output = [
            "+----+------+-----------+------+---------+------+-------+------------------+",
            "| Id | User | Host      | db   | Command | Time | State | Info         "
            "    |",
            "+----+------+-----------+------+---------+------+-------+------------------+",
            "|  7 | root | localhost | NULL | Query   |    0 | init  | show"
            " processlist |",
            "+----+------+-----------+------+---------+------+-------+------------------+",
        ]
        ret = salt.utils.data.mysql_to_dict(test_mysql_output, "Info")
        expected_dict = {
            "show processlist": {
                "Info": "show processlist",
                "db": "NULL",
                "State": "init",
                "Host": "localhost",
                "Command": "Query",
                "User": "root",
                "Time": 0,
                "Id": 7,
            }
        }
        self.assertDictEqual(ret, expected_dict)
    def test_subdict_match(self):
        test_two_level_dict = {"foo": {"bar": "baz"}}
        test_two_level_comb_dict = {"foo": {"bar": "baz:woz"}}
        test_two_level_dict_and_list = {
            "abc": ["def", "ghi", {"lorem": {"ipsum": [{"dolor": "sit"}]}}],
        }
        test_three_level_dict = {"a": {"b": {"c": "v"}}}
        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_dict, "foo:bar:baz")
        )
        self.assertFalse(
            salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz")
        )
        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz:woz")
        )
        self.assertFalse(
            salt.utils.data.subdict_match(
                test_two_level_comb_dict, "foo:bar:baz:woz:wiz"
            )
        )
        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_dict_and_list, "abc:ghi")
        )
        self.assertTrue(
            salt.utils.data.subdict_match(
                test_two_level_dict_and_list, "abc:lorem:ipsum:dolor:sit"
            )
        )
        self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:b:c:v"))
        self.assertFalse(salt.utils.data.subdict_match(test_three_level_dict, "a:c:v"))
        self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:*:c:v"))
    def test_subdict_match_with_wildcards(self):
        data = {"a": {"b": {"ç": "d", "é": ["eff", "gee", "8ch"], "ĩ": {"j": "k"}}}}
        assert salt.utils.data.subdict_match(data, "*:*:*:*")
        assert salt.utils.data.subdict_match(data, "a:*:*:*")
        assert salt.utils.data.subdict_match(data, "a:b:*:*")
        assert salt.utils.data.subdict_match(data, "a:b:ç:*")
        assert salt.utils.data.subdict_match(data, "a:b:*:d")
        assert salt.utils.data.subdict_match(data, "a:*:ç:d")
        assert salt.utils.data.subdict_match(data, "*:b:ç:d")
        assert salt.utils.data.subdict_match(data, "*:*:ç:d")
        assert salt.utils.data.subdict_match(data, "*:*:*:d")
        assert salt.utils.data.subdict_match(data, "a:*:*:d")
        assert salt.utils.data.subdict_match(data, "a:b:*:ef*")
        assert salt.utils.data.subdict_match(data, "a:b:*:g*")
        assert salt.utils.data.subdict_match(data, "a:b:*:j:*")
        assert salt.utils.data.subdict_match(data, "a:b:*:j:k")
        assert salt.utils.data.subdict_match(data, "a:b:*:*:k")
        assert salt.utils.data.subdict_match(data, "a:b:*:*:*")
    def test_traverse_dict(self):
        test_two_level_dict = {"foo": {"bar": "baz"}}
        self.assertDictEqual(
            {"not_found": "nope"},
            salt.utils.data.traverse_dict(
                test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
            ),
        )
        self.assertEqual(
            "baz",
            salt.utils.data.traverse_dict(
                test_two_level_dict, "foo:bar", {"not_found": "not_found"}
            ),
        )
    def test_traverse_dict_and_list(self):
        test_two_level_dict = {"foo": {"bar": "baz"}}
        test_two_level_dict_and_list = {
            "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
        }
        self.assertDictEqual(
            {"not_found": "nope"},
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
            ),
        )
        self.assertEqual(
            "baz",
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict, "foo:bar", {"not_found": "not_found"}
            ),
        )
        self.assertDictEqual(
            {"not_found": "nope"},
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list, "foo:bar", {"not_found": "nope"}
            ),
        )
        self.assertEqual(
            "baz",
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list, "foo:1", {"not_found": "not_found"}
            ),
        )
        self.assertEqual(
            "sit",
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list,
                "foo:lorem:ipsum:dolor",
                {"not_found": "not_found"},
            ),
        )
        self.assertEqual(
            "it worked",
            salt.utils.data.traverse_dict_and_list(
                {"foo": {1234: "it worked"}},
                "foo:1234",
                "it didn't work",
            ),
        )
        self.assertEqual(
            "default",
            salt.utils.data.traverse_dict_and_list(
                {"foo": {"baz": "didn't work"}},
                "foo:bar",
                "default",
            ),
        )
    def test_issue_39709(self):
        test_two_level_dict_and_list = {
            "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
        }
        self.assertEqual(
            "sit",
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list,
                ["foo", "lorem", "ipsum", "dolor"],
                {"not_found": "not_found"},
            ),
        )
    def test_compare_dicts(self):
        ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "bar"})
        self.assertEqual(ret, {})
        ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "woz"})
        expected_ret = {"foo": {"new": "woz", "old": "bar"}}
        self.assertDictEqual(ret, expected_ret)
    def test_compare_lists_no_change(self):
        ret = salt.utils.data.compare_lists(
            old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3, "a", "b", "c"]
        )
        expected = {}
        self.assertDictEqual(ret, expected)
    def test_compare_lists_changes(self):
        ret = salt.utils.data.compare_lists(
            old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 4, "x", "y", "z"]
        )
        expected = {"new": [4, "x", "y", "z"], "old": [3, "a", "b", "c"]}
        self.assertDictEqual(ret, expected)
    def test_compare_lists_changes_new(self):
        ret = salt.utils.data.compare_lists(old=[1, 2, 3], new=[1, 2, 3, "x", "y", "z"])
        expected = {"new": ["x", "y", "z"]}
        self.assertDictEqual(ret, expected)
    def test_compare_lists_changes_old(self):
        ret = salt.utils.data.compare_lists(old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3])
        expected = {"old": ["a", "b", "c"]}
        self.assertDictEqual(ret, expected)
    def test_decode(self):
        expected = [
            "unicode_str",
            "питон",
            123,
            456.789,
            True,
            False,
            None,
            "яйца",
            BYTES,
            [123, 456.789, "спам", True, False, None, "яйца", BYTES],
            (987, 654.321, "яйца", "яйца", None, (True, "яйца", BYTES)),
            {
                "str_key": "str_val",
                None: True,
                123: 456.789,
                "яйца": BYTES,
                "subdict": {
                    "unicode_key": "яйца",
                    "tuple": (123, "hello", "world", True, "яйца", BYTES),
                    "list": [456, "спам", False, "яйца", BYTES],
                },
            },
            OrderedDict([("foo", "bar"), (123, 456), ("яйца", BYTES)]),
        ]
        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
        )
        self.assertEqual(ret, expected)
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            self.test_data,
            keep=False,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
        )
        expected[10] = [987, 654.321, "яйца", "яйца", None, [True, "яйца", BYTES]]
        expected[11]["subdict"]["tuple"] = [123, "hello", "world", True, "яйца", BYTES]
        expected[12] = {"foo": "bar", 123: 456, "яйца": BYTES}
        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=False,
            preserve_tuples=False,
        )
        self.assertEqual(ret, expected)
        for item in (123, 4.56, True, False, None):
            log.debug("Testing decode of %s", item)
            self.assertEqual(salt.utils.data.decode(item), item)
        self.assertEqual(salt.utils.data.decode("foo"), "foo")
        self.assertEqual(salt.utils.data.decode(_b("bar")), "bar")
        self.assertEqual(salt.utils.data<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.decode(EGGS, normalize=True), "яйца")
        self.assertEqual(salt.utils.data.decode(EGGS, normalize=False), EGGS)
        self.assertEqual(</b></font>salt.utils.data.decode(BYTES, keep=True), BYTES)
        self.assertRaises(UnicodeDecodeError, salt.utils.data.decode, BYTES, keep=False)
    def test_circular_refs_dicts(self):
        test_dict = {"key": "value", "type": "test1"}
        test_dict["self"] = test_dict
        ret = salt.utils.data._remove_circular_refs(ob=test_dict)
        self.assertDictEqual(ret, {"key": "value", "type": "test1", "self": None})
    def test_circular_refs_lists(self):
        test_list = {
            "foo": [],
        }
        test_list["foo"].append((test_list,))
        ret = salt.utils.data._remove_circular_refs(ob=test_list)
        self.assertDictEqual(ret, {"foo": [(None,)]})
    def test_circular_refs_tuple(self):
        test_dup = {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
        ret = salt.utils.data._remove_circular_refs(ob=test_dup)
        self.assertDictEqual(
            ret, {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
        )
    def test_decode_to_str(self):
        expected = [
            _s("unicode_str"),
            _s("питон"),
            123,
            456.789,
            True,
            False,
            None,
            _s("яйца"),
            BYTES,
            [123, 456.789, _s("спам"), True, False, None, _s("яйца"), BYTES],
            (987, 654.321, _s("яйца"), _s("яйца"), None, (True, _s("яйца"), BYTES)),
            {
                _s("str_key"): _s("str_val"),
                None: True,
                123: 456.789,
                _s("яйца"): BYTES,
                _s("subdict"): {
                    _s("unicode_key"): _s("яйца"),
                    _s("tuple"): (
                        123,
                        _s("hello"),
                        _s("world"),
                        True,
                        _s("яйца"),
                        BYTES,
                    ),
                    _s("list"): [456, _s("спам"), False, _s("яйца"), BYTES],
                },
            },
            OrderedDict([(_s("foo"), _s("bar")), (123, 456), (_s("яйца"), BYTES)]),
        ]
        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
            to_str=True,
        )
        self.assertEqual(ret, expected)
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            self.test_data,
            keep=False,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
            to_str=True,
        )
        expected[10] = [
            987,
            654.321,
            _s("яйца"),
            _s("яйца"),
            None,
            [True, _s("яйца"), BYTES],
        ]
        expected[11][_s("subdict")][_s("tuple")] = [
            123,
            _s("hello"),
            _s("world"),
            True,
            _s("яйца"),
            BYTES,
        ]
        expected[12] = {_s("foo"): _s("bar"), 123: 456, _s("яйца"): BYTES}
        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=False,
            preserve_tuples=False,
            to_str=True,
        )
        self.assertEqual(ret, expected)
        for item in (123, 4.56, True, False, None):
            log.debug("Testing decode of %s", item)
            self.assertEqual(salt.utils.data.decode(item, to_str=True), item)
        self.assertEqual(salt.utils.data.decode("foo", to_str=True), _s("foo"))
        self.assertEqual(salt.utils.data.decode(_b("bar"), to_str=True), _s("bar"))
        self.assertEqual(salt.utils.data.decode(BYTES, keep=True, to_str=True), BYTES)
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            BYTES,
            keep=False,
            to_str=True,
        )
    def test_decode_fallback(self):
        with patch.object(builtins, "__salt_system_encoding__", "ascii"):
            self.assertEqual(salt.utils.data.decode(_b("яйца")), "яйца")
    def test_encode(self):
        expected = [
            _b("unicode_str"),
            _b("питон"),
            123,
            456.789,
            True,
            False,
            None,
            _b(EGGS),
            BYTES,
            [123, 456.789, _b("спам"), True, False, None, _b(EGGS), BYTES],
            (987, 654.321, _b("яйца"), _b(EGGS), None, (True, _b(EGGS), BYTES)),
            {
                _b("str_key"): _b("str_val"),
                None: True,
                123: 456.789,
                _b(EGGS): BYTES,
                _b("subdict"): {
                    _b("unicode_key"): _b(EGGS),
                    _b("tuple"): (123, _b("hello"), _b("world"), True, _b(EGGS), BYTES),
                    _b("list"): [456, _b("спам"), False, _b(EGGS), BYTES],
                },
            },
            OrderedDict([(_b("foo"), _b("bar")), (123, 456), (_b(EGGS), BYTES)]),
        ]
        ret = salt.utils.data.encode(
            self.test_data, keep=True, preserve_dict_class=True, preserve_tuples=True
        )
        self.assertEqual(ret, expected)
        ret = salt.utils.data.encode(
            self.test_data, keep=False, preserve_dict_class=True, preserve_tuples=True
        )
        self.assertEqual(ret, expected)
        expected[10] = [
            987,
            654.321,
            _b("яйца"),
            _b(EGGS),
            None,
            [True, _b(EGGS), BYTES],
        ]
        expected[11][_b("subdict")][_b("tuple")] = [
            123,
            _b("hello"),
            _b("world"),
            True,
            _b(EGGS),
            BYTES,
        ]
        expected[12] = {_b("foo"): _b("bar"), 123: 456, _b(EGGS): BYTES}
        ret = salt.utils.data.encode(
            self.test_data, keep=True, preserve_dict_class=False, preserve_tuples=False
        )
        self.assertEqual(ret, expected)
        ret = salt.utils.data.encode(
            self.test_data, keep=False, preserve_dict_class=False, preserve_tuples=False
        )
        self.assertEqual(ret, expected)
        for item in (123, 4.56, True, False, None):
            log.debug("Testing encode of %s", item)
            self.assertEqual(salt.utils.data.encode(item), item)
        self.assertEqual(salt.utils.data.encode("foo"), _b("foo"))
        self.assertEqual(salt.utils.data.encode(_b("bar")), _b("bar"))
        self.assertEqual(salt.utils.data.encode(BYTES, keep=True), BYTES)
        self.assertEqual(salt.utils.data.encode(BYTES, keep=False), BYTES)
    def test_encode_keep(self):
        unicode_str = "питон"
        encoding = "ascii"
        self.assertEqual(
            salt.utils.data.encode(unicode_str, encoding, keep=True), unicode_str
        )
        self.assertRaises(
            UnicodeEncodeError,
            salt.utils.data.encode,
            unicode_str,
            encoding,
            keep=False,
        )
        data = [
            unicode_str,
            [b"foo", [unicode_str], {b"key": unicode_str}, (unicode_str,)],
            {
                b"list": [b"foo", unicode_str],
                b"dict": {b"key": unicode_str},
                b"tuple": (b"foo", unicode_str),
            },
            ([b"foo", unicode_str], {b"key": unicode_str}, (unicode_str,)),
        ]
        self.assertEqual(
            salt.utils.data.encode(data, encoding, keep=True, preserve_tuples=True),
            data,
        )
        self.assertRaises(
            UnicodeEncodeError,
            salt.utils.data.encode,
            data,
            encoding,
            keep=False,
            preserve_tuples=True,
        )
        for index, _ in enumerate(data):
            self.assertEqual(
                salt.utils.data.encode(
                    data[index], encoding, keep=True, preserve_tuples=True
                ),
                data[index],
            )
            self.assertRaises(
                UnicodeEncodeError,
                salt.utils.data.encode,
                data[index],
                encoding,
                keep=False,
                preserve_tuples=True,
            )
    def test_encode_fallback(self):
        with patch.object(builtins, "__salt_system_encoding__", "ascii"):
            self.assertEqual(salt.utils.data.encode("яйца"), _b("яйца"))
        with patch.object(builtins, "__salt_system_encoding__", "CP1252"):
            self.assertEqual(salt.utils.data.encode("Ψ"), _b("Ψ"))
    def test_repack_dict(self):
        list_of_one_element_dicts = [
            {"dict_key_1": "dict_val_1"},
            {"dict_key_2": "dict_val_2"},
            {"dict_key_3": "dict_val_3"},
        ]
        expected_ret = {
            "dict_key_1": "dict_val_1",
            "dict_key_2": "dict_val_2",
            "dict_key_3": "dict_val_3",
        }
        ret = salt.utils.data.repack_dictlist(list_of_one_element_dicts)
        self.assertDictEqual(ret, expected_ret)
        yaml_key_val_pair = "- key1: val1"
        ret = salt.utils.data.repack_dictlist(yaml_key_val_pair)
        self.assertDictEqual(ret, {"key1": "val1"})
        ret = salt.utils.data.repack_dictlist(LOREM_IPSUM)
        self.assertDictEqual(ret, {})
    def test_stringify(self):
        self.assertRaises(TypeError, salt.utils.data.stringify, 9)
        self.assertEqual(
            salt.utils.data.stringify(["one", "two", "three", 4, 5]),
            ["one", "two", "three", "4", "5"],
        )
    def test_json_query(self):
        with patch("salt.utils.data.jmespath", None):
            self.assertRaisesRegex(
                RuntimeError, "requires jmespath", salt.utils.data.json_query, {}, "@"
            )
        user_groups = {
            "user1": {"groups": ["group1", "group2", "group3"]},
            "user2": {"groups": ["group1", "group2"]},
            "user3": {"groups": ["group3"]},
        }
        expression = "*.groups[0]"
        primary_groups = ["group1", "group1", "group3"]
        self.assertEqual(
            sorted(salt.utils.data.json_query(user_groups, expression)), primary_groups
        )
class FilterFalseyTestCase(TestCase):
    def test_nop(self):
        old_dict = {
            "foo": "bar",
            "bar": {"baz": {"qux": "quux"}},
            "baz": ["qux", {"foo": "bar"}],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict)
        self.assertEqual(old_dict, new_dict)
        self.assertIs(type(old_dict), type(new_dict))
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        self.assertEqual(old_dict, new_dict)
        old_list = ["foo", "bar"]
        new_list = salt.utils.data.filter_falsey(old_list)
        self.assertEqual(old_list, new_list)
        self.assertIs(type(old_list), type(new_list))
        old_set = {"foo", "bar"}
        new_set = salt.utils.data.filter_falsey(old_set)
        self.assertEqual(old_set, new_set)
        self.assertIs(type(old_set), type(new_set))
        old_dict = OrderedDict(
            [
                ("foo", "bar"),
                ("bar", OrderedDict([("qux", "quux")])),
                ("baz", ["qux", OrderedDict([("foo", "bar")])]),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict)
        self.assertEqual(old_dict, new_dict)
        self.assertIs(type(old_dict), type(new_dict))
        old_list = [0]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[int])
        self.assertEqual(old_list, new_list)
        old_list = [""]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[str])
        self.assertEqual(old_list, new_list)
        old_list = [[]]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type([])])
        self.assertEqual(old_list, new_list)
        old_list = [{}]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type({})])
        self.assertEqual(old_list, new_list)
    def test_filter_dict_no_recurse(self):
        old_dict = {
            "foo": None,
            "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
            "baz": ["qux"],
            "qux": {},
            "quux": [],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict)
        expect_dict = {
            "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
            "baz": ["qux"],
        }
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))
    def test_filter_dict_recurse(self):
        old_dict = {
            "foo": None,
            "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
            "baz": ["qux"],
            "qux": {},
            "quux": [],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        expect_dict = {"baz": ["qux"]}
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))
    def test_filter_list_no_recurse(self):
        old_list = ["foo", None, [], {}, 0, ""]
        new_list = salt.utils.data.filter_falsey(old_list)
        expect_list = ["foo"]
        self.assertEqual(expect_list, new_list)
        self.assertIs(type(expect_list), type(new_list))
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(old_list)
        self.assertEqual(old_list, new_list)
        self.assertIs(type(old_list), type(new_list))
    def test_filter_list_recurse(self):
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=3)
        expect_list = ["foo", ["foo"], ["foo"], {"foo": "bar"}]
        self.assertEqual(expect_list, new_list)
        self.assertIs(type(expect_list), type(new_list))
    def test_filter_set_no_recurse(self):
        old_set = {"foo", None, 0, ""}
        new_set = salt.utils.data.filter_falsey(old_set)
        expect_set = {"foo"}
        self.assertEqual(expect_set, new_set)
        self.assertIs(type(expect_set), type(new_set))
    def test_filter_ordereddict_no_recurse(self):
        old_dict = OrderedDict(
            [
                ("foo", None),
                (
                    "bar",
                    OrderedDict(
                        [
                            (
                                "baz",
                                OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
                            )
                        ]
                    ),
                ),
                ("baz", ["qux"]),
                ("qux", {}),
                ("quux", []),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict)
        expect_dict = OrderedDict(
            [
                (
                    "bar",
                    OrderedDict(
                        [
                            (
                                "baz",
                                OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
                            )
                        ]
                    ),
                ),
                ("baz", ["qux"]),
            ]
        )
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))
    def test_filter_ordereddict_recurse(self):
        old_dict = OrderedDict(
            [
                ("foo", None),
                (
                    "bar",
                    OrderedDict(
                        [
                            (
                                "baz",
                                OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
                            )
                        ]
                    ),
                ),
                ("baz", ["qux"]),
                ("qux", {}),
                ("quux", []),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        expect_dict = OrderedDict([("baz", ["qux"])])
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))
    def test_filter_list_recurse_limit(self):
        old_list = [None, [None, [None, [None]]]]
        new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=2)
        self.assertEqual([[[[None]]]], new_list)
    def test_filter_dict_recurse_limit(self):
        old_dict = {
            "one": None,
            "foo": {"two": None, "bar": {"three": None, "baz": {"four": None}}},
        }
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=2)
        self.assertEqual({"foo": {"bar": {"baz": {"four": None}}}}, new_dict)
    def test_filter_exclude_types(self):
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[int, str]
        )
        self.assertEqual(
            ["foo", ["foo"], ["foo"], {"foo": 0}, {"foo": "bar"}, [{"foo": ""}]],
            new_list,
        )
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type([])]
        )
        self.assertEqual(
            ["foo", ["foo"], ["foo"], {"foo": "bar", "baz": []}, []], new_list
        )
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type({})]
        )
        self.assertEqual(["foo", ["foo"], ["foo"], {}, {"foo": "bar"}, [{}]], new_list)
        old_list = [
            "foo",
            ["foo"],
            ["foo", None],
            {"foo": 0},
            {"foo": "bar", "baz": []},
            [{"foo": ""}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type(None)]
        )
        self.assertEqual(["foo", ["foo"], ["foo", None], {"foo": "bar"}], new_list)
class FilterRecursiveDiff(TestCase):
    def test_list_equality(self):
        test_list = [0, 1, 2]
        self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
        test_list = [[0], [1], [0, 1, 2]]
        self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
    def test_dict_equality(self):
        test_dict = {"foo": "bar", "bar": {"baz": {"qux": "quux"}}, "frop": 0}
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
    def test_ordereddict_equality(self):
        test_dict = OrderedDict(
            [
                ("foo", "bar"),
                ("bar", OrderedDict([("baz", OrderedDict([("qux", "quux")]))])),
                ("frop", 0),
            ]
        )
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
    def test_mixed_equality(self):
        test_data = {
            "foo": "bar",
            "baz": [0, 1, 2],
            "bar": {"baz": [{"qux": "quux"}, {"froop", 0}]},
        }
        self.assertEqual({}, salt.utils.data.recursive_diff(test_data, test_data))
    def test_set_equality(self):
        test_set = {0, 1, 2, 3, "foo"}
        self.assertEqual({}, salt.utils.data.recursive_diff(test_set, test_set))
        set_one = {0, 1, 2, 3}
        set_two = {3, 2, 1, 0}
        self.assertEqual({}, salt.utils.data.recursive_diff(set_one, set_two))
    def test_tuple_equality(self):
        test_tuple = (0, 1, 2, 3, "foo")
        self.assertEqual({}, salt.utils.data.recursive_diff(test_tuple, test_tuple))
    def test_list_inequality(self):
        list_one = [0, 1, 2]
        list_two = ["foo", "bar", "baz"]
        expected_result = {"old": list_one, "new": list_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {"new": list_one, "old": list_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )
        list_one = [0, "foo", 1, "bar"]
        list_two = [1, "foo", 1, "qux"]
        expected_result = {"old": [0, "bar"], "new": [1, "qux"]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {"new": [0, "bar"], "old": [1, "qux"]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )
        list_one = [0, 1, [2, 3]]
        list_two = [0, 1, ["foo", "bar"]]
        expected_result = {"old": [[2, 3]], "new": [["foo", "bar"]]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {"new": [[2, 3]], "old": [["foo", "bar"]]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )
    def test_dict_inequality(self):
        dict_one = {"foo": 1, "bar": 2, "baz": 3}
        dict_two = {"foo": 2, 1: "bar", "baz": 3}
        expected_result = {"old": {"foo": 1, "bar": 2}, "new": {"foo": 2, 1: "bar"}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {"new": {"foo": 1, "bar": 2}, "old": {"foo": 2, 1: "bar"}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )
        dict_one = {"foo": {"bar": {"baz": 1}}}
        dict_two = {"foo": {"qux": {"baz": 1}}}
        expected_result = {"old": dict_one, "new": dict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {"new": dict_one, "old": dict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )
    def test_ordereddict_inequality(self):
        odict_one = OrderedDict([("foo", "bar"), ("bar", "baz")])
        odict_two = OrderedDict([("bar", "baz"), ("foo", "bar")])
        expected_result = {"old": odict_one, "new": odict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
        )
    def test_set_inequality(self):
        set_one = {0, 1, 2, 4}
        set_two = {0, 1, 3, 4}
        expected_result = {"old": {2}, "new": {3}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )
        expected_result = {"new": {2}, "old": {3}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_two, set_one)
        )
        set_one = {0, "foo", 1, "bar"}
        set_two = {"foo", 1, "bar", 2}
        expected_result = {}
        self.assertNotEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )
    def test_mixed_inequality(self):
        dict_one = {"foo": [1, 2, 3]}
        dict_two = {"foo": [3, 2, 1]}
        expected_result = {"old": {"foo": [1, 3]}, "new": {"foo": [3, 1]}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {"new": {"foo": [1, 3]}, "old": {"foo": [3, 1]}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )
        list_one = [1, 2, {"foo": ["bar", {"foo": 1, "bar": 2}]}]
        list_two = [3, 4, {"foo": ["qux", {"foo": 1, "bar": 2}]}]
        expected_result = {
            "old": [1, 2, {"foo": ["bar"]}],
            "new": [3, 4, {"foo": ["qux"]}],
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {
            "new": [1, 2, {"foo": ["bar"]}],
            "old": [3, 4, {"foo": ["qux"]}],
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )
        mixed_one = {"foo": {0, 1, 2}, "bar": [0, 1, 2]}
        mixed_two = {"foo": {1, 2, 3}, "bar": [1, 2, 3]}
        expected_result = {
            "old": {"foo": {0}, "bar": [0, 1, 2]},
            "new": {"foo": {3}, "bar": [1, 2, 3]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_one, mixed_two)
        )
        expected_result = {
            "new": {"foo": {0}, "bar": [0, 1, 2]},
            "old": {"foo": {3}, "bar": [1, 2, 3]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
        )
    def test_tuple_inequality(self):
        tuple_one = (1, 2, 3)
        tuple_two = (3, 2, 1)
        expected_result = {"old": (1, 3), "new": (3, 1)}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
        )
    def test_list_vs_set(self):
        mixed_one = [1, 2, 3]
<a name="0"></a>        mixed_two = {3, 2, 1}
        expected_result = {}
        self.assertEqual(
            expected_result, salt.utils.data<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.recursive_diff(mixed_one, mixed_two)
        )
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
        )
    def test_dict_vs_ordereddict(self):
        test_dict = {"foo": "bar", "bar": "baz"}
        test_odict = OrderedDict(</b></font>[("foo", "bar"), ("bar", "baz")])
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict))
        self.assertEqual({}, salt.utils.data.recursive_diff(test_odict, test_dict))
        test_odict2 = OrderedDict([("bar", "baz"), ("foo", "bar")])
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict2))
        self.assertEqual({}, salt.utils.data.recursive_diff(test_odict2, test_dict))
    def test_list_ignore_ignored(self):
        list_one = [1, 2, 3]
        list_two = [3, 2, 1]
        expected_result = {"old": [1, 3], "new": [3, 1]}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(list_one, list_two, ignore_keys=[1, 3]),
        )
    def test_dict_ignore(self):
        dict_one = {"foo": 1, "bar": 2, "baz": 3}
        dict_two = {"foo": 3, "bar": 2, "baz": 1}
        expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
        )
    def test_ordereddict_ignore(self):
        odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
        odict_two = OrderedDict([("baz", 1), ("bar", 2), ("foo", 3)])
        expected_result = {
            "old": OrderedDict([("baz", 3)]),
            "new": OrderedDict([("baz", 1)]),
        }
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(odict_one, odict_two, ignore_keys=["foo"]),
        )
    def test_dict_vs_ordereddict_ignore(self):
        dict_one = {"foo": 1, "bar": 2, "baz": 3}
        odict_two = OrderedDict([("foo", 3), ("bar", 2), ("baz", 1)])
        expected_result = {"old": {"baz": 3}, "new": OrderedDict([("baz", 1)])}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, odict_two, ignore_keys=["foo"]),
        )
    def test_mixed_nested_ignore(self):
        dict_one = {"foo": [1], "bar": {"foo": 1, "bar": 2}, "baz": 3}
        dict_two = {"foo": [2], "bar": {"foo": 3, "bar": 2}, "baz": 1}
        expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
        )
    def test_ordered_dict_unequal_length(self):
        odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
        odict_two = OrderedDict([("foo", 1), ("bar", 2)])
        expected_result = {"old": OrderedDict([("baz", 3)]), "new": {}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
        )
    def test_list_unequal_length(self):
        list_one = [1, 2, 3]
        list_two = [1, 2, 3, 4]
        expected_result = {"old": [], "new": [4]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
    def test_set_unequal_length(self):
        set_one = {1, 2, 3}
        set_two = {4, 3, 2, 1}
        expected_result = {"old": set(), "new": {4}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )
    def test_tuple_unequal_length(self):
        tuple_one = (1, 2, 3)
        tuple_two = (1, 2, 3, 4)
        expected_result = {"old": (), "new": (4,)}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
        )
    def test_list_unordered(self):
        list_one = [1, 2, 3, 4]
        list_two = [4, 3, 2]
        expected_result = {"old": [1], "new": []}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(list_one, list_two, ignore_order=True),
        )
    def test_mixed_nested_unordered(self):
        dict_one = {"foo": {"bar": [1, 2, 3]}, "bar": [{"foo": 4}, 0]}
        dict_two = {"foo": {"bar": [3, 2, 1]}, "bar": [0, {"foo": 4}]}
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_order=True),
        )
        expected_result = {
            "old": {"foo": {"bar": [1, 3]}, "bar": [{"foo": 4}, 0]},
            "new": {"foo": {"bar": [3, 1]}, "bar": [0, {"foo": 4}]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
    def test_ordered_dict_unordered(self):
        odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
        odict_two = OrderedDict([("baz", 3), ("bar", 2), ("foo", 1)])
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(odict_one, odict_two, ignore_order=True),
        )
    def test_ignore_missing_keys_dict(self):
        dict_one = {"foo": 1, "bar": 2, "baz": 3}
        dict_two = {"bar": 3}
        expected_result = {"old": {"bar": 2}, "new": {"bar": 3}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
    def test_ignore_missing_keys_ordered_dict(self):
        odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
        odict_two = OrderedDict([("bar", 3)])
        expected_result = {"old": odict_one, "new": odict_two}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                odict_one, odict_two, ignore_missing_keys=True
            ),
        )
    def test_ignore_missing_keys_recursive(self):
        dict_one = {"foo": {"bar": 2, "baz": 3}}
        dict_two = {"foo": {"baz": 3}}
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
        dict_two = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
        dict_one = {"foo": ["bar", {"baz": 3}]}
        dict_two = {"foo": ["bar", {}]}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
