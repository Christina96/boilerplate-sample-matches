<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for riak.py &amp; test_data_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for riak.py &amp; test_data_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>riak.py (11.607142%)<th>test_data_3.py (1.1529933%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-39)<td><a href="#" name="0">(1275-1286)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-202)<td><a href="#" name="1">(369-373)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>riak.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.utils.path
2 def __virtual__():
3     if salt.utils.path.which("riak"):
4         return True
5     return (
6         False,
7         "The riak execution module failed to load: the riak binary is not in the path.",
8     )
9 def __execute_cmd(name, cmd):
10 <a name="0"></a>    """
11     Execute Riak commands
12     return __salt__<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["cmd.run_all"]("{} {}".format(salt.utils.path.which(name), cmd))
13 def start():
14     ret = {"comment": "", "success": False}
15     cmd = __execute_cmd(</b></font>"riak", "start")
16     if cmd["retcode"] != 0:
17         ret["comment"] = cmd["stderr"]
18     else:
19         ret["comment"] = cmd["stdout"]
20         ret["success"] = True
21     return ret
22 def stop():
23     ret = {"comment": "", "success": False}
24     cmd = __execute_cmd("riak", "stop")
25     if cmd["retcode"] != 0:
26         ret["comment"] = cmd["stderr"]
27     else:
28         ret["comment"] = cmd["stdout"]
29         ret["success"] = True
30     return ret
31 def cluster_join(username, hostname):
32     ret = {"comment": "", "success": False}
33     cmd = __execute_cmd("riak-admin", "cluster join {}@{}".format(username, hostname))
34     if cmd["retcode"] != 0:
35         ret["comment"] = cmd["stdout"]
36     else:
37         ret["comment"] = cmd["stdout"]
38         ret["success"] = True
39     return ret
40 def cluster_leave(username, hostname):
41     ret = {"comment": "", "success": False}
42     cmd = __execute_cmd("riak-admin", "cluster leave {}@{}".format(username, hostname))
43     if cmd["retcode"] != 0:
44         ret["comment"] = cmd["stdout"]
45     else:
46         ret["comment"] = cmd["stdout"]
47         ret["success"] = True
48     return ret
49 def cluster_plan():
50     cmd = __execute_cmd("riak-admin", "cluster plan")
51     if cmd["retcode"] != 0:
52         return False
53     return True
54 def cluster_commit():
55     ret = {"comment": "", "success": False}
56     cmd = __execute_cmd("riak-admin", "cluster commit")
57     if cmd["retcode"] != 0:
58         ret["comment"] = cmd["stdout"]
59     else:
60         ret["comment"] = cmd["stdout"]
61         ret["success"] = True
62     return ret
63 def member_status():
64     ret = {
65         "membership": {},
66         "summary": {"Valid": 0, "Leaving": 0, "Exiting": 0, "Joining": 0, "Down": 0},
67     }
68     out = __execute_cmd("riak-admin", "member-status")["stdout"].splitlines()
69     for line in out:
70         if line.startswith(("=", "-", "Status")):
71 <a name="1"></a>            continue
72         if "/" in line:
73             for item in line<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.split("/"):
74                 key, val = item.split(":")
75                 ret["summary"][key.strip()] = val.strip(</b></font>)
76         if len(line.split()) == 4:
77             (status, ring, pending, node) = line.split()
78             ret["membership"][node] = {
79                 "Status": status,
80                 "Ring": ring,
81                 "Pending": pending,
82             }
83     return ret
84 def status():
85     ret = {}
86     cmd = __execute_cmd("riak-admin", "status")
87     for i in cmd["stdout"].splitlines():
88         if ":" in i:
89             (name, val) = i.split(":", 1)
90             ret[name.strip()] = val.strip()
91     return ret
92 def test():
93     ret = {"comment": "", "success": False}
94     cmd = __execute_cmd("riak-admin", "test")
95     if cmd["retcode"] != 0:
96         ret["comment"] = cmd["stdout"]
97     else:
98         ret["comment"] = cmd["stdout"]
99         ret["success"] = True
100     return ret
101 def services():
102     cmd = __execute_cmd("riak-admin", "services")
103     return cmd["stdout"][1:-1].split(",")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import builtins
2 import logging
3 import salt.utils.data
4 import salt.utils.stringutils
5 from salt.utils.odict import OrderedDict
6 from tests.support.mock import patch
7 from tests.support.unit import LOREM_IPSUM, TestCase
8 log = logging.getLogger(__name__)
9 _b = lambda x: x.encode("utf-8")
10 _s = lambda x: salt.utils.stringutils.to_str(x, normalize=True)
11 BYTES = b"1\x814\x10"
12 EGGS = "\u044f\u0438\u0306\u0446\u0430"
13 class DataTestCase(TestCase):
14     test_data = [
15         "unicode_str",
16         _b("питон"),
17         123,
18         456.789,
19         True,
20         False,
21         None,
22         EGGS,
23         BYTES,
24         [123, 456.789, _b("спам"), True, False, None, EGGS, BYTES],
25         (987, 654.321, _b("яйца"), EGGS, None, (True, EGGS, BYTES)),
26         {
27             _b("str_key"): _b("str_val"),
28             None: True,
29             123: 456.789,
30             EGGS: BYTES,
31             _b("subdict"): {
32                 "unicode_key": EGGS,
33                 _b("tuple"): (123, "hello", _b("world"), True, EGGS, BYTES),
34                 _b("list"): [456, _b("спам"), False, EGGS, BYTES],
35             },
36         },
37         OrderedDict([(_b("foo"), "bar"), (123, 456), (EGGS, BYTES)]),
38     ]
39     def test_sorted_ignorecase(self):
40         test_list = ["foo", "Foo", "bar", "Bar"]
41         expected_list = ["bar", "Bar", "foo", "Foo"]
42         self.assertEqual(salt.utils.data.sorted_ignorecase(test_list), expected_list)
43     def test_mysql_to_dict(self):
44         test_mysql_output = [
45             "+----+------+-----------+------+---------+------+-------+------------------+",
46             "| Id | User | Host      | db   | Command | Time | State | Info         "
47             "    |",
48             "+----+------+-----------+------+---------+------+-------+------------------+",
49             "|  7 | root | localhost | NULL | Query   |    0 | init  | show"
50             " processlist |",
51             "+----+------+-----------+------+---------+------+-------+------------------+",
52         ]
53         ret = salt.utils.data.mysql_to_dict(test_mysql_output, "Info")
54         expected_dict = {
55             "show processlist": {
56                 "Info": "show processlist",
57                 "db": "NULL",
58                 "State": "init",
59                 "Host": "localhost",
60                 "Command": "Query",
61                 "User": "root",
62                 "Time": 0,
63                 "Id": 7,
64             }
65         }
66         self.assertDictEqual(ret, expected_dict)
67     def test_subdict_match(self):
68         test_two_level_dict = {"foo": {"bar": "baz"}}
69         test_two_level_comb_dict = {"foo": {"bar": "baz:woz"}}
70         test_two_level_dict_and_list = {
71             "abc": ["def", "ghi", {"lorem": {"ipsum": [{"dolor": "sit"}]}}],
72         }
73         test_three_level_dict = {"a": {"b": {"c": "v"}}}
74         self.assertTrue(
75             salt.utils.data.subdict_match(test_two_level_dict, "foo:bar:baz")
76         )
77         self.assertFalse(
78             salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz")
79         )
80         self.assertTrue(
81             salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz:woz")
82         )
83         self.assertFalse(
84             salt.utils.data.subdict_match(
85                 test_two_level_comb_dict, "foo:bar:baz:woz:wiz"
86             )
87         )
88         self.assertTrue(
89             salt.utils.data.subdict_match(test_two_level_dict_and_list, "abc:ghi")
90         )
91         self.assertTrue(
92             salt.utils.data.subdict_match(
93                 test_two_level_dict_and_list, "abc:lorem:ipsum:dolor:sit"
94             )
95         )
96         self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:b:c:v"))
97         self.assertFalse(salt.utils.data.subdict_match(test_three_level_dict, "a:c:v"))
98         self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:*:c:v"))
99     def test_subdict_match_with_wildcards(self):
100         data = {"a": {"b": {"ç": "d", "é": ["eff", "gee", "8ch"], "ĩ": {"j": "k"}}}}
101         assert salt.utils.data.subdict_match(data, "*:*:*:*")
102         assert salt.utils.data.subdict_match(data, "a:*:*:*")
103         assert salt.utils.data.subdict_match(data, "a:b:*:*")
104         assert salt.utils.data.subdict_match(data, "a:b:ç:*")
105         assert salt.utils.data.subdict_match(data, "a:b:*:d")
106         assert salt.utils.data.subdict_match(data, "a:*:ç:d")
107         assert salt.utils.data.subdict_match(data, "*:b:ç:d")
108         assert salt.utils.data.subdict_match(data, "*:*:ç:d")
109         assert salt.utils.data.subdict_match(data, "*:*:*:d")
110         assert salt.utils.data.subdict_match(data, "a:*:*:d")
111         assert salt.utils.data.subdict_match(data, "a:b:*:ef*")
112         assert salt.utils.data.subdict_match(data, "a:b:*:g*")
113         assert salt.utils.data.subdict_match(data, "a:b:*:j:*")
114         assert salt.utils.data.subdict_match(data, "a:b:*:j:k")
115         assert salt.utils.data.subdict_match(data, "a:b:*:*:k")
116         assert salt.utils.data.subdict_match(data, "a:b:*:*:*")
117     def test_traverse_dict(self):
118         test_two_level_dict = {"foo": {"bar": "baz"}}
119         self.assertDictEqual(
120             {"not_found": "nope"},
121             salt.utils.data.traverse_dict(
122                 test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
123             ),
124         )
125         self.assertEqual(
126             "baz",
127             salt.utils.data.traverse_dict(
128                 test_two_level_dict, "foo:bar", {"not_found": "not_found"}
129             ),
130         )
131     def test_traverse_dict_and_list(self):
132         test_two_level_dict = {"foo": {"bar": "baz"}}
133         test_two_level_dict_and_list = {
134             "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
135         }
136         self.assertDictEqual(
137             {"not_found": "nope"},
138             salt.utils.data.traverse_dict_and_list(
139                 test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
140             ),
141         )
142         self.assertEqual(
143             "baz",
144             salt.utils.data.traverse_dict_and_list(
145                 test_two_level_dict, "foo:bar", {"not_found": "not_found"}
146             ),
147         )
148         self.assertDictEqual(
149             {"not_found": "nope"},
150             salt.utils.data.traverse_dict_and_list(
151                 test_two_level_dict_and_list, "foo:bar", {"not_found": "nope"}
152             ),
153         )
154         self.assertEqual(
155             "baz",
156             salt.utils.data.traverse_dict_and_list(
157                 test_two_level_dict_and_list, "foo:1", {"not_found": "not_found"}
158             ),
159         )
160         self.assertEqual(
161             "sit",
162             salt.utils.data.traverse_dict_and_list(
163                 test_two_level_dict_and_list,
164                 "foo:lorem:ipsum:dolor",
165                 {"not_found": "not_found"},
166             ),
167         )
168         self.assertEqual(
169             "it worked",
170             salt.utils.data.traverse_dict_and_list(
171                 {"foo": {1234: "it worked"}},
172                 "foo:1234",
173                 "it didn't work",
174             ),
175         )
176         self.assertEqual(
177             "default",
178             salt.utils.data.traverse_dict_and_list(
179                 {"foo": {"baz": "didn't work"}},
180                 "foo:bar",
181                 "default",
182             ),
183         )
184     def test_issue_39709(self):
185         test_two_level_dict_and_list = {
186             "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
187         }
188         self.assertEqual(
189             "sit",
190             salt.utils.data.traverse_dict_and_list(
191                 test_two_level_dict_and_list,
192                 ["foo", "lorem", "ipsum", "dolor"],
193                 {"not_found": "not_found"},
194             ),
195         )
196     def test_compare_dicts(self):
197         ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "bar"})
198         self.assertEqual(ret, {})
199         ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "woz"})
200         expected_ret = {"foo": {"new": "woz", "old": "bar"}}
201         self.assertDictEqual(ret, expected_ret)
202     def test_compare_lists_no_change(self):
203         ret = salt.utils.data.compare_lists(
204             old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3, "a", "b", "c"]
205         )
206         expected = {}
207         self.assertDictEqual(ret, expected)
208     def test_compare_lists_changes(self):
209         ret = salt.utils.data.compare_lists(
210             old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 4, "x", "y", "z"]
211         )
212         expected = {"new": [4, "x", "y", "z"], "old": [3, "a", "b", "c"]}
213         self.assertDictEqual(ret, expected)
214     def test_compare_lists_changes_new(self):
215         ret = salt.utils.data.compare_lists(old=[1, 2, 3], new=[1, 2, 3, "x", "y", "z"])
216         expected = {"new": ["x", "y", "z"]}
217         self.assertDictEqual(ret, expected)
218     def test_compare_lists_changes_old(self):
219         ret = salt.utils.data.compare_lists(old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3])
220         expected = {"old": ["a", "b", "c"]}
221         self.assertDictEqual(ret, expected)
222     def test_decode(self):
223         expected = [
224             "unicode_str",
225             "питон",
226             123,
227             456.789,
228             True,
229             False,
230             None,
231             "яйца",
232             BYTES,
233             [123, 456.789, "спам", True, False, None, "яйца", BYTES],
234             (987, 654.321, "яйца", "яйца", None, (True, "яйца", BYTES)),
235             {
236                 "str_key": "str_val",
237                 None: True,
238                 123: 456.789,
239                 "яйца": BYTES,
240                 "subdict": {
241                     "unicode_key": "яйца",
242                     "tuple": (123, "hello", "world", True, "яйца", BYTES),
243                     "list": [456, "спам", False, "яйца", BYTES],
244                 },
245             },
246             OrderedDict([("foo", "bar"), (123, 456), ("яйца", BYTES)]),
247         ]
248         ret = salt.utils.data.decode(
249             self.test_data,
250             keep=True,
251             normalize=True,
252             preserve_dict_class=True,
253             preserve_tuples=True,
254         )
255         self.assertEqual(ret, expected)
256         self.assertRaises(
257             UnicodeDecodeError,
258             salt.utils.data.decode,
259             self.test_data,
260             keep=False,
261             normalize=True,
262             preserve_dict_class=True,
263             preserve_tuples=True,
264         )
265         expected[10] = [987, 654.321, "яйца", "яйца", None, [True, "яйца", BYTES]]
266         expected[11]["subdict"]["tuple"] = [123, "hello", "world", True, "яйца", BYTES]
267         expected[12] = {"foo": "bar", 123: 456, "яйца": BYTES}
268         ret = salt.utils.data.decode(
269             self.test_data,
270             keep=True,
271             normalize=True,
272             preserve_dict_class=False,
273             preserve_tuples=False,
274         )
275         self.assertEqual(ret, expected)
276         for item in (123, 4.56, True, False, None):
277             log.debug("Testing decode of %s", item)
278             self.assertEqual(salt.utils.data.decode(item), item)
279         self.assertEqual(salt.utils.data.decode("foo"), "foo")
280         self.assertEqual(salt.utils.data.decode(_b("bar")), "bar")
281         self.assertEqual(salt.utils.data<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.decode(EGGS, normalize=True), "яйца")
282         self.assertEqual(salt.utils.data.decode(EGGS, normalize=False), EGGS)
283         self.assertEqual(</b></font>salt.utils.data.decode(BYTES, keep=True), BYTES)
284         self.assertRaises(UnicodeDecodeError, salt.utils.data.decode, BYTES, keep=False)
285     def test_circular_refs_dicts(self):
286         test_dict = {"key": "value", "type": "test1"}
287         test_dict["self"] = test_dict
288         ret = salt.utils.data._remove_circular_refs(ob=test_dict)
289         self.assertDictEqual(ret, {"key": "value", "type": "test1", "self": None})
290     def test_circular_refs_lists(self):
291         test_list = {
292             "foo": [],
293         }
294         test_list["foo"].append((test_list,))
295         ret = salt.utils.data._remove_circular_refs(ob=test_list)
296         self.assertDictEqual(ret, {"foo": [(None,)]})
297     def test_circular_refs_tuple(self):
298         test_dup = {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
299         ret = salt.utils.data._remove_circular_refs(ob=test_dup)
300         self.assertDictEqual(
301             ret, {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
302         )
303     def test_decode_to_str(self):
304         expected = [
305             _s("unicode_str"),
306             _s("питон"),
307             123,
308             456.789,
309             True,
310             False,
311             None,
312             _s("яйца"),
313             BYTES,
314             [123, 456.789, _s("спам"), True, False, None, _s("яйца"), BYTES],
315             (987, 654.321, _s("яйца"), _s("яйца"), None, (True, _s("яйца"), BYTES)),
316             {
317                 _s("str_key"): _s("str_val"),
318                 None: True,
319                 123: 456.789,
320                 _s("яйца"): BYTES,
321                 _s("subdict"): {
322                     _s("unicode_key"): _s("яйца"),
323                     _s("tuple"): (
324                         123,
325                         _s("hello"),
326                         _s("world"),
327                         True,
328                         _s("яйца"),
329                         BYTES,
330                     ),
331                     _s("list"): [456, _s("спам"), False, _s("яйца"), BYTES],
332                 },
333             },
334             OrderedDict([(_s("foo"), _s("bar")), (123, 456), (_s("яйца"), BYTES)]),
335         ]
336         ret = salt.utils.data.decode(
337             self.test_data,
338             keep=True,
339             normalize=True,
340             preserve_dict_class=True,
341             preserve_tuples=True,
342             to_str=True,
343         )
344         self.assertEqual(ret, expected)
345         self.assertRaises(
346             UnicodeDecodeError,
347             salt.utils.data.decode,
348             self.test_data,
349             keep=False,
350             normalize=True,
351             preserve_dict_class=True,
352             preserve_tuples=True,
353             to_str=True,
354         )
355         expected[10] = [
356             987,
357             654.321,
358             _s("яйца"),
359             _s("яйца"),
360             None,
361             [True, _s("яйца"), BYTES],
362         ]
363         expected[11][_s("subdict")][_s("tuple")] = [
364             123,
365             _s("hello"),
366             _s("world"),
367             True,
368             _s("яйца"),
369             BYTES,
370         ]
371         expected[12] = {_s("foo"): _s("bar"), 123: 456, _s("яйца"): BYTES}
372         ret = salt.utils.data.decode(
373             self.test_data,
374             keep=True,
375             normalize=True,
376             preserve_dict_class=False,
377             preserve_tuples=False,
378             to_str=True,
379         )
380         self.assertEqual(ret, expected)
381         for item in (123, 4.56, True, False, None):
382             log.debug("Testing decode of %s", item)
383             self.assertEqual(salt.utils.data.decode(item, to_str=True), item)
384         self.assertEqual(salt.utils.data.decode("foo", to_str=True), _s("foo"))
385         self.assertEqual(salt.utils.data.decode(_b("bar"), to_str=True), _s("bar"))
386         self.assertEqual(salt.utils.data.decode(BYTES, keep=True, to_str=True), BYTES)
387         self.assertRaises(
388             UnicodeDecodeError,
389             salt.utils.data.decode,
390             BYTES,
391             keep=False,
392             to_str=True,
393         )
394     def test_decode_fallback(self):
395         with patch.object(builtins, "__salt_system_encoding__", "ascii"):
396             self.assertEqual(salt.utils.data.decode(_b("яйца")), "яйца")
397     def test_encode(self):
398         expected = [
399             _b("unicode_str"),
400             _b("питон"),
401             123,
402             456.789,
403             True,
404             False,
405             None,
406             _b(EGGS),
407             BYTES,
408             [123, 456.789, _b("спам"), True, False, None, _b(EGGS), BYTES],
409             (987, 654.321, _b("яйца"), _b(EGGS), None, (True, _b(EGGS), BYTES)),
410             {
411                 _b("str_key"): _b("str_val"),
412                 None: True,
413                 123: 456.789,
414                 _b(EGGS): BYTES,
415                 _b("subdict"): {
416                     _b("unicode_key"): _b(EGGS),
417                     _b("tuple"): (123, _b("hello"), _b("world"), True, _b(EGGS), BYTES),
418                     _b("list"): [456, _b("спам"), False, _b(EGGS), BYTES],
419                 },
420             },
421             OrderedDict([(_b("foo"), _b("bar")), (123, 456), (_b(EGGS), BYTES)]),
422         ]
423         ret = salt.utils.data.encode(
424             self.test_data, keep=True, preserve_dict_class=True, preserve_tuples=True
425         )
426         self.assertEqual(ret, expected)
427         ret = salt.utils.data.encode(
428             self.test_data, keep=False, preserve_dict_class=True, preserve_tuples=True
429         )
430         self.assertEqual(ret, expected)
431         expected[10] = [
432             987,
433             654.321,
434             _b("яйца"),
435             _b(EGGS),
436             None,
437             [True, _b(EGGS), BYTES],
438         ]
439         expected[11][_b("subdict")][_b("tuple")] = [
440             123,
441             _b("hello"),
442             _b("world"),
443             True,
444             _b(EGGS),
445             BYTES,
446         ]
447         expected[12] = {_b("foo"): _b("bar"), 123: 456, _b(EGGS): BYTES}
448         ret = salt.utils.data.encode(
449             self.test_data, keep=True, preserve_dict_class=False, preserve_tuples=False
450         )
451         self.assertEqual(ret, expected)
452         ret = salt.utils.data.encode(
453             self.test_data, keep=False, preserve_dict_class=False, preserve_tuples=False
454         )
455         self.assertEqual(ret, expected)
456         for item in (123, 4.56, True, False, None):
457             log.debug("Testing encode of %s", item)
458             self.assertEqual(salt.utils.data.encode(item), item)
459         self.assertEqual(salt.utils.data.encode("foo"), _b("foo"))
460         self.assertEqual(salt.utils.data.encode(_b("bar")), _b("bar"))
461         self.assertEqual(salt.utils.data.encode(BYTES, keep=True), BYTES)
462         self.assertEqual(salt.utils.data.encode(BYTES, keep=False), BYTES)
463     def test_encode_keep(self):
464         unicode_str = "питон"
465         encoding = "ascii"
466         self.assertEqual(
467             salt.utils.data.encode(unicode_str, encoding, keep=True), unicode_str
468         )
469         self.assertRaises(
470             UnicodeEncodeError,
471             salt.utils.data.encode,
472             unicode_str,
473             encoding,
474             keep=False,
475         )
476         data = [
477             unicode_str,
478             [b"foo", [unicode_str], {b"key": unicode_str}, (unicode_str,)],
479             {
480                 b"list": [b"foo", unicode_str],
481                 b"dict": {b"key": unicode_str},
482                 b"tuple": (b"foo", unicode_str),
483             },
484             ([b"foo", unicode_str], {b"key": unicode_str}, (unicode_str,)),
485         ]
486         self.assertEqual(
487             salt.utils.data.encode(data, encoding, keep=True, preserve_tuples=True),
488             data,
489         )
490         self.assertRaises(
491             UnicodeEncodeError,
492             salt.utils.data.encode,
493             data,
494             encoding,
495             keep=False,
496             preserve_tuples=True,
497         )
498         for index, _ in enumerate(data):
499             self.assertEqual(
500                 salt.utils.data.encode(
501                     data[index], encoding, keep=True, preserve_tuples=True
502                 ),
503                 data[index],
504             )
505             self.assertRaises(
506                 UnicodeEncodeError,
507                 salt.utils.data.encode,
508                 data[index],
509                 encoding,
510                 keep=False,
511                 preserve_tuples=True,
512             )
513     def test_encode_fallback(self):
514         with patch.object(builtins, "__salt_system_encoding__", "ascii"):
515             self.assertEqual(salt.utils.data.encode("яйца"), _b("яйца"))
516         with patch.object(builtins, "__salt_system_encoding__", "CP1252"):
517             self.assertEqual(salt.utils.data.encode("Ψ"), _b("Ψ"))
518     def test_repack_dict(self):
519         list_of_one_element_dicts = [
520             {"dict_key_1": "dict_val_1"},
521             {"dict_key_2": "dict_val_2"},
522             {"dict_key_3": "dict_val_3"},
523         ]
524         expected_ret = {
525             "dict_key_1": "dict_val_1",
526             "dict_key_2": "dict_val_2",
527             "dict_key_3": "dict_val_3",
528         }
529         ret = salt.utils.data.repack_dictlist(list_of_one_element_dicts)
530         self.assertDictEqual(ret, expected_ret)
531         yaml_key_val_pair = "- key1: val1"
532         ret = salt.utils.data.repack_dictlist(yaml_key_val_pair)
533         self.assertDictEqual(ret, {"key1": "val1"})
534         ret = salt.utils.data.repack_dictlist(LOREM_IPSUM)
535         self.assertDictEqual(ret, {})
536     def test_stringify(self):
537         self.assertRaises(TypeError, salt.utils.data.stringify, 9)
538         self.assertEqual(
539             salt.utils.data.stringify(["one", "two", "three", 4, 5]),
540             ["one", "two", "three", "4", "5"],
541         )
542     def test_json_query(self):
543         with patch("salt.utils.data.jmespath", None):
544             self.assertRaisesRegex(
545                 RuntimeError, "requires jmespath", salt.utils.data.json_query, {}, "@"
546             )
547         user_groups = {
548             "user1": {"groups": ["group1", "group2", "group3"]},
549             "user2": {"groups": ["group1", "group2"]},
550             "user3": {"groups": ["group3"]},
551         }
552         expression = "*.groups[0]"
553         primary_groups = ["group1", "group1", "group3"]
554         self.assertEqual(
555             sorted(salt.utils.data.json_query(user_groups, expression)), primary_groups
556         )
557 class FilterFalseyTestCase(TestCase):
558     def test_nop(self):
559         old_dict = {
560             "foo": "bar",
561             "bar": {"baz": {"qux": "quux"}},
562             "baz": ["qux", {"foo": "bar"}],
563         }
564         new_dict = salt.utils.data.filter_falsey(old_dict)
565         self.assertEqual(old_dict, new_dict)
566         self.assertIs(type(old_dict), type(new_dict))
567         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
568         self.assertEqual(old_dict, new_dict)
569         old_list = ["foo", "bar"]
570         new_list = salt.utils.data.filter_falsey(old_list)
571         self.assertEqual(old_list, new_list)
572         self.assertIs(type(old_list), type(new_list))
573         old_set = {"foo", "bar"}
574         new_set = salt.utils.data.filter_falsey(old_set)
575         self.assertEqual(old_set, new_set)
576         self.assertIs(type(old_set), type(new_set))
577         old_dict = OrderedDict(
578             [
579                 ("foo", "bar"),
580                 ("bar", OrderedDict([("qux", "quux")])),
581                 ("baz", ["qux", OrderedDict([("foo", "bar")])]),
582             ]
583         )
584         new_dict = salt.utils.data.filter_falsey(old_dict)
585         self.assertEqual(old_dict, new_dict)
586         self.assertIs(type(old_dict), type(new_dict))
587         old_list = [0]
588         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[int])
589         self.assertEqual(old_list, new_list)
590         old_list = [""]
591         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[str])
592         self.assertEqual(old_list, new_list)
593         old_list = [[]]
594         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type([])])
595         self.assertEqual(old_list, new_list)
596         old_list = [{}]
597         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type({})])
598         self.assertEqual(old_list, new_list)
599     def test_filter_dict_no_recurse(self):
600         old_dict = {
601             "foo": None,
602             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
603             "baz": ["qux"],
604             "qux": {},
605             "quux": [],
606         }
607         new_dict = salt.utils.data.filter_falsey(old_dict)
608         expect_dict = {
609             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
610             "baz": ["qux"],
611         }
612         self.assertEqual(expect_dict, new_dict)
613         self.assertIs(type(expect_dict), type(new_dict))
614     def test_filter_dict_recurse(self):
615         old_dict = {
616             "foo": None,
617             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
618             "baz": ["qux"],
619             "qux": {},
620             "quux": [],
621         }
622         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
623         expect_dict = {"baz": ["qux"]}
624         self.assertEqual(expect_dict, new_dict)
625         self.assertIs(type(expect_dict), type(new_dict))
626     def test_filter_list_no_recurse(self):
627         old_list = ["foo", None, [], {}, 0, ""]
628         new_list = salt.utils.data.filter_falsey(old_list)
629         expect_list = ["foo"]
630         self.assertEqual(expect_list, new_list)
631         self.assertIs(type(expect_list), type(new_list))
632         old_list = [
633             "foo",
634             ["foo"],
635             ["foo", None],
636             {"foo": 0},
637             {"foo": "bar", "baz": []},
638             [{"foo": ""}],
639         ]
640         new_list = salt.utils.data.filter_falsey(old_list)
641         self.assertEqual(old_list, new_list)
642         self.assertIs(type(old_list), type(new_list))
643     def test_filter_list_recurse(self):
644         old_list = [
645             "foo",
646             ["foo"],
647             ["foo", None],
648             {"foo": 0},
649             {"foo": "bar", "baz": []},
650             [{"foo": ""}],
651         ]
652         new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=3)
653         expect_list = ["foo", ["foo"], ["foo"], {"foo": "bar"}]
654         self.assertEqual(expect_list, new_list)
655         self.assertIs(type(expect_list), type(new_list))
656     def test_filter_set_no_recurse(self):
657         old_set = {"foo", None, 0, ""}
658         new_set = salt.utils.data.filter_falsey(old_set)
659         expect_set = {"foo"}
660         self.assertEqual(expect_set, new_set)
661         self.assertIs(type(expect_set), type(new_set))
662     def test_filter_ordereddict_no_recurse(self):
663         old_dict = OrderedDict(
664             [
665                 ("foo", None),
666                 (
667                     "bar",
668                     OrderedDict(
669                         [
670                             (
671                                 "baz",
672                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
673                             )
674                         ]
675                     ),
676                 ),
677                 ("baz", ["qux"]),
678                 ("qux", {}),
679                 ("quux", []),
680             ]
681         )
682         new_dict = salt.utils.data.filter_falsey(old_dict)
683         expect_dict = OrderedDict(
684             [
685                 (
686                     "bar",
687                     OrderedDict(
688                         [
689                             (
690                                 "baz",
691                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
692                             )
693                         ]
694                     ),
695                 ),
696                 ("baz", ["qux"]),
697             ]
698         )
699         self.assertEqual(expect_dict, new_dict)
700         self.assertIs(type(expect_dict), type(new_dict))
701     def test_filter_ordereddict_recurse(self):
702         old_dict = OrderedDict(
703             [
704                 ("foo", None),
705                 (
706                     "bar",
707                     OrderedDict(
708                         [
709                             (
710                                 "baz",
711                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
712                             )
713                         ]
714                     ),
715                 ),
716                 ("baz", ["qux"]),
717                 ("qux", {}),
718                 ("quux", []),
719             ]
720         )
721         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
722         expect_dict = OrderedDict([("baz", ["qux"])])
723         self.assertEqual(expect_dict, new_dict)
724         self.assertIs(type(expect_dict), type(new_dict))
725     def test_filter_list_recurse_limit(self):
726         old_list = [None, [None, [None, [None]]]]
727         new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=2)
728         self.assertEqual([[[[None]]]], new_list)
729     def test_filter_dict_recurse_limit(self):
730         old_dict = {
731             "one": None,
732             "foo": {"two": None, "bar": {"three": None, "baz": {"four": None}}},
733         }
734         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=2)
735         self.assertEqual({"foo": {"bar": {"baz": {"four": None}}}}, new_dict)
736     def test_filter_exclude_types(self):
737         old_list = [
738             "foo",
739             ["foo"],
740             ["foo", None],
741             {"foo": 0},
742             {"foo": "bar", "baz": []},
743             [{"foo": ""}],
744         ]
745         new_list = salt.utils.data.filter_falsey(
746             old_list, recurse_depth=3, ignore_types=[int, str]
747         )
748         self.assertEqual(
749             ["foo", ["foo"], ["foo"], {"foo": 0}, {"foo": "bar"}, [{"foo": ""}]],
750             new_list,
751         )
752         old_list = [
753             "foo",
754             ["foo"],
755             ["foo", None],
756             {"foo": 0},
757             {"foo": "bar", "baz": []},
758             [{"foo": ""}],
759         ]
760         new_list = salt.utils.data.filter_falsey(
761             old_list, recurse_depth=3, ignore_types=[type([])]
762         )
763         self.assertEqual(
764             ["foo", ["foo"], ["foo"], {"foo": "bar", "baz": []}, []], new_list
765         )
766         old_list = [
767             "foo",
768             ["foo"],
769             ["foo", None],
770             {"foo": 0},
771             {"foo": "bar", "baz": []},
772             [{"foo": ""}],
773         ]
774         new_list = salt.utils.data.filter_falsey(
775             old_list, recurse_depth=3, ignore_types=[type({})]
776         )
777         self.assertEqual(["foo", ["foo"], ["foo"], {}, {"foo": "bar"}, [{}]], new_list)
778         old_list = [
779             "foo",
780             ["foo"],
781             ["foo", None],
782             {"foo": 0},
783             {"foo": "bar", "baz": []},
784             [{"foo": ""}],
785         ]
786         new_list = salt.utils.data.filter_falsey(
787             old_list, recurse_depth=3, ignore_types=[type(None)]
788         )
789         self.assertEqual(["foo", ["foo"], ["foo", None], {"foo": "bar"}], new_list)
790 class FilterRecursiveDiff(TestCase):
791     def test_list_equality(self):
792         test_list = [0, 1, 2]
793         self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
794         test_list = [[0], [1], [0, 1, 2]]
795         self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
796     def test_dict_equality(self):
797         test_dict = {"foo": "bar", "bar": {"baz": {"qux": "quux"}}, "frop": 0}
798         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
799     def test_ordereddict_equality(self):
800         test_dict = OrderedDict(
801             [
802                 ("foo", "bar"),
803                 ("bar", OrderedDict([("baz", OrderedDict([("qux", "quux")]))])),
804                 ("frop", 0),
805             ]
806         )
807         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
808     def test_mixed_equality(self):
809         test_data = {
810             "foo": "bar",
811             "baz": [0, 1, 2],
812             "bar": {"baz": [{"qux": "quux"}, {"froop", 0}]},
813         }
814         self.assertEqual({}, salt.utils.data.recursive_diff(test_data, test_data))
815     def test_set_equality(self):
816         test_set = {0, 1, 2, 3, "foo"}
817         self.assertEqual({}, salt.utils.data.recursive_diff(test_set, test_set))
818         set_one = {0, 1, 2, 3}
819         set_two = {3, 2, 1, 0}
820         self.assertEqual({}, salt.utils.data.recursive_diff(set_one, set_two))
821     def test_tuple_equality(self):
822         test_tuple = (0, 1, 2, 3, "foo")
823         self.assertEqual({}, salt.utils.data.recursive_diff(test_tuple, test_tuple))
824     def test_list_inequality(self):
825         list_one = [0, 1, 2]
826         list_two = ["foo", "bar", "baz"]
827         expected_result = {"old": list_one, "new": list_two}
828         self.assertEqual(
829             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
830         )
831         expected_result = {"new": list_one, "old": list_two}
832         self.assertEqual(
833             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
834         )
835         list_one = [0, "foo", 1, "bar"]
836         list_two = [1, "foo", 1, "qux"]
837         expected_result = {"old": [0, "bar"], "new": [1, "qux"]}
838         self.assertEqual(
839             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
840         )
841         expected_result = {"new": [0, "bar"], "old": [1, "qux"]}
842         self.assertEqual(
843             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
844         )
845         list_one = [0, 1, [2, 3]]
846         list_two = [0, 1, ["foo", "bar"]]
847         expected_result = {"old": [[2, 3]], "new": [["foo", "bar"]]}
848         self.assertEqual(
849             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
850         )
851         expected_result = {"new": [[2, 3]], "old": [["foo", "bar"]]}
852         self.assertEqual(
853             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
854         )
855     def test_dict_inequality(self):
856         dict_one = {"foo": 1, "bar": 2, "baz": 3}
857         dict_two = {"foo": 2, 1: "bar", "baz": 3}
858         expected_result = {"old": {"foo": 1, "bar": 2}, "new": {"foo": 2, 1: "bar"}}
859         self.assertEqual(
860             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
861         )
862         expected_result = {"new": {"foo": 1, "bar": 2}, "old": {"foo": 2, 1: "bar"}}
863         self.assertEqual(
864             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
865         )
866         dict_one = {"foo": {"bar": {"baz": 1}}}
867         dict_two = {"foo": {"qux": {"baz": 1}}}
868         expected_result = {"old": dict_one, "new": dict_two}
869         self.assertEqual(
870             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
871         )
872         expected_result = {"new": dict_one, "old": dict_two}
873         self.assertEqual(
874             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
875         )
876     def test_ordereddict_inequality(self):
877         odict_one = OrderedDict([("foo", "bar"), ("bar", "baz")])
878         odict_two = OrderedDict([("bar", "baz"), ("foo", "bar")])
879         expected_result = {"old": odict_one, "new": odict_two}
880         self.assertEqual(
881             expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
882         )
883     def test_set_inequality(self):
884         set_one = {0, 1, 2, 4}
885         set_two = {0, 1, 3, 4}
886         expected_result = {"old": {2}, "new": {3}}
887         self.assertEqual(
888             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
889         )
890         expected_result = {"new": {2}, "old": {3}}
891         self.assertEqual(
892             expected_result, salt.utils.data.recursive_diff(set_two, set_one)
893         )
894         set_one = {0, "foo", 1, "bar"}
895         set_two = {"foo", 1, "bar", 2}
896         expected_result = {}
897         self.assertNotEqual(
898             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
899         )
900     def test_mixed_inequality(self):
901         dict_one = {"foo": [1, 2, 3]}
902         dict_two = {"foo": [3, 2, 1]}
903         expected_result = {"old": {"foo": [1, 3]}, "new": {"foo": [3, 1]}}
904         self.assertEqual(
905             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
906         )
907         expected_result = {"new": {"foo": [1, 3]}, "old": {"foo": [3, 1]}}
908         self.assertEqual(
909             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
910         )
911         list_one = [1, 2, {"foo": ["bar", {"foo": 1, "bar": 2}]}]
912         list_two = [3, 4, {"foo": ["qux", {"foo": 1, "bar": 2}]}]
913         expected_result = {
914             "old": [1, 2, {"foo": ["bar"]}],
915             "new": [3, 4, {"foo": ["qux"]}],
916         }
917         self.assertEqual(
918             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
919         )
920         expected_result = {
921             "new": [1, 2, {"foo": ["bar"]}],
922             "old": [3, 4, {"foo": ["qux"]}],
923         }
924         self.assertEqual(
925             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
926         )
927         mixed_one = {"foo": {0, 1, 2}, "bar": [0, 1, 2]}
928         mixed_two = {"foo": {1, 2, 3}, "bar": [1, 2, 3]}
929         expected_result = {
930             "old": {"foo": {0}, "bar": [0, 1, 2]},
931             "new": {"foo": {3}, "bar": [1, 2, 3]},
932         }
933         self.assertEqual(
934             expected_result, salt.utils.data.recursive_diff(mixed_one, mixed_two)
935         )
936         expected_result = {
937             "new": {"foo": {0}, "bar": [0, 1, 2]},
938             "old": {"foo": {3}, "bar": [1, 2, 3]},
939         }
940         self.assertEqual(
941             expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
942         )
943     def test_tuple_inequality(self):
944         tuple_one = (1, 2, 3)
945         tuple_two = (3, 2, 1)
946         expected_result = {"old": (1, 3), "new": (3, 1)}
947         self.assertEqual(
948             expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
949         )
950     def test_list_vs_set(self):
951         mixed_one = [1, 2, 3]
952 <a name="0"></a>        mixed_two = {3, 2, 1}
953         expected_result = {}
954         self.assertEqual(
955             expected_result, salt.utils.data<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.recursive_diff(mixed_one, mixed_two)
956         )
957         self.assertEqual(
958             expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
959         )
960     def test_dict_vs_ordereddict(self):
961         test_dict = {"foo": "bar", "bar": "baz"}
962         test_odict = OrderedDict(</b></font>[("foo", "bar"), ("bar", "baz")])
963         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict))
964         self.assertEqual({}, salt.utils.data.recursive_diff(test_odict, test_dict))
965         test_odict2 = OrderedDict([("bar", "baz"), ("foo", "bar")])
966         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict2))
967         self.assertEqual({}, salt.utils.data.recursive_diff(test_odict2, test_dict))
968     def test_list_ignore_ignored(self):
969         list_one = [1, 2, 3]
970         list_two = [3, 2, 1]
971         expected_result = {"old": [1, 3], "new": [3, 1]}
972         self.assertEqual(
973             expected_result,
974             salt.utils.data.recursive_diff(list_one, list_two, ignore_keys=[1, 3]),
975         )
976     def test_dict_ignore(self):
977         dict_one = {"foo": 1, "bar": 2, "baz": 3}
978         dict_two = {"foo": 3, "bar": 2, "baz": 1}
979         expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
980         self.assertEqual(
981             expected_result,
982             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
983         )
984     def test_ordereddict_ignore(self):
985         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
986         odict_two = OrderedDict([("baz", 1), ("bar", 2), ("foo", 3)])
987         expected_result = {
988             "old": OrderedDict([("baz", 3)]),
989             "new": OrderedDict([("baz", 1)]),
990         }
991         self.assertEqual(
992             expected_result,
993             salt.utils.data.recursive_diff(odict_one, odict_two, ignore_keys=["foo"]),
994         )
995     def test_dict_vs_ordereddict_ignore(self):
996         dict_one = {"foo": 1, "bar": 2, "baz": 3}
997         odict_two = OrderedDict([("foo", 3), ("bar", 2), ("baz", 1)])
998         expected_result = {"old": {"baz": 3}, "new": OrderedDict([("baz", 1)])}
999         self.assertEqual(
1000             expected_result,
1001             salt.utils.data.recursive_diff(dict_one, odict_two, ignore_keys=["foo"]),
1002         )
1003     def test_mixed_nested_ignore(self):
1004         dict_one = {"foo": [1], "bar": {"foo": 1, "bar": 2}, "baz": 3}
1005         dict_two = {"foo": [2], "bar": {"foo": 3, "bar": 2}, "baz": 1}
1006         expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
1007         self.assertEqual(
1008             expected_result,
1009             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
1010         )
1011     def test_ordered_dict_unequal_length(self):
1012         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1013         odict_two = OrderedDict([("foo", 1), ("bar", 2)])
1014         expected_result = {"old": OrderedDict([("baz", 3)]), "new": {}}
1015         self.assertEqual(
1016             expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
1017         )
1018     def test_list_unequal_length(self):
1019         list_one = [1, 2, 3]
1020         list_two = [1, 2, 3, 4]
1021         expected_result = {"old": [], "new": [4]}
1022         self.assertEqual(
1023             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
1024         )
1025     def test_set_unequal_length(self):
1026         set_one = {1, 2, 3}
1027         set_two = {4, 3, 2, 1}
1028         expected_result = {"old": set(), "new": {4}}
1029         self.assertEqual(
1030             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
1031         )
1032     def test_tuple_unequal_length(self):
1033         tuple_one = (1, 2, 3)
1034         tuple_two = (1, 2, 3, 4)
1035         expected_result = {"old": (), "new": (4,)}
1036         self.assertEqual(
1037             expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
1038         )
1039     def test_list_unordered(self):
1040         list_one = [1, 2, 3, 4]
1041         list_two = [4, 3, 2]
1042         expected_result = {"old": [1], "new": []}
1043         self.assertEqual(
1044             expected_result,
1045             salt.utils.data.recursive_diff(list_one, list_two, ignore_order=True),
1046         )
1047     def test_mixed_nested_unordered(self):
1048         dict_one = {"foo": {"bar": [1, 2, 3]}, "bar": [{"foo": 4}, 0]}
1049         dict_two = {"foo": {"bar": [3, 2, 1]}, "bar": [0, {"foo": 4}]}
1050         expected_result = {}
1051         self.assertEqual(
1052             expected_result,
1053             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_order=True),
1054         )
1055         expected_result = {
1056             "old": {"foo": {"bar": [1, 3]}, "bar": [{"foo": 4}, 0]},
1057             "new": {"foo": {"bar": [3, 1]}, "bar": [0, {"foo": 4}]},
1058         }
1059         self.assertEqual(
1060             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
1061         )
1062     def test_ordered_dict_unordered(self):
1063         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1064         odict_two = OrderedDict([("baz", 3), ("bar", 2), ("foo", 1)])
1065         expected_result = {}
1066         self.assertEqual(
1067             expected_result,
1068             salt.utils.data.recursive_diff(odict_one, odict_two, ignore_order=True),
1069         )
1070     def test_ignore_missing_keys_dict(self):
1071         dict_one = {"foo": 1, "bar": 2, "baz": 3}
1072         dict_two = {"bar": 3}
1073         expected_result = {"old": {"bar": 2}, "new": {"bar": 3}}
1074         self.assertEqual(
1075             expected_result,
1076             salt.utils.data.recursive_diff(
1077                 dict_one, dict_two, ignore_missing_keys=True
1078             ),
1079         )
1080     def test_ignore_missing_keys_ordered_dict(self):
1081         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1082         odict_two = OrderedDict([("bar", 3)])
1083         expected_result = {"old": odict_one, "new": odict_two}
1084         self.assertEqual(
1085             expected_result,
1086             salt.utils.data.recursive_diff(
1087                 odict_one, odict_two, ignore_missing_keys=True
1088             ),
1089         )
1090     def test_ignore_missing_keys_recursive(self):
1091         dict_one = {"foo": {"bar": 2, "baz": 3}}
1092         dict_two = {"foo": {"baz": 3}}
1093         expected_result = {}
1094         self.assertEqual(
1095             expected_result,
1096             salt.utils.data.recursive_diff(
1097                 dict_one, dict_two, ignore_missing_keys=True
1098             ),
1099         )
1100         dict_two = {}
1101         self.assertEqual(
1102             expected_result,
1103             salt.utils.data.recursive_diff(
1104                 dict_one, dict_two, ignore_missing_keys=True
1105             ),
1106         )
1107         dict_one = {"foo": ["bar", {"baz": 3}]}
1108         dict_two = {"foo": ["bar", {}]}
1109         self.assertEqual(
1110             expected_result,
1111             salt.utils.data.recursive_diff(
1112                 dict_one, dict_two, ignore_missing_keys=True
1113             ),
1114         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
