<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for riak.py &amp; test_data_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for riak.py &amp; test_data_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>riak.py (11.607142%)<th>test_data_3.py (1.1529933%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-39)<td><a href="#" name="0">(1275-1286)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-202)<td><a href="#" name="1">(369-373)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>riak.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.utils.path
2 def __virtual__():
3     if salt.utils.path.which("riak"):
4         return True
5     return (
6         False,
7         "The riak execution module failed to load: the riak binary is not in the path.",
8     )
9 def __execute_cmd(name, cmd):
10     Execute Riak commands
11     """
12     return __salt__<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["cmd.run_all"]("{} {}".format(salt.utils.path.which(name), cmd))
13 def start():
14     """
15     Start Riak
16     CLI Example:
17     .. code-block:: bash
18         salt '*' riak.start
19     """
20     ret = {"comment": "", "success": False}
21     cmd = __execute_cmd(</b></font>"riak", "start")
22     if cmd["retcode"] != 0:
23         ret["comment"] = cmd["stderr"]
24     else:
25         ret["comment"] = cmd["stdout"]
26         ret["success"] = True
27     return ret
28 def stop():
29     """
30     Stop Riak
31     .. versionchanged:: 2015.8.0
32     CLI Example:
33     .. code-block:: bash
34         salt '*' riak.stop
35     """
36     ret = {"comment": "", "success": False}
37     cmd = __execute_cmd("riak", "stop")
38     if cmd["retcode"] != 0:
39         ret["comment"] = cmd["stderr"]
40     else:
41         ret["comment"] = cmd["stdout"]
42         ret["success"] = True
43     return ret
44 def cluster_join(username, hostname):
45     """
46     Join a Riak cluster
47     .. versionchanged:: 2015.8.0
48     CLI Example:
49     .. code-block:: bash
50         salt '*' riak.cluster_join &lt;user&gt; &lt;host&gt;
51     username - The riak username to join the cluster
52     hostname - The riak hostname you are connecting to
53     """
54     ret = {"comment": "", "success": False}
55     cmd = __execute_cmd("riak-admin", "cluster join {}@{}".format(username, hostname))
56     if cmd["retcode"] != 0:
57         ret["comment"] = cmd["stdout"]
58     else:
59         ret["comment"] = cmd["stdout"]
60         ret["success"] = True
61     return ret
62 def cluster_leave(username, hostname):
63     """
64     Leave a Riak cluster
65     .. versionadded:: 2015.8.0
66     CLI Example:
67     .. code-block:: bash
68         salt '*' riak.cluster_leave &lt;username&gt; &lt;host&gt;
69     username - The riak username to join the cluster
70     hostname - The riak hostname you are connecting to
71     """
72     ret = {"comment": "", "success": False}
73     cmd = __execute_cmd("riak-admin", "cluster leave {}@{}".format(username, hostname))
74     if cmd["retcode"] != 0:
75         ret["comment"] = cmd["stdout"]
76     else:
77         ret["comment"] = cmd["stdout"]
78         ret["success"] = True
79     return ret
80 def cluster_plan():
81     """
82     Review Cluster Plan
83     .. versionchanged:: 2015.8.0
84     CLI Example:
85     .. code-block:: bash
86         salt '*' riak.cluster_plan
87     """
88     cmd = __execute_cmd("riak-admin", "cluster plan")
89     if cmd["retcode"] != 0:
90         return False
91     return True
92 def cluster_commit():
93     """
94     Commit Cluster Changes
95     .. versionchanged:: 2015.8.0
96     CLI Example:
97     .. code-block:: bash
98         salt '*' riak.cluster_commit
99     """
100     ret = {"comment": "", "success": False}
101     cmd = __execute_cmd("riak-admin", "cluster commit")
102     if cmd["retcode"] != 0:
103         ret["comment"] = cmd["stdout"]
104     else:
105         ret["comment"] = cmd["stdout"]
106         ret["success"] = True
107     return ret
108 def member_status():
109     """
110     Get cluster member status
111     .. versionchanged:: 2015.8.0
112     CLI Example:
113     .. code-block:: bash
114         salt '*' riak.member_status
115     """
116     ret = {
117         "membership": {},
118         "summary": {"Valid": 0, "Leaving": 0, "Exiting": 0, "Joining": 0, "Down": 0},
119     }
120     out = __execute_cmd("riak-admin", "member-status")["stdout"].splitlines()
121     for line in out:
122         if line.startswith(("=", "-", "Status")):
123         if "/" in line:
124             for item in line<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.split("/"):
125                 key, val = item.split(":")
126                 ret["summary"][key.strip()] = val.strip(</b></font>)
127         if len(line.split()) == 4:
128             (status, ring, pending, node) = line.split()
129             ret["membership"][node] = {
130                 "Status": status,
131                 "Ring": ring,
132                 "Pending": pending,
133             }
134     return ret
135 def status():
136     """
137     Current node status
138     .. versionadded:: 2015.8.0
139     CLI Example:
140     .. code-block:: bash
141         salt '*' riak.status
142     """
143     ret = {}
144     cmd = __execute_cmd("riak-admin", "status")
145     for i in cmd["stdout"].splitlines():
146         if ":" in i:
147             (name, val) = i.split(":", 1)
148             ret[name.strip()] = val.strip()
149     return ret
150 def test():
151     """
152     Runs a test of a few standard Riak operations
153     .. versionadded:: 2015.8.0
154     CLI Example:
155     .. code-block:: bash
156         salt '*' riak.test
157     """
158     ret = {"comment": "", "success": False}
159     cmd = __execute_cmd("riak-admin", "test")
160     if cmd["retcode"] != 0:
161         ret["comment"] = cmd["stdout"]
162     else:
163         ret["comment"] = cmd["stdout"]
164         ret["success"] = True
165     return ret
166 def services():
167     """
168     List available services on a node
169     .. versionadded:: 2015.8.0
170     CLI Example:
171     .. code-block:: bash
172         salt '*' riak.services
173     """
174     cmd = __execute_cmd("riak-admin", "services")
175     return cmd["stdout"][1:-1].split(",")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Tests for salt.utils.data
3 """
4 import builtins
5 import logging
6 import salt.utils.data
7 import salt.utils.stringutils
8 from salt.utils.odict import OrderedDict
9 from tests.support.mock import patch
10 from tests.support.unit import LOREM_IPSUM, TestCase
11 log = logging.getLogger(__name__)
12 _b = lambda x: x.encode("utf-8")
13 _s = lambda x: salt.utils.stringutils.to_str(x, normalize=True)
14 BYTES = b"1\x814\x10"
15 EGGS = "\u044f\u0438\u0306\u0446\u0430"
16 class DataTestCase(TestCase):
17     test_data = [
18         "unicode_str",
19         _b("питон"),
20         123,
21         456.789,
22         True,
23         False,
24         None,
25         EGGS,
26         BYTES,
27         [123, 456.789, _b("спам"), True, False, None, EGGS, BYTES],
28         (987, 654.321, _b("яйца"), EGGS, None, (True, EGGS, BYTES)),
29         {
30             _b("str_key"): _b("str_val"),
31             None: True,
32             123: 456.789,
33             EGGS: BYTES,
34             _b("subdict"): {
35                 "unicode_key": EGGS,
36                 _b("tuple"): (123, "hello", _b("world"), True, EGGS, BYTES),
37                 _b("list"): [456, _b("спам"), False, EGGS, BYTES],
38             },
39         },
40         OrderedDict([(_b("foo"), "bar"), (123, 456), (EGGS, BYTES)]),
41     ]
42     def test_sorted_ignorecase(self):
43         test_list = ["foo", "Foo", "bar", "Bar"]
44         expected_list = ["bar", "Bar", "foo", "Foo"]
45         self.assertEqual(salt.utils.data.sorted_ignorecase(test_list), expected_list)
46     def test_mysql_to_dict(self):
47         test_mysql_output = [
48             "+----+------+-----------+------+---------+------+-------+------------------+",
49             "| Id | User | Host      | db   | Command | Time | State | Info         "
50             "    |",
51             "+----+------+-----------+------+---------+------+-------+------------------+",
52             "|  7 | root | localhost | NULL | Query   |    0 | init  | show"
53             " processlist |",
54             "+----+------+-----------+------+---------+------+-------+------------------+",
55         ]
56         ret = salt.utils.data.mysql_to_dict(test_mysql_output, "Info")
57         expected_dict = {
58             "show processlist": {
59                 "Info": "show processlist",
60                 "db": "NULL",
61                 "State": "init",
62                 "Host": "localhost",
63                 "Command": "Query",
64                 "User": "root",
65                 "Time": 0,
66                 "Id": 7,
67             }
68         }
69         self.assertDictEqual(ret, expected_dict)
70     def test_subdict_match(self):
71         test_two_level_dict = {"foo": {"bar": "baz"}}
72         test_two_level_comb_dict = {"foo": {"bar": "baz:woz"}}
73         test_two_level_dict_and_list = {
74             "abc": ["def", "ghi", {"lorem": {"ipsum": [{"dolor": "sit"}]}}],
75         }
76         test_three_level_dict = {"a": {"b": {"c": "v"}}}
77         self.assertTrue(
78             salt.utils.data.subdict_match(test_two_level_dict, "foo:bar:baz")
79         )
80         self.assertFalse(
81             salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz")
82         )
83         self.assertTrue(
84             salt.utils.data.subdict_match(test_two_level_comb_dict, "foo:bar:baz:woz")
85         )
86         self.assertFalse(
87             salt.utils.data.subdict_match(
88                 test_two_level_comb_dict, "foo:bar:baz:woz:wiz"
89             )
90         )
91         self.assertTrue(
92             salt.utils.data.subdict_match(test_two_level_dict_and_list, "abc:ghi")
93         )
94         self.assertTrue(
95             salt.utils.data.subdict_match(
96                 test_two_level_dict_and_list, "abc:lorem:ipsum:dolor:sit"
97             )
98         )
99         self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:b:c:v"))
100         self.assertFalse(salt.utils.data.subdict_match(test_three_level_dict, "a:c:v"))
101         self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, "a:*:c:v"))
102     def test_subdict_match_with_wildcards(self):
103         """
104         Tests subdict matching when wildcards are used in the expression
105         """
106         data = {"a": {"b": {"ç": "d", "é": ["eff", "gee", "8ch"], "ĩ": {"j": "k"}}}}
107         assert salt.utils.data.subdict_match(data, "*:*:*:*")
108         assert salt.utils.data.subdict_match(data, "a:*:*:*")
109         assert salt.utils.data.subdict_match(data, "a:b:*:*")
110         assert salt.utils.data.subdict_match(data, "a:b:ç:*")
111         assert salt.utils.data.subdict_match(data, "a:b:*:d")
112         assert salt.utils.data.subdict_match(data, "a:*:ç:d")
113         assert salt.utils.data.subdict_match(data, "*:b:ç:d")
114         assert salt.utils.data.subdict_match(data, "*:*:ç:d")
115         assert salt.utils.data.subdict_match(data, "*:*:*:d")
116         assert salt.utils.data.subdict_match(data, "a:*:*:d")
117         assert salt.utils.data.subdict_match(data, "a:b:*:ef*")
118         assert salt.utils.data.subdict_match(data, "a:b:*:g*")
119         assert salt.utils.data.subdict_match(data, "a:b:*:j:*")
120         assert salt.utils.data.subdict_match(data, "a:b:*:j:k")
121         assert salt.utils.data.subdict_match(data, "a:b:*:*:k")
122         assert salt.utils.data.subdict_match(data, "a:b:*:*:*")
123     def test_traverse_dict(self):
124         test_two_level_dict = {"foo": {"bar": "baz"}}
125         self.assertDictEqual(
126             {"not_found": "nope"},
127             salt.utils.data.traverse_dict(
128                 test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
129             ),
130         )
131         self.assertEqual(
132             "baz",
133             salt.utils.data.traverse_dict(
134                 test_two_level_dict, "foo:bar", {"not_found": "not_found"}
135             ),
136         )
137     def test_traverse_dict_and_list(self):
138         test_two_level_dict = {"foo": {"bar": "baz"}}
139         test_two_level_dict_and_list = {
140             "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
141         }
142         self.assertDictEqual(
143             {"not_found": "nope"},
144             salt.utils.data.traverse_dict_and_list(
145                 test_two_level_dict, "foo:bar:baz", {"not_found": "nope"}
146             ),
147         )
148         self.assertEqual(
149             "baz",
150             salt.utils.data.traverse_dict_and_list(
151                 test_two_level_dict, "foo:bar", {"not_found": "not_found"}
152             ),
153         )
154         self.assertDictEqual(
155             {"not_found": "nope"},
156             salt.utils.data.traverse_dict_and_list(
157                 test_two_level_dict_and_list, "foo:bar", {"not_found": "nope"}
158             ),
159         )
160         self.assertEqual(
161             "baz",
162             salt.utils.data.traverse_dict_and_list(
163                 test_two_level_dict_and_list, "foo:1", {"not_found": "not_found"}
164             ),
165         )
166         self.assertEqual(
167             "sit",
168             salt.utils.data.traverse_dict_and_list(
169                 test_two_level_dict_and_list,
170                 "foo:lorem:ipsum:dolor",
171                 {"not_found": "not_found"},
172             ),
173         )
174         self.assertEqual(
175             "it worked",
176             salt.utils.data.traverse_dict_and_list(
177                 {"foo": {1234: "it worked"}},
178                 "foo:1234",
179                 "it didn't work",
180             ),
181         )
182         self.assertEqual(
183             "default",
184             salt.utils.data.traverse_dict_and_list(
185                 {"foo": {"baz": "didn't work"}},
186                 "foo:bar",
187                 "default",
188             ),
189         )
190     def test_issue_39709(self):
191         test_two_level_dict_and_list = {
192             "foo": ["bar", "baz", {"lorem": {"ipsum": [{"dolor": "sit"}]}}]
193         }
194         self.assertEqual(
195             "sit",
196             salt.utils.data.traverse_dict_and_list(
197                 test_two_level_dict_and_list,
198                 ["foo", "lorem", "ipsum", "dolor"],
199                 {"not_found": "not_found"},
200             ),
201         )
202     def test_compare_dicts(self):
203         ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "bar"})
204         self.assertEqual(ret, {})
205         ret = salt.utils.data.compare_dicts(old={"foo": "bar"}, new={"foo": "woz"})
206         expected_ret = {"foo": {"new": "woz", "old": "bar"}}
207         self.assertDictEqual(ret, expected_ret)
208     def test_compare_lists_no_change(self):
209         ret = salt.utils.data.compare_lists(
210             old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3, "a", "b", "c"]
211         )
212         expected = {}
213         self.assertDictEqual(ret, expected)
214     def test_compare_lists_changes(self):
215         ret = salt.utils.data.compare_lists(
216             old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 4, "x", "y", "z"]
217         )
218         expected = {"new": [4, "x", "y", "z"], "old": [3, "a", "b", "c"]}
219         self.assertDictEqual(ret, expected)
220     def test_compare_lists_changes_new(self):
221         ret = salt.utils.data.compare_lists(old=[1, 2, 3], new=[1, 2, 3, "x", "y", "z"])
222         expected = {"new": ["x", "y", "z"]}
223         self.assertDictEqual(ret, expected)
224     def test_compare_lists_changes_old(self):
225         ret = salt.utils.data.compare_lists(old=[1, 2, 3, "a", "b", "c"], new=[1, 2, 3])
226         expected = {"old": ["a", "b", "c"]}
227         self.assertDictEqual(ret, expected)
228     def test_decode(self):
229         """
230         Companion to test_decode_to_str, they should both be kept up-to-date
231         with one another.
232         NOTE: This uses the lambda "_b" defined above in the global scope,
233         which encodes a string to a bytestring, assuming utf-8.
234         """
235         expected = [
236             "unicode_str",
237             "питон",
238             123,
239             456.789,
240             True,
241             False,
242             None,
243             "яйца",
244             BYTES,
245             [123, 456.789, "спам", True, False, None, "яйца", BYTES],
246             (987, 654.321, "яйца", "яйца", None, (True, "яйца", BYTES)),
247             {
248                 "str_key": "str_val",
249                 None: True,
250                 123: 456.789,
251                 "яйца": BYTES,
252                 "subdict": {
253                     "unicode_key": "яйца",
254                     "tuple": (123, "hello", "world", True, "яйца", BYTES),
255                     "list": [456, "спам", False, "яйца", BYTES],
256                 },
257             },
258             OrderedDict([("foo", "bar"), (123, 456), ("яйца", BYTES)]),
259         ]
260         ret = salt.utils.data.decode(
261             self.test_data,
262             keep=True,
263             normalize=True,
264             preserve_dict_class=True,
265             preserve_tuples=True,
266         )
267         self.assertEqual(ret, expected)
268         self.assertRaises(
269             UnicodeDecodeError,
270             salt.utils.data.decode,
271             self.test_data,
272             keep=False,
273             normalize=True,
274             preserve_dict_class=True,
275             preserve_tuples=True,
276         )
277         expected[10] = [987, 654.321, "яйца", "яйца", None, [True, "яйца", BYTES]]
278         expected[11]["subdict"]["tuple"] = [123, "hello", "world", True, "яйца", BYTES]
279         expected[12] = {"foo": "bar", 123: 456, "яйца": BYTES}
280         ret = salt.utils.data.decode(
281             self.test_data,
282             keep=True,
283             normalize=True,
284             preserve_dict_class=False,
285             preserve_tuples=False,
286         )
287         self.assertEqual(ret, expected)
288         for item in (123, 4.56, True, False, None):
289             log.debug("Testing decode of %s", item)
290             self.assertEqual(salt.utils.data.decode(item), item)
291         self.assertEqual(salt.utils.data.decode("foo"), "foo")
292         self.assertEqual(salt.utils.data.decode(_b("bar")), "bar")
293         self.assertEqual(salt.utils.data<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.decode(EGGS, normalize=True), "яйца")
294         self.assertEqual(salt.utils.data.decode(EGGS, normalize=False), EGGS)
295         self.assertEqual(</b></font>salt.utils.data.decode(BYTES, keep=True), BYTES)
296         self.assertRaises(UnicodeDecodeError, salt.utils.data.decode, BYTES, keep=False)
297     def test_circular_refs_dicts(self):
298         test_dict = {"key": "value", "type": "test1"}
299         test_dict["self"] = test_dict
300         ret = salt.utils.data._remove_circular_refs(ob=test_dict)
301         self.assertDictEqual(ret, {"key": "value", "type": "test1", "self": None})
302     def test_circular_refs_lists(self):
303         test_list = {
304             "foo": [],
305         }
306         test_list["foo"].append((test_list,))
307         ret = salt.utils.data._remove_circular_refs(ob=test_list)
308         self.assertDictEqual(ret, {"foo": [(None,)]})
309     def test_circular_refs_tuple(self):
310         test_dup = {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
311         ret = salt.utils.data._remove_circular_refs(ob=test_dup)
312         self.assertDictEqual(
313             ret, {"foo": "string 1", "bar": "string 1", "ham": 1, "spam": 1}
314         )
315     def test_decode_to_str(self):
316         """
317         Companion to test_decode, they should both be kept up-to-date with one
318         another.
319         NOTE: This uses the lambda "_s" defined above in the global scope,
320         which converts the string/bytestring to a str type.
321         """
322         expected = [
323             _s("unicode_str"),
324             _s("питон"),
325             123,
326             456.789,
327             True,
328             False,
329             None,
330             _s("яйца"),
331             BYTES,
332             [123, 456.789, _s("спам"), True, False, None, _s("яйца"), BYTES],
333             (987, 654.321, _s("яйца"), _s("яйца"), None, (True, _s("яйца"), BYTES)),
334             {
335                 _s("str_key"): _s("str_val"),
336                 None: True,
337                 123: 456.789,
338                 _s("яйца"): BYTES,
339                 _s("subdict"): {
340                     _s("unicode_key"): _s("яйца"),
341                     _s("tuple"): (
342                         123,
343                         _s("hello"),
344                         _s("world"),
345                         True,
346                         _s("яйца"),
347                         BYTES,
348                     ),
349                     _s("list"): [456, _s("спам"), False, _s("яйца"), BYTES],
350                 },
351             },
352             OrderedDict([(_s("foo"), _s("bar")), (123, 456), (_s("яйца"), BYTES)]),
353         ]
354         ret = salt.utils.data.decode(
355             self.test_data,
356             keep=True,
357             normalize=True,
358             preserve_dict_class=True,
359             preserve_tuples=True,
360             to_str=True,
361         )
362         self.assertEqual(ret, expected)
363         self.assertRaises(
364             UnicodeDecodeError,
365             salt.utils.data.decode,
366             self.test_data,
367             keep=False,
368             normalize=True,
369             preserve_dict_class=True,
370             preserve_tuples=True,
371             to_str=True,
372         )
373         expected[10] = [
374             987,
375             654.321,
376             _s("яйца"),
377             _s("яйца"),
378             None,
379             [True, _s("яйца"), BYTES],
380         ]
381         expected[11][_s("subdict")][_s("tuple")] = [
382             123,
383             _s("hello"),
384             _s("world"),
385             True,
386             _s("яйца"),
387             BYTES,
388         ]
389         expected[12] = {_s("foo"): _s("bar"), 123: 456, _s("яйца"): BYTES}
390         ret = salt.utils.data.decode(
391             self.test_data,
392             keep=True,
393             normalize=True,
394             preserve_dict_class=False,
395             preserve_tuples=False,
396             to_str=True,
397         )
398         self.assertEqual(ret, expected)
399         for item in (123, 4.56, True, False, None):
400             log.debug("Testing decode of %s", item)
401             self.assertEqual(salt.utils.data.decode(item, to_str=True), item)
402         self.assertEqual(salt.utils.data.decode("foo", to_str=True), _s("foo"))
403         self.assertEqual(salt.utils.data.decode(_b("bar"), to_str=True), _s("bar"))
404         self.assertEqual(salt.utils.data.decode(BYTES, keep=True, to_str=True), BYTES)
405         self.assertRaises(
406             UnicodeDecodeError,
407             salt.utils.data.decode,
408             BYTES,
409             keep=False,
410             to_str=True,
411         )
412     def test_decode_fallback(self):
413         """
414         Test fallback to utf-8
415         """
416         with patch.object(builtins, "__salt_system_encoding__", "ascii"):
417             self.assertEqual(salt.utils.data.decode(_b("яйца")), "яйца")
418     def test_encode(self):
419         """
420         NOTE: This uses the lambda "_b" defined above in the global scope,
421         which encodes a string to a bytestring, assuming utf-8.
422         """
423         expected = [
424             _b("unicode_str"),
425             _b("питон"),
426             123,
427             456.789,
428             True,
429             False,
430             None,
431             _b(EGGS),
432             BYTES,
433             [123, 456.789, _b("спам"), True, False, None, _b(EGGS), BYTES],
434             (987, 654.321, _b("яйца"), _b(EGGS), None, (True, _b(EGGS), BYTES)),
435             {
436                 _b("str_key"): _b("str_val"),
437                 None: True,
438                 123: 456.789,
439                 _b(EGGS): BYTES,
440                 _b("subdict"): {
441                     _b("unicode_key"): _b(EGGS),
442                     _b("tuple"): (123, _b("hello"), _b("world"), True, _b(EGGS), BYTES),
443                     _b("list"): [456, _b("спам"), False, _b(EGGS), BYTES],
444                 },
445             },
446             OrderedDict([(_b("foo"), _b("bar")), (123, 456), (_b(EGGS), BYTES)]),
447         ]
448         ret = salt.utils.data.encode(
449             self.test_data, keep=True, preserve_dict_class=True, preserve_tuples=True
450         )
451         self.assertEqual(ret, expected)
452         ret = salt.utils.data.encode(
453             self.test_data, keep=False, preserve_dict_class=True, preserve_tuples=True
454         )
455         self.assertEqual(ret, expected)
456         expected[10] = [
457             987,
458             654.321,
459             _b("яйца"),
460             _b(EGGS),
461             None,
462             [True, _b(EGGS), BYTES],
463         ]
464         expected[11][_b("subdict")][_b("tuple")] = [
465             123,
466             _b("hello"),
467             _b("world"),
468             True,
469             _b(EGGS),
470             BYTES,
471         ]
472         expected[12] = {_b("foo"): _b("bar"), 123: 456, _b(EGGS): BYTES}
473         ret = salt.utils.data.encode(
474             self.test_data, keep=True, preserve_dict_class=False, preserve_tuples=False
475         )
476         self.assertEqual(ret, expected)
477         ret = salt.utils.data.encode(
478             self.test_data, keep=False, preserve_dict_class=False, preserve_tuples=False
479         )
480         self.assertEqual(ret, expected)
481         for item in (123, 4.56, True, False, None):
482             log.debug("Testing encode of %s", item)
483             self.assertEqual(salt.utils.data.encode(item), item)
484         self.assertEqual(salt.utils.data.encode("foo"), _b("foo"))
485         self.assertEqual(salt.utils.data.encode(_b("bar")), _b("bar"))
486         self.assertEqual(salt.utils.data.encode(BYTES, keep=True), BYTES)
487         self.assertEqual(salt.utils.data.encode(BYTES, keep=False), BYTES)
488     def test_encode_keep(self):
489         """
490         Whereas we tested the keep argument in test_decode, it is much easier
491         to do a more comprehensive test of keep in its own function where we
492         can force the encoding.
493         """
494         unicode_str = "питон"
495         encoding = "ascii"
496         self.assertEqual(
497             salt.utils.data.encode(unicode_str, encoding, keep=True), unicode_str
498         )
499         self.assertRaises(
500             UnicodeEncodeError,
501             salt.utils.data.encode,
502             unicode_str,
503             encoding,
504             keep=False,
505         )
506         data = [
507             unicode_str,
508             [b"foo", [unicode_str], {b"key": unicode_str}, (unicode_str,)],
509             {
510                 b"list": [b"foo", unicode_str],
511                 b"dict": {b"key": unicode_str},
512                 b"tuple": (b"foo", unicode_str),
513             },
514             ([b"foo", unicode_str], {b"key": unicode_str}, (unicode_str,)),
515         ]
516         self.assertEqual(
517             salt.utils.data.encode(data, encoding, keep=True, preserve_tuples=True),
518             data,
519         )
520         self.assertRaises(
521             UnicodeEncodeError,
522             salt.utils.data.encode,
523             data,
524             encoding,
525             keep=False,
526             preserve_tuples=True,
527         )
528         for index, _ in enumerate(data):
529             self.assertEqual(
530                 salt.utils.data.encode(
531                     data[index], encoding, keep=True, preserve_tuples=True
532                 ),
533                 data[index],
534             )
535             self.assertRaises(
536                 UnicodeEncodeError,
537                 salt.utils.data.encode,
538                 data[index],
539                 encoding,
540                 keep=False,
541                 preserve_tuples=True,
542             )
543     def test_encode_fallback(self):
544         """
545         Test fallback to utf-8
546         """
547         with patch.object(builtins, "__salt_system_encoding__", "ascii"):
548             self.assertEqual(salt.utils.data.encode("яйца"), _b("яйца"))
549         with patch.object(builtins, "__salt_system_encoding__", "CP1252"):
550             self.assertEqual(salt.utils.data.encode("Ψ"), _b("Ψ"))
551     def test_repack_dict(self):
552         list_of_one_element_dicts = [
553             {"dict_key_1": "dict_val_1"},
554             {"dict_key_2": "dict_val_2"},
555             {"dict_key_3": "dict_val_3"},
556         ]
557         expected_ret = {
558             "dict_key_1": "dict_val_1",
559             "dict_key_2": "dict_val_2",
560             "dict_key_3": "dict_val_3",
561         }
562         ret = salt.utils.data.repack_dictlist(list_of_one_element_dicts)
563         self.assertDictEqual(ret, expected_ret)
564         yaml_key_val_pair = "- key1: val1"
565         ret = salt.utils.data.repack_dictlist(yaml_key_val_pair)
566         self.assertDictEqual(ret, {"key1": "val1"})
567         ret = salt.utils.data.repack_dictlist(LOREM_IPSUM)
568         self.assertDictEqual(ret, {})
569     def test_stringify(self):
570         self.assertRaises(TypeError, salt.utils.data.stringify, 9)
571         self.assertEqual(
572             salt.utils.data.stringify(["one", "two", "three", 4, 5]),
573             ["one", "two", "three", "4", "5"],
574         )
575     def test_json_query(self):
576         with patch("salt.utils.data.jmespath", None):
577             self.assertRaisesRegex(
578                 RuntimeError, "requires jmespath", salt.utils.data.json_query, {}, "@"
579             )
580         user_groups = {
581             "user1": {"groups": ["group1", "group2", "group3"]},
582             "user2": {"groups": ["group1", "group2"]},
583             "user3": {"groups": ["group3"]},
584         }
585         expression = "*.groups[0]"
586         primary_groups = ["group1", "group1", "group3"]
587         self.assertEqual(
588             sorted(salt.utils.data.json_query(user_groups, expression)), primary_groups
589         )
590 class FilterFalseyTestCase(TestCase):
591     """
592     Test suite for salt.utils.data.filter_falsey
593     """
594     def test_nop(self):
595         """
596         Test cases where nothing will be done.
597         """
598         old_dict = {
599             "foo": "bar",
600             "bar": {"baz": {"qux": "quux"}},
601             "baz": ["qux", {"foo": "bar"}],
602         }
603         new_dict = salt.utils.data.filter_falsey(old_dict)
604         self.assertEqual(old_dict, new_dict)
605         self.assertIs(type(old_dict), type(new_dict))
606         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
607         self.assertEqual(old_dict, new_dict)
608         old_list = ["foo", "bar"]
609         new_list = salt.utils.data.filter_falsey(old_list)
610         self.assertEqual(old_list, new_list)
611         self.assertIs(type(old_list), type(new_list))
612         old_set = {"foo", "bar"}
613         new_set = salt.utils.data.filter_falsey(old_set)
614         self.assertEqual(old_set, new_set)
615         self.assertIs(type(old_set), type(new_set))
616         old_dict = OrderedDict(
617             [
618                 ("foo", "bar"),
619                 ("bar", OrderedDict([("qux", "quux")])),
620                 ("baz", ["qux", OrderedDict([("foo", "bar")])]),
621             ]
622         )
623         new_dict = salt.utils.data.filter_falsey(old_dict)
624         self.assertEqual(old_dict, new_dict)
625         self.assertIs(type(old_dict), type(new_dict))
626         old_list = [0]
627         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[int])
628         self.assertEqual(old_list, new_list)
629         old_list = [""]
630         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[str])
631         self.assertEqual(old_list, new_list)
632         old_list = [[]]
633         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type([])])
634         self.assertEqual(old_list, new_list)
635         old_list = [{}]
636         new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type({})])
637         self.assertEqual(old_list, new_list)
638     def test_filter_dict_no_recurse(self):
639         """
640         Test filtering a dictionary without recursing.
641         This will only filter out key-values where the values are falsey.
642         """
643         old_dict = {
644             "foo": None,
645             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
646             "baz": ["qux"],
647             "qux": {},
648             "quux": [],
649         }
650         new_dict = salt.utils.data.filter_falsey(old_dict)
651         expect_dict = {
652             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
653             "baz": ["qux"],
654         }
655         self.assertEqual(expect_dict, new_dict)
656         self.assertIs(type(expect_dict), type(new_dict))
657     def test_filter_dict_recurse(self):
658         """
659         Test filtering a dictionary with recursing.
660         This will filter out any key-values where the values are falsey or when
661         the values *become* falsey after filtering their contents (in case they
662         are lists or dicts).
663         """
664         old_dict = {
665             "foo": None,
666             "bar": {"baz": {"qux": None, "quux": "", "foo": []}},
667             "baz": ["qux"],
668             "qux": {},
669             "quux": [],
670         }
671         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
672         expect_dict = {"baz": ["qux"]}
673         self.assertEqual(expect_dict, new_dict)
674         self.assertIs(type(expect_dict), type(new_dict))
675     def test_filter_list_no_recurse(self):
676         """
677         Test filtering a list without recursing.
678         This will only filter out items which are falsey.
679         """
680         old_list = ["foo", None, [], {}, 0, ""]
681         new_list = salt.utils.data.filter_falsey(old_list)
682         expect_list = ["foo"]
683         self.assertEqual(expect_list, new_list)
684         self.assertIs(type(expect_list), type(new_list))
685         old_list = [
686             "foo",
687             ["foo"],
688             ["foo", None],
689             {"foo": 0},
690             {"foo": "bar", "baz": []},
691             [{"foo": ""}],
692         ]
693         new_list = salt.utils.data.filter_falsey(old_list)
694         self.assertEqual(old_list, new_list)
695         self.assertIs(type(old_list), type(new_list))
696     def test_filter_list_recurse(self):
697         """
698         Test filtering a list with recursing.
699         This will filter out any items which are falsey, or which become falsey
700         after filtering their contents (in case they are lists or dicts).
701         """
702         old_list = [
703             "foo",
704             ["foo"],
705             ["foo", None],
706             {"foo": 0},
707             {"foo": "bar", "baz": []},
708             [{"foo": ""}],
709         ]
710         new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=3)
711         expect_list = ["foo", ["foo"], ["foo"], {"foo": "bar"}]
712         self.assertEqual(expect_list, new_list)
713         self.assertIs(type(expect_list), type(new_list))
714     def test_filter_set_no_recurse(self):
715         """
716         Test filtering a set without recursing.
717         Note that a set cannot contain unhashable types, so recursion is not possible.
718         """
719         old_set = {"foo", None, 0, ""}
720         new_set = salt.utils.data.filter_falsey(old_set)
721         expect_set = {"foo"}
722         self.assertEqual(expect_set, new_set)
723         self.assertIs(type(expect_set), type(new_set))
724     def test_filter_ordereddict_no_recurse(self):
725         """
726         Test filtering an OrderedDict without recursing.
727         """
728         old_dict = OrderedDict(
729             [
730                 ("foo", None),
731                 (
732                     "bar",
733                     OrderedDict(
734                         [
735                             (
736                                 "baz",
737                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
738                             )
739                         ]
740                     ),
741                 ),
742                 ("baz", ["qux"]),
743                 ("qux", {}),
744                 ("quux", []),
745             ]
746         )
747         new_dict = salt.utils.data.filter_falsey(old_dict)
748         expect_dict = OrderedDict(
749             [
750                 (
751                     "bar",
752                     OrderedDict(
753                         [
754                             (
755                                 "baz",
756                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
757                             )
758                         ]
759                     ),
760                 ),
761                 ("baz", ["qux"]),
762             ]
763         )
764         self.assertEqual(expect_dict, new_dict)
765         self.assertIs(type(expect_dict), type(new_dict))
766     def test_filter_ordereddict_recurse(self):
767         """
768         Test filtering an OrderedDict with recursing.
769         """
770         old_dict = OrderedDict(
771             [
772                 ("foo", None),
773                 (
774                     "bar",
775                     OrderedDict(
776                         [
777                             (
778                                 "baz",
779                                 OrderedDict([("qux", None), ("quux", ""), ("foo", [])]),
780                             )
781                         ]
782                     ),
783                 ),
784                 ("baz", ["qux"]),
785                 ("qux", {}),
786                 ("quux", []),
787             ]
788         )
789         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
790         expect_dict = OrderedDict([("baz", ["qux"])])
791         self.assertEqual(expect_dict, new_dict)
792         self.assertIs(type(expect_dict), type(new_dict))
793     def test_filter_list_recurse_limit(self):
794         """
795         Test filtering a list with recursing, but with a limited depth.
796         Note that the top-level is always processed, so a recursion depth of 2
797         means that two *additional* levels are processed.
798         """
799         old_list = [None, [None, [None, [None]]]]
800         new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=2)
801         self.assertEqual([[[[None]]]], new_list)
802     def test_filter_dict_recurse_limit(self):
803         """
804         Test filtering a dict with recursing, but with a limited depth.
805         Note that the top-level is always processed, so a recursion depth of 2
806         means that two *additional* levels are processed.
807         """
808         old_dict = {
809             "one": None,
810             "foo": {"two": None, "bar": {"three": None, "baz": {"four": None}}},
811         }
812         new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=2)
813         self.assertEqual({"foo": {"bar": {"baz": {"four": None}}}}, new_dict)
814     def test_filter_exclude_types(self):
815         """
816         Test filtering a list recursively, but also ignoring (i.e. not filtering)
817         out certain types that can be falsey.
818         """
819         old_list = [
820             "foo",
821             ["foo"],
822             ["foo", None],
823             {"foo": 0},
824             {"foo": "bar", "baz": []},
825             [{"foo": ""}],
826         ]
827         new_list = salt.utils.data.filter_falsey(
828             old_list, recurse_depth=3, ignore_types=[int, str]
829         )
830         self.assertEqual(
831             ["foo", ["foo"], ["foo"], {"foo": 0}, {"foo": "bar"}, [{"foo": ""}]],
832             new_list,
833         )
834         old_list = [
835             "foo",
836             ["foo"],
837             ["foo", None],
838             {"foo": 0},
839             {"foo": "bar", "baz": []},
840             [{"foo": ""}],
841         ]
842         new_list = salt.utils.data.filter_falsey(
843             old_list, recurse_depth=3, ignore_types=[type([])]
844         )
845         self.assertEqual(
846             ["foo", ["foo"], ["foo"], {"foo": "bar", "baz": []}, []], new_list
847         )
848         old_list = [
849             "foo",
850             ["foo"],
851             ["foo", None],
852             {"foo": 0},
853             {"foo": "bar", "baz": []},
854             [{"foo": ""}],
855         ]
856         new_list = salt.utils.data.filter_falsey(
857             old_list, recurse_depth=3, ignore_types=[type({})]
858         )
859         self.assertEqual(["foo", ["foo"], ["foo"], {}, {"foo": "bar"}, [{}]], new_list)
860         old_list = [
861             "foo",
862             ["foo"],
863             ["foo", None],
864             {"foo": 0},
865             {"foo": "bar", "baz": []},
866             [{"foo": ""}],
867         ]
868         new_list = salt.utils.data.filter_falsey(
869             old_list, recurse_depth=3, ignore_types=[type(None)]
870         )
871         self.assertEqual(["foo", ["foo"], ["foo", None], {"foo": "bar"}], new_list)
872 class FilterRecursiveDiff(TestCase):
873     """
874     Test suite for salt.utils.data.recursive_diff
875     """
876     def test_list_equality(self):
877         """
878         Test cases where equal lists are compared.
879         """
880         test_list = [0, 1, 2]
881         self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
882         test_list = [[0], [1], [0, 1, 2]]
883         self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))
884     def test_dict_equality(self):
885         """
886         Test cases where equal dicts are compared.
887         """
888         test_dict = {"foo": "bar", "bar": {"baz": {"qux": "quux"}}, "frop": 0}
889         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
890     def test_ordereddict_equality(self):
891         """
892         Test cases where equal OrderedDicts are compared.
893         """
894         test_dict = OrderedDict(
895             [
896                 ("foo", "bar"),
897                 ("bar", OrderedDict([("baz", OrderedDict([("qux", "quux")]))])),
898                 ("frop", 0),
899             ]
900         )
901         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))
902     def test_mixed_equality(self):
903         """
904         Test cases where mixed nested lists and dicts are compared.
905         """
906         test_data = {
907             "foo": "bar",
908             "baz": [0, 1, 2],
909             "bar": {"baz": [{"qux": "quux"}, {"froop", 0}]},
910         }
911         self.assertEqual({}, salt.utils.data.recursive_diff(test_data, test_data))
912     def test_set_equality(self):
913         """
914         Test cases where equal sets are compared.
915         """
916         test_set = {0, 1, 2, 3, "foo"}
917         self.assertEqual({}, salt.utils.data.recursive_diff(test_set, test_set))
918         set_one = {0, 1, 2, 3}
919         set_two = {3, 2, 1, 0}
920         self.assertEqual({}, salt.utils.data.recursive_diff(set_one, set_two))
921     def test_tuple_equality(self):
922         """
923         Test cases where equal tuples are compared.
924         """
925         test_tuple = (0, 1, 2, 3, "foo")
926         self.assertEqual({}, salt.utils.data.recursive_diff(test_tuple, test_tuple))
927     def test_list_inequality(self):
928         """
929         Test cases where two inequal lists are compared.
930         """
931         list_one = [0, 1, 2]
932         list_two = ["foo", "bar", "baz"]
933         expected_result = {"old": list_one, "new": list_two}
934         self.assertEqual(
935             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
936         )
937         expected_result = {"new": list_one, "old": list_two}
938         self.assertEqual(
939             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
940         )
941         list_one = [0, "foo", 1, "bar"]
942         list_two = [1, "foo", 1, "qux"]
943         expected_result = {"old": [0, "bar"], "new": [1, "qux"]}
944         self.assertEqual(
945             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
946         )
947         expected_result = {"new": [0, "bar"], "old": [1, "qux"]}
948         self.assertEqual(
949             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
950         )
951         list_one = [0, 1, [2, 3]]
952         list_two = [0, 1, ["foo", "bar"]]
953         expected_result = {"old": [[2, 3]], "new": [["foo", "bar"]]}
954         self.assertEqual(
955             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
956         )
957         expected_result = {"new": [[2, 3]], "old": [["foo", "bar"]]}
958         self.assertEqual(
959             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
960         )
961     def test_dict_inequality(self):
962         """
963         Test cases where two inequal dicts are compared.
964         """
965         dict_one = {"foo": 1, "bar": 2, "baz": 3}
966         dict_two = {"foo": 2, 1: "bar", "baz": 3}
967         expected_result = {"old": {"foo": 1, "bar": 2}, "new": {"foo": 2, 1: "bar"}}
968         self.assertEqual(
969             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
970         )
971         expected_result = {"new": {"foo": 1, "bar": 2}, "old": {"foo": 2, 1: "bar"}}
972         self.assertEqual(
973             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
974         )
975         dict_one = {"foo": {"bar": {"baz": 1}}}
976         dict_two = {"foo": {"qux": {"baz": 1}}}
977         expected_result = {"old": dict_one, "new": dict_two}
978         self.assertEqual(
979             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
980         )
981         expected_result = {"new": dict_one, "old": dict_two}
982         self.assertEqual(
983             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
984         )
985     def test_ordereddict_inequality(self):
986         """
987         Test cases where two inequal OrderedDicts are compared.
988         """
989         odict_one = OrderedDict([("foo", "bar"), ("bar", "baz")])
990         odict_two = OrderedDict([("bar", "baz"), ("foo", "bar")])
991         expected_result = {"old": odict_one, "new": odict_two}
992         self.assertEqual(
993             expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
994         )
995     def test_set_inequality(self):
996         """
997         Test cases where two inequal sets are compared.
998         Tricky as the sets are compared zipped, so shuffled sets of equal values
999         are considered different.
1000         """
1001         set_one = {0, 1, 2, 4}
1002         set_two = {0, 1, 3, 4}
1003         expected_result = {"old": {2}, "new": {3}}
1004         self.assertEqual(
1005             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
1006         )
1007         expected_result = {"new": {2}, "old": {3}}
1008         self.assertEqual(
1009             expected_result, salt.utils.data.recursive_diff(set_two, set_one)
1010         )
1011         set_one = {0, "foo", 1, "bar"}
1012         set_two = {"foo", 1, "bar", 2}
1013         expected_result = {}
1014         self.assertNotEqual(
1015             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
1016         )
1017     def test_mixed_inequality(self):
1018         """
1019         Test cases where two mixed dicts/iterables that are different are compared.
1020         """
1021         dict_one = {"foo": [1, 2, 3]}
1022         dict_two = {"foo": [3, 2, 1]}
1023         expected_result = {"old": {"foo": [1, 3]}, "new": {"foo": [3, 1]}}
1024         self.assertEqual(
1025             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
1026         )
1027         expected_result = {"new": {"foo": [1, 3]}, "old": {"foo": [3, 1]}}
1028         self.assertEqual(
1029             expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
1030         )
1031         list_one = [1, 2, {"foo": ["bar", {"foo": 1, "bar": 2}]}]
1032         list_two = [3, 4, {"foo": ["qux", {"foo": 1, "bar": 2}]}]
1033         expected_result = {
1034             "old": [1, 2, {"foo": ["bar"]}],
1035             "new": [3, 4, {"foo": ["qux"]}],
1036         }
1037         self.assertEqual(
1038             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
1039         )
1040         expected_result = {
1041             "new": [1, 2, {"foo": ["bar"]}],
1042             "old": [3, 4, {"foo": ["qux"]}],
1043         }
1044         self.assertEqual(
1045             expected_result, salt.utils.data.recursive_diff(list_two, list_one)
1046         )
1047         mixed_one = {"foo": {0, 1, 2}, "bar": [0, 1, 2]}
1048         mixed_two = {"foo": {1, 2, 3}, "bar": [1, 2, 3]}
1049         expected_result = {
1050             "old": {"foo": {0}, "bar": [0, 1, 2]},
1051             "new": {"foo": {3}, "bar": [1, 2, 3]},
1052         }
1053         self.assertEqual(
1054             expected_result, salt.utils.data.recursive_diff(mixed_one, mixed_two)
1055         )
1056         expected_result = {
1057             "new": {"foo": {0}, "bar": [0, 1, 2]},
1058             "old": {"foo": {3}, "bar": [1, 2, 3]},
1059         }
1060         self.assertEqual(
1061             expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
1062         )
1063     def test_tuple_inequality(self):
1064         """
1065         Test cases where two tuples that are different are compared.
1066         """
1067         tuple_one = (1, 2, 3)
1068         tuple_two = (3, 2, 1)
1069         expected_result = {"old": (1, 3), "new": (3, 1)}
1070         self.assertEqual(
1071             expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
1072         )
1073     def test_list_vs_set(self):
1074         """
1075         Test case comparing a list with a set, will be compared unordered.
1076         """
1077         mixed_one = [1, 2, 3]
1078         expected_result = {}
1079         self.assertEqual(
1080             expected_result, salt.utils.data<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.recursive_diff(mixed_one, mixed_two)
1081         )
1082         self.assertEqual(
1083             expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
1084         )
1085     def test_dict_vs_ordereddict(self):
1086         """
1087         Test case comparing a dict with an ordereddict, will be compared unordered.
1088         """
1089         test_dict = {"foo": "bar", "bar": "baz"}
1090         test_odict = OrderedDict(</b></font>[("foo", "bar"), ("bar", "baz")])
1091         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict))
1092         self.assertEqual({}, salt.utils.data.recursive_diff(test_odict, test_dict))
1093         test_odict2 = OrderedDict([("bar", "baz"), ("foo", "bar")])
1094         self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict2))
1095         self.assertEqual({}, salt.utils.data.recursive_diff(test_odict2, test_dict))
1096     def test_list_ignore_ignored(self):
1097         """
1098         Test case comparing two lists with ignore-list supplied (which is not used
1099         when comparing lists).
1100         """
1101         list_one = [1, 2, 3]
1102         list_two = [3, 2, 1]
1103         expected_result = {"old": [1, 3], "new": [3, 1]}
1104         self.assertEqual(
1105             expected_result,
1106             salt.utils.data.recursive_diff(list_one, list_two, ignore_keys=[1, 3]),
1107         )
1108     def test_dict_ignore(self):
1109         """
1110         Test case comparing two dicts with ignore-list supplied.
1111         """
1112         dict_one = {"foo": 1, "bar": 2, "baz": 3}
1113         dict_two = {"foo": 3, "bar": 2, "baz": 1}
1114         expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
1115         self.assertEqual(
1116             expected_result,
1117             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
1118         )
1119     def test_ordereddict_ignore(self):
1120         """
1121         Test case comparing two OrderedDicts with ignore-list supplied.
1122         """
1123         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1124         odict_two = OrderedDict([("baz", 1), ("bar", 2), ("foo", 3)])
1125         expected_result = {
1126             "old": OrderedDict([("baz", 3)]),
1127             "new": OrderedDict([("baz", 1)]),
1128         }
1129         self.assertEqual(
1130             expected_result,
1131             salt.utils.data.recursive_diff(odict_one, odict_two, ignore_keys=["foo"]),
1132         )
1133     def test_dict_vs_ordereddict_ignore(self):
1134         """
1135         Test case comparing a dict with an OrderedDict with ignore-list supplied.
1136         """
1137         dict_one = {"foo": 1, "bar": 2, "baz": 3}
1138         odict_two = OrderedDict([("foo", 3), ("bar", 2), ("baz", 1)])
1139         expected_result = {"old": {"baz": 3}, "new": OrderedDict([("baz", 1)])}
1140         self.assertEqual(
1141             expected_result,
1142             salt.utils.data.recursive_diff(dict_one, odict_two, ignore_keys=["foo"]),
1143         )
1144     def test_mixed_nested_ignore(self):
1145         """
1146         Test case comparing mixed, nested items with ignore-list supplied.
1147         """
1148         dict_one = {"foo": [1], "bar": {"foo": 1, "bar": 2}, "baz": 3}
1149         dict_two = {"foo": [2], "bar": {"foo": 3, "bar": 2}, "baz": 1}
1150         expected_result = {"old": {"baz": 3}, "new": {"baz": 1}}
1151         self.assertEqual(
1152             expected_result,
1153             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=["foo"]),
1154         )
1155     def test_ordered_dict_unequal_length(self):
1156         """
1157         Test case comparing two OrderedDicts of unequal length.
1158         """
1159         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1160         odict_two = OrderedDict([("foo", 1), ("bar", 2)])
1161         expected_result = {"old": OrderedDict([("baz", 3)]), "new": {}}
1162         self.assertEqual(
1163             expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
1164         )
1165     def test_list_unequal_length(self):
1166         """
1167         Test case comparing two lists of unequal length.
1168         """
1169         list_one = [1, 2, 3]
1170         list_two = [1, 2, 3, 4]
1171         expected_result = {"old": [], "new": [4]}
1172         self.assertEqual(
1173             expected_result, salt.utils.data.recursive_diff(list_one, list_two)
1174         )
1175     def test_set_unequal_length(self):
1176         """
1177         Test case comparing two sets of unequal length.
1178         This does not do anything special, as it is unordered.
1179         """
1180         set_one = {1, 2, 3}
1181         set_two = {4, 3, 2, 1}
1182         expected_result = {"old": set(), "new": {4}}
1183         self.assertEqual(
1184             expected_result, salt.utils.data.recursive_diff(set_one, set_two)
1185         )
1186     def test_tuple_unequal_length(self):
1187         """
1188         Test case comparing two tuples of unequal length.
1189         This should be the same as comparing two ordered lists.
1190         """
1191         tuple_one = (1, 2, 3)
1192         tuple_two = (1, 2, 3, 4)
1193         expected_result = {"old": (), "new": (4,)}
1194         self.assertEqual(
1195             expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
1196         )
1197     def test_list_unordered(self):
1198         """
1199         Test case comparing two lists unordered.
1200         """
1201         list_one = [1, 2, 3, 4]
1202         list_two = [4, 3, 2]
1203         expected_result = {"old": [1], "new": []}
1204         self.assertEqual(
1205             expected_result,
1206             salt.utils.data.recursive_diff(list_one, list_two, ignore_order=True),
1207         )
1208     def test_mixed_nested_unordered(self):
1209         """
1210         Test case comparing nested dicts/lists unordered.
1211         """
1212         dict_one = {"foo": {"bar": [1, 2, 3]}, "bar": [{"foo": 4}, 0]}
1213         dict_two = {"foo": {"bar": [3, 2, 1]}, "bar": [0, {"foo": 4}]}
1214         expected_result = {}
1215         self.assertEqual(
1216             expected_result,
1217             salt.utils.data.recursive_diff(dict_one, dict_two, ignore_order=True),
1218         )
1219         expected_result = {
1220             "old": {"foo": {"bar": [1, 3]}, "bar": [{"foo": 4}, 0]},
1221             "new": {"foo": {"bar": [3, 1]}, "bar": [0, {"foo": 4}]},
1222         }
1223         self.assertEqual(
1224             expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
1225         )
1226     def test_ordered_dict_unordered(self):
1227         """
1228         Test case comparing OrderedDicts unordered.
1229         """
1230         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1231         odict_two = OrderedDict([("baz", 3), ("bar", 2), ("foo", 1)])
1232         expected_result = {}
1233         self.assertEqual(
1234             expected_result,
1235             salt.utils.data.recursive_diff(odict_one, odict_two, ignore_order=True),
1236         )
1237     def test_ignore_missing_keys_dict(self):
1238         """
1239         Test case ignoring missing keys on a comparison of dicts.
1240         """
1241         dict_one = {"foo": 1, "bar": 2, "baz": 3}
1242         dict_two = {"bar": 3}
1243         expected_result = {"old": {"bar": 2}, "new": {"bar": 3}}
1244         self.assertEqual(
1245             expected_result,
1246             salt.utils.data.recursive_diff(
1247                 dict_one, dict_two, ignore_missing_keys=True
1248             ),
1249         )
1250     def test_ignore_missing_keys_ordered_dict(self):
1251         """
1252         Test case not ignoring missing keys on a comparison of OrderedDicts.
1253         """
1254         odict_one = OrderedDict([("foo", 1), ("bar", 2), ("baz", 3)])
1255         odict_two = OrderedDict([("bar", 3)])
1256         expected_result = {"old": odict_one, "new": odict_two}
1257         self.assertEqual(
1258             expected_result,
1259             salt.utils.data.recursive_diff(
1260                 odict_one, odict_two, ignore_missing_keys=True
1261             ),
1262         )
1263     def test_ignore_missing_keys_recursive(self):
1264         """
1265         Test case ignoring missing keys on a comparison of nested dicts.
1266         """
1267         dict_one = {"foo": {"bar": 2, "baz": 3}}
1268         dict_two = {"foo": {"baz": 3}}
1269         expected_result = {}
1270         self.assertEqual(
1271             expected_result,
1272             salt.utils.data.recursive_diff(
1273                 dict_one, dict_two, ignore_missing_keys=True
1274             ),
1275         )
1276         dict_two = {}
1277         self.assertEqual(
1278             expected_result,
1279             salt.utils.data.recursive_diff(
1280                 dict_one, dict_two, ignore_missing_keys=True
1281             ),
1282         )
1283         dict_one = {"foo": ["bar", {"baz": 3}]}
1284         dict_two = {"foo": ["bar", {}]}
1285         self.assertEqual(
1286             expected_result,
1287             salt.utils.data.recursive_diff(
1288                 dict_one, dict_two, ignore_missing_keys=True
1289             ),
1290         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
