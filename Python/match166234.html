<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for riak.py & test_data_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for riak.py & test_data_3.py
      </h3>
      <h1 align="center">
        2.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>riak.py (11.607142%)<TH>test_data_3.py (1.1529933%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match166234-0.html#0',2,'match166234-1.html#0',3)" NAME="0">(24-39)<TD><A HREF="javascript:ZweiFrames('match166234-0.html#0',2,'match166234-1.html#0',3)" NAME="0">(1275-1286)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match166234-0.html#1',2,'match166234-1.html#1',3)" NAME="1">(200-202)<TD><A HREF="javascript:ZweiFrames('match166234-0.html#1',2,'match166234-1.html#1',3)" NAME="1">(369-373)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>riak.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Riak Salt Module
&quot;&quot;&quot;

import salt.utils.path


def __virtual__():
    &quot;&quot;&quot;
    Only available on systems with Riak installed.
    &quot;&quot;&quot;
    if salt.utils.path.which(&quot;riak&quot;):
        return True
    return (
        False,
        &quot;The riak execution module failed to load: the riak binary is not in the path.&quot;,
    )


def __execute_cmd(name, cmd):
<A NAME="0"></A>    &quot;&quot;&quot;
    Execute Riak commands
    &quot;&quot;&quot;
    return __salt__<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match166234-1.html#0',3,'match166234-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;cmd.run_all&quot;](&quot;{} {}&quot;.format(salt.utils.path.which(name), cmd))


def start():
    &quot;&quot;&quot;
    Start Riak

    CLI Example:

    .. code-block:: bash

        salt '*' riak.start
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(</B></FONT>&quot;riak&quot;, &quot;start&quot;)

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stderr&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def stop():
    &quot;&quot;&quot;
    Stop Riak

    .. versionchanged:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.stop
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(&quot;riak&quot;, &quot;stop&quot;)

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stderr&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def cluster_join(username, hostname):
    &quot;&quot;&quot;
    Join a Riak cluster

    .. versionchanged:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.cluster_join &lt;user&gt; &lt;host&gt;

    username - The riak username to join the cluster
    hostname - The riak hostname you are connecting to
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;cluster join {}@{}&quot;.format(username, hostname))

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def cluster_leave(username, hostname):
    &quot;&quot;&quot;
    Leave a Riak cluster

    .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.cluster_leave &lt;username&gt; &lt;host&gt;

    username - The riak username to join the cluster
    hostname - The riak hostname you are connecting to
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;cluster leave {}@{}&quot;.format(username, hostname))

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def cluster_plan():
    &quot;&quot;&quot;
    Review Cluster Plan

    .. versionchanged:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.cluster_plan
    &quot;&quot;&quot;
    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;cluster plan&quot;)

    if cmd[&quot;retcode&quot;] != 0:
        return False

    return True


def cluster_commit():
    &quot;&quot;&quot;
    Commit Cluster Changes

    .. versionchanged:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.cluster_commit
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;cluster commit&quot;)

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def member_status():
    &quot;&quot;&quot;
    Get cluster member status

    .. versionchanged:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.member_status
    &quot;&quot;&quot;
    ret = {
        &quot;membership&quot;: {},
        &quot;summary&quot;: {&quot;Valid&quot;: 0, &quot;Leaving&quot;: 0, &quot;Exiting&quot;: 0, &quot;Joining&quot;: 0, &quot;Down&quot;: 0},
    }

    out = __execute_cmd(&quot;riak-admin&quot;, &quot;member-status&quot;)[&quot;stdout&quot;].splitlines()

    for line in out:
        if line.startswith((&quot;=&quot;, &quot;-&quot;, &quot;Status&quot;)):
<A NAME="1"></A>            continue
        if &quot;/&quot; in line:
            # We're in the summary line
            for item in line<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match166234-1.html#1',3,'match166234-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.split(&quot;/&quot;):
                key, val = item.split(&quot;:&quot;)
                ret[&quot;summary&quot;][key.strip()] = val.strip(</B></FONT>)

        if len(line.split()) == 4:
            # We're on a node status line
            (status, ring, pending, node) = line.split()

            ret[&quot;membership&quot;][node] = {
                &quot;Status&quot;: status,
                &quot;Ring&quot;: ring,
                &quot;Pending&quot;: pending,
            }

    return ret


def status():
    &quot;&quot;&quot;
    Current node status

    .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.status
    &quot;&quot;&quot;
    ret = {}

    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;status&quot;)

    for i in cmd[&quot;stdout&quot;].splitlines():
        if &quot;:&quot; in i:
            (name, val) = i.split(&quot;:&quot;, 1)
            ret[name.strip()] = val.strip()

    return ret


def test():
    &quot;&quot;&quot;
    Runs a test of a few standard Riak operations

    .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.test
    &quot;&quot;&quot;
    ret = {&quot;comment&quot;: &quot;&quot;, &quot;success&quot;: False}

    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;test&quot;)

    if cmd[&quot;retcode&quot;] != 0:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
    else:
        ret[&quot;comment&quot;] = cmd[&quot;stdout&quot;]
        ret[&quot;success&quot;] = True

    return ret


def services():
    &quot;&quot;&quot;
    List available services on a node

    .. versionadded:: 2015.8.0

    CLI Example:

    .. code-block:: bash

        salt '*' riak.services
    &quot;&quot;&quot;
    cmd = __execute_cmd(&quot;riak-admin&quot;, &quot;services&quot;)

    return cmd[&quot;stdout&quot;][1:-1].split(&quot;,&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Tests for salt.utils.data
&quot;&quot;&quot;

import builtins
import logging

import salt.utils.data
import salt.utils.stringutils
from salt.utils.odict import OrderedDict
from tests.support.mock import patch
from tests.support.unit import LOREM_IPSUM, TestCase

log = logging.getLogger(__name__)
_b = lambda x: x.encode(&quot;utf-8&quot;)
_s = lambda x: salt.utils.stringutils.to_str(x, normalize=True)
# Some randomized data that will not decode
BYTES = b&quot;1\x814\x10&quot;

# This is an example of a unicode string with й constructed using two separate
# code points. Do not modify it.
EGGS = &quot;\u044f\u0438\u0306\u0446\u0430&quot;


class DataTestCase(TestCase):
    test_data = [
        &quot;unicode_str&quot;,
        _b(&quot;питон&quot;),
        123,
        456.789,
        True,
        False,
        None,
        EGGS,
        BYTES,
        [123, 456.789, _b(&quot;спам&quot;), True, False, None, EGGS, BYTES],
        (987, 654.321, _b(&quot;яйца&quot;), EGGS, None, (True, EGGS, BYTES)),
        {
            _b(&quot;str_key&quot;): _b(&quot;str_val&quot;),
            None: True,
            123: 456.789,
            EGGS: BYTES,
            _b(&quot;subdict&quot;): {
                &quot;unicode_key&quot;: EGGS,
                _b(&quot;tuple&quot;): (123, &quot;hello&quot;, _b(&quot;world&quot;), True, EGGS, BYTES),
                _b(&quot;list&quot;): [456, _b(&quot;спам&quot;), False, EGGS, BYTES],
            },
        },
        OrderedDict([(_b(&quot;foo&quot;), &quot;bar&quot;), (123, 456), (EGGS, BYTES)]),
    ]

    def test_sorted_ignorecase(self):
        test_list = [&quot;foo&quot;, &quot;Foo&quot;, &quot;bar&quot;, &quot;Bar&quot;]
        expected_list = [&quot;bar&quot;, &quot;Bar&quot;, &quot;foo&quot;, &quot;Foo&quot;]
        self.assertEqual(salt.utils.data.sorted_ignorecase(test_list), expected_list)

    def test_mysql_to_dict(self):
        test_mysql_output = [
            &quot;+----+------+-----------+------+---------+------+-------+------------------+&quot;,
            &quot;| Id | User | Host      | db   | Command | Time | State | Info         &quot;
            &quot;    |&quot;,
            &quot;+----+------+-----------+------+---------+------+-------+------------------+&quot;,
            &quot;|  7 | root | localhost | NULL | Query   |    0 | init  | show&quot;
            &quot; processlist |&quot;,
            &quot;+----+------+-----------+------+---------+------+-------+------------------+&quot;,
        ]

        ret = salt.utils.data.mysql_to_dict(test_mysql_output, &quot;Info&quot;)
        expected_dict = {
            &quot;show processlist&quot;: {
                &quot;Info&quot;: &quot;show processlist&quot;,
                &quot;db&quot;: &quot;NULL&quot;,
                &quot;State&quot;: &quot;init&quot;,
                &quot;Host&quot;: &quot;localhost&quot;,
                &quot;Command&quot;: &quot;Query&quot;,
                &quot;User&quot;: &quot;root&quot;,
                &quot;Time&quot;: 0,
                &quot;Id&quot;: 7,
            }
        }

        self.assertDictEqual(ret, expected_dict)

    def test_subdict_match(self):
        test_two_level_dict = {&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}
        test_two_level_comb_dict = {&quot;foo&quot;: {&quot;bar&quot;: &quot;baz:woz&quot;}}
        test_two_level_dict_and_list = {
            &quot;abc&quot;: [&quot;def&quot;, &quot;ghi&quot;, {&quot;lorem&quot;: {&quot;ipsum&quot;: [{&quot;dolor&quot;: &quot;sit&quot;}]}}],
        }
        test_three_level_dict = {&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: &quot;v&quot;}}}

        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_dict, &quot;foo:bar:baz&quot;)
        )
        # In test_two_level_comb_dict, 'foo:bar' corresponds to 'baz:woz', not
        # 'baz'. This match should return False.
        self.assertFalse(
            salt.utils.data.subdict_match(test_two_level_comb_dict, &quot;foo:bar:baz&quot;)
        )
        # This tests matching with the delimiter in the value part (in other
        # words, that the path 'foo:bar' corresponds to the string 'baz:woz').
        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_comb_dict, &quot;foo:bar:baz:woz&quot;)
        )
        # This would match if test_two_level_comb_dict['foo']['bar'] was equal
        # to 'baz:woz:wiz', or if there was more deep nesting. But it does not,
        # so this should return False.
        self.assertFalse(
            salt.utils.data.subdict_match(
                test_two_level_comb_dict, &quot;foo:bar:baz:woz:wiz&quot;
            )
        )
        # This tests for cases when a key path corresponds to a list. The
        # value part 'ghi' should be successfully matched as it is a member of
        # the list corresponding to key path 'abc'. It is somewhat a
        # duplication of a test within test_traverse_dict_and_list, but
        # salt.utils.data.subdict_match() does more than just invoke
        # salt.utils.traverse_list_and_dict() so this particular assertion is a
        # sanity check.
        self.assertTrue(
            salt.utils.data.subdict_match(test_two_level_dict_and_list, &quot;abc:ghi&quot;)
        )
        # This tests the use case of a dict embedded in a list, embedded in a
        # list, embedded in a dict. This is a rather absurd case, but it
        # confirms that match recursion works properly.
        self.assertTrue(
            salt.utils.data.subdict_match(
                test_two_level_dict_and_list, &quot;abc:lorem:ipsum:dolor:sit&quot;
            )
        )
        # Test four level dict match for reference
        self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, &quot;a:b:c:v&quot;))
        # Test regression in 2015.8 where 'a:c:v' would match 'a:b:c:v'
        self.assertFalse(salt.utils.data.subdict_match(test_three_level_dict, &quot;a:c:v&quot;))
        # Test wildcard match
        self.assertTrue(salt.utils.data.subdict_match(test_three_level_dict, &quot;a:*:c:v&quot;))

    def test_subdict_match_with_wildcards(self):
        &quot;&quot;&quot;
        Tests subdict matching when wildcards are used in the expression
        &quot;&quot;&quot;
        data = {&quot;a&quot;: {&quot;b&quot;: {&quot;ç&quot;: &quot;d&quot;, &quot;é&quot;: [&quot;eff&quot;, &quot;gee&quot;, &quot;8ch&quot;], &quot;ĩ&quot;: {&quot;j&quot;: &quot;k&quot;}}}}
        assert salt.utils.data.subdict_match(data, &quot;*:*:*:*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:*:*:*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:ç:*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:*:ç:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;*:b:ç:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;*:*:ç:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;*:*:*:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:*:*:d&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:ef*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:g*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:j:*&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:j:k&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:*:k&quot;)
        assert salt.utils.data.subdict_match(data, &quot;a:b:*:*:*&quot;)

    def test_traverse_dict(self):
        test_two_level_dict = {&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}

        self.assertDictEqual(
            {&quot;not_found&quot;: &quot;nope&quot;},
            salt.utils.data.traverse_dict(
                test_two_level_dict, &quot;foo:bar:baz&quot;, {&quot;not_found&quot;: &quot;nope&quot;}
            ),
        )
        self.assertEqual(
            &quot;baz&quot;,
            salt.utils.data.traverse_dict(
                test_two_level_dict, &quot;foo:bar&quot;, {&quot;not_found&quot;: &quot;not_found&quot;}
            ),
        )

    def test_traverse_dict_and_list(self):
        test_two_level_dict = {&quot;foo&quot;: {&quot;bar&quot;: &quot;baz&quot;}}
        test_two_level_dict_and_list = {
            &quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;, {&quot;lorem&quot;: {&quot;ipsum&quot;: [{&quot;dolor&quot;: &quot;sit&quot;}]}}]
        }

        # Check traversing too far: salt.utils.data.traverse_dict_and_list() returns
        # the value corresponding to a given key path, and baz is a value
        # corresponding to the key path foo:bar.
        self.assertDictEqual(
            {&quot;not_found&quot;: &quot;nope&quot;},
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict, &quot;foo:bar:baz&quot;, {&quot;not_found&quot;: &quot;nope&quot;}
            ),
        )
        # Now check to ensure that foo:bar corresponds to baz
        self.assertEqual(
            &quot;baz&quot;,
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict, &quot;foo:bar&quot;, {&quot;not_found&quot;: &quot;not_found&quot;}
            ),
        )
        # Check traversing too far
        self.assertDictEqual(
            {&quot;not_found&quot;: &quot;nope&quot;},
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list, &quot;foo:bar&quot;, {&quot;not_found&quot;: &quot;nope&quot;}
            ),
        )
        # Check index 1 (2nd element) of list corresponding to path 'foo'
        self.assertEqual(
            &quot;baz&quot;,
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list, &quot;foo:1&quot;, {&quot;not_found&quot;: &quot;not_found&quot;}
            ),
        )
        # Traverse a couple times into dicts embedded in lists
        self.assertEqual(
            &quot;sit&quot;,
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list,
                &quot;foo:lorem:ipsum:dolor&quot;,
                {&quot;not_found&quot;: &quot;not_found&quot;},
            ),
        )

        # Traverse and match integer key in a nested dict
        # https://github.com/saltstack/salt/issues/56444
        self.assertEqual(
            &quot;it worked&quot;,
            salt.utils.data.traverse_dict_and_list(
                {&quot;foo&quot;: {1234: &quot;it worked&quot;}},
                &quot;foo:1234&quot;,
                &quot;it didn't work&quot;,
            ),
        )
        # Make sure that we properly return the default value when the initial
        # attempt fails and YAML-loading the target key doesn't change its
        # value.
        self.assertEqual(
            &quot;default&quot;,
            salt.utils.data.traverse_dict_and_list(
                {&quot;foo&quot;: {&quot;baz&quot;: &quot;didn't work&quot;}},
                &quot;foo:bar&quot;,
                &quot;default&quot;,
            ),
        )

    def test_issue_39709(self):
        test_two_level_dict_and_list = {
            &quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;, {&quot;lorem&quot;: {&quot;ipsum&quot;: [{&quot;dolor&quot;: &quot;sit&quot;}]}}]
        }

        self.assertEqual(
            &quot;sit&quot;,
            salt.utils.data.traverse_dict_and_list(
                test_two_level_dict_and_list,
                [&quot;foo&quot;, &quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;],
                {&quot;not_found&quot;: &quot;not_found&quot;},
            ),
        )

    def test_compare_dicts(self):
        ret = salt.utils.data.compare_dicts(old={&quot;foo&quot;: &quot;bar&quot;}, new={&quot;foo&quot;: &quot;bar&quot;})
        self.assertEqual(ret, {})

        ret = salt.utils.data.compare_dicts(old={&quot;foo&quot;: &quot;bar&quot;}, new={&quot;foo&quot;: &quot;woz&quot;})
        expected_ret = {&quot;foo&quot;: {&quot;new&quot;: &quot;woz&quot;, &quot;old&quot;: &quot;bar&quot;}}
        self.assertDictEqual(ret, expected_ret)

    def test_compare_lists_no_change(self):
        ret = salt.utils.data.compare_lists(
            old=[1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;], new=[1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
        )
        expected = {}
        self.assertDictEqual(ret, expected)

    def test_compare_lists_changes(self):
        ret = salt.utils.data.compare_lists(
            old=[1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;], new=[1, 2, 4, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
        )
        expected = {&quot;new&quot;: [4, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], &quot;old&quot;: [3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}
        self.assertDictEqual(ret, expected)

    def test_compare_lists_changes_new(self):
        ret = salt.utils.data.compare_lists(old=[1, 2, 3], new=[1, 2, 3, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
        expected = {&quot;new&quot;: [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]}
        self.assertDictEqual(ret, expected)

    def test_compare_lists_changes_old(self):
        ret = salt.utils.data.compare_lists(old=[1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;], new=[1, 2, 3])
        expected = {&quot;old&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}
        self.assertDictEqual(ret, expected)

    def test_decode(self):
        &quot;&quot;&quot;
        Companion to test_decode_to_str, they should both be kept up-to-date
        with one another.

        NOTE: This uses the lambda &quot;_b&quot; defined above in the global scope,
        which encodes a string to a bytestring, assuming utf-8.
        &quot;&quot;&quot;
        expected = [
            &quot;unicode_str&quot;,
            &quot;питон&quot;,
            123,
            456.789,
            True,
            False,
            None,
            &quot;яйца&quot;,
            BYTES,
            [123, 456.789, &quot;спам&quot;, True, False, None, &quot;яйца&quot;, BYTES],
            (987, 654.321, &quot;яйца&quot;, &quot;яйца&quot;, None, (True, &quot;яйца&quot;, BYTES)),
            {
                &quot;str_key&quot;: &quot;str_val&quot;,
                None: True,
                123: 456.789,
                &quot;яйца&quot;: BYTES,
                &quot;subdict&quot;: {
                    &quot;unicode_key&quot;: &quot;яйца&quot;,
                    &quot;tuple&quot;: (123, &quot;hello&quot;, &quot;world&quot;, True, &quot;яйца&quot;, BYTES),
                    &quot;list&quot;: [456, &quot;спам&quot;, False, &quot;яйца&quot;, BYTES],
                },
            },
            OrderedDict([(&quot;foo&quot;, &quot;bar&quot;), (123, 456), (&quot;яйца&quot;, BYTES)]),
        ]

        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
        )
        self.assertEqual(ret, expected)

        # The binary data in the data structure should fail to decode, even
        # using the fallback, and raise an exception.
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            self.test_data,
            keep=False,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
        )

        # Now munge the expected data so that we get what we would expect if we
        # disable preservation of dict class and tuples
        expected[10] = [987, 654.321, &quot;яйца&quot;, &quot;яйца&quot;, None, [True, &quot;яйца&quot;, BYTES]]
        expected[11][&quot;subdict&quot;][&quot;tuple&quot;] = [123, &quot;hello&quot;, &quot;world&quot;, True, &quot;яйца&quot;, BYTES]
        expected[12] = {&quot;foo&quot;: &quot;bar&quot;, 123: 456, &quot;яйца&quot;: BYTES}

        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=False,
            preserve_tuples=False,
        )
        self.assertEqual(ret, expected)

        # Now test single non-string, non-data-structure items, these should
        # return the same value when passed to this function
        for item in (123, 4.56, True, False, None):
            log.debug(&quot;Testing decode of %s&quot;, item)
            self.assertEqual(salt.utils.data.decode(item), item)

<A NAME="1"></A>        # Test single strings (not in a data structure)
        self.assertEqual(salt.utils.data.decode(&quot;foo&quot;), &quot;foo&quot;)
        self.assertEqual(salt.utils.data.decode(_b(&quot;bar&quot;)), &quot;bar&quot;)
        self.assertEqual(salt.utils.data<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match166234-0.html#1',2,'match166234-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.decode(EGGS, normalize=True), &quot;яйца&quot;)
        self.assertEqual(salt.utils.data.decode(EGGS, normalize=False), EGGS)

        # Test binary blob
        self.assertEqual(</B></FONT>salt.utils.data.decode(BYTES, keep=True), BYTES)
        self.assertRaises(UnicodeDecodeError, salt.utils.data.decode, BYTES, keep=False)

    def test_circular_refs_dicts(self):
        test_dict = {&quot;key&quot;: &quot;value&quot;, &quot;type&quot;: &quot;test1&quot;}
        test_dict[&quot;self&quot;] = test_dict
        ret = salt.utils.data._remove_circular_refs(ob=test_dict)
        self.assertDictEqual(ret, {&quot;key&quot;: &quot;value&quot;, &quot;type&quot;: &quot;test1&quot;, &quot;self&quot;: None})

    def test_circular_refs_lists(self):
        test_list = {
            &quot;foo&quot;: [],
        }
        test_list[&quot;foo&quot;].append((test_list,))
        ret = salt.utils.data._remove_circular_refs(ob=test_list)
        self.assertDictEqual(ret, {&quot;foo&quot;: [(None,)]})

    def test_circular_refs_tuple(self):
        test_dup = {&quot;foo&quot;: &quot;string 1&quot;, &quot;bar&quot;: &quot;string 1&quot;, &quot;ham&quot;: 1, &quot;spam&quot;: 1}
        ret = salt.utils.data._remove_circular_refs(ob=test_dup)
        self.assertDictEqual(
            ret, {&quot;foo&quot;: &quot;string 1&quot;, &quot;bar&quot;: &quot;string 1&quot;, &quot;ham&quot;: 1, &quot;spam&quot;: 1}
        )

    def test_decode_to_str(self):
        &quot;&quot;&quot;
        Companion to test_decode, they should both be kept up-to-date with one
        another.

        NOTE: This uses the lambda &quot;_s&quot; defined above in the global scope,
        which converts the string/bytestring to a str type.
        &quot;&quot;&quot;
        expected = [
            _s(&quot;unicode_str&quot;),
            _s(&quot;питон&quot;),
            123,
            456.789,
            True,
            False,
            None,
            _s(&quot;яйца&quot;),
            BYTES,
            [123, 456.789, _s(&quot;спам&quot;), True, False, None, _s(&quot;яйца&quot;), BYTES],
            (987, 654.321, _s(&quot;яйца&quot;), _s(&quot;яйца&quot;), None, (True, _s(&quot;яйца&quot;), BYTES)),
            {
                _s(&quot;str_key&quot;): _s(&quot;str_val&quot;),
                None: True,
                123: 456.789,
                _s(&quot;яйца&quot;): BYTES,
                _s(&quot;subdict&quot;): {
                    _s(&quot;unicode_key&quot;): _s(&quot;яйца&quot;),
                    _s(&quot;tuple&quot;): (
                        123,
                        _s(&quot;hello&quot;),
                        _s(&quot;world&quot;),
                        True,
                        _s(&quot;яйца&quot;),
                        BYTES,
                    ),
                    _s(&quot;list&quot;): [456, _s(&quot;спам&quot;), False, _s(&quot;яйца&quot;), BYTES],
                },
            },
            OrderedDict([(_s(&quot;foo&quot;), _s(&quot;bar&quot;)), (123, 456), (_s(&quot;яйца&quot;), BYTES)]),
        ]

        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
            to_str=True,
        )
        self.assertEqual(ret, expected)

        # The binary data in the data structure should fail to decode, even
        # using the fallback, and raise an exception.
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            self.test_data,
            keep=False,
            normalize=True,
            preserve_dict_class=True,
            preserve_tuples=True,
            to_str=True,
        )

        # Now munge the expected data so that we get what we would expect if we
        # disable preservation of dict class and tuples
        expected[10] = [
            987,
            654.321,
            _s(&quot;яйца&quot;),
            _s(&quot;яйца&quot;),
            None,
            [True, _s(&quot;яйца&quot;), BYTES],
        ]
        expected[11][_s(&quot;subdict&quot;)][_s(&quot;tuple&quot;)] = [
            123,
            _s(&quot;hello&quot;),
            _s(&quot;world&quot;),
            True,
            _s(&quot;яйца&quot;),
            BYTES,
        ]
        expected[12] = {_s(&quot;foo&quot;): _s(&quot;bar&quot;), 123: 456, _s(&quot;яйца&quot;): BYTES}

        ret = salt.utils.data.decode(
            self.test_data,
            keep=True,
            normalize=True,
            preserve_dict_class=False,
            preserve_tuples=False,
            to_str=True,
        )
        self.assertEqual(ret, expected)

        # Now test single non-string, non-data-structure items, these should
        # return the same value when passed to this function
        for item in (123, 4.56, True, False, None):
            log.debug(&quot;Testing decode of %s&quot;, item)
            self.assertEqual(salt.utils.data.decode(item, to_str=True), item)

        # Test single strings (not in a data structure)
        self.assertEqual(salt.utils.data.decode(&quot;foo&quot;, to_str=True), _s(&quot;foo&quot;))
        self.assertEqual(salt.utils.data.decode(_b(&quot;bar&quot;), to_str=True), _s(&quot;bar&quot;))

        # Test binary blob
        self.assertEqual(salt.utils.data.decode(BYTES, keep=True, to_str=True), BYTES)
        self.assertRaises(
            UnicodeDecodeError,
            salt.utils.data.decode,
            BYTES,
            keep=False,
            to_str=True,
        )

    def test_decode_fallback(self):
        &quot;&quot;&quot;
        Test fallback to utf-8
        &quot;&quot;&quot;
        with patch.object(builtins, &quot;__salt_system_encoding__&quot;, &quot;ascii&quot;):
            self.assertEqual(salt.utils.data.decode(_b(&quot;яйца&quot;)), &quot;яйца&quot;)

    def test_encode(self):
        &quot;&quot;&quot;
        NOTE: This uses the lambda &quot;_b&quot; defined above in the global scope,
        which encodes a string to a bytestring, assuming utf-8.
        &quot;&quot;&quot;
        expected = [
            _b(&quot;unicode_str&quot;),
            _b(&quot;питон&quot;),
            123,
            456.789,
            True,
            False,
            None,
            _b(EGGS),
            BYTES,
            [123, 456.789, _b(&quot;спам&quot;), True, False, None, _b(EGGS), BYTES],
            (987, 654.321, _b(&quot;яйца&quot;), _b(EGGS), None, (True, _b(EGGS), BYTES)),
            {
                _b(&quot;str_key&quot;): _b(&quot;str_val&quot;),
                None: True,
                123: 456.789,
                _b(EGGS): BYTES,
                _b(&quot;subdict&quot;): {
                    _b(&quot;unicode_key&quot;): _b(EGGS),
                    _b(&quot;tuple&quot;): (123, _b(&quot;hello&quot;), _b(&quot;world&quot;), True, _b(EGGS), BYTES),
                    _b(&quot;list&quot;): [456, _b(&quot;спам&quot;), False, _b(EGGS), BYTES],
                },
            },
            OrderedDict([(_b(&quot;foo&quot;), _b(&quot;bar&quot;)), (123, 456), (_b(EGGS), BYTES)]),
        ]

        # Both keep=True and keep=False should work because the BYTES data is
        # already bytes.
        ret = salt.utils.data.encode(
            self.test_data, keep=True, preserve_dict_class=True, preserve_tuples=True
        )
        self.assertEqual(ret, expected)
        ret = salt.utils.data.encode(
            self.test_data, keep=False, preserve_dict_class=True, preserve_tuples=True
        )
        self.assertEqual(ret, expected)

        # Now munge the expected data so that we get what we would expect if we
        # disable preservation of dict class and tuples
        expected[10] = [
            987,
            654.321,
            _b(&quot;яйца&quot;),
            _b(EGGS),
            None,
            [True, _b(EGGS), BYTES],
        ]
        expected[11][_b(&quot;subdict&quot;)][_b(&quot;tuple&quot;)] = [
            123,
            _b(&quot;hello&quot;),
            _b(&quot;world&quot;),
            True,
            _b(EGGS),
            BYTES,
        ]
        expected[12] = {_b(&quot;foo&quot;): _b(&quot;bar&quot;), 123: 456, _b(EGGS): BYTES}

        ret = salt.utils.data.encode(
            self.test_data, keep=True, preserve_dict_class=False, preserve_tuples=False
        )
        self.assertEqual(ret, expected)
        ret = salt.utils.data.encode(
            self.test_data, keep=False, preserve_dict_class=False, preserve_tuples=False
        )
        self.assertEqual(ret, expected)

        # Now test single non-string, non-data-structure items, these should
        # return the same value when passed to this function
        for item in (123, 4.56, True, False, None):
            log.debug(&quot;Testing encode of %s&quot;, item)
            self.assertEqual(salt.utils.data.encode(item), item)

        # Test single strings (not in a data structure)
        self.assertEqual(salt.utils.data.encode(&quot;foo&quot;), _b(&quot;foo&quot;))
        self.assertEqual(salt.utils.data.encode(_b(&quot;bar&quot;)), _b(&quot;bar&quot;))

        # Test binary blob, nothing should happen even when keep=False since
        # the data is already bytes
        self.assertEqual(salt.utils.data.encode(BYTES, keep=True), BYTES)
        self.assertEqual(salt.utils.data.encode(BYTES, keep=False), BYTES)

    def test_encode_keep(self):
        &quot;&quot;&quot;
        Whereas we tested the keep argument in test_decode, it is much easier
        to do a more comprehensive test of keep in its own function where we
        can force the encoding.
        &quot;&quot;&quot;
        unicode_str = &quot;питон&quot;
        encoding = &quot;ascii&quot;

        # Test single string
        self.assertEqual(
            salt.utils.data.encode(unicode_str, encoding, keep=True), unicode_str
        )
        self.assertRaises(
            UnicodeEncodeError,
            salt.utils.data.encode,
            unicode_str,
            encoding,
            keep=False,
        )

        data = [
            unicode_str,
            [b&quot;foo&quot;, [unicode_str], {b&quot;key&quot;: unicode_str}, (unicode_str,)],
            {
                b&quot;list&quot;: [b&quot;foo&quot;, unicode_str],
                b&quot;dict&quot;: {b&quot;key&quot;: unicode_str},
                b&quot;tuple&quot;: (b&quot;foo&quot;, unicode_str),
            },
            ([b&quot;foo&quot;, unicode_str], {b&quot;key&quot;: unicode_str}, (unicode_str,)),
        ]

        # Since everything was a bytestring aside from the bogus data, the
        # return data should be identical. We don't need to test recursive
        # decoding, that has already been tested in test_encode.
        self.assertEqual(
            salt.utils.data.encode(data, encoding, keep=True, preserve_tuples=True),
            data,
        )
        self.assertRaises(
            UnicodeEncodeError,
            salt.utils.data.encode,
            data,
            encoding,
            keep=False,
            preserve_tuples=True,
        )

        for index, _ in enumerate(data):
            self.assertEqual(
                salt.utils.data.encode(
                    data[index], encoding, keep=True, preserve_tuples=True
                ),
                data[index],
            )
            self.assertRaises(
                UnicodeEncodeError,
                salt.utils.data.encode,
                data[index],
                encoding,
                keep=False,
                preserve_tuples=True,
            )

    def test_encode_fallback(self):
        &quot;&quot;&quot;
        Test fallback to utf-8
        &quot;&quot;&quot;
        with patch.object(builtins, &quot;__salt_system_encoding__&quot;, &quot;ascii&quot;):
            self.assertEqual(salt.utils.data.encode(&quot;яйца&quot;), _b(&quot;яйца&quot;))
        with patch.object(builtins, &quot;__salt_system_encoding__&quot;, &quot;CP1252&quot;):
            self.assertEqual(salt.utils.data.encode(&quot;Ψ&quot;), _b(&quot;Ψ&quot;))

    def test_repack_dict(self):
        list_of_one_element_dicts = [
            {&quot;dict_key_1&quot;: &quot;dict_val_1&quot;},
            {&quot;dict_key_2&quot;: &quot;dict_val_2&quot;},
            {&quot;dict_key_3&quot;: &quot;dict_val_3&quot;},
        ]
        expected_ret = {
            &quot;dict_key_1&quot;: &quot;dict_val_1&quot;,
            &quot;dict_key_2&quot;: &quot;dict_val_2&quot;,
            &quot;dict_key_3&quot;: &quot;dict_val_3&quot;,
        }
        ret = salt.utils.data.repack_dictlist(list_of_one_element_dicts)
        self.assertDictEqual(ret, expected_ret)

        # Try with yaml
        yaml_key_val_pair = &quot;- key1: val1&quot;
        ret = salt.utils.data.repack_dictlist(yaml_key_val_pair)
        self.assertDictEqual(ret, {&quot;key1&quot;: &quot;val1&quot;})

        # Make sure we handle non-yaml junk data
        ret = salt.utils.data.repack_dictlist(LOREM_IPSUM)
        self.assertDictEqual(ret, {})

    def test_stringify(self):
        self.assertRaises(TypeError, salt.utils.data.stringify, 9)
        self.assertEqual(
            salt.utils.data.stringify([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 4, 5]),
            [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;4&quot;, &quot;5&quot;],
        )

    def test_json_query(self):
        # Raises exception if jmespath module is not found
        with patch(&quot;salt.utils.data.jmespath&quot;, None):
            self.assertRaisesRegex(
                RuntimeError, &quot;requires jmespath&quot;, salt.utils.data.json_query, {}, &quot;@&quot;
            )

        # Test search
        user_groups = {
            &quot;user1&quot;: {&quot;groups&quot;: [&quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;]},
            &quot;user2&quot;: {&quot;groups&quot;: [&quot;group1&quot;, &quot;group2&quot;]},
            &quot;user3&quot;: {&quot;groups&quot;: [&quot;group3&quot;]},
        }
        expression = &quot;*.groups[0]&quot;
        primary_groups = [&quot;group1&quot;, &quot;group1&quot;, &quot;group3&quot;]
        self.assertEqual(
            sorted(salt.utils.data.json_query(user_groups, expression)), primary_groups
        )


class FilterFalseyTestCase(TestCase):
    &quot;&quot;&quot;
    Test suite for salt.utils.data.filter_falsey
    &quot;&quot;&quot;

    def test_nop(self):
        &quot;&quot;&quot;
        Test cases where nothing will be done.
        &quot;&quot;&quot;
        # Test with dictionary without recursion
        old_dict = {
            &quot;foo&quot;: &quot;bar&quot;,
            &quot;bar&quot;: {&quot;baz&quot;: {&quot;qux&quot;: &quot;quux&quot;}},
            &quot;baz&quot;: [&quot;qux&quot;, {&quot;foo&quot;: &quot;bar&quot;}],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict)
        self.assertEqual(old_dict, new_dict)
        # Check returned type equality
        self.assertIs(type(old_dict), type(new_dict))
        # Test dictionary with recursion
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        self.assertEqual(old_dict, new_dict)
        # Test with list
        old_list = [&quot;foo&quot;, &quot;bar&quot;]
        new_list = salt.utils.data.filter_falsey(old_list)
        self.assertEqual(old_list, new_list)
        # Check returned type equality
        self.assertIs(type(old_list), type(new_list))
        # Test with set
        old_set = {&quot;foo&quot;, &quot;bar&quot;}
        new_set = salt.utils.data.filter_falsey(old_set)
        self.assertEqual(old_set, new_set)
        # Check returned type equality
        self.assertIs(type(old_set), type(new_set))
        # Test with OrderedDict
        old_dict = OrderedDict(
            [
                (&quot;foo&quot;, &quot;bar&quot;),
                (&quot;bar&quot;, OrderedDict([(&quot;qux&quot;, &quot;quux&quot;)])),
                (&quot;baz&quot;, [&quot;qux&quot;, OrderedDict([(&quot;foo&quot;, &quot;bar&quot;)])]),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict)
        self.assertEqual(old_dict, new_dict)
        self.assertIs(type(old_dict), type(new_dict))
        # Test excluding int
        old_list = [0]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[int])
        self.assertEqual(old_list, new_list)
        # Test excluding str (or unicode) (or both)
        old_list = [&quot;&quot;]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[str])
        self.assertEqual(old_list, new_list)
        # Test excluding list
        old_list = [[]]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type([])])
        self.assertEqual(old_list, new_list)
        # Test excluding dict
        old_list = [{}]
        new_list = salt.utils.data.filter_falsey(old_list, ignore_types=[type({})])
        self.assertEqual(old_list, new_list)

    def test_filter_dict_no_recurse(self):
        &quot;&quot;&quot;
        Test filtering a dictionary without recursing.
        This will only filter out key-values where the values are falsey.
        &quot;&quot;&quot;
        old_dict = {
            &quot;foo&quot;: None,
            &quot;bar&quot;: {&quot;baz&quot;: {&quot;qux&quot;: None, &quot;quux&quot;: &quot;&quot;, &quot;foo&quot;: []}},
            &quot;baz&quot;: [&quot;qux&quot;],
            &quot;qux&quot;: {},
            &quot;quux&quot;: [],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict)
        expect_dict = {
            &quot;bar&quot;: {&quot;baz&quot;: {&quot;qux&quot;: None, &quot;quux&quot;: &quot;&quot;, &quot;foo&quot;: []}},
            &quot;baz&quot;: [&quot;qux&quot;],
        }
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))

    def test_filter_dict_recurse(self):
        &quot;&quot;&quot;
        Test filtering a dictionary with recursing.
        This will filter out any key-values where the values are falsey or when
        the values *become* falsey after filtering their contents (in case they
        are lists or dicts).
        &quot;&quot;&quot;
        old_dict = {
            &quot;foo&quot;: None,
            &quot;bar&quot;: {&quot;baz&quot;: {&quot;qux&quot;: None, &quot;quux&quot;: &quot;&quot;, &quot;foo&quot;: []}},
            &quot;baz&quot;: [&quot;qux&quot;],
            &quot;qux&quot;: {},
            &quot;quux&quot;: [],
        }
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        expect_dict = {&quot;baz&quot;: [&quot;qux&quot;]}
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))

    def test_filter_list_no_recurse(self):
        &quot;&quot;&quot;
        Test filtering a list without recursing.
        This will only filter out items which are falsey.
        &quot;&quot;&quot;
        old_list = [&quot;foo&quot;, None, [], {}, 0, &quot;&quot;]
        new_list = salt.utils.data.filter_falsey(old_list)
        expect_list = [&quot;foo&quot;]
        self.assertEqual(expect_list, new_list)
        self.assertIs(type(expect_list), type(new_list))
        # Ensure nested values are *not* filtered out.
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(old_list)
        self.assertEqual(old_list, new_list)
        self.assertIs(type(old_list), type(new_list))

    def test_filter_list_recurse(self):
        &quot;&quot;&quot;
        Test filtering a list with recursing.
        This will filter out any items which are falsey, or which become falsey
        after filtering their contents (in case they are lists or dicts).
        &quot;&quot;&quot;
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=3)
        expect_list = [&quot;foo&quot;, [&quot;foo&quot;], [&quot;foo&quot;], {&quot;foo&quot;: &quot;bar&quot;}]
        self.assertEqual(expect_list, new_list)
        self.assertIs(type(expect_list), type(new_list))

    def test_filter_set_no_recurse(self):
        &quot;&quot;&quot;
        Test filtering a set without recursing.
        Note that a set cannot contain unhashable types, so recursion is not possible.
        &quot;&quot;&quot;
        old_set = {&quot;foo&quot;, None, 0, &quot;&quot;}
        new_set = salt.utils.data.filter_falsey(old_set)
        expect_set = {&quot;foo&quot;}
        self.assertEqual(expect_set, new_set)
        self.assertIs(type(expect_set), type(new_set))

    def test_filter_ordereddict_no_recurse(self):
        &quot;&quot;&quot;
        Test filtering an OrderedDict without recursing.
        &quot;&quot;&quot;
        old_dict = OrderedDict(
            [
                (&quot;foo&quot;, None),
                (
                    &quot;bar&quot;,
                    OrderedDict(
                        [
                            (
                                &quot;baz&quot;,
                                OrderedDict([(&quot;qux&quot;, None), (&quot;quux&quot;, &quot;&quot;), (&quot;foo&quot;, [])]),
                            )
                        ]
                    ),
                ),
                (&quot;baz&quot;, [&quot;qux&quot;]),
                (&quot;qux&quot;, {}),
                (&quot;quux&quot;, []),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict)
        expect_dict = OrderedDict(
            [
                (
                    &quot;bar&quot;,
                    OrderedDict(
                        [
                            (
                                &quot;baz&quot;,
                                OrderedDict([(&quot;qux&quot;, None), (&quot;quux&quot;, &quot;&quot;), (&quot;foo&quot;, [])]),
                            )
                        ]
                    ),
                ),
                (&quot;baz&quot;, [&quot;qux&quot;]),
            ]
        )
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))

    def test_filter_ordereddict_recurse(self):
        &quot;&quot;&quot;
        Test filtering an OrderedDict with recursing.
        &quot;&quot;&quot;
        old_dict = OrderedDict(
            [
                (&quot;foo&quot;, None),
                (
                    &quot;bar&quot;,
                    OrderedDict(
                        [
                            (
                                &quot;baz&quot;,
                                OrderedDict([(&quot;qux&quot;, None), (&quot;quux&quot;, &quot;&quot;), (&quot;foo&quot;, [])]),
                            )
                        ]
                    ),
                ),
                (&quot;baz&quot;, [&quot;qux&quot;]),
                (&quot;qux&quot;, {}),
                (&quot;quux&quot;, []),
            ]
        )
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=3)
        expect_dict = OrderedDict([(&quot;baz&quot;, [&quot;qux&quot;])])
        self.assertEqual(expect_dict, new_dict)
        self.assertIs(type(expect_dict), type(new_dict))

    def test_filter_list_recurse_limit(self):
        &quot;&quot;&quot;
        Test filtering a list with recursing, but with a limited depth.
        Note that the top-level is always processed, so a recursion depth of 2
        means that two *additional* levels are processed.
        &quot;&quot;&quot;
        old_list = [None, [None, [None, [None]]]]
        new_list = salt.utils.data.filter_falsey(old_list, recurse_depth=2)
        self.assertEqual([[[[None]]]], new_list)

    def test_filter_dict_recurse_limit(self):
        &quot;&quot;&quot;
        Test filtering a dict with recursing, but with a limited depth.
        Note that the top-level is always processed, so a recursion depth of 2
        means that two *additional* levels are processed.
        &quot;&quot;&quot;
        old_dict = {
            &quot;one&quot;: None,
            &quot;foo&quot;: {&quot;two&quot;: None, &quot;bar&quot;: {&quot;three&quot;: None, &quot;baz&quot;: {&quot;four&quot;: None}}},
        }
        new_dict = salt.utils.data.filter_falsey(old_dict, recurse_depth=2)
        self.assertEqual({&quot;foo&quot;: {&quot;bar&quot;: {&quot;baz&quot;: {&quot;four&quot;: None}}}}, new_dict)

    def test_filter_exclude_types(self):
        &quot;&quot;&quot;
        Test filtering a list recursively, but also ignoring (i.e. not filtering)
        out certain types that can be falsey.
        &quot;&quot;&quot;
        # Ignore int, unicode
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[int, str]
        )
        self.assertEqual(
            [&quot;foo&quot;, [&quot;foo&quot;], [&quot;foo&quot;], {&quot;foo&quot;: 0}, {&quot;foo&quot;: &quot;bar&quot;}, [{&quot;foo&quot;: &quot;&quot;}]],
            new_list,
        )
        # Ignore list
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type([])]
        )
        self.assertEqual(
            [&quot;foo&quot;, [&quot;foo&quot;], [&quot;foo&quot;], {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []}, []], new_list
        )
        # Ignore dict
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type({})]
        )
        self.assertEqual([&quot;foo&quot;, [&quot;foo&quot;], [&quot;foo&quot;], {}, {&quot;foo&quot;: &quot;bar&quot;}, [{}]], new_list)
        # Ignore NoneType
        old_list = [
            &quot;foo&quot;,
            [&quot;foo&quot;],
            [&quot;foo&quot;, None],
            {&quot;foo&quot;: 0},
            {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: []},
            [{&quot;foo&quot;: &quot;&quot;}],
        ]
        new_list = salt.utils.data.filter_falsey(
            old_list, recurse_depth=3, ignore_types=[type(None)]
        )
        self.assertEqual([&quot;foo&quot;, [&quot;foo&quot;], [&quot;foo&quot;, None], {&quot;foo&quot;: &quot;bar&quot;}], new_list)


class FilterRecursiveDiff(TestCase):
    &quot;&quot;&quot;
    Test suite for salt.utils.data.recursive_diff
    &quot;&quot;&quot;

    def test_list_equality(self):
        &quot;&quot;&quot;
        Test cases where equal lists are compared.
        &quot;&quot;&quot;
        test_list = [0, 1, 2]
        self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))

        test_list = [[0], [1], [0, 1, 2]]
        self.assertEqual({}, salt.utils.data.recursive_diff(test_list, test_list))

    def test_dict_equality(self):
        &quot;&quot;&quot;
        Test cases where equal dicts are compared.
        &quot;&quot;&quot;
        test_dict = {&quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: {&quot;baz&quot;: {&quot;qux&quot;: &quot;quux&quot;}}, &quot;frop&quot;: 0}
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))

    def test_ordereddict_equality(self):
        &quot;&quot;&quot;
        Test cases where equal OrderedDicts are compared.
        &quot;&quot;&quot;
        test_dict = OrderedDict(
            [
                (&quot;foo&quot;, &quot;bar&quot;),
                (&quot;bar&quot;, OrderedDict([(&quot;baz&quot;, OrderedDict([(&quot;qux&quot;, &quot;quux&quot;)]))])),
                (&quot;frop&quot;, 0),
            ]
        )
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_dict))

    def test_mixed_equality(self):
        &quot;&quot;&quot;
        Test cases where mixed nested lists and dicts are compared.
        &quot;&quot;&quot;
        test_data = {
            &quot;foo&quot;: &quot;bar&quot;,
            &quot;baz&quot;: [0, 1, 2],
            &quot;bar&quot;: {&quot;baz&quot;: [{&quot;qux&quot;: &quot;quux&quot;}, {&quot;froop&quot;, 0}]},
        }
        self.assertEqual({}, salt.utils.data.recursive_diff(test_data, test_data))

    def test_set_equality(self):
        &quot;&quot;&quot;
        Test cases where equal sets are compared.
        &quot;&quot;&quot;
        test_set = {0, 1, 2, 3, &quot;foo&quot;}
        self.assertEqual({}, salt.utils.data.recursive_diff(test_set, test_set))

        # This is a bit of an oddity, as python seems to sort the sets in memory
        # so both sets end up with the same ordering (0..3).
        set_one = {0, 1, 2, 3}
        set_two = {3, 2, 1, 0}
        self.assertEqual({}, salt.utils.data.recursive_diff(set_one, set_two))

    def test_tuple_equality(self):
        &quot;&quot;&quot;
        Test cases where equal tuples are compared.
        &quot;&quot;&quot;
        test_tuple = (0, 1, 2, 3, &quot;foo&quot;)
        self.assertEqual({}, salt.utils.data.recursive_diff(test_tuple, test_tuple))

    def test_list_inequality(self):
        &quot;&quot;&quot;
        Test cases where two inequal lists are compared.
        &quot;&quot;&quot;
        list_one = [0, 1, 2]
        list_two = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
        expected_result = {&quot;old&quot;: list_one, &quot;new&quot;: list_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {&quot;new&quot;: list_one, &quot;old&quot;: list_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )

        list_one = [0, &quot;foo&quot;, 1, &quot;bar&quot;]
        list_two = [1, &quot;foo&quot;, 1, &quot;qux&quot;]
        expected_result = {&quot;old&quot;: [0, &quot;bar&quot;], &quot;new&quot;: [1, &quot;qux&quot;]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {&quot;new&quot;: [0, &quot;bar&quot;], &quot;old&quot;: [1, &quot;qux&quot;]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )

        list_one = [0, 1, [2, 3]]
        list_two = [0, 1, [&quot;foo&quot;, &quot;bar&quot;]]
        expected_result = {&quot;old&quot;: [[2, 3]], &quot;new&quot;: [[&quot;foo&quot;, &quot;bar&quot;]]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {&quot;new&quot;: [[2, 3]], &quot;old&quot;: [[&quot;foo&quot;, &quot;bar&quot;]]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )

    def test_dict_inequality(self):
        &quot;&quot;&quot;
        Test cases where two inequal dicts are compared.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;baz&quot;: 3}
        dict_two = {&quot;foo&quot;: 2, 1: &quot;bar&quot;, &quot;baz&quot;: 3}
        expected_result = {&quot;old&quot;: {&quot;foo&quot;: 1, &quot;bar&quot;: 2}, &quot;new&quot;: {&quot;foo&quot;: 2, 1: &quot;bar&quot;}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {&quot;new&quot;: {&quot;foo&quot;: 1, &quot;bar&quot;: 2}, &quot;old&quot;: {&quot;foo&quot;: 2, 1: &quot;bar&quot;}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )

        dict_one = {&quot;foo&quot;: {&quot;bar&quot;: {&quot;baz&quot;: 1}}}
        dict_two = {&quot;foo&quot;: {&quot;qux&quot;: {&quot;baz&quot;: 1}}}
        expected_result = {&quot;old&quot;: dict_one, &quot;new&quot;: dict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {&quot;new&quot;: dict_one, &quot;old&quot;: dict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )

    def test_ordereddict_inequality(self):
        &quot;&quot;&quot;
        Test cases where two inequal OrderedDicts are compared.
        &quot;&quot;&quot;
        odict_one = OrderedDict([(&quot;foo&quot;, &quot;bar&quot;), (&quot;bar&quot;, &quot;baz&quot;)])
        odict_two = OrderedDict([(&quot;bar&quot;, &quot;baz&quot;), (&quot;foo&quot;, &quot;bar&quot;)])
        expected_result = {&quot;old&quot;: odict_one, &quot;new&quot;: odict_two}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
        )

    def test_set_inequality(self):
        &quot;&quot;&quot;
        Test cases where two inequal sets are compared.
        Tricky as the sets are compared zipped, so shuffled sets of equal values
        are considered different.
        &quot;&quot;&quot;
        set_one = {0, 1, 2, 4}
        set_two = {0, 1, 3, 4}
        expected_result = {&quot;old&quot;: {2}, &quot;new&quot;: {3}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )
        expected_result = {&quot;new&quot;: {2}, &quot;old&quot;: {3}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_two, set_one)
        )

        # It is unknown how different python versions will store sets in memory.
        # Python 2.7 seems to sort it (i.e. set_one below becomes {0, 1, 'foo', 'bar'}
        # However Python 3.6.8 stores it differently each run.
        # So just test for &quot;not equal&quot; here.
        set_one = {0, &quot;foo&quot;, 1, &quot;bar&quot;}
        set_two = {&quot;foo&quot;, 1, &quot;bar&quot;, 2}
        expected_result = {}
        self.assertNotEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )

    def test_mixed_inequality(self):
        &quot;&quot;&quot;
        Test cases where two mixed dicts/iterables that are different are compared.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: [1, 2, 3]}
        dict_two = {&quot;foo&quot;: [3, 2, 1]}
        expected_result = {&quot;old&quot;: {&quot;foo&quot;: [1, 3]}, &quot;new&quot;: {&quot;foo&quot;: [3, 1]}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )
        expected_result = {&quot;new&quot;: {&quot;foo&quot;: [1, 3]}, &quot;old&quot;: {&quot;foo&quot;: [3, 1]}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_two, dict_one)
        )

        list_one = [1, 2, {&quot;foo&quot;: [&quot;bar&quot;, {&quot;foo&quot;: 1, &quot;bar&quot;: 2}]}]
        list_two = [3, 4, {&quot;foo&quot;: [&quot;qux&quot;, {&quot;foo&quot;: 1, &quot;bar&quot;: 2}]}]
        expected_result = {
            &quot;old&quot;: [1, 2, {&quot;foo&quot;: [&quot;bar&quot;]}],
            &quot;new&quot;: [3, 4, {&quot;foo&quot;: [&quot;qux&quot;]}],
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )
        expected_result = {
            &quot;new&quot;: [1, 2, {&quot;foo&quot;: [&quot;bar&quot;]}],
            &quot;old&quot;: [3, 4, {&quot;foo&quot;: [&quot;qux&quot;]}],
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_two, list_one)
        )

        mixed_one = {&quot;foo&quot;: {0, 1, 2}, &quot;bar&quot;: [0, 1, 2]}
        mixed_two = {&quot;foo&quot;: {1, 2, 3}, &quot;bar&quot;: [1, 2, 3]}
        expected_result = {
            &quot;old&quot;: {&quot;foo&quot;: {0}, &quot;bar&quot;: [0, 1, 2]},
            &quot;new&quot;: {&quot;foo&quot;: {3}, &quot;bar&quot;: [1, 2, 3]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_one, mixed_two)
        )
        expected_result = {
            &quot;new&quot;: {&quot;foo&quot;: {0}, &quot;bar&quot;: [0, 1, 2]},
            &quot;old&quot;: {&quot;foo&quot;: {3}, &quot;bar&quot;: [1, 2, 3]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
        )

    def test_tuple_inequality(self):
        &quot;&quot;&quot;
        Test cases where two tuples that are different are compared.
        &quot;&quot;&quot;
        tuple_one = (1, 2, 3)
        tuple_two = (3, 2, 1)
        expected_result = {&quot;old&quot;: (1, 3), &quot;new&quot;: (3, 1)}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
        )

    def test_list_vs_set(self):
        &quot;&quot;&quot;
        Test case comparing a list with a set, will be compared unordered.
        &quot;&quot;&quot;
        mixed_one = [1, 2, 3]
<A NAME="0"></A>        mixed_two = {3, 2, 1}
        expected_result = {}
        self.assertEqual(
            expected_result, salt.utils.data<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match166234-0.html#0',2,'match166234-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.recursive_diff(mixed_one, mixed_two)
        )
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(mixed_two, mixed_one)
        )

    def test_dict_vs_ordereddict(self):
        &quot;&quot;&quot;
        Test case comparing a dict with an ordereddict, will be compared unordered.
        &quot;&quot;&quot;
        test_dict = {&quot;foo&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;baz&quot;}
        test_odict = OrderedDict(</B></FONT>[(&quot;foo&quot;, &quot;bar&quot;), (&quot;bar&quot;, &quot;baz&quot;)])
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict))
        self.assertEqual({}, salt.utils.data.recursive_diff(test_odict, test_dict))

        test_odict2 = OrderedDict([(&quot;bar&quot;, &quot;baz&quot;), (&quot;foo&quot;, &quot;bar&quot;)])
        self.assertEqual({}, salt.utils.data.recursive_diff(test_dict, test_odict2))
        self.assertEqual({}, salt.utils.data.recursive_diff(test_odict2, test_dict))

    def test_list_ignore_ignored(self):
        &quot;&quot;&quot;
        Test case comparing two lists with ignore-list supplied (which is not used
        when comparing lists).
        &quot;&quot;&quot;
        list_one = [1, 2, 3]
        list_two = [3, 2, 1]
        expected_result = {&quot;old&quot;: [1, 3], &quot;new&quot;: [3, 1]}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(list_one, list_two, ignore_keys=[1, 3]),
        )

    def test_dict_ignore(self):
        &quot;&quot;&quot;
        Test case comparing two dicts with ignore-list supplied.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;baz&quot;: 3}
        dict_two = {&quot;foo&quot;: 3, &quot;bar&quot;: 2, &quot;baz&quot;: 1}
        expected_result = {&quot;old&quot;: {&quot;baz&quot;: 3}, &quot;new&quot;: {&quot;baz&quot;: 1}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=[&quot;foo&quot;]),
        )

    def test_ordereddict_ignore(self):
        &quot;&quot;&quot;
        Test case comparing two OrderedDicts with ignore-list supplied.
        &quot;&quot;&quot;
        odict_one = OrderedDict([(&quot;foo&quot;, 1), (&quot;bar&quot;, 2), (&quot;baz&quot;, 3)])
        odict_two = OrderedDict([(&quot;baz&quot;, 1), (&quot;bar&quot;, 2), (&quot;foo&quot;, 3)])
        # The key 'foo' will be ignored, which means the key from the other OrderedDict
        # will always be considered &quot;different&quot; since OrderedDicts are compared ordered.
        expected_result = {
            &quot;old&quot;: OrderedDict([(&quot;baz&quot;, 3)]),
            &quot;new&quot;: OrderedDict([(&quot;baz&quot;, 1)]),
        }
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(odict_one, odict_two, ignore_keys=[&quot;foo&quot;]),
        )

    def test_dict_vs_ordereddict_ignore(self):
        &quot;&quot;&quot;
        Test case comparing a dict with an OrderedDict with ignore-list supplied.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;baz&quot;: 3}
        odict_two = OrderedDict([(&quot;foo&quot;, 3), (&quot;bar&quot;, 2), (&quot;baz&quot;, 1)])
        expected_result = {&quot;old&quot;: {&quot;baz&quot;: 3}, &quot;new&quot;: OrderedDict([(&quot;baz&quot;, 1)])}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, odict_two, ignore_keys=[&quot;foo&quot;]),
        )

    def test_mixed_nested_ignore(self):
        &quot;&quot;&quot;
        Test case comparing mixed, nested items with ignore-list supplied.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: [1], &quot;bar&quot;: {&quot;foo&quot;: 1, &quot;bar&quot;: 2}, &quot;baz&quot;: 3}
        dict_two = {&quot;foo&quot;: [2], &quot;bar&quot;: {&quot;foo&quot;: 3, &quot;bar&quot;: 2}, &quot;baz&quot;: 1}
        expected_result = {&quot;old&quot;: {&quot;baz&quot;: 3}, &quot;new&quot;: {&quot;baz&quot;: 1}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_keys=[&quot;foo&quot;]),
        )

    def test_ordered_dict_unequal_length(self):
        &quot;&quot;&quot;
        Test case comparing two OrderedDicts of unequal length.
        &quot;&quot;&quot;
        odict_one = OrderedDict([(&quot;foo&quot;, 1), (&quot;bar&quot;, 2), (&quot;baz&quot;, 3)])
        odict_two = OrderedDict([(&quot;foo&quot;, 1), (&quot;bar&quot;, 2)])
        expected_result = {&quot;old&quot;: OrderedDict([(&quot;baz&quot;, 3)]), &quot;new&quot;: {}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(odict_one, odict_two)
        )

    def test_list_unequal_length(self):
        &quot;&quot;&quot;
        Test case comparing two lists of unequal length.
        &quot;&quot;&quot;
        list_one = [1, 2, 3]
        list_two = [1, 2, 3, 4]
        expected_result = {&quot;old&quot;: [], &quot;new&quot;: [4]}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(list_one, list_two)
        )

    def test_set_unequal_length(self):
        &quot;&quot;&quot;
        Test case comparing two sets of unequal length.
        This does not do anything special, as it is unordered.
        &quot;&quot;&quot;
        set_one = {1, 2, 3}
        set_two = {4, 3, 2, 1}
        expected_result = {&quot;old&quot;: set(), &quot;new&quot;: {4}}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(set_one, set_two)
        )

    def test_tuple_unequal_length(self):
        &quot;&quot;&quot;
        Test case comparing two tuples of unequal length.
        This should be the same as comparing two ordered lists.
        &quot;&quot;&quot;
        tuple_one = (1, 2, 3)
        tuple_two = (1, 2, 3, 4)
        expected_result = {&quot;old&quot;: (), &quot;new&quot;: (4,)}
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(tuple_one, tuple_two)
        )

    def test_list_unordered(self):
        &quot;&quot;&quot;
        Test case comparing two lists unordered.
        &quot;&quot;&quot;
        list_one = [1, 2, 3, 4]
        list_two = [4, 3, 2]
        expected_result = {&quot;old&quot;: [1], &quot;new&quot;: []}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(list_one, list_two, ignore_order=True),
        )

    def test_mixed_nested_unordered(self):
        &quot;&quot;&quot;
        Test case comparing nested dicts/lists unordered.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: {&quot;bar&quot;: [1, 2, 3]}, &quot;bar&quot;: [{&quot;foo&quot;: 4}, 0]}
        dict_two = {&quot;foo&quot;: {&quot;bar&quot;: [3, 2, 1]}, &quot;bar&quot;: [0, {&quot;foo&quot;: 4}]}
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(dict_one, dict_two, ignore_order=True),
        )
        expected_result = {
            &quot;old&quot;: {&quot;foo&quot;: {&quot;bar&quot;: [1, 3]}, &quot;bar&quot;: [{&quot;foo&quot;: 4}, 0]},
            &quot;new&quot;: {&quot;foo&quot;: {&quot;bar&quot;: [3, 1]}, &quot;bar&quot;: [0, {&quot;foo&quot;: 4}]},
        }
        self.assertEqual(
            expected_result, salt.utils.data.recursive_diff(dict_one, dict_two)
        )

    def test_ordered_dict_unordered(self):
        &quot;&quot;&quot;
        Test case comparing OrderedDicts unordered.
        &quot;&quot;&quot;
        odict_one = OrderedDict([(&quot;foo&quot;, 1), (&quot;bar&quot;, 2), (&quot;baz&quot;, 3)])
        odict_two = OrderedDict([(&quot;baz&quot;, 3), (&quot;bar&quot;, 2), (&quot;foo&quot;, 1)])
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(odict_one, odict_two, ignore_order=True),
        )

    def test_ignore_missing_keys_dict(self):
        &quot;&quot;&quot;
        Test case ignoring missing keys on a comparison of dicts.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;baz&quot;: 3}
        dict_two = {&quot;bar&quot;: 3}
        expected_result = {&quot;old&quot;: {&quot;bar&quot;: 2}, &quot;new&quot;: {&quot;bar&quot;: 3}}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )

    def test_ignore_missing_keys_ordered_dict(self):
        &quot;&quot;&quot;
        Test case not ignoring missing keys on a comparison of OrderedDicts.
        &quot;&quot;&quot;
        odict_one = OrderedDict([(&quot;foo&quot;, 1), (&quot;bar&quot;, 2), (&quot;baz&quot;, 3)])
        odict_two = OrderedDict([(&quot;bar&quot;, 3)])
        expected_result = {&quot;old&quot;: odict_one, &quot;new&quot;: odict_two}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                odict_one, odict_two, ignore_missing_keys=True
            ),
        )

    def test_ignore_missing_keys_recursive(self):
        &quot;&quot;&quot;
        Test case ignoring missing keys on a comparison of nested dicts.
        &quot;&quot;&quot;
        dict_one = {&quot;foo&quot;: {&quot;bar&quot;: 2, &quot;baz&quot;: 3}}
        dict_two = {&quot;foo&quot;: {&quot;baz&quot;: 3}}
        expected_result = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
        # Compare from dict-in-dict
        dict_two = {}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
        # Compare from dict-in-list
        dict_one = {&quot;foo&quot;: [&quot;bar&quot;, {&quot;baz&quot;: 3}]}
        dict_two = {&quot;foo&quot;: [&quot;bar&quot;, {}]}
        self.assertEqual(
            expected_result,
            salt.utils.data.recursive_diff(
                dict_one, dict_two, ignore_missing_keys=True
            ),
        )
</PRE>
</div>
  </div>
</body>
</html>
