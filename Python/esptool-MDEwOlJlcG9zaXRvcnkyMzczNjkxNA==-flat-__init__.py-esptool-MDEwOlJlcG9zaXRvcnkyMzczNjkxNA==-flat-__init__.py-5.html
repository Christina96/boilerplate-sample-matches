
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init__.py</h3>
            <pre><code>1  import argparse
2  import hashlib
3  import operator
4  import os
5  import struct
6  import sys
7  import tempfile
8  import zlib
9  from collections import namedtuple
10  from cryptography import exceptions
11  from cryptography.hazmat.backends import default_backend
12  from cryptography.hazmat.primitives import hashes
13  from cryptography.hazmat.primitives import serialization
14  from cryptography.hazmat.primitives.asymmetric import ec, padding, rsa, utils
15  from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
16  from cryptography.utils import int_to_bytes
17  import ecdsa
18  import esptool
19  SIG_BLOCK_MAGIC = 0xE7
20  SIG_BLOCK_VERSION_RSA = 0x02
21  SIG_BLOCK_VERSION_ECDSA = 0x03
22  CURVE_ID_P192 = 1
23  CURVE_ID_P256 = 2
24  SECTOR_SIZE = 4096
25  SIG_BLOCK_SIZE = (
26      1216  # Refer to secure boot v2 signature block format for more details.
27  )
28  def get_chunks(source, chunk_len):
29      return (source[i : i + chunk_len] for i in range(0, len(source), chunk_len))
30  def endian_swap_words(source):
31      assert len(source) % 4 == 0
32      words = &quot;I&quot; * (len(source) // 4)
33      return struct.pack(&quot;&lt;&quot; + words, *struct.unpack(&quot;&gt;&quot; + words, source))
34  def swap_word_order(source):
35      assert len(source) % 4 == 0
36      words = &quot;I&quot; * (len(source) // 4)
37      return struct.pack(words, *reversed(struct.unpack(words, source)))
38  def _load_hardware_key(keyfile):
39      key = keyfile.read()
40      if len(key) not in [16, 24, 32, 64]:
41          raise esptool.FatalError(
42              &quot;Key file contains wrong length (%d bytes), 16, 24, 32 or 64 expected.&quot;
43              % len(key)
44          )
45      if len(key) == 16:
46          key = _sha256_digest(key)
47          print(&quot;Using 128-bit key (extended)&quot;)
48      elif len(key) == 24:
49          key = key + key[8:16]
50          assert len(key) == 32
51          print(&quot;Using 192-bit key (extended)&quot;)
52      elif len(key) == 32:
53          print(&quot;Using 256-bit key&quot;)
54      else:
55          print(&quot;Using 512-bit key&quot;)
56      return key
57  def digest_secure_bootloader(args):
58      _check_output_is_not_input(args.keyfile, args.output)
59      _check_output_is_not_input(args.image, args.output)
60      _check_output_is_not_input(args.iv, args.output)
61      if args.iv is not None:
62          print(&quot;WARNING: --iv argument is for TESTING PURPOSES ONLY&quot;)
63          iv = args.iv.read(128)
64      else:
65          iv = os.urandom(128)
66      plaintext_image = args.image.read()
67      args.image.seek(0)
68      fw_image = esptool.bin_image.ESP32FirmwareImage(args.image)
69      if fw_image.append_digest:
70          if len(plaintext_image) % 128 &lt;= 32:
71              new_len = len(plaintext_image) - (len(plaintext_image) % 128)
72              plaintext_image = plaintext_image[:new_len]
73      if len(plaintext_image) % 128 != 0:
74          plaintext_image += b&quot;\xFF&quot; * (128 - (len(plaintext_image) % 128))
75      plaintext = iv + plaintext_image
76      key = _load_hardware_key(args.keyfile)
77      backend = default_backend()
78      cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
79      encryptor = cipher.encryptor()
80      digest = hashlib.sha512()
81      for block in get_chunks(plaintext, 16):
82          block = block[::-1]  # reverse each input block
83          cipher_block = encryptor.update(block)
84          cipher_block = cipher_block[::-1]
85          for block in get_chunks(cipher_block, 4):
86              digest.update(block[::-1])
87      if args.output is None:
88          args.output = os.path.splitext(args.image.name)[0] + &quot;-digest-0x0000.bin&quot;
89      with open(args.output, &quot;wb&quot;) as f:
90          f.write(iv)
91          digest = digest.digest()
92          for word in get_chunks(digest, 4):
93              f.write(word[::-1])  # swap word order in the result
94          f.write(b&quot;\xFF&quot; * (0x1000 - f.tell()))  # pad to 0x1000
95          f.write(plaintext_image)
96      print(&quot;digest+image written to %s&quot; % args.output)
97  def _generate_ecdsa_signing_key(curve_id, keyfile):
98      sk = ecdsa.SigningKey.generate(curve=curve_id)
99      with open(keyfile, &quot;wb&quot;) as f:
100          f.write(sk.to_pem())
101  def generate_signing_key(args):
102      if os.path.exists(args.keyfile):
103          raise esptool.FatalError(&quot;ERROR: Key file %s already exists&quot; % args.keyfile)
104      if args.version == &quot;1&quot;:
105          if hasattr(args, &quot;scheme&quot;):
106              if args.scheme != &quot;ecdsa256&quot; and args.scheme is not None:
107                  raise esptool.FatalError(&quot;ERROR: V1 only supports ECDSA256&quot;)
108          _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
109          print(&quot;ECDSA NIST256p private key in PEM format written to %s&quot; % args.keyfile)
110      elif args.version == &quot;2&quot;:
111          if args.scheme == &quot;rsa3072&quot; or args.scheme is None:
112              private_key = rsa.generate_private_key(
113                  public_exponent=65537, key_size=3072, backend=default_backend()
114              ).private_bytes(
115                  encoding=serialization.Encoding.PEM,
116                  format=serialization.PrivateFormat.TraditionalOpenSSL,
117                  encryption_algorithm=serialization.NoEncryption(),
118              )
119              with open(args.keyfile, &quot;wb&quot;) as f:
120                  f.write(private_key)
121              print(&quot;RSA 3072 private key in PEM format written to %s&quot; % args.keyfile)
122          elif args.scheme == &quot;ecdsa192&quot;:
123              _generate_ecdsa_signing_key(ecdsa.NIST192p, args.keyfile)
124              print(
125                  &quot;ECDSA NIST192p private key in PEM format written to %s&quot; % args.keyfile
126              )
127          elif args.scheme == &quot;ecdsa256&quot;:
128              _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
129              print(
130                  &quot;ECDSA NIST256p private key in PEM format written to %s&quot; % args.keyfile
131              )
132          else:
133              raise esptool.FatalError(
134                  &quot;ERROR: Unsupported signing scheme (%s)&quot; % args.scheme
135              )
136  def load_ecdsa_signing_key(keyfile):
137      try:
138          sk = ecdsa.SigningKey.from_pem(keyfile.read())
139      except ValueError:
140          raise esptool.FatalError(
141              &quot;Incorrect ECDSA private key specified. &quot;
142              &quot;Please check algorithm and/or format.&quot;
143          )
144      if sk.curve not in [ecdsa.NIST192p, ecdsa.NIST256p]:
145          raise esptool.FatalError(&quot;Supports NIST192p and NIST256p keys only&quot;)
146      return sk
147  def _load_ecdsa_signing_key(keyfile):
148      sk = load_ecdsa_signing_key(keyfile)
149      if sk.curve != ecdsa.NIST256p:
150          raise esptool.FatalError(
151              &quot;Signing key uses incorrect curve. ESP32 Secure Boot only supports &quot;
152              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&#x27;)&quot;
153          )
154      return sk
155  def _load_ecdsa_verifying_key(keyfile):
156      try:
157          vk = ecdsa.VerifyingKey.from_pem(keyfile.read())
158      except ValueError:
159          raise esptool.FatalError(
160              &quot;Incorrect ECDSA public key specified. &quot;
161              &quot;Please check algorithm and/or format.&quot;
162          )
163      if vk.curve != ecdsa.NIST256p:
164          raise esptool.FatalError(
165              &quot;Signing key uses incorrect curve. ESP32 Secure Boot only supports &quot;
166              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&#x27;)&quot;
167          )
168      return vk
169  def _load_sbv2_signing_key(keydata):
170      sk = serialization.load_pem_private_key(
171          keydata, password=None, backend=default_backend()
172      )
173      if isinstance(sk, rsa.RSAPrivateKey):
174          if sk.key_size != 3072:
175              raise esptool.FatalError(
176                  &quot;Key file has length %d bits. Secure boot v2 only supports RSA-3072.&quot;
177                  % sk.key_size
178              )
179          return sk
180      if isinstance(sk, ec.EllipticCurvePrivateKey):
181          if not (
182              isinstance(sk.curve, ec.SECP192R1) or isinstance(sk.curve, ec.SECP256R1)
183          ):
184              raise esptool.FatalError(
185                  &quot;Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports &quot;
186                  &quot;NIST192p, NIST256p (aka prime192v1, prime256v1)&quot;
187              )
188          return sk
189      raise esptool.FatalError(&quot;Unsupported signing key for Secure Boot V2&quot;)
190  def _load_sbv2_pub_key(keydata):
191      vk = serialization.load_pem_public_key(keydata, backend=default_backend())
192      if isinstance(vk, rsa.RSAPublicKey):
193          if vk.key_size != 3072:
194              raise esptool.FatalError(
195                  &quot;Key file has length %d bits. Secure boot v2 only supports RSA-3072.&quot;
196                  % vk.key_size
197              )
198          return vk
199      if isinstance(vk, ec.EllipticCurvePublicKey):
200          if not (
201              isinstance(vk.curve, ec.SECP192R1) or isinstance(vk.curve, ec.SECP256R1)
202          ):
203              raise esptool.FatalError(
204                  &quot;Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports &quot;
205                  &quot;NIST192p, NIST256p (aka prime192v1, prime256v1)&quot;
206              )
207          return vk
208      raise esptool.FatalError(&quot;Unsupported public key for Secure Boot V2&quot;)
209  def _get_sbv2_pub_key(keyfile):
210      key_data = keyfile.read()
211      if (
212          b&quot;-BEGIN RSA PRIVATE KEY&quot; in key_data
213          or b&quot;-BEGIN EC PRIVATE KEY&quot; in key_data
214          or b&quot;-BEGIN PRIVATE KEY&quot; in key_data
215      ):
216          return _load_sbv2_signing_key(key_data).public_key()
217      elif b&quot;-BEGIN PUBLIC KEY&quot; in key_data:
218          vk = _load_sbv2_pub_key(key_data)
219      else:
220          raise esptool.FatalError(
221              &quot;Verification key does not appear to be an RSA Private or &quot;
222              &quot;Public key in PEM format. Unsupported&quot;
223          )
224      return vk
225  def _get_sbv2_rsa_primitives(public_key):
226      primitives = namedtuple(&quot;primitives&quot;, [&quot;n&quot;, &quot;e&quot;, &quot;m&quot;, &quot;rinv&quot;])
227      numbers = public_key.public_numbers()
228      primitives.n = numbers.n  #
229      primitives.e = numbers.e  # two public key components
230      primitives.m = -rsa._modinv(primitives.n, 1 &lt;&lt; 32)
231      rr = 1 &lt;&lt; (public_key.key_size * 2)
232      primitives.rinv = rr % primitives.n
233      return primitives
234  def _microecc_format(a, b, curve_len):
235      byte_len = int(curve_len / 8)
236      ab = int_to_bytes(a, byte_len)[::-1] + int_to_bytes(b, byte_len)[::-1]
237      assert len(ab) == 48 or len(ab) == 64
238      return ab
239  def sign_data(args):
240      if args.keyfile:
241          _check_output_is_not_input(args.keyfile, args.output)
242      _check_output_is_not_input(args.datafile, args.output)
243      if args.version == &quot;1&quot;:
244          return sign_secure_boot_v1(args)
245      elif args.version == &quot;2&quot;:
246          return sign_secure_boot_v2(args)
247  def sign_secure_boot_v1(args):
248      binary_content = args.datafile.read()
249      if args.hsm:
250          raise esptool.FatalError(
251              &quot;Secure Boot V1 does not support signing using an &quot;
252              &quot;external Hardware Security Module (HSM)&quot;
253          )
254      if args.signature:
255          print(&quot;Pre-calculated signatures found&quot;)
256          if len(args.pub_key) &gt; 1:
257              raise esptool.FatalError(&quot;Secure Boot V1 only supports one signing key&quot;)
258          signature = args.signature[0].read()
259          vk = _load_ecdsa_verifying_key(args.pub_key[0])
260      else:
261          if len(args.keyfile) &gt; 1:
262              raise esptool.FatalError(&quot;Secure Boot V1 only supports one signing key&quot;)
263          sk = _load_ecdsa_signing_key(args.keyfile[0])
264          signature = sk.sign_deterministic(binary_content, hashlib.sha256)
265          vk = sk.get_verifying_key()
266      vk.verify(signature, binary_content, hashlib.sha256)  # throws exception on failure
267      if args.output is None or os.path.abspath(args.output) == os.path.abspath(
268          args.datafile.name
269      ):  # append signature to input file
270          args.datafile.close()
271          outfile = open(args.datafile.name, &quot;ab&quot;)
272      else:  # write file &amp; signature to new file
273          outfile = open(args.output, &quot;wb&quot;)
274          outfile.write(binary_content)
275      outfile.write(
276          struct.pack(&quot;I&quot;, 0)
277      )  # Version indicator, allow for different curves/formats later
278      outfile.write(signature)
279      outfile.close()
280      print(&quot;Signed %d bytes of data from %s&quot; % (len(binary_content), args.datafile.name))
281  def sign_secure_boot_v2(args):
282      SIG_BLOCK_MAX_COUNT = 3
283      contents = args.datafile.read()
284      sig_block_num = 0
285      signature_sector = b&quot;&quot;
286      signature = args.signature
287      pub_key = args.pub_key
288      if len(contents) % SECTOR_SIZE != 0:
289          if args.signature:
290              raise esptool.FatalError(
291                  &quot;Secure Boot V2 requires the signature block to start &quot;
292                  &quot;from a 4KB aligned sector &quot;
293                  &quot;but the datafile supplied is not sector aligned.&quot;
294              )
295          else:
296              pad_by = SECTOR_SIZE - (len(contents) % SECTOR_SIZE)
297              print(
298                  f&quot;Padding data contents by {pad_by} bytes &quot;
299                  &quot;so signature sector aligns at sector boundary&quot;
300              )
301              contents += b&quot;\xff&quot; * pad_by
302      elif args.append_signatures:
303          while sig_block_num &lt; SIG_BLOCK_MAX_COUNT:
304              sig_block = validate_signature_block(contents, sig_block_num)
305              if sig_block is None:
306                  break
307              signature_sector += (
308                  sig_block  # Signature sector is populated with already valid blocks
309              )
310              sig_block_num += 1
311          if len(signature_sector) % SIG_BLOCK_SIZE != 0:
312              raise esptool.FatalError(&quot;Incorrect signature sector size&quot;)
313          if sig_block_num == 0:
314              print(
315                  &quot;No valid signature blocks found. &quot;
316                  &quot;Discarding --append-signature and proceeding to sign the image afresh.&quot;
317              )
318          else:
319              print(
320                  f&quot;{sig_block_num} valid signature block(s) already present &quot;
321                  &quot;in the signature sector.&quot;
322              )
323              if sig_block_num == SIG_BLOCK_MAX_COUNT:
324                  raise esptool.FatalError(
325                      f&quot;Upto {SIG_BLOCK_MAX_COUNT} signature blocks are supported. &quot;
326                      &quot;(For ESP32-ECO3 only 1 signature block is supported)&quot;
327                  )
328              contents = contents[: len(contents) - SECTOR_SIZE]
329      if args.hsm:
330          if args.hsm_config is None:
331              raise esptool.FatalError(
332                  &quot;Config file is required to generate signature using an external HSM.&quot;
333              )
334          import espsecure.esp_hsm_sign as hsm
335          try:
336              config = hsm.read_hsm_config(args.hsm_config)
337          except Exception as e:
338              raise esptool.FatalError(f&quot;Incorrect HSM config file format ({e})&quot;)
339          if pub_key is None:
340              pub_key = extract_pubkey_from_hsm(config)
341          signature = generate_signature_using_hsm(config, contents)
342      if signature:
343          print(&quot;Pre-calculated signatures found&quot;)
344          key_count = len(pub_key)
345          if len(signature) != key_count:
346              raise esptool.FatalError(
347                  f&quot;Number of public keys ({key_count}) not equal to &quot;
348                  f&quot;the number of signatures {len(signature)}.&quot;
349              )
350      else:
351          key_count = len(args.keyfile)
352      empty_signature_blocks = SIG_BLOCK_MAX_COUNT - sig_block_num
353      if key_count &gt; empty_signature_blocks:
354          raise esptool.FatalError(
355              f&quot;Number of keys({key_count}) more than the empty signature blocks.&quot;
356              f&quot;({empty_signature_blocks})&quot;
357          )
358      print(f&quot;{key_count} signing key(s) found.&quot;)
359      digest = hashlib.sha256()
360      digest.update(contents)
361      digest = digest.digest()
362      if signature:
363          signature_block = generate_signature_block_using_pre_calculated_signature(
364              signature, pub_key, digest
365          )
366      else:
367          signature_block = generate_signature_block_using_private_key(
368              args.keyfile, digest
369          )
370      if signature_block is None or len(signature_block) == 0:
371          raise esptool.FatalError(&quot;Signature Block generation failed&quot;)
372      signature_sector += signature_block
373      if (
374          len(signature_sector) &lt; 0
375          and len(signature_sector) &gt; SIG_BLOCK_SIZE * 3
376          and len(signature_sector) % SIG_BLOCK_SIZE != 0
377      ):
378          raise esptool.FatalError(&quot;Incorrect signature sector generation&quot;)
379      total_sig_blocks = len(signature_sector) // SIG_BLOCK_SIZE
380      signature_sector = signature_sector + (
381          b&quot;\xff&quot; * (SECTOR_SIZE - len(signature_sector))
382      )
383      if len(signature_sector) != SECTOR_SIZE:
384          raise esptool.FatalError(&quot;Incorrect signature sector size&quot;)
385      if args.output is None:
386          args.datafile.close()
387          args.output = args.datafile.name
388      with open(args.output, &quot;wb&quot;) as f:
389          f.write(contents + signature_sector)
390      print(
391          f&quot;Signed {len(contents)} bytes of data from {args.datafile.name}. &quot;
392          f&quot;Signature sector now has {total_sig_blocks} signature blocks.&quot;
393      )
394  def generate_signature_using_hsm(config, contents):
395      import espsecure.esp_hsm_sign as hsm
396      session = hsm.establish_session(config)
397      private_key = hsm.get_privkey_info(session, config)
398      signature = hsm.sign_payload(private_key, contents)
399      hsm.close_connection(session)
400      temp_signature_file = tempfile.TemporaryFile()
401      temp_signature_file.write(signature)
402      temp_signature_file.seek(0)
403      return [temp_signature_file]
404  def generate_signature_block_using_pre_calculated_signature(signature, pub_key, digest):
405      signature_blocks = b&quot;&quot;
406      for sig, pk in zip(signature, pub_key):
407          try:
408              public_key = _get_sbv2_pub_key(pk)
409              signature = sig.read()
410              if isinstance(public_key, rsa.RSAPublicKey):
411                  rsa_primitives = _get_sbv2_rsa_primitives(public_key)
412                  public_key.verify(
413                      signature,
414                      digest,
415                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
416                      utils.Prehashed(hashes.SHA256()),
417                  )
418                  signature_block = generate_rsa_signature_block(
419                      digest, rsa_primitives, signature
420                  )
421              else:
422                  numbers = public_key.public_numbers()
423                  if isinstance(numbers.curve, ec.SECP192R1):
424                      curve_len = 192
425                      curve_id = CURVE_ID_P192
426                  elif isinstance(numbers.curve, ec.SECP256R1):
427                      curve_len = 256
428                      curve_id = CURVE_ID_P256
429                  else:
430                      raise esptool.FatalError(&quot;Invalid ECDSA curve instance.&quot;)
431                  public_key.verify(
432                      signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
433                  )
434                  pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
435                  r, s = utils.decode_dss_signature(signature)
436                  signature_rs = _microecc_format(r, s, curve_len)
437                  signature_block = generate_ecdsa_signature_block(
438                      digest, curve_id, pubkey_point, signature_rs
439                  )
440          except exceptions.InvalidSignature:
441              raise esptool.FatalError(
442                  &quot;Signature verification failed: Invalid Signature\n&quot;
443                  &quot;The pre-calculated signature has not been signed &quot;
444                  &quot;using the given public key&quot;
445              )
446          signature_block += struct.pack(&quot;&lt;I&quot;, zlib.crc32(signature_block) &amp; 0xFFFFFFFF)
447          signature_block += b&quot;\x00&quot; * 16  # padding
448          if len(signature_block) != SIG_BLOCK_SIZE:
449              raise esptool.FatalError(&quot;Incorrect signature block size&quot;)
450          signature_blocks += signature_block
451      return signature_blocks
452  def generate_signature_block_using_private_key(keyfiles, digest):
453      signature_blocks = b&quot;&quot;
454      for keyfile in keyfiles:
455          private_key = _load_sbv2_signing_key(keyfile.read())
456          if isinstance(private_key, rsa.RSAPrivateKey):
457              signature = private_key.sign(
458                  digest,
459                  padding.PSS(
460                      mgf=padding.MGF1(hashes.SHA256()),
461                      salt_length=32,
462                  ),
463                  utils.Prehashed(hashes.SHA256()),
464              )
465              rsa_primitives = _get_sbv2_rsa_primitives(private_key.public_key())
466              signature_block = generate_rsa_signature_block(
467                  digest, rsa_primitives, signature
468              )
469          else:
470              signature = private_key.sign(
471                  digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
472              )
473              numbers = private_key.public_key().public_numbers()
474              if isinstance(private_key.curve, ec.SECP192R1):
475                  curve_len = 192
476                  curve_id = CURVE_ID_P192
477              elif isinstance(numbers.curve, ec.SECP256R1):
478                  curve_len = 256
479                  curve_id = CURVE_ID_P256
480              else:
481                  raise esptool.FatalError(&quot;Invalid ECDSA curve instance.&quot;)
482              pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
483              r, s = utils.decode_dss_signature(signature)
484              signature_rs = _microecc_format(r, s, curve_len)
485              signature_block = generate_ecdsa_signature_block(
486                  digest, curve_id, pubkey_point, signature_rs
487              )
488          signature_block += struct.pack(&quot;&lt;I&quot;, zlib.crc32(signature_block) &amp; 0xFFFFFFFF)
489          signature_block += b&quot;\x00&quot; * 16  # padding
490          if len(signature_block) != SIG_BLOCK_SIZE:
491              raise esptool.FatalError(&quot;Incorrect signature block size&quot;)
492          signature_blocks += signature_block
493      return signature_blocks
494  def generate_rsa_signature_block(digest, rsa_primitives, signature):
495      signature_block = struct.pack(
496          &quot;&lt;BBxx32s384sI384sI384s&quot;,
497          SIG_BLOCK_MAGIC,
498          SIG_BLOCK_VERSION_RSA,
499          digest,
<span onclick='openModal()' class='match'>500          int_to_bytes(rsa_primitives.n)[::-1],
501          rsa_primitives.e,
</span>502          int_to_bytes(rsa_primitives.rinv)[::-1],
503          rsa_primitives.m &amp; 0xFFFFFFFF,
504          signature[::-1],
505      )
506      return signature_block
507  def generate_ecdsa_signature_block(digest, curve_id, pubkey_point, signature_rs):
508      signature_block = struct.pack(
509          &quot;&lt;BBxx32sB64s64s1031x&quot;,
510          SIG_BLOCK_MAGIC,
511          SIG_BLOCK_VERSION_ECDSA,
512          digest,
513          curve_id,
514          pubkey_point,
515          signature_rs,
516      )
517      return signature_block
518  def verify_signature(args):
519      if args.version == &quot;1&quot;:
520          return verify_signature_v1(args)
521      elif args.version == &quot;2&quot;:
522          return verify_signature_v2(args)
523  def verify_signature_v1(args):
524      key_data = args.keyfile.read()
525      if b&quot;-BEGIN EC PRIVATE KEY&quot; in key_data:
526          sk = ecdsa.SigningKey.from_pem(key_data)
527          vk = sk.get_verifying_key()
528      elif b&quot;-BEGIN PUBLIC KEY&quot; in key_data:
529          vk = ecdsa.VerifyingKey.from_pem(key_data)
530      elif len(key_data) == 64:
531          vk = ecdsa.VerifyingKey.from_string(key_data, curve=ecdsa.NIST256p)
532      else:
533          raise esptool.FatalError(
534              &quot;Verification key does not appear to be an EC key in PEM format &quot;
535              &quot;or binary EC public key data. Unsupported&quot;
536          )
537      if vk.curve != ecdsa.NIST256p:
538          raise esptool.FatalError(
539              &quot;Public key uses incorrect curve. ESP32 Secure Boot only supports &quot;
540              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&quot;
541          )
542      binary_content = args.datafile.read()
543      data = binary_content[0:-68]
544      sig_version, signature = struct.unpack(&quot;I64s&quot;, binary_content[-68:])
545      if sig_version != 0:
546          raise esptool.FatalError(
547              &quot;Signature block has version %d. This version of espsecure &quot;
548              &quot;only supports version 0.&quot; % sig_version
549          )
550      print(&quot;Verifying %d bytes of data&quot; % len(data))
551      try:
552          if vk.verify(signature, data, hashlib.sha256):
553              print(&quot;Signature is valid&quot;)
554          else:
555              raise esptool.FatalError(&quot;Signature is not valid&quot;)
556      except ecdsa.keys.BadSignatureError:
557          raise esptool.FatalError(&quot;Signature is not valid&quot;)
558  def validate_signature_block(image_content, sig_blk_num):
559      offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
560      sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
561      assert len(sig_blk) == SIG_BLOCK_SIZE
562      magic, version, _, _, _, _, _, _, blk_crc = struct.unpack(
563          &quot;&lt;BBxx32s384sI384sI384sI16x&quot;, sig_blk
564      )
565      calc_crc = zlib.crc32(sig_blk[:1196])
566      is_invalid_block = magic != SIG_BLOCK_MAGIC
567      is_invalid_block |= version not in [SIG_BLOCK_VERSION_RSA, SIG_BLOCK_VERSION_ECDSA]
568      if is_invalid_block or blk_crc != calc_crc &amp; 0xFFFFFFFF:  # Signature block invalid
569          return None
570      key_type = &quot;RSA&quot; if version == SIG_BLOCK_VERSION_RSA else &quot;ECDSA&quot;
571      print(f&quot;Signature block {sig_blk_num} is valid ({key_type}).&quot;)
572      return sig_blk
573  def verify_signature_v2(args):
574      keyfile = args.keyfile
575      if args.hsm:
576          if args.hsm_config is None:
577              raise esptool.FatalError(
578                  &quot;Config file is required to extract public key from an external HSM.&quot;
579              )
580          import espsecure.esp_hsm_sign as hsm
581          try:
582              config = hsm.read_hsm_config(args.hsm_config)
583          except Exception as e:
584              raise esptool.FatalError(f&quot;Incorrect HSM config file format ({e})&quot;)
585          keyfile = extract_pubkey_from_hsm(config)[0]
586      vk = _get_sbv2_pub_key(keyfile)
587      if isinstance(vk, rsa.RSAPublicKey):
588          SIG_BLOCK_MAX_COUNT = 3
589      elif isinstance(vk, ec.EllipticCurvePublicKey):
590          SIG_BLOCK_MAX_COUNT = 1
591      image_content = args.datafile.read()
592      if len(image_content) &lt; SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
593          raise esptool.FatalError(
594              &quot;Invalid datafile. Data size should be non-zero &amp; a multiple of 4096.&quot;
595          )
596      digest = digest = hashlib.sha256()
597      digest.update(image_content[:-SECTOR_SIZE])
598      digest = digest.digest()
599      valid = False
600      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
601          sig_blk = validate_signature_block(image_content, sig_blk_num)
602          if sig_blk is None:
603              print(f&quot;Signature block {sig_blk_num} invalid. Skipping.&quot;)
604              continue
605          _, version, blk_digest = struct.unpack(&quot;&lt;BBxx32s&quot;, sig_blk[:36])
606          if blk_digest != digest:
607              raise esptool.FatalError(
608                  &quot;Signature block image digest does not match &quot;
609                  f&quot;the actual image digest {digest}. Expected {blk_digest}.&quot;
610              )
611          try:
612              if isinstance(vk, rsa.RSAPublicKey):
613                  _, _, _, _, signature, _ = struct.unpack(
614                      &quot;&lt;384sI384sI384sI16x&quot;, sig_blk[36:]
615                  )
616                  vk.verify(
617                      signature[::-1],
618                      digest,
619                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
620                      utils.Prehashed(hashes.SHA256()),
621                  )
622              else:
623                  curve_id, _pubkey, encoded_rs = struct.unpack(
624                      &quot;B64s64s1031x4x16x&quot;, sig_blk[36:]
625                  )
626                  assert curve_id in (CURVE_ID_P192, CURVE_ID_P256)
627                  keylen = (
628                      24 if curve_id == CURVE_ID_P192 else 32
629                  )  # length of each number in the keypair
630                  r = int.from_bytes(encoded_rs[:keylen], &quot;little&quot;)
631                  s = int.from_bytes(encoded_rs[keylen : keylen * 2], &quot;little&quot;)
632                  signature = utils.encode_dss_signature(r, s)
633                  vk.verify(signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256())))
634              key_type = &quot;RSA&quot; if isinstance(vk, rsa.RSAPublicKey) else &quot;ECDSA&quot;
635              print(
636                  f&quot;Signature block {sig_blk_num} verification successful using &quot;
637                  f&quot;the supplied key ({key_type}).&quot;
638              )
639              valid = True
640          except exceptions.InvalidSignature:
641              print(
642                  f&quot;Signature block {sig_blk_num} is not signed by the supplied key. &quot;
643                  &quot;Checking the next block&quot;
644              )
645              continue
646      if not valid:
647          raise esptool.FatalError(
648              &quot;Checked all blocks. Signature could not be verified with the provided key.&quot;
649          )
650  def extract_public_key(args):
651      _check_output_is_not_input(args.keyfile, args.public_keyfile)
652      if args.version == &quot;1&quot;:
653          sk = _load_ecdsa_signing_key(args.keyfile)
654          vk = sk.get_verifying_key()
655          args.public_keyfile.write(vk.to_string())
656      elif args.version == &quot;2&quot;:
657          sk = _load_sbv2_signing_key(args.keyfile.read())
658          vk = sk.public_key().public_bytes(
659              encoding=serialization.Encoding.PEM,
660              format=serialization.PublicFormat.SubjectPublicKeyInfo,
661          )
662          args.public_keyfile.write(vk)
663      print(
664          &quot;%s public key extracted to %s&quot; % (args.keyfile.name, args.public_keyfile.name)
665      )
666  def extract_pubkey_from_hsm(config):
667      import espsecure.esp_hsm_sign as hsm
668      session = hsm.establish_session(config)
669      public_key = hsm.get_pubkey(session, config)
670      hsm.close_connection(session)
671      pem = public_key.public_bytes(
672          encoding=serialization.Encoding.PEM,
673          format=serialization.PublicFormat.SubjectPublicKeyInfo,
674      )
675      temp_pub_key_file = tempfile.TemporaryFile()
676      temp_pub_key_file.write(pem)
677      temp_pub_key_file.seek(0)
678      return [temp_pub_key_file]
679  def _sha256_digest(data):
680      digest = hashlib.sha256()
681      digest.update(data)
682      return digest.digest()
683  def signature_info_v2(args):
684      SIG_BLOCK_MAX_COUNT = 3
685      image_content = args.datafile.read()
686      if len(image_content) &lt; SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
687          raise esptool.FatalError(
688              &quot;Invalid datafile. Data size should be non-zero &amp; a multiple of 4096.&quot;
689          )
690      digest = _sha256_digest(image_content[:-SECTOR_SIZE])
691      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
692          sig_blk = validate_signature_block(image_content, sig_blk_num)
693          if sig_blk is None:
694              print(
695                  &quot;Signature block %d absent/invalid. Skipping checking next blocks.&quot;
696                  % sig_blk_num
697              )
698              return
699          sig_data = struct.unpack(&quot;&lt;BBxx32s384sI384sI384sI16x&quot;, sig_blk)
700          if sig_data[2] != digest:
701              raise esptool.FatalError(
702                  &quot;Digest in signature block %d doesn&#x27;t match the image digest.&quot;
703                  % (sig_blk_num)
704              )
705          offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
706          sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
707          if sig_data[1] == SIG_BLOCK_VERSION_RSA:
708              key_digest = _sha256_digest(sig_blk[36:812])
709          elif sig_data[1] == SIG_BLOCK_VERSION_ECDSA:
710              key_digest = _sha256_digest(sig_blk[36:101])
711          else:
712              raise esptool.FatalError(
713                  &quot;Unsupported scheme in signature block %d&quot; % (sig_blk_num)
714              )
715          print(
716              &quot;Public key digest for block %d: %s&quot;
717              % (sig_blk_num, &quot; &quot;.join(&quot;{:02x}&quot;.format(c) for c in bytearray(key_digest)))
718          )
719  def _digest_sbv2_public_key(keyfile):
720      public_key = _get_sbv2_pub_key(keyfile)
721      if isinstance(public_key, rsa.RSAPublicKey):
722          rsa_primitives = _get_sbv2_rsa_primitives(public_key)
723          binary_format = struct.pack(
724              &quot;&lt;384sI384sI&quot;,
725              int_to_bytes(rsa_primitives.n)[::-1],
726              rsa_primitives.e,
727              int_to_bytes(rsa_primitives.rinv)[::-1],
728              rsa_primitives.m &amp; 0xFFFFFFFF,
729          )
730      else:  # ECC public key
731          numbers = public_key.public_numbers()
732          if isinstance(public_key.curve, ec.SECP192R1):
733              curve_len = 192
734              curve_id = CURVE_ID_P192
735          else:
736              curve_len = 256
737              curve_id = CURVE_ID_P256
738          pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
739          binary_format = struct.pack(
740              &quot;&lt;B64s&quot;,
741              curve_id,
742              pubkey_point,
743          )
744      return hashlib.sha256(binary_format).digest()
745  def digest_sbv2_public_key(args):
746      _check_output_is_not_input(args.keyfile, args.output)
747      public_key_digest = _digest_sbv2_public_key(args.keyfile)
748      with open(args.output, &quot;wb&quot;) as f:
749          print(
750              &quot;Writing the public key digest of %s to %s.&quot;
751              % (args.keyfile.name, args.output)
752          )
753          f.write(public_key_digest)
754  def digest_rsa_public_key(args):
755      digest_sbv2_public_key(args)
756  def digest_private_key(args):
757      _check_output_is_not_input(args.keyfile, args.digest_file)
758      sk = _load_ecdsa_signing_key(args.keyfile)
759      repr(sk.to_string())
760      digest = hashlib.sha256()
761      digest.update(sk.to_string())
762      result = digest.digest()
763      if args.keylen == 192:
764          result = result[0:24]
765      args.digest_file.write(result)
766      print(
767          &quot;SHA-256 digest of private key %s%s written to %s&quot;
768          % (
769              args.keyfile.name,
770              &quot;&quot; if args.keylen == 256 else &quot; (truncated to 192 bits)&quot;,
771              args.digest_file.name,
772          )
773      )
774  _FLASH_ENCRYPTION_TWEAK_PATTERN = [
775      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
776      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
777      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
778      14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
779      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
780      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
781      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
782      12, 11, 10, 9, 8, 7, 6, 5,
783      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
784      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
785      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
786      10, 9, 8, 7, 6, 5,
787      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
788      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
789      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
790      8, 7, 6, 5
791  ]
792  assert len(_FLASH_ENCRYPTION_TWEAK_PATTERN) == 256
793  def _flash_encryption_tweak_range(flash_crypt_config=0xF):
794      tweak_range = []
795      if (flash_crypt_config &amp; 1) != 0:
796          tweak_range += range(67)
797      if (flash_crypt_config &amp; 2) != 0:
798          tweak_range += range(67, 132)
799      if (flash_crypt_config &amp; 4) != 0:
800          tweak_range += range(132, 195)
801      if (flash_crypt_config &amp; 8) != 0:
802          tweak_range += range(195, 256)
803      return tweak_range
804  def _flash_encryption_tweak_range_bits(flash_crypt_config=0xF):
805      tweak_range = 0
806      if (flash_crypt_config &amp; 1) != 0:
807          tweak_range |= (
808              0xFFFFFFFFFFFFFFFFE00000000000000000000000000000000000000000000000
809          )
810      if (flash_crypt_config &amp; 2) != 0:
811          tweak_range |= (
812              0x00000000000000001FFFFFFFFFFFFFFFF0000000000000000000000000000000
813          )
814      if (flash_crypt_config &amp; 4) != 0:
815          tweak_range |= (
816              0x000000000000000000000000000000000FFFFFFFFFFFFFFFE000000000000000
817          )
818      if (flash_crypt_config &amp; 8) != 0:
819          tweak_range |= (
820              0x0000000000000000000000000000000000000000000000001FFFFFFFFFFFFFFF
821          )
822      return tweak_range
823  mul1 = 0x0000200004000080000004000080001000000200004000080000040000800010
824  mul2 = 0x0000000000000000200000000000000010000000000000002000000000000001
825  mul1_mask = 0xFFFFFFFFFFFFFF801FFFFFFFFFFFFFF00FFFFFFFFFFFFFF81FFFFFFFFFFFFFF0
826  mul2_mask = 0x000000000000007FE00000000000000FF000000000000007E00000000000000F
827  def _flash_encryption_tweak_key(key, offset, tweak_range):
828      addr = offset &gt;&gt; 5
829      key ^= ((mul1 * addr) | ((mul2 * addr) &amp; mul2_mask)) &amp; tweak_range
830      return int.to_bytes(key, length=32, byteorder=&quot;big&quot;, signed=False)
831  def generate_flash_encryption_key(args):
832      print(&quot;Writing %d random bits to key file %s&quot; % (args.keylen, args.key_file.name))
833      args.key_file.write(os.urandom(args.keylen // 8))
834  def _flash_encryption_operation_esp32(
835      output_file, input_file, flash_address, keyfile, flash_crypt_conf, do_decrypt
836  ):
837      key = _load_hardware_key(keyfile)
838      if flash_address % 16 != 0:
839          raise esptool.FatalError(
840              &quot;Starting flash address 0x%x must be a multiple of 16&quot; % flash_address
841          )
842      if flash_crypt_conf == 0:
843          print(&quot;WARNING: Setting FLASH_CRYPT_CONF to zero is not recommended&quot;)
844      tweak_range = _flash_encryption_tweak_range_bits(flash_crypt_conf)
845      key = int.from_bytes(key, byteorder=&quot;big&quot;, signed=False)
846      backend = default_backend()
847      cipher = None
848      block_offs = flash_address
849      while True:
850          block = input_file.read(16)
851          if len(block) == 0:
852              break
853          elif len(block) &lt; 16:
854              if do_decrypt:
855                  raise esptool.FatalError(&quot;Data length is not a multiple of 16 bytes&quot;)
856              pad = 16 - len(block)
857              block = block + os.urandom(pad)
858              print(
859                  &quot;Note: Padding with %d bytes of random data &quot;
860                  &quot;(encrypted data must be multiple of 16 bytes long)&quot; % pad
861              )
862          if block_offs % 32 == 0 or cipher is None:
863              block_key = _flash_encryption_tweak_key(key, block_offs, tweak_range)
864              if cipher is None:  # first pass
865                  cipher = Cipher(algorithms.AES(block_key), modes.ECB(), backend=backend)
866                  actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
867              else:
868                  try:
869                      backend = actor._ctx._backend
870                      res = backend._lib.EVP_CipherInit_ex(
871                          actor._ctx._ctx,
872                          backend._ffi.NULL,
873                          backend._ffi.NULL,
874                          backend._ffi.from_buffer(block_key),
875                          backend._ffi.NULL,
876                          actor._ctx._operation,
877                      )
878                      backend.openssl_assert(res != 0)
879                  except AttributeError:
880                      cipher.algorithm.key = block_key
881                      actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
882          block = block[::-1]  # reverse input block byte order
883          block = actor.update(block)
884          output_file.write(block[::-1])  # reverse output block byte order
885          block_offs += 16
886  def _flash_encryption_operation_aes_xts(
887      output_file, input_file, flash_address, keyfile, do_decrypt
888  ):
889      backend = default_backend()
890      key = _load_hardware_key(keyfile)
891      indata = input_file.read()
892      if flash_address % 16 != 0:
893          raise esptool.FatalError(
894              &quot;Starting flash address 0x%x must be a multiple of 16&quot; % flash_address
895          )
896      if len(indata) % 16 != 0:
897          raise esptool.FatalError(
898              &quot;Input data length (%d) must be a multiple of 16&quot; % len(indata)
899          )
900      if len(indata) == 0:
901          raise esptool.FatalError(&quot;Input data must be longer than 0&quot;)
902      pad_left = flash_address % 0x80
903      indata = (b&quot;\x00&quot; * pad_left) + indata
904      pad_right = len(indata) % 0x80
905      if pad_right &gt; 0:
906          pad_right = 0x80 - pad_right
907      indata = indata + (b&quot;\x00&quot; * pad_right)
908      inblocks = _split_blocks(indata, 0x80)  # split into 1024 bit blocks
909      output = []
910      for inblock in inblocks:  # for each block
911          tweak = struct.pack(&quot;&lt;I&quot;, (flash_address &amp; ~0x7F)) + (b&quot;\x00&quot; * 12)
912          flash_address += 0x80  # for next block
913          if len(tweak) != 16:
914              raise esptool.FatalError(
915                  &quot;Length of tweak must be 16, was {}&quot;.format(len(tweak))
916              )
917          cipher = Cipher(algorithms.AES(key), modes.XTS(tweak), backend=backend)
918          encryptor = cipher.decryptor() if do_decrypt else cipher.encryptor()
919          inblock = inblock[::-1]  # reverse input
920          outblock = encryptor.update(inblock)  # standard algo
921          output.append(outblock[::-1])  # reverse output
922      output = b&quot;&quot;.join(output)
923      if pad_right != 0:
924          output = output[:-pad_right]
925      if pad_left != 0:
926          output = output[pad_left:]
927      if len(output) != len(indata) - pad_left - pad_right:
928          raise esptool.FatalError(
929              &quot;Length of input data ({}) should match the output data ({})&quot;.format(
930                  len(indata) - pad_left - pad_right, len(output)
931              )
932          )
933      output_file.write(output)
934  def _split_blocks(text, block_len=16):
935      assert len(text) % block_len == 0
936      pos = 0
937      while pos &lt; len(text):
938          yield text[pos : pos + block_len]
939          pos = pos + block_len
940  def decrypt_flash_data(args):
941      _check_output_is_not_input(args.keyfile, args.output)
942      _check_output_is_not_input(args.encrypted_file, args.output)
943      if args.aes_xts:
944          return _flash_encryption_operation_aes_xts(
945              args.output, args.encrypted_file, args.address, args.keyfile, True
946          )
947      else:
948          return _flash_encryption_operation_esp32(
949              args.output,
950              args.encrypted_file,
951              args.address,
952              args.keyfile,
953              args.flash_crypt_conf,
954              True,
955          )
956  def encrypt_flash_data(args):
957      _check_output_is_not_input(args.keyfile, args.output)
958      _check_output_is_not_input(args.plaintext_file, args.output)
959      if args.aes_xts:
960          return _flash_encryption_operation_aes_xts(
961              args.output, args.plaintext_file, args.address, args.keyfile, False
962          )
963      else:
964          return _flash_encryption_operation_esp32(
965              args.output,
966              args.plaintext_file,
967              args.address,
968              args.keyfile,
969              args.flash_crypt_conf,
970              False,
971          )
972  def _samefile(p1, p2):
973      return os.path.normcase(os.path.normpath(p1)) == os.path.normcase(
974          os.path.normpath(p2)
975      )
976  def _check_output_is_not_input(input_file, output_file):
977      i = getattr(input_file, &quot;name&quot;, input_file)
978      o = getattr(output_file, &quot;name&quot;, output_file)
979      check_f = _samefile if isinstance(i, str) and isinstance(o, str) else operator.eq
980      if check_f(i, o):
981          raise esptool.FatalError(
982              &#x27;The input &quot;{}&quot; and output &quot;{}&quot; should not be the same!&#x27;.format(i, o)
983          )
984  class OutFileType(object):
985      def __init__(self):
986          self.path = None
987          self.file_obj = None
988      def __call__(self, path):
989          self.path = path
990          return self
991      def __repr__(self):
992          return &quot;{}({})&quot;.format(type(self).__name__, self.path)
993      def write(self, payload):
994          if len(payload) &gt; 0:
995              if not self.file_obj:
996                  self.file_obj = open(self.path, &quot;wb&quot;)
997              self.file_obj.write(payload)
998      def close(self):
999          if self.file_obj:
1000              self.file_obj.close()
1001              self.file_obj = None
1002      @property
1003      def name(self):
1004          return self.path
1005  def main(custom_commandline=None):
1006      parser = argparse.ArgumentParser(
1007          description=&quot;espsecure.py v%s - ESP32 Secure Boot &amp; Flash Encryption tool&quot;
1008          % esptool.__version__,
1009          prog=&quot;espsecure&quot;,
1010      )
1011      subparsers = parser.add_subparsers(
1012          dest=&quot;operation&quot;, help=&quot;Run espsecure.py {command} -h for additional help&quot;
1013      )
1014      p = subparsers.add_parser(
1015          &quot;digest_secure_bootloader&quot;,
1016          help=&quot;Take a bootloader binary image and a secure boot key, &quot;
1017          &quot;and output a combined digest+binary suitable for flashing along &quot;
1018          &quot;with the precalculated secure boot key.&quot;,
1019      )
1020      p.add_argument(
1021          &quot;--keyfile&quot;,
1022          &quot;-k&quot;,
1023          help=&quot;256 bit key for secure boot digest.&quot;,
1024          type=argparse.FileType(&quot;rb&quot;),
1025          required=True,
1026      )
1027      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for signed digest image.&quot;)
1028      p.add_argument(
1029          &quot;--iv&quot;,
1030          help=&quot;128 byte IV file. Supply a file for testing purposes only, &quot;
1031          &quot;if not supplied an IV will be randomly generated.&quot;,
1032          type=argparse.FileType(&quot;rb&quot;),
1033      )
1034      p.add_argument(
1035          &quot;image&quot;,
1036          help=&quot;Bootloader image file to calculate digest from&quot;,
1037          type=argparse.FileType(&quot;rb&quot;),
1038      )
1039      p = subparsers.add_parser(
1040          &quot;generate_signing_key&quot;,
1041          help=&quot;Generate a private key for signing secure boot images &quot;
1042          &quot;as per the secure boot version. &quot;
1043          &quot;Key file is generated in PEM format, &quot;
1044          &quot;Secure Boot V1 - ECDSA NIST256p private key. &quot;
1045          &quot;Secure Boot V2 - RSA 3072, ECDSA NIST256p, ECDSA NIST192p private key.&quot;,
1046      )
1047      p.add_argument(
1048          &quot;--version&quot;,
1049          &quot;-v&quot;,
1050          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1051          choices=[&quot;1&quot;, &quot;2&quot;],
1052          default=&quot;1&quot;,
1053      )
1054      p.add_argument(
1055          &quot;--scheme&quot;,
1056          &quot;-s&quot;,
1057          help=&quot;Scheme of secure boot signing.&quot;,
1058          choices=[&quot;rsa3072&quot;, &quot;ecdsa192&quot;, &quot;ecdsa256&quot;],
1059          required=False,
1060      )
1061      p.add_argument(
1062          &quot;keyfile&quot;, help=&quot;Filename for private key file (embedded public key)&quot;
1063      )
1064      p = subparsers.add_parser(
1065          &quot;sign_data&quot;,
1066          help=&quot;Sign a data file for use with secure boot. &quot;
1067          &quot;Signing algorithm is deterministic ECDSA w/ SHA-512 (V1) &quot;
1068          &quot;or either RSA-PSS or ECDSA w/ SHA-256 (V2).&quot;,
1069      )
1070      p.add_argument(
1071          &quot;--version&quot;,
1072          &quot;-v&quot;,
1073          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1074          choices=[&quot;1&quot;, &quot;2&quot;],
1075          required=True,
1076      )
1077      p.add_argument(
1078          &quot;--keyfile&quot;,
1079          &quot;-k&quot;,
1080          help=&quot;Private key file for signing. Key is in PEM format.&quot;,
1081          type=argparse.FileType(&quot;rb&quot;),
1082          nargs=&quot;+&quot;,
1083      )
1084      p.add_argument(
1085          &quot;--append_signatures&quot;,
1086          &quot;-a&quot;,
1087          help=&quot;Append signature block(s) to already signed image. &quot;
1088          &quot;Valid only for ESP32-S2.&quot;,
1089          action=&quot;store_true&quot;,
1090      )
1091      p.add_argument(
1092          &quot;--hsm&quot;,
1093          help=&quot;Use an external Hardware Security Module &quot;
1094          &quot;to generate signature using PKCS#11 interface.&quot;,
1095          action=&quot;store_true&quot;,
1096      )
1097      p.add_argument(
1098          &quot;--hsm-config&quot;,
1099          help=&quot;Config file for the external Hardware Security Module &quot;
1100          &quot;to be used to generate signature.&quot;,
1101          default=None,
1102      )
1103      p.add_argument(
1104          &quot;--pub-key&quot;,
1105          help=&quot;Public key files corresponding to the private key used to generate &quot;
1106          &quot;the pre-calculated signatures. Keys should be in PEM format.&quot;,
1107          type=argparse.FileType(&quot;rb&quot;),
1108          nargs=&quot;+&quot;,
1109      )
1110      p.add_argument(
1111          &quot;--signature&quot;,
1112          help=&quot;Pre-calculated signatures. &quot;
1113          &quot;Signatures generated using external private keys e.g. keys stored in HSM.&quot;,
1114          type=argparse.FileType(&quot;rb&quot;),
1115          nargs=&quot;+&quot;,
1116          default=None,
1117      )
1118      p.add_argument(
1119          &quot;--output&quot;,
1120          &quot;-o&quot;,
1121          help=&quot;Output file for signed digest image. Default is to sign the input file.&quot;,
1122      )
1123      p.add_argument(
1124          &quot;datafile&quot;,
1125          help=&quot;File to sign. For version 1, this can be any file. &quot;
1126          &quot;For version 2, this must be a valid app image.&quot;,
1127          type=argparse.FileType(&quot;rb&quot;),
1128      )
1129      p = subparsers.add_parser(
1130          &quot;verify_signature&quot;,
1131          help=&#x27;Verify a data file previously signed by &quot;sign_data&quot;, &#x27;
1132          &quot;using the public key.&quot;,
1133      )
1134      p.add_argument(
1135          &quot;--version&quot;,
1136          &quot;-v&quot;,
1137          help=&quot;Version of the secure boot scheme to use.&quot;,
1138          choices=[&quot;1&quot;, &quot;2&quot;],
1139          required=True,
1140      )
1141      p.add_argument(
1142          &quot;--hsm&quot;,
1143          help=&quot;Use an external Hardware Security Module &quot;
1144          &quot;to verify signature using PKCS#11 interface.&quot;,
1145          action=&quot;store_true&quot;,
1146      )
1147      p.add_argument(
1148          &quot;--hsm-config&quot;,
1149          help=&quot;Config file for the external Hardware Security Module &quot;
1150          &quot;to be used to verify signature.&quot;,
1151          default=None,
1152      )
1153      p.add_argument(
1154          &quot;--keyfile&quot;,
1155          &quot;-k&quot;,
1156          help=&quot;Public key file for verification. &quot;
1157          &quot;Can be private or public key in PEM format.&quot;,
1158          type=argparse.FileType(&quot;rb&quot;),
1159      )
1160      p.add_argument(
1161          &quot;datafile&quot;,
1162          help=&quot;Signed data file to verify signature.&quot;,
1163          type=argparse.FileType(&quot;rb&quot;),
1164      )
1165      p = subparsers.add_parser(
1166          &quot;extract_public_key&quot;,
1167          help=&quot;Extract the public verification key for signatures, &quot;
1168          &quot;save it as a raw binary file.&quot;,
1169      )
1170      p.add_argument(
1171          &quot;--version&quot;,
1172          &quot;-v&quot;,
1173          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1174          choices=[&quot;1&quot;, &quot;2&quot;],
1175          default=&quot;1&quot;,
1176      )
1177      p.add_argument(
1178          &quot;--keyfile&quot;,
1179          &quot;-k&quot;,
1180          help=&quot;Private key file (PEM format) to extract the &quot;
1181          &quot;public verification key from.&quot;,
1182          type=argparse.FileType(&quot;rb&quot;),
1183          required=True,
1184      )
1185      p.add_argument(
1186          &quot;public_keyfile&quot;, help=&quot;File to save new public key into&quot;, type=OutFileType()
1187      )
1188      p = subparsers.add_parser(
1189          &quot;digest_rsa_public_key&quot;,
1190          help=&quot;Generate an SHA-256 digest of the RSA public key. &quot;
1191          &quot;This digest is burned into the eFuse and asserts the legitimacy &quot;
1192          &quot;of the public key for Secure boot v2.&quot;,
1193      )
1194      p.add_argument(
1195          &quot;--keyfile&quot;,
1196          &quot;-k&quot;,
1197          help=&quot;Public key file for verification. &quot;
1198          &quot;Can be private or public key in PEM format.&quot;,
1199          type=argparse.FileType(&quot;rb&quot;),
1200          required=True,
1201      )
1202      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for the digest.&quot;, required=True)
1203      p = subparsers.add_parser(
1204          &quot;digest_sbv2_public_key&quot;,
1205          help=&quot;Generate an SHA-256 digest of the public key. &quot;
1206          &quot;This digest is burned into the eFuse and asserts the legitimacy &quot;
1207          &quot;of the public key for Secure boot v2.&quot;,
1208      )
1209      p.add_argument(
1210          &quot;--keyfile&quot;,
1211          &quot;-k&quot;,
1212          help=&quot;Public key file for verification. &quot;
1213          &quot;Can be private or public key in PEM format.&quot;,
1214          type=argparse.FileType(&quot;rb&quot;),
1215          required=True,
1216      )
1217      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for the digest.&quot;, required=True)
1218      p = subparsers.add_parser(
1219          &quot;signature_info_v2&quot;,
1220          help=&quot;Reads the signature block and provides the signature block information.&quot;,
1221      )
1222      p.add_argument(
1223          &quot;datafile&quot;,
1224          help=&quot;Secure boot v2 signed data file.&quot;,
1225          type=argparse.FileType(&quot;rb&quot;),
1226      )
1227      p = subparsers.add_parser(
1228          &quot;digest_private_key&quot;,
1229          help=&quot;Generate an SHA-256 digest of the private signing key. &quot;
1230          &quot;This can be used as a reproducible secure bootloader (only secure boot v1) &quot;
1231          &quot;or flash encryption key.&quot;,
1232      )
1233      p.add_argument(
1234          &quot;--keyfile&quot;,
1235          &quot;-k&quot;,
1236          help=&quot;Private key file (PEM format) to generate a digest from.&quot;,
1237          type=argparse.FileType(&quot;rb&quot;),
1238          required=True,
1239      )
1240      p.add_argument(
1241          &quot;--keylen&quot;,
1242          &quot;-l&quot;,
1243          help=&quot;Length of private key digest file to generate (in bits). &quot;
1244          &quot;3/4 Coding Scheme requires 192 bit key.&quot;,
1245          choices=[192, 256],
1246          default=256,
1247          type=int,
1248      )
1249      p.add_argument(
1250          &quot;digest_file&quot;, help=&quot;File to write 32 byte digest into&quot;, type=OutFileType()
1251      )
1252      p = subparsers.add_parser(
1253          &quot;generate_flash_encryption_key&quot;,
1254          help=&quot;Generate a development-use flash encryption key with random data.&quot;,
1255      )
1256      p.add_argument(
1257          &quot;--keylen&quot;,
1258          &quot;-l&quot;,
1259          help=&quot;Length of private key digest file to generate (in bits). &quot;
1260          &quot;3/4 Coding Scheme requires 192 bit key.&quot;,
1261          choices=[128, 192, 256, 512],
1262          default=256,
1263          type=int,
1264      )
1265      p.add_argument(
1266          &quot;key_file&quot;,
1267          help=&quot;File to write 16, 24, 32 or 64 byte key into&quot;,
1268          type=OutFileType(),
1269      )
1270      p = subparsers.add_parser(
1271          &quot;decrypt_flash_data&quot;,
1272          help=&quot;Decrypt some data read from encrypted flash (using known key)&quot;,
1273      )
1274      p.add_argument(
1275          &quot;encrypted_file&quot;,
1276          help=&quot;File with encrypted flash contents&quot;,
1277          type=argparse.FileType(&quot;rb&quot;),
1278      )
1279      p.add_argument(
1280          &quot;--aes_xts&quot;,
1281          &quot;-x&quot;,
1282          help=&quot;Decrypt data using AES-XTS as used on &quot;
1283          &quot;ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6&quot;,
1284          action=&quot;store_true&quot;,
1285      )
1286      p.add_argument(
1287          &quot;--keyfile&quot;,
1288          &quot;-k&quot;,
1289          help=&quot;File with flash encryption key&quot;,
1290          type=argparse.FileType(&quot;rb&quot;),
1291          required=True,
1292      )
1293      p.add_argument(
1294          &quot;--output&quot;,
1295          &quot;-o&quot;,
1296          help=&quot;Output file for plaintext data.&quot;,
1297          type=OutFileType(),
1298          required=True,
1299      )
1300      p.add_argument(
1301          &quot;--address&quot;,
1302          &quot;-a&quot;,
1303          help=&quot;Address offset in flash that file was read from.&quot;,
1304          required=True,
1305          type=esptool.arg_auto_int,
1306      )
1307      p.add_argument(
1308          &quot;--flash_crypt_conf&quot;,
1309          help=&quot;Override FLASH_CRYPT_CONF efuse value (default is 0XF).&quot;,
1310          required=False,
1311          default=0xF,
1312          type=esptool.arg_auto_int,
1313      )
1314      p = subparsers.add_parser(
1315          &quot;encrypt_flash_data&quot;,
1316          help=&quot;Encrypt some data suitable for encrypted flash (using known key)&quot;,
1317      )
1318      p.add_argument(
1319          &quot;--aes_xts&quot;,
1320          &quot;-x&quot;,
1321          help=&quot;Encrypt data using AES-XTS as used on &quot;
1322          &quot;ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6&quot;,
1323          action=&quot;store_true&quot;,
1324      )
1325      p.add_argument(
1326          &quot;--keyfile&quot;,
1327          &quot;-k&quot;,
1328          help=&quot;File with flash encryption key&quot;,
1329          type=argparse.FileType(&quot;rb&quot;),
1330          required=True,
1331      )
1332      p.add_argument(
1333          &quot;--output&quot;,
1334          &quot;-o&quot;,
1335          help=&quot;Output file for encrypted data.&quot;,
1336          type=OutFileType(),
1337          required=True,
1338      )
1339      p.add_argument(
1340          &quot;--address&quot;,
1341          &quot;-a&quot;,
1342          help=&quot;Address offset in flash where file will be flashed.&quot;,
1343          required=True,
1344          type=esptool.arg_auto_int,
1345      )
1346      p.add_argument(
1347          &quot;--flash_crypt_conf&quot;,
1348          help=&quot;Override FLASH_CRYPT_CONF efuse value (default is 0XF).&quot;,
1349          required=False,
1350          default=0xF,
1351          type=esptool.arg_auto_int,
1352      )
1353      p.add_argument(
1354          &quot;plaintext_file&quot;,
1355          help=&quot;File with plaintext content for encrypting&quot;,
1356          type=argparse.FileType(&quot;rb&quot;),
1357      )
1358      args = parser.parse_args(custom_commandline)
1359      print(&quot;espsecure.py v%s&quot; % esptool.__version__)
1360      if args.operation is None:
1361          parser.print_help()
1362          parser.exit(1)
1363      try:
1364          operation_func = globals()[args.operation]
1365          operation_func(args)
1366      finally:
1367          for arg_name in vars(args):
1368              obj = getattr(args, arg_name)
1369              if isinstance(obj, OutFileType):
1370                  obj.close()
1371  def _main():
1372      try:
1373          main()
1374      except esptool.FatalError as e:
1375          print(&quot;\nA fatal error occurred: %s&quot; % e)
1376          sys.exit(2)
1377      except ValueError as e:
1378          try:
1379              if [arg for arg in e.args if &quot;Could not deserialize key data.&quot; in arg]:
1380                  print(
1381                      &quot;Note: This error originates from the cryptography module. &quot;
1382                      &quot;It is likely not a problem with espsecure, &quot;
1383                      &quot;please make sure you are using a compatible OpenSSL backend.&quot;
1384                  )
1385          finally:
1386              raise
1387  if __name__ == &quot;__main__&quot;:
1388      _main()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init__.py</h3>
            <pre><code>1  import argparse
2  import hashlib
3  import operator
4  import os
5  import struct
6  import sys
7  import tempfile
8  import zlib
9  from collections import namedtuple
10  from cryptography import exceptions
11  from cryptography.hazmat.backends import default_backend
12  from cryptography.hazmat.primitives import hashes
13  from cryptography.hazmat.primitives import serialization
14  from cryptography.hazmat.primitives.asymmetric import ec, padding, rsa, utils
15  from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
16  from cryptography.utils import int_to_bytes
17  import ecdsa
18  import esptool
19  SIG_BLOCK_MAGIC = 0xE7
20  SIG_BLOCK_VERSION_RSA = 0x02
21  SIG_BLOCK_VERSION_ECDSA = 0x03
22  CURVE_ID_P192 = 1
23  CURVE_ID_P256 = 2
24  SECTOR_SIZE = 4096
25  SIG_BLOCK_SIZE = (
26      1216  # Refer to secure boot v2 signature block format for more details.
27  )
28  def get_chunks(source, chunk_len):
29      return (source[i : i + chunk_len] for i in range(0, len(source), chunk_len))
30  def endian_swap_words(source):
31      assert len(source) % 4 == 0
32      words = &quot;I&quot; * (len(source) // 4)
33      return struct.pack(&quot;&lt;&quot; + words, *struct.unpack(&quot;&gt;&quot; + words, source))
34  def swap_word_order(source):
35      assert len(source) % 4 == 0
36      words = &quot;I&quot; * (len(source) // 4)
37      return struct.pack(words, *reversed(struct.unpack(words, source)))
38  def _load_hardware_key(keyfile):
39      key = keyfile.read()
40      if len(key) not in [16, 24, 32, 64]:
41          raise esptool.FatalError(
42              &quot;Key file contains wrong length (%d bytes), 16, 24, 32 or 64 expected.&quot;
43              % len(key)
44          )
45      if len(key) == 16:
46          key = _sha256_digest(key)
47          print(&quot;Using 128-bit key (extended)&quot;)
48      elif len(key) == 24:
49          key = key + key[8:16]
50          assert len(key) == 32
51          print(&quot;Using 192-bit key (extended)&quot;)
52      elif len(key) == 32:
53          print(&quot;Using 256-bit key&quot;)
54      else:
55          print(&quot;Using 512-bit key&quot;)
56      return key
57  def digest_secure_bootloader(args):
58      _check_output_is_not_input(args.keyfile, args.output)
59      _check_output_is_not_input(args.image, args.output)
60      _check_output_is_not_input(args.iv, args.output)
61      if args.iv is not None:
62          print(&quot;WARNING: --iv argument is for TESTING PURPOSES ONLY&quot;)
63          iv = args.iv.read(128)
64      else:
65          iv = os.urandom(128)
66      plaintext_image = args.image.read()
67      args.image.seek(0)
68      fw_image = esptool.bin_image.ESP32FirmwareImage(args.image)
69      if fw_image.append_digest:
70          if len(plaintext_image) % 128 &lt;= 32:
71              new_len = len(plaintext_image) - (len(plaintext_image) % 128)
72              plaintext_image = plaintext_image[:new_len]
73      if len(plaintext_image) % 128 != 0:
74          plaintext_image += b&quot;\xFF&quot; * (128 - (len(plaintext_image) % 128))
75      plaintext = iv + plaintext_image
76      key = _load_hardware_key(args.keyfile)
77      backend = default_backend()
78      cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
79      encryptor = cipher.encryptor()
80      digest = hashlib.sha512()
81      for block in get_chunks(plaintext, 16):
82          block = block[::-1]  # reverse each input block
83          cipher_block = encryptor.update(block)
84          cipher_block = cipher_block[::-1]
85          for block in get_chunks(cipher_block, 4):
86              digest.update(block[::-1])
87      if args.output is None:
88          args.output = os.path.splitext(args.image.name)[0] + &quot;-digest-0x0000.bin&quot;
89      with open(args.output, &quot;wb&quot;) as f:
90          f.write(iv)
91          digest = digest.digest()
92          for word in get_chunks(digest, 4):
93              f.write(word[::-1])  # swap word order in the result
94          f.write(b&quot;\xFF&quot; * (0x1000 - f.tell()))  # pad to 0x1000
95          f.write(plaintext_image)
96      print(&quot;digest+image written to %s&quot; % args.output)
97  def _generate_ecdsa_signing_key(curve_id, keyfile):
98      sk = ecdsa.SigningKey.generate(curve=curve_id)
99      with open(keyfile, &quot;wb&quot;) as f:
100          f.write(sk.to_pem())
101  def generate_signing_key(args):
102      if os.path.exists(args.keyfile):
103          raise esptool.FatalError(&quot;ERROR: Key file %s already exists&quot; % args.keyfile)
104      if args.version == &quot;1&quot;:
105          if hasattr(args, &quot;scheme&quot;):
106              if args.scheme != &quot;ecdsa256&quot; and args.scheme is not None:
107                  raise esptool.FatalError(&quot;ERROR: V1 only supports ECDSA256&quot;)
108          _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
109          print(&quot;ECDSA NIST256p private key in PEM format written to %s&quot; % args.keyfile)
110      elif args.version == &quot;2&quot;:
111          if args.scheme == &quot;rsa3072&quot; or args.scheme is None:
112              private_key = rsa.generate_private_key(
113                  public_exponent=65537, key_size=3072, backend=default_backend()
114              ).private_bytes(
115                  encoding=serialization.Encoding.PEM,
116                  format=serialization.PrivateFormat.TraditionalOpenSSL,
117                  encryption_algorithm=serialization.NoEncryption(),
118              )
119              with open(args.keyfile, &quot;wb&quot;) as f:
120                  f.write(private_key)
121              print(&quot;RSA 3072 private key in PEM format written to %s&quot; % args.keyfile)
122          elif args.scheme == &quot;ecdsa192&quot;:
123              _generate_ecdsa_signing_key(ecdsa.NIST192p, args.keyfile)
124              print(
125                  &quot;ECDSA NIST192p private key in PEM format written to %s&quot; % args.keyfile
126              )
127          elif args.scheme == &quot;ecdsa256&quot;:
128              _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
129              print(
130                  &quot;ECDSA NIST256p private key in PEM format written to %s&quot; % args.keyfile
131              )
132          else:
133              raise esptool.FatalError(
134                  &quot;ERROR: Unsupported signing scheme (%s)&quot; % args.scheme
135              )
136  def load_ecdsa_signing_key(keyfile):
137      try:
138          sk = ecdsa.SigningKey.from_pem(keyfile.read())
139      except ValueError:
140          raise esptool.FatalError(
141              &quot;Incorrect ECDSA private key specified. &quot;
142              &quot;Please check algorithm and/or format.&quot;
143          )
144      if sk.curve not in [ecdsa.NIST192p, ecdsa.NIST256p]:
145          raise esptool.FatalError(&quot;Supports NIST192p and NIST256p keys only&quot;)
146      return sk
147  def _load_ecdsa_signing_key(keyfile):
148      sk = load_ecdsa_signing_key(keyfile)
149      if sk.curve != ecdsa.NIST256p:
150          raise esptool.FatalError(
151              &quot;Signing key uses incorrect curve. ESP32 Secure Boot only supports &quot;
152              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&#x27;)&quot;
153          )
154      return sk
155  def _load_ecdsa_verifying_key(keyfile):
156      try:
157          vk = ecdsa.VerifyingKey.from_pem(keyfile.read())
158      except ValueError:
159          raise esptool.FatalError(
160              &quot;Incorrect ECDSA public key specified. &quot;
161              &quot;Please check algorithm and/or format.&quot;
162          )
163      if vk.curve != ecdsa.NIST256p:
164          raise esptool.FatalError(
165              &quot;Signing key uses incorrect curve. ESP32 Secure Boot only supports &quot;
166              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&#x27;)&quot;
167          )
168      return vk
169  def _load_sbv2_signing_key(keydata):
170      sk = serialization.load_pem_private_key(
171          keydata, password=None, backend=default_backend()
172      )
173      if isinstance(sk, rsa.RSAPrivateKey):
174          if sk.key_size != 3072:
175              raise esptool.FatalError(
176                  &quot;Key file has length %d bits. Secure boot v2 only supports RSA-3072.&quot;
177                  % sk.key_size
178              )
179          return sk
180      if isinstance(sk, ec.EllipticCurvePrivateKey):
181          if not (
182              isinstance(sk.curve, ec.SECP192R1) or isinstance(sk.curve, ec.SECP256R1)
183          ):
184              raise esptool.FatalError(
185                  &quot;Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports &quot;
186                  &quot;NIST192p, NIST256p (aka prime192v1, prime256v1)&quot;
187              )
188          return sk
189      raise esptool.FatalError(&quot;Unsupported signing key for Secure Boot V2&quot;)
190  def _load_sbv2_pub_key(keydata):
191      vk = serialization.load_pem_public_key(keydata, backend=default_backend())
192      if isinstance(vk, rsa.RSAPublicKey):
193          if vk.key_size != 3072:
194              raise esptool.FatalError(
195                  &quot;Key file has length %d bits. Secure boot v2 only supports RSA-3072.&quot;
196                  % vk.key_size
197              )
198          return vk
199      if isinstance(vk, ec.EllipticCurvePublicKey):
200          if not (
201              isinstance(vk.curve, ec.SECP192R1) or isinstance(vk.curve, ec.SECP256R1)
202          ):
203              raise esptool.FatalError(
204                  &quot;Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports &quot;
205                  &quot;NIST192p, NIST256p (aka prime192v1, prime256v1)&quot;
206              )
207          return vk
208      raise esptool.FatalError(&quot;Unsupported public key for Secure Boot V2&quot;)
209  def _get_sbv2_pub_key(keyfile):
210      key_data = keyfile.read()
211      if (
212          b&quot;-BEGIN RSA PRIVATE KEY&quot; in key_data
213          or b&quot;-BEGIN EC PRIVATE KEY&quot; in key_data
214          or b&quot;-BEGIN PRIVATE KEY&quot; in key_data
215      ):
216          return _load_sbv2_signing_key(key_data).public_key()
217      elif b&quot;-BEGIN PUBLIC KEY&quot; in key_data:
218          vk = _load_sbv2_pub_key(key_data)
219      else:
220          raise esptool.FatalError(
221              &quot;Verification key does not appear to be an RSA Private or &quot;
222              &quot;Public key in PEM format. Unsupported&quot;
223          )
224      return vk
225  def _get_sbv2_rsa_primitives(public_key):
226      primitives = namedtuple(&quot;primitives&quot;, [&quot;n&quot;, &quot;e&quot;, &quot;m&quot;, &quot;rinv&quot;])
227      numbers = public_key.public_numbers()
228      primitives.n = numbers.n  #
229      primitives.e = numbers.e  # two public key components
230      primitives.m = -rsa._modinv(primitives.n, 1 &lt;&lt; 32)
231      rr = 1 &lt;&lt; (public_key.key_size * 2)
232      primitives.rinv = rr % primitives.n
233      return primitives
234  def _microecc_format(a, b, curve_len):
235      byte_len = int(curve_len / 8)
236      ab = int_to_bytes(a, byte_len)[::-1] + int_to_bytes(b, byte_len)[::-1]
237      assert len(ab) == 48 or len(ab) == 64
238      return ab
239  def sign_data(args):
240      if args.keyfile:
241          _check_output_is_not_input(args.keyfile, args.output)
242      _check_output_is_not_input(args.datafile, args.output)
243      if args.version == &quot;1&quot;:
244          return sign_secure_boot_v1(args)
245      elif args.version == &quot;2&quot;:
246          return sign_secure_boot_v2(args)
247  def sign_secure_boot_v1(args):
248      binary_content = args.datafile.read()
249      if args.hsm:
250          raise esptool.FatalError(
251              &quot;Secure Boot V1 does not support signing using an &quot;
252              &quot;external Hardware Security Module (HSM)&quot;
253          )
254      if args.signature:
255          print(&quot;Pre-calculated signatures found&quot;)
256          if len(args.pub_key) &gt; 1:
257              raise esptool.FatalError(&quot;Secure Boot V1 only supports one signing key&quot;)
258          signature = args.signature[0].read()
259          vk = _load_ecdsa_verifying_key(args.pub_key[0])
260      else:
261          if len(args.keyfile) &gt; 1:
262              raise esptool.FatalError(&quot;Secure Boot V1 only supports one signing key&quot;)
263          sk = _load_ecdsa_signing_key(args.keyfile[0])
264          signature = sk.sign_deterministic(binary_content, hashlib.sha256)
265          vk = sk.get_verifying_key()
266      vk.verify(signature, binary_content, hashlib.sha256)  # throws exception on failure
267      if args.output is None or os.path.abspath(args.output) == os.path.abspath(
268          args.datafile.name
269      ):  # append signature to input file
270          args.datafile.close()
271          outfile = open(args.datafile.name, &quot;ab&quot;)
272      else:  # write file &amp; signature to new file
273          outfile = open(args.output, &quot;wb&quot;)
274          outfile.write(binary_content)
275      outfile.write(
276          struct.pack(&quot;I&quot;, 0)
277      )  # Version indicator, allow for different curves/formats later
278      outfile.write(signature)
279      outfile.close()
280      print(&quot;Signed %d bytes of data from %s&quot; % (len(binary_content), args.datafile.name))
281  def sign_secure_boot_v2(args):
282      SIG_BLOCK_MAX_COUNT = 3
283      contents = args.datafile.read()
284      sig_block_num = 0
285      signature_sector = b&quot;&quot;
286      signature = args.signature
287      pub_key = args.pub_key
288      if len(contents) % SECTOR_SIZE != 0:
289          if args.signature:
290              raise esptool.FatalError(
291                  &quot;Secure Boot V2 requires the signature block to start &quot;
292                  &quot;from a 4KB aligned sector &quot;
293                  &quot;but the datafile supplied is not sector aligned.&quot;
294              )
295          else:
296              pad_by = SECTOR_SIZE - (len(contents) % SECTOR_SIZE)
297              print(
298                  f&quot;Padding data contents by {pad_by} bytes &quot;
299                  &quot;so signature sector aligns at sector boundary&quot;
300              )
301              contents += b&quot;\xff&quot; * pad_by
302      elif args.append_signatures:
303          while sig_block_num &lt; SIG_BLOCK_MAX_COUNT:
304              sig_block = validate_signature_block(contents, sig_block_num)
305              if sig_block is None:
306                  break
307              signature_sector += (
308                  sig_block  # Signature sector is populated with already valid blocks
309              )
310              sig_block_num += 1
311          if len(signature_sector) % SIG_BLOCK_SIZE != 0:
312              raise esptool.FatalError(&quot;Incorrect signature sector size&quot;)
313          if sig_block_num == 0:
314              print(
315                  &quot;No valid signature blocks found. &quot;
316                  &quot;Discarding --append-signature and proceeding to sign the image afresh.&quot;
317              )
318          else:
319              print(
320                  f&quot;{sig_block_num} valid signature block(s) already present &quot;
321                  &quot;in the signature sector.&quot;
322              )
323              if sig_block_num == SIG_BLOCK_MAX_COUNT:
324                  raise esptool.FatalError(
325                      f&quot;Upto {SIG_BLOCK_MAX_COUNT} signature blocks are supported. &quot;
326                      &quot;(For ESP32-ECO3 only 1 signature block is supported)&quot;
327                  )
328              contents = contents[: len(contents) - SECTOR_SIZE]
329      if args.hsm:
330          if args.hsm_config is None:
331              raise esptool.FatalError(
332                  &quot;Config file is required to generate signature using an external HSM.&quot;
333              )
334          import espsecure.esp_hsm_sign as hsm
335          try:
336              config = hsm.read_hsm_config(args.hsm_config)
337          except Exception as e:
338              raise esptool.FatalError(f&quot;Incorrect HSM config file format ({e})&quot;)
339          if pub_key is None:
340              pub_key = extract_pubkey_from_hsm(config)
341          signature = generate_signature_using_hsm(config, contents)
342      if signature:
343          print(&quot;Pre-calculated signatures found&quot;)
344          key_count = len(pub_key)
345          if len(signature) != key_count:
346              raise esptool.FatalError(
347                  f&quot;Number of public keys ({key_count}) not equal to &quot;
348                  f&quot;the number of signatures {len(signature)}.&quot;
349              )
350      else:
351          key_count = len(args.keyfile)
352      empty_signature_blocks = SIG_BLOCK_MAX_COUNT - sig_block_num
353      if key_count &gt; empty_signature_blocks:
354          raise esptool.FatalError(
355              f&quot;Number of keys({key_count}) more than the empty signature blocks.&quot;
356              f&quot;({empty_signature_blocks})&quot;
357          )
358      print(f&quot;{key_count} signing key(s) found.&quot;)
359      digest = hashlib.sha256()
360      digest.update(contents)
361      digest = digest.digest()
362      if signature:
363          signature_block = generate_signature_block_using_pre_calculated_signature(
364              signature, pub_key, digest
365          )
366      else:
367          signature_block = generate_signature_block_using_private_key(
368              args.keyfile, digest
369          )
370      if signature_block is None or len(signature_block) == 0:
371          raise esptool.FatalError(&quot;Signature Block generation failed&quot;)
372      signature_sector += signature_block
373      if (
374          len(signature_sector) &lt; 0
375          and len(signature_sector) &gt; SIG_BLOCK_SIZE * 3
376          and len(signature_sector) % SIG_BLOCK_SIZE != 0
377      ):
378          raise esptool.FatalError(&quot;Incorrect signature sector generation&quot;)
379      total_sig_blocks = len(signature_sector) // SIG_BLOCK_SIZE
380      signature_sector = signature_sector + (
381          b&quot;\xff&quot; * (SECTOR_SIZE - len(signature_sector))
382      )
383      if len(signature_sector) != SECTOR_SIZE:
384          raise esptool.FatalError(&quot;Incorrect signature sector size&quot;)
385      if args.output is None:
386          args.datafile.close()
387          args.output = args.datafile.name
388      with open(args.output, &quot;wb&quot;) as f:
389          f.write(contents + signature_sector)
390      print(
391          f&quot;Signed {len(contents)} bytes of data from {args.datafile.name}. &quot;
392          f&quot;Signature sector now has {total_sig_blocks} signature blocks.&quot;
393      )
394  def generate_signature_using_hsm(config, contents):
395      import espsecure.esp_hsm_sign as hsm
396      session = hsm.establish_session(config)
397      private_key = hsm.get_privkey_info(session, config)
398      signature = hsm.sign_payload(private_key, contents)
399      hsm.close_connection(session)
400      temp_signature_file = tempfile.TemporaryFile()
401      temp_signature_file.write(signature)
402      temp_signature_file.seek(0)
403      return [temp_signature_file]
404  def generate_signature_block_using_pre_calculated_signature(signature, pub_key, digest):
405      signature_blocks = b&quot;&quot;
406      for sig, pk in zip(signature, pub_key):
407          try:
408              public_key = _get_sbv2_pub_key(pk)
409              signature = sig.read()
410              if isinstance(public_key, rsa.RSAPublicKey):
411                  rsa_primitives = _get_sbv2_rsa_primitives(public_key)
412                  public_key.verify(
413                      signature,
414                      digest,
415                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
416                      utils.Prehashed(hashes.SHA256()),
417                  )
418                  signature_block = generate_rsa_signature_block(
419                      digest, rsa_primitives, signature
420                  )
421              else:
422                  numbers = public_key.public_numbers()
423                  if isinstance(numbers.curve, ec.SECP192R1):
424                      curve_len = 192
425                      curve_id = CURVE_ID_P192
426                  elif isinstance(numbers.curve, ec.SECP256R1):
427                      curve_len = 256
428                      curve_id = CURVE_ID_P256
429                  else:
430                      raise esptool.FatalError(&quot;Invalid ECDSA curve instance.&quot;)
431                  public_key.verify(
432                      signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
433                  )
434                  pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
435                  r, s = utils.decode_dss_signature(signature)
436                  signature_rs = _microecc_format(r, s, curve_len)
437                  signature_block = generate_ecdsa_signature_block(
438                      digest, curve_id, pubkey_point, signature_rs
439                  )
440          except exceptions.InvalidSignature:
441              raise esptool.FatalError(
442                  &quot;Signature verification failed: Invalid Signature\n&quot;
443                  &quot;The pre-calculated signature has not been signed &quot;
444                  &quot;using the given public key&quot;
445              )
446          signature_block += struct.pack(&quot;&lt;I&quot;, zlib.crc32(signature_block) &amp; 0xFFFFFFFF)
447          signature_block += b&quot;\x00&quot; * 16  # padding
448          if len(signature_block) != SIG_BLOCK_SIZE:
449              raise esptool.FatalError(&quot;Incorrect signature block size&quot;)
450          signature_blocks += signature_block
451      return signature_blocks
452  def generate_signature_block_using_private_key(keyfiles, digest):
453      signature_blocks = b&quot;&quot;
454      for keyfile in keyfiles:
455          private_key = _load_sbv2_signing_key(keyfile.read())
456          if isinstance(private_key, rsa.RSAPrivateKey):
457              signature = private_key.sign(
458                  digest,
459                  padding.PSS(
460                      mgf=padding.MGF1(hashes.SHA256()),
461                      salt_length=32,
462                  ),
463                  utils.Prehashed(hashes.SHA256()),
464              )
465              rsa_primitives = _get_sbv2_rsa_primitives(private_key.public_key())
466              signature_block = generate_rsa_signature_block(
467                  digest, rsa_primitives, signature
468              )
469          else:
470              signature = private_key.sign(
471                  digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
472              )
473              numbers = private_key.public_key().public_numbers()
474              if isinstance(private_key.curve, ec.SECP192R1):
475                  curve_len = 192
476                  curve_id = CURVE_ID_P192
477              elif isinstance(numbers.curve, ec.SECP256R1):
478                  curve_len = 256
479                  curve_id = CURVE_ID_P256
480              else:
481                  raise esptool.FatalError(&quot;Invalid ECDSA curve instance.&quot;)
482              pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
483              r, s = utils.decode_dss_signature(signature)
484              signature_rs = _microecc_format(r, s, curve_len)
485              signature_block = generate_ecdsa_signature_block(
486                  digest, curve_id, pubkey_point, signature_rs
487              )
488          signature_block += struct.pack(&quot;&lt;I&quot;, zlib.crc32(signature_block) &amp; 0xFFFFFFFF)
489          signature_block += b&quot;\x00&quot; * 16  # padding
490          if len(signature_block) != SIG_BLOCK_SIZE:
491              raise esptool.FatalError(&quot;Incorrect signature block size&quot;)
492          signature_blocks += signature_block
493      return signature_blocks
494  def generate_rsa_signature_block(digest, rsa_primitives, signature):
495      signature_block = struct.pack(
496          &quot;&lt;BBxx32s384sI384sI384s&quot;,
497          SIG_BLOCK_MAGIC,
498          SIG_BLOCK_VERSION_RSA,
499          digest,
500          int_to_bytes(rsa_primitives.n)[::-1],
501          rsa_primitives.e,
502          int_to_bytes(rsa_primitives.rinv)[::-1],
503          rsa_primitives.m &amp; 0xFFFFFFFF,
504          signature[::-1],
505      )
506      return signature_block
507  def generate_ecdsa_signature_block(digest, curve_id, pubkey_point, signature_rs):
508      signature_block = struct.pack(
509          &quot;&lt;BBxx32sB64s64s1031x&quot;,
510          SIG_BLOCK_MAGIC,
511          SIG_BLOCK_VERSION_ECDSA,
512          digest,
513          curve_id,
514          pubkey_point,
515          signature_rs,
516      )
517      return signature_block
518  def verify_signature(args):
519      if args.version == &quot;1&quot;:
520          return verify_signature_v1(args)
521      elif args.version == &quot;2&quot;:
522          return verify_signature_v2(args)
523  def verify_signature_v1(args):
524      key_data = args.keyfile.read()
525      if b&quot;-BEGIN EC PRIVATE KEY&quot; in key_data:
526          sk = ecdsa.SigningKey.from_pem(key_data)
527          vk = sk.get_verifying_key()
528      elif b&quot;-BEGIN PUBLIC KEY&quot; in key_data:
529          vk = ecdsa.VerifyingKey.from_pem(key_data)
530      elif len(key_data) == 64:
531          vk = ecdsa.VerifyingKey.from_string(key_data, curve=ecdsa.NIST256p)
532      else:
533          raise esptool.FatalError(
534              &quot;Verification key does not appear to be an EC key in PEM format &quot;
535              &quot;or binary EC public key data. Unsupported&quot;
536          )
537      if vk.curve != ecdsa.NIST256p:
538          raise esptool.FatalError(
539              &quot;Public key uses incorrect curve. ESP32 Secure Boot only supports &quot;
540              &quot;NIST256p (openssl calls this curve &#x27;prime256v1&quot;
541          )
542      binary_content = args.datafile.read()
543      data = binary_content[0:-68]
544      sig_version, signature = struct.unpack(&quot;I64s&quot;, binary_content[-68:])
545      if sig_version != 0:
546          raise esptool.FatalError(
547              &quot;Signature block has version %d. This version of espsecure &quot;
548              &quot;only supports version 0.&quot; % sig_version
549          )
550      print(&quot;Verifying %d bytes of data&quot; % len(data))
551      try:
552          if vk.verify(signature, data, hashlib.sha256):
553              print(&quot;Signature is valid&quot;)
554          else:
555              raise esptool.FatalError(&quot;Signature is not valid&quot;)
556      except ecdsa.keys.BadSignatureError:
557          raise esptool.FatalError(&quot;Signature is not valid&quot;)
558  def validate_signature_block(image_content, sig_blk_num):
559      offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
560      sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
561      assert len(sig_blk) == SIG_BLOCK_SIZE
562      magic, version, _, _, _, _, _, _, blk_crc = struct.unpack(
563          &quot;&lt;BBxx32s384sI384sI384sI16x&quot;, sig_blk
564      )
565      calc_crc = zlib.crc32(sig_blk[:1196])
566      is_invalid_block = magic != SIG_BLOCK_MAGIC
567      is_invalid_block |= version not in [SIG_BLOCK_VERSION_RSA, SIG_BLOCK_VERSION_ECDSA]
568      if is_invalid_block or blk_crc != calc_crc &amp; 0xFFFFFFFF:  # Signature block invalid
569          return None
570      key_type = &quot;RSA&quot; if version == SIG_BLOCK_VERSION_RSA else &quot;ECDSA&quot;
571      print(f&quot;Signature block {sig_blk_num} is valid ({key_type}).&quot;)
572      return sig_blk
573  def verify_signature_v2(args):
574      keyfile = args.keyfile
575      if args.hsm:
576          if args.hsm_config is None:
577              raise esptool.FatalError(
578                  &quot;Config file is required to extract public key from an external HSM.&quot;
579              )
580          import espsecure.esp_hsm_sign as hsm
581          try:
582              config = hsm.read_hsm_config(args.hsm_config)
583          except Exception as e:
584              raise esptool.FatalError(f&quot;Incorrect HSM config file format ({e})&quot;)
585          keyfile = extract_pubkey_from_hsm(config)[0]
586      vk = _get_sbv2_pub_key(keyfile)
587      if isinstance(vk, rsa.RSAPublicKey):
588          SIG_BLOCK_MAX_COUNT = 3
589      elif isinstance(vk, ec.EllipticCurvePublicKey):
590          SIG_BLOCK_MAX_COUNT = 1
591      image_content = args.datafile.read()
592      if len(image_content) &lt; SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
593          raise esptool.FatalError(
594              &quot;Invalid datafile. Data size should be non-zero &amp; a multiple of 4096.&quot;
595          )
596      digest = digest = hashlib.sha256()
597      digest.update(image_content[:-SECTOR_SIZE])
598      digest = digest.digest()
599      valid = False
600      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
601          sig_blk = validate_signature_block(image_content, sig_blk_num)
602          if sig_blk is None:
603              print(f&quot;Signature block {sig_blk_num} invalid. Skipping.&quot;)
604              continue
605          _, version, blk_digest = struct.unpack(&quot;&lt;BBxx32s&quot;, sig_blk[:36])
606          if blk_digest != digest:
607              raise esptool.FatalError(
608                  &quot;Signature block image digest does not match &quot;
609                  f&quot;the actual image digest {digest}. Expected {blk_digest}.&quot;
610              )
611          try:
612              if isinstance(vk, rsa.RSAPublicKey):
613                  _, _, _, _, signature, _ = struct.unpack(
614                      &quot;&lt;384sI384sI384sI16x&quot;, sig_blk[36:]
615                  )
616                  vk.verify(
617                      signature[::-1],
618                      digest,
619                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
620                      utils.Prehashed(hashes.SHA256()),
621                  )
622              else:
623                  curve_id, _pubkey, encoded_rs = struct.unpack(
624                      &quot;B64s64s1031x4x16x&quot;, sig_blk[36:]
625                  )
626                  assert curve_id in (CURVE_ID_P192, CURVE_ID_P256)
627                  keylen = (
628                      24 if curve_id == CURVE_ID_P192 else 32
629                  )  # length of each number in the keypair
630                  r = int.from_bytes(encoded_rs[:keylen], &quot;little&quot;)
631                  s = int.from_bytes(encoded_rs[keylen : keylen * 2], &quot;little&quot;)
632                  signature = utils.encode_dss_signature(r, s)
633                  vk.verify(signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256())))
634              key_type = &quot;RSA&quot; if isinstance(vk, rsa.RSAPublicKey) else &quot;ECDSA&quot;
635              print(
636                  f&quot;Signature block {sig_blk_num} verification successful using &quot;
637                  f&quot;the supplied key ({key_type}).&quot;
638              )
639              valid = True
640          except exceptions.InvalidSignature:
641              print(
642                  f&quot;Signature block {sig_blk_num} is not signed by the supplied key. &quot;
643                  &quot;Checking the next block&quot;
644              )
645              continue
646      if not valid:
647          raise esptool.FatalError(
648              &quot;Checked all blocks. Signature could not be verified with the provided key.&quot;
649          )
650  def extract_public_key(args):
651      _check_output_is_not_input(args.keyfile, args.public_keyfile)
652      if args.version == &quot;1&quot;:
653          sk = _load_ecdsa_signing_key(args.keyfile)
654          vk = sk.get_verifying_key()
655          args.public_keyfile.write(vk.to_string())
656      elif args.version == &quot;2&quot;:
657          sk = _load_sbv2_signing_key(args.keyfile.read())
658          vk = sk.public_key().public_bytes(
659              encoding=serialization.Encoding.PEM,
660              format=serialization.PublicFormat.SubjectPublicKeyInfo,
661          )
662          args.public_keyfile.write(vk)
663      print(
664          &quot;%s public key extracted to %s&quot; % (args.keyfile.name, args.public_keyfile.name)
665      )
666  def extract_pubkey_from_hsm(config):
667      import espsecure.esp_hsm_sign as hsm
668      session = hsm.establish_session(config)
669      public_key = hsm.get_pubkey(session, config)
670      hsm.close_connection(session)
671      pem = public_key.public_bytes(
672          encoding=serialization.Encoding.PEM,
673          format=serialization.PublicFormat.SubjectPublicKeyInfo,
674      )
675      temp_pub_key_file = tempfile.TemporaryFile()
676      temp_pub_key_file.write(pem)
677      temp_pub_key_file.seek(0)
678      return [temp_pub_key_file]
679  def _sha256_digest(data):
680      digest = hashlib.sha256()
681      digest.update(data)
682      return digest.digest()
683  def signature_info_v2(args):
684      SIG_BLOCK_MAX_COUNT = 3
685      image_content = args.datafile.read()
686      if len(image_content) &lt; SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
687          raise esptool.FatalError(
688              &quot;Invalid datafile. Data size should be non-zero &amp; a multiple of 4096.&quot;
689          )
690      digest = _sha256_digest(image_content[:-SECTOR_SIZE])
691      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
692          sig_blk = validate_signature_block(image_content, sig_blk_num)
693          if sig_blk is None:
694              print(
695                  &quot;Signature block %d absent/invalid. Skipping checking next blocks.&quot;
696                  % sig_blk_num
697              )
698              return
699          sig_data = struct.unpack(&quot;&lt;BBxx32s384sI384sI384sI16x&quot;, sig_blk)
700          if sig_data[2] != digest:
701              raise esptool.FatalError(
702                  &quot;Digest in signature block %d doesn&#x27;t match the image digest.&quot;
703                  % (sig_blk_num)
704              )
705          offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
706          sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
707          if sig_data[1] == SIG_BLOCK_VERSION_RSA:
708              key_digest = _sha256_digest(sig_blk[36:812])
709          elif sig_data[1] == SIG_BLOCK_VERSION_ECDSA:
710              key_digest = _sha256_digest(sig_blk[36:101])
711          else:
712              raise esptool.FatalError(
713                  &quot;Unsupported scheme in signature block %d&quot; % (sig_blk_num)
714              )
715          print(
716              &quot;Public key digest for block %d: %s&quot;
717              % (sig_blk_num, &quot; &quot;.join(&quot;{:02x}&quot;.format(c) for c in bytearray(key_digest)))
718          )
719  def _digest_sbv2_public_key(keyfile):
720      public_key = _get_sbv2_pub_key(keyfile)
721      if isinstance(public_key, rsa.RSAPublicKey):
722          rsa_primitives = _get_sbv2_rsa_primitives(public_key)
723          binary_format = struct.pack(
724              &quot;&lt;384sI384sI&quot;,
<span onclick='openModal()' class='match'>725              int_to_bytes(rsa_primitives.n)[::-1],
726              rsa_primitives.e,
</span>727              int_to_bytes(rsa_primitives.rinv)[::-1],
728              rsa_primitives.m &amp; 0xFFFFFFFF,
729          )
730      else:  # ECC public key
731          numbers = public_key.public_numbers()
732          if isinstance(public_key.curve, ec.SECP192R1):
733              curve_len = 192
734              curve_id = CURVE_ID_P192
735          else:
736              curve_len = 256
737              curve_id = CURVE_ID_P256
738          pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
739          binary_format = struct.pack(
740              &quot;&lt;B64s&quot;,
741              curve_id,
742              pubkey_point,
743          )
744      return hashlib.sha256(binary_format).digest()
745  def digest_sbv2_public_key(args):
746      _check_output_is_not_input(args.keyfile, args.output)
747      public_key_digest = _digest_sbv2_public_key(args.keyfile)
748      with open(args.output, &quot;wb&quot;) as f:
749          print(
750              &quot;Writing the public key digest of %s to %s.&quot;
751              % (args.keyfile.name, args.output)
752          )
753          f.write(public_key_digest)
754  def digest_rsa_public_key(args):
755      digest_sbv2_public_key(args)
756  def digest_private_key(args):
757      _check_output_is_not_input(args.keyfile, args.digest_file)
758      sk = _load_ecdsa_signing_key(args.keyfile)
759      repr(sk.to_string())
760      digest = hashlib.sha256()
761      digest.update(sk.to_string())
762      result = digest.digest()
763      if args.keylen == 192:
764          result = result[0:24]
765      args.digest_file.write(result)
766      print(
767          &quot;SHA-256 digest of private key %s%s written to %s&quot;
768          % (
769              args.keyfile.name,
770              &quot;&quot; if args.keylen == 256 else &quot; (truncated to 192 bits)&quot;,
771              args.digest_file.name,
772          )
773      )
774  _FLASH_ENCRYPTION_TWEAK_PATTERN = [
775      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
776      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
777      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
778      14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
779      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
780      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
781      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
782      12, 11, 10, 9, 8, 7, 6, 5,
783      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
784      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
785      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
786      10, 9, 8, 7, 6, 5,
787      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
788      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
789      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
790      8, 7, 6, 5
791  ]
792  assert len(_FLASH_ENCRYPTION_TWEAK_PATTERN) == 256
793  def _flash_encryption_tweak_range(flash_crypt_config=0xF):
794      tweak_range = []
795      if (flash_crypt_config &amp; 1) != 0:
796          tweak_range += range(67)
797      if (flash_crypt_config &amp; 2) != 0:
798          tweak_range += range(67, 132)
799      if (flash_crypt_config &amp; 4) != 0:
800          tweak_range += range(132, 195)
801      if (flash_crypt_config &amp; 8) != 0:
802          tweak_range += range(195, 256)
803      return tweak_range
804  def _flash_encryption_tweak_range_bits(flash_crypt_config=0xF):
805      tweak_range = 0
806      if (flash_crypt_config &amp; 1) != 0:
807          tweak_range |= (
808              0xFFFFFFFFFFFFFFFFE00000000000000000000000000000000000000000000000
809          )
810      if (flash_crypt_config &amp; 2) != 0:
811          tweak_range |= (
812              0x00000000000000001FFFFFFFFFFFFFFFF0000000000000000000000000000000
813          )
814      if (flash_crypt_config &amp; 4) != 0:
815          tweak_range |= (
816              0x000000000000000000000000000000000FFFFFFFFFFFFFFFE000000000000000
817          )
818      if (flash_crypt_config &amp; 8) != 0:
819          tweak_range |= (
820              0x0000000000000000000000000000000000000000000000001FFFFFFFFFFFFFFF
821          )
822      return tweak_range
823  mul1 = 0x0000200004000080000004000080001000000200004000080000040000800010
824  mul2 = 0x0000000000000000200000000000000010000000000000002000000000000001
825  mul1_mask = 0xFFFFFFFFFFFFFF801FFFFFFFFFFFFFF00FFFFFFFFFFFFFF81FFFFFFFFFFFFFF0
826  mul2_mask = 0x000000000000007FE00000000000000FF000000000000007E00000000000000F
827  def _flash_encryption_tweak_key(key, offset, tweak_range):
828      addr = offset &gt;&gt; 5
829      key ^= ((mul1 * addr) | ((mul2 * addr) &amp; mul2_mask)) &amp; tweak_range
830      return int.to_bytes(key, length=32, byteorder=&quot;big&quot;, signed=False)
831  def generate_flash_encryption_key(args):
832      print(&quot;Writing %d random bits to key file %s&quot; % (args.keylen, args.key_file.name))
833      args.key_file.write(os.urandom(args.keylen // 8))
834  def _flash_encryption_operation_esp32(
835      output_file, input_file, flash_address, keyfile, flash_crypt_conf, do_decrypt
836  ):
837      key = _load_hardware_key(keyfile)
838      if flash_address % 16 != 0:
839          raise esptool.FatalError(
840              &quot;Starting flash address 0x%x must be a multiple of 16&quot; % flash_address
841          )
842      if flash_crypt_conf == 0:
843          print(&quot;WARNING: Setting FLASH_CRYPT_CONF to zero is not recommended&quot;)
844      tweak_range = _flash_encryption_tweak_range_bits(flash_crypt_conf)
845      key = int.from_bytes(key, byteorder=&quot;big&quot;, signed=False)
846      backend = default_backend()
847      cipher = None
848      block_offs = flash_address
849      while True:
850          block = input_file.read(16)
851          if len(block) == 0:
852              break
853          elif len(block) &lt; 16:
854              if do_decrypt:
855                  raise esptool.FatalError(&quot;Data length is not a multiple of 16 bytes&quot;)
856              pad = 16 - len(block)
857              block = block + os.urandom(pad)
858              print(
859                  &quot;Note: Padding with %d bytes of random data &quot;
860                  &quot;(encrypted data must be multiple of 16 bytes long)&quot; % pad
861              )
862          if block_offs % 32 == 0 or cipher is None:
863              block_key = _flash_encryption_tweak_key(key, block_offs, tweak_range)
864              if cipher is None:  # first pass
865                  cipher = Cipher(algorithms.AES(block_key), modes.ECB(), backend=backend)
866                  actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
867              else:
868                  try:
869                      backend = actor._ctx._backend
870                      res = backend._lib.EVP_CipherInit_ex(
871                          actor._ctx._ctx,
872                          backend._ffi.NULL,
873                          backend._ffi.NULL,
874                          backend._ffi.from_buffer(block_key),
875                          backend._ffi.NULL,
876                          actor._ctx._operation,
877                      )
878                      backend.openssl_assert(res != 0)
879                  except AttributeError:
880                      cipher.algorithm.key = block_key
881                      actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
882          block = block[::-1]  # reverse input block byte order
883          block = actor.update(block)
884          output_file.write(block[::-1])  # reverse output block byte order
885          block_offs += 16
886  def _flash_encryption_operation_aes_xts(
887      output_file, input_file, flash_address, keyfile, do_decrypt
888  ):
889      backend = default_backend()
890      key = _load_hardware_key(keyfile)
891      indata = input_file.read()
892      if flash_address % 16 != 0:
893          raise esptool.FatalError(
894              &quot;Starting flash address 0x%x must be a multiple of 16&quot; % flash_address
895          )
896      if len(indata) % 16 != 0:
897          raise esptool.FatalError(
898              &quot;Input data length (%d) must be a multiple of 16&quot; % len(indata)
899          )
900      if len(indata) == 0:
901          raise esptool.FatalError(&quot;Input data must be longer than 0&quot;)
902      pad_left = flash_address % 0x80
903      indata = (b&quot;\x00&quot; * pad_left) + indata
904      pad_right = len(indata) % 0x80
905      if pad_right &gt; 0:
906          pad_right = 0x80 - pad_right
907      indata = indata + (b&quot;\x00&quot; * pad_right)
908      inblocks = _split_blocks(indata, 0x80)  # split into 1024 bit blocks
909      output = []
910      for inblock in inblocks:  # for each block
911          tweak = struct.pack(&quot;&lt;I&quot;, (flash_address &amp; ~0x7F)) + (b&quot;\x00&quot; * 12)
912          flash_address += 0x80  # for next block
913          if len(tweak) != 16:
914              raise esptool.FatalError(
915                  &quot;Length of tweak must be 16, was {}&quot;.format(len(tweak))
916              )
917          cipher = Cipher(algorithms.AES(key), modes.XTS(tweak), backend=backend)
918          encryptor = cipher.decryptor() if do_decrypt else cipher.encryptor()
919          inblock = inblock[::-1]  # reverse input
920          outblock = encryptor.update(inblock)  # standard algo
921          output.append(outblock[::-1])  # reverse output
922      output = b&quot;&quot;.join(output)
923      if pad_right != 0:
924          output = output[:-pad_right]
925      if pad_left != 0:
926          output = output[pad_left:]
927      if len(output) != len(indata) - pad_left - pad_right:
928          raise esptool.FatalError(
929              &quot;Length of input data ({}) should match the output data ({})&quot;.format(
930                  len(indata) - pad_left - pad_right, len(output)
931              )
932          )
933      output_file.write(output)
934  def _split_blocks(text, block_len=16):
935      assert len(text) % block_len == 0
936      pos = 0
937      while pos &lt; len(text):
938          yield text[pos : pos + block_len]
939          pos = pos + block_len
940  def decrypt_flash_data(args):
941      _check_output_is_not_input(args.keyfile, args.output)
942      _check_output_is_not_input(args.encrypted_file, args.output)
943      if args.aes_xts:
944          return _flash_encryption_operation_aes_xts(
945              args.output, args.encrypted_file, args.address, args.keyfile, True
946          )
947      else:
948          return _flash_encryption_operation_esp32(
949              args.output,
950              args.encrypted_file,
951              args.address,
952              args.keyfile,
953              args.flash_crypt_conf,
954              True,
955          )
956  def encrypt_flash_data(args):
957      _check_output_is_not_input(args.keyfile, args.output)
958      _check_output_is_not_input(args.plaintext_file, args.output)
959      if args.aes_xts:
960          return _flash_encryption_operation_aes_xts(
961              args.output, args.plaintext_file, args.address, args.keyfile, False
962          )
963      else:
964          return _flash_encryption_operation_esp32(
965              args.output,
966              args.plaintext_file,
967              args.address,
968              args.keyfile,
969              args.flash_crypt_conf,
970              False,
971          )
972  def _samefile(p1, p2):
973      return os.path.normcase(os.path.normpath(p1)) == os.path.normcase(
974          os.path.normpath(p2)
975      )
976  def _check_output_is_not_input(input_file, output_file):
977      i = getattr(input_file, &quot;name&quot;, input_file)
978      o = getattr(output_file, &quot;name&quot;, output_file)
979      check_f = _samefile if isinstance(i, str) and isinstance(o, str) else operator.eq
980      if check_f(i, o):
981          raise esptool.FatalError(
982              &#x27;The input &quot;{}&quot; and output &quot;{}&quot; should not be the same!&#x27;.format(i, o)
983          )
984  class OutFileType(object):
985      def __init__(self):
986          self.path = None
987          self.file_obj = None
988      def __call__(self, path):
989          self.path = path
990          return self
991      def __repr__(self):
992          return &quot;{}({})&quot;.format(type(self).__name__, self.path)
993      def write(self, payload):
994          if len(payload) &gt; 0:
995              if not self.file_obj:
996                  self.file_obj = open(self.path, &quot;wb&quot;)
997              self.file_obj.write(payload)
998      def close(self):
999          if self.file_obj:
1000              self.file_obj.close()
1001              self.file_obj = None
1002      @property
1003      def name(self):
1004          return self.path
1005  def main(custom_commandline=None):
1006      parser = argparse.ArgumentParser(
1007          description=&quot;espsecure.py v%s - ESP32 Secure Boot &amp; Flash Encryption tool&quot;
1008          % esptool.__version__,
1009          prog=&quot;espsecure&quot;,
1010      )
1011      subparsers = parser.add_subparsers(
1012          dest=&quot;operation&quot;, help=&quot;Run espsecure.py {command} -h for additional help&quot;
1013      )
1014      p = subparsers.add_parser(
1015          &quot;digest_secure_bootloader&quot;,
1016          help=&quot;Take a bootloader binary image and a secure boot key, &quot;
1017          &quot;and output a combined digest+binary suitable for flashing along &quot;
1018          &quot;with the precalculated secure boot key.&quot;,
1019      )
1020      p.add_argument(
1021          &quot;--keyfile&quot;,
1022          &quot;-k&quot;,
1023          help=&quot;256 bit key for secure boot digest.&quot;,
1024          type=argparse.FileType(&quot;rb&quot;),
1025          required=True,
1026      )
1027      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for signed digest image.&quot;)
1028      p.add_argument(
1029          &quot;--iv&quot;,
1030          help=&quot;128 byte IV file. Supply a file for testing purposes only, &quot;
1031          &quot;if not supplied an IV will be randomly generated.&quot;,
1032          type=argparse.FileType(&quot;rb&quot;),
1033      )
1034      p.add_argument(
1035          &quot;image&quot;,
1036          help=&quot;Bootloader image file to calculate digest from&quot;,
1037          type=argparse.FileType(&quot;rb&quot;),
1038      )
1039      p = subparsers.add_parser(
1040          &quot;generate_signing_key&quot;,
1041          help=&quot;Generate a private key for signing secure boot images &quot;
1042          &quot;as per the secure boot version. &quot;
1043          &quot;Key file is generated in PEM format, &quot;
1044          &quot;Secure Boot V1 - ECDSA NIST256p private key. &quot;
1045          &quot;Secure Boot V2 - RSA 3072, ECDSA NIST256p, ECDSA NIST192p private key.&quot;,
1046      )
1047      p.add_argument(
1048          &quot;--version&quot;,
1049          &quot;-v&quot;,
1050          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1051          choices=[&quot;1&quot;, &quot;2&quot;],
1052          default=&quot;1&quot;,
1053      )
1054      p.add_argument(
1055          &quot;--scheme&quot;,
1056          &quot;-s&quot;,
1057          help=&quot;Scheme of secure boot signing.&quot;,
1058          choices=[&quot;rsa3072&quot;, &quot;ecdsa192&quot;, &quot;ecdsa256&quot;],
1059          required=False,
1060      )
1061      p.add_argument(
1062          &quot;keyfile&quot;, help=&quot;Filename for private key file (embedded public key)&quot;
1063      )
1064      p = subparsers.add_parser(
1065          &quot;sign_data&quot;,
1066          help=&quot;Sign a data file for use with secure boot. &quot;
1067          &quot;Signing algorithm is deterministic ECDSA w/ SHA-512 (V1) &quot;
1068          &quot;or either RSA-PSS or ECDSA w/ SHA-256 (V2).&quot;,
1069      )
1070      p.add_argument(
1071          &quot;--version&quot;,
1072          &quot;-v&quot;,
1073          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1074          choices=[&quot;1&quot;, &quot;2&quot;],
1075          required=True,
1076      )
1077      p.add_argument(
1078          &quot;--keyfile&quot;,
1079          &quot;-k&quot;,
1080          help=&quot;Private key file for signing. Key is in PEM format.&quot;,
1081          type=argparse.FileType(&quot;rb&quot;),
1082          nargs=&quot;+&quot;,
1083      )
1084      p.add_argument(
1085          &quot;--append_signatures&quot;,
1086          &quot;-a&quot;,
1087          help=&quot;Append signature block(s) to already signed image. &quot;
1088          &quot;Valid only for ESP32-S2.&quot;,
1089          action=&quot;store_true&quot;,
1090      )
1091      p.add_argument(
1092          &quot;--hsm&quot;,
1093          help=&quot;Use an external Hardware Security Module &quot;
1094          &quot;to generate signature using PKCS#11 interface.&quot;,
1095          action=&quot;store_true&quot;,
1096      )
1097      p.add_argument(
1098          &quot;--hsm-config&quot;,
1099          help=&quot;Config file for the external Hardware Security Module &quot;
1100          &quot;to be used to generate signature.&quot;,
1101          default=None,
1102      )
1103      p.add_argument(
1104          &quot;--pub-key&quot;,
1105          help=&quot;Public key files corresponding to the private key used to generate &quot;
1106          &quot;the pre-calculated signatures. Keys should be in PEM format.&quot;,
1107          type=argparse.FileType(&quot;rb&quot;),
1108          nargs=&quot;+&quot;,
1109      )
1110      p.add_argument(
1111          &quot;--signature&quot;,
1112          help=&quot;Pre-calculated signatures. &quot;
1113          &quot;Signatures generated using external private keys e.g. keys stored in HSM.&quot;,
1114          type=argparse.FileType(&quot;rb&quot;),
1115          nargs=&quot;+&quot;,
1116          default=None,
1117      )
1118      p.add_argument(
1119          &quot;--output&quot;,
1120          &quot;-o&quot;,
1121          help=&quot;Output file for signed digest image. Default is to sign the input file.&quot;,
1122      )
1123      p.add_argument(
1124          &quot;datafile&quot;,
1125          help=&quot;File to sign. For version 1, this can be any file. &quot;
1126          &quot;For version 2, this must be a valid app image.&quot;,
1127          type=argparse.FileType(&quot;rb&quot;),
1128      )
1129      p = subparsers.add_parser(
1130          &quot;verify_signature&quot;,
1131          help=&#x27;Verify a data file previously signed by &quot;sign_data&quot;, &#x27;
1132          &quot;using the public key.&quot;,
1133      )
1134      p.add_argument(
1135          &quot;--version&quot;,
1136          &quot;-v&quot;,
1137          help=&quot;Version of the secure boot scheme to use.&quot;,
1138          choices=[&quot;1&quot;, &quot;2&quot;],
1139          required=True,
1140      )
1141      p.add_argument(
1142          &quot;--hsm&quot;,
1143          help=&quot;Use an external Hardware Security Module &quot;
1144          &quot;to verify signature using PKCS#11 interface.&quot;,
1145          action=&quot;store_true&quot;,
1146      )
1147      p.add_argument(
1148          &quot;--hsm-config&quot;,
1149          help=&quot;Config file for the external Hardware Security Module &quot;
1150          &quot;to be used to verify signature.&quot;,
1151          default=None,
1152      )
1153      p.add_argument(
1154          &quot;--keyfile&quot;,
1155          &quot;-k&quot;,
1156          help=&quot;Public key file for verification. &quot;
1157          &quot;Can be private or public key in PEM format.&quot;,
1158          type=argparse.FileType(&quot;rb&quot;),
1159      )
1160      p.add_argument(
1161          &quot;datafile&quot;,
1162          help=&quot;Signed data file to verify signature.&quot;,
1163          type=argparse.FileType(&quot;rb&quot;),
1164      )
1165      p = subparsers.add_parser(
1166          &quot;extract_public_key&quot;,
1167          help=&quot;Extract the public verification key for signatures, &quot;
1168          &quot;save it as a raw binary file.&quot;,
1169      )
1170      p.add_argument(
1171          &quot;--version&quot;,
1172          &quot;-v&quot;,
1173          help=&quot;Version of the secure boot signing scheme to use.&quot;,
1174          choices=[&quot;1&quot;, &quot;2&quot;],
1175          default=&quot;1&quot;,
1176      )
1177      p.add_argument(
1178          &quot;--keyfile&quot;,
1179          &quot;-k&quot;,
1180          help=&quot;Private key file (PEM format) to extract the &quot;
1181          &quot;public verification key from.&quot;,
1182          type=argparse.FileType(&quot;rb&quot;),
1183          required=True,
1184      )
1185      p.add_argument(
1186          &quot;public_keyfile&quot;, help=&quot;File to save new public key into&quot;, type=OutFileType()
1187      )
1188      p = subparsers.add_parser(
1189          &quot;digest_rsa_public_key&quot;,
1190          help=&quot;Generate an SHA-256 digest of the RSA public key. &quot;
1191          &quot;This digest is burned into the eFuse and asserts the legitimacy &quot;
1192          &quot;of the public key for Secure boot v2.&quot;,
1193      )
1194      p.add_argument(
1195          &quot;--keyfile&quot;,
1196          &quot;-k&quot;,
1197          help=&quot;Public key file for verification. &quot;
1198          &quot;Can be private or public key in PEM format.&quot;,
1199          type=argparse.FileType(&quot;rb&quot;),
1200          required=True,
1201      )
1202      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for the digest.&quot;, required=True)
1203      p = subparsers.add_parser(
1204          &quot;digest_sbv2_public_key&quot;,
1205          help=&quot;Generate an SHA-256 digest of the public key. &quot;
1206          &quot;This digest is burned into the eFuse and asserts the legitimacy &quot;
1207          &quot;of the public key for Secure boot v2.&quot;,
1208      )
1209      p.add_argument(
1210          &quot;--keyfile&quot;,
1211          &quot;-k&quot;,
1212          help=&quot;Public key file for verification. &quot;
1213          &quot;Can be private or public key in PEM format.&quot;,
1214          type=argparse.FileType(&quot;rb&quot;),
1215          required=True,
1216      )
1217      p.add_argument(&quot;--output&quot;, &quot;-o&quot;, help=&quot;Output file for the digest.&quot;, required=True)
1218      p = subparsers.add_parser(
1219          &quot;signature_info_v2&quot;,
1220          help=&quot;Reads the signature block and provides the signature block information.&quot;,
1221      )
1222      p.add_argument(
1223          &quot;datafile&quot;,
1224          help=&quot;Secure boot v2 signed data file.&quot;,
1225          type=argparse.FileType(&quot;rb&quot;),
1226      )
1227      p = subparsers.add_parser(
1228          &quot;digest_private_key&quot;,
1229          help=&quot;Generate an SHA-256 digest of the private signing key. &quot;
1230          &quot;This can be used as a reproducible secure bootloader (only secure boot v1) &quot;
1231          &quot;or flash encryption key.&quot;,
1232      )
1233      p.add_argument(
1234          &quot;--keyfile&quot;,
1235          &quot;-k&quot;,
1236          help=&quot;Private key file (PEM format) to generate a digest from.&quot;,
1237          type=argparse.FileType(&quot;rb&quot;),
1238          required=True,
1239      )
1240      p.add_argument(
1241          &quot;--keylen&quot;,
1242          &quot;-l&quot;,
1243          help=&quot;Length of private key digest file to generate (in bits). &quot;
1244          &quot;3/4 Coding Scheme requires 192 bit key.&quot;,
1245          choices=[192, 256],
1246          default=256,
1247          type=int,
1248      )
1249      p.add_argument(
1250          &quot;digest_file&quot;, help=&quot;File to write 32 byte digest into&quot;, type=OutFileType()
1251      )
1252      p = subparsers.add_parser(
1253          &quot;generate_flash_encryption_key&quot;,
1254          help=&quot;Generate a development-use flash encryption key with random data.&quot;,
1255      )
1256      p.add_argument(
1257          &quot;--keylen&quot;,
1258          &quot;-l&quot;,
1259          help=&quot;Length of private key digest file to generate (in bits). &quot;
1260          &quot;3/4 Coding Scheme requires 192 bit key.&quot;,
1261          choices=[128, 192, 256, 512],
1262          default=256,
1263          type=int,
1264      )
1265      p.add_argument(
1266          &quot;key_file&quot;,
1267          help=&quot;File to write 16, 24, 32 or 64 byte key into&quot;,
1268          type=OutFileType(),
1269      )
1270      p = subparsers.add_parser(
1271          &quot;decrypt_flash_data&quot;,
1272          help=&quot;Decrypt some data read from encrypted flash (using known key)&quot;,
1273      )
1274      p.add_argument(
1275          &quot;encrypted_file&quot;,
1276          help=&quot;File with encrypted flash contents&quot;,
1277          type=argparse.FileType(&quot;rb&quot;),
1278      )
1279      p.add_argument(
1280          &quot;--aes_xts&quot;,
1281          &quot;-x&quot;,
1282          help=&quot;Decrypt data using AES-XTS as used on &quot;
1283          &quot;ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6&quot;,
1284          action=&quot;store_true&quot;,
1285      )
1286      p.add_argument(
1287          &quot;--keyfile&quot;,
1288          &quot;-k&quot;,
1289          help=&quot;File with flash encryption key&quot;,
1290          type=argparse.FileType(&quot;rb&quot;),
1291          required=True,
1292      )
1293      p.add_argument(
1294          &quot;--output&quot;,
1295          &quot;-o&quot;,
1296          help=&quot;Output file for plaintext data.&quot;,
1297          type=OutFileType(),
1298          required=True,
1299      )
1300      p.add_argument(
1301          &quot;--address&quot;,
1302          &quot;-a&quot;,
1303          help=&quot;Address offset in flash that file was read from.&quot;,
1304          required=True,
1305          type=esptool.arg_auto_int,
1306      )
1307      p.add_argument(
1308          &quot;--flash_crypt_conf&quot;,
1309          help=&quot;Override FLASH_CRYPT_CONF efuse value (default is 0XF).&quot;,
1310          required=False,
1311          default=0xF,
1312          type=esptool.arg_auto_int,
1313      )
1314      p = subparsers.add_parser(
1315          &quot;encrypt_flash_data&quot;,
1316          help=&quot;Encrypt some data suitable for encrypted flash (using known key)&quot;,
1317      )
1318      p.add_argument(
1319          &quot;--aes_xts&quot;,
1320          &quot;-x&quot;,
1321          help=&quot;Encrypt data using AES-XTS as used on &quot;
1322          &quot;ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6&quot;,
1323          action=&quot;store_true&quot;,
1324      )
1325      p.add_argument(
1326          &quot;--keyfile&quot;,
1327          &quot;-k&quot;,
1328          help=&quot;File with flash encryption key&quot;,
1329          type=argparse.FileType(&quot;rb&quot;),
1330          required=True,
1331      )
1332      p.add_argument(
1333          &quot;--output&quot;,
1334          &quot;-o&quot;,
1335          help=&quot;Output file for encrypted data.&quot;,
1336          type=OutFileType(),
1337          required=True,
1338      )
1339      p.add_argument(
1340          &quot;--address&quot;,
1341          &quot;-a&quot;,
1342          help=&quot;Address offset in flash where file will be flashed.&quot;,
1343          required=True,
1344          type=esptool.arg_auto_int,
1345      )
1346      p.add_argument(
1347          &quot;--flash_crypt_conf&quot;,
1348          help=&quot;Override FLASH_CRYPT_CONF efuse value (default is 0XF).&quot;,
1349          required=False,
1350          default=0xF,
1351          type=esptool.arg_auto_int,
1352      )
1353      p.add_argument(
1354          &quot;plaintext_file&quot;,
1355          help=&quot;File with plaintext content for encrypting&quot;,
1356          type=argparse.FileType(&quot;rb&quot;),
1357      )
1358      args = parser.parse_args(custom_commandline)
1359      print(&quot;espsecure.py v%s&quot; % esptool.__version__)
1360      if args.operation is None:
1361          parser.print_help()
1362          parser.exit(1)
1363      try:
1364          operation_func = globals()[args.operation]
1365          operation_func(args)
1366      finally:
1367          for arg_name in vars(args):
1368              obj = getattr(args, arg_name)
1369              if isinstance(obj, OutFileType):
1370                  obj.close()
1371  def _main():
1372      try:
1373          main()
1374      except esptool.FatalError as e:
1375          print(&quot;\nA fatal error occurred: %s&quot; % e)
1376          sys.exit(2)
1377      except ValueError as e:
1378          try:
1379              if [arg for arg in e.args if &quot;Could not deserialize key data.&quot; in arg]:
1380                  print(
1381                      &quot;Note: This error originates from the cryptography module. &quot;
1382                      &quot;It is likely not a problem with espsecure, &quot;
1383                      &quot;please make sure you are using a compatible OpenSSL backend.&quot;
1384                  )
1385          finally:
1386              raise
1387  if __name__ == &quot;__main__&quot;:
1388      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init__.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init__.py</div>
                </div>
                <div class="column column_space"><pre><code>500          int_to_bytes(rsa_primitives.n)[::-1],
501          rsa_primitives.e,
</pre></code></div>
                <div class="column column_space"><pre><code>725              int_to_bytes(rsa_primitives.n)[::-1],
726              rsa_primitives.e,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    